context,reference_code,input_generator,io_pairs
"In a recent project, you are tasked with generating all possible arrangements of distinct integers representing various configurations of product features. Given a list of distinct integers, how can you determine all the unique permutations of these integers? What unique arrangements can be produced from the input variable `nums`? Please return all the possible permutations in the form of a list of lists.

The input and output requirements are as follows:

Input:
  `nums` (List[int]): A list of distinct integers for which all possible permutations are to be generated.

Output:
  `return` (List[List[int]]): A list of lists, where each inner list represents a unique permutation of the input list.","# import necessary packages
from typing import List

# all class and function definitions in the code file, if any
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        result = []
        if len(nums) == 1:
            return [[nums[0]]]

        for i in range(len(nums)):
            v = nums.pop(0)
            combinations = self.permute(nums)
            for j in range(len(combinations)):
                combinations[j].append(v)
            result.extend(combinations)
            nums.append(v)

        return result

# main function
def main_solution(nums: List[int]) -> List[List[int]]:
    # Validate input
    if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums):
        raise ValueError(""Input must be a list of integers."")
    
    # Create an instance of Solution and call the permute method
    solution_instance = Solution()
    result = solution_instance.permute(nums)
    
    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)
    return result","import random

def input_generator():
    # Generate a random list of distinct integers
    nums = random.sample(range(-10, 10), k=random.randint(1, 6))  # Random length between 1 and 6
    return {""nums"": nums}","[{'input': {'nums': [-6]}, 'output': [[-6]]}, {'input': {'nums': [0, -1, -3]}, 'output': [[-3, -1, 0], [-1, -3, 0], [0, -3, -1], [-3, 0, -1], [-1, 0, -3], [0, -1, -3]]}, {'input': {'nums': [-10]}, 'output': [[-10]]}, {'input': {'nums': [-5, 9]}, 'output': [[9, -5], [-5, 9]]}, {'input': {'nums': [-2, -9]}, 'output': [[-9, -2], [-2, -9]]}]"
"In a certain scenario, you are tasked with identifying unique sets of three items from a collection of integers that, when combined, yield a total sum of zero. Given a list of integers named `nums`, what unique triplets can be found that satisfy this condition, ensuring that no duplicate combinations are included in the final result?

The input and output requirements are as follows:

Input:
  `nums` (List[int]): A list of integers to find unique triplets that sum up to zero.

Output:
  `return` (List[List[int]]): A list of unique triplets, where each triplet is a list of three integers that sum to zero.","# import necessary packages
from typing import List

# all class and function definitions in the code file, if any
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        ans = []
        nums.sort()
        if not nums or nums[0] > 0 or nums[len(nums) - 1] < 0:
            return []
        for a in range(len(nums) - 2):
            if nums[a] > 0:
                break
            if a > 0 and nums[a] == nums[a - 1]:
                continue
            i, j = a + 1, len(nums) - 1
            while i < j:
                val = nums[a] + nums[i] + nums[j]
                if val < 0:
                    i += 1
                elif val > 0:
                    j -= 1
                else:
                    ans.append([nums[a], nums[i], nums[j]])
                    while i < j and nums[i] == nums[i + 1]:
                        i += 1
                    while i < j and nums[j] == nums[j - 1]:
                        j -= 1
                    i += 1
                    j -= 1
        return ans

# main function
def main_solution(nums):
    # Convert input to list of integers
    nums = list(map(int, nums))  
    # Initialize the Solution class
    solution = Solution()
    # Call the threeSum method and get the result
    result = solution.threeSum(nums)
    # Convert result to JSON serializable format
    return [list(triplet) for triplet in result]","import random

def input_generator():
    # Generate a random list of integers
    nums = random.sample(range(-10, 11), random.randint(3, 10))  # Random length between 3 and 10
    return {""nums"": nums}","[{'input': {'nums': [-6, 5, 8]}, 'output': []}, {'input': {'nums': [8, 0, -5, -9, -10]}, 'output': []}, {'input': {'nums': [0, 8, -3, 7]}, 'output': []}, {'input': {'nums': [-4, 3, -8, -2]}, 'output': []}, {'input': {'nums': [5, -3, -4, 9, -10, 3, -2, -9, -6]}, 'output': [[-6, -3, 9], [-3, -2, 5]]}]"
"In a busy sorting center, an unsorted array of integers is delivered for sorting. Each integer represents an item that needs to be organized in ascending order to streamline the sorting process. Given an `unsorted_array`, can you determine what the final sorted order of the items will be after applying the quicksort algorithm? Please return the sorted array.

The input and output requirements are as follows:

Input:
  `unsorted_array` (list): A list of integers that need to be sorted.

Output:
  `return` (list): A sorted list of integers in ascending order.","# import necessary packages
import json

# all class and function definitions in the code file
class QuickSort(object):
    """"""Quicksort implementation""""""

    def __init__(self, unsorted_array):
        """"""Initialize an array for quicksort""""""
        self.array_to_sort = unsorted_array
        self.is_sorted = False

    def swap(self, swap_x, swap_y):
        """"""Swap two elements of an array""""""
        tmp = self.array_to_sort[swap_x]
        self.array_to_sort[swap_x] = self.array_to_sort[swap_y]
        self.array_to_sort[swap_y] = tmp

    def partition(self, lo_index, hi_index):
        """"""Partition the array""""""        
        pivot = self.array_to_sort[hi_index]
        insert_here = lo_index - 1 

        for from_here in range(lo_index, hi_index):
            if self.array_to_sort[from_here] <= pivot:
                insert_here = insert_here + 1
                self.swap(insert_here, from_here)

        self.swap(insert_here + 1, hi_index)
        return insert_here + 1

    def quicksort(self, lo_index, hi_index):
        """"""Quicksort a slice of the array""""""
        if lo_index < hi_index:
            partition_index = self.partition(lo_index, hi_index)
            self.quicksort(lo_index, partition_index - 1)
            self.quicksort(partition_index + 1, hi_index)

# main function
def main_solution(unsorted_array):
    """"""
    Sorts an array using the quicksort algorithm.
    
    Args:
        unsorted_array (list): A list of integers to be sorted.
        
    Returns:
        list: A sorted list of integers.
    """"""
    # Create an instance of QuickSort
    quicksort_instance = QuickSort(unsorted_array)
    quicksort_instance.quicksort(0, len(quicksort_instance.array_to_sort) - 1)
    
    # Return the sorted array
    return quicksort_instance.array_to_sort","import random

def input_generator():
    # generate input arguments for the main_solution function
    unsorted_array = random.sample(range(1, 100), random.randint(5, 15))  # Random list of 5 to 15 unique integers
    return {""unsorted_array"": unsorted_array}","[{'input': {'unsorted_array': [11, 24, 25, 32, 34, 39, 51, 54, 59, 66, 91, 92, 95, 96]}, 'output': [11, 24, 25, 32, 34, 39, 51, 54, 59, 66, 91, 92, 95, 96]}, {'input': {'unsorted_array': [2, 39, 40, 41, 43, 56, 57, 59, 64, 70, 71, 83]}, 'output': [2, 39, 40, 41, 43, 56, 57, 59, 64, 70, 71, 83]}, {'input': {'unsorted_array': [5, 6, 13, 14, 25, 26, 53, 60]}, 'output': [5, 6, 13, 14, 25, 26, 53, 60]}, {'input': {'unsorted_array': [46, 64, 72, 76, 93]}, 'output': [46, 64, 72, 76, 93]}, {'input': {'unsorted_array': [33, 43, 54, 55, 91, 96]}, 'output': [33, 43, 54, 55, 91, 96]}]"
"In a busy sorting center, an unsorted array of integers is delivered for sorting. Each integer represents an item that needs to be organized in ascending order to streamline the sorting process. Given an `unsorted_array`, can you determine what the final sorted order of the items will be after applying the quicksort algorithm? Please return the sorted array.

The input and output requirements are as follows:

Input:
  `unsorted_array` (list): A list of integers that need to be sorted.

Output:
  `return` (list): A sorted list of integers in ascending order.","# import necessary packages
import json

# all class and function definitions in the code file
class QuickSort(object):
    """"""Quicksort implementation""""""

    def __init__(self, unsorted_array):
        """"""Initialize an array for quicksort""""""
        self.array_to_sort = unsorted_array
        self.is_sorted = False

    def swap(self, swap_x, swap_y):
        """"""Swap two elements of an array""""""
        tmp = self.array_to_sort[swap_x]
        self.array_to_sort[swap_x] = self.array_to_sort[swap_y]
        self.array_to_sort[swap_y] = tmp

    def partition(self, lo_index, hi_index):
        """"""Partition the array""""""        
        pivot = self.array_to_sort[hi_index]
        insert_here = lo_index - 1 

        for from_here in range(lo_index, hi_index):
            if self.array_to_sort[from_here] <= pivot:
                insert_here = insert_here + 1
                self.swap(insert_here, from_here)

        self.swap(insert_here + 1, hi_index)
        return insert_here + 1

    def quicksort(self, lo_index, hi_index):
        """"""Quicksort a slice of the array""""""
        if lo_index < hi_index:
            partition_index = self.partition(lo_index, hi_index)
            self.quicksort(lo_index, partition_index - 1)
            self.quicksort(partition_index + 1, hi_index)

# main function
def main_solution(unsorted_array):
    """"""
    Sorts an array using the quicksort algorithm.
    
    Args:
        unsorted_array (list): A list of integers to be sorted.
        
    Returns:
        list: A sorted list of integers.
    """"""
    # Create an instance of QuickSort
    quicksort_instance = QuickSort(unsorted_array)
    quicksort_instance.quicksort(0, len(quicksort_instance.array_to_sort) - 1)
    
    # Return the sorted array
    return quicksort_instance.array_to_sort","import random

def input_generator():
    # generate input arguments for the main_solution function
    unsorted_array = random.sample(range(1, 100), random.randint(5, 15))  # Random list of 5 to 15 unique integers
    return {""unsorted_array"": unsorted_array}","[{'input': {'unsorted_array': [3, 28, 34, 45, 48, 52, 53, 59, 71, 75, 96]}, 'output': [3, 28, 34, 45, 48, 52, 53, 59, 71, 75, 96]}, {'input': {'unsorted_array': [8, 47, 65, 73, 74]}, 'output': [8, 47, 65, 73, 74]}, {'input': {'unsorted_array': [5, 14, 23, 31, 53, 56, 58, 70, 74, 75, 81, 83, 84, 93]}, 'output': [5, 14, 23, 31, 53, 56, 58, 70, 74, 75, 81, 83, 84, 93]}, {'input': {'unsorted_array': [22, 39, 64, 80, 83, 84]}, 'output': [22, 39, 64, 80, 83, 84]}, {'input': {'unsorted_array': [7, 13, 15, 22, 27, 43, 45, 55, 57, 59, 86, 90, 91]}, 'output': [7, 13, 15, 22, 27, 43, 45, 55, 57, 59, 86, 90, 91]}]"
"In combinatorial mathematics, Pascal's Triangle is a triangular array of the binomial coefficients. Each number is the sum of the two directly above it. Given a positive integer `lines`, how can you generate Pascal's Triangle up to that number of rows? What will the structure of the triangle look like when represented as a list of lists, where each inner list corresponds to a row in the triangle?

The input and output requirements are as follows:

Input:
  `lines` (int): The number of rows to generate in Pascal's Triangle. It should be a positive integer.

Output:
  `return` (list): A list of lists where each inner list represents a row of Pascal's Triangle. Each element in the inner list is an integer representing the value in that position of the triangle.","# import necessary packages
import sys

# Function to calculate the value of a single cell in Pascal's Triangle
def calculate_one(line, place):
    if place == 1 or line == place:
        return 1
    else:
        return calculate_one(line - 1, place - 1) + calculate_one(line - 1, place)

# Function to generate a single line of Pascal's Triangle
def write_line(line):
    return [calculate_one(line, i) for i in range(1, line + 1)]

# Main function
def main_solution(lines):
    """"""
    This function generates Pascal's Triangle up to the specified number of lines.

    Input:
      `lines` (int): The number of rows to generate in Pascal's Triangle.

    Output:
      `return` (list): A list of lists representing the rows of Pascal's Triangle.
    """"""
    triangle = [write_line(i) for i in range(1, lines + 1)]
    return triangle","import random

def input_generator():
    # generate input arguments for the main_solution function
    lines = random.randint(1, 10)  # Randomly generate a number of lines between 1 and 10
    return {""lines"": lines}","[{'input': {'lines': 3}, 'output': [[1], [1, 1], [1, 2, 1]]}, {'input': {'lines': 8}, 'output': [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1]]}, {'input': {'lines': 9}, 'output': [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1]]}, {'input': {'lines': 5}, 'output': [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]}, {'input': {'lines': 4}, 'output': [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]]}]"
"In combinatorial mathematics, Pascal's Triangle is a triangular array of the binomial coefficients. Each number is the sum of the two directly above it. Given a positive integer `lines`, how can you generate Pascal's Triangle up to that number of rows? What will the structure of the triangle look like when represented as a list of lists, where each inner list corresponds to a row in the triangle?

The input and output requirements are as follows:

Input:
  `lines` (int): The number of rows to generate in Pascal's Triangle. It should be a positive integer.

Output:
  `return` (list): A list of lists where each inner list represents a row of Pascal's Triangle. Each element in the inner list is an integer representing the value in that position of the triangle.","# import necessary packages
import sys

# Function to calculate the value of a single cell in Pascal's Triangle
def calculate_one(line, place):
    if place == 1 or line == place:
        return 1
    else:
        return calculate_one(line - 1, place - 1) + calculate_one(line - 1, place)

# Function to generate a single line of Pascal's Triangle
def write_line(line):
    return [calculate_one(line, i) for i in range(1, line + 1)]

# Main function
def main_solution(lines):
    """"""
    This function generates Pascal's Triangle up to the specified number of lines.

    Input:
      `lines` (int): The number of rows to generate in Pascal's Triangle.

    Output:
      `return` (list): A list of lists representing the rows of Pascal's Triangle.
    """"""
    triangle = [write_line(i) for i in range(1, lines + 1)]
    return triangle","import random

def input_generator():
    # generate input arguments for the main_solution function
    lines = random.randint(1, 10)  # Randomly generate a number of lines between 1 and 10
    return {""lines"": lines}","[{'input': {'lines': 3}, 'output': [[1], [1, 1], [1, 2, 1]]}, {'input': {'lines': 1}, 'output': [[1]]}, {'input': {'lines': 4}, 'output': [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]]}, {'input': {'lines': 2}, 'output': [[1], [1, 1]]}, {'input': {'lines': 5}, 'output': [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]}]"
"In a linked list, nodes can be reversed in groups of a specified size. Given a list of integers representing the values in the linked list and an integer representing the size of the groups, how can you determine the new order of the nodes after reversing them in groups of that size? Please specify the linked list values as `head` and the group size as `k`, and return the resulting order of the linked list values after the operations.

The input and output requirements are as follows:

Input:
  `head` (list of integers): A list of integers representing the values in the linked list.
  `k` (int): An integer representing the size of the groups to reverse.

Output:
  `return` (list of integers): A list of integers representing the values in the linked list after reversing nodes in k-group.","# import necessary packages
# No external packages are required for the given problem.

# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# main function
def main_solution(head, k):
    # Convert the input list represented as a list of integers to a linked list
    def create_linked_list(arr):
        if not arr:
            return None
        head = ListNode(arr[0])
        current = head
        for value in arr[1:]:
            current.next = ListNode(value)
            current = current.next
        return head
    
    # Convert the linked list back to a list for output
    def linked_list_to_list(node):
        result = []
        while node:
            result.append(node.val)
            node = node.next
        return result

    # Length of the linked list
    def length(root):
        itr = root
        a = 0
        while itr:
            itr = itr.next
            a += 1
        return a

    # Reverse the nodes in k-group
    def reverse(head, k, l):
        if l < k:
            return head
        c = 0
        prev = None
        curr = head
        while c < k and curr is not None:
            nex = curr.next
            curr.next = prev
            prev = curr
            curr = nex
            c += 1
        if curr is not None:
            head.next = reverse(curr, k, l - k)
        return prev

    # Convert head input to linked list
    head = create_linked_list(head)
    
    # Call the reverseKGroup logic
    new_head = reverse(head, k, length(head))
    
    # Convert the output linked list back to a list
    return linked_list_to_list(new_head)","import random

def input_generator():
    head_length = random.randint(1, 10)  # Length of the linked list between 1 and 10
    head = [random.randint(1, 100) for _ in range(head_length)]  # Random integers for linked list values
    k = random.randint(1, 5)  # Random k value between 1 and 5
    return {""head"": head, ""k"": k}","[{'input': {'head': [59, 42, 13, 86, 68, 75, 73, 3, 68, 63], 'k': 1}, 'output': [59, 42, 13, 86, 68, 75, 73, 3, 68, 63]}, {'input': {'head': [6, 11, 67, 81, 30, 16, 35, 50, 39, 94], 'k': 1}, 'output': [6, 11, 67, 81, 30, 16, 35, 50, 39, 94]}, {'input': {'head': [68, 9], 'k': 2}, 'output': [9, 68]}, {'input': {'head': [26, 13, 47, 63], 'k': 4}, 'output': [63, 47, 13, 26]}, {'input': {'head': [9, 84, 61, 15, 22, 36, 73, 54, 75, 14], 'k': 2}, 'output': [84, 9, 15, 61, 36, 22, 54, 73, 14, 75]}]"
"In combinatorial mathematics, Pascal's Triangle is a triangular array of the binomial coefficients. Each number is the sum of the two directly above it. Given a positive integer `lines`, how can you generate Pascal's Triangle up to that number of rows? What will the structure of the triangle look like when represented as a list of lists, where each inner list corresponds to a row in the triangle?

The input and output requirements are as follows:

Input:
  `lines` (int): The number of rows to generate in Pascal's Triangle. It should be a positive integer.

Output:
  `return` (list): A list of lists where each inner list represents a row of Pascal's Triangle. Each element in the inner list is an integer representing the value in that position of the triangle.","# import necessary packages
import sys

# Function to calculate the value of a single cell in Pascal's Triangle
def calculate_one(line, place):
    if place == 1 or line == place:
        return 1
    else:
        return calculate_one(line - 1, place - 1) + calculate_one(line - 1, place)

# Function to generate a single line of Pascal's Triangle
def write_line(line):
    return [calculate_one(line, i) for i in range(1, line + 1)]

# Main function
def main_solution(lines):
    """"""
    This function generates Pascal's Triangle up to the specified number of lines.

    Input:
      `lines` (int): The number of rows to generate in Pascal's Triangle.

    Output:
      `return` (list): A list of lists representing the rows of Pascal's Triangle.
    """"""
    triangle = [write_line(i) for i in range(1, lines + 1)]
    return triangle","import random

def input_generator():
    # generate input arguments for the main_solution function
    lines = random.randint(1, 10)  # Randomly generate a number of lines between 1 and 10
    return {""lines"": lines}","[{'input': {'lines': 5}, 'output': [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]}, {'input': {'lines': 4}, 'output': [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]]}, {'input': {'lines': 1}, 'output': [[1]]}, {'input': {'lines': 7}, 'output': [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1]]}, {'input': {'lines': 6}, 'output': [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]]}]"
"In a digital library, users often search for specific books using their unique identification numbers. Given a list of identification numbers that may be sorted in either ascending or descending order, how can you efficiently determine the position of a specific book identified by its number? 

You need to find the index of the book identified by `target` in the list of `arr`. If the book is not found, return -1.

The input and output requirements are as follows:

Input:
  `arr` (list of int): A list of integers, which may be sorted in ascending or descending order.
  `target` (int): The integer value to search for in the list.

Output:
  `return` (int): The index of the target integer in the list if found; otherwise, return -1.","# import necessary packages
import json

# all class and function definitions in the code file, if any
# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)

def binary_search(arr, target, start, end):
    midpoint = (start + end) // 2
    if start > end:
        return -1
    if arr[midpoint] == target:
        return midpoint

    if arr[midpoint] > target:
        return binary_search(arr, target, start, midpoint - 1)
    else:
        return binary_search(arr, target, midpoint + 1, end)

def agnostic_binary_search(arr, target):
    isAsc, start, end = False, 0, len(arr) - 1
    if len(arr) >= 2:
        if arr[0] < arr[-1]:
            isAsc = True

    while start <= end:
        midpoint = (start + end) // 2
        if arr[midpoint] == target:
            return midpoint
        if isAsc:
            if arr[midpoint] > target:
                end = midpoint - 1
            else:
                start = midpoint + 1
        else:
            if arr[midpoint] > target:
                start = midpoint + 1
            else:
                end = midpoint - 1
    return -1

# main function
def main_solution(arr, target):
    # Convert input to appropriate types
    if len(arr) == 0:
        return -1  # If the array is empty, return -1
    # Call the agnostic binary search function
    index = agnostic_binary_search(arr, target)
    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)
    return index","import random

def input_generator():
    # Generate a random list of integers
    arr_length = random.randint(1, 10)  # Random length between 1 and 10
    arr = random.sample(range(-100, 100), arr_length)  # Unique integers between -100 and 100
    target = random.choice(arr)  # Randomly select a target from the array
    return {""arr"": arr, ""target"": target}","[{'input': {'arr': [-80, 14, 89, -38, -94, -11, -49], 'target': -80}, 'output': 0}, {'input': {'arr': [-62, 80, 79, 60, -29], 'target': 79}, 'output': 2}, {'input': {'arr': [99, -23], 'target': 99}, 'output': 0}, {'input': {'arr': [-54, -4, 26, -19], 'target': 26}, 'output': 2}, {'input': {'arr': [37, 22, 82, -32, 30, -98, -47, 71, -80], 'target': 22}, 'output': -1}]"
"In a busy sorting center, an unsorted array of integers is delivered for sorting. Each integer represents an item that needs to be organized in ascending order to streamline the sorting process. Given an `unsorted_array`, can you determine what the final sorted order of the items will be after applying the quicksort algorithm? Please return the sorted array.

The input and output requirements are as follows:

Input:
  `unsorted_array` (list): A list of integers that need to be sorted.

Output:
  `return` (list): A sorted list of integers in ascending order.","# import necessary packages
import json

# all class and function definitions in the code file
class QuickSort(object):
    """"""Quicksort implementation""""""

    def __init__(self, unsorted_array):
        """"""Initialize an array for quicksort""""""
        self.array_to_sort = unsorted_array
        self.is_sorted = False

    def swap(self, swap_x, swap_y):
        """"""Swap two elements of an array""""""
        tmp = self.array_to_sort[swap_x]
        self.array_to_sort[swap_x] = self.array_to_sort[swap_y]
        self.array_to_sort[swap_y] = tmp

    def partition(self, lo_index, hi_index):
        """"""Partition the array""""""        
        pivot = self.array_to_sort[hi_index]
        insert_here = lo_index - 1 

        for from_here in range(lo_index, hi_index):
            if self.array_to_sort[from_here] <= pivot:
                insert_here = insert_here + 1
                self.swap(insert_here, from_here)

        self.swap(insert_here + 1, hi_index)
        return insert_here + 1

    def quicksort(self, lo_index, hi_index):
        """"""Quicksort a slice of the array""""""
        if lo_index < hi_index:
            partition_index = self.partition(lo_index, hi_index)
            self.quicksort(lo_index, partition_index - 1)
            self.quicksort(partition_index + 1, hi_index)

# main function
def main_solution(unsorted_array):
    """"""
    Sorts an array using the quicksort algorithm.
    
    Args:
        unsorted_array (list): A list of integers to be sorted.
        
    Returns:
        list: A sorted list of integers.
    """"""
    # Create an instance of QuickSort
    quicksort_instance = QuickSort(unsorted_array)
    quicksort_instance.quicksort(0, len(quicksort_instance.array_to_sort) - 1)
    
    # Return the sorted array
    return quicksort_instance.array_to_sort","import random

def input_generator():
    # generate input arguments for the main_solution function
    unsorted_array = random.sample(range(1, 100), random.randint(5, 15))  # Random list of 5 to 15 unique integers
    return {""unsorted_array"": unsorted_array}","[{'input': {'unsorted_array': [5, 6, 20, 21, 25, 36, 55, 63, 68, 70, 74, 75, 80, 87, 99]}, 'output': [5, 6, 20, 21, 25, 36, 55, 63, 68, 70, 74, 75, 80, 87, 99]}, {'input': {'unsorted_array': [40, 47, 48, 54, 58, 60, 61, 71, 72, 86, 87, 94, 99]}, 'output': [40, 47, 48, 54, 58, 60, 61, 71, 72, 86, 87, 94, 99]}, {'input': {'unsorted_array': [28, 41, 58, 70, 77, 82]}, 'output': [28, 41, 58, 70, 77, 82]}, {'input': {'unsorted_array': [9, 32, 34, 37, 38, 42, 45, 57, 62, 71, 72, 73, 89, 98, 99]}, 'output': [9, 32, 34, 37, 38, 42, 45, 57, 62, 71, 72, 73, 89, 98, 99]}, {'input': {'unsorted_array': [14, 41, 51, 59, 84, 87]}, 'output': [14, 41, 51, 59, 84, 87]}]"
