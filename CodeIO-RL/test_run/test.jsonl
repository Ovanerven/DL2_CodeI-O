{"context": "In a game of Tic Tac Toe, given the current state of the board and the markers assigned to two players, what would be the resulting board state after one move, and which player, if any, would be declared the winner?\n\nThe input and output requirements are as follows:\n\nInput:\n- `board_state` (list of lists of strings): A 3x3 grid representing the current state of the Tic Tac Toe board. Each cell can be either an empty string `''`, `'X'`, or `'O'`.\n- `player1_marker` (string): The marker for player 1, either `'X'` or `'O'`.\n- `player2_marker` (string): The marker for player 2, either `'X'` or `'O'`.\n\nOutput:\n- `return` (tuple): A tuple containing:\n  - `new_board_state` (list of lists of strings): The updated 3x3 grid after the move.\n  - `winner` (string or None): The marker of the winner (`'X'` or `'O'`), or `None` if there is no winner yet.", "reference_code": "# import necessary packages\nimport random\nimport copy\nimport ast\n\n# Constants\nMARKERS = ['X', 'O']\n\n# Board class definition\nclass Board(object):\n    def __init__(self):\n        self.state = []\n        self.newBoard()\n\n    def newBoard(self):\n        self.state = [['', '', ''] for _ in range(3)]\n\n    def getState(self):\n        return self.state\n\n    def place(self, marker, x, y):\n        if marker in MARKERS and self.state[y][x] not in MARKERS:\n            self.state[y][x] = marker\n\n    def checkForWin(self):\n        nn = {\n            \"topLeft\": self.state[0][0],\n            \"topMid\": self.state[0][1],\n            \"topRight\": self.state[0][2],\n            \"midLeft\": self.state[1][0],\n            \"midMid\": self.state[1][1],\n            \"midRight\": self.state[1][2],\n            \"botLeft\": self.state[2][0],\n            \"botMid\": self.state[2][1],\n            \"botRight\": self.state[2][2],\n        }\n\n        if nn['topLeft'] in MARKERS:\n            if (nn['topLeft'] == nn['topMid'] == nn['topRight'] or\n                nn['topLeft'] == nn['midMid'] == nn['botRight'] or\n                nn['topLeft'] == nn['midLeft'] == nn['botLeft']):\n                return nn['topLeft']\n        if nn['topMid'] in MARKERS:\n            if nn['topMid'] == nn['midMid'] == nn['botMid']:\n                return nn['topMid']\n        if nn['topRight'] in MARKERS:\n            if nn['topRight'] == nn['midRight'] == nn['botRight']:\n                return nn['topRight']\n        if nn['midLeft'] in MARKERS:\n            if nn['midLeft'] == nn['midMid'] == nn['midRight']:\n                return nn['midLeft']\n        if nn['midMid'] in MARKERS:\n            if nn['midMid'] == nn['topRight'] == nn['botLeft']:\n                return nn['midMid']\n        if nn['botLeft'] in MARKERS:\n            if nn['botLeft'] == nn['botMid'] == nn['botRight']:\n                return nn['botLeft']\n        for value in nn.values():\n            if value not in MARKERS:\n                return None\n        return 'Draw'\n\n# Agent class definition\nclass Agent(object):\n    def __init__(self, marker, random=False):\n        self.stateValues = {}\n        self.epsilon = 0.1\n        self.alpha = 0.99\n        self.marker = marker\n        self.lastState = []\n        self.random = random\n\n    def updateVars(self):\n        self.epsilon *= 0.9999\n        self.alpha *= 0.9999\n\n    def greedyMove(self, currentState):\n        possibilities = {}\n        for i in range(3):\n            for j in range(3):\n                if currentState[i][j] not in MARKERS:\n                    possibleState = copy.deepcopy(currentState)\n                    possibleState[i][j] = self.marker\n                    if str(possibleState) in self.stateValues:\n                        possibilities[str(possibleState)] = self.stateValues[str(possibleState)]\n                    else:\n                        self.stateValues[str(possibleState)] = 0.5\n                        possibilities[str(possibleState)] = 0.5\n\n        maxState = None\n        maxValue = -10\n        for key, value in possibilities.items():\n            if value > maxValue:\n                maxState = key\n                maxValue = value\n            elif value == maxValue:\n                if random.randint(0, 1) == 0:\n                    maxState = key\n                    maxValue = value\n\n        x = y = 0\n        maxState = ast.literal_eval(maxState)\n        for i in range(3):\n            for j in range(3):\n                if currentState[i][j] != maxState[i][j]:\n                    x = j\n                    y = i\n\n        if str(currentState) in self.stateValues:\n            self.stateValues[str(currentState)] += self.alpha * (self.stateValues[str(maxState)] - self.stateValues[str(currentState)])\n        else:\n            self.stateValues[str(currentState)] = 0.5\n\n        self.lastState = maxState\n        return x, y\n\n    def exploratoryMove(self, currentState):\n        possibilities = []\n        for i in range(3):\n            for j in range(3):\n                if currentState[i][j] not in MARKERS:\n                    possibilities.append((j, i))\n\n        choice = random.randint(0, len(possibilities) - 1)\n        move = possibilities[choice]\n        x, y = move\n\n        temp = copy.deepcopy(currentState)\n        temp[y][x] = self.marker\n        self.lastState = temp\n\n        return x, y\n\n    def chooseMove(self, currentState):\n        rVal = random.randint(1, 100)\n        decrVal = float(rVal) / 100\n\n        if self.random or decrVal <= self.epsilon:\n            x, y = self.exploratoryMove(currentState)\n        else:\n            x, y = self.greedyMove(currentState)\n\n        self.updateVars()\n        return x, y\n\n# main function\ndef main_solution(board_state, player1_marker, player2_marker):\n    board = Board()\n    board.state = board_state\n    p1 = Agent(player1_marker)\n    p2 = Agent(player2_marker)\n\n    game = Game(p1, p2)\n    game.board = board\n    game.makeMove(game.nextMove)\n\n    return game.board.getState(), game.winner.marker if game.winner else None\n\nclass Game(object):\n    def __init__(self, p1, p2):\n        self.board = Board()\n        self.p1 = p1\n        self.p2 = p2\n        self.lastMove, self.nextMove = self.chooseFirst(self.p1, self.p2)\n        self.winner = None\n\n    def chooseFirst(self, p1, p2):\n        return (p1, p2) if random.randint(0, 1) == 0 else (p2, p1)\n\n    def makeMove(self, player):\n        x, y = player.chooseMove(self.board.getState())\n        self.board.place(player.marker, x, y)\n        self.nextMove = self.lastMove\n        self.lastMove = player\n        result = self.board.checkForWin()\n        if result == player.marker:\n            self.gameOver(player.marker)\n        elif result == 'Draw':\n            self.gameOver('Draw')\n        else:\n            self.makeMove(self.nextMove)\n\n    def gameOver(self, status):\n        if status in MARKERS:\n            self.winner = self.lastMove\n        else:\n            self.winner = None", "input_generator": "import random\n\ndef input_generator():\n    markers = ['X', 'O']\n    player1_marker = random.choice(markers)\n    player2_marker = 'O' if player1_marker == 'X' else 'X'\n    \n    board_state = []\n    for _ in range(3):\n        row = []\n        for _ in range(3):\n            cell = random.choice(['', 'X', 'O'])\n            row.append(cell)\n        board_state.append(row)\n    \n    return {\n        'board_state': board_state,\n        'player1_marker': player1_marker,\n        'player2_marker': player2_marker\n    }"}
{"context": "Given a dataset with features and target values, how can we determine the optimal parameters (theta) for a linear regression model using gradient descent, given a specific learning rate and number of iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `X_data` (list of lists): A list of lists representing the feature matrix. Each sublist represents a row in the matrix.\n  `y_data` (list): A list representing the target vector.\n  `alpha` (float): The learning rate for the gradient descent algorithm.\n  `iterations` (int): The number of iterations for the gradient descent algorithm.\n\nOutput:\n  `return` (list of lists): A list of lists representing the final theta values after running the gradient descent algorithm. Each sublist contains one theta value.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(X_data, y_data, alpha, iterations):\n    # Convert JSON serializable inputs to numpy matrices\n    X = np.matrix(X_data).T\n    y = np.matrix(y_data).T\n    theta = np.matrix([0, 1]).T\n\n    for i in range(iterations):\n        h = X.dot(theta)\n        derivative = np.matrix([0, 0]).T\n        for j in range(X.shape[1]):\n            derivative[j] = sum(np.multiply(h - y, X[:, j]))\n        theta = theta - alpha * derivative\n\n    # Convert numpy matrix to JSON serializable list\n    theta_list = theta.tolist()\n    return theta_list", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random number of data points between 10 and 100\n    n = random.randint(10, 100)\n    \n    # Generate random X_data (features) between -10 and 10\n    X_data = [random.uniform(-10, 10) for _ in range(n)]\n    \n    # Generate random y_data (target) with some linear relationship plus noise\n    slope = random.uniform(-5, 5)\n    intercept = random.uniform(-5, 5)\n    noise = [random.uniform(-1, 1) for _ in range(n)]\n    y_data = [slope * x + intercept + n for x, n in zip(X_data, noise)]\n    \n    # Generate random alpha (learning rate) between 0.001 and 0.1\n    alpha = random.uniform(0.001, 0.1)\n    \n    # Generate random iterations between 100 and 1000\n    iterations = random.randint(100, 1000)\n    \n    return {\n        'X_data': X_data,\n        'y_data': y_data,\n        'alpha': alpha,\n        'iterations': iterations\n    }"}
{"context": "Given a time series represented by a 2D array, where each row is a separate time series, and a specific segment of each row is set to a constant value (referred to as a \"top hat\" function), what is the autocorrelation function for each time series after normalization? The autocorrelation function should be calculated for each row and normalized by the variance of the row.\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): Number of rows in the array.\n  `n` (int): Number of columns in the array.\n  `top_hat_indices` (list of int): A list containing two integers representing the start and end indices of the top hat function.\n\nOutput:\n  `return` (list of list of float): A list of autocorrelation functions, where each autocorrelation function is represented as a list of floats.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(m, n, top_hat_indices):\n    # Initialize the array\n    x = np.zeros(shape=(m, n))\n    \n    # Apply the top hat function to each row\n    for row in x:\n        row[top_hat_indices[0]:top_hat_indices[1]] = 1\n    \n    # Calculate the autocorrelation for each row\n    acorrs = []\n    for row in x:\n        y = row - row.mean()\n        acorr = np.correlate(y, y, mode=\"full\")\n        acorr = acorr[acorr.size // 2:]\n        acorr /= (row.var() * np.arange(row.size, 0, -1))\n        acorrs.append(acorr.tolist())  # Convert to list for JSON serializability\n    \n    return acorrs", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    m = random.randint(1, 10)\n    n = random.randint(5, 20)\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n)\n    top_hat_indices = [start, end]\n    return {'m': m, 'n': n, 'top_hat_indices': top_hat_indices}"}
{"context": "Given a square matrix, what are the eigenvalues and corresponding eigenvectors of the matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of floats): A 2D list representing a square matrix. Each sublist represents a row in the matrix.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `eigenvalues` (list of floats): A list of eigenvalues of the input matrix.\n    - `eigenvectors` (list of lists of floats): A list of eigenvectors corresponding to the eigenvalues. Each eigenvector is represented as a list of floats.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom numpy.linalg import eig\n\n# main function\ndef main_solution(matrix):\n    # Convert the input matrix to a numpy array\n    A = np.array(matrix)\n    \n    # Calculate the eigenvalues and eigenvectors\n    eigenvalues, eigenvectors = eig(A)\n    \n    # Convert the eigenvalues and eigenvectors to JSON serializable format\n    eigenvalues = eigenvalues.tolist()\n    eigenvectors = eigenvectors.tolist()\n    \n    # Return the eigenvalues and eigenvectors\n    return {\"eigenvalues\": eigenvalues, \"eigenvectors\": eigenvectors}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random size for the matrix (2x2 or 3x3)\n    size = random.choice([2, 3])\n    \n    # Generate random integers for the matrix elements\n    matrix = np.random.randint(-10, 10, size=(size, size)).tolist()\n    \n    return {\"matrix\": matrix}"}
{"context": "Given two numbers represented in base -2, what is the sum of these two numbers when they are converted back to base -2?\n\nThe input and output requirements are as follows:\n\nInput:\n  `arr1` (list of int): A list of integers representing a number in base -2.\n  `arr2` (list of int): A list of integers representing another number in base -2.\nOutput:\n  `return` (list of int): A list of integers representing the sum of the two input numbers in base -2.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef int2neg2(x):\n    ans = \"\"\n    while x != 0:\n        tmp = abs(x % (-2))\n        ans += str(tmp)\n        x = (x - tmp) // (-2)\n    return \"\".join(reversed(ans))\n\ndef neg22int(arr):\n    answer = 0\n    base = 1\n    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == 1:\n            answer += base\n        base *= (-2)\n    return answer\n\n# main function\ndef main_solution(arr1, arr2):\n    # Convert the input lists to integers in base -2\n    int1 = neg22int(arr1)\n    int2 = neg22int(arr2)\n    \n    # Sum the integers\n    sum_int = int1 + int2\n    \n    # Convert the sum back to base -2\n    sum_neg2 = int2neg2(sum_int)\n    \n    # Convert the result to a list of integers\n    result = [int(char) for char in sum_neg2]\n    \n    # Return the result as a list of integers\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate two random integers between -100 and 100\n    int1 = random.randint(-100, 100)\n    int2 = random.randint(-100, 100)\n    \n    # Convert integers to base -2 lists\n    arr1 = [int(c) for c in int2neg2(int1)] if int1 != 0 else [0]\n    arr2 = [int(c) for c in int2neg2(int2)] if int2 != 0 else [0]\n    \n    return {'arr1': arr1, 'arr2': arr2}"}
{"context": "Given a Rubik's Cube that is initially solved, if we apply a series of random scramble moves to it, will the cube remain solved? Specifically, what is the result of applying the given scramble moves to the cube?\n\nThe input and output requirements are as follows:\n\nInput:\n  `scramble_moves` (list of strings): A list of strings representing the moves to scramble the Rubik's Cube. Each string should be a valid move in the format \"F\", \"B\", \"L\", \"R\", \"U\", \"D\", \"F'\", \"B'\", \"L'\", \"R'\", \"U'\", \"D'\", \"F2\", \"B2\", \"L2\", \"R2\", \"U2\", \"D2\".\n\nOutput:\n  `return` (dictionary): A dictionary with a single key \"is_solved\" (boolean) indicating whether the Rubik's Cube is solved after applying the scramble moves.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Cubie(object):\n    def __init__(self, cx, cy, cz):\n        self.colors = [cx, cy, cz]\n\n    def rotate(self, axis):\n        if axis == 0:  # X\n            self.colors = [self.colors[0], self.colors[2], self.colors[1]]\n        elif axis == 1:  # Y\n            self.colors = [self.colors[2], self.colors[1], self.colors[0]]\n        elif axis == 2:  # Z\n            self.colors = [self.colors[1], self.colors[0], self.colors[2]]\n\n    def update_colors(self, new_color):\n        self.colors = new_color\n\nclass Cube(object):\n    def __init__(self, state=None):\n        self._orientation = [0, 1, 2]\n        self._state = []\n\n        if not state:\n            for i in range(27):\n                cx = cy = cz = None\n\n                if i % 3 == 0:  # left\n                    cx = 'b'\n                elif i % 3 == 2:  # right\n                    cx = 'g'\n                if i < 9:  # front\n                    cz = 'r'\n                elif i > 17:  # back\n                    cz = 'o'\n                if i % 9 < 3:  # up\n                    cy = 'y'\n                elif i % 9 > 5:  # down\n                    cy = 'w'\n\n                self._state.append(Cubie(cx, cy, cz))\n\n        self._front = [self._state[i] for i in (0, 1, 2, 5, 8, 7, 6, 3, 4)]\n        self._back = [self._state[i] for i in (20, 19, 18, 21, 24, 25, 26, 23, 22)]\n        self._left = [self._state[i] for i in (18, 9, 0, 3, 6, 15, 24, 21, 12)]\n        self._right = [self._state[i] for i in (2, 11, 20, 23, 26, 17, 8, 5, 14)]\n        self._up = [self._state[i] for i in (18, 19, 20, 11, 2, 1, 0, 9, 10)]\n        self._down = [self._state[i] for i in (6, 7, 8, 17, 26, 25, 24, 15, 16)]\n        self._equator = [self._state[i] for i in (3, 4, 5, 14, 23, 22, 21, 12, 13)]\n\n        self._face_dict = {\n            'F': (self._front, 2), 'B': (self._back, 2),\n            'L': (self._left, 0), 'R': (self._right, 0),\n            'U': (self._up, 1), 'D': (self._down, 1)\n        }\n\n        self._face_order = ('U', 'L', 'F', 'R', 'B', 'D')\n\n    def get_face(self, face, side=False):\n        face_s = self._face_dict[face][0]\n        if not side:\n            axis = self._face_dict[face][1]\n            return ''.join(face_s[i].colors[axis] for i in (0, 1, 2, 7, 8, 3, 6, 5, 4))\n        else:\n            re = ''\n            for i in range(0, 8, 2):\n                axis = 0 if i % 4 == 2 else 2\n                for j in range(3):\n                    re += face_s[i+j if i+j < 8 else 0].colors[axis]\n            return re\n\n    def set_face(self, face, s):\n        face_s = self._face_dict[face][0]\n        axis = self._face_dict[face][1]\n        for i, j in zip((0, 1, 2, 7, 8, 3, 6, 5, 4), range(9)):\n            face_s[i].colors[axis] = s[j]\n\n    def is_solved(self):\n        for face in self._face_dict.keys():\n            face_s = self.get_face(face)\n            c = face_s[0]\n            for i in face_s[1:]:\n                if i != c:\n                    return False\n        return True\n\n    def turn(self, face):\n        if 'Y' in face:\n            self.rotate_y(False if \"'\" in face else True)\n            if '2' in face:\n                self.rotate_y(False if \"'\" in face else True)\n            return\n\n        shift = 2 if \"'\" in face else -2\n        face_s = self._face_dict[face[0]][0]\n        axis = self._face_dict[face[0]][1]\n        face_ref = [face_s[(i + shift) % 8].colors for i in range(8)]\n        for color, color_new in zip(face_s[:-1], face_ref):\n            color.update_colors(color_new)\n            color.rotate(axis)\n\n        if '2' in face:\n            self.turn(face[:-1])\n\n    def rotate_y(self, cw=True):\n        shift = 0\n        if cw:\n            self.turn('U')\n            self.turn(\"D'\")\n            shift = 2\n        else:\n            self.turn(\"U'\")\n            self.turn('D')\n            shift = -2\n        cubies = self._equator\n        cubies_ref = [cubies[(i + shift) % 8].colors for i in range(8)]\n        for color, color_new in zip(cubies[:-1], cubies_ref):\n            color.update_colors(color_new)\n            color.rotate(1)\n\n    def scramble(self, turns=10, by_hand=False):\n        p = []\n        for i in range(turns):\n            move_pool = ['F', 'B', 'L', 'R', 'U']\n            if by_hand:\n                move_pool.append('D')\n            move = random.choice(move_pool)\n            move += random.choice([\"'\", ''])\n            self.turn(move)\n            p.append(move)\n        return p\n\n# main function\ndef main_solution(scramble_moves):\n    # Initialize a solved cube\n    cube = Cube()\n    \n    # Apply the scramble moves to the cube\n    for move in scramble_moves:\n        cube.turn(move)\n    \n    # Check if the cube is solved after applying the scramble moves\n    is_solved = cube.is_solved()\n    \n    # Return the result as a dictionary\n    return {\"is_solved\": is_solved}", "input_generator": "import random\n\ndef input_generator():\n    move_options = ['F', 'B', 'L', 'R', 'U', 'D']\n    modifiers = [\"\", \"'\", \"2\"]\n    num_moves = random.randint(5, 15)\n    scramble_moves = []\n    for _ in range(num_moves):\n        move = random.choice(move_options)\n        modifier = random.choice(modifiers)\n        scramble_moves.append(move + modifier)\n    return {\"scramble_moves\": scramble_moves}"}
{"context": "Given a set of dominoes, each with two numbers on its sides, can you determine if they can be arranged in a chain such that the second number of each domino matches the first number of the next domino? If a valid chain exists, what is the arrangement of the dominoes in that chain?\n\nThe input and output requirements are as follows:\n\nInput:\n  `dominoes` (list of lists): A list of dominoes, where each domino is represented as a list of two integers. Each integer represents the number on one side of the domino.\n\nOutput:\n  `return` (list of lists): A valid chain of dominoes if one exists, otherwise an empty list. Each domino in the chain is represented as a list of two integers.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(dominoes):\n    \"\"\"\n    Determines if a set of dominoes can form a valid chain.\n\n    Args:\n        dominoes (list of lists): A list of dominoes, where each domino is represented as a list of two integers.\n\n    Returns:\n        list of lists: A valid chain of dominoes if one exists, otherwise an empty list.\n    \"\"\"\n    if not dominoes:\n        return []\n\n    for permutation in itertools.permutations(dominoes):\n        solution = check(permutation)\n        if solution is not None:\n            return solution\n    return []\n\ndef check(permutation):\n    \"\"\"\n    Checks if a given permutation of dominoes forms a valid chain.\n\n    Args:\n        permutation (tuple of lists): A permutation of dominoes.\n\n    Returns:\n        list of lists: A valid chain of dominoes if one exists, otherwise None.\n    \"\"\"\n    last_prev, prev = permutation[0]\n    solution = [list(permutation[0])]\n    for i in range(1, len(permutation)):\n        if permutation[i][0] == prev:\n            prev = permutation[i][1]\n            solution.append(list(permutation[i]))\n        elif permutation[i][1] == prev:\n            prev = permutation[i][0]\n            solution.append(list(permutation[i][::-1]))\n        else:\n            return None\n    return solution if prev == last_prev else None", "input_generator": "import random\n\ndef input_generator():\n    # Randomly decide the number of dominoes (between 1 and 6 for reasonable size)\n    n = random.randint(1, 6)\n    \n    # Generate dominoes ensuring some can form a chain\n    if random.random() < 0.5:\n        # Generate a valid chain\n        first = random.randint(0, 6)\n        dominoes = []\n        prev = first\n        for _ in range(n):\n            next_num = random.randint(0, 6)\n            dominoes.append([prev, next_num])\n            prev = next_num\n        # Close the loop if more than one domino\n        if n > 1:\n            dominoes[-1][1] = first\n    else:\n        # Generate random dominoes (may or may not form a chain)\n        dominoes = []\n        for _ in range(n):\n            a = random.randint(0, 6)\n            b = random.randint(0, 6)\n            dominoes.append([a, b])\n    \n    # Shuffle the dominoes to add randomness\n    random.shuffle(dominoes)\n    \n    return {'dominoes': dominoes}"}
{"context": "Alice and Bob are playing a game with a pile of stones. Alice always goes first. On each player's turn, they can remove either 2, 3, or 5 stones from the pile. The player who cannot make a move loses the game. Given the number of stones `n` in the pile, who will win the game if both players play optimally?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of stones in the pile.\n\nOutput:\n  `return` (str): A string indicating the winner of the game. It can be either \"First\" or \"Second\".", "reference_code": "# import necessary packages\nimport sys\n\n# all class and function definitions in the code file, if any\nwin = {0: False, 1: False}\n\ndef progdyn(n):\n    if n not in win:\n        win[n] = not progdyn(n - 2) or (n > 2 and not progdyn(n - 3)) or (n > 4 and not progdyn(n - 5))\n    return win[n]\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = progdyn(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return \"First\" if result else \"Second\"", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(0, 100)\n    return {'n': n}"}
{"context": "Given a polynomial function defined by its coefficients, how can we find an approximate root of this polynomial using the Newton-Raphson method starting from a given initial guess?\n\nThe input and output requirements are as follows:\n\nInput:\n  `coefficients` (list of float): The coefficients of the polynomial function in descending order of degree. For example, for the polynomial \\(3x^3 - 2x^2 + 5x - 1\\), the coefficients would be `[3, -2, 5, -1]`.\n  `initial_guess` (float): The initial guess for the root of the polynomial function.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `root` (float): The approximate root of the polynomial function.\n    - `error` (float): The error (distance from the root to zero) of the approximation.\n    - `iterations` (int): The number of iterations taken to find the root.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef cubic_function(a=0, b=0, c=0, d=0):\n    return lambda x : (a * pow(x, 3)) + (b * pow(x, 2)) + (c * x) + d\n\ndef derivative(function, x, h=0.00001):\n    return (function(x + h) - function(x)) / h\n\ndef evaluate_guess(function, guess_x):\n    return abs( 0 - function(guess_x) )\n\ndef newthon_raphson_step(function, guess_x=0):\n    return guess_x - (function(guess_x) / derivative(function, guess_x) )\n\ndef newthon_raphson(function, x_0=0, precision=0.000001, max_iterations=1000):\n    best_guess_x = x_0\n    \u0394 = evaluate_guess(function, x_0)\n    iteration = 0\n\n    while best_guess_x is not None and \u0394 > precision and iteration < max_iterations:\n        iteration += 1\n        best_guess_x = newthon_raphson_step(function, best_guess_x)\n        \u0394 = evaluate_guess(function, best_guess_x)\n\n    return best_guess_x, \u0394, iteration\n\n# main function\ndef main_solution(coefficients, initial_guess):\n  \"\"\"\n  Find the root of a polynomial function using the Newton-Raphson method.\n\n  Parameters:\n  coefficients (list of float): The coefficients of the polynomial function in descending order of degree.\n  initial_guess (float): The initial guess for the root.\n\n  Returns:\n  dict: A dictionary containing the root, the error, and the number of iterations.\n  \"\"\"\n  # Convert coefficients to a polynomial function\n  function = cubic_function(*coefficients)\n  \n  # Find the root using Newton-Raphson method\n  root, error, iterations = newthon_raphson(function, initial_guess)\n  \n  # Return the result as a dictionary\n  return {\n      \"root\": root,\n      \"error\": error,\n      \"iterations\": iterations\n  }", "input_generator": "import random\n\ndef input_generator():\n    # Generate random coefficients for a cubic polynomial (a, b, c, d)\n    coefficients = [random.uniform(-10, 10) for _ in range(4)]\n    \n    # Generate a reasonable initial guess, possibly near a root\n    # To make it reasonable, we can pick a value between -5 and 5\n    initial_guess = random.uniform(-5, 5)\n    \n    return {\n        \"coefficients\": coefficients,\n        \"initial_guess\": initial_guess\n    }"}
{"context": "Given a string and a pattern, how can we determine all possible ways to map each character in the pattern to a non-empty substring of the string such that the concatenation of the substrings matches the pattern?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string that needs to be matched against the pattern.\n  `pattern` (str): A pattern string that defines the structure of the mapping.\n\nOutput:\n  `return` (list of dict): A list of dictionaries where each dictionary represents a possible mapping of the pattern characters to substrings of the input string. Each key in the dictionary is a character from the pattern, and the corresponding value is the substring from the input string that matches the pattern character.", "reference_code": "# import necessary packages\nimport copy\n\n# main function\ndef main_solution(input_string, pattern):\n    # Convert the input variables to the required format for the recursion function\n    def recursion(str, ptn, map={}, res=[]):\n        if len(ptn) == 0:\n            if len(str) == 0:\n                res.append(copy.deepcopy(map))\n                return\n            else:\n                return\n        \n        ch = ptn[0]\n        rop = ptn[1:]\n        \n        if ch in map:\n            if map[ch] == str[0:len(map[ch])]:\n                recursion(str[len(map[ch]):], rop, map, res)\n        else:\n            for i in range(len(str)):\n                prefix = str[0:i+1]\n                rest = str[i+1:]\n                map[ch] = prefix\n                recursion(rest, rop, map, res)\n                del map[ch]\n        \n        return res\n    \n    # Call the recursion function with the provided input and pattern\n    result = recursion(input_string, pattern)\n    \n    # Convert the result to a JSON serializable format\n    json_result = [dict(item) for item in result]\n    \n    return json_result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random pattern with 1-3 unique lowercase letters\n    pattern_length = random.randint(1, 3)\n    pattern = ''.join(random.sample(string.ascii_lowercase, pattern_length))\n    \n    # Generate a random input string with length between pattern_length and 10\n    input_length = random.randint(pattern_length, 10)\n    input_string = ''.join(random.choices(string.ascii_lowercase, k=input_length))\n    \n    return {\n        'input_string': input_string,\n        'pattern': pattern\n    }"}
{"context": "Given a binary string, determine if the number it represents is divisible by 3. What is the result of checking the divisibility of the given binary string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `binary_string` (str): A string representing a binary number. The string should only contain characters '0' and '1'.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input binary string represents a number divisible by 3. `True` if divisible, `False` otherwise.", "reference_code": "# import necessary packages\nimport re\n\n# main function\ndef main_solution(binary_string):\n    # Convert the input binary string to a format suitable for the regex\n    binary_string = str(binary_string)\n    \n    # Define the regex pattern for numbers divisible by 3\n    DIV_3 = re.compile(r'^(0|11|10(00)*(1+(00)+)*1*01)+$')\n    \n    # Check if the binary string matches the regex pattern\n    match = bool(DIV_3.match(binary_string))\n    \n    # Return the result\n    return match", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random binary string that may or may not be divisible by 3\n    length = random.randint(1, 20)\n    binary_string = ''.join(random.choice('01') for _ in range(length))\n    \n    # Occasionally ensure the string is divisible by 3\n    if random.random() < 0.5:\n        num = random.randint(0, 100) * 3\n        binary_string = bin(num)[2:]\n    \n    return {'binary_string': binary_string}"}
{"context": "Given a range of digits from 1 to a specified highest digit, what is the largest prime number that can be formed by permuting these digits?\n\nThe input and output requirements are as follows:\n\nInput:\n  `highest_digit` (int): The highest digit to consider for generating pandigital numbers. Must be between 1 and 9.\n\nOutput:\n  `return` (int): The largest prime pandigital number found for the given `highest_digit`. If no such number is found, returns 0.", "reference_code": "# import necessary packages\nimport math\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef IsPrime(num):\n    if num <= 1:\n        return False\n\n    sqRt = round(math.sqrt(num))\n    for i in range(2, sqRt + 1):\n        if num % i == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(highest_digit):\n    largest = 0\n\n    while largest == 0 and highest_digit >= 1:\n        l = list(permutations(range(1, highest_digit + 1)))\n\n        for permutation in l:\n            num = 0\n            for i in permutation:\n                num *= 10\n                num += i\n            if num < largest or not IsPrime(num):\n                continue\n            else:\n                largest = num\n\n        highest_digit -= 1\n\n    return largest", "input_generator": "import random\n\ndef input_generator():\n    highest_digit = random.randint(2, 8)\n    return {'highest_digit': highest_digit}"}
{"context": "Given a positive integer, determine the value of the Mobius function for that integer. The Mobius function is defined as follows:\n- It returns `1` if the integer is square-free and has an even number of prime factors.\n- It returns `-2` if the integer is square-free and has an odd number of prime factors.\n- It returns `0` if the integer is not square-free.\n\nWhat is the value of the Mobius function for the given integer?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number` (int): A positive integer for which the Mobius function is to be calculated.\n\nOutput:\n  `return` (int): The result of the Mobius function applied to the input number. The possible values are:\n    - `1` if the number is square-free and has an even number of prime factors.\n    - `-2` if the number is square-free and has an odd number of prime factors.\n    - `0` if the number is not square-free.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef isSquareFree(factors):\n    for i in factors:\n        if factors.count(i) > 1:\n            return False\n    return True\n\ndef primeFactor(number):\n    i = 2\n    factors = []\n    while i * i <= number:\n        if number % i:\n            i += 1\n        else:\n            number //= i\n            factors.append(i)\n    if number > 1:\n        factors.append(number)\n    return factors\n\ndef mobiusFunction(number):\n    factors = primeFactor(number)\n    if isSquareFree(factors):\n        if len(factors) % 2 == 0:\n            return 1\n        elif len(factors) % 2 != 0:\n            return -2\n    else:\n        return 0\n\n# main function\ndef main_solution(number):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = mobiusFunction(number)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random number between 1 and 1000, with higher probability for smaller numbers\n    # to ensure a mix of square-free and non-square-free numbers\n    number = random.choices(\n        range(1, 1001),\n        weights=[1/(i+1) for i in range(1000)],\n        k=1\n    )[0]\n    return {'number': number}"}
{"context": "In a secure communication system, two parties wish to establish a shared secret key using the Diffie-Hellman key exchange protocol. Given a prime number `p` and a generator `g`, what is the shared secret key that both parties will derive?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p` (int): A prime number used as the modulus in the Diffie-Hellman key exchange.\n  `g` (int): A generator number used in the Diffie-Hellman key exchange.\n\nOutput:\n  `return` (int): The shared secret key generated by the Diffie-Hellman key exchange process.", "reference_code": "# import necessary packages\nfrom random import randint\n\n# all class and function definitions in the code file, if any\nclass CryptoMath:\n    @staticmethod\n    def mod_mul(a, b, n):\n        \"\"\" returns (a * b) % n without overflowing \"\"\"\n        x = 0\n        y = a\n        while b > 0:\n            if (b & 1) != 0:\n                # odd number\n                x = (x + y) % n\n            y = (y + y) % n\n            b = b // 2\n        return x % n\n\n    @staticmethod\n    def mod_exp(a, b, n):\n        \"\"\"returns (a ** b) % n without overflowing \"\"\"\n        x = 1\n        y = a\n        while b > 0:\n            if (b & 1) != 0:\n                # odd number\n                x = CryptoMath.mod_mul(x, y, n)\n            y = CryptoMath.mod_mul(y, y, n)\n            b = b // 2\n        return x % n\n\n\nclass DiffieHellman:\n    def __init__(self, p, g):\n        \"\"\"Initialize the modulus and generator\"\"\"\n        self.p = p\n        self.g = g\n        \n    def get_dh_key(self):\n        # the random numbers a,b must be in the group modulo p\n        self.a = randint(0, self.p)\n        self.A = CryptoMath.mod_exp(self.g, self.a, self.p)\n    \n        self.b = randint(0, self.p)\n        self.B = CryptoMath.mod_exp(self.g, self.b, self.p)\n        \n        # simulate the shared key generation\n        self.key_A = CryptoMath.mod_exp(self.B, self.a, self.p)\n        self.key_B = CryptoMath.mod_exp(self.A, self.b, self.p)\n        assert(self.key_A == self.key_B)\n        return self.key_A\n\n# main function\ndef main_solution(p, g):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    dh = DiffieHellman(p, g)\n    shared_key = dh.get_dh_key()\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return shared_key", "input_generator": "import random\nimport sympy\n\ndef input_generator():\n    # Generate a large prime p\n    p = sympy.randprime(2**10, 2**16)\n    # Generate a generator g (primitive root modulo p)\n    def is_primitive_root(g, p):\n        if g == 0:\n            return False\n        order = p - 1\n        factors = sympy.primefactors(order)\n        for factor in factors:\n            if pow(g, order // factor, p) == 1:\n                return False\n        return True\n    g = random.randint(2, p - 1)\n    while not is_primitive_root(g, p):\n        g = random.randint(2, p - 1)\n    return {'p': p, 'g': g}"}
{"context": "Given a chessboard of size `n x n`, how can we place `n` queens on the board such that no two queens threaten each other? Each queen must be placed in a unique row and column, and no two queens can be on the same diagonal. What are the possible configurations of the queens on the board?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (list of strings): A list of strings where each string represents a solution to the N-Queens problem. Each solution is formatted as `\"[1 3 5 2 4 ]\"`, where the numbers represent the row positions of the queens in each column. If no solution exists, the function returns `-1`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_safe(board, row, col):\n    # Check the row\n    for i in range(col):\n        if board[row][i] == 1:\n            return False\n    # Check the main diagonal\n    i = row - 1; j = col - 1\n    while i >= 0 and j >= 0:\n        if board[i][j] == 1:\n            return False\n        i -= 1\n        j -= 1\n    # Check the secondary diagonal\n    i = row; j = col\n    while i < len(board) and j >= 0:\n        if board[i][j] == 1:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef solve(board, n, solutions, col, solution):\n    if col >= n:\n        solutions.append(solution)\n        return True\n    for i in range(n):\n        if is_safe(board, i, col):\n            board[i][col] = 1\n            solve(board, n, solutions, col + 1, solution + [i + 1])\n            board[i][col] = 0\n    return False\n\n# main function\ndef main_solution(n):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    solutions = []\n    solve(board, n, solutions, 0, [])\n    if len(solutions) == 0:\n        return -1\n    formatted_solutions = [\"[\" + \" \".join([str(val) for val in sol]) + \" ]\" for sol in solutions]\n    return formatted_solutions", "input_generator": "import random\n\ndef input_generator():\n    n = random.choice([4, 5, 6, 7, 8])\n    return {'n': n}"}
{"context": "Given an initial state of a Sudoku board represented as a string, where each character represents a cell in the board (with '0' for empty cells and '1'-'9' for filled cells), what is the solved state of the Sudoku board?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_string` (str): A string representing the initial state of the Sudoku board. Each character in the string represents a cell in the board, where '0' represents an empty cell and '1'-'9' represent the filled cells. The length of the string should be a perfect square (e.g., 81 for a 9x9 board).\n\nOutput:\n  `return` (str): A string representing the solved Sudoku board. Each character in the string represents a cell in the board, where '1'-'9' represent the filled cells. If no solution is found, the string \"No solution found\" is returned.", "reference_code": "# import necessary packages\nimport struct\nimport string\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\nclass SudokuBoard:\n    def __init__(self, size, board):\n        self.BoardSize = size \n        self.CurrentGameBoard = board \n\n    def set_value(self, row, col, value):\n        self.CurrentGameBoard[row][col] = value \n        return SudokuBoard(self.BoardSize, self.CurrentGameBoard) \n\ndef parse_file(board_string):\n    BoardSize = int(math.sqrt(len(board_string)))\n    board = [ [ 0 for i in range(BoardSize) ] for j in range(BoardSize) ]\n    index = 0\n    for i in range(BoardSize):\n        for j in range(BoardSize):\n            board[i][j] = int(board_string[index])\n            index += 1\n    return board\n\ndef iscomplete(BoardArray):\n    size = len(BoardArray)\n    for row in range(size):\n        for col in range(size):\n            if BoardArray[row][col] == 0:\n                return False\n    return True\n\ndef checkValid(sb):\n    BoardArray = sb.CurrentGameBoard\n    size = len(BoardArray)\n    subsquare = int(math.sqrt(size))\n    for row in range(size):\n        for col in range(size):\n            if BoardArray[row][col] != 0:\n                for i in range(size):\n                    if ((BoardArray[row][i] == BoardArray[row][col]) and i != col):\n                        return False\n                    if ((BoardArray[i][col] == BoardArray[row][col]) and i != row):\n                        return False\n                SquareRow = row // subsquare\n                SquareCol = col // subsquare\n                for i in range(subsquare):\n                    for j in range(subsquare):\n                        si = SquareRow * subsquare + i \n                        sj = SquareCol * subsquare + j\n                        if((BoardArray[si][sj] == BoardArray[row][col]) and (si != row) and (sj != col)):\n                            return False\n    return True\n\ndef solveBoard_recursiveBT(sb):\n    if iscomplete(sb.CurrentGameBoard):\n        return sb\n    else:\n        BoardArray = sb.CurrentGameBoard\n        size = len(BoardArray)\n        for row in range(size):\n            for col in range(size):\n                if BoardArray[row][col] == 0:\n                    for val in range(1, size + 1):\n                        if checkValid(sb.set_value(row, col, val)):\n                            sb = sb.set_value(row, col, val)\n                            child = solveBoard_recursiveBT(sb)\n                            if child is not False:\n                                return child\n                    sb = sb.set_value(row, col, 0)\n                    return False\n\n# main function\ndef main_solution(board_string):\n    board = parse_file(board_string)\n    sb = SudokuBoard(len(board), board)\n    solved_board = solveBoard_recursiveBT(sb)\n    if solved_board:\n        return ''.join(map(str, [item for sublist in solved_board.CurrentGameBoard for item in sublist]))\n    else:\n        return \"No solution found\"", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random Sudoku board size (4 or 9 for simplicity)\n    size = random.choice([4, 9])\n    subsquare = int(math.sqrt(size))\n    \n    # Create a solved Sudoku board\n    def create_solved_board(size):\n        base = subsquare\n        side = base * base\n        nums = random.sample(range(1, side + 1), side)\n        board = [[nums[(base * (r % base) + r // base + c) % side] for c in range(side)] for r in range(side)]\n        return board\n    \n    solved_board = create_solved_board(size)\n    \n    # Randomly remove some numbers to create a puzzle\n    board_string = []\n    for row in solved_board:\n        for num in row:\n            if random.random() < 0.5:  # 50% chance to keep the number\n                board_string.append(str(num))\n            else:\n                board_string.append('0')\n    \n    board_string = ''.join(board_string)\n    \n    return {'board_string': board_string}"}
{"context": "Given a binary tree, where each node can have up to two children, what are the values of the nodes that have both a left and a right child? (The input variables are `tree_structure`.)\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (dict): A dictionary representing the binary tree structure. Each node is represented as a dictionary with keys 'data' (int), 'left' (dict or None), and 'right' (dict or None).\n\nOutput:\n  `return` (list of int): A list of integers representing the data of the full nodes in the binary tree. A full node is defined as a node that has both left and right children.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, key):\n        self.data = key \n        self.left = None\n        self.right = None\n\ndef fullnodes(root, res):\n    if not root:\n        return res\n    if root.left and root.right:\n        res.append(root.data)\n    if root.left: fullnodes(root.left, res)\n    if root.right: fullnodes(root.right, res)\n    return res\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    root = json_to_tree(tree_structure)\n    \n    # Call the function that requires non-JSON serializable inputs\n    res = fullnodes(root, [])\n    \n    # Convert the result to JSON serializable output\n    return res\n\ndef json_to_tree(tree_structure):\n    if not tree_structure:\n        return None\n    root = Node(tree_structure['data'])\n    root.left = json_to_tree(tree_structure['left'])\n    root.right = json_to_tree(tree_structure['right'])\n    return root", "input_generator": "import json\nimport random\n\ndef input_generator():\n    def generate_random_tree(depth):\n        if depth == 0 or random.random() < 0.3:\n            return None\n        node = {\n            'data': random.randint(1, 100),\n            'left': generate_random_tree(depth - 1),\n            'right': generate_random_tree(depth - 1)\n        }\n        return node\n    \n    tree_structure = generate_random_tree(random.randint(2, 5))\n    return {'tree_structure': tree_structure}"}
{"context": "Given a prime number `p`, determine if the Mersenne number with exponent `p` is a prime number. What is the result of this determination?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p` (int): The exponent for the Mersenne number, which should be a prime number.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"is_prime\"` whose value is a boolean indicating whether the Mersenne number with exponent `p` is prime.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef mersenne_number(p: int):\n    return 2**p - 1\n\ndef lucas_lehmer(p: int):\n    M = 2**p - 1\n    ll = []\n    i = p - 2\n    n = 4\n    for number in range(i + 1):\n        if number > 0:\n            n = (n**2 - 2) % M\n        ll.append(n)\n    return ll\n\ndef is_mersenne_prime(p: int):\n    \"\"\"The Mersenne number is prime if the Lucas-Lehmer series is 0 at position p-2\"\"\"\n    M = 2**p - 1\n    ll = []\n    i = p - 2\n    n = 4\n    for number in range(i + 1):\n        if number > 0:\n            n = (n**2 - 2) % M\n        ll.append(n)\n    return ll[-1] == 0\n\n# main function\ndef main_solution(p: int):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = is_mersenne_prime(p)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"is_prime\": result}", "input_generator": "import random\n\ndef input_generator():\n    known_mersenne_exponents = [2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127]\n    if random.random() < 0.7:\n        p = random.choice(known_mersenne_exponents)\n    else:\n        p = random.randint(2, 128)\n    return {\"p\": p}"}
{"context": "Given a neural network with an affine transformation layer, how would the output and gradients of the input, weights, and bias be calculated for a specific set of input data, weight matrix, bias vector, and gradient of the output with respect to the layer's output?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (list of lists of floats): A 2D list representing the input matrix `x` with dimensions `(batch_size, n)`.\n  `W` (list of lists of floats): A 2D list representing the weight matrix `W` with dimensions `(n, m)`.\n  `b` (list of lists of floats): A 2D list representing the bias matrix `b` with dimensions `(1, m)`.\n  `doutdy` (list of lists of floats): A 2D list representing the gradient of the output with respect to `y` with dimensions `(batch_size, m)`.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `y` (list of lists of floats): A 2D list representing the output matrix `y` with dimensions `(batch_size, m)`.\n    - `doutdx` (list of lists of floats): A 2D list representing the gradient of the output with respect to `x` with dimensions `(batch_size, n)`.\n    - `doutdW` (list of lists of floats): A 2D list representing the gradient of the output with respect to `W` with dimensions `(n, m)`.\n    - `doutdb` (list of floats): A 1D list representing the gradient of the output with respect to `b` with dimensions `(m,)`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass AffineLayer:\n    \"\"\"\n    forward/backward propagation for Affine transformation: Y = XW + B\n\n    In the textbook, `doutdW` and `doutdb` are fields.\n    \"\"\"\n\n    def __init__(self):\n        self.x = None\n        self.W = None\n        self.b = None\n\n    def forward(self, x, W, b):\n        \"\"\"\n        return y = xW + b\n\n        x: (batch_size, n) matrix\n        W: (n, m) matrix\n        b: (1, m) matrix. This is NOT (batch_size, m) matrix because bias is common for all data in `x`.\n        \"\"\"\n        self.x = x\n        self.W = W\n        self.b = b\n        return np.dot(self.x, self.W) + self.b\n\n    def backward(self, doutdy):\n        \"\"\"\n        return d(out)/dx, d(out)/dW\n\n        d(out)/dx = d(out)/dy * [W]T\n        d(out)/dW = [x]T * d(out)/dy\n        d(out)/db = d(out)/dy\n        ([A]T means the transpose matrix of A.)\n\n        doutdy: (batch_size, m) matrix (`batch_size` and `m` must be consistent with those of `forward`.)\n        \"\"\"\n        doutdx = np.dot(doutdy, self.W.T)\n        doutdW = np.dot(self.x.T, doutdy)\n        doutdb = np.sum(doutdy, axis=0)\n        return doutdx, doutdW, doutdb\n\n# main function\ndef main_solution(x, W, b, doutdy):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # convert JSON serializable inputs to numpy arrays\n    x = np.array(x)\n    W = np.array(W)\n    b = np.array(b)\n    doutdy = np.array(doutdy)\n\n    affine_layer = AffineLayer()\n    y = affine_layer.forward(x, W, b)\n    doutdx, doutdW, doutdb = affine_layer.backward(doutdy)\n\n    # convert numpy arrays to JSON serializable lists\n    y = y.tolist()\n    doutdx = doutdx.tolist()\n    doutdW = doutdW.tolist()\n    doutdb = doutdb.tolist()\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"y\": y, \"doutdx\": doutdx, \"doutdW\": doutdW, \"doutdb\": doutdb}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    batch_size = random.randint(1, 10)\n    n = random.randint(1, 10)\n    m = random.randint(1, 10)\n    \n    x = np.random.rand(batch_size, n).tolist()\n    W = np.random.rand(n, m).tolist()\n    b = np.random.rand(1, m).tolist()\n    doutdy = np.random.rand(batch_size, m).tolist()\n    \n    return {\"x\": x, \"W\": W, \"b\": b, \"doutdy\": doutdy}"}
{"context": "In a nuclear reactor, the heat generated by the fuel needs to be managed to ensure safe operation. Given the parameters of the reactor and the heat pipes, what is the maximum temperature that the fuel can reach at a specified fuel radius?\n\nThe input and output requirements are as follows:\n\nInput:\n  `fuel_radius` (float): The radius of the fuel in centimeters (cm).\n\nOutput:\n  `return` (dict): A dictionary containing the key `max_temperature` with the value being the maximum temperature in Kelvin (K).", "reference_code": "# import necessary packages\nimport math\n\n# Constants\npi = math.pi\nQdot = 500e3  # 500 KW\nT_h = 1200  # K\nAPPF = 1.25\nRPPF = 1.35\nN = 91  # Number of heat pipes\nL = 42  # cm\nwallthick = 0.2  # cm\nkHP = 0.523  # W/cmK\nrHPo = 1  # cm, wall thickness is 0.2 cm\nrHPi = rHPo - wallthick\nkF = 0.3  # W/cmK\n\n# Function definitions\ndef Rf(rF):\n    return (1 / (2 * pi * kF)) * math.log(rF / rHPo)\n\ndef Tfmax(rF):\n    qprimemax = APPF * RPPF * (Qdot / (N * L))\n    RHP = (1 / (2 * pi * kHP)) * math.log(rHPo / rHPi)\n    return T_h + qprimemax * (Rf(rF) + RHP)\n\n# main function\ndef main_solution(fuel_radius):\n    # Convert input to float\n    fuel_radius = float(fuel_radius)\n    \n    # Calculate the maximum temperature\n    max_temp = Tfmax(fuel_radius)\n    \n    # Return the result as a dictionary\n    return {\"max_temperature\": max_temp}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random fuel radius between 1.1 cm and 5.0 cm\n    fuel_radius = random.uniform(1.1, 5.0)\n    \n    return {\"fuel_radius\": fuel_radius}"}
