{"context": "Given a position in the Fibonacci sequence and a modulo value, what is the result of the Fibonacci number at that position modulo the given value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The position in the Fibonacci sequence.\n  `m` (int): The modulo value.\n\nOutput:\n  `return` (int): The result of the Fibonacci number at position `n` modulo `m`.", "reference_code": "# import necessary packages\nimport sys\n\n# main function\ndef main_solution(n, m):\n    # Convert JSON serializable inputs to the required format\n    n = int(n)\n    m = int(m)\n\n    # Function to calculate the huge Fibonacci number modulo m\n    def get_fibonacci_huge(n, m):\n        if n == 0:\n            return 0\n\n        fib = {0: 0, 1: 1}\n        mod = {0: 0, 1: 1}\n\n        i = 2\n\n        while True:\n            fib.setdefault(i, mod.get(i - 1) + mod.get(i - 2))\n            mod.setdefault(i, fib.get(i) % m)\n            if mod[i - 1] == 0 and mod[i] == 1:\n                break\n            i += 1\n\n        remainder = n % (i - 1)\n        return fib.get(remainder) % m\n\n    # Get the result\n    result = get_fibonacci_huge(n, m)\n\n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(0, 10**6)\n    m = random.randint(2, 10**5)\n    return {'n': n, 'm': m}", "io_pairs": [{"input": {"n": 340285, "m": 31490}, "output": 4655}, {"input": {"n": 390036, "m": 42507}, "output": 20637}, {"input": {"n": 139445, "m": 33630}, "output": 22535}, {"input": {"n": 689468, "m": 59713}, "output": 19198}, {"input": {"n": 609839, "m": 8596}, "output": 1}, {"input": {"n": 912697, "m": 87976}, "output": 34985}, {"input": {"n": 94681, "m": 65449}, "output": 37911}, {"input": {"n": 126165, "m": 27690}, "output": 24260}, {"input": {"n": 462534, "m": 16760}, "output": 1712}, {"input": {"n": 864018, "m": 41226}, "output": 24892}], "error_log": []}
{"context": "In a game of strategy, a player is faced with a pile of cakes, one of which is poisoned. The player must decide whether to go first or second and then make moves to avoid eating the last cake. Each move consists of taking one, two, or three cakes, but the player cannot repeat the opponent's previous move. Given the initial number of cakes and whether the player is making the first move, what will be the outcome of the game for the player?\n\nThe input and output requirements are as follows:\n\nInput:\n  `cakes` (int): The number of cakes initially on the table.\n  `is_first_move` (bool): A boolean indicating whether the player is making the first move.\n\nOutput:\n  `return` (str): A string indicating the result of the game. Possible values are \"Won\", \"Lost\", or \"Invalid move\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Player:\n    def __init__(self, cakes):\n        pass\n\n    def firstmove(self, cakes):\n        return cakes > 2 and cakes % 4 != 2\n\n    def move(self, cakes, last):\n        return 3 if cakes % 4 < 3 else 1\n\n# main function\ndef main_solution(cakes, is_first_move):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    player = Player(cakes)\n    if is_first_move:\n        if not player.firstmove(cakes):\n            return \"Invalid first move\"\n        last_move = 0\n    else:\n        last_move = random.choice([1, 2, 3])\n    \n    while cakes > 0:\n        if cakes == 1:\n            return \"Lost\"\n        move = player.move(cakes, last_move)\n        if move == last_move:\n            return \"Invalid move\"\n        cakes -= move\n        last_move = move\n    \n    return \"Won\"", "input_generator": "import random\n\ndef input_generator():\n    cakes = random.randint(1, 100)\n    is_first_move = random.choice([True, False])\n    return {'cakes': cakes, 'is_first_move': is_first_move}", "io_pairs": [{"input": {"cakes": 25, "is_first_move": false}, "output": "Invalid move"}, {"input": {"cakes": 79, "is_first_move": false}, "output": "Invalid move"}, {"input": {"cakes": 39, "is_first_move": true}, "output": "Won"}, {"input": {"cakes": 18, "is_first_move": false}, "output": "Won"}, {"input": {"cakes": 3, "is_first_move": true}, "output": "Won"}, {"input": {"cakes": 47, "is_first_move": true}, "output": "Won"}, {"input": {"cakes": 78, "is_first_move": false}, "output": "Won"}, {"input": {"cakes": 80, "is_first_move": false}, "output": "Invalid move"}, {"input": {"cakes": 8, "is_first_move": false}, "output": "Invalid move"}, {"input": {"cakes": 43, "is_first_move": false}, "output": "Won"}], "error_log": []}
{"context": "In an alien language that uses the Latin alphabet, the order of letters is unknown. You have received a list of words that are sorted lexicographically according to the rules of this language. What is the order of the letters in this alien language based on the given list of words?\n\nThe input and output requirements are as follows:\n\nInput:\n  `words` (List[str]): A list of non-empty strings representing words sorted lexicographically by the rules of the alien language.\n\nOutput:\n  `return` (str): A string representing the order of letters in the alien language. If the order is invalid, it returns an empty string.", "reference_code": "# import necessary packages\nfrom collections import defaultdict, deque\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def alienOrder(self, words: List[str]) -> str:\n        G = self.construct_graph(words)\n        visited = defaultdict(int)  # 0 not visited, 1 visiting, 2 visited\n        ret = deque()\n        for u in G.keys():\n            if visited[u] == 0:\n                if not self.topo_dfs(G, u, visited, ret):\n                    return \"\"\n\n        return \"\".join(ret)\n\n    def construct_graph(self, words):\n        G = defaultdict(list)\n        # need to initialize, consider test case [\"z\", \"z\"]\n        for w in words:  # error\n            for c in w:\n                G[c]\n\n        for i in range(len(words) - 1):  # compare word_i and word_{i+1}\n            for c1, c2 in zip(words[i], words[i+1]):\n                if c1 != c2:  # lexical order\n                    G[c1].append(c2)\n                    break  # need to break for lexical order\n\n        return G\n\n    def topo_dfs(self, G, u, visited, ret):\n        \"\"\"\n        Topological sort\n        G = defaultdict(list)\n        visited = defaultdict(int)  # 0 not visited, 1 visiting, 2 visited\n\n        pre-condition: u is not visited (0)\n        \"\"\"\n        visited[u] = 1\n        for nbr in G[u]:\n            if visited[nbr] == 1:\n                return False\n            if visited[nbr] == 0:\n                if not self.topo_dfs(G, nbr, visited, ret):\n                    return False\n\n        visited[u] = 2\n        ret.appendleft(u)  # visit larger first\n        return True\n\n# main function\ndef main_solution(words: List[str]) -> str:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.alienOrder(words)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nfrom typing import List\n\ndef input_generator():\n    # Define possible characters for the alien language\n    chars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n             'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    \n    # Randomly select a subset of characters to use\n    num_chars = random.randint(3, 10)\n    selected_chars = random.sample(chars, num_chars)\n    \n    # Generate a random order for the selected characters\n    random_order = selected_chars.copy()\n    random.shuffle(random_order)\n    \n    # Generate words based on the random order\n    num_words = random.randint(2, 10)\n    words = []\n    for _ in range(num_words):\n        word_length = random.randint(1, 5)\n        word = ''.join(random.choices(random_order, k=word_length))\n        words.append(word)\n    \n    # Ensure the words are lexically ordered based on the random_order\n    words.sort(key=lambda word: [random_order.index(c) for c in word])\n    \n    return {'words': words}", "io_pairs": [{"input": {"words": ["khhh", "hcckk", "hkcy"]}, "output": "yckh"}, {"input": {"words": ["azcwz", "pz", "cn", "xwa"]}, "output": "nwzapcx"}, {"input": {"words": ["w", "w", "wi", "wi", "winp", "wkwm", "p", "pinwp", "nm"]}, "output": "mikwpn"}, {"input": {"words": ["qwc", "qtqc", "w", "f", "t", "tqt", "twqf"]}, "output": "cqwft"}, {"input": {"words": ["w", "swwew", "ssw", "ses", "ew", "ee"]}, "output": "wse"}, {"input": {"words": ["wewv", "wem", "o", "e", "eu", "em", "eoemo"]}, "output": "uvwmoe"}, {"input": {"words": ["vtsks", "dyvc", "kct", "rcyy"]}, "output": "cystvdkr"}, {"input": {"words": ["bexx", "u", "xzsp"]}, "output": "pszebux"}, {"input": {"words": ["t", "tsuy", "tauyu", "ssy", "sycty", "suuc", "yca", "a", "u"]}, "output": "ctsyau"}, {"input": {"words": ["au", "d", "d", "wu"]}, "output": "uadw"}], "error_log": []}
{"context": "Given a binary search tree, how can we transform it into an ordered doubly linked list where each node's left pointer points to the previous node and the right pointer points to the next node in the sequence? What is the sequence of values in the resulting doubly linked list?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (dict): A dictionary representing the structure of the binary search tree. Each key-value pair represents a node in the tree. The keys are:\n    - `value` (int): The value of the node.\n    - `left` (dict or None): The left child of the node, represented as another tree structure dictionary. If there is no left child, this is `None`.\n    - `right` (dict or None): The right child of the node, represented as another tree structure dictionary. If there is no right child, this is `None`.\n\nOutput:\n  `return` (list of int): A list of integers representing the values of the nodes in the doubly linked list, in the order they appear from head to tail.", "reference_code": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    left, right = None, None\n    def __init__(self, data):\n        self.value = data\n\ndef in_order_to_queue(head, queue):\n    if not head:\n        return\n    in_order_to_queue(head.left, queue)\n    queue.append(head)\n    in_order_to_queue(head.right, queue)\n\ndef process(head):\n    if not head:\n        return None\n    leftE = process(head.left)\n    rightE = process(head.right)\n    leftS = leftE.right if leftE else None\n    rightS = rightE.right if rightE else None\n    if leftE and rightE:\n        leftE.right = head\n        head.right = rightS\n        rightS.left = head\n        rightE.right = leftS\n        return rightE\n    elif leftE:\n        leftE.right = head\n        head.left = leftE\n        head.right = leftS\n        return head\n    elif rightE:\n        head.right = rightS\n        rightS.left = head\n        rightE.right = head\n        return rightE\n    else:\n        head.right = head\n        return head\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(structure):\n        if not structure:\n            return None\n        node = Node(structure['value'])\n        node.left = build_tree(structure['left'])\n        node.right = build_tree(structure['right'])\n        return node\n\n    head = build_tree(tree_structure)\n    \n    # Convert the binary search tree to a doubly linked list\n    if not head:\n        return None\n    last = process(head)\n    head = last.right\n    last.right = None\n    \n    # Convert the doubly linked list back to a JSON serializable output\n    result = []\n    cur = head\n    while cur:\n        result.append(cur.value)\n        cur = cur.right\n    \n    return result", "input_generator": "import random\nfrom collections import deque\n\ndef input_generator():\n    def generate_tree(depth):\n        if depth == 0 or random.random() < 0.3:\n            return None\n        value = random.randint(1, 100)\n        left = generate_tree(depth - 1)\n        right = generate_tree(depth - 1)\n        return {'value': value, 'left': left, 'right': right}\n    \n    tree_structure = generate_tree(random.randint(1, 5))\n    return {'tree_structure': tree_structure}", "io_pairs": [{"input": {"tree_structure": {"value": 99, "left": null, "right": null}}, "output": [99]}, {"input": {"tree_structure": {"value": 42, "left": null, "right": null}}, "output": [42]}, {"input": {"tree_structure": {"value": 29, "left": null, "right": null}}, "output": [29]}, {"input": {"tree_structure": {"value": 68, "left": null, "right": null}}, "output": [68]}, {"input": {"tree_structure": {"value": 34, "left": null, "right": null}}, "output": [34]}, {"input": {"tree_structure": {"value": 27, "left": null, "right": null}}, "output": [27]}, {"input": {"tree_structure": {"value": 63, "left": null, "right": null}}, "output": [63]}, {"input": {"tree_structure": {"value": 53, "left": null, "right": null}}, "output": [53]}, {"input": {"tree_structure": {"value": 47, "left": null, "right": {"value": 34, "left": null, "right": null}}}, "output": [47, 34]}, {"input": {"tree_structure": {"value": 84, "left": {"value": 63, "left": null, "right": null}, "right": null}}, "output": [63, 84]}], "error_log": []}
{"context": "Given a grid of size R x C, where R is the number of rows and C is the number of columns, and a number M representing the number of mines to be placed in the grid, what is the arrangement of the mines such that there is a safe path from the top-left corner (marked as 'c') to the bottom-right corner without stepping on a mine? The grid should be represented as a string where 'c' marks the starting point, '.' marks safe cells, and '*' marks mines. If no such arrangement is possible, return \"Impossible\".\n\nThe input and output requirements are as follows:\n\nInput:\n- `R` (int): Number of rows in the grid.\n- `C` (int): Number of columns in the grid.\n- `M` (int): Number of mines to be placed in the grid.\n\nOutput:\n- `return` (str): A string representation of the grid with 'c' marking the starting point, '.' marking safe cells, and '*' marking mines. If no valid configuration is possible, returns \"Impossible\".", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(R, C, M):\n    \"\"\"\n    Solves the problem of placing mines in a grid of size R x C with M mines, ensuring that there is a path from the top-left corner to the bottom-right corner without stepping on a mine.\n\n    Args:\n    R (int): Number of rows in the grid.\n    C (int): Number of columns in the grid.\n    M (int): Number of mines to be placed in the grid.\n\n    Returns:\n    str: A string representation of the grid with 'c' marking the starting point, '.' marking safe cells, and '*' marking mines. If no valid configuration is possible, returns \"Impossible\".\n    \"\"\"\n    blanks = R * C - M\n    if blanks <= 0:\n        return \"Impossible\"\n    \n    grid = [['*' for _ in range(C)] for _ in range(R)]\n    \n    if blanks == 1:\n        grid[0][0] = 'c'\n        return '\\n'.join(''.join(row) for row in grid)\n    \n    if R == 1:\n        for i in range(blanks):\n            grid[0][i] = '.'\n        grid[0][0] = 'c'\n        return '\\n'.join(''.join(row) for row in grid)\n    \n    if C == 1:\n        for i in range(blanks):\n            grid[i][0] = '.'\n        grid[0][0] = 'c'\n        return '\\n'.join(''.join(row) for row in grid)\n    \n    if blanks in [2, 3, 5, 7]:\n        return \"Impossible\"\n    \n    rows = 2\n    columns = 2\n    found_match = False\n    \n    while not found_match:\n        leftover = blanks - rows * columns\n        if leftover < 0 or columns > C:\n            rows += 1\n            columns = 2\n        elif leftover == 0:\n            found_match = True\n        elif rows != R and columns != C:\n            if leftover >= 2 and (leftover <= columns or leftover <= rows):\n                found_match = True\n            elif leftover < rows + columns and leftover >= 5:\n                found_match = True\n            else:\n                columns += 1\n        elif rows == R and (leftover <= rows and leftover > 1):\n            found_match = True\n        elif columns == C and (leftover <= columns and leftover > 1):\n            found_match = True\n        else:\n            columns += 1\n        if rows > R:\n            break\n    \n    if not found_match:\n        return \"Impossible\"\n    \n    for i in range(rows):\n        for j in range(columns):\n            grid[i][j] = '.'\n    \n    if leftover <= columns:\n        for i in range(leftover):\n            grid[rows][i] = '.'\n    elif leftover <= rows:\n        for i in range(leftover):\n            grid[i][columns] = '.'\n    else:\n        extra = leftover - 2\n        while C < extra:\n            extra -= 1\n        for i in range(extra):\n            grid[rows][i] = '.'\n        leftover -= extra\n        for i in range(leftover):\n            grid[i][columns] = '.'\n    \n    grid[0][0] = 'c'\n    return '\\n'.join(''.join(row) for row in grid)", "input_generator": "import random\n\ndef input_generator():\n    R = random.randint(1, 20)\n    C = random.randint(1, 20)\n    max_mines = R * C - 1\n    M = random.randint(0, max_mines) if max_mines > 0 else 0\n    return {'R': R, 'C': C, 'M': M}", "io_pairs": [{"input": {"R": 2, "C": 2, "M": 0}, "output": "c.\n.."}, {"input": {"R": 11, "C": 6, "M": 17}, "output": "c.....\n......\n......\n.....*\n.....*\n.....*\n.....*\n.....*\n......\n******\n******"}, {"input": {"R": 5, "C": 19, "M": 71}, "output": "c.......***********\n........***********\n........***********\n*******************\n*******************"}, {"input": {"R": 10, "C": 3, "M": 3}, "output": "c..\n...\n...\n...\n...\n...\n...\n...\n...\n***"}, {"input": {"R": 10, "C": 4, "M": 34}, "output": "c.**\n..**\n..**\n****\n****\n****\n****\n****\n****\n****"}, {"input": {"R": 15, "C": 4, "M": 20}, "output": "c...\n....\n....\n....\n....\n....\n....\n....\n....\n....\n****\n****\n****\n****\n****"}, {"input": {"R": 16, "C": 5, "M": 53}, "output": "c....\n.....\n....*\n....*\n....*\n.....\n*****\n*****\n*****\n*****\n*****\n*****\n*****\n*****\n*****\n*****"}, {"input": {"R": 16, "C": 1, "M": 6}, "output": "c\n.\n.\n.\n.\n.\n.\n.\n.\n.\n*\n*\n*\n*\n*\n*"}, {"input": {"R": 1, "C": 18, "M": 13}, "output": "c....*************"}, {"input": {"R": 12, "C": 7, "M": 67}, "output": "c.....*\n......*\n.....**\n*******\n*******\n*******\n*******\n*******\n*******\n*******\n*******\n*******"}], "error_log": []}
{"context": "Given a chessboard of a certain width, how many distinct ways can you place N queens on the board such that no two queens threaten each other? The queens must be placed in such a way that no two queens share the same row, column, or diagonal. The width of the chessboard is denoted by `board_width`.\n\nThe input and output requirements are as follows:\n\nInput:\n- `board_width` (int): The width of the chessboard, which is also the number of queens to be placed. It must be a positive integer.\n\nOutput:\n- `return` (int): The number of distinct solutions to the N-Queens problem for the given board width.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef isInt(strNum):\n    try:\n        int(strNum)\n        return True\n    except ValueError:\n        return False\n\ndef check(grid, qY, qX, w):\n    # Check all directions for conflicts\n    directions = [(-1, -1), (-1, 1), (1, -1), (1, 1), (0, 1), (1, 0)]\n    for dy, dx in directions:\n        y, x = qY + dy, qX + dx\n        while 0 <= y < w and 0 <= x < w:\n            if grid[y][x] == \"Q\":\n                return False\n            y += dy\n            x += dx\n    return True\n\ndef nFor(grid, y, depth, size, answers):\n    if depth <= 0:\n        return\n    for i in range(size):\n        if check(grid, y, i, size):\n            grid[y][i] = \"Q\"\n            if depth == 1:\n                answers[0] += 1\n            nFor(grid, y + 1, depth - 1, size, answers)\n        grid[y][i] = \"\"\n\n# main function\ndef main_solution(board_width):\n    # Initialize the grid and other variables\n    grid = [[\" \" for _ in range(board_width)] for _ in range(board_width)]\n    answers = [0]\n    \n    # Start the recursive function to find solutions\n    nFor(grid, 0, board_width, board_width, answers)\n    \n    # Return the number of solutions found\n    return answers[0]", "input_generator": "import random\n\ndef input_generator():\n    return {'board_width': random.randint(1, 10)}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "In a secret communication system, a message needs to be encrypted using a transposition cipher. The encryption process involves rearranging the characters of the message based on a key and repeating the process a specified number of times. Given a key, the number of stages, and a plaintext message, what is the resulting encrypted text?\n\nThe input and output requirements are as follows:\n\nInput:\n  `key` (str): A string representing the key used for the transposition cipher.\n  `stage` (int): An integer representing the number of times the transposition cipher should be applied.\n  `plaintext` (str): A string representing the plaintext message to be encrypted.\n\nOutput:\n  `return` (str): A string representing the encrypted text after applying the transposition cipher.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# Method used to encrypt a plain text message given a specific key.\n# The stage will determine the number of time the transposition cipher\n# needs to be completed on the plain text\ndef Transpose_Encrypt(key, stage, plaintext):\n    # Removing non alphabetic characters\n    plaintext = ''.join(char for char in plaintext.lower() if 'a' <= char <= 'z')\n\n    # Getting the lengths of the key and message\n    kLen = len(key)\n    sLen = len(plaintext)\n\n    # Calculating and adding, if necessary, the padding\n    padLen = 0\n    if (sLen % kLen > 0):\n        padLen = kLen - (sLen % kLen)\n    if (padLen > 0):\n        plaintext = plaintext.ljust(sLen + padLen, 'x')\n        sLen = len(plaintext)\n\n    # Getting the order in which the columns will be read\n    kList = [char for char in key.lower()]\n    kListSorted = [char for char in key.lower()]\n    kListSorted.sort()\n    kIndex = []\n    for i in range(kLen):\n        kIndex.append(kList.index(kListSorted[i]))\n        kList[kList.index(kListSorted[i])] = \" \"\n\n    # For loop to do the encryption multiple times if the stage is\n    # greater than 1\n    for sNum in range(stage):\n        if (sNum < 1):\n            sText = plaintext\n\n        # Creating and populating the transposition matrix\n        nCol = kLen\n        nRow = sLen // kLen\n        trans = np.full((nRow, nCol), '')\n\n        tCounter = 0\n        for i in range(nRow):\n            for j in range(nCol):\n                trans[i][j] = sText[tCounter]\n                tCounter += 1\n\n        # Encrypting the plaintext string\n        encryptText = \"\"\n        for i in range(nCol):\n            for j in range(nRow):\n                encryptText += trans[j][kIndex[i]]\n\n        if (stage > 1):\n            sText = encryptText\n\n    # Returning the encrypted string\n    return encryptText\n\n# main function\ndef main_solution(key, stage, plaintext):\n    # Convert input variables to the required format if necessary\n    key = str(key)\n    stage = int(stage)\n    plaintext = str(plaintext)\n\n    # Call the encryption function\n    encrypted_text = Transpose_Encrypt(key, stage, plaintext)\n\n    # Return the encrypted text as a string\n    return encrypted_text", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random key (letters only, length between 3 and 10)\n    key_length = random.randint(3, 10)\n    key = ''.join(random.choice(string.ascii_letters) for _ in range(key_length))\n    \n    # Generate a random stage (between 1 and 5)\n    stage = random.randint(1, 5)\n    \n    # Generate a random plaintext (length between 10 and 50, letters and possibly other characters)\n    plaintext_length = random.randint(10, 50)\n    plaintext = ''.join(random.choice(string.ascii_letters + string.digits + string.punctuation + ' ') for _ in range(plaintext_length))\n    \n    return {'key': key, 'stage': stage, 'plaintext': plaintext}", "io_pairs": [{"input": {"key": "OQkevVUDd", "stage": 3, "plaintext": "\\CXGG8?4wN(&0[v]tqj"}, "output": "xxtwxgcxxjnxqxxxvg"}, {"input": {"key": "TNlz", "stage": 3, "plaintext": "e_:]|G,xX}0dD$LsF>h+>o4EM)@(aIswtMj)@xofp\\g4.&`aJ$"}, "output": "apaxfgejshjoixowfxdsdelmmgtx"}, {"input": {"key": "hZeHVjmPFd", "stage": 1, "plaintext": "#_X?&g^Rjp]x82l3yU-3T.[KB#$`4>cQq7VA=D8"}, "output": "txrcuxxkjqxvlaydpqgb"}, {"input": {"key": "bvDuTG", "stage": 1, "plaintext": "*4kT[T.oV] 4-uFxVr$4}JfpZIB+"}, "output": "kfptviufxvjxorbtxz"}, {"input": {"key": "hhYmN", "stage": 2, "plaintext": "JM4C)NmfXp%nw"}, "output": "jnfmxcnpmw"}, {"input": {"key": "pxBuRlk", "stage": 2, "plaintext": "Q%d=xD$[t/={e856Gx>P/\\ (W/}=o@Q{iVWJS:/E,{w9Bj6pC"}, "output": "sitxjxdcvqxjxxwogxwpxbqdwepe"}, {"input": {"key": "dJhNc", "stage": 3, "plaintext": "06Lu,!Y;5uW_@[ic{x]"}, "output": "luycwuxxxi"}, {"input": {"key": "Vdwk", "stage": 1, "plaintext": "2z^+I^t'oN.l}Hefo?]f'M&ax"}, "output": "iloxoemxznfathfx"}, {"input": {"key": "uwnsAZ", "stage": 1, "plaintext": "V^7_V]Fwe079E|H`^d>Kwg;$&)TS9"}, "output": "egxfkxwwxvhsvdxetx"}, {"input": {"key": "kZnT", "stage": 4, "plaintext": "iA_ym?g1R9O CC+W\\%{{ 0j:;tMz5\\G>VP9;<@M"}, "output": "iymjcxotwacmmpxrgvgz"}], "error_log": []}
{"context": "Given a square matrix of size \\( n \\times n \\) and an integer exponent \\( x \\), what is the resulting matrix when the original matrix is raised to the power \\( x \\), with each element of the resulting matrix taken modulo 1000?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the square matrix (n x n).\n  `x` (int): The exponent to which the matrix should be raised.\n  `a` (list of lists of int): The n x n matrix represented as a list of lists of integers.\n\nOutput:\n  `return` (list of lists of int): The resulting n x n matrix after raising the input matrix `a` to the power `x`, with each element modulo 1000.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef multi_mat(n, m1, m2): \n    result = [[0 for _ in range(n)] for _ in range(n)] #\uacc4\uc0b0 \uacb0\uacfc \ub2f4\ub294 \ud589\ub82c\n\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                result[i][j] += m1[i][k] * m2[k][j] #\ud589\ub82c \uacc4\uc0b0 \uac12\uc744 \uacb0\uacfc \ub2f4\ub294 \ud589\ub82c\uc5d0 \ub123\uc5b4\uc90c\n            result[i][j] %= 1000 #1000\uc73c\ub85c \ub098\ub208 \ub098\uba38\uc9c0\n    \n    return result\n\ndef dev(n, x, mat):\n    if x == 1: #\uc885\ub8cc : x // 2 = n = 0\n        return mat \n    else:\n        tmp = dev(n, x // 2, mat)\n        if x % 2 == 0: #\uc9dd\uc218 \uc81c\uacf1\n            return multi_mat(n, tmp, tmp)\n        else: #\ud640\uc218 \uc81c\uacf1\n            return multi_mat(n, multi_mat(n, tmp, tmp), mat)\n\n# main function\ndef main_solution(n, x, a):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # convert input to the required format for the original functions\n    a = [[int(val) for val in row] for row in a]\n    \n    # call the original function\n    result = dev(n, x, a)\n    \n    # convert the result to a JSON serializable format\n    result = [[val % 1000 for val in row] for row in result]\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Matrix size between 1x1 and 10x10\n    x = random.randint(1, 20)  # Exponent between 1 and 20\n    \n    # Generate a random n x n matrix with elements between 0 and 999\n    a = [[random.randint(0, 999) for _ in range(n)] for _ in range(n)]\n    \n    return {\n        'n': n,\n        'x': x,\n        'a': a\n    }", "io_pairs": [{"input": {"n": 1, "x": 15, "a": [[986]]}, "output": [[776]]}, {"input": {"n": 1, "x": 10, "a": [[302]]}, "output": [[24]]}, {"input": {"n": 2, "x": 2, "a": [[178, 123], [477, 243]]}, "output": [[355, 783], [817, 720]]}, {"input": {"n": 1, "x": 1, "a": [[433]]}, "output": [[433]]}, {"input": {"n": 2, "x": 7, "a": [[28, 606], [255, 827]]}, "output": [[982, 794], [745, 783]]}, {"input": {"n": 2, "x": 19, "a": [[58, 608], [802, 503]]}, "output": [[416, 424], [806, 751]]}, {"input": {"n": 1, "x": 7, "a": [[329]]}, "output": [[409]]}, {"input": {"n": 1, "x": 12, "a": [[356]]}, "output": [[536]]}, {"input": {"n": 2, "x": 10, "a": [[98, 693], [447, 905]]}, "output": [[836, 721], [859, 615]]}, {"input": {"n": 2, "x": 18, "a": [[178, 398], [812, 486]]}, "output": [[768, 400], [600, 168]]}], "error_log": []}
{"context": "Given a puzzle with a starting configuration and a goal configuration, what is the sequence of moves required to transform the starting configuration into the goal configuration using the A* search algorithm with the Manhattan distance heuristic? If the puzzle is unsolvable, indicate so.\n\nThe input and output requirements are as follows:\n\nInput:\n  `init_state` (list of lists of integers): The initial state of the puzzle represented as a 2D list of integers.\n  `goal_state` (list of lists of integers): The goal state of the puzzle represented as a 2D list of integers.\n\nOutput:\n  `return` (list of strings): The sequence of moves to solve the puzzle, or [\"UNSOLVABLE\"] if the puzzle is unsolvable.", "reference_code": "# import necessary packages\nimport math\nfrom datetime import datetime\nfrom queue import PriorityQueue\n\n# all class and function definitions in the code file, if any\nclass Puzzle(object):\n    def __init__(self, init_state, goal_state):\n        self.init_state = init_state\n        self.goal_state = goal_state\n        self.actions = list()\n        self.solvable = False\n        self.maxSize = 1\n        self.solutionDepth = 0\n        self.runtime = 0\n        self.goal_position = {}\n        for x, row in enumerate(goal_state):\n            for y, num in enumerate(row):\n                self.goal_position[num] = (x, y)\n\n    def solve(self):\n        if not self.isSolvable(self.init_state):\n            return [\"UNSOLVABLE\"]\n\n        startTime = datetime.now()\n        stack = PriorityQueue()\n        stack.put([len(self.actions) + self.gethn(self.init_state), self.init_state, self.actions])\n        visited = set()\n        max_stack = 1\n        generated = 1\n\n        while stack.qsize() > 0:\n            if stack.qsize() > max_stack:\n                max_stack = stack.qsize()\n            currNode = stack.get()\n            if self.tuplifyStates(currNode[1]) in visited:\n                continue\n            visited.add(self.tuplifyStates(currNode[1]))\n            if currNode[1] == self.goal_state:\n                endTime = datetime.now()\n                delta = endTime - startTime\n                self.solvable = True\n                self.maxSize = max_stack\n                self.solutionDepth = len(currNode[2])\n                self.runtime = delta\n                self.generated = generated\n                self.explored = len(visited)\n                return currNode[2]\n            successors = self.findSuccessors(currNode)\n            for successor in successors:\n                if self.tuplifyStates(successor[1]) in visited:\n                    continue\n                hn = self.gethn(successor[1]) + len(successor[2])\n                successor[0] = hn\n                stack.put(successor)\n                generated += 1\n            del(currNode)\n\n    def gethn(self, state):\n        distance = 0\n        for x, row in enumerate(state):\n            for y, num in enumerate(row):\n                if num == 0:\n                    continue\n                distance += abs(self.goal_position[num][0] - x) + abs(self.goal_position[num][1] - y)\n        return distance\n\n    def isEven(self, n):\n        return n % 2 == 0\n\n    def checkSmallerAfter(self, arr, i):\n        arrLen = len(arr)\n        check = int(arr[i])\n        count = 0\n        for x in range(i, arrLen):\n            if (int(arr[x]) < check) and int(arr[x]):\n                count = count + 1\n        return count\n\n    def isSolvable(self, state):\n        arrLen = len(state)\n        arrStore = []\n        for arrH in state:\n            for arrV in arrH:\n                arrStore.append(arrV)\n        arrStoreLen = len(arrStore)\n        count = 0\n        for i in range(arrStoreLen):\n            count = count + self.checkSmallerAfter(arrStore, i)\n        if self.isEven(arrLen):\n            [r, c] = self.findBlankSpace(state)\n            countFromBottom = arrLen - r\n            if self.isEven(countFromBottom):\n                return not self.isEven(count)\n            else:\n                return self.isEven(count)\n        else:\n            return self.isEven(count)\n\n    def findSuccessors(self, node):\n        successors = []\n        blankSpace = self.findBlankSpace(node[1])\n        if blankSpace[0] != len(node[1]) - 1:\n            successors.append(self.slideUp(node))\n        if blankSpace[0] != 0:\n            successors.append(self.slideDown(node))\n        if blankSpace[1] != len(node[1]) - 1:\n            successors.append(self.slideLeft(node))\n        if blankSpace[1] != 0:\n            successors.append(self.slideRight(node))\n        return successors\n\n    def findBlankSpace(self, state):\n        for i in range(len(state[0])):\n            for j in range(len(state[0])):\n                if state[i][j] == 0:\n                    return [i, j]\n\n    def slideUp(self, node):\n        state = node[1]\n        n = len(node[1])\n        blankSpace = self.findBlankSpace(state)\n        moves = []\n        for move in node[2]:\n            moves.append(move)\n        moves.append(\"UP\")\n        newState = [[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(n):\n                newState[i][j] = state[i][j]\n        newState[blankSpace[0]][blankSpace[1]] = newState[blankSpace[0] + 1][blankSpace[1]]\n        newState[blankSpace[0] + 1][blankSpace[1]] = 0\n        return [node[0], newState, moves]\n\n    def slideDown(self, node):\n        state = node[1]\n        n = len(node[1])\n        blankSpace = self.findBlankSpace(state)\n        moves = []\n        for move in node[2]:\n            moves.append(move)\n        moves.append(\"DOWN\")\n        newState = [[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(n):\n                newState[i][j] = state[i][j]\n        newState[blankSpace[0]][blankSpace[1]] = newState[blankSpace[0] - 1][blankSpace[1]]\n        newState[blankSpace[0] - 1][blankSpace[1]] = 0\n        return [node[0], newState, moves]\n\n    def slideLeft(self, node):\n        state = node[1]\n        n = len(node[1])\n        blankSpace = self.findBlankSpace(state)\n        moves = []\n        for move in node[2]:\n            moves.append(move)\n        moves.append(\"LEFT\")\n        newState = [[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(n):\n                newState[i][j] = state[i][j]\n        newState[blankSpace[0]][blankSpace[1]] = newState[blankSpace[0]][blankSpace[1] + 1]\n        newState[blankSpace[0]][blankSpace[1] + 1] = 0\n        return [node[0], newState, moves]\n\n    def slideRight(self, node):\n        state = node[1]\n        n = len(node[1])\n        blankSpace = self.findBlankSpace(state)\n        moves = []\n        for move in node[2]:\n            moves.append(move)\n        moves.append(\"RIGHT\")\n        newState = [[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(n):\n                newState[i][j] = state[i][j]\n        newState[blankSpace[0]][blankSpace[1]] = newState[blankSpace[0]][blankSpace[1] - 1]\n        newState[blankSpace[0]][blankSpace[1] - 1] = 0\n        return [node[0], newState, moves]\n\n    def stringifyStates(self, state):\n        return ''.join(''.join(map(str, row)) for row in state)\n\n    def tuplifyStates(self, state):\n        return tuple(map(tuple, state))\n\n# main function\ndef main_solution(init_state, goal_state):\n    puzzle = Puzzle(init_state, goal_state)\n    result = puzzle.solve()\n    return result", "input_generator": "import random\n\ndef input_generator():\n    size = random.choice([3, 4])  # Generate 3x3 or 4x4 puzzles\n    numbers = list(range(size * size))\n    random.shuffle(numbers)\n    \n    # Ensure the initial state is solvable\n    while True:\n        init_state = [numbers[i*size:(i+1)*size] for i in range(size)]\n        puzzle = Puzzle(init_state, [[i*size + j + 1 for j in range(size)] for i in range(size)])\n        puzzle.goal_state[-1][-1] = 0  # Set the last element to 0 for the goal state\n        if puzzle.isSolvable(init_state):\n            break\n        random.shuffle(numbers)\n    \n    goal_state = [[i*size + j + 1 for j in range(size)] for i in range(size)]\n    goal_state[-1][-1] = 0\n    \n    return {\n        'init_state': init_state,\n        'goal_state': goal_state\n    }", "io_pairs": [], "error_log": []}
{"context": "Given a string of characters, how can we determine all possible palindrome permutations that can be formed from it? Specifically, what are the unique palindrome permutations for the given input string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string of characters for which palindrome permutations need to be generated. The string should contain only lowercase letters and should not be empty.\n\nOutput:\n  `return` (list of str): A list of strings, where each string is a unique palindrome permutation of the input string. If no palindrome permutations can be formed, the list will be empty.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\ndef count_letters(string):\n    counts = {'odd': ''}\n    i = 0\n\n    while (i < len(string)):\n        if (string[i] in counts):\n            counts[string[i]] += 1\n        else:\n            counts[string[i]] = 1\n        i += 1\n\n    return counts\n\ndef can_make_palindrome(string, counts):\n    odd = 0\n\n    for k, v in counts.items():\n        if (k != 'odd' and counts[k] & 1):\n            odd += 1\n            counts['odd'] = k\n            if (odd > 1):\n                break\n\n    if (len(string) & 1):\n        return odd == 1\n    else:\n        return odd == 0\n\ndef permute_palindromes(string):\n    palindromes = []\n    counts = count_letters(string)\n\n    if (can_make_palindrome(string, counts)):\n        initial = \"\"\n\n        for k, v in counts.items():\n            if (k != 'odd'):\n                initial += (counts[k] // 2) * k\n\n        permute(list(initial), 0, palindromes, counts['odd'])\n\n    return palindromes\n\ndef swap(string, x, y):\n    temp = string[x]\n    string[x] = string[y]\n    string[y] = temp\n\n    return string\n\ndef permute(string_list, start, palindromes, separator=''):\n    palindrome = \"\".join(string_list) + separator + \"\".join(string_list[::-1])\n    palindromes.append(palindrome)\n\n    i = start\n\n    for i in range(start, len(string_list)):\n        if (string_list[start] != string_list[i]):\n            swap(string_list, start, i)\n            permute(string_list, i+1, palindromes, separator)\n            swap(string_list, start, i)\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a JSON serializable format\n    input_string = str(input_string)\n\n    # Call the permute_palindromes function\n    palindromes = permute_palindromes(input_string)\n\n    # Convert the output to a JSON serializable format\n    palindromes = [str(p) for p in palindromes]\n\n    return palindromes", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 10)\n    chars = random.choices(string.ascii_lowercase, k=length)\n    \n    # Ensure the string can potentially form a palindrome\n    if random.choice([True, False]):\n        half = length // 2\n        first_half = random.choices(string.ascii_lowercase, k=half)\n        second_half = first_half.copy()\n        random.shuffle(second_half)\n        if length % 2 == 1:\n            middle_char = random.choice(string.ascii_lowercase)\n            input_string = ''.join(first_half + [middle_char] + second_half)\n        else:\n            input_string = ''.join(first_half + second_half)\n    else:\n        input_string = ''.join(chars)\n    \n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "zz"}, "output": ["zz"]}, {"input": {"input_string": "useiesu"}, "output": ["useiesu", "sueieus", "esuiuse"]}, {"input": {"input_string": "yjpejepy"}, "output": ["yjpeepjy", "jypeepyj", "jyeppeyj", "pjyeeyjp", "ejpyypje"]}, {"input": {"input_string": "cyhhcy"}, "output": ["cyhhyc", "ychhcy", "hyccyh"]}, {"input": {"input_string": "rcwrfmjt"}, "output": []}, {"input": {"input_string": "qgqqqgq"}, "output": ["qqgqgqq", "gqqqqqg"]}, {"input": {"input_string": "fl"}, "output": []}, {"input": {"input_string": "d"}, "output": ["d"]}, {"input": {"input_string": "evve"}, "output": ["evve", "veev"]}, {"input": {"input_string": "jlj"}, "output": ["jlj"]}], "error_log": []}
{"context": "Given a function \\( f(x) = (x - 3)^2 \\), we want to find the minimum value of this function using Newton's method with backtracking line search. What are the final values of \\( x \\) and \\( f(x) \\) after the method converges, and how many iterations were required to achieve this result, given an initial starting point \\( x_0 \\) and a tolerance level \\( \\epsilon \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x0` (float): The initial starting point for the Newton's method.\n  `error` (float): The tolerance level for stopping the iteration.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `final_x` (float): The final x value after the Newton's method converges.\n    - `final_y` (float): The final y value (objective function value) after the Newton's method converges.\n    - `iterations` (int): The number of iterations taken to converge.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef f(x):\n    return (x - 3) ** 2\n\ndef f_grad(x):\n    return 2 * (x - 3)\n\ndef f_grad_2(x):\n    return 2\n\ndef BacktrackingLineSearch(x0):\n    alpha = 1\n    x = x0\n    rho = 0.8\n    c = 1e-4\n\n    while f(x + alpha * (-f_grad(x))) > f(x) + c * alpha * f_grad(x) * (-f_grad(x)):\n        alpha *= rho\n\n    return alpha\n\n# main function\ndef main_solution(x0, error):\n    # Convert input variables if necessary\n    x0 = float(x0)\n    error = float(error)\n\n    curve_y = [f(x0)]\n    curve_x = [x0]\n\n    lambda_squre = 1\n    while lambda_squre / 2 > error:\n        stepSize = BacktrackingLineSearch(x0)\n        xnt = - (1 / f_grad_2(x0)) * (f_grad(x0))\n        x0 = x0 + stepSize * xnt\n\n        y1 = f(x0)\n        lambda_squre = (f_grad(x0)) * (1 / f_grad_2(x0)) * (f_grad(x0))\n\n        curve_x.append(x0)\n        curve_y.append(y1)\n\n    # Convert output variables if necessary\n    return {\"final_x\": x0, \"final_y\": y1, \"iterations\": len(curve_x)}", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    x0 = random.uniform(-10.0, 10.0)\n    error = 10 ** random.uniform(-6, -2)\n    return {\"x0\": x0, \"error\": error}", "io_pairs": [{"input": {"x0": -6.32276755966668, "error": 8.174121150832476e-06}, "output": {"final_x": 2.9994033428761813, "final_y": 3.5599972340364345e-07, "iterations": 7}}, {"input": {"x0": -5.253315457022902, "error": 0.00030021917042758503}, "output": {"final_x": 2.986794695268763, "final_y": 0.0001743800730448256, "iterations": 5}}, {"input": {"x0": -9.111672486847215, "error": 0.009442506307741325}, "output": {"final_x": 2.9031066201052225, "final_y": 0.009388327067433679, "iterations": 4}}, {"input": {"x0": -2.5019160441435195, "error": 0.0005055234397830798}, "output": {"final_x": 2.9911969343293703, "final_y": 7.749396520141944e-05, "iterations": 5}}, {"input": {"x0": 2.582233425609976, "error": 1.707911798559525e-05}, "output": {"final_x": 2.99665786740488, "final_y": 1.1169850283364702e-05, "iterations": 4}}, {"input": {"x0": 4.774683367287736, "error": 0.0023315470359910697}, "output": {"final_x": 3.014197466938302, "final_y": 0.00020156806746417948, "iterations": 4}}, {"input": {"x0": 1.5219162351567483, "error": 8.187496274455318e-05}, "output": {"final_x": 2.997635065976251, "final_y": 5.5929129366858415e-06, "iterations": 5}}, {"input": {"x0": -7.848742743941683, "error": 0.000488605174721849}, "output": {"final_x": 2.9826420116096934, "final_y": 0.0003012997609580172, "iterations": 5}}, {"input": {"x0": -0.1496260068382469, "error": 1.5771048304334196e-06}, "output": {"final_x": 2.9989921196778115, "final_y": 1.0158227438547123e-06, "iterations": 6}}, {"input": {"x0": 5.362714135113119, "error": 9.750365286044056e-06}, "output": {"final_x": 3.0007560685232364, "final_y": 5.716396118288666e-07, "iterations": 6}}], "error_log": []}
{"context": "Given a sequence of characters, what are all the possible unique arrangements of these characters?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_list` (str or list): A string or list of characters for which permutations need to be generated. If a string is provided, it will be converted to a list of characters.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input characters.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef permutation(lst):\n    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return [lst]\n    l = []\n    for i in range(len(lst)):\n        m = lst[i]\n        rem_lst = lst[:i] + lst[i+1:]\n        for p in permutation(rem_lst):\n            l.append([m] + p)\n    return l\n\n# main function\ndef main_solution(input_list):\n    # Convert the input list to a list of characters if it's a string\n    if isinstance(input_list, str):\n        input_list = list(input_list)\n    \n    # Get all permutations of the input list\n    permutations = permutation(input_list)\n    \n    # Convert the permutations to a JSON serializable format\n    permutations_serializable = [''.join(p) for p in permutations]\n    \n    return permutations_serializable", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    input_type = random.choice(['str', 'list'])\n    \n    if input_type == 'str':\n        chars = random.choices(string.ascii_letters, k=length)\n        input_list = ''.join(chars)\n    else:\n        input_list = random.sample(range(10), length)\n    \n    return {'input_list': input_list}", "io_pairs": [{"input": {"input_list": "K"}, "output": ["K"]}, {"input": {"input_list": "goK"}, "output": ["goK", "gKo", "ogK", "oKg", "Kgo", "Kog"]}, {"input": {"input_list": "Q"}, "output": ["Q"]}, {"input": {"input_list": "aSr"}, "output": ["aSr", "arS", "Sar", "Sra", "raS", "rSa"]}, {"input": {"input_list": "l"}, "output": ["l"]}, {"input": {"input_list": "YF"}, "output": ["YF", "FY"]}, {"input": {"input_list": "xRw"}, "output": ["xRw", "xwR", "Rxw", "Rwx", "wxR", "wRx"]}, {"input": {"input_list": "o"}, "output": ["o"]}, {"input": {"input_list": "b"}, "output": ["b"]}, {"input": {"input_list": "kdQ"}, "output": ["kdQ", "kQd", "dkQ", "dQk", "Qkd", "Qdk"]}], "error_log": []}
{"context": "Given a square matrix, what is the determinant of the matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of floats): A 2D list representing a square matrix. Each sublist represents a row in the matrix.\n\nOutput:\n  `return` (float): The determinant of the input matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix):\n    # Convert the input matrix to a numpy array\n    matrix = np.array(matrix)\n    \n    # Calculate the determinant of the matrix\n    determinant = np.linalg.det(matrix)\n    \n    # Return the determinant as a float\n    return float(determinant)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.randint(2, 5)\n    matrix = np.random.randint(-10, 10, size=(size, size)).tolist()\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[9, -6], [2, 3]]}, "output": 38.99999999999999}, {"input": {"matrix": [[-5, 2, -7], [0, -2, -8], [4, -10, -8]]}, "output": 199.99999999999991}, {"input": {"matrix": [[0, -8], [3, -4]]}, "output": 23.999999999999993}, {"input": {"matrix": [[7, 8, 5], [3, -3, 8], [-3, -9, 3]]}, "output": -2.999999999999969}, {"input": {"matrix": [[0, -2, -9], [0, 7, -1], [-3, -9, 5]]}, "output": -195.0}, {"input": {"matrix": [[4, 5, 5], [0, 6, 2], [3, -6, 9]]}, "output": 203.99999999999994}, {"input": {"matrix": [[0, -2], [3, 2]]}, "output": 6.0}, {"input": {"matrix": [[8, -6, -9], [6, 7, -7], [8, -3, -1]]}, "output": 742.0}, {"input": {"matrix": [[-7, -2, 6], [-2, -4, 6], [6, -8, -10]]}, "output": -408.0000000000003}, {"input": {"matrix": [[9, 4], [8, -6]]}, "output": -85.99999999999997}], "error_log": []}
{"context": "Given a binary tree, determine whether it is symmetrical. A binary tree is symmetrical if it looks the same when reflected across its central axis. What is the result of checking the symmetry of the given binary tree structure?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (list of int or None): A list representing the structure of the binary tree. Each element in the list corresponds to a node's value, with `None` indicating a missing node. The list is structured such that the index represents the node's position in a level-order traversal of the tree. For example, the root node is at index 0, its left child is at index 1, its right child is at index 2, and so on.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetrical. `True` if the tree is symmetrical, `False` otherwise.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isSymmetrical(self, pRoot):\n        def isSame(p, q):\n            if p == None and q == None: return True\n            if p == None or q == None: return False\n            if p.val != q.val: return False\n            return isSame(p.left, q.right) and isSame(p.right, q.left)\n\n        return isSame(pRoot, pRoot)\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(node_list):\n        if not node_list:\n            return None\n        nodes = [TreeNode(val) if val is not None else None for val in node_list]\n        n = len(nodes)\n        for i in range(n):\n            if nodes[i] is not None:\n                left_index = 2 * i + 1\n                right_index = 2 * i + 2\n                if left_index < n:\n                    nodes[i].left = nodes[left_index]\n                if right_index < n:\n                    nodes[i].right = nodes[right_index]\n        return nodes[0]\n\n    pRoot = build_tree(tree_structure)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution()\n    result = solution.isSymmetrical(pRoot)\n    \n    # Convert the result to a JSON serializable output\n    return result", "input_generator": "import random\nfrom random import choice, randint\n\ndef input_generator():\n    def generate_symmetric_tree(depth):\n        if depth == 0:\n            return [random.randint(1, 100)]\n        left = generate_symmetric_tree(depth - 1)\n        right = left.copy()\n        val = random.randint(1, 100)\n        return [val] + left + right\n    \n    def generate_asymmetric_tree(depth):\n        if depth == 0:\n            return [random.randint(1, 100)]\n        left = generate_asymmetric_tree(depth - 1)\n        right = generate_asymmetric_tree(depth - 1)\n        if random.random() < 0.5:\n            right[-1] = random.randint(1, 100) if right[-1] is not None else None\n        val = random.randint(1, 100)\n        return [val] + left + right\n    \n    if random.random() < 0.5:\n        depth = randint(0, 3)\n        tree = generate_symmetric_tree(depth)\n    else:\n        depth = randint(1, 3)\n        tree = generate_asymmetric_tree(depth)\n    \n    # Randomly replace some nodes with None\n    for i in range(len(tree)):\n        if random.random() < 0.2:\n            tree[i] = None\n    \n    return {'tree_structure': tree}", "io_pairs": [{"input": {"tree_structure": [17, 67, 67]}, "output": true}, {"input": {"tree_structure": [34]}, "output": true}, {"input": {"tree_structure": [43, 48, null, 42, 42, 5, 42, 42, 48, 5, 42, 42, 5, 42, 42]}, "output": false}, {"input": {"tree_structure": [83, 4, 96, 59, null, 66, 5]}, "output": false}, {"input": {"tree_structure": [null]}, "output": true}, {"input": {"tree_structure": [74, 91, 91]}, "output": true}, {"input": {"tree_structure": [62, 72, null, 26, null, 50, null]}, "output": false}, {"input": {"tree_structure": [14, 19, 19]}, "output": true}, {"input": {"tree_structure": [53, 33, 49, null, 34, 96, null]}, "output": false}, {"input": {"tree_structure": [38, null, 58]}, "output": false}], "error_log": []}
{"context": "Given a range of integers, what are the palindromic prime numbers within that range?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start` (int): The starting point of the range within which to search for palindromic primes.\n  `end` (int): The ending point of the range within which to search for palindromic primes.\n\nOutput:\n  `return` (list of str): A list of strings representing the palindromic primes found between the `start` and `end` values.", "reference_code": "# import necessary packages\nimport sys\nsys.setrecursionlimit(30000)\n\n# all class and function definitions in the code file, if any\ndef isprime(n, i):\n    if n == 1:\n        return False\n    if n == 2:\n        return True\n    \n    if i > int(n**0.5)+1:\n        return True\n    if n%i == 0:\n        return False\n    if i == 2:\n        i += 1\n    else:\n        i += 2\n        \n    return isprime(n,i)\n\ndef palincheck(word):\n    if len(word) < 2: return True\n    if word[0] != word[-1]: return False\n    return palincheck(word[1:-1])\n\ndef find_palindromic_primes(start, end):\n    palindromic_primes = []\n    \n    def ispalin(n, e):\n        if n > e:\n            return\n        \n        n_str = str(n)\n        if palincheck(n_str) == True:\n            if isprime(int(n_str), 2) == True:\n                palindromic_primes.append(n_str)\n         \n        ispalin(int(n_str)+1, e)\n    \n    ispalin(start, end)\n    return palindromic_primes\n\n# main function\ndef main_solution(start, end):\n    # Convert inputs to integers\n    start = int(start)\n    end = int(end)\n    \n    # Find palindromic primes in the given range\n    palindromic_primes = find_palindromic_primes(start, end)\n    \n    # Convert the list of palindromic primes to a JSON serializable format\n    return palindromic_primes", "input_generator": "import random\n\ndef input_generator():\n    # Generate a reasonable range for start and end\n    # Palindromic primes are rare, so we need to choose ranges carefully\n    # Common ranges where palindromic primes exist: 2-1000, but sometimes larger\n    \n    # Randomly choose between small, medium, and large ranges\n    choice = random.randint(0, 2)\n    \n    if choice == 0:\n        # Small range with high probability of palindromic primes\n        start = random.randint(2, 100)\n        end = start + random.randint(10, 100)\n    elif choice == 1:\n        # Medium range with some palindromic primes\n        start = random.randint(100, 1000)\n        end = start + random.randint(50, 200)\n    else:\n        # Larger range, fewer palindromic primes\n        start = random.randint(1000, 10000)\n        end = start + random.randint(100, 500)\n    \n    return {'start': str(start), 'end': str(end)}", "io_pairs": [{"input": {"start": "478", "end": "630"}, "output": []}, {"input": {"start": "5780", "end": "6186"}, "output": []}, {"input": {"start": "671", "end": "800"}, "output": ["727", "757", "787", "797"]}, {"input": {"start": "221", "end": "402"}, "output": ["313", "353", "373", "383"]}, {"input": {"start": "503", "end": "584"}, "output": []}, {"input": {"start": "8333", "end": "8440"}, "output": []}, {"input": {"start": "326", "end": "456"}, "output": ["353", "373", "383"]}, {"input": {"start": "1269", "end": "1744"}, "output": []}, {"input": {"start": "3989", "end": "4224"}, "output": []}, {"input": {"start": "64", "end": "158"}, "output": ["101", "131", "151"]}], "error_log": []}
{"context": "Given a string, how can we generate all unique permutations of the string in lexicographical order?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string for which all unique permutations need to be generated.\n\nOutput:\n  `return` (list of str): A list of all unique permutations of the input string, sorted in lexicographical order.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def Permutation(self, ss):\n        if not ss:\n            return []\n         \n        def Permutation(startIdx):\n            if startIdx >= len(arrSs):\n                clone = ''.join(arrSs)\n                res.append(clone)\n            else:\n                changeIdx = startIdx\n                while changeIdx < len(arrSs):\n                    arrSs[changeIdx], arrSs[startIdx] = arrSs[startIdx], arrSs[changeIdx]\n                    Permutation(startIdx + 1)\n                    arrSs[changeIdx], arrSs[startIdx] = arrSs[startIdx], arrSs[changeIdx]\n                    changeIdx += 1\n         \n        res = []\n        arrSs = list(ss)\n        Permutation(0)\n        res = list(set(res))\n        return sorted(res)\n\n# main function\ndef main_solution(input_string):\n  # Convert the input string to a JSON serializable format\n  input_string = str(input_string)\n  \n  # Create an instance of the Solution class\n  solution = Solution()\n  \n  # Call the Permutation method to get the result\n  result = solution.Permutation(input_string)\n  \n  # Convert the result to a JSON serializable format\n  result = list(result)\n  \n  # Return the result\n  return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 6)\n    chars = random.choices(string.ascii_letters, k=length)\n    input_string = ''.join(chars)\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "k"}, "output": ["k"]}, {"input": {"input_string": "Ox"}, "output": ["Ox", "xO"]}, {"input": {"input_string": "Wbs"}, "output": ["Wbs", "Wsb", "bWs", "bsW", "sWb", "sbW"]}, {"input": {"input_string": "rzw"}, "output": ["rwz", "rzw", "wrz", "wzr", "zrw", "zwr"]}, {"input": {"input_string": "O"}, "output": ["O"]}, {"input": {"input_string": "Gh"}, "output": ["Gh", "hG"]}, {"input": {"input_string": "Rb"}, "output": ["Rb", "bR"]}, {"input": {"input_string": "cGH"}, "output": ["GHc", "GcH", "HGc", "HcG", "cGH", "cHG"]}, {"input": {"input_string": "Qmy"}, "output": ["Qmy", "Qym", "mQy", "myQ", "yQm", "ymQ"]}, {"input": {"input_string": "JtFJ"}, "output": ["FJJt", "FJtJ", "FtJJ", "JFJt", "JFtJ", "JJFt", "JJtF", "JtFJ", "JtJF", "tFJJ", "tJFJ", "tJJF"]}], "error_log": []}
{"context": "Given a set of scrabble tiles, what are the valid words that can be formed using all the tiles?\n\nThe input and output requirements are as follows:\n\nInput:\n  `letters` (str): A string of characters representing the tiles or letters to be used to find anagrams.\n\nOutput:\n  `return` (list of str): A list of strings representing the valid words that can be formed from the given letters.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef ana(beg, end):\n    if len(end) == 1:\n        return [beg + end]\n    \n    f = []\n    for i in range(len(end)):\n        f += [beg + end[i]]\n        f += ana(beg + end[i], end[:i] + end[i+1:])\n    return f\n\ndef anagrams(letters):\n    # Mock dictionary for demonstration purposes\n    dictionary = [\"cat\", \"dog\", \"act\", \"god\", \"tac\", \"odg\"]\n    \n    real_words = []\n    words = ana(\"\", letters)\n    \n    for word in words:\n        if len(word) > 1 and (word in dictionary):\n            real_words.append(word)\n    return real_words\n\n# main function\ndef main_solution(letters):\n    # Convert input to string if necessary\n    letters = str(letters)\n    \n    # Call the anagrams function to get the real words\n    real_words = anagrams(letters)\n    \n    # Return the result as a list of strings\n    return real_words", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Define some common letters that can form actual words (from the mock dictionary)\n    common_letters = ['c', 'a', 't', 'd', 'o', 'g']\n    \n    # Randomly decide the length of the input (between 2 and 6 characters)\n    length = random.randint(2, 6)\n    \n    # Randomly decide whether to use common letters or random letters\n    if random.choice([True, False]):\n        letters = random.sample(common_letters, length)\n    else:\n        letters = random.choices(string.ascii_lowercase, k=length)\n    \n    # Join the letters into a string\n    letters_str = ''.join(letters)\n    \n    return {'letters': letters_str}", "io_pairs": [{"input": {"letters": "gaodct"}, "output": ["god", "act", "odg", "dog", "cat", "tac"]}, {"input": {"letters": "vvs"}, "output": []}, {"input": {"letters": "xla"}, "output": []}, {"input": {"letters": "yqeeuj"}, "output": []}, {"input": {"letters": "tc"}, "output": []}, {"input": {"letters": "vler"}, "output": []}, {"input": {"letters": "ruxacu"}, "output": []}, {"input": {"letters": "acgtod"}, "output": ["act", "cat", "god", "tac", "odg", "dog"]}, {"input": {"letters": "tcgoa"}, "output": ["tac", "cat", "act"]}, {"input": {"letters": "cw"}, "output": []}], "error_log": []}
{"context": "In a classroom setting, students are called randomly using a Rolodex system. Given the number of students in the class, what is the expected number of tries required to call each student at least once?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of students in the class. It should be a positive integer.\n\nOutput:\n  `return` (float): The expected number of Rolodex tries to call all students at least once.", "reference_code": "# import necessary packages\nfrom math import factorial\n\n# all class and function definitions in the code file, if any\ndef f(x):\n    return float(x)\n\ndef product(iterable):\n    prod = 1\n    for n in iterable:\n        prod *= n\n    return prod\n\ndef npr(n, r):\n    assert 0 <= r <= n\n    return product(range(n - r + 1, n + 1))\n\ndef ncr(n, r):\n    assert 0 <= r <= n\n    if r > n // 2:\n        r = n - r\n    return npr(n, r) // factorial(r)\n\ndef rolodex(n):\n    inf = int(1e3)\n    so = 0.0\n    for r in range(n, inf):\n        si = 0.0\n        for i in range(n):\n            p1 = f(ncr(n,i))\n            p2 = f((-1)**i)\n            p3 = (1.0 - f((i+1))/f(n))**f((r-1))\n            si += p1*p2*p3\n        so += f(r)*si \n    return so\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = rolodex(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Reasonable range to avoid excessive computation\n    return {'n': n}", "io_pairs": [{"input": {"n": 2}, "output": 2.9999999999999996}, {"input": {"n": 4}, "output": 7.3541666666666625}, {"input": {"n": 7}, "output": 16.64692613196883}, {"input": {"n": 5}, "output": 10.21477777777779}, {"input": {"n": 3}, "output": 4.916666666666667}, {"input": {"n": 10}, "output": 27.453430416984062}, {"input": {"n": 9}, "output": 23.724643043219704}, {"input": {"n": 6}, "output": 13.335339506172836}, {"input": {"n": 1}, "output": 1.0}, {"input": {"n": 8}, "output": 20.117110927521246}], "error_log": []}
{"context": "Given a tree structure where each node contains a string identifier, how can we create an empty tree structure that mimics the original tree's structure and return the contents of the nodes in postorder traversal?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (list of strings): A list representing the structure of the tree. Each string in the list represents the content of a node in the tree. The first element is the root node, and subsequent elements are the children of the root node.\n\nOutput:\n  `return` (list of strings): A list representing the contents of the nodes in the empty tree structure created by the `empty_like` function, in postorder traversal.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    def __init__(self, contents: object = None) -> object:\n        self._parent = None\n        self._children = []\n        self._contents = contents\n\n    @property\n    def contents(self):\n        return self._contents\n\n    @contents.setter\n    def contents(self, value):\n        self._contents = value\n\n    @property\n    def parent(self):\n        return getattr(self, '_parent', None)\n\n    @parent.setter\n    def parent(self, parent):\n        if not isinstance(parent, Node):\n            raise ValueError(\"A parent node must be itself a Node.\")\n        parent.add_child(self)\n\n    @property\n    def children(self):\n        return self._children\n\n    def add_child(self, child) -> None:\n        if not isinstance(child, Node):\n            raise ValueError(\"A child must be itself a Node.\")\n        descendents = [person for person in PostorderTree(self)][:-1]\n        if self in descendents:\n            raise ValueError(\"A child cannot be in its own line of descent.\")\n        for sibling in self._children:\n            if sibling is child:\n                return\n        child._parent = self\n        self._children.append(child)\n\n    def remove_child(self, orphan) -> None:\n        for i in reversed(range(len(self.children))):\n            if self._children[i] is orphan:\n                del self._children[i]\n\nclass BinaryNode(Node):\n    def __init__(self, contents=None):\n        super().__init__(contents=contents)\n        self._children = [None, None]\n\n    @property\n    def left(self):\n        return self._children[0]\n\n    @left.setter\n    def left(self, child):\n        if child is self._children[0]:\n            return\n        del self._children[0]\n        super().add_child(child)\n        self._children = list(reversed(self._children))\n\n    @property\n    def right(self):\n        return self._children[1]\n\n    @right.setter\n    def right(self, child):\n        if child is self._children[1]:\n            return\n        del self._children[1]\n        super().add_child(child)\n\n    def add_child(self, child):\n        raise NotImplementedError(\"Binary nodes have a fixed number of child nodes\")\n\n    def remove_child(self, orphan):\n        if orphan is self.left:\n            del self._children[0]\n            self._children[0] = None\n        elif orphan is self.right:\n            del self._children[1]\n            self._children[1] = None\n\nclass Tree(object):\n    def __init__(self, root=None):\n        self.root = root\n\n    @property\n    def root(self):\n        return getattr(self, '_root', None)\n\n    @root.setter\n    def root(self, root):\n        if not isinstance(root, Node):\n            contents = root\n            self._root = Node(contents)\n        else:\n            self._root = root\n\nclass PostorderTree(Tree):\n    def __init__(self, root=None):\n        super().__init__(root)\n\n    def __iter__(self):\n        for child in self.root._children:\n            for nextgen in PostorderTree(child):\n                yield nextgen\n        yield self.root\n\nLRNTree = PostorderTree\n\ndef empty_like(root, basetype=None):\n    if basetype is None:\n        basetype = type(root)\n    top = basetype()\n    for child in root.children:\n        top.add_child(empty_like(child, basetype))\n    return top\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    root = Node(tree_structure[0])\n    for child in tree_structure[1:]:\n        root.add_child(Node(child))\n    \n    # Create an empty tree structure like the input tree\n    empty_tree = empty_like(root)\n    \n    # Convert the output to JSON serializable format\n    result = []\n    for node in PostorderTree(empty_tree):\n        result.append(node.contents)\n    \n    return result", "input_generator": "import random\nfrom random import randint\n\ndef input_generator():\n    def generate_tree(depth):\n        if depth == 0:\n            return [random.choice(['A', 'B', 'C', 'D', 'E'])]\n        tree = [random.choice(['X', 'Y', 'Z', 'W'])]\n        num_children = randint(1, 3)\n        for _ in range(num_children):\n            tree.append(generate_tree(depth - 1))\n        return tree\n    \n    depth = randint(1, 4)\n    tree_structure = generate_tree(depth)\n    return {'tree_structure': tree_structure}", "io_pairs": [{"input": {"tree_structure": ["Z", ["B"], ["C"], ["C"]]}, "output": [null, null, null, null]}, {"input": {"tree_structure": ["X", ["X", ["B"]]]}, "output": [null, null]}, {"input": {"tree_structure": ["Z", ["E"], ["A"]]}, "output": [null, null, null]}, {"input": {"tree_structure": ["Z", ["D"]]}, "output": [null, null]}, {"input": {"tree_structure": ["Z", ["E"]]}, "output": [null, null]}, {"input": {"tree_structure": ["W", ["E"], ["D"]]}, "output": [null, null, null]}, {"input": {"tree_structure": ["Y", ["A"]]}, "output": [null, null]}, {"input": {"tree_structure": ["W", ["X", ["D"]], ["Z", ["D"]]]}, "output": [null, null, null]}, {"input": {"tree_structure": ["Z", ["Z", ["E"]]]}, "output": [null, null]}, {"input": {"tree_structure": ["Y", ["C"], ["C"], ["B"]]}, "output": [null, null, null, null]}], "error_log": []}
{"context": "Given a building with `n` floors and two eggs, determine the minimum number of tests required to find the highest floor from which an egg can be dropped without breaking. The eggs can be reused if they do not break, but if an egg breaks, it cannot be used again. What is the minimum number of tests needed to find the threshold floor?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of floors in the building.\n\nOutput:\n  `return` (int): The minimum number of tests required to determine the highest floor from which an egg can be dropped without breaking.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    # @param {int} n an integer\n    # @return {int} an integer\n    def dropEggs(self, n):\n        s = int(math.sqrt(2 * n))\n        while s * (s + 1) < n:\n            s += 1\n        return s\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.dropEggs(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(1, 1000000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 44913}, "output": 299}, {"input": {"n": 787839}, "output": 1255}, {"input": {"n": 567902}, "output": 1065}, {"input": {"n": 295564}, "output": 768}, {"input": {"n": 666086}, "output": 1154}, {"input": {"n": 928794}, "output": 1362}, {"input": {"n": 25549}, "output": 226}, {"input": {"n": 893012}, "output": 1336}, {"input": {"n": 277936}, "output": 745}, {"input": {"n": 5079}, "output": 100}], "error_log": []}
{"context": "In a game of Connect4, how do the rewards for each player accumulate based on a sequence of moves on a custom-sized board with multiple players?\n\nThe input and output requirements are as follows:\n\nInput:\n- `rows` (int): Number of rows in the Connect4 board.\n- `cols` (int): Number of columns in the Connect4 board.\n- `players` (int): Number of players in the game.\n- `player_tokens` (list of str): List of tokens representing each player.\n- `moves` (list of int): List of column indices where players make their moves.\n\nOutput:\n- `return` (dict): Dictionary where keys are player indices (0-based) and values are the cumulative rewards for each player.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Board:\n    def __init__(self, rows=6, cols=7, players=2):\n        self.board = np.zeros((rows, cols)).astype(int)\n        self.rows = self.board.shape[0]\n        self.cols = self.board.shape[1]\n        self.in_play = np.ones(cols).astype(int) * (self.rows - 1)\n\n    def get_board(self):\n        return self.board\n\n    def make_move(self, drop_column, player):\n        if not self.is_full(drop_column):\n            row = self.in_play[drop_column]\n            self.board[row, drop_column] = player\n            self.in_play[drop_column] -= 1\n\n    def is_full(self, drop_column):\n        return self.in_play[drop_column] < 0\n\n\nclass Connect4:\n    def __init__(self, rows=6, cols=7, players=2, player_tokens=[\"O\", \"X\"], l_reward=-1, verbose=False):\n        self.board = Board(rows=rows, cols=cols, players=players)\n        self.player_tokens = player_tokens\n        self.players = players\n        self.player_list = np.arange(players) + 1\n        self.active_player = 1\n        self.living_reward = l_reward\n        self.iteration = 0\n        self.ply = 0\n        self.verbose = verbose\n        self.invalid_move_penalty = -100\n        self.win_reward = 100\n        self.lose_reward = -100\n\n    def step(self, action):\n        self.board.make_move(action, self.active_player)\n        new_state = self.board.get_board()\n        is_done = self.check_for_win(new_state)\n        if self.check_for_draw(self.board):\n            return self.get_draw()\n\n        self.next_turn()\n        reward = self.get_reward(new_state, is_done)\n        extra_stuff = {\"turn\": self.ply, \"iteration\": self.iteration}\n        if self.board.is_full(action):\n            reward = self.invalid_move_penalty\n            extra_stuff.update({\"Error\": \"Invalid Move\"})\n        return new_state, reward, is_done, extra_stuff\n\n    def get_reward(self, new_state, done):\n        rewards = {p: 0 for p in range(self.players)}\n        if done:\n            for p in range(self.players):\n                rewards[p] = self.lose_reward\n            rewards[self.active_player - 1] = self.win_reward\n        else:\n            rewards[self.active_player - 1] = self.living_reward\n        return rewards\n\n    def get_draw(self):\n        rewards = {p: 0 for p in range(self.players)}\n        done = True\n        new_state = self.board.get_board()\n        extra_stuff = {\n            \"turn\": self.ply,\n            \"iteration\": self.iteration,\n            \"error\": \"Board is full. It's a draw\"\n        }\n        return new_state, rewards, done, extra_stuff\n\n    def next_turn(self):\n        self.active_player = self.player_list[(self.active_player - 1) % self.players]\n        self.iteration += 1\n        self.ply = self.iteration / self.players\n\n    def check_for_draw(self, board):\n        for column in range(board.cols):\n            if not board.is_full(column):\n                return False\n        return True\n\n    def check_for_win(self, board):\n        # Check for horizontal win\n        for i in range(self.board.rows):\n            hcount = 0\n            for j in range(self.board.cols):\n                if board[i, j] == self.active_player:\n                    hcount += 1\n                else:\n                    hcount = 0\n                if hcount >= 4:\n                    return True\n\n        # Check for vertical win\n        for j in range(self.board.cols):\n            vcount = 0\n            for i in range(self.board.rows):\n                if board[i, j] == self.active_player:\n                    vcount += 1\n                else:\n                    vcount = 0\n                if vcount >= 4:\n                    return True\n\n        # Diagonal Check\n        for i in range(self.board.rows - 3):\n            for j in range(self.board.cols - 3):\n                if (board[i, j] == self.active_player and\n                        board[i + 1, j + 1] == self.active_player and\n                        board[i + 2, j + 2] == self.active_player and\n                        board[i + 3, j + 3] == self.active_player):\n                    return True\n                if (board[i, j] == self.active_player and\n                        board[i - 1, j - 1] == self.active_player and\n                        board[i - 2, j - 2] == self.active_player and\n                        board[i - 3, j - 3] == self.active_player):\n                    return True\n        return False\n\n# main function\ndef main_solution(rows, cols, players, player_tokens, moves):\n    game = Connect4(rows=rows, cols=cols, players=players, player_tokens=player_tokens)\n    rewards = {p: 0 for p in range(players)}\n    done = False\n    for move in moves:\n        if not done:\n            _, step_rewards, done, _ = game.step(move)\n            for p in range(players):\n                rewards[p] += step_rewards[p]\n    return rewards", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    rows = random.choice([6, 7, 8])\n    cols = random.choice([7, 8, 9])\n    players = random.randint(2, 4)\n    player_tokens = random.sample(['O', 'X', 'Y', 'Z', 'A', 'B'], players)\n    num_moves = random.randint(5, 20)\n    moves = [random.randint(0, cols - 1) for _ in range(num_moves)]\n    \n    return {\n        'rows': rows,\n        'cols': cols,\n        'players': players,\n        'player_tokens': player_tokens,\n        'moves': moves\n    }", "io_pairs": [{"input": {"rows": 6, "cols": 7, "players": 2, "player_tokens": ["B", "Y"], "moves": [4, 4, 5, 5, 5]}, "output": {"0": -5, "1": 0}}, {"input": {"rows": 7, "cols": 7, "players": 3, "player_tokens": ["Y", "X", "O"], "moves": [6, 1, 0, 6, 3]}, "output": {"0": -5, "1": 0, "2": 0}}, {"input": {"rows": 7, "cols": 7, "players": 2, "player_tokens": ["X", "A"], "moves": [6, 1, 5, 1, 5, 5, 6, 2, 2]}, "output": {"0": -9, "1": 0}}, {"input": {"rows": 7, "cols": 7, "players": 2, "player_tokens": ["O", "A"], "moves": [5, 1, 6, 1, 1, 2, 1, 5, 5]}, "output": {"0": 94, "1": -100}}, {"input": {"rows": 7, "cols": 7, "players": 2, "player_tokens": ["X", "O"], "moves": [6, 0, 3, 4, 2, 6]}, "output": {"0": -6, "1": 0}}, {"input": {"rows": 8, "cols": 9, "players": 2, "player_tokens": ["A", "Y"], "moves": [4, 0, 8, 2, 2, 3]}, "output": {"0": -6, "1": 0}}, {"input": {"rows": 7, "cols": 7, "players": 2, "player_tokens": ["O", "A"], "moves": [1, 4, 6, 5, 2, 4]}, "output": {"0": -6, "1": 0}}, {"input": {"rows": 8, "cols": 8, "players": 2, "player_tokens": ["B", "Y"], "moves": [3, 7, 5, 4, 0, 4, 5, 3]}, "output": {"0": -8, "1": 0}}, {"input": {"rows": 8, "cols": 7, "players": 2, "player_tokens": ["Z", "X"], "moves": [2, 5, 2, 1, 5, 3, 1]}, "output": {"0": -7, "1": 0}}, {"input": {"rows": 7, "cols": 9, "players": 2, "player_tokens": ["B", "O"], "moves": [4, 8, 0, 3, 3]}, "output": {"0": -5, "1": 0}}], "error_log": []}
{"context": "Given a map of a terrain represented by a grid of cells, each cell has a specific height. Water flows from higher cells to lower cells following the rules of gravity. The goal is to determine the drainage basins formed by the water flow. Each drainage basin is labeled with a unique letter from 'a' to 'z'. What is the labeling of the drainage basins for the given map?\n\nThe input and output requirements are as follows:\n\nInput:\n  `size` (list of int): A list containing two integers representing the dimensions of the map. `size[0]` is the number of rows and `size[1]` is the number of columns.\n  `heights` (list of list of int): A 2D list representing the height of each cell in the map. The dimensions of this list should match the dimensions specified in `size`.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents a row of the map after processing. Each character in the string represents the drainage basin label for that cell.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef get_map(size, heights):\n    map = []\n    for jj in range(size[0]):\n        map.append([])\n        for kk in range(size[1]):\n            map[jj].append([heights[jj][kk], False, ' '])\n    return map\n\ndef process_loc(next_x, next_y, map, processed, next_sink):\n    if map[next_x][next_y][1] == True:\n        for (x, y) in processed:\n            map[x][y] = [map[x][y][0], True, map[next_x][next_y][2]]\n        return\n\n    processed.append((next_x, next_y))\n\n    curr_height = map[next_x][next_y][0]\n    low_x = -1\n    low_y = -1\n    if next_x > 0 and processed.count((next_x-1, next_y)) == 0:\n        if map[next_x-1][next_y][0] < curr_height:\n            curr_height = map[next_x-1][next_y][0]\n            low_x = next_x - 1\n            low_y = next_y\n    if next_y > 0 and processed.count((next_x, next_y-1)) == 0:\n        if map[next_x][next_y-1][0] < curr_height:\n            curr_height = map[next_x][next_y-1][0]\n            low_x = next_x\n            low_y = next_y - 1\n    if next_y < len(map[0])-1 and processed.count((next_x, next_y+1)) == 0:\n        if map[next_x][next_y+1][0] < curr_height:\n            curr_height = map[next_x][next_y+1][0]\n            low_x = next_x\n            low_y = next_y + 1\n    if next_x < len(map)-1 and processed.count((next_x+1, next_y)) == 0:\n        if map[next_x+1][next_y][0] < curr_height:\n            curr_height = map[next_x+1][next_y][0]\n            low_x = next_x + 1\n            low_y = next_y\n\n    if low_x < 0:\n        for (x, y) in processed:\n            map[x][y] = [map[x][y][0], True, next_sink[0][next_sink[1]]]\n        next_sink[1] = next_sink[1] + 1\n    else:\n        process_loc(low_x, low_y, map, processed, next_sink)\n\ndef process_map(map):\n    next_x = 0\n    next_y = 0\n    sink_names = [\"abcdefghijklmnopqrstuvwxyz\", 0]\n\n    while next_x < len(map) and next_y < len(map[0]):\n        process_loc(next_x, next_y, map, [], sink_names)\n        next_y = next_y + 1\n        if next_y >= len(map[0]):\n            next_x = next_x + 1\n            next_y = 0\n\n    result = []\n    for ii in range(len(map)):\n        result.append(''.join([map[ii][jj][2] for jj in range(len(map[ii]))]))\n    return result\n\n# main function\ndef main_solution(size, heights):\n    map = get_map(size, heights)\n    result = process_map(map)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(1, 10)\n    cols = random.randint(1, 10)\n    size = (rows, cols)\n    heights = []\n    for _ in range(rows):\n        row = [random.randint(1, 100) for _ in range(cols)]\n        heights.append(row)\n    return {'size': size, 'heights': heights}", "io_pairs": [{"input": {"size": [1, 5], "heights": [[1, 44, 31, 88, 25]]}, "output": ["aabcc"]}, {"input": {"size": [1, 1], "heights": [[33]]}, "output": ["a"]}, {"input": {"size": [1, 5], "heights": [[85, 74, 67, 79, 37]]}, "output": ["aaabb"]}, {"input": {"size": [3, 2], "heights": [[18, 52], [12, 16], [88, 45]]}, "output": ["aa", "aa", "aa"]}, {"input": {"size": [1, 3], "heights": [[63, 53, 67]]}, "output": ["aaa"]}, {"input": {"size": [1, 4], "heights": [[6, 39, 11, 81]]}, "output": ["aabb"]}, {"input": {"size": [2, 3], "heights": [[45, 61, 23], [98, 96, 44]]}, "output": ["abb", "abb"]}, {"input": {"size": [2, 1], "heights": [[31], [17]]}, "output": ["a", "a"]}, {"input": {"size": [1, 7], "heights": [[43, 92, 31, 49, 48, 44, 27]]}, "output": ["abbbccc"]}, {"input": {"size": [3, 1], "heights": [[38], [76], [7]]}, "output": ["a", "b", "b"]}], "error_log": []}
{"context": "Given a maze represented by a grid of cells where `0` indicates an open path and `1` indicates a wall, how can we determine if there is a path from the top row to the bottom row? The maze is provided in a specific string format where each row is a comma-separated list of integers and rows are separated by semicolons. What is the resulting maze and the solution status after attempting to solve it using a Breadth-First Search algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `maze` (str): A string representation of the maze where each row is a comma-separated list of integers (0 for open path, 1 for wall) and rows are separated by semicolons.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `solved_maze` (str): The string representation of the maze after attempting to solve it.\n    - `solved` (bool): A boolean indicating whether the maze was successfully solved (True) or not (False).", "reference_code": "# import necessary packages\nimport queue\nimport random\n\n# all class and function definitions in the code file, if any\nclass TwoDMazeSolver:\n\n    def __init__(self, maze):\n        self.maze = maze\n\n    @staticmethod\n    def find_start(maze):\n        for i in range(len(maze[0])):\n            if maze[0][i] == 0:\n                return 0, i\n        return -1, -1\n\n    @staticmethod\n    def check_bounds(row, col, maze):\n        if row < 0 or col < 0 or row >= len(maze) or col >= len(maze[0]):\n            return False\n        if maze[row][col] == 1 or maze[row][col] == 2:\n            return False\n        return True\n\n    @staticmethod\n    def get_surrounding(row, col):\n        res = []\n        for x, y in ((0, 1), (1, 0), (-1, 0), (0, -1)):\n            res.append((row + x, col + y))\n        return res\n\n    @staticmethod\n    def get_valid_moves(row, col, maze):\n        if maze[row][col] == 1:\n            return []\n        surr = TwoDMazeSolver.get_surrounding(row, col)\n        valid = [(x, y) for x, y in surr if TwoDMazeSolver.check_bounds(x, y, maze)]\n        return valid\n\ndef bfs_solve(maze):\n    row, col = TwoDMazeSolver.find_start(maze)\n    q = queue.Queue()\n    q.put((row, col))\n    while not q.empty():\n        r, c = q.get()\n        maze[r][c] = 2\n        if r == len(maze) - 1:\n            return True\n        surr = TwoDMazeSolver.get_surrounding(r, c)\n        for nr, nc in surr:\n            if TwoDMazeSolver.check_bounds(nr, nc, maze):\n                q.put((nr, nc))\n    return False\n\n# main function\ndef main_solution(maze):\n    # Convert the maze to a list of lists if it's not already\n    if isinstance(maze, str):\n        maze = [list(map(int, row.split(','))) for row in maze.split(';')]\n    \n    # Solve the maze using BFS\n    solved = bfs_solve(maze)\n    \n    # Convert the maze back to a string representation\n    maze_str = ';'.join(','.join(map(str, row)) for row in maze)\n    \n    # Return the solved maze and the result of the solution\n    return {\"solved_maze\": maze_str, \"solved\": solved}", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(5, 10)\n    cols = random.randint(5, 10)\n    maze = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n    # Set start point (top row, random column)\n    start_col = random.randint(0, cols - 1)\n    maze[0][start_col] = 0\n    \n    # Set end point (bottom row, random column)\n    end_col = random.randint(0, cols - 1)\n    maze[-1][end_col] = 0\n    \n    # Add some walls (1s)\n    for _ in range(random.randint(5, 15)):\n        row = random.randint(0, rows - 1)\n        col = random.randint(0, cols - 1)\n        if (row == 0 and col == start_col) or (row == rows - 1 and col == end_col):\n            continue\n        maze[row][col] = 1\n    \n    # Convert maze to string representation\n    maze_str = ';'.join(','.join(map(str, row)) for row in maze)\n    \n    return {\"maze\": maze_str}", "io_pairs": [{"input": {"maze": "0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0;1,1,0,0,0,1,0,0;0,0,0,0,0,0,0,0;0,0,1,0,0,1,1,0;0,0,0,0,0,0,0,1"}, "output": {"solved_maze": "2,2,2,2,2,2,2,2;2,2,2,2,2,2,2,2;1,1,2,2,2,1,2,0;2,2,2,2,2,2,0,0;0,2,1,2,2,1,1,0;0,0,0,2,0,0,0,1", "solved": true}}, {"input": {"maze": "0,0,0,0,0,0,0,1,0;0,1,0,1,0,0,0,0,0;0,0,0,0,1,0,0,0,0;0,0,0,0,0,1,0,0,0;1,0,0,0,0,0,0,1,0"}, "output": {"solved_maze": "2,2,2,2,2,2,0,1,0;2,1,2,1,2,0,0,0,0;2,2,2,2,1,0,0,0,0;2,2,2,0,0,1,0,0,0;1,2,0,0,0,0,0,1,0", "solved": true}}, {"input": {"maze": "1,0,0,0,0,0,0;0,0,0,0,0,0,0;0,0,0,0,1,0,0;0,0,1,0,1,1,0;0,0,0,0,0,1,1;0,1,0,0,0,0,0"}, "output": {"solved_maze": "1,2,2,2,2,2,2;2,2,2,2,2,2,2;2,2,2,2,1,2,0;2,2,1,2,1,1,0;2,2,2,2,0,1,1;0,1,2,0,0,0,0", "solved": true}}, {"input": {"maze": "0,1,0,0,0,0;0,0,0,0,1,0;1,0,0,0,0,0;0,0,0,0,0,1;0,1,0,1,0,1;0,0,0,0,0,0;1,1,0,0,0,1;1,0,0,0,0,0"}, "output": {"solved_maze": "2,1,2,2,2,2;2,2,2,2,1,2;1,2,2,2,2,2;2,2,2,2,2,1;2,1,2,1,2,1;2,2,2,2,2,0;1,1,2,2,0,1;1,0,2,0,0,0", "solved": true}}, {"input": {"maze": "0,0,0,0,0,0;0,0,1,0,0,1;0,0,0,1,0,1;0,1,1,1,0,0;0,0,1,0,0,0"}, "output": {"solved_maze": "2,2,2,2,2,0;2,2,1,2,0,1;2,2,2,1,0,1;2,1,1,1,0,0;2,0,1,0,0,0", "solved": true}}, {"input": {"maze": "0,0,0,1,0,0,0;0,0,1,0,1,0,1;0,0,1,0,1,0,0;1,0,0,0,1,0,0;0,0,0,0,0,0,0;0,0,0,0,0,0,0;0,0,0,0,1,0,1"}, "output": {"solved_maze": "2,2,2,1,0,0,0;2,2,1,0,1,0,1;2,2,1,2,1,0,0;1,2,2,2,1,0,0;2,2,2,2,0,0,0;0,2,2,0,0,0,0;0,2,0,0,1,0,1", "solved": true}}, {"input": {"maze": "0,0,0,0,0;0,0,0,0,0;0,0,1,0,0;0,0,1,1,0;0,1,0,0,0;0,1,0,0,1;0,0,0,1,0"}, "output": {"solved_maze": "2,2,2,2,2;2,2,2,2,2;2,2,1,2,2;2,2,1,1,0;2,1,0,0,0;2,1,0,0,1;2,0,0,1,0", "solved": true}}, {"input": {"maze": "0,1,0,1,1;0,0,1,0,0;0,0,0,0,1;0,0,1,0,0;0,0,0,0,1"}, "output": {"solved_maze": "2,1,0,1,1;2,2,1,0,0;2,2,2,0,1;2,2,1,0,0;2,0,0,0,1", "solved": true}}, {"input": {"maze": "0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0;0,0,0,0,0,0,1,0;0,0,1,0,0,0,0,0;0,0,0,0,0,0,0,1;1,0,1,0,0,0,1,0"}, "output": {"solved_maze": "2,2,2,2,2,2,2,0;2,2,2,2,2,2,0,0;2,2,2,2,2,0,1,0;2,2,1,2,0,0,0,0;2,2,2,0,0,0,0,1;1,2,1,0,0,0,1,0", "solved": true}}, {"input": {"maze": "1,1,0,0,0,0,0;0,0,0,0,0,0,0;0,0,0,1,0,0,0;0,1,1,0,1,0,0;0,0,0,1,0,1,0"}, "output": {"solved_maze": "1,1,2,2,2,2,2;2,2,2,2,2,2,2;2,2,2,1,2,2,2;2,1,1,0,1,2,0;2,0,0,1,0,1,0", "solved": true}}], "error_log": []}
{"context": "Given a binary tree, determine if it is symmetrical. A binary tree is symmetrical if it looks the same when reflected across its center. What is the symmetry status of the given binary tree?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (str): A JSON string representing the structure of the binary tree. Each node is represented by an integer or `null` for a non-existent node. The tree is serialized in a level-order traversal format.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetrical. `True` if the tree is symmetrical, `False` otherwise.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isSymmetrical(self, pRoot):\n        if not pRoot:\n            return True\n        return self.isMirror(pRoot.left, pRoot.right)\n\n    def isMirror(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        if left.val != right.val:\n            return False\n        outside = self.isMirror(left.left, right.right)\n        inside = self.isMirror(left.right, right.left)\n        return outside and inside\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            node = queue.pop(0)\n            if nodes[i] is not None:\n                node.left = TreeNode(nodes[i])\n                queue.append(node.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                node.right = TreeNode(nodes[i])\n                queue.append(node.right)\n            i += 1\n        return root\n\n    tree_structure = json.loads(tree_structure)\n    root = build_tree(tree_structure)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution()\n    result = solution.isSymmetrical(root)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import json\nimport random\n\ndef input_generator():\n    def generate_symmetric_tree(depth):\n        if depth == 0:\n            return []\n        val = random.randint(1, 100)\n        tree = [val]\n        current_level = [tree]\n        for _ in range(depth - 1):\n            next_level = []\n            for node in current_level:\n                left_val = random.randint(1, 100) if random.random() > 0.2 else None\n                right_val = left_val if left_val is not None and random.random() > 0.2 else (random.randint(1, 100) if random.random() > 0.2 else None\n                node.append(left_val)\n                node.append(right_val)\n                if left_val is not None:\n                    next_level.append([left_val])\n                if right_val is not None:\n                    next_level.append([right_val])\n            current_level = next_level\n        # Flatten the tree\n        flattened = []\n        queue = [tree]\n        while queue:\n            current = queue.pop(0)\n            flattened.append(current[0])\n            if len(current) > 1:\n                queue.append(current[1] if current[1] is not None else [None])\n            if len(current) > 2:\n                queue.append(current[2] if current[2] is not None else [None])\n        return flattened\n\n    def generate_random_tree(depth):\n        if depth == 0:\n            return []\n        val = random.randint(1, 100)\n        tree = [val]\n        current_level = [tree]\n        for _ in range(depth - 1):\n            next_level = []\n            for node in current_level:\n                left_val = random.randint(1, 100) if random.random() > 0.5 else None\n                right_val = random.randint(1, 100) if random.random() > 0.5 else None\n                node.append(left_val)\n                node.append(right_val)\n                if left_val is not None:\n                    next_level.append([left_val])\n                if right_val is not None:\n                    next_level.append([right_val])\n            current_level = next_level\n        # Flatten the tree\n        flattened = []\n        queue = [tree]\n        while queue:\n            current = queue.pop(0)\n            flattened.append(current[0])\n            if len(current) > 1:\n                queue.append(current[1] if current[1] is not None else [None])\n            if len(current) > 2:\n                queue.append(current[2] if current[2] is not None else [None])\n        return flattened\n\n    if random.random() > 0.5:\n        depth = random.randint(1, 4)\n        tree_structure = generate_symmetric_tree(depth)\n    else:\n        depth = random.randint(1, 4)\n        tree_structure = generate_random_tree(depth)\n    \n    return {'tree_structure': json.dumps(tree_structure)}", "io_pairs": [], "error_log": ["STDERR:   File \"<string>\", line 56\n    right_val = left_val if left_val is not None and random.random() > 0.2 else (random.randint(1, 100) if random.random() > 0.2 else None\n                                                                                ^\nSyntaxError: '(' was never closed\n"]}
{"context": "Given a number, how can we estimate its square root using the gradient descent algorithm, and what is the difference between this estimated value and the true square root calculated using a standard mathematical function?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num` (float): The number for which the square root is to be calculated.\n  `learning_rate` (float): The learning rate for the gradient descent algorithm. Default is 0.01.\n  `iterations` (int): The number of iterations for the gradient descent algorithm. Default is 1000.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `estimated_sqrt` (float): The estimated square root of the input number using the gradient descent algorithm.\n    - `true_sqrt` (float): The true square root of the input number calculated using the `math.sqrt` function.", "reference_code": "# import necessary packages\nimport math\nimport numpy as np\n\n# main function\ndef main_solution(num, learning_rate=0.01, iterations=1000):\n    # Convert JSON serializable inputs to original input variables\n    num = float(num)\n    learning_rate = float(learning_rate)\n    iterations = int(iterations)\n\n    # Gradient Descent Algorithm to calculate square root\n    cur = 0.0\n    for _ in range(iterations):\n        cur -= learning_rate * (cur**2 - num)\n\n    # Convert the result to JSON serializable output\n    return {\"estimated_sqrt\": cur, \"true_sqrt\": math.sqrt(num)}", "input_generator": "import random\n\ndef input_generator():\n    num = random.uniform(0.1, 1000.0)\n    learning_rate = random.choice([0.001, 0.01, 0.1, 0.05])\n    iterations = random.randint(100, 10000)\n    return {\n        \"num\": num,\n        \"learning_rate\": learning_rate,\n        \"iterations\": iterations\n    }", "io_pairs": [{"input": {"num": 211.46963909588294, "learning_rate": 0.001, "iterations": 7242}, "output": {"estimated_sqrt": 14.541995705400344, "true_sqrt": 14.541995705400375}}, {"input": {"num": 20.686683729916453, "learning_rate": 0.1, "iterations": 5957}, "output": {"estimated_sqrt": 4.548261616256968, "true_sqrt": 4.548261616256969}}, {"input": {"num": 571.3833686579435, "learning_rate": 0.01, "iterations": 5936}, "output": {"estimated_sqrt": 23.903626684207218, "true_sqrt": 23.90362668420722}}, {"input": {"num": 547.7125306927253, "learning_rate": 0.01, "iterations": 4166}, "output": {"estimated_sqrt": 23.40325897589319, "true_sqrt": 23.40325897589319}}, {"input": {"num": 625.4544722546397, "learning_rate": 0.001, "iterations": 8811}, "output": {"estimated_sqrt": 25.009087793333006, "true_sqrt": 25.00908779333304}}, {"input": {"num": 527.9119502165333, "learning_rate": 0.05, "iterations": 9870}, "output": {"estimated_sqrt": 8.690183457874596, "true_sqrt": 22.976334568780402}}, {"input": {"num": 567.0159998788863, "learning_rate": 0.001, "iterations": 3925}, "output": {"estimated_sqrt": 23.812097763088506, "true_sqrt": 23.81209776308854}}, {"input": {"num": 30.65353530225053, "learning_rate": 0.1, "iterations": 2492}, "output": {"estimated_sqrt": 5.536563492117699, "true_sqrt": 5.536563492117699}}, {"input": {"num": 219.5505113089624, "learning_rate": 0.01, "iterations": 2556}, "output": {"estimated_sqrt": 14.81723696607982, "true_sqrt": 14.817236966079824}}, {"input": {"num": 709.4103963994854, "learning_rate": 0.001, "iterations": 9829}, "output": {"estimated_sqrt": 26.6347591766752, "true_sqrt": 26.63475917667523}}], "error_log": []}
{"context": "Given a set of points on a 2D plane, how many isosceles triangles can be formed from these points? An isosceles triangle has two sides of equal length, and vertices can be shared by multiple triangles.\n\nThe input and output requirements are as follows:\n\nInput:\n  `points` (list of tuples): A list of (x, y) coordinates, where each tuple represents a point in a 2D plane. Each tuple contains two integers.\n\nOutput:\n  `return` (int): The number of isosceles triangles that can be formed from the given list of points.", "reference_code": "# import necessary packages\nfrom itertools import combinations\nimport random\n\n# main function\ndef main_solution(points):\n    \"\"\"\n    Determines the number of isosceles triangles that can be formed from a given list of (x, y) coordinates.\n    \n    Parameters:\n    points (list of tuples): A list of (x, y) coordinates.\n    \n    Returns:\n    int: The number of isosceles triangles that can be formed.\n    \"\"\"\n    triangles = 0\n    for (x1, y1), (x2, y2), (x3, y3) in combinations(points, 3):\n        a = round(((x1-x2)**2 + (y1-y2)**2)**0.5, 2)\n        b = round(((x1-x3)**2 + (y1-y3)**2)**0.5, 2)\n        c = round(((x2-x3)**2 + (y2-y3)**2)**0.5, 2)\n        collinear = 0.5 * (x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) == 0\n        if (a == b or b == c or a == c) and not collinear:\n            triangles += 1\n    return triangles", "input_generator": "import random\n\ndef input_generator():\n    num_points = random.randint(3, 10)  # Generate between 3 and 10 points\n    points = []\n    for _ in range(num_points):\n        x = random.randint(-10, 10)\n        y = random.randint(-10, 10)\n        points.append((x, y))\n    return {'points': points}", "io_pairs": [{"input": {"points": [[-4, 10], [-3, 8], [4, 8], [3, 0]]}, "output": 0}, {"input": {"points": [[8, -1], [5, -2], [-10, -3]]}, "output": 0}, {"input": {"points": [[10, 10], [5, 2], [0, -10], [8, 3], [2, -8], [8, 10], [8, 3]]}, "output": 0}, {"input": {"points": [[-3, -9], [0, 1], [-7, 6], [4, -8]]}, "output": 0}, {"input": {"points": [[-7, -5], [-10, -1], [7, 5]]}, "output": 0}, {"input": {"points": [[3, 8], [-8, -8], [-4, 9]]}, "output": 0}, {"input": {"points": [[6, 0], [5, 3], [-9, 5], [-9, -5], [1, 0], [0, -8]]}, "output": 4}, {"input": {"points": [[-1, 10], [6, -5], [5, -2], [-4, 10], [1, -8], [4, -1]]}, "output": 0}, {"input": {"points": [[9, -5], [-8, 9], [-7, -8], [2, 2], [2, 4]]}, "output": 0}, {"input": {"points": [[9, 5], [-3, 0], [-8, 3], [5, -4], [10, 0], [-4, -2]]}, "output": 1}], "error_log": []}
{"context": "Given a list of integers, can you determine if there exists a permutation of these integers such that by applying a series of addition, subtraction, or multiplication operations, the result can be exactly 42?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numbers` (list of strings): A list of strings representing integers. Each string should be a valid integer.\n\nOutput:\n  `return` (string): A string that is either \"YES\" or \"NO\". \"YES\" indicates that there exists a permutation of the input numbers that can be manipulated to reach the number 42, and \"NO\" indicates that no such permutation exists.", "reference_code": "# import necessary packages\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef check(l):\n    number = l[0]\n    l = l[1:]\n    if len(l) == 0:\n        if number == 42:\n            return True\n        else:\n            return False\n    else:\n        second_number = l.pop()\n        t1 = [number + second_number] + l\n        t2 = [number - second_number] + l\n        t3 = [number * second_number] + l\n        return check(t1) or check(t2) or check(t3)\n\ndef check_all(l):\n    for p in permutations(l):\n        if check(list(p)):\n            return True\n    return False\n\n# main function\ndef main_solution(numbers):\n    # Convert the input list of strings to integers\n    numbers = [int(num) for num in numbers]\n    \n    # Check if any permutation of the numbers can be manipulated to reach 42\n    result = check_all(numbers)\n    \n    # Return the result as a string \"YES\" or \"NO\"\n    return \"YES\" if result else \"NO\"", "input_generator": "import random\nfrom itertools import permutations\n\ndef input_generator():\n    # Generate a random list of numbers between 1 and 20\n    n = random.randint(2, 5)  # Reasonable size for permutations\n    numbers = [random.randint(1, 20) for _ in range(n)]\n    \n    # Occasionally ensure a valid case where 42 is achievable\n    if random.random() < 0.3:\n        # Create a solvable case: e.g., [20, 22, 2] -> 20 + 22 = 42\n        a = random.randint(10, 30)\n        b = 42 - a\n        numbers = [a, b] + [random.randint(1, 20) for _ in range(n-2)]\n    \n    # Convert numbers to strings to match the main_solution input format\n    return {'numbers': [str(num) for num in numbers]}", "io_pairs": [{"input": {"numbers": ["8", "19", "17"]}, "output": "NO"}, {"input": {"numbers": ["5", "17", "1", "20"]}, "output": "YES"}, {"input": {"numbers": ["11", "5", "5", "17", "11"]}, "output": "YES"}, {"input": {"numbers": ["12", "2", "15", "4"]}, "output": "YES"}, {"input": {"numbers": ["6", "8", "13", "15"]}, "output": "YES"}, {"input": {"numbers": ["10", "1", "8", "11", "17"]}, "output": "YES"}, {"input": {"numbers": ["5", "19", "11", "17", "14"]}, "output": "NO"}, {"input": {"numbers": ["30", "12", "17", "13", "11"]}, "output": "NO"}, {"input": {"numbers": ["4", "19", "11"]}, "output": "NO"}, {"input": {"numbers": ["7", "9", "1", "9", "5"]}, "output": "YES"}], "error_log": []}
{"context": "Given a mathematical series that approximates the value of \u03c0, how can we estimate \u03c0 using the first `n` terms of this series? Specifically, what is the estimated value of \u03c0 when using the first `n` terms?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of terms to use in the series approximation for estimating \u03c0.\n\nOutput:\n  `return` (dict): A dictionary containing the key `\"estimated_pi\"` with the value being the estimated value of \u03c0 based on the first `n` terms of the series.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef mysqrt(a):\n    x = a\n    while True:\n        y = ((x + (a / x)) / 2)\n        if abs(x - y) < 0.00001:\n            break\n        else:\n            x = y\n    return y\n\ndef silnia(n):\n    if n == 1 or n == 0:\n        return 1\n    else:\n        return n * silnia(n - 1)\n\ndef calculate_skladnik(n):\n    return (silnia(4 * n) * (1103 + 26390 * n) / ((silnia(n)**4) * (396**(4 * n))))\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    k = (2 * math.sqrt(2)) / 9801\n    granica = 10**(-15)\n    result = 0\n\n    for i in range(n):\n        skladnik = calculate_skladnik(i)\n        if skladnik < granica:\n            break\n        else:\n            result += skladnik\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"estimated_pi\": 1 / (k * result)}", "input_generator": "import random\n\ndef input_generator():\n    return {\"n\": random.randint(1, 10)}", "io_pairs": [{"input": {"n": 3}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 6}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 9}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 1}, "output": {"estimated_pi": 3.1415927300133055}}, {"input": {"n": 7}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 8}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 2}, "output": {"estimated_pi": 3.1415926535897936}}, {"input": {"n": 5}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 10}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 4}, "output": {"estimated_pi": 3.141592653589793}}], "error_log": []}
{"context": "In a high-dimensional space, a grid of cubes follows Conway's Game of Life rules. Given an initial state of the grid and the dimension (either 3D or 4D), how many cubes will remain active after six iterations of the game?\n\nThe input and output requirements are as follows:\n\nInput:\n  `string_grid` (List[List[str]]): A 2D list of strings representing the initial state of the grid. Each string is either `.` (inactive) or `#` (active).\n  `dim` (int): An integer representing the dimension of the grid (either 3 or 4).\n\nOutput:\n  `return` (int): The number of active cubes after six iterations of the Conway's Game of Life rules.", "reference_code": "# import necessary packages\nfrom collections import defaultdict\nfrom itertools import product\nfrom typing import List, Tuple\n\n# all class and function definitions in the code file, if any\ndef get_neighbour_locations(dim: int) -> List[Tuple]:\n    # get the relative positions of all neighbours of a point in a cartesian grid\n    return [pos for pos in product(range(-1, 2), repeat=dim) if pos != (0,) * dim]\n\nclass CubeGrid:\n    \"\"\"A grid of Conway cubes.\"\"\"\n\n    def __init__(self, string_grid: List[List[str]], dim: int):\n        self.dim = dim\n        self.neighbour_pos = get_neighbour_locations(dim)\n\n        self._update = self._update_3d if dim == 3 else self._update_4d\n\n        grid = defaultdict(bool)\n        for y in range(len(string_grid)):\n            for x in range(len(string_grid[0])):\n                grid[(x, y) + (0,) * (dim - 2)] = string_grid[y][x] == \"#\"\n        self.grid = grid\n\n    @property\n    def active_cubes(self):\n        # count the number of active cubes after six iterations\n        for _ in range(6):\n            self._update()\n\n        return sum(self.grid.values())\n\n    def _get_coord_ranges(self):\n        # return the ranges of each coordinate that need to be scanned for updates\n        coord_ranges = []\n        for i in range(self.dim):\n            c_range = sorted([p[i] for p in self.grid.keys()])\n            c_lims = range(c_range[0] - 1, c_range[-1] + 2)\n            coord_ranges.append(c_lims)\n\n        return coord_ranges\n\n    def _cube_state(self, p):\n        # obtain the new state of a cube given the current state of all cubes\n        num_active_neighbours = 0\n        for q in self.neighbour_pos:\n            neighbour_pos = tuple(p[i] + q[i] for i in range(self.dim))\n            num_active_neighbours += self.grid[neighbour_pos]\n\n        if self.grid[p]:\n            new_state = 2 <= num_active_neighbours <= 3\n        else:\n            new_state = num_active_neighbours == 3\n\n        return new_state\n\n    def _update_3d(self):\n        # update the grid in 3d\n        x_range, y_range, z_range = self._get_coord_ranges()\n        new_grid = defaultdict(bool)\n\n        for x in x_range:\n            for y in y_range:\n                for z in z_range:\n                    new_grid[(x, y, z)] = self._cube_state((x, y, z))\n\n        self.grid = new_grid\n\n    def _update_4d(self):\n        # update the grid in 4d\n        x_range, y_range, z_range, w_range = self._get_coord_ranges()\n        new_grid = defaultdict(bool)\n\n        for x in x_range:\n            for y in y_range:\n                for z in z_range:\n                    for w in w_range:\n                        new_grid[(x, y, z, w)] = self._cube_state((x, y, z, w))\n\n        self.grid = new_grid\n\n# main function\ndef main_solution(string_grid: List[List[str]], dim: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    cube_grid = CubeGrid(string_grid, dim)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return cube_grid.active_cubes", "input_generator": "import random\nfrom typing import List\n\ndef input_generator():\n    dim = random.choice([3, 4])\n    size = random.randint(3, 6)\n    string_grid = []\n    for _ in range(size):\n        row = []\n        for _ in range(size):\n            row.append(random.choice(['.', '#']))\n        string_grid.append(row)\n    return {'string_grid': string_grid, 'dim': dim}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Imagine you are designing a game where players navigate through a maze. The maze is generated randomly and needs to be represented in a string format for display purposes. Given the number of junction points across and down, and the characters used to represent walls and hallways, what would the string representation of the maze look like?\n\nThe input and output requirements are as follows:\n\nInput:\n  `width` (int): Number of junction points across (maze width is twice the size).\n  `height` (int): Number of junction points down (maze height is twice the size).\n  `chars` (list of str): Characters to represent walls and hallways in the maze.\n\nOutput:\n  `return` (str): A string representation of the maze.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef makeMaze(width, height):\n    \"\"\"Initializes an 2D list for the maze then begins the recurseive function.\n\n    Args:\n        width: Number of junction points accross (maze width is twice the size)\n        height: Number of junction points down (maze height is twice the size)\n\n    Returns:\n        A 2D list containing a maze of twisted passageways.\n    \"\"\"\n    maze = [[0 for j in range(width*2)] for i in range(height*2)]\n    recurseMaze(maze, int(width / 2) * 2, int(height / 2) * 2, 0, 0)\n    return maze\n\ndef recurseMaze(maze, x, y, dirx, diry):\n    \"\"\"This function is added to the call stack each time it is called.  It keeps\n    track if it's location and directions, so when functions are removed from the\n    stack and returns here the functions know where it's left off.\n\n    Args:\n        maze: The 2D list that the maze data will be stored in.\n        x: The X location of the current cell in the maze.\n        y: The Y location of the current cell in the maze.\n        dirx: The x direction that was taken to get to this cell.\n        diry: The y direction that was taken to get to this cell.\n\n    Returns:\n        Nothing\n    \"\"\"\n    if not 0 <= y < len(maze) or not 0 <= x < len(maze[0]) or maze[y][x] != 0:\n        return\n    maze[y-diry][x-dirx] = 1\n    maze[y][x] = 1\n    directions = [(1,0), (-1,0), (0,1), (0,-1)]\n    random.shuffle(directions)\n    for dx, dy in directions:\n        recurseMaze(maze, x + dx * 2, y + dy * 2, dx, dy)\n\ndef mazeString(maze, chars):\n    \"\"\"This function takes the lists of 1's and 0's and returns a string that\n    can easily be printed to the screen.\n\n    Args:\n        maze: The maze lists holding the maze information.\n        chars: The characters that should be used for drawing the maze (wall, hall)\n\n    Returns:\n        A string representing the maze that is ready for printing.\n    \"\"\"\n    s = chars[0] * (len(maze[0]) + 1) + \"\\n\"\n    for row in maze:\n        s += chars[0]\n        for cell in row:\n            s += chars[cell]\n        s += \"\\n\"\n    return s\n\n# main function\ndef main_solution(width, height, chars):\n    \"\"\"Generates a maze and returns a string representation of it.\n\n    Args:\n        width (int): Number of junction points across (maze width is twice the size).\n        height (int): Number of junction points down (maze height is twice the size).\n        chars (list of str): Characters to represent walls and hallways in the maze.\n\n    Returns:\n        str: A string representation of the maze.\n    \"\"\"\n    maze = makeMaze(width, height)\n    maze_str = mazeString(maze, chars)\n    return maze_str", "input_generator": "import random\n\ndef input_generator():\n    width = random.randint(3, 10)\n    height = random.randint(3, 10)\n    wall_char = random.choice(['#', '@', '%', 'X'])\n    hall_char = random.choice([' ', '.', '-', ' '])\n    chars = [wall_char, hall_char]\n    return {'width': width, 'height': height, 'chars': chars}", "io_pairs": [{"input": {"width": 4, "height": 4, "chars": ["%", " "]}, "output": "%%%%%%%%%\n%     % %\n% %%% % %\n%   %   %\n% % %%%%%\n% % %   %\n% % %%% %\n% %     %\n%%%%%%%%%\n"}, {"input": {"width": 6, "height": 3, "chars": ["@", "."]}, "output": "@@@@@@@@@@@@@\n@.....@...@.@\n@.@@@.@.@.@.@\n@.@...@.@.@.@\n@.@.@@@@@.@.@\n@.@.........@\n@@@@@@@@@@@@@\n"}, {"input": {"width": 4, "height": 3, "chars": ["@", "-"]}, "output": "@@@@@@@@@\n@-------@\n@-@@@@@-@\n@---@-@-@\n@@@-@-@-@\n@---@---@\n@@@@@@@@@\n"}, {"input": {"width": 3, "height": 4, "chars": ["@", " "]}, "output": "@@@@@@@\n@     @\n@ @@@ @\n@ @   @\n@ @@@ @\n@   @ @\n@@@@@ @\n@     @\n@@@@@@@\n"}, {"input": {"width": 6, "height": 3, "chars": ["X", "."]}, "output": "XXXXXXXXXXXXX\nX...........X\nX.XXXXXXX.X.X\nX.X.X...X.X.X\nX.X.X.XXXXX.X\nX...X.......X\nXXXXXXXXXXXXX\n"}, {"input": {"width": 3, "height": 5, "chars": ["@", " "]}, "output": "@@@@@@@\n@     @\n@@@@@ @\n@     @\n@ @@@ @\n@   @ @\n@@@@@ @\n@ @   @\n@ @ @@@\n@     @\n@@@@@@@\n"}, {"input": {"width": 6, "height": 3, "chars": ["#", "-"]}, "output": "#############\n#-#-----#---#\n#-#-###-###-#\n#-#---#-#---#\n#-###-###-#-#\n#---------#-#\n#############\n"}, {"input": {"width": 4, "height": 4, "chars": ["#", " "]}, "output": "#########\n#   #   #\n# # # # #\n# #   # #\n# ##### #\n#   #   #\n### #####\n#       #\n#########\n"}, {"input": {"width": 6, "height": 3, "chars": ["%", " "]}, "output": "%%%%%%%%%%%%%\n%       %   %\n% %%%%% % % %\n%     % % % %\n%%%%% %%% % %\n%         % %\n%%%%%%%%%%%%%\n"}, {"input": {"width": 3, "height": 4, "chars": ["%", "."]}, "output": "%%%%%%%\n%.....%\n%.%%%.%\n%...%.%\n%.%%%.%\n%.%.%.%\n%.%.%.%\n%.%...%\n%%%%%%%\n"}], "error_log": []}
{"context": "Given a chessboard of size `n` by `n`, how many distinct ways can you place `n` queens on the board such that no two queens threaten each other?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the chessboard and the number of queens to be placed on the board.\n\nOutput:\n  `return` (int): The total number of distinct solutions to the N-Queens problem for the given board size `n`.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def __init__(self):\n        self.result = 0\n    \n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def check(k, j):\n            for i in range(k):\n                if board[i] == j or abs(k - i) == abs(board[i] - j):\n                    return False\n            return True\n        \n        def nqueen(depth):\n            if depth == n:\n                self.result += 1\n                return\n            for i in range(n):\n                if check(depth, i):\n                    board[depth] = i                    \n                    nqueen(depth + 1)\n        \n        board = [-1 for _ in range(n)]\n        nqueen(0)\n        return self.result\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.totalNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Reasonable range for N-Queens problem\n    return {'n': n}", "io_pairs": [{"input": {"n": 5}, "output": 10}, {"input": {"n": 9}, "output": 352}, {"input": {"n": 4}, "output": 2}, {"input": {"n": 6}, "output": 4}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 8}, "output": 92}, {"input": {"n": 2}, "output": 0}, {"input": {"n": 7}, "output": 40}, {"input": {"n": 10}, "output": 724}, {"input": {"n": 3}, "output": 0}], "error_log": []}
{"context": "In a milkshake shop, there are several flavors of milkshakes available. Each customer has specific preferences for these flavors, indicating whether they prefer the milkshake to be malted or unmalted. Given the number of milkshake flavors and the preferences of multiple customers, determine whether it is possible to satisfy all customers with a single batch of milkshakes. If it is possible, what should be the malted status of each flavor? If it is impossible to satisfy all customers, indicate that it is impossible.\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_shakes` (int): The number of milkshake flavors available.\n  `customers` (list of lists of tuples): A list where each element is a list of tuples representing a customer's preferences. Each tuple contains two integers: the flavor index (0-based) and the malted preference (0 for unmalted, 1 for malted).\n\nOutput:\n  `return` (str): A string representing the result. If it is possible to satisfy all customers, it will be a space-separated string of integers representing the malted status of each flavor. If it is impossible to satisfy all customers, the string will be \"IMPOSSIBLE\".", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(num_shakes, customers):\n    shakes = [0] * num_shakes  # Create unmalted list\n    impossible = False\n    solved = False\n\n    while not impossible and not solved:  # While not finished\n        redo = False\n        for customer in customers:  # Examine all customers\n            unsatisfied = []\n            for flavor, malt in customer:  # Examine all their preferences\n                if shakes[flavor] == malt:  # If satisfied, move to next customer\n                    unsatisfied = []\n                    break\n                else:  # If unsatisfied, take note of it\n                    unsatisfied.append((flavor, malt))\n\n            for flavor, malt in unsatisfied:  # Check unsatisfied flavors\n                if malt == 1 and shakes[flavor] == 0:  # Look for a possible malted preference\n                    shakes[flavor] = 1  # Attend the malted preference\n                    redo = True  # Restart checking customers\n                    break\n\n            if redo:\n                break\n\n            if len(unsatisfied) > 0:  # If we've reached here, all insatisfactions are unmalted\n                impossible = True  # Then we can't solve it\n                break\n\n        if not redo:  # If we don't need to look into customers again\n            solved = True  # Problem was solved (might still be impossible)\n\n    result = \"IMPOSSIBLE\" if impossible else \" \".join(map(str, shakes))  # Decide result\n    return result", "input_generator": "import random\n\ndef input_generator():\n    num_shakes = random.randint(1, 10)\n    num_customers = random.randint(1, 10)\n    customers = []\n    for _ in range(num_customers):\n        num_preferences = random.randint(1, 3)\n        preferences = []\n        flavors = random.sample(range(num_shakes), min(num_preferences, num_shakes))\n        for flavor in flavors:\n            malt = random.randint(0, 1)\n            preferences.append((flavor, malt))\n        customers.append(preferences)\n    return {'num_shakes': num_shakes, 'customers': customers}", "io_pairs": [{"input": {"num_shakes": 2, "customers": [[[0, 1]]]}, "output": "1 0"}, {"input": {"num_shakes": 2, "customers": [[[0, 0], [1, 1]], [[1, 0]], [[0, 1]]]}, "output": "IMPOSSIBLE"}, {"input": {"num_shakes": 7, "customers": [[[5, 1]]]}, "output": "0 0 0 0 0 1 0"}, {"input": {"num_shakes": 10, "customers": [[[3, 0], [7, 1], [6, 0]]]}, "output": "0 0 0 0 0 0 0 0 0 0"}, {"input": {"num_shakes": 1, "customers": [[[0, 0]], [[0, 0]]]}, "output": "0"}, {"input": {"num_shakes": 1, "customers": [[[0, 1]]]}, "output": "1"}, {"input": {"num_shakes": 5, "customers": [[[3, 1]]]}, "output": "0 0 0 1 0"}, {"input": {"num_shakes": 3, "customers": [[[1, 1]]]}, "output": "0 1 0"}, {"input": {"num_shakes": 8, "customers": [[[3, 1]]]}, "output": "0 0 0 1 0 0 0 0"}, {"input": {"num_shakes": 10, "customers": [[[4, 1]], [[1, 0], [8, 0]]]}, "output": "0 0 0 0 1 0 0 0 0 0"}], "error_log": []}
{"context": "Given a variable \\( x \\) and a degree \\( n \\), what is the value of the \\( n \\)-th Legendre polynomial \\( P_n(x) \\) rounded to three decimal places?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): The value of the variable \\( x \\) for which the Legendre polynomial \\( P_n(x) \\) is to be calculated.\n  `n` (int): The degree \\( n \\) of the Legendre polynomial \\( P_n(x) \\).\n\nOutput:\n  `return` (float): The value of the Legendre polynomial \\( P_n(x) \\) rounded to 3 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef pol(x, n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return x\n    else:\n        return ((((2 * n - 1) * x * pol(x, n - 1)) - ((n - 1) * pol(x, n - 2))) / n)\n\n# main function\ndef main_solution(x, n):\n    # Convert input variables to appropriate types\n    x = float(x)\n    n = int(n)\n    \n    # Calculate the Legendre polynomial value\n    result = pol(x, n)\n    \n    # Return the result rounded to 3 decimal places\n    return round(result, 3)", "input_generator": "import random\n\ndef input_generator():\n    x = random.uniform(-1.0, 1.0)\n    n = random.randint(0, 10)\n    return {'x': x, 'n': n}", "io_pairs": [{"input": {"x": 0.053929275802870436, "n": 2}, "output": -0.496}, {"input": {"x": 0.8175153510980546, "n": 3}, "output": 0.14}, {"input": {"x": -0.959516950356126, "n": 10}, "output": -0.261}, {"input": {"x": 0.13786078389212086, "n": 3}, "output": -0.2}, {"input": {"x": -0.34158960386076975, "n": 0}, "output": 1}, {"input": {"x": 0.46991021435285973, "n": 2}, "output": -0.169}, {"input": {"x": 0.24701905461809703, "n": 9}, "output": 0.182}, {"input": {"x": 0.7508255852170751, "n": 7}, "output": -0.038}, {"input": {"x": 0.7630881575311748, "n": 0}, "output": 1}, {"input": {"x": -0.7665914301449865, "n": 2}, "output": 0.381}], "error_log": []}
{"context": "Given a positive integer, what are the unique ways to partition it into sums of smaller integers? For example, for the number 4, the partitions could be [1, 1, 1, 1], [1, 1, 2], [2, 2], and [1, 3]. What are the unique additive partitions for a given number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number` (int): The integer for which additive partitions are to be calculated.\n\nOutput:\n  `return` (str): A JSON string representing the list of all unique additive partitions of the input number. Each partition is a list of integers.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nbase_cases = {1: [[1]],\n              2: [[1, 1]]}\n\ndef additive_partitions(number):\n    partitions = []\n\n    if number == 1 or number == 2:\n        return base_cases.get(number)\n\n    for x in range(1, number // 2 + 1):\n        partitions.append([x, (number - x)])\n\n        sub_list_x = additive_partitions(x)\n        sub_list_c = additive_partitions(number - x)\n\n        sub_partitions_list = [sub_x + sub_c for sub_x in sub_list_x for sub_c in sub_list_c]\n\n        for element in sub_partitions_list:\n            element.sort()\n\n        partitions.extend([element for element in sub_partitions_list if element not in partitions])\n\n    return partitions\n\n# main function\ndef main_solution(number):\n    # Convert the input to an integer\n    number = int(number)\n    \n    # Get the additive partitions\n    partitions = additive_partitions(number)\n    \n    # Convert the partitions to a JSON serializable format\n    partitions_json = json.dumps(partitions)\n    \n    # Return the JSON string\n    return partitions_json", "input_generator": "import random\n\ndef input_generator():\n    number = random.randint(1, 10)\n    return {'number': str(number)}", "io_pairs": [{"input": {"number": "5"}, "output": "[[1, 4], [1, 1, 3], [1, 1, 1, 2], [1, 1, 1, 1, 1], [1, 2, 2], [2, 3]]"}, {"input": {"number": "3"}, "output": "[[1, 2], [1, 1, 1]]"}, {"input": {"number": "1"}, "output": "[[1]]"}, {"input": {"number": "4"}, "output": "[[1, 3], [1, 1, 2], [1, 1, 1, 1], [2, 2]]"}, {"input": {"number": "2"}, "output": "[[1, 1]]"}], "error_log": []}
{"context": "Given a function \\( f(x) = e^{-x^2} \\), you are tasked with determining the integral of this function over a specified interval using the Romberg integration method. What is the result of the Romberg integration for the function \\( f(x) \\) over the interval \\([Lim\\_inf, Lim\\_sup]\\) with \\( k \\) iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `Lim_inf` (float): The inferior limit of the interval for integration.\n  `Lim_sup` (float): The superior limit of the interval for integration.\n  `k` (int): The number of iterations for the Romberg method.\n\nOutput:\n  `return` (dict): A dictionary containing the result of the Romberg integration. The key is `\"result\"` and the value is a float representing the computed integral.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# Function to be solved -----------------------------------\n\ndef f(x):\n    return np.exp(-x**2)\n\ndef romberg(col1):\n    n = len(col1)\n    for j in range(n - 1):\n        temp_col = [0] * (n - 1 - j)\n        for i in range(n - 1 - j):\n            power = j + 1\n            temp_col[i] = (4 ** power * col1[i + 1] - col1[i]) / (4 ** power - 1)\n        col1[:n - 1 - j] = temp_col\n    return col1[0]\n\ndef trapezio(f, a, b, h):                            \n    n = int((b - a) / h)\n    soma = 0\n    for k in range(1, n):\n        soma += f(a + k * h)\n    return (h / 2) * (f(a) + 2 * soma + f(b))\n\n# main function\ndef main_solution(Lim_inf, Lim_sup, k):\n    # Convert input variables if necessary\n    hs = [0.5 / 2 ** i for i in range(k)]\n    \n    # Calculate the first column of the Romberg table\n    col1 = [trapezio(f, Lim_inf, Lim_sup, hi) for hi in hs]\n    \n    # Calculate the Romberg integration result\n    result = romberg(col1)\n    \n    # Return the result as a JSON serializable output\n    return {\"result\": result}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    Lim_inf = random.uniform(-5.0, 0.0)\n    Lim_sup = random.uniform(0.0, 5.0)\n    k = random.randint(2, 6)\n    return {\"Lim_inf\": Lim_inf, \"Lim_sup\": Lim_sup, \"k\": k}", "io_pairs": [{"input": {"Lim_inf": -0.3898453966195836, "Lim_sup": 0.2203386054429296, "k": 5}, "output": {"result": 0.583807456152122}}, {"input": {"Lim_inf": -1.668348471924777, "Lim_sup": 4.697136209058286, "k": 4}, "output": {"result": 1.7562319434382956}}, {"input": {"Lim_inf": -2.1119769022888386, "Lim_sup": 1.5902273243220422, "k": 2}, "output": {"result": 1.7204331288607797}}, {"input": {"Lim_inf": -0.9178493939742456, "Lim_sup": 2.104375842397486, "k": 6}, "output": {"result": 1.5977076793059068}}, {"input": {"Lim_inf": -0.46552217758939207, "Lim_sup": 3.3736750161199334, "k": 4}, "output": {"result": 1.3201979254592848}}, {"input": {"Lim_inf": -1.6663941841158199, "Lim_sup": 2.598062096410291, "k": 4}, "output": {"result": 1.7558805431970286}}, {"input": {"Lim_inf": -3.6301458235398036, "Lim_sup": 2.7709804709108647, "k": 4}, "output": {"result": 1.7723558287513415}}, {"input": {"Lim_inf": -2.5302524886095723, "Lim_sup": 0.12242987836054209, "k": 2}, "output": {"result": 0.8545018513596648}}, {"input": {"Lim_inf": -4.757312055737871, "Lim_sup": 0.260210886063883, "k": 2}, "output": {"result": 1.123605752824827}}, {"input": {"Lim_inf": -3.34410871222931, "Lim_sup": 1.2490677046682803, "k": 6}, "output": {"result": 1.7023030428939323}}], "error_log": []}
{"context": "In a city, there is a grid-like structure representing the layout of houses. Some houses are quarantined due to a recent outbreak, and you need to navigate from the top-left corner of the grid to a specific destination house. Given the number of rows (`M`) and columns (`N`) in the grid, a list of quarantined house numbers, and the destination house number, what is the shortest path to reach the destination house from the source, expressed as a sequence of directions (UP, LEFT, RIGHT, DOWN)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `M` (int): Number of rows in the grid.\n  `N` (int): Number of columns in the grid.\n  `housesquarantined` (list of int): List of house numbers that are quarantined.\n  `Destinationhouse` (int): House number of the destination.\n\nOutput:\n  `return` (str): A string representing the directions to reach the destination from the source. If the destination cannot be reached, it returns \"Destination can't be reached\".", "reference_code": "# import necessary packages\nfrom collections import deque\nimport math\n\n# all class and function definitions in the code file, if any\n# Below lists details all 4 possible movements from a cell\nrow = [-1, 0, 0, 1]\ncol = [0, -1, 1, 0]\nstring = [\"U\",\"L\",\"R\",\"D\"]\n\n# Function to check if it is possible to go to position (row, col)\n# from current position. The function returns false if row, col\n# is not a valid position or has value 0 or it is already visited\ndef isValid(mat, visited, row, col):\n    return (row >= 0) and (row < len(mat)) and (col >= 0) and (col < len(mat[0])) \\\n           and mat[row][col] == 1 and not visited[row][col]\n\n# Find Shortest Possible Route in a matrix mat from source \n# cell (i, j) to destination cell (x, y) and returns the directions\ndef BFS(mat, i, j, x, y):\n    # construct a matrix to keep track of visited cells\n    visited = [[False for _ in range(len(mat[0]))] for _ in range(len(mat))]\n\n    # create an empty queue\n    q = deque()\n\n    # mark source cell as visited and enqueue the source node\n    visited[i][j] = True\n\n    # (i, j, dist) represents matrix cell coordinates and its\n    # minimum distance from the source\n    q.append((i, j, 0, \"\"))\n\n    # stores length of longest path from source to destination\n    min_dist = float('inf')\n    directions = \"\"\n\n    #  run till queue is empty\n    while q:\n        # pop front node from queue and process it\n        (i, j, dist, path) = q.popleft()\n\n        # (i, j) represents current cell and dist stores its\n        # minimum distance from the source\n\n        # if destination is found, update min_dist and stop\n        if i == x and j == y:\n            min_dist = dist\n            directions = path\n            break\n\n        # check for all 4 possible movements from current cell\n        # and enqueue each valid movement\n        for k in range(4):\n            # check if it is possible to go to position\n            # (i + row[k], j + col[k]) from current position\n            if isValid(mat, visited, i + row[k], j + col[k]):\n                # mark next cell as visited and enqueue it\n                visited[i + row[k]][j + col[k]] = True\n                q.append((i + row[k], j + col[k], dist + 1, path + string[k]))\n\n    if min_dist == float('inf'):\n        return \"Destination can't be reached\"\n    else:\n        return directions\n\n# This function is to convert decimal house numbers to the specific coordinates\n# in terms of i and j pointing a specific cell in the grid\ndef convert(housenumber, M, N):\n    i = math.ceil(housenumber / N) - 1\n    j = housenumber - (N * (i)) - 1\n    return (i, j)\n\n# main function\ndef main_solution(M, N, housesquarantined, Destinationhouse):\n    # Convert JSON serializable inputs to original input variables\n    mat = [[1 for _ in range(N)] for _ in range(M)]\n    i, j = convert(Destinationhouse, M, N)\n\n    for house in housesquarantined:\n        quarantine_index_i, quarantine_index_j = convert(house, M, N)\n        mat[quarantine_index_i][quarantine_index_j] = 0\n\n    # Call the BFS function and get the result\n    result = BFS(mat, 0, 0, i, j)\n\n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    M = random.randint(2, 10)\n    N = random.randint(2, 10)\n    total_houses = M * N\n    Destinationhouse = random.randint(1, total_houses)\n    \n    # Ensure at least one non-quarantined house exists (excluding (0,0) which is the start)\n    max_quarantined = min(total_houses - 2, random.randint(1, total_houses // 2))\n    housesquarantined = random.sample(range(1, total_houses + 1), max_quarantined)\n    \n    return {\n        'M': M,\n        'N': N,\n        'housesquarantined': housesquarantined,\n        'Destinationhouse': Destinationhouse\n    }", "io_pairs": [{"input": {"M": 5, "N": 3, "housesquarantined": [11, 2, 9, 3, 4, 7, 13], "Destinationhouse": 3}, "output": "Destination can't be reached"}, {"input": {"M": 7, "N": 4, "housesquarantined": [11, 23, 5, 24, 25, 12, 3, 1], "Destinationhouse": 3}, "output": "Destination can't be reached"}, {"input": {"M": 5, "N": 4, "housesquarantined": [17, 19, 8, 10, 20, 14, 7, 12, 11], "Destinationhouse": 18}, "output": "Destination can't be reached"}, {"input": {"M": 5, "N": 4, "housesquarantined": [10, 11, 12, 5, 9, 15, 6, 1], "Destinationhouse": 12}, "output": "Destination can't be reached"}, {"input": {"M": 3, "N": 7, "housesquarantined": [1, 9, 21, 13, 18, 8], "Destinationhouse": 7}, "output": "RRRRRR"}, {"input": {"M": 3, "N": 7, "housesquarantined": [7, 1, 5], "Destinationhouse": 21}, "output": "RRRDRRRD"}, {"input": {"M": 8, "N": 8, "housesquarantined": [10, 45, 58, 20, 48, 7, 26, 49, 53, 46, 6], "Destinationhouse": 24}, "output": "RRRRDRRRD"}, {"input": {"M": 3, "N": 6, "housesquarantined": [17, 7, 14, 8], "Destinationhouse": 5}, "output": "RRRR"}, {"input": {"M": 6, "N": 2, "housesquarantined": [3, 4, 5, 6, 10, 11], "Destinationhouse": 5}, "output": "Destination can't be reached"}, {"input": {"M": 6, "N": 7, "housesquarantined": [40, 28, 26, 11], "Destinationhouse": 38}, "output": "RRDDDDD"}], "error_log": []}
{"context": "Given the Euler angles (yaw, pitch, roll) of an object in radians, what is the normalized quaternion representation of these angles, and what are the corresponding Euler angles when converted back from this quaternion?\n\nThe input and output requirements are as follows:\n\nInput:\n  `yaw` (float): The yaw angle in radians.\n  `pitch` (float): The pitch angle in radians.\n  `roll` (float): The roll angle in radians.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `normalized_quaternion` (tuple): A tuple of four floats representing the normalized quaternion (w, x, y, z).\n    - `converted_euler_angles` (tuple): A tuple of three floats representing the Euler angles (yaw, pitch, roll) converted back from the normalized quaternion.", "reference_code": "# import necessary packages\nfrom math import pi, sin, cos, asin, acos, atan2, sqrt\nimport random\n\n# all class and function definitions in the code file, if any\ndef quaternion_mgnitude(w, x, y, z):\n    return sqrt(w*w + x*x + y*y + z*z)\n\ndef quaternion_normalise(w, x, y, z):\n    mag = sqrt(w*w + x*x + y*y + z*z)\n    return w/mag, x/mag, y/mag, z/mag\n\ndef quaternion_from_axis_angle(vector, theta):\n    sin_half_theta = sin(theta/2)\n    return cos(theta/2), vector[0]*sin_half_theta, vector[1]*sin_half_theta, vector[2]*sin_half_theta\n\ndef quaternion_to_rotation_matrix_rows(w, x, y, z):\n    x2 = x*x\n    y2 = y*2\n    z2 = z*2\n    row0 = (1 - 2*y2 - 2*z2,\n            2*x*y - 2*w*z,\n            2*x*z + 2*w*y)\n    row1 = (2*x*y + 2*w*z,\n            1 - 2*x2 - 2*z2,\n            2*y*z - 2*w*x)\n    row2 = (2*x*z - 2*w*y,\n            2*y*z + 2*w*x,\n            1 - 2*x2 - 2*y2)\n    return row0, row1, row2\n\ndef quaternion_from_rotation_matrix_rows(row0, row1, row2):\n    trace = row0[0] + row1[1] + row2[2]\n    if trace > row2[2]:\n        S = sqrt(1.0 + trace) *  2\n        w = 0.25 * S\n        x = (row2[1] - row1[2]) / S\n        y = (row0[2] - row2[0]) / S\n        z = (row1[0] - row0[1]) / S\n    elif row0[0] < row1[1] and row0[0] < row2[2]:\n        S = sqrt(1.0 + row0[0] - row1[1] - row2[2]) * 2\n        w = (row2[1] - row1[2]) / S\n        x = 0.25 * S\n        y = (row0[1] + row1[0]) / S\n        z = (row0[2] + row2[0]) / S\n    elif row1[1] < row2[2]:\n        S = sqrt(1.0 + row1[1] - row0[0] - row2[2]) * 2\n        w = (row0[2] - row2[0]) / S\n        x = (row0[1] + row1[0]) / S\n        y = 0.25 * S\n        z = (row1[2] + row2[1]) / S\n    else:\n        S = sqrt(1.0 + row2[2] - row0[0] - row1[1]) * 2\n        w = (row1[0] - row0[1]) / S\n        x = (row0[2] + row2[0]) / S\n        y = (row1[2] + row2[1]) / S\n        z = 0.25 * S\n    return w, x, y, z\n\ndef quaternion_from_euler_angles(yaw, pitch, roll):\n    return (cos(roll/2)*cos(pitch/2)*cos(yaw/2) + sin(roll/2)*sin(pitch/2)*sin(yaw/2),\n            sin(roll/2)*cos(pitch/2)*cos(yaw/2) - cos(roll/2)*sin(pitch/2)*sin(yaw/2),\n            cos(roll/2)*sin(pitch/2)*cos(yaw/2) + sin(roll/2)*cos(pitch/2)*sin(yaw/2),\n            cos(roll/2)*cos(pitch/2)*sin(yaw/2) - sin(roll/2)*sin(pitch/2)*cos(yaw/2))\n\ndef quaternion_to_euler_angles(w, x, y, z):\n    w2 = w*w\n    x2 = x*x\n    y2 = y*y\n    z2 = z*z\n    return (atan2(2.0 * (x*y + z*w), (w2 + x2 - y2 - z2)),\n            asin(2.0 * (w*y - x*z) / (w2 + x2 + y2 + z2)),\n            atan2(2.0 * (y*z + x*w), (w2 - x2 - y2 + z2)))\n\ndef quaternion_multiply(a, b):\n    a_w, a_x, a_y, a_z = a\n    b_w, b_x, b_y, b_z = b\n    return (a_w*b_w - a_x*b_x - a_y*b_y - a_z*b_z,\n            a_w*b_x + a_x*b_w + a_y*b_z - a_z*b_y,\n            a_w*b_y - a_x*b_z + a_y*b_w + a_z*b_x,\n            a_w*b_z + a_x*b_y - a_y*b_x + a_z*b_w)\n\ndef quaternion_scalar_multiply(q, s):\n    w, x, y, z = q\n    return (w*s, x*s, y*s, z*s)\n\n# main function\ndef main_solution(yaw, pitch, roll):\n    # Convert Euler angles to quaternion\n    quaternion = quaternion_from_euler_angles(yaw, pitch, roll)\n    \n    # Normalize the quaternion\n    normalized_quaternion = quaternion_normalise(*quaternion)\n    \n    # Convert the normalized quaternion back to Euler angles\n    euler_angles = quaternion_to_euler_angles(*normalized_quaternion)\n    \n    # Return the normalized quaternion and the converted Euler angles\n    return {\n        \"normalized_quaternion\": normalized_quaternion,\n        \"converted_euler_angles\": euler_angles\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    yaw = random.uniform(-math.pi, math.pi)\n    pitch = random.uniform(-math.pi/2, math.pi/2)\n    roll = random.uniform(-math.pi, math.pi)\n    return {\n        \"yaw\": yaw,\n        \"pitch\": pitch,\n        \"roll\": roll\n    }", "io_pairs": [{"input": {"yaw": -2.8381463151709205, "pitch": -1.0631763070184712, "roll": 1.6612130422958966}, "output": {"normalized_quaternion": [0.45783510405446426, -0.24174779269507868, -0.6808111343334422, -0.5181131358980458], "converted_euler_angles": [-2.8381463151709205, -1.063176307018471, 1.6612130422958968]}}, {"input": {"yaw": -3.10267811611857, "pitch": 1.497337065723252, "roll": -2.2341260673072973}, "output": {"normalized_quaternion": [0.6179241130042716, 0.2854837420882485, 0.664149640310798, -0.3091505763316835], "converted_euler_angles": [-3.102678116118569, 1.4973370657232516, -2.234126067307297]}}, {"input": {"yaw": 0.31250775335806225, "pitch": 0.5515361692835543, "roll": 1.1764100491876324}, "output": {"normalized_quaternion": [0.8142632928272789, 0.49214761741976154, 0.306850877356873, -0.02466884041551998], "converted_euler_angles": [0.31250775335806225, 0.5515361692835544, 1.1764100491876321]}}, {"input": {"yaw": 2.224461999673853, "pitch": -1.1959568436671373, "roll": 0.31897012890280196}, "output": {"normalized_quaternion": [0.28103742692435013, 0.5565052764728631, -0.12835157876801245, 0.7712624158827923], "converted_euler_angles": [2.224461999673853, -1.1959568436671373, 0.318970128902802]}}, {"input": {"yaw": -2.2494378088973286, "pitch": 0.7926925712579687, "roll": 1.1444231565056873}, "output": {"normalized_quaternion": [0.14600005758606474, 0.5083016383081759, -0.31061284286645335, -0.7898310512536908], "converted_euler_angles": [-2.2494378088973286, 0.7926925712579689, 1.1444231565056875]}}, {"input": {"yaw": -0.9218887253678787, "pitch": -1.4929768421632337, "roll": -0.6402350729546393}, "output": {"normalized_quaternion": [0.529017437914723, -0.49358952619325036, -0.4745492476865507, -0.5013112222308549], "converted_euler_angles": [-0.9218887253678794, -1.4929768421632335, -0.6402350729546397]}}, {"input": {"yaw": 2.159750679906831, "pitch": 1.4360583053845648, "roll": 1.795294963379078}, "output": {"normalized_quaternion": [0.6749901066571946, -0.08413410909862414, 0.7126525398254392, 0.17156970910227945], "converted_euler_angles": [2.1597506799068293, 1.436058305384564, 1.7952949633790765]}}, {"input": {"yaw": 0.037230594431545416, "pitch": -1.217068526658188, "roll": 0.47678225071285096}, "output": {"normalized_quaternion": [0.7946318231572737, 0.20405599226488383, -0.5517955330252943, 0.14981023790072712], "converted_euler_angles": [0.037230594431545375, -1.2170685266581882, 0.47678225071285113]}}, {"input": {"yaw": 2.616645641118513, "pitch": -0.7322141231145395, "roll": 2.8855518988368463}, "output": {"normalized_quaternion": [-0.3119620681504707, 0.28443065268978474, 0.8825106642575765, 0.2072529838564338], "converted_euler_angles": [2.616645641118513, -0.7322141231145394, 2.8855518988368463]}}, {"input": {"yaw": -2.7250283984663706, "pitch": 0.6341000530018994, "roll": -2.9226138520532556}, "output": {"normalized_quaternion": [0.3246692877845992, -0.1619664044717436, 0.9311017533063563, -0.037500165089851024], "converted_euler_angles": [-2.7250283984663706, 0.6341000530018995, -2.9226138520532556]}}], "error_log": []}
{"context": "Given the classic n-queens puzzle, where you need to place `n` queens on an `n`\u00d7`n` chessboard such that no two queens can attack each other, what are the distinct configurations of the queens' placements for a given board size `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (List[List[str]]): A list of all distinct solutions to the n-queens puzzle. Each solution is represented as a list of strings, where each string represents a row on the chessboard. 'Q' indicates a queen, and '.' indicates an empty space.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        result = []\n\n        def isVaild(j, set):\n            for i in range(0, len(set)):\n                if set[i] == j or abs(i - len(set)) == abs(set[i] - j):\n                    return False\n            return True\n\n        def callback(i, set):\n            if len(set) == n:\n                temp = []\n                for k in range(0, n):\n                    row = '.' * set[k] + 'Q' + '.' * (n - set[k] - 1)\n                    temp.append(row)\n                result.append(temp)\n                return\n                \n            for j in range(0, n):\n                if isVaild(j, set):\n                    set.append(j)\n                    callback(i + 1, set)\n                    set.pop()\n\n        for i in range(0, n):\n            callback(0, [i])\n\n        return result\n\n# main function\ndef main_solution(n):\n    # Convert JSON serializable input to the original input variables\n    n = int(n)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    s = Solution()\n    result = s.solveNQueens(n)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.choice([4, 5, 6, 7, 8])\n    return {'n': n}", "io_pairs": [{"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}], "error_log": []}
{"context": "In a simplified version of Yahtzee, a player rolls a set of dice and must decide which dice to hold to maximize their expected score. Given a specific hand of dice and the number of sides on each die, what is the optimal strategy for holding the dice to achieve the highest expected score?\n\nThe input and output requirements are as follows:\n\nInput:\n  `hand` (list of integers): A list of integers representing the dice in the hand. Each integer should be between 1 and `num_die_sides`.\n  `num_die_sides` (integer): An integer representing the number of sides on each die. This should be a positive integer.\n\nOutput:\n  `return` (dictionary): A dictionary with the following keys:\n    - `expected_score` (float): The expected score when holding the optimal dice.\n    - `dice_to_hold` (list of integers): A list of integers representing the dice to hold for the optimal strategy.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef gen_all_sequences(outcomes, length):\n    \"\"\"\n    Iterative function that enumerates the set of all sequences of\n    outcomes of given length.\n    \"\"\"\n    answer_set = set([()])\n    for dummy_idx in range(length):\n        temp_set = set()\n        for partial_sequence in answer_set:\n            for item in outcomes:\n                new_sequence = list(partial_sequence)\n                new_sequence.append(item)\n                temp_set.add(tuple(new_sequence))\n        answer_set = temp_set\n    return answer_set\n\ndef score(hand):\n    \"\"\"\n    Compute the maximal score for a Yahtzee hand according to the\n    upper section of the Yahtzee score card.\n\n    hand: full yahtzee hand\n\n    Returns an integer score \n    \"\"\"\n    roll = {}\n    for dice in hand:\n        roll[dice] = roll.get(dice, 0) + dice\n        \n    max_dice = None\n    max_val = 0\n    \n    for dice, val in roll.items():\n        if max_dice == None:\n            max_dice = dice\n            max_val = val\n        elif val > max_val:\n            max_dice = dice\n            max_val = val\n            \n    return max_val\n\ndef expected_value(held_dice, num_die_sides, num_free_dice):\n    \"\"\"\n    Compute the expected value based on held_dice given that there\n    are num_free_dice to be rolled, each with num_die_sides.\n\n    held_dice: dice that you will hold\n    num_die_sides: number of sides on each die\n    num_free_dice: number of dice to be rolled\n\n    Returns a floating point expected value\n    \"\"\"\n    die = [num + 1 for num in range(num_die_sides)]\n    outcomes = gen_all_sequences(die, num_free_dice)\n    \n    total = 0\n    n_cases = 0\n    for num in outcomes:\n        hand = held_dice + num\n        total = total + score(hand)\n        n_cases = n_cases + 1\n    \n    return total / float(n_cases)\n\ndef gen_all_holds(hand):\n    \"\"\"\n    Generate all possible choices of dice from hand to hold.\n\n    hand: full yahtzee hand\n\n    Returns a set of tuples, where each tuple is dice to hold\n    \"\"\"\n    power_set = set([()])\n    \n    for roll in hand:\n        temp_set = set(power_set)\n        for subset in power_set:\n            new_subset = list(subset)\n            new_subset.append(roll)\n            temp_set.add(tuple(new_subset))\n        power_set = temp_set\n    \n    return power_set\n\ndef strategy(hand, num_die_sides):\n    \"\"\"\n    Compute the hold that maximizes the expected value when the\n    discarded dice are rolled.\n\n    hand: full yahtzee hand\n    num_die_sides: number of sides on each die\n\n    Returns a tuple where the first element is the expected score and\n    the second element is a tuple of the dice to hold\n    \"\"\"\n    all_holds = gen_all_holds(hand)\n    hand_length = len(hand)\n\n    max_val = 0\n    max_held = None\n    \n    for held_dice in all_holds:\n        free_dice = hand_length - len(held_dice) \n        held_val = expected_value(held_dice, num_die_sides, free_dice)\n        \n        if(held_val >= max_val):\n            max_val = held_val\n            max_held = held_dice\n  \n    return (max_val, max_held)\n\n# main function\ndef main_solution(hand, num_die_sides):\n    \"\"\"\n    Compute the optimal strategy for a given Yahtzee hand and number of die sides.\n\n    hand: list of integers representing the dice in the hand\n    num_die_sides: integer representing the number of sides on each die\n\n    Returns a dictionary with keys 'expected_score' and 'dice_to_hold'\n    \"\"\"\n    hand = tuple(hand)  # Convert list to tuple for compatibility with existing functions\n    expected_score, dice_to_hold = strategy(hand, num_die_sides)\n    return {\n        'expected_score': expected_score,\n        'dice_to_hold': list(dice_to_hold)  # Convert tuple to list for JSON serialization\n    }", "input_generator": "import random\n\ndef input_generator():\n    num_die_sides = random.randint(4, 8)  # Reasonable number of sides (e.g., 4 to 8)\n    hand_size = random.randint(3, 5)  # Reasonable hand size (e.g., 3 to 5 dice)\n    hand = tuple(random.randint(1, num_die_sides) for _ in range(hand_size))\n    return {\n        'hand': list(hand),\n        'num_die_sides': num_die_sides\n    }", "io_pairs": [{"input": {"hand": [4, 3, 2], "num_die_sides": 5}, "output": {"expected_score": 6.16, "dice_to_hold": [4]}}, {"input": {"hand": [2, 3, 4, 6, 5], "num_die_sides": 6}, "output": {"expected_score": 10.691358024691358, "dice_to_hold": [6]}}, {"input": {"hand": [5, 1, 3, 5, 3], "num_die_sides": 6}, "output": {"expected_score": 12.657407407407407, "dice_to_hold": [5, 5]}}, {"input": {"hand": [5, 1, 2], "num_die_sides": 5}, "output": {"expected_score": 7.16, "dice_to_hold": [5]}}, {"input": {"hand": [2, 2, 3, 1, 4], "num_die_sides": 5}, "output": {"expected_score": 8.5504, "dice_to_hold": [4]}}, {"input": {"hand": [6, 5, 5], "num_die_sides": 7}, "output": {"expected_score": 10.714285714285714, "dice_to_hold": [5, 5]}}, {"input": {"hand": [1, 2, 5, 6, 2], "num_die_sides": 8}, "output": {"expected_score": 11.1025390625, "dice_to_hold": [6]}}, {"input": {"hand": [6, 5, 8], "num_die_sides": 8}, "output": {"expected_score": 10.1875, "dice_to_hold": [8]}}, {"input": {"hand": [4, 4, 2, 4], "num_die_sides": 5}, "output": {"expected_score": 12.8, "dice_to_hold": [4, 4, 4]}}, {"input": {"hand": [5, 3, 2], "num_die_sides": 5}, "output": {"expected_score": 7.16, "dice_to_hold": [5]}}], "error_log": []}
{"context": "Given a matrix, how can we obtain its representation after rotating it 180 degrees?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of integers): A 2D list representing the matrix to be rotated. Each sublist represents a row in the matrix.\n\nOutput:\n  `return` (list of lists of integers): A 2D list representing the matrix after being rotated 180 degrees. Each sublist represents a row in the rotated matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix):\n    # Convert the input list to a numpy array\n    matrix = np.array(matrix)\n    \n    # Rotate the matrix 180 degrees\n    rotated_matrix = np.rot90(matrix, 2)\n    \n    # Convert the numpy array back to a list\n    rotated_matrix = rotated_matrix.tolist()\n    \n    # Return the rotated matrix\n    return rotated_matrix", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    rows = random.randint(1, 10)\n    cols = random.randint(1, 10)\n    matrix = [[random.randint(0, 100) for _ in range(cols)] for _ in range(rows)]\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[94, 85, 55, 45, 84], [32, 66, 30, 85, 8]]}, "output": [[8, 85, 30, 66, 32], [84, 45, 55, 85, 94]]}, {"input": {"matrix": [[39, 62, 4, 23], [18, 58, 25, 75]]}, "output": [[75, 25, 58, 18], [23, 4, 62, 39]]}, {"input": {"matrix": [[62], [65]]}, "output": [[65], [62]]}, {"input": {"matrix": [[1, 42, 88, 44], [52, 15, 98, 70]]}, "output": [[70, 98, 15, 52], [44, 88, 42, 1]]}, {"input": {"matrix": [[18], [66]]}, "output": [[66], [18]]}, {"input": {"matrix": [[39, 26, 77], [95, 47, 4]]}, "output": [[4, 47, 95], [77, 26, 39]]}, {"input": {"matrix": [[99, 92, 11], [63, 60, 85]]}, "output": [[85, 60, 63], [11, 92, 99]]}, {"input": {"matrix": [[42]]}, "output": [[42]]}, {"input": {"matrix": [[65, 96, 59, 46], [37, 46, 9, 67], [10, 41, 35, 18]]}, "output": [[18, 35, 41, 10], [67, 9, 46, 37], [46, 59, 96, 65]]}, {"input": {"matrix": [[83, 6, 96, 92, 62, 51, 62, 5, 94, 72]]}, "output": [[72, 94, 5, 62, 51, 62, 92, 96, 6, 83]]}], "error_log": []}
{"context": "Given a sequence of integers that forms a quadratic sequence, what would be the next set of integers in the sequence that matches the same quadratic pattern?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_list` (str): A JSON string representing a list of integers. The list should contain at least three integers to form a valid quadratic sequence.\n\nOutput:\n  `return` (str): A JSON string representing a list of integers. This list is the continuation of the quadratic sequence derived from the input list.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef quad_sequence(lst):\n    x = len(lst)\n    for n in range(x - 1, 2 * x - 1):\n        p = lst[-1]\n        lst.append(p + (lst[1] - lst[0]) + (lst[0] - 2 * lst[1] + lst[2]) * n)\n    return lst[x:]\n\n# main function\ndef main_solution(input_list):\n    # Convert input_list to a list of integers\n    input_list = json.loads(input_list)\n    \n    # Call the quad_sequence function\n    result = quad_sequence(input_list)\n    \n    # Convert the result to a JSON serializable format\n    result_json = json.dumps(result)\n    \n    return result_json", "input_generator": "import json\nimport random\n\ndef input_generator():\n    # Generate a random quadratic sequence initial terms\n    a = random.randint(-10, 10)\n    b = random.randint(-10, 10)\n    c = random.randint(-10, 10)\n    input_list = [a, b, c]\n    \n    return {'input_list': json.dumps(input_list)}", "io_pairs": [{"input": {"input_list": "[-6, 2, -4]"}, "output": "[-24, -58, -106]"}, {"input": {"input_list": "[-4, 9, 5]"}, "output": "[-16, -54, -109]"}, {"input": {"input_list": "[5, -7, 6]"}, "output": "[44, 107, 195]"}, {"input": {"input_list": "[3, 5, -2]"}, "output": "[-18, -43, -77]"}, {"input": {"input_list": "[-10, -10, -8]"}, "output": "[-4, 2, 10]"}, {"input": {"input_list": "[8, -7, 5]"}, "output": "[44, 110, 203]"}, {"input": {"input_list": "[-5, -7, -10]"}, "output": "[-14, -19, -25]"}, {"input": {"input_list": "[10, 10, -4]"}, "output": "[-32, -74, -130]"}, {"input": {"input_list": "[2, 0, 6]"}, "output": "[20, 42, 72]"}, {"input": {"input_list": "[1, 4, -6]"}, "output": "[-29, -65, -114]"}], "error_log": []}
{"context": "Given a number of iterations `n`, what is the value of the sum `S` calculated by iterating from 1 to `n`, where each term in the sum is given by the formula: \n\n\\[ S = \\sum_{k=1}^{n} \\frac{(-1)^k \\cdot (k^3 - 27)}{3 \\cdot (k+2)!} \\]\n\nThe result should be rounded to 6 decimal places.\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer representing the number of iterations for the calculation.\n\nOutput:\n  `return` (float): A float representing the calculated sum `S` with 6 decimal places.", "reference_code": "# import necessary packages\nimport random\nimport math\n\n# main function\ndef main_solution(n):\n    # Convert the input to the required type if necessary\n    n = int(n)\n    \n    # Initialize variables\n    k = 1\n    s = 0\n    \n    # Calculate the sum using the given formula\n    while k <= n:\n        s += ((-1)**k * (k**3 - 27)) / (3*math.factorial(k+2))\n        k += 1\n    \n    # Return the result as a float with 6 decimal places\n    return round(s, 6)", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(1, 20)\n    return {'n': n}", "io_pairs": [{"input": {"n": 18}, "output": 1.192515}, {"input": {"n": 20}, "output": 1.192515}, {"input": {"n": 19}, "output": 1.192515}, {"input": {"n": 2}, "output": 1.180556}, {"input": {"n": 1}, "output": 1.444444}, {"input": {"n": 7}, "output": 1.192476}, {"input": {"n": 16}, "output": 1.192515}, {"input": {"n": 10}, "output": 1.192515}, {"input": {"n": 11}, "output": 1.192515}, {"input": {"n": 13}, "output": 1.192515}], "error_log": []}
{"context": "Given a non-perfect square integer, what is the sum of the first 100 decimals of its square root when calculated using a specific sequence period and term?\n\nThe input and output requirements are as follows:\n\nInput:\n  `value` (int): The integer value for which the sequence period and decimals are to be calculated. Must be a non-perfect square.\n  `term` (int): The number of terms to consider in the sequence for calculating the decimals.\n\nOutput:\n  `return` (int): The sum of the first 100 decimals of the square root of the given `value`.", "reference_code": "# import necessary packages\nimport math\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef get_sequence_period(i):\n    sequence = [int(math.sqrt(i))]\n    num = -sequence[-1]\n    den = 1\n    orig_num = -num\n    orig_den = int(i - orig_num**2)\n    start = True\n\n    while True:\n        num = -num\n        den = int((i - num**2) / den)\n        if [orig_num, orig_den] == [num, den] and not start:\n            return sequence\n        # Finds the square root of the multiple of den that achieves the (num-den*mul)**2 closest to i\n        mul = int(((2 * num * den + math.sqrt(4 * (num**2) * (den**2) - 4 * (den**2) * ((num**2) - i))) / (2 * (den**2))))\n        sequence.append(mul)\n        num = num - den * mul\n\n        start = False\n\ndef decimals_n_value(value, term):\n    sequence = get_sequence_period(value)\n    sequence = sequence + (sequence[1:]) * (math.ceil(term / len(sequence[1:])))\n    a_num = sequence[0]\n    b_num = sequence[1] * sequence[0] + 1\n\n    a_den = 1\n    b_den = sequence[1]\n    for i in sequence[2:term]:\n        tmp_num = b_num\n        tmp_den = b_den\n        b_num = b_num * i + a_num\n        b_den = b_den * i + a_den\n        a_num = tmp_num\n        a_den = tmp_den\n    return b_num, b_den\n\ndef division(a, b):\n    quot = a // b\n    res = a % b\n    q = [quot]\n    while len(q) < 100:\n        if res < b:\n            res *= 10\n            while res < b:\n                res *= 10\n                q.append(0)\n        if len(q) == 100:\n            break\n        quot = res // b\n        res = res % b\n        q.append(quot)\n        if res == 0:\n            break\n    return q\n\n# main function\ndef main_solution(value, term):\n    # Convert JSON serializable inputs to the original input variables\n    value = int(value)\n    term = int(term)\n    \n    # Invoke the core logic\n    a, b = decimals_n_value(value, term)\n    decimals = division(a, b)\n    \n    # Convert the output to JSON serializable format\n    return sum(decimals)", "input_generator": "import random\nimport math\n\ndef input_generator():\n    non_square_numbers = [i for i in range(2, 100) if not math.isqrt(i) ** 2 == i]\n    value = random.choice(non_square_numbers)\n    term = random.randint(1, 50)\n    return {'value': value, 'term': term}", "io_pairs": [{"input": {"value": 20, "term": 26}, "output": 504}, {"input": {"value": 47, "term": 19}, "output": 447}, {"input": {"value": 38, "term": 9}, "output": 453}, {"input": {"value": 84, "term": 1}, "output": 598}, {"input": {"value": 5, "term": 28}, "output": 428}, {"input": {"value": 86, "term": 31}, "output": 444}, {"input": {"value": 65, "term": 48}, "output": 440}, {"input": {"value": 17, "term": 45}, "output": 441}, {"input": {"value": 63, "term": 4}, "output": 31}, {"input": {"value": 21, "term": 8}, "output": 460}], "error_log": []}
{"context": "Given a network of airports and their routes, which airports have the most flights? Specifically, identify the top 10 airports with the highest number of flights to or from other airports.\n\nThe input and output requirements are as follows:\n\nInput:\n  `nodes` (int): The number of nodes (airports) in the graph.\n  `edges` (int): The number of edges (routes) in the graph.\n\nOutput:\n  `return` (list of int): A list of node indices representing the top 10 airports with the most flights.", "reference_code": "# import necessary packages\nimport networkx as nx\nimport numpy as np\nimport copy as cp\n\n# all class and function definitions in the code file, if any\ndef random_graph(nodes, edges):\n    G = nx.Graph()\n    for n in range(nodes):\n        G.add_node(n)\n    e = 0\n    while e < edges:\n        u = np.random.randint(0, nodes)\n        v = np.random.randint(0, nodes)\n        if u != v and (u, v) not in G.edges and (v, u) not in G.edges:\n            G.add_edge(u, v)\n            e += 1\n    return G\n\n# main function\ndef main_solution(nodes, edges):\n    # Convert JSON serializable inputs to original input variables\n    G = random_graph(nodes, edges)\n    \n    # Compute the top 10 airports with the most flights\n    power_dict = {}\n    for node in G.nodes:\n        value = 0\n        for edge in G.edges(data=True):\n            (u, v, d) = edge\n            w = d.get('weight', 1)  # Default weight to 1 if not present\n            if node == edge[0] or node == edge[1]:\n                value += w\n        power_dict.setdefault(value, node)\n        \n    sorted_p = sorted(power_dict)[-10:]\n    sorted_p = reversed(sorted_p)\n\n    top_airports = []\n    for i in sorted_p:\n        top_airports.append(power_dict[i])\n    \n    # Return the top 10 airports with the most flights\n    return top_airports", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    nodes = random.randint(20, 100)\n    max_edges = min(nodes * (nodes - 1) // 2, 1000)  # Ensure reasonable number of edges\n    edges = random.randint(nodes, max_edges)\n    return {'nodes': nodes, 'edges': edges}", "io_pairs": [{"input": {"nodes": 50, "edges": 855}, "output": [0, 2, 15, 19, 3, 4, 5, 1, 14, 10]}, {"input": {"nodes": 30, "edges": 150}, "output": [1, 9, 20, 4, 11, 7, 3, 6, 13, 0]}, {"input": {"nodes": 97, "edges": 594}, "output": [56, 32, 40, 0, 13, 7, 3, 5, 33, 2]}, {"input": {"nodes": 70, "edges": 546}, "output": [17, 23, 11, 0, 19, 13, 16, 7, 3, 1]}, {"input": {"nodes": 50, "edges": 250}, "output": [1, 7, 13, 0, 16, 9, 4, 5, 2, 26]}, {"input": {"nodes": 26, "edges": 53}, "output": [5, 8, 1, 16, 3, 2, 0, 10]}, {"input": {"nodes": 33, "edges": 176}, "output": [32, 31, 4, 7, 3, 6, 12, 1, 21, 5]}, {"input": {"nodes": 22, "edges": 224}, "output": [0, 1, 15]}, {"input": {"nodes": 61, "edges": 787}, "output": [29, 32, 13, 18, 11, 4, 7, 2, 28, 0]}, {"input": {"nodes": 24, "edges": 89}, "output": [12, 16, 4, 0, 2, 3, 1, 20]}], "error_log": []}
{"context": "Given a computational art generation system that uses random functions to determine the color of each pixel in an image, what are the RGB values for a randomly selected pixel when the system is configured with specific minimum and maximum depths for the random functions, and the image dimensions are set to a certain width and height?\n\nThe input and output requirements are as follows:\n\nInput:\n  `min_depth` (int): The minimum depth of the random function.\n  `max_depth` (int): The maximum depth of the random function.\n  `x_size` (int): The width of the image.\n  `y_size` (int): The height of the image.\n\nOutput:\n  `return` (dict): A dictionary containing the RGB values for a specific pixel. The keys are \"red\", \"green\", and \"blue\", each with an integer value between 0 and 255.", "reference_code": "# import necessary packages\nfrom random import randint\nfrom math import cos, sin, pi\n\n# all class and function definitions in the code file, if any\ndef build_random_function(min_depth, max_depth):\n    \"\"\" Builds a random function of depth at least min_depth and depth\n        at most max_depth (see assignment writeup for definition of depth\n        in this context)\n\n        min_depth: the minimum depth of the random function\n        max_depth: the maximum depth of the random function\n        returns: the randomly generated function represented as a nested list\n                 (see assignment writeup for details on the representation of\n                 these functions)\n    \"\"\"\n    hello = ['x','y']\n    func = ['x','y','cos_pi','sin_pi','prod','square','average']\n    if max_depth == 1:\n        return hello[randint(0,1)]\n    else:\n        block = func[randint(2,6)]\n        if block == 'prod' or block == 'average': # accounts for when a block requires two inputs\n            return [block, build_random_function(min_depth-1, max_depth-1), build_random_function(min_depth-1, max_depth-1)]\n        else:\n           return [block, build_random_function(min_depth-1, max_depth-1)]\n\ndef evaluate_random_function(f, x, y):\n    \"\"\" Evaluate the random function f with inputs x,y\n        Representation of the function f is defined in the assignment writeup\n        f: the function to evaluate\n        x: the value of x to be used to evaluate the function\n        y: the value of y to be used to evaluate the function\n        returns: the function value\n    \"\"\"\n    if f[0] == 'x': # If the first index is x or y, we've already reached the innermost layer and can stop our recursion\n        return x\n    elif f[0] == 'y':\n        return y\n    elif f[0] == 'square':\n        return evaluate_random_function(f[1],x,y)**2\n    elif f[0] == 'average':\n        return (evaluate_random_function(f[1],x,y)+evaluate_random_function(f[2],x,y))/2\n    elif f[0] == 'cos_pi':\n        return cos(pi*evaluate_random_function(f[1],x,y))\n    elif f[0] == 'sin_pi':\n        return sin(pi*evaluate_random_function(f[1],x,y))\n    elif f[0] == 'prod':\n        return evaluate_random_function(f[1],x,y)*evaluate_random_function(f[2],x,y)\n\ndef remap_interval(val, input_interval_start, input_interval_end, output_interval_start, output_interval_end):\n    \"\"\" Given an input value in the interval [input_interval_start,\n        input_interval_end], return an output value scaled to fall within\n        the output interval [output_interval_start, output_interval_end].\n    \"\"\"\n    output_interval = float(output_interval_end - output_interval_start)\n    input_interval = float(input_interval_end - input_interval_start) # doesn't really matter which we float\n    scaled_val = (output_interval*(val - input_interval_start)/(input_interval)) + output_interval_start\n    return scaled_val\n\ndef color_map(val):\n    \"\"\" Maps input value between -1 and 1 to an integer 0-255, suitable for\n        use as an RGB color code.\n\n        val: value to remap, must be a float in the interval [-1, 1]\n        returns: integer in the interval [0,255]\n    \"\"\"\n    color_code = remap_interval(val, -1, 1, 0, 255)\n    return int(color_code)\n\n# main function\ndef main_solution(min_depth, max_depth, x_size, y_size):\n    \"\"\" Generates computational art by evaluating random functions for RGB channels.\n\n        min_depth: the minimum depth of the random function\n        max_depth: the maximum depth of the random function\n        x_size: the width of the image\n        y_size: the height of the image\n        returns: a dictionary with RGB values for a specific pixel (x, y)\n    \"\"\"\n    # Generate random functions for red, green, and blue channels\n    red_function = build_random_function(min_depth, max_depth)\n    green_function = build_random_function(min_depth, max_depth)\n    blue_function = build_random_function(min_depth, max_depth)\n\n    # Choose a specific pixel to evaluate\n    x = remap_interval(randint(0, x_size-1), 0, x_size, -1, 1)\n    y = remap_interval(randint(0, y_size-1), 0, y_size, -1, 1)\n\n    # Evaluate the functions for the chosen pixel\n    red_value = color_map(evaluate_random_function(red_function, x, y))\n    green_value = color_map(evaluate_random_function(green_function, x, y))\n    blue_value = color_map(evaluate_random_function(blue_function, x, y))\n\n    # Return the RGB values as a dictionary\n    return {\n        \"red\": red_value,\n        \"green\": green_value,\n        \"blue\": blue_value\n    }", "input_generator": "import random\nfrom random import randint\n\ndef input_generator():\n    min_depth = randint(1, 5)\n    max_depth = randint(min_depth, 10)\n    x_size = randint(10, 100)\n    y_size = randint(10, 100)\n    return {\n        \"min_depth\": min_depth,\n        \"max_depth\": max_depth,\n        \"x_size\": x_size,\n        \"y_size\": y_size\n    }", "io_pairs": [{"input": {"min_depth": 2, "max_depth": 4, "x_size": 11, "y_size": 81}, "output": {"red": 140, "green": 151, "blue": 130}}, {"input": {"min_depth": 1, "max_depth": 7, "x_size": 64, "y_size": 83}, "output": {"red": 202, "green": 246, "blue": 127}}, {"input": {"min_depth": 2, "max_depth": 4, "x_size": 70, "y_size": 24}, "output": {"red": 236, "green": 157, "blue": 127}}, {"input": {"min_depth": 4, "max_depth": 7, "x_size": 74, "y_size": 53}, "output": {"red": 128, "green": 252, "blue": 31}}, {"input": {"min_depth": 1, "max_depth": 7, "x_size": 86, "y_size": 97}, "output": {"red": 254, "green": 172, "blue": 206}}, {"input": {"min_depth": 5, "max_depth": 6, "x_size": 15, "y_size": 53}, "output": {"red": 94, "green": 138, "blue": 0}}, {"input": {"min_depth": 5, "max_depth": 7, "x_size": 36, "y_size": 70}, "output": {"red": 136, "green": 254, "blue": 167}}, {"input": {"min_depth": 1, "max_depth": 7, "x_size": 40, "y_size": 71}, "output": {"red": 127, "green": 179, "blue": 177}}, {"input": {"min_depth": 5, "max_depth": 9, "x_size": 76, "y_size": 39}, "output": {"red": 252, "green": 31, "blue": 172}}, {"input": {"min_depth": 2, "max_depth": 4, "x_size": 97, "y_size": 39}, "output": {"red": 254, "green": 74, "blue": 183}}], "error_log": []}
{"context": "In the context of space exploration, a rocket needs to achieve a certain velocity to escape the gravitational pull of a planet. Given the required velocity for a rocket to escape, what is the mass of the fuel required for the rocket to achieve this escape velocity?\n\nThe input and output requirements are as follows:\n\nInput:\n  `velocity` (float): The required velocity for the rocket to escape the planet, measured in meters per second (m/s).\n\nOutput:\n  `return` (float): The mass of the fuel required for the rocket, measured in kilograms (kg).", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(velocity):\n    \"\"\"\n    Calculate the mass of the fuel required for a rocket to escape the planet.\n    \n    Args:\n    velocity (float): The required velocity for the rocket to escape the planet.\n    \n    Returns:\n    float: The mass of the fuel required for the rocket.\n    \"\"\"\n    v_e = 2550  # exhaust velocity in m/s\n    mass_rocket = 250000  # mass of the rocket in kg\n    mass_fuel = mass_rocket * (math.exp(velocity / v_e) - 1)\n    return mass_fuel", "input_generator": "import random\n\ndef input_generator():\n    velocity = random.uniform(1000, 5000)\n    return {'velocity': velocity}", "io_pairs": [{"input": {"velocity": 3816.2505074225114}, "output": 866584.4921261718}, {"input": {"velocity": 3414.376421449333}, "output": 703779.0716300359}, {"input": {"velocity": 4924.319323156235}, "output": 1474282.9032712139}, {"input": {"velocity": 1842.5871568880843}, "output": 264936.7701106374}, {"input": {"velocity": 4863.9832044083105}, "output": 1433963.1493395714}, {"input": {"velocity": 3367.6444301452307}, "output": 686459.0482606669}, {"input": {"velocity": 2793.9604493398847}, "output": 497797.0983668288}, {"input": {"velocity": 3584.2818777415796}, "output": 769493.9484871748}, {"input": {"velocity": 4752.64917087691}, "output": 1362022.541357865}, {"input": {"velocity": 3302.5874024671593}, "output": 662869.7716283689}], "error_log": []}
{"context": "Given a set of triangles defined by their vertices, how many of these triangles contain the origin (0,0) within their interior?\n\nThe input and output requirements are as follows:\n\nInput:\n  `triangles` (list of lists): A list of triangles, where each triangle is represented as a list of six integers `[x0, y0, x1, y1, x2, y2]`. Each pair of integers represents the coordinates of a vertex of the triangle.\n\nOutput:\n  `return` (int): The number of triangles that contain the origin (0,0) within their interior.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef Area(x0, y0, x1, y1, x2, y2):\n    return 0.5 * (-y1 * x2 + y0 * (-x1 + x2) + x0 * (y1 - y2) + x1 * y2)\n\ndef S(x0, y0, x1, y1, x2, y2):\n    return 1 / (2 * Area(x0, y0, x1, y1, x2, y2)) * (y0 * x2 - x0 * y2)\n\ndef T(x0, y0, x1, y1, x2, y2):\n    return 1 / (2 * Area(x0, y0, x1, y1, x2, y2)) * (x0 * y1 - y0 * x1)\n\n# main function\ndef main_solution(triangles):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    count = 0\n    for triangle in triangles:\n        (x0, y0, x1, y1, x2, y2) = triangle\n        s = S(x0, y0, x1, y1, x2, y2)\n        t = T(x0, y0, x1, y1, x2, y2)\n        if s > 0 and t > 0 and 1 - s - t > 0:\n            count += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count", "input_generator": "import random\n\ndef input_generator():\n    num_triangles = random.randint(1, 20)\n    triangles = []\n    for _ in range(num_triangles):\n        # Generate three distinct points to form a triangle\n        x0, y0 = random.uniform(-10, 10), random.uniform(-10, 10)\n        x1, y1 = random.uniform(-10, 10), random.uniform(-10, 10)\n        x2, y2 = random.uniform(-10, 10), random.uniform(-10, 10)\n        # Ensure the points are not colinear (Area != 0)\n        while abs(0.5 * (-y1 * x2 + y0 * (-x1 + x2) + x0 * (y1 - y2) + x1 * y2)) < 1e-6:\n            x2, y2 = random.uniform(-10, 10), random.uniform(-10, 10)\n        triangles.append([x0, y0, x1, y1, x2, y2])\n    return {'triangles': triangles}", "io_pairs": [{"input": {"triangles": [[1.4409058213649377, -5.145740990026835, -7.140867781504843, -4.284496855826867, 5.885251716068771, 4.486527977823814], [-0.6633566484426563, -0.7963857956738849, 6.3463564489955, -0.8587376068261321, -5.620232089485572, 8.660603527257194]]}, "output": 2}, {"input": {"triangles": [[8.20768810368454, -6.827446940418911, 1.4538964808331905, -9.993644795974488, -3.6850509882687987, -1.7446345077966168]]}, "output": 0}, {"input": {"triangles": [[-0.12015629324783994, 9.099088395363005, -0.9658779088156493, -6.089541906642209, 9.001070437539859, -9.27116347155025]]}, "output": 1}, {"input": {"triangles": [[-7.8978808884301355, 7.622072857855041, 7.194208150705094, 5.716324968456988, -5.10143958053275, 5.247809290897456]]}, "output": 0}, {"input": {"triangles": [[5.329659884734351, 4.126316509856526, 7.303646967314368, -0.21568925086332946, -3.773066458619243, -9.022638037293824], [7.714498032885938, -8.11898839881011, -6.49773030759393, -8.681573288127062, 3.816050540832645, -8.109308796571433]]}, "output": 0}, {"input": {"triangles": [[-9.123114192757711, 6.348855188914598, 5.081861459664545, -5.614103547825899, 0.12643571037027712, 2.477669792023619], [7.775510222220515, 5.305069950974751, -0.8590868140538728, -7.980713070740817, 9.805547175910807, -9.589164373021434]]}, "output": 1}, {"input": {"triangles": [[-3.919142153694944, -3.45374197722818, -9.439747621635917, -9.831139575874792, 3.3881284376053316, 0.3953991423579595], [7.718482735089779, -0.29684862874431417, -0.1816133619402649, -1.0405977659664707, 8.435723950473623, -0.17642714813594473]]}, "output": 0}, {"input": {"triangles": [[1.9369628824117626, 3.8653733951071185, 3.1147070128263046, 3.474260406633089, -6.017517853771224, 6.6315030893388], [0.7686485733436079, -6.601006338136825, -2.65608114737093, -2.139003006107039, -3.088371018831751, 0.6348728741290639]]}, "output": 0}, {"input": {"triangles": [[-8.195602729658575, -9.475923000992521, -5.516805133242471, -5.504056415775209, -4.031865240979229, 5.285257444629487], [-4.357522692501807, 8.389512050146031, -3.6024924175715833, -0.49014791373620525, 9.550026410280058, 5.223587871427881]]}, "output": 0}, {"input": {"triangles": [[0.4333970568222405, 6.170915709166941, -9.55876711264162, 4.555060337762784, 1.9499356458246666, 4.103843476435525], [-0.3881281572250046, 2.6275203187659084, -9.787959145644802, 4.211038796089239, 3.2056701776561347, 1.3864964652827965]]}, "output": 0}], "error_log": []}
{"context": "Given a non-negative integer `m`, what is the fractional representation of the Bernoulli number B(m)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The non-negative integer for which the Bernoulli number B(m) is to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing the numerator and denominator of the Bernoulli number B(m) in its fractional form.\n    - `numerator` (int): The numerator of the Bernoulli number.\n    - `denominator` (int): The denominator of the Bernoulli number.", "reference_code": "# import necessary packages\nfrom math import factorial\nfrom fractions import Fraction\n\n# all class and function definitions in the code file, if any\nbinoDict = {}\nbernDict = {}\n\ndef binomial(n, r):\n    if (n, r) in binoDict:\n        return binoDict[(n, r)]\n    b = Fraction(factorial(n) // (factorial(r) * factorial(n-r)))\n    binoDict[(n, r)] = b\n    return b\n\ndef B(m):\n    if m == 0:\n        return Fraction(1, 1)\n    if m == 1:\n        return Fraction(1, 2)\n    if m % 2 == 1:\n        return 0\n    if m in bernDict:\n        return bernDict[m]\n    sigma = Fraction(0, 1)\n    for k in range(m):\n        sigma += binomial(m, k) * B(k) / (m - k + 1)\n    ans = Fraction(1, 1) - sigma\n    bernDict[m] = ans\n    return ans\n\n# main function\ndef main_solution(m):\n    # Convert input to Fraction if necessary\n    m = int(m)\n    \n    # Calculate the Bernoulli number\n    result = B(m)\n    \n    # Convert the result to a JSON serializable format\n    return {\"numerator\": result.numerator, \"denominator\": result.denominator}", "input_generator": "import random\nfrom fractions import Fraction\n\ndef input_generator():\n    m_options = [0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n    m = random.choice(m_options)\n    return {\"m\": m}", "io_pairs": [{"input": {"m": 0}, "output": {"numerator": 1, "denominator": 1}}, {"input": {"m": 12}, "output": {"numerator": -691, "denominator": 2730}}, {"input": {"m": 10}, "output": {"numerator": 5, "denominator": 66}}, {"input": {"m": 16}, "output": {"numerator": -3617, "denominator": 510}}, {"input": {"m": 1}, "output": {"numerator": 1, "denominator": 2}}, {"input": {"m": 14}, "output": {"numerator": 7, "denominator": 6}}, {"input": {"m": 20}, "output": {"numerator": -174611, "denominator": 330}}, {"input": {"m": 4}, "output": {"numerator": -1, "denominator": 30}}, {"input": {"m": 18}, "output": {"numerator": 43867, "denominator": 798}}, {"input": {"m": 8}, "output": {"numerator": -1, "denominator": 30}}], "error_log": []}
{"context": "In a secure communication system, two prime numbers `p` and `q` are used to encrypt a message `plainText` using a modified RSA algorithm. After encryption, the cipher text undergoes a series of modifications before being sent. On the receiver side, the cipher text is decrypted back to the original message. Given the prime numbers `p` and `q`, and the original message `plainText`, what is the decrypted message after the entire encryption and decryption process?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p` (int): A prime number used in the RSA algorithm.\n  `q` (int): Another prime number used in the RSA algorithm, different from `p`.\n  `plainText` (str): The plain text message to be encrypted and then decrypted. The string should only contain lowercase and uppercase English letters.\n\nOutput:\n  `return` (str): The decrypted text message, which should be the same as the input `plainText`.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# Checks if a number is prime or not\ndef isPrime(n):\n    if (n < 2): \n        return False\n    limit = int(math.sqrt(n))\n    for i in range(2, limit+1):\n        if n % i == 0:\n            return False\n    return True\n\n# Calculates the GCD of two numbers 'a' and 'b'\ndef gcd(a, b):\n    if (b == 0):\n        return a\n    return gcd(b, a % b)\n\n# Calculates the GCD of two numbers 'a' and 'b'\n# as well as coefficients 'x' and 'y' such that ax + by = GCD(a, b)\ndef egcd(a, b):\n    if (b == 0):\n        return [a, 1, 0]\n    else:\n        ans = egcd(b, a % b)\n        temp = ans[1] - ans[2] * (a // b)\n        ans[1] = ans[2]\n        ans[2] = temp\n        return ans\n\n# Calculates the multiplicative inverse\ndef multiplicativeInverse(a, b):\n    egcdArray = egcd(a, b)\n    bMultiplier = egcdArray[2]\n\n    if (bMultiplier < 0):\n        return (bMultiplier % a + a) % a\n    else:\n        return (bMultiplier % a)\n\n# Performs the exponentiation of large numbers (Binary Exponentiation)\ndef binaryPower(a, b, n):\n    if (b == 0):\n        return 1\n    result = binaryPower(a, int(b / 2), n)\n\n    # Odd power\n    if (b % 2 == 1):\n        return (result * result * a) % n\n    # Even power\n    else:\n        return (result * result) % n\n\n# Encrypts the plaintext (single integer)\ndef encrypt(M, e, n):\n    C = binaryPower(M, e, n) % n\n    return C\n\n# Decrypts the cipher text (single integer)\ndef decrypt(C, e, n):\n    M = binaryPower(C, e, n) % n\n    return M\n\n# Converts a string to list of corresponding numbers in Unicode\ndef stringToNumber(s):\n    nums = []\n    for i in s:\n        if (i.isupper()):\n            nums.append((ord(i) - 65 + 26))\n        else:\n            nums.append((ord(i) - 97))\n    return nums\n\n# Converts a list of numbers in Unicode to string\ndef numberToString(numList):\n    s = ''\n    for num in numList:\n        if (num > 25):\n            s += chr(num + 65 - 26)\n        else:\n            s += chr(num + 97)\n    return s\n\n# Performs right shift on the cipher text\n# by a specified number of bits\ndef shiftRightCipher(cipherText, p, q):\n    bits = math.ceil(max(p, q) / min(p, q))\n\n    # Modify each cipher in the list\n    for i in range(0, len(cipherText)):\n        cipherText[i] = (cipherText[i] * bits) + abs(p - q) \n\n    # Shuffle the cipher array \n    shiftPoint = (bits) % len(cipherText)\n    result = cipherText[shiftPoint : ] + cipherText[ : shiftPoint]\n    return result\n\n# Performs left shift on the cipher text\n# by a specified number of bits\ndef shiftLeftCipher(cipherText, p, q):\n    bits = math.ceil(max(p, q) / min(p, q))\n\n    # Regain each cipher in the list\n    for i in range(0, len(cipherText)):\n        cipherText[i] = int((cipherText[i] - abs(p - q)) / bits)\n\n    # Shuffle the array of ciphers\n    shiftPoint = (len(cipherText) - bits) % len(cipherText)\n    result = cipherText[shiftPoint : ] + cipherText[ : shiftPoint]\n    return result\n\n# Encrypts a string of characters\ndef encryptString(plainText, publicKey, p, q):\n    cipherList = []\n    # Converting plaintext(string) to numList(number)\n    numList = stringToNumber(plainText)\n    \n    for number in numList:\n        # Plain text (M < n)\n        M = number\n        C = encrypt(M, publicKey[0], publicKey[1])\n        cipherList.append(C)\n    \n    # Modifying cipherList\n    modifiedCipher = shiftRightCipher(cipherList, p, q)\n    return modifiedCipher\n\n# Decrypts a string of characters\ndef decryptString(cipherText, privateKey, p, q):\n    # Regaining the original cipher\n    cipherList = shiftLeftCipher(cipherText, p, q)\n    decryptList = []\n    \n    for cipher in cipherList:\n        M = decrypt(cipher, privateKey[0], privateKey[1])\n        decryptList.append(M)\n\n    # Converting decryptList(number) to decryptText(string)\n    decryptText = numberToString(decryptList)\n    return decryptText\n\n# Performs initial RSA steps\ndef initializeRSA(p, q):\n    # Calculation of n\n    n = p * q\n\n    # Calculation of phi(n)\n    phi = (p - 1) * (q - 1)\n\n    # Select integer e such that gcd(phi, e) = 1\n    for e in range(2, phi):\n        if (gcd(phi, e) == 1):\n            break\n\n    # Calculaiton of d\n    d = multiplicativeInverse(phi, e)\n\n    # Public and private keys\n    publicKey = [e, n]\n    privateKey = [d, n]\n\n    return publicKey, privateKey\n\n# main function\ndef main_solution(p, q, plainText):\n    # Ensure p and q are prime and different\n    if not isPrime(p) or not isPrime(q) or p == q:\n        raise ValueError(\"p and q must be different prime numbers.\")\n    \n    # Initialize RSA\n    publicKey, privateKey = initializeRSA(p, q)\n    \n    # Encrypt the plain text\n    cipherText = encryptString(plainText, publicKey, p, q)\n    \n    # Decrypt the cipher text\n    decryptedText = decryptString(cipherText, privateKey, p, q)\n    \n    # Return the decrypted text\n    return decryptedText", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate two distinct primes p and q between 100 and 1000\n    primes = []\n    for num in range(100, 1000):\n        if all(num % i != 0 for i in range(2, int(math.sqrt(num)) + 1)):\n            primes.append(num)\n    p, q = random.sample(primes, 2)\n    \n    # Generate a random plaintext string of length between 5 and 20\n    length = random.randint(5, 20)\n    plainText = ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', k=length))\n    \n    return {'p': p, 'q': q, 'plainText': plainText}", "io_pairs": [{"input": {"p": 137, "q": 947, "plainText": "ImwBowfyUqdWse"}, "output": "ImwBowfyUqdWse"}, {"input": {"p": 463, "q": 563, "plainText": "CvhcAgVLqmehiwlXyr"}, "output": "CvhcAgVLqmehiwlXyr"}, {"input": {"p": 919, "q": 461, "plainText": "AdTGnIoiHrAruT"}, "output": "AdTGnIoiHrAruT"}, {"input": {"p": 443, "q": 787, "plainText": "BUDQTHoAGUxnsVeD"}, "output": "BUDQTHoAGUxnsVeD"}, {"input": {"p": 359, "q": 103, "plainText": "xkSOhqXxJZhqnf"}, "output": "xkSOhqXxJZhqnf"}, {"input": {"p": 691, "q": 907, "plainText": "SVvFtjCCbI"}, "output": "SVvFtjCCbI"}, {"input": {"p": 659, "q": 127, "plainText": "vHRHANtFbQm"}, "output": "vHRHANtFbQm"}, {"input": {"p": 229, "q": 389, "plainText": "KamcPKPOklfsP"}, "output": "KamcPKPOklfsP"}, {"input": {"p": 953, "q": 683, "plainText": "ApsKxAbTkHOOzdRH"}, "output": "ApsKxAbTkHOOzdRH"}, {"input": {"p": 449, "q": 919, "plainText": "qQcDpjzIOXfXcpdEekIU"}, "output": "qQcDpjzIOXfXcpdEekIU"}], "error_log": []}
{"context": "In a Minesweeper game, a player attempts to clear a rectangular board containing hidden mines without detonating any of them. Each square on the board can either contain a mine or be empty. If a square is empty, it displays the number of mines in the surrounding eight squares. Given the dimensions of the board and the coordinates of a square to be revealed, what is the state of the board after revealing that square?\n\nThe input and output requirements are as follows:\n\nInput:\n- `cols` (int): The number of columns in the Minesweeper board.\n- `rows` (int): The number of rows in the Minesweeper board.\n- `reveal_x` (int): The x-coordinate (column index) of the square to be revealed.\n- `reveal_y` (int): The y-coordinate (row index) of the square to be revealed.\n\nOutput:\n- `return` (list of lists of int): A 2D list representing the Minesweeper board. Each element in the list is an integer:\n  - `-1` if the square is not revealed.\n  - The number of surrounding mines if the square is revealed.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Square():\n    def __init__(self, state, revealed, value, x, y):\n        self.state = state\n        self.revealed = revealed\n        self.value = value\n        self.x, self.y = x, y\n\n    def render_square(self):\n        if self.revealed:\n            return str(self.value)\n        else:\n            return '-'\n\nclass Squares():\n    def __init__(self, cols, rows):\n        cols, rows = int(cols), int(rows)\n        self.board = [[Square(False, False, 0, x, y) for x in range(cols)] for y in range(rows)]\n        self.total_squares = cols * rows\n        self.__randomize_mines(cols, rows, self.board)\n        self.__calculate_values(cols, rows, self.board)\n\n    def __randomize_mines(self, cols, rows, board):\n        self.total_mines = int(self.total_squares / 4)\n        remaining_mines = self.total_mines\n        xrange, yrange = range(cols), range(rows)\n\n        while remaining_mines > 0:\n            x, y = random.choice(xrange), random.choice(yrange)\n            if not board[y][x].state:\n                board[y][x].state = True\n                remaining_mines -= 1\n\n    def __calculate_values(self, cols, rows, board):\n        deltas = [\n            (-1, -1), (0, 1), (1, 1),\n            (-1, 0), (1, 0),\n            (-1, 1), (0, -1), (1, -1),\n        ]\n        for y in range(rows):\n            for x in range(cols):\n                if board[y][x].state:\n                    for delta in deltas:\n                        dx, dy = x + delta[0], y + delta[1]\n                        if self.__is_within_range(dx, dy, cols, rows):\n                            board[dy][dx].value += 1\n\n    def __is_within_range(self, x, y, cols, rows):\n        return x >= 0 and x < cols and y >= 0 and y < rows\n\n# main function\ndef main_solution(cols, rows, reveal_x, reveal_y):\n    # Initialize the game board\n    game = Squares(cols, rows)\n    \n    # Reveal the specified square\n    game.board[reveal_y][reveal_x].revealed = True\n    \n    # Collect the revealed values of the board\n    revealed_values = []\n    for row in game.board:\n        revealed_values.append([square.value if square.revealed else -1 for square in row])\n    \n    # Return the revealed values of the board\n    return revealed_values", "input_generator": "import random\n\ndef input_generator():\n    cols = random.randint(5, 15)\n    rows = random.randint(5, 15)\n    reveal_x = random.randint(0, cols - 1)\n    reveal_y = random.randint(0, rows - 1)\n    return {'cols': cols, 'rows': rows, 'reveal_x': reveal_x, 'reveal_y': reveal_y}", "io_pairs": [{"input": {"cols": 6, "rows": 5, "reveal_x": 0, "reveal_y": 0}, "output": [[0, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]}, {"input": {"cols": 5, "rows": 5, "reveal_x": 3, "reveal_y": 1}, "output": [[-1, -1, -1, -1, -1], [-1, -1, -1, 1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1]]}, {"input": {"cols": 6, "rows": 6, "reveal_x": 3, "reveal_y": 0}, "output": [[-1, -1, -1, 0, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]}, {"input": {"cols": 5, "rows": 6, "reveal_x": 4, "reveal_y": 2}, "output": [[-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, 2], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1]]}, {"input": {"cols": 6, "rows": 5, "reveal_x": 5, "reveal_y": 2}, "output": [[-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, 1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]}, {"input": {"cols": 5, "rows": 6, "reveal_x": 3, "reveal_y": 5}, "output": [[-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, 2, -1]]}, {"input": {"cols": 8, "rows": 5, "reveal_x": 4, "reveal_y": 1}, "output": [[-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, 3, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1]]}, {"input": {"cols": 8, "rows": 6, "reveal_x": 2, "reveal_y": 4}, "output": [[-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, 2, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1]]}, {"input": {"cols": 5, "rows": 6, "reveal_x": 3, "reveal_y": 2}, "output": [[-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, 4, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1]]}, {"input": {"cols": 8, "rows": 5, "reveal_x": 7, "reveal_y": 2}, "output": [[-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, 1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1]]}], "error_log": []}
{"context": "Given a puzzle configuration represented as a 2D list, and a specified heuristic, what is the calculated score of the puzzle based on the heuristic? The puzzle is a square grid of a given side length, and the heuristic can be one of 'manhattan', 'hamming', or 'sietse'.\n\nThe input and output requirements are as follows:\n\nInput:\n  `puzzle` (list of lists of integers): A 2D list representing the puzzle configuration. Each sublist represents a row in the puzzle.\n  `side_length` (integer): The side length of the puzzle, which is the number of rows or columns.\n  `heuristic` (string): The heuristic to use for scoring. Possible values are 'manhattan', 'hamming', or 'sietse'.\n\nOutput:\n  `return` (integer): The calculated score of the puzzle based on the specified heuristic.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Puzzle:\n    def __init__(self, puzzle=None, parent=None, side_length=3, gen_solution=False, move_made=None):\n        if puzzle != None:\n            self.puzzle = [row.copy() for row in puzzle]\n        else:\n            self.puzzle = None\n        self.parent = parent\n        self.score = 0\n        self.h_score = 0\n        self.g_score = 0\n        self.side_length = side_length\n        self.move_made = move_made\n        if (gen_solution == True):\n            self.generate_snail_solution(self.gen_empty_puzzle(side_length), 1, 0, 0, 'right')\n        else:\n            self.snail_solution = None\n    \n    def is_solvable(self):\n        inversions = 0\n        res = []\n        sol = []\n\n        for y in range(len(self.puzzle)):\n            for x in range(len(self.puzzle[y])):\n                res.append(self.puzzle[y][x])\n\n        for y in range(len(self.snail_solution)):\n            for x in range(len(self.snail_solution[y])):\n                sol.append(self.snail_solution[y][x])\n\n        for i in range(len(res)):\n            for j in range(i + 1, len(res)):\n                if sol.index(res[i]) > sol.index(res[j]):\n                    inversions += 1\n\n        if len(self.puzzle) % 2 == 0:\n            if inversions % 2 != 0:\n                return (False)\n            else:\n                return (True)\n        else:\n            if inversions % 2 == 0:\n                return (False)\n            else:\n                return (True)\n\n    def give_score(self, g_score, heur='manhattan'):\n        self.g_score = g_score\n        score = 0\n\n        if (heur == 'hamming'):\n            for y in range(len(self.puzzle)):\n                for x in range(len(self.puzzle)):\n                    if self.puzzle[y][x] != self.snail_solution[y][x] and self.puzzle[y][x] != 0:\n                        score += 1\n        elif (heur == 'manhattan') or (heur == 'sietse'):\n            for y in range(len(self.puzzle)):\n                for x in range(len(self.puzzle)):\n                    score += manhattan_distance(self.puzzle, self.snail_solution, y, x)\n        if (heur == 'sietse'):\n            pairs = []\n            for y in range(len(self.puzzle)):\n                for x in range(len(self.puzzle)):\n                    if self.puzzle[y][x] != self.snail_solution[y][x] and self.puzzle[y][x] != 0 and self.snail_solution[y][x] != 0:\n                        pairs.append([self.puzzle[y][x], self.snail_solution[y][x]])\n            for pair in pairs:\n                if pair[::-1] in pairs:\n                    score += 1\n        self.h_score = score\n\n        self.score = self.g_score + self.h_score\n\n    def set_side_length(self, side_length):\n        self.side_length = side_length\n    \n    def gen_empty_puzzle(self, side_length):\n        return ([[0 for x in range(side_length)] for x in range(side_length)])\n\n    def generate_snail_solution(self, puzzle, ctr, y, x, direction):\n        if ctr == (self.side_length * self.side_length):\n            self.snail_solution = puzzle\n        else:\n            if direction == 'right':\n                while x < len(puzzle) and puzzle[y][x] == 0:\n                    puzzle[y][x] = ctr\n                    ctr += 1\n                    x += 1\n                self.generate_snail_solution(puzzle, ctr, y + 1, x - 1, 'down')\n            elif direction == 'down':\n                while y < len(puzzle) and puzzle[y][x] == 0:\n                    puzzle[y][x] = ctr\n                    ctr += 1\n                    y += 1\n                self.generate_snail_solution(puzzle, ctr, y - 1, x - 1, 'left')\n            elif direction == 'left':\n                while x >= 0 and puzzle[y][x] == 0:\n                    puzzle[y][x] = ctr\n                    ctr += 1\n                    x -= 1\n                self.generate_snail_solution(puzzle, ctr, y - 1, x + 1, 'up')\n            elif direction == 'up':\n                while y >= 0 and puzzle[y][x] == 0:\n                    puzzle[y][x] = ctr\n                    ctr += 1\n                    y -= 1\n                self.generate_snail_solution(puzzle, ctr, y + 1, x + 1, 'right')\n\ndef manhattan_distance(puzzle, solution, y, x):\n    for i in range(len(solution)):\n        for j in range(len(solution[i])):\n            if solution[i][j] == puzzle[y][x]:\n                return (abs(i - y) + abs(j - x))\n\n# main function\ndef main_solution(puzzle, side_length, heuristic):\n    # Convert input to JSON serializable format\n    puzzle = [[int(x) for x in row] for row in puzzle]\n    side_length = int(side_length)\n    heuristic = str(heuristic)\n\n    # Initialize the Puzzle object\n    puzzle_obj = Puzzle(puzzle=puzzle, side_length=side_length, gen_solution=True)\n\n    # Calculate the score using the given heuristic\n    puzzle_obj.give_score(0, heur=heuristic)\n\n    # Return the score as a JSON serializable output\n    return puzzle_obj.score", "input_generator": "import random\n\ndef input_generator():\n    side_length = random.choice([3, 4])\n    heuristic = random.choice(['manhattan', 'hamming', 'sietse'])\n    \n    # Generate a solvable puzzle\n    puzzle = [[0 for _ in range(side_length)] for _ in range(side_length)]\n    numbers = list(range(1, side_length * side_length)) + [0]\n    random.shuffle(numbers)\n    \n    for i in range(side_length):\n        for j in range(side_length):\n            puzzle[i][j] = numbers.pop()\n    \n    # Ensure the puzzle is solvable by swapping if necessary\n    puzzle_obj = Puzzle(puzzle=puzzle, side_length=side_length, gen_solution=True)\n    if not puzzle_obj.is_solvable():\n        # Swap two non-zero elements to make it solvable\n        non_zero = []\n        for i in range(side_length):\n            for j in range(side_length):\n                if puzzle[i][j] != 0:\n                    non_zero.append((i, j))\n        if len(non_zero) >= 2:\n            a, b = random.sample(non_zero, 2)\n            puzzle[a[0]][a[1]], puzzle[b[0]][b[1]] = puzzle[b[0]][b[1]], puzzle[a[0]][a[1]]\n    \n    return {\n        'puzzle': puzzle,\n        'side_length': side_length,\n        'heuristic': heuristic\n    }", "io_pairs": [], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, given the current state of the board and which player is currently making the move, what is the best move and its corresponding score according to the minimax algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_state` (list of int): A list of 9 integers representing the current state of the Tic-Tac-Toe board. Each integer can be -1 (O), 0 (empty), or 1 (X).\n  `max_player` (bool): A boolean indicating whether the current player is the maximizing player (True) or the minimizing player (False).\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `score` (int): The score of the best move determined by the minimax algorithm.\n    - `move` (int): The index of the best move on the board (0-8).", "reference_code": "# import necessary packages\nfrom copy import deepcopy\nfrom random import randint\n\n# all class and function definitions in the code file, if any\nclass Board(object):\n    def __init__(self):\n        self.board = [0 for _ in range(9)]\n\n    def winner(self):\n        def winning_line(a, b, c):\n            if (\n                self.board[a] != 0 and\n                self.board[a] == self.board[b] == self.board[c]\n            ):\n                return self.board[a]\n\n        lines = [\n            [0, 1, 2], [3, 4, 5], [6, 7, 8],\n            [0, 3, 6], [1, 4, 7], [2, 5, 8],\n            [0, 4, 8], [2, 4, 6]]\n\n        for a, b, c in lines:\n            res = winning_line(a, b, c)\n            if res:\n                return res\n\n    def valid_moves(self):\n        return [i for i in range(9) if self.board[i] == 0]\n\n    def is_full(self):\n        return len(self.valid_moves()) == 0\n\n    def apply(self, i, player):\n        self.board[i] = player\n\n    def __str__(self):\n        def x(i):\n            r = { -1 : 'O', 0 : '.', 1: 'X'}\n            return r[self.board[i]]\n\n        return '%s %s %s\\n%s %s %s\\n%s %s %s' % (\n            x(0), x(1), x(2), x(3), x(4), x(5), x(6), x(7), x(8))\n\n\ndef minimax(board, max_player):\n    winner = board.winner()\n    if winner:\n        return winner, None\n\n    best_move, best_score = None, 0\n    player = 1 if max_player else -1\n\n    for move in board.valid_moves():\n        new_board = deepcopy(board)\n        new_board.apply(move, player)\n        score, _ = minimax(new_board, not max_player)\n        # if the move is a winning move, pick it, and return\n        if score == player:\n            return player, move\n        if best_move is None:\n            best_score = score\n            best_move = move\n        else:\n            if (\n                (max_player and score > best_score) or\n                (not max_player and score < best_score)\n            ):\n                best_score = score\n                best_move = move\n\n    return best_score, best_move\n\n# main function\ndef main_solution(board_state, max_player):\n    # Convert JSON serializable input to original input variables\n    board = Board()\n    board.board = board_state\n\n    # Apply the minimax algorithm to determine the best move\n    score, move = minimax(board, max_player)\n\n    # Convert the output to JSON serializable format\n    return {\"score\": score, \"move\": move}", "input_generator": "import random\nfrom random import randint\n\ndef input_generator():\n    board_state = [0] * 9\n    max_player = random.choice([True, False])\n    \n    # Randomly fill some positions with -1 or 1, ensuring no winner\n    for i in range(random.randint(0, 5)):\n        pos = random.choice([idx for idx, val in enumerate(board_state) if val == 0])\n        board_state[pos] = random.choice([-1, 1])\n    \n    # Ensure no winner\n    def has_winner(board):\n        lines = [\n            [0, 1, 2], [3, 4, 5], [6, 7, 8],\n            [0, 3, 6], [1, 4, 7], [2, 5, 8],\n            [0, 4, 8], [2, 4, 6]\n        ]\n        for a, b, c in lines:\n            if board[a] != 0 and board[a] == board[b] == board[c]:\n                return True\n        return False\n    \n    while has_winner(board_state):\n        board_state = [0] * 9\n        for i in range(random.randint(0, 5)):\n            pos = random.choice([idx for idx, val in enumerate(board_state) if val == 0])\n            board_state[pos] = random.choice([-1, 1])\n    \n    return {\"board_state\": board_state, \"max_player\": max_player}", "io_pairs": [{"input": {"board_state": [-1, 0, 0, 0, 0, 0, 0, 0, 0], "max_player": true}, "output": {"score": 0, "move": 4}}, {"input": {"board_state": [0, 0, -1, 0, 1, 1, 0, 0, 1], "max_player": true}, "output": {"score": 1, "move": 0}}, {"input": {"board_state": [1, 0, 0, -1, 0, -1, 0, 1, -1], "max_player": false}, "output": {"score": -1, "move": 1}}, {"input": {"board_state": [1, -1, 0, 0, 0, 1, 0, -1, 1], "max_player": false}, "output": {"score": -1, "move": 4}}, {"input": {"board_state": [0, 0, 1, 0, 1, 0, -1, 1, 1], "max_player": false}, "output": {"score": 1, "move": 0}}, {"input": {"board_state": [0, 0, 0, 0, 0, 0, 0, 0, 0], "max_player": true}, "output": {"score": 0, "move": 0}}, {"input": {"board_state": [0, 0, 0, 0, 0, 0, 0, 1, -1], "max_player": true}, "output": {"score": 0, "move": 0}}, {"input": {"board_state": [0, 0, 0, 0, 1, 0, 0, 0, 0], "max_player": false}, "output": {"score": 0, "move": 0}}, {"input": {"board_state": [0, 0, -1, 0, 0, 0, 0, 0, 0], "max_player": true}, "output": {"score": 0, "move": 4}}, {"input": {"board_state": [0, 1, 0, 0, 1, 1, 0, -1, 0], "max_player": true}, "output": {"score": 1, "move": 0}}], "error_log": []}
{"context": "In a historical game of elimination, a group of people stand in a circle. Starting from a given person, every k-th person is eliminated until only one person remains. Given the number of people in the circle and the step count, which position in the circle will be the last remaining person?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of people in the circle.\n  `k` (int): The step count to eliminate the next person.\n\nOutput:\n  `return` (int): The position of the last remaining person in the circle.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef josephus_problem(array, k, index):\n    if len(array) == 1:\n        return array[0]\n    index = (index + k) % len(array)\n    array.pop(index)\n    return josephus_problem(array, k, index)\n\n# main function\ndef main_solution(n, k):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    array = [i for i in range(1, n + 1)]\n    index = 0\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = josephus_problem(array, k - 1, index)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 100)\n    k = random.randint(1, n)\n    return {'n': n, 'k': k}", "io_pairs": [{"input": {"n": 15, "k": 8}, "output": 15}, {"input": {"n": 23, "k": 6}, "output": 17}, {"input": {"n": 45, "k": 19}, "output": 14}, {"input": {"n": 24, "k": 16}, "output": 20}, {"input": {"n": 74, "k": 5}, "output": 8}, {"input": {"n": 59, "k": 59}, "output": 44}, {"input": {"n": 91, "k": 69}, "output": 61}, {"input": {"n": 58, "k": 29}, "output": 21}, {"input": {"n": 72, "k": 46}, "output": 1}, {"input": {"n": 34, "k": 25}, "output": 26}], "error_log": []}
{"context": "In an egg washing system, the valve position is determined by the level of dirt on the eggs and the flow rate of the washing system. Given the level of dirt on the eggs (`EggDirt`) and the flow rate of the washing system (`FlowRate`), what is the optimal valve position for the washing system?\n\nThe input and output requirements are as follows:\n\nInput:\n  `EggDirt` (float): The level of dirt on the eggs, ranging from 0.0 (no dirt) to 1.0 (very dirty).\n  `FlowRate` (float): The flow rate of the washing system, ranging from 0.0 (no flow) to 1.0 (maximum flow).\n\nOutput:\n  `return` (float): The calculated valve position for the washing system, rounded to two decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\nclass IdentityFunction:\n    def __init__(self, name, a, m, n, b):\n        self.name = name\n        self.a = a\n        self.m = m\n        self.n = n\n        self.b = b\n\n    @classmethod\n    def MakeSymmetricalTriangle(cls, name, a, b):\n        m = (a + b) / 2\n        return cls(name, a, m, m, b)\n\n    @classmethod\n    def MakeTriangle(cls, name, a, m, b):\n        return cls(name, a, m, m, b)\n\n    @classmethod\n    def MakeTrapazoid(cls, name, a, m, n, b):\n        return cls(name, a, m, n, b)\n\n    def GetName(self):\n        return self.name\n    \n    def GetMidPoint(self):\n        return (self.m + self.n) / 2\n\n    def Calculate(self, v):\n        if v < self.a:\n            return 0\n        elif v < self.m:\n            return (v - self.a) / (self.m - self.a)\n        elif v < self.n:\n            return 1\n        elif v < self.b:\n            return (self.b - v) / (self.b - self.n)\n        else:\n            return 0\n\nclass FuzzyOperator:\n    @staticmethod\n    def FuzzAnd(a, b):\n        return min(a, b)\n\n    @staticmethod \n    def FuzzOr(a, b):\n        return max(a, b)\n\n# main function\ndef main_solution(EggDirt, FlowRate):\n    # Define the membership functions for the Egg Wash system\n    EggDirtLow = IdentityFunction.MakeSymmetricalTriangle(\"Low\", 0.0, 0.5)\n    EggDirtAcceptable = IdentityFunction.MakeSymmetricalTriangle(\"Acceptable\", 0.25, 0.75)\n    EggDirtHigh = IdentityFunction.MakeSymmetricalTriangle(\"High\", 0.5, 1.0)\n\n    FlowRateLow = IdentityFunction.MakeSymmetricalTriangle(\"Low\", 0.0, 0.75)\n    FlowRateHigh = IdentityFunction.MakeSymmetricalTriangle(\"High\", 0.25, 1.0)\n\n    ValvePositionLow = IdentityFunction.MakeSymmetricalTriangle(\"Low\", 0.0, 0.5)\n    ValvePositionMedium = IdentityFunction.MakeSymmetricalTriangle(\"Medium\", 0.25, 0.75)\n    ValvePositionHigh = IdentityFunction.MakeSymmetricalTriangle(\"High\", 0.5, 1.0)\n\n    # Step 1 Fuzzification\n    EggDirtLowDOM = EggDirtLow.Calculate(EggDirt)\n    EggDirtAcceptableDOM = EggDirtAcceptable.Calculate(EggDirt)\n    EggDirtHighDOM = EggDirtHigh.Calculate(EggDirt)\n\n    FlowRateLowDOM = FlowRateLow.Calculate(FlowRate)\n    FlowRateHighDOM = FlowRateHigh.Calculate(FlowRate)\n\n    # Aggregation\n    PositionLow1 = FuzzyOperator.FuzzAnd(EggDirtLowDOM, FlowRateLowDOM)\n    PositionLow2 = FuzzyOperator.FuzzAnd(EggDirtLowDOM, FlowRateHighDOM)\n    PositionMedimum1 = EggDirtAcceptableDOM\n    PositionHigh1 = FuzzyOperator.FuzzAnd(EggDirtHighDOM, FlowRateLowDOM)\n    PositionHigh2 = FuzzyOperator.FuzzAnd(EggDirtHighDOM, FlowRateHighDOM)\n\n    # Composition\n    PositionLowDOM = FuzzyOperator.FuzzOr(PositionLow1, PositionLow2)\n    PositionMedimumDOM = PositionMedimum1\n    PositionHighDOM = FuzzyOperator.FuzzOr(PositionHigh1, PositionHigh2)\n\n    # Defuzzification\n    ValvePosition = PositionLowDOM * ValvePositionLow.GetMidPoint() + PositionMedimumDOM * ValvePositionMedium.GetMidPoint() + PositionHighDOM * ValvePositionHigh.GetMidPoint()\n    \n    return round(ValvePosition, 2)", "input_generator": "import random\n\ndef input_generator():\n    EggDirt = random.uniform(0.0, 1.0)\n    FlowRate = random.uniform(0.0, 1.0)\n    return {'EggDirt': EggDirt, 'FlowRate': FlowRate}", "io_pairs": [{"input": {"EggDirt": 0.004642439298164325, "FlowRate": 0.43122496859630166}, "output": 0.0}, {"input": {"EggDirt": 0.24601725424924603, "FlowRate": 0.08317169909829591}, "output": 0.06}, {"input": {"EggDirt": 0.24052893719998603, "FlowRate": 0.4092904458211417}, "output": 0.23}, {"input": {"EggDirt": 0.9750482084236354, "FlowRate": 0.5007430582017016}, "output": 0.07}, {"input": {"EggDirt": 0.1599161684985384, "FlowRate": 0.18658321328605432}, "output": 0.12}, {"input": {"EggDirt": 0.9441396703134721, "FlowRate": 0.7718910837381955}, "output": 0.17}, {"input": {"EggDirt": 0.03694226552067681, "FlowRate": 0.5960634271054195}, "output": 0.04}, {"input": {"EggDirt": 0.58219688884288, "FlowRate": 0.17657750197559696}, "output": 0.58}, {"input": {"EggDirt": 0.8907478134832979, "FlowRate": 0.6325683026998612}, "output": 0.33}, {"input": {"EggDirt": 0.7729881530823004, "FlowRate": 0.36356220537828}, "output": 0.68}], "error_log": []}
{"context": "Given a chessboard of size N\u00d7N, where N is the number of queens to be placed, determine the positions on the board where the queens can be placed such that no two queens can attack each other. The positions should be determined based on a given chance parameter that controls the iteration over the board positions. What are the positions where the queens can be safely placed?\n\nThe input and output requirements are as follows:\n\nInput:\n  `queens` (int): The number of queens to place on the board.\n  `chance` (int): A parameter to control the iteration over the board positions.\n\nOutput:\n  `return` (List[List[int]]): A list of positions where queens are placed. Each position is represented as a list of two integers `[row, column]`.", "reference_code": "# import necessary packages\nfrom typing import List, Generator\n\n# all class and function definitions in the code file, if any\ndef position_Generator(n: int = 4) -> Generator[List[int], None, None]:\n    \"\"\"\n    generator to send back a position [0, 0]\n    :param n: number of queens\n    :return: yields a position in the chess\n    \"\"\"\n    return ([i, j] for i in range(0, n) for j in range(0, n))\n\ndef horizontal_attack(pos: List[int], h_queens: int) -> List[List[int]]:\n    \"\"\"\n    attack the position horizontally and sends back a list of death\n    :param h_queens: number of queens\n    :param pos: position to attack from with the queen\n    :return: list of deaths\n    \"\"\"\n    list_deaths = []\n    pos_gen = position_Generator(h_queens)\n    while True:\n        try:\n            new_pos = next(pos_gen)\n        except StopIteration:\n            break\n        if pos == new_pos:\n            continue\n        if pos[0] == new_pos[0]:\n            list_deaths.append(new_pos)\n    return list_deaths\n\ndef vertical_attack(pos: List[int], v_queens: int) -> List[List[int]]:\n    \"\"\"\n    attack the position vertically and sends back a list of death\n    :param v_queens: number of queens\n    :param pos: position to attack from with the queen\n    :return: list of deaths\n    \"\"\"\n    list_deaths = []\n    pos_gen = position_Generator(v_queens)\n    while True:\n        try:\n            new_pos = next(pos_gen)\n        except StopIteration:\n            break\n        if pos == new_pos:\n            continue\n        if pos[1] == new_pos[1]:\n            list_deaths.append(new_pos)\n    return list_deaths\n\ndef diagonal_attack(pos: List[int], d_queens: int) -> List[List[int]]:\n    \"\"\"\n    attack the position diagonal and sends back a list of death\n    :param d_queens: number of queens\n    :param pos: position to attack from with the queen\n    :return: list of deaths\n    \"\"\"\n    list_deaths = []\n    pos_gen = position_Generator(d_queens)\n    while True:\n        try:\n            new_pos = next(pos_gen)\n        except StopIteration:\n            break\n        if pos == new_pos:\n            continue\n        if pos[0] + pos[1] == new_pos[0] + new_pos[1]:\n            list_deaths.append(new_pos)\n        if pos[0] - new_pos[0] == pos[1] - new_pos[1]:\n            list_deaths.append(new_pos)\n    return list_deaths\n\ndef has_horse_distance(pos: List[int], temp_queens: List[List[int]], queens: int) -> bool:\n    \"\"\"\n    check if current square is a horse movement distance from last queen\n    :param queens: number of queen to accommodate\n    :param pos: current position\n    :param temp_queens: previous queen position\n    :return: false if not a distance of horse else true\n    \"\"\"\n    pre_queen = temp_queens[-1]\n    if pre_queen[1] == queens - 3 and pos[1] != queens - 1:\n        return False\n\n    for queen in temp_queens:\n        if pos == queen:\n            return True\n        if pos[0] - 1 == queen[0] and pos[1] - 2 == queen[1]:\n            return True\n        elif pos[0] - 2 == queen[0] and pos[1] - 1 == queen[1]:\n            return True\n        elif pos[0] - 2 == queen[0] and pos[1] + 1 == queen[1]:\n            return True\n        elif pos[0] - 1 == queen[0] and pos[1] + 2 == queen[1]:\n            return True\n        elif pos[0] + 1 == queen[0] and pos[1] + 2 == queen[1]:\n            return True\n        elif pos[0] + 2 == queen[0] and pos[1] + 1 == queen[1]:\n            return True\n        elif pos[0] + 2 == queen[0] and pos[1] - 1 == queen[1]:\n            return True\n        elif pos[0] + 1 == queen[0] and pos[1] - 2 == queen[1]:\n            return True\n    return False\n\n# main function\ndef main_solution(queens: int, chance: int) -> List[List[int]]:\n    \"\"\"\n    Main function to solve the N-Queens puzzle with a given number of queens and a chance parameter.\n    :param queens: Number of queens to place on the board.\n    :param chance: A parameter to control the iteration over the board positions.\n    :return: List of positions where queens are placed.\n    \"\"\"\n    queen_positions = []\n    it = position_Generator(queens)\n    list_death = []\n    \n    for k in range(0, chance):\n        try:\n            next(it)\n        except StopIteration:\n            break\n\n    while True:\n        try:\n            square = next(it)\n        except StopIteration:\n            break\n\n        if not queen_positions:\n            queen_positions.append(square)\n\n        if has_horse_distance(square, queen_positions, queens):\n            if square not in list_death:\n                for dead in horizontal_attack(square, queens):\n                    list_death.append(dead)\n                for dead in vertical_attack(square, queens):\n                    list_death.append(dead)\n                for dead in diagonal_attack(square, queens):\n                    list_death.append(dead)\n                if square not in queen_positions:\n                    queen_positions.append(square)\n\n    return queen_positions", "input_generator": "import random\n\ndef input_generator():\n    queens = random.randint(4, 8)  # Reasonable board size between 4x4 and 8x8\n    chance = random.randint(0, queens * queens - 1)  # Chance within the range of possible squares\n    return {'queens': queens, 'chance': chance}", "io_pairs": [{"input": {"queens": 8, "chance": 53}, "output": [[6, 5], [7, 7]]}, {"input": {"queens": 8, "chance": 16}, "output": [[2, 0], [3, 2], [4, 4], [5, 1], [6, 3]]}, {"input": {"queens": 4, "chance": 10}, "output": [[2, 2], [3, 0]]}, {"input": {"queens": 4, "chance": 9}, "output": [[2, 1], [3, 3]]}, {"input": {"queens": 6, "chance": 16}, "output": [[2, 4], [3, 2], [4, 0], [5, 3]]}, {"input": {"queens": 5, "chance": 2}, "output": [[0, 2], [1, 4], [2, 1], [3, 3], [4, 0]]}, {"input": {"queens": 6, "chance": 15}, "output": [[2, 3], [3, 5], [4, 2], [5, 0]]}, {"input": {"queens": 6, "chance": 26}, "output": [[4, 2], [5, 0]]}, {"input": {"queens": 7, "chance": 26}, "output": [[3, 5], [4, 3], [5, 1], [6, 4]]}, {"input": {"queens": 8, "chance": 45}, "output": [[5, 5], [6, 7], [7, 4]]}], "error_log": []}
{"context": "The Collatz Conjecture is a famous unsolved problem in mathematics. It states that for any positive integer \\( n \\), if you repeatedly apply the following rules:\n1. If \\( n \\) is even, divide it by 2.\n2. If \\( n \\) is odd, multiply it by 3 and add 1.\n\nEventually, you will always reach the number 1. Given an upper limit \\( t \\), can you verify if the Collatz Conjecture holds true for all numbers up to \\( t \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `t` (int): The upper limit up to which the Collatz Conjecture should be verified. It should be a positive integer.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the Collatz Conjecture holds true up to the given limit `t`. Returns `True` if the conjecture holds, otherwise `False`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef collatz(x, col):\n    if x in col:\n        return True\n    else:\n        if x % 2:\n            c = collatz(3 * x + 1, col)\n            if c:\n                col.add(x)\n                return c\n        else:\n            c = collatz(x // 2, col)\n            if c:\n                col.add(x)\n                return c\n\ndef CollatzVerifyTo(t, col):\n    for i in range(1, t):\n        if not collatz(i, col):\n            return False\n    return True\n\n# main function\ndef main_solution(t):\n    # Convert JSON serializable input to original input variables\n    col = {4}\n    \n    # Invoke the core function\n    result = CollatzVerifyTo(t, col)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    t = random.randint(5, 1000)\n    return {'t': t}", "io_pairs": [{"input": {"t": 522}, "output": true}, {"input": {"t": 635}, "output": true}, {"input": {"t": 572}, "output": true}, {"input": {"t": 363}, "output": true}, {"input": {"t": 637}, "output": true}, {"input": {"t": 301}, "output": true}, {"input": {"t": 705}, "output": true}, {"input": {"t": 577}, "output": true}, {"input": {"t": 185}, "output": true}, {"input": {"t": 885}, "output": true}], "error_log": []}
{"context": "Given an angle in radians, how can we determine the sine value using both a built-in mathematical function and a custom iterative approach? Specifically, what are the sine values calculated using the built-in `sin` function and the custom `mans_sinuss` function for a given angle `x`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): The input angle in radians for which the sine function is to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `builtin_sin` (float): The sine value of `x` calculated using the built-in `sin` function, rounded to 2 decimal places.\n    - `custom_sin` (float): The sine value of `x` calculated using the custom `mans_sinuss` function, rounded to 2 decimal places.", "reference_code": "# import necessary packages\nfrom math import sin\n\n# all class and function definitions in the code file, if any\ndef mans_sinuss(x):\n    k = 0\n    a = (-1)**0 * x**1 / (1)\n    S = a\n\n    while k < 500:\n        k += 1\n        R = (-1) * x * x / ((2 * k) * (2 * k + 1))\n        a = a * R\n        S += a\n\n    return S\n\n# main function\ndef main_solution(x):\n    # Convert the input to a float if necessary\n    x = float(x)\n    \n    # Calculate the sine value using the built-in function\n    y = sin(x)\n    \n    # Calculate the sine value using the custom function\n    custom_sin = mans_sinuss(x)\n    \n    # Return the results as a dictionary\n    return {\n        \"builtin_sin\": round(y, 2),\n        \"custom_sin\": round(custom_sin, 2)\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random float between -2*pi and 2*pi for reasonable sine calculation\n    x = random.uniform(-2 * math.pi, 2 * math.pi)\n    return {\"x\": x}", "io_pairs": [{"input": {"x": 4.724640296919333}, "output": {"builtin_sin": -1.0, "custom_sin": -1.0}}, {"input": {"x": -5.394316214442142}, "output": {"builtin_sin": 0.78, "custom_sin": 0.78}}, {"input": {"x": 1.1314530513015857}, "output": {"builtin_sin": 0.91, "custom_sin": 0.91}}, {"input": {"x": 2.365784447247659}, "output": {"builtin_sin": 0.7, "custom_sin": 0.7}}, {"input": {"x": 1.1145490292124034}, "output": {"builtin_sin": 0.9, "custom_sin": 0.9}}, {"input": {"x": -4.359031084519488}, "output": {"builtin_sin": 0.94, "custom_sin": 0.94}}, {"input": {"x": -2.247272585480909}, "output": {"builtin_sin": -0.78, "custom_sin": -0.78}}, {"input": {"x": 1.5586425897266647}, "output": {"builtin_sin": 1.0, "custom_sin": 1.0}}, {"input": {"x": -5.819353766468989}, "output": {"builtin_sin": 0.45, "custom_sin": 0.45}}, {"input": {"x": -2.494976769940182}, "output": {"builtin_sin": -0.6, "custom_sin": -0.6}}], "error_log": []}
{"context": "Given a vector space of dimension `d`, a probability `prob`, a sigma value `sigma`, and a vector `x` of `d` values, what is the value of the discriminant function computed using these inputs?\n\nThe input and output requirements are as follows:\n\nInput:\n  `d` (int): The dimension of the vector space.\n  `prob` (float): The probability value between 0 and 1.\n  `sigma` (float): The sigma value for the discriminant function.\n  `x` (list of float): A list of `d` float values representing the vector `x`.\n\nOutput:\n  `return` (float): The value of the discriminant function.", "reference_code": "# import necessary packages\nimport random\nimport numpy as np\n\n# main function\ndef main_solution(d, prob, sigma, x):\n    # Convert input variables to appropriate types if necessary\n    d = int(d)\n    prob = float(prob)\n    sigma = float(sigma)\n    x = list(map(float, x))\n    \n    # creating a random mean vector of dimension d \n    mean = [random.randrange(-10, 10) for _ in range(d)]\n    \n    # Computing discriminant function\n    dis = np.log(prob)\n    for i in range(d):\n        x[i] -= mean[i]\n    dis += -0.5 * np.power(np.linalg.norm(x), 2) / np.power(sigma, 2)\n    \n    # Convert output to JSON serializable format\n    dis = float(dis)\n    \n    return dis", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    d = random.randint(1, 10)\n    prob = random.uniform(0.01, 0.99)\n    sigma = random.uniform(0.1, 5.0)\n    x = [random.uniform(-10.0, 10.0) for _ in range(d)]\n    return {'d': d, 'prob': prob, 'sigma': sigma, 'x': x}", "io_pairs": [{"input": {"d": 2, "prob": 0.58651884677867, "sigma": 1.7079258905180443, "x": [9.004493522170606, -0.9817765270117462]}, "output": -15.15629403795504}, {"input": {"d": 7, "prob": 0.48034040864101085, "sigma": 1.347363129483582, "x": [3.7685406587428023, -1.3666127963870611, -1.0712865693455793, -0.8824980835004741, 8.868644797129711, 7.623330407546998, -3.943452063414636]}, "output": -109.59367241821128}, {"input": {"d": 10, "prob": 0.8365207315720303, "sigma": 1.4650971972682765, "x": [0.3355954064787259, -5.027635585134531, -5.704033260971306, -0.8688625989082297, 0.3048956115829231, 1.3781917044942222, 0.06192492120693416, -7.203240551542313, 8.723240720722742, 7.695382939144103]}, "output": -140.59251706571573}, {"input": {"d": 7, "prob": 0.882391069852662, "sigma": 1.1776222781985908, "x": [-7.358842367221197, 5.405395470965127, -4.44310141610333, -4.920118872434558, -2.8141480274498987, 4.0763778731824, -6.340889467637085]}, "output": -137.26704878701477}, {"input": {"d": 4, "prob": 0.34351570623777694, "sigma": 1.2938528582440658, "x": [7.880323559777793, 4.159587680631521, -5.914614812732186, -5.441833804145981]}, "output": -55.38880892699943}, {"input": {"d": 7, "prob": 0.818510025876552, "sigma": 4.285598041689693, "x": [-2.35041005384212, 4.895138526047058, -3.265017160565204, 7.92052384485665, -7.93975138824099, -3.4682215238375758, -9.005406185578595]}, "output": -9.815959064586169}, {"input": {"d": 9, "prob": 0.6925297950553944, "sigma": 4.6442084016776555, "x": [-1.0693454034715941, 5.971858512985309, -0.7581597748675328, -4.8740122340481555, 0.3711326222426141, 6.815677439652369, 0.580131940575356, -1.7775551264515492, -6.7347260173017]}, "output": -9.358365343708233}, {"input": {"d": 4, "prob": 0.39297941586036067, "sigma": 4.4444721053215455, "x": [-8.341117268566443, -8.496461003169468, -7.709153508194637, -1.7047545139875098]}, "output": -17.307612437380644}, {"input": {"d": 9, "prob": 0.5865123483425305, "sigma": 4.238832823591057, "x": [2.1302334239824177, 9.395291010178727, -3.292018219929435, -7.9927234529163655, -4.543514394969483, 3.145587035843107, -7.258095306452235, 3.702157714850509, 1.222008234324468]}, "output": -15.271282730058294}, {"input": {"d": 1, "prob": 0.685281300524581, "sigma": 2.813195526392362, "x": [0.40464471212257713]}, "output": -0.4003193993720545}], "error_log": []}
{"context": "Given a mountain represented by a 2D grid where each cell contains an elevation value, determine the longest path that can be skied, starting from any point on the mountain, with the largest difference in elevation. The skier can only move to adjacent cells (north, south, east, or west) with a lower elevation. What is the sequence of elevations that form this longest path with the largest drop?\n\nThe input and output requirements are as follows:\n\nInput:\n  `grid` (list of lists of integers): A 2D grid representing the elevation map of the mountain. Each element in the grid represents the elevation at that point.\n\nOutput:\n  `return` (list of integers): A list representing the longest path with the largest difference in elevation. Each element in the list represents the elevation at a point in the path.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef getSuccessorState(px, py, grid, x, y):\n    if px < 0 or px > x-1 or py < 0 or py > y-1:\n        raise ValueError(\"Invalid point given!\")\n    options = []\n    currentElevation = grid[py][px]\n    # West option\n    if px > 0 and currentElevation > grid[py][px-1]:\n        options.append((py, px-1))\n    # East option\n    if px < x-1 and currentElevation > grid[py][px+1]:\n        options.append((py, px+1))\n    # South option\n    if py < y-1 and currentElevation > grid[py+1][px]:\n        options.append((py+1, px))\n    # North option\n    if py > 0 and currentElevation > grid[py-1][px]:\n        options.append((py-1, px))\n    return options\n\ndef dp_dfs(px, py, grid, x, y, record):\n    if (py, px) in record:\n        return record[(py, px)]\n    nextStates = getSuccessorState(px, py, grid, x, y)\n    currentElevation = grid[py][px]\n    if not nextStates:\n        return [[currentElevation]]\n    localCopy = []\n    for coords in nextStates:\n        newy, newx = coords\n        if (newy, newx) in record:\n            cache = record[(newy, newx)]\n            for route in cache:\n                newRoute = [currentElevation]\n                newRoute.extend(route)\n                localCopy.append(newRoute)\n            continue\n        possibleRoutes = dp_dfs(newx, newy, grid, x, y, record)\n        for route in possibleRoutes:\n            newRoute = list(route)\n            newRoute.insert(0, currentElevation)\n            localCopy.append(newRoute)\n    record[(py, px)] = localCopy\n    return localCopy\n\ndef selectLargestDiff(paths):\n    diff = [paths[i][0] - paths[i][-1] for i in range(len(paths))]\n    maxDiff = max(diff)\n    return [paths[i] for i in range(len(paths)) if diff[i] == maxDiff]\n\n# main function\ndef main_solution(grid):\n    x = len(grid[0])\n    y = len(grid)\n    record = {}\n    possiblePaths = {}\n    currentMax = float(\"-inf\")\n    \n    for i in range(y):\n        for j in range(x):\n            temp = dp_dfs(j, i, grid, x, y, record)\n            if not temp:\n                continue\n            for path in temp:\n                if not path:\n                    continue\n                length = len(path)\n                if length < currentMax:\n                    continue\n                currentMax = length\n                if length in possiblePaths:\n                    possiblePaths[length].append(path)\n                else:\n                    possiblePaths[length] = [path]\n    \n    ans = selectLargestDiff(possiblePaths[currentMax])[0]\n    return ans", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(3, 10)\n    cols = random.randint(3, 10)\n    grid = []\n    for _ in range(rows):\n        row = [random.randint(1, 100) for _ in range(cols)]\n        grid.append(row)\n    return {'grid': grid}", "io_pairs": [{"input": {"grid": [[70, 54, 89, 54], [92, 39, 30, 54], [76, 38, 28, 56]]}, "output": [92, 70, 54, 39, 30, 28]}, {"input": {"grid": [[35, 5, 56], [53, 91, 13], [90, 60, 81]]}, "output": [91, 53, 35, 5]}, {"input": {"grid": [[53, 15, 74], [41, 93, 12], [20, 11, 81]]}, "output": [93, 41, 20, 11]}, {"input": {"grid": [[44, 95, 94, 5], [31, 88, 48, 80], [15, 27, 66, 95]]}, "output": [95, 44, 31, 15]}, {"input": {"grid": [[19, 17, 99], [48, 72, 18], [26, 45, 17], [26, 71, 22]]}, "output": [72, 48, 19, 17]}, {"input": {"grid": [[75, 60, 3, 96], [42, 64, 2, 90], [66, 69, 64, 62]]}, "output": [69, 64, 60, 3, 2]}, {"input": {"grid": [[69, 34, 3], [14, 10, 54], [86, 53, 73]]}, "output": [86, 53, 10]}, {"input": {"grid": [[27, 61, 50], [23, 92, 5], [28, 13, 19]]}, "output": [92, 61, 50, 5]}, {"input": {"grid": [[83, 68, 94], [78, 93, 88], [75, 94, 86]]}, "output": [94, 93, 78, 75]}, {"input": {"grid": [[10, 1, 54, 69], [34, 42, 96, 42], [6, 54, 51, 5]]}, "output": [96, 42, 34, 10, 1]}], "error_log": []}
{"context": "Given a matrix with `m` rows and `n` columns, where each element is a real number, what is the Frobenius norm of the matrix? The Frobenius norm is defined as the square root of the sum of the squares of all the elements in the matrix.\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The number of rows in the matrix.\n  `n` (int): The number of columns in the matrix.\n  `a` (list of lists of floats): The matrix represented as a list of lists, where each inner list represents a row of the matrix.\n\nOutput:\n  `return` (float): The Frobenius norm of the matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(m, n, a):\n  # Convert the input list to a numpy array\n  a_np = np.array(a)\n  \n  # Compute the Frobenius norm of the matrix\n  value = np.sqrt(np.sum(a_np ** 2))\n  \n  # Return the Frobenius norm as a float\n  return float(value)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    m = random.randint(1, 10)\n    n = random.randint(1, 10)\n    a = np.random.rand(m, n).tolist()\n    return {'m': m, 'n': n, 'a': a}", "io_pairs": [{"input": {"m": 3, "n": 1, "a": [[0.6989164699786634], [0.692821545095215], [0.6715319540155821]]}, "output": 1.1914029925342402}, {"input": {"m": 1, "n": 9, "a": [[0.8976822841002258, 0.04315286513853056, 0.6208572498879602, 0.1171579435952863, 0.4390570332478225, 0.4161196400068877, 0.9396144403464135, 0.9400540413597339, 0.13136167278681699]]}, "output": 1.8321148383626078}, {"input": {"m": 2, "n": 1, "a": [[0.10098547686292791], [0.1079651566233567]]}, "output": 0.14783281632282763}, {"input": {"m": 1, "n": 8, "a": [[0.5121034533264458, 0.5263576089283621, 0.1924730975244492, 0.03891109538395765, 0.4955853376109224, 0.3549321898109047, 0.24691629899200385, 0.08953693806873919]]}, "output": 1.0091721628175339}, {"input": {"m": 1, "n": 1, "a": [[0.019584264921558625]]}, "output": 0.019584264921558625}, {"input": {"m": 2, "n": 3, "a": [[0.3183665700313767, 0.8101217344493108, 0.38492440255301685], [0.5650570518108007, 0.38906910052987076, 0.49045483846296634]]}, "output": 1.2716255260812719}, {"input": {"m": 2, "n": 3, "a": [[0.746541879359237, 0.8465374420917446, 0.22867503545439116], [0.3800321688729189, 0.5562767928979733, 0.8608606009393321]]}, "output": 1.587826182012773}, {"input": {"m": 4, "n": 2, "a": [[0.12420298751818126, 0.4806312908050494], [0.27941375724122997, 0.23174010450085258], [0.560657770113978, 0.7459373100565886], [0.3667909156873239, 0.9566494556442895]]}, "output": 1.5161403978913017}, {"input": {"m": 2, "n": 6, "a": [[0.14994554948764782, 0.18570904909050856, 0.706165954193225, 0.36673534253493956, 0.9331399670097285, 0.6227142189851824], [0.7278988956452654, 0.45411213750922463, 0.8198728402059478, 0.526500109855301, 0.519883447352417, 0.6743218110161815]]}, "output": 2.0878450758500557}, {"input": {"m": 1, "n": 9, "a": [[0.9783207681431133, 0.5428168966642217, 0.20640750310841816, 0.24908422393970764, 0.7282710657744995, 0.1589193889739503, 0.16762427294357118, 0.12334620686429854, 0.7863360046430597]]}, "output": 1.604269095227252}], "error_log": []}
{"context": "In a game of Tic Tac Toe, a player (either human or computer) needs to make the best possible move based on the current state of the board. Given the current state of the board, the symbol ('X' or 'O') of the player, and whether the player is a computer, what is the best move the player should make?\n\nThe input and output requirements are as follows:\n\nInput:\n- `gameBoard` (list of str): A list representing the current state of the Tic Tac Toe board. Each element can be either 'X', 'O', or '_' (empty). The list has exactly 9 elements.\n- `playerSymbol` (str): A string representing the symbol ('X' or 'O') of the player whose move is being calculated.\n- `isComputer` (bool): A boolean indicating whether the player is a computer (True) or a human (False).\n\nOutput:\n- `return` (dict): A dictionary containing the following keys:\n  - `value` (int): The value of the best move calculated by the alpha-beta pruning algorithm.\n  - `place` (int): The index (0-8) of the best move on the game board.", "reference_code": "# import necessary packages\nfrom random import randrange\n\n# all class and function definitions in the code file, if any\nclass Player(object):\n    def __init__(self, symbol, isComputer):\n        self.symbol = symbol\n        self.isComputer = isComputer\n    \n    def play(self, gameBoard):\n        if self.isComputer:\n            depth, alpha, beta, isMax = 9 - gameBoard.count('_'), -10, 10, True\n            value, place = self.alphaBeta(gameBoard, depth, alpha, beta, isMax)\n        else:\n            place = int(input('Enter a number from 1 to 9: ')) - 1\n            while self.isInvalid(gameBoard, place):\n                place = int(input('Enter again: ')) - 1\n\n        gameBoard[place] = self.symbol\n\n    def alphaBeta(self, gameBoard, depth, alpha, beta, isMaxPlayer):\n        value = checkIfWon(gameBoard, self.symbol)\n        if value != 0:\n            return value, -1\n        if depth == 0:\n            return value, -1\n        if isMaxPlayer:\n            value = -10\n            listOfNumbers = list(range(9))\n            while listOfNumbers:\n                random = listOfNumbers.pop(randrange(len(listOfNumbers)))\n                if gameBoard[random] == '_':\n                    gameBoard[random] = self.symbol\n                    temp_value = self.alphaBeta(gameBoard, depth - 1, alpha, beta, False)[0]\n                    if temp_value > value:\n                        value = temp_value\n                        place = random\n                    alpha = max(alpha, value)\n                    gameBoard[random] = '_'\n                    if alpha >= beta:\n                        break\n        else:\n            value = 10\n            listOfNumbers = list(range(9))\n            while listOfNumbers:\n                random = listOfNumbers.pop(randrange(len(listOfNumbers)))\n                if gameBoard[random] == '_':\n                    gameBoard[random] = self.symbol\n                    temp_value = self.alphaBeta(gameBoard, depth - 1, alpha, beta, True)[0]\n                    if temp_value < value:\n                        value = temp_value\n                        place = random\n                    beta = min(beta, value)\n                    gameBoard[random] = '_'\n                    if beta <= alpha:\n                        break\n        return value, place\n\n    def isInvalid(self, gameBoard, place):\n        if place not in list(range(9)):\n            return True\n        if gameBoard[place] != '_':\n            return True\n        return False\n\n    def isSymbolX(self):\n        return self.symbol == 'X'\n\ndef checkIfWon(gameBoard, symbol):\n    symbolToNumber = {'X': 1, 'O': -1, '_': 0}\n    gameState = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    \n    for i in range(3):\n        for j in range(3):\n            gameState[i][j] = symbolToNumber[gameBoard[i * 3 + j]]\n    \n    for i in range(3):\n        rowcount, colcount = 0, 0\n        for j in range(3):\n            rowcount += gameState[i][j]\n            colcount += gameState[j][i]\n        if rowcount == -3 or colcount == -3:\n            return -1\n        if rowcount == 3 or colcount == 3:\n            return 1\n    if gameState[1][1] == -1:\n        if (gameState[0][0] == -1 and gameState[2][2] == -1) or (gameState[0][2] == -1 and gameState[2][0] == -1):\n            return -1\n    if gameState[1][1] == 1:\n        if (gameState[0][0] == 1 and gameState[2][2] == 1) or (gameState[0][2] == 1 and gameState[2][0] == 1):\n            return 1\n\n    return 0\n\n# main function\ndef main_solution(gameBoard, playerSymbol, isComputer):\n    # Convert JSON serializable inputs to original input variables\n    player = Player(playerSymbol, isComputer)\n    \n    # Core solution code\n    depth, alpha, beta, isMax = 9 - gameBoard.count('_'), -10, 10, True\n    value, place = player.alphaBeta(gameBoard, depth, alpha, beta, isMax)\n    \n    # Convert output to JSON serializable\n    return {\"value\": value, \"place\": place}", "input_generator": "import random\nfrom random import choice, randint\n\ndef input_generator():\n    symbols = ['X', 'O']\n    playerSymbol = choice(symbols)\n    isComputer = choice([True, False])\n    \n    # Generate a random game board with some moves already made\n    gameBoard = ['_'] * 9\n    num_moves = randint(0, 4)  # Up to 4 moves already made\n    for _ in range(num_moves):\n        empty_positions = [i for i, x in enumerate(gameBoard) if x == '_']\n        if empty_positions:\n            pos = choice(empty_positions)\n            gameBoard[pos] = choice(symbols)\n    \n    return {\n        \"gameBoard\": gameBoard,\n        \"playerSymbol\": playerSymbol,\n        \"isComputer\": isComputer\n    }", "io_pairs": [{"input": {"gameBoard": ["_", "_", "_", "_", "_", "_", "O", "O", "X"], "playerSymbol": "O", "isComputer": true}, "output": {"value": 0, "place": 5}}, {"input": {"gameBoard": ["_", "_", "_", "_", "_", "O", "_", "_", "_"], "playerSymbol": "X", "isComputer": false}, "output": {"value": 0, "place": 4}}, {"input": {"gameBoard": ["X", "O", "_", "_", "_", "_", "_", "_", "_"], "playerSymbol": "X", "isComputer": true}, "output": {"value": 0, "place": 6}}, {"input": {"gameBoard": ["_", "_", "_", "X", "_", "_", "_", "_", "O"], "playerSymbol": "O", "isComputer": true}, "output": {"value": 0, "place": 1}}, {"input": {"gameBoard": ["_", "_", "_", "_", "_", "_", "_", "_", "_"], "playerSymbol": "O", "isComputer": true}, "output": {"value": 0, "place": -1}}, {"input": {"gameBoard": ["_", "_", "_", "_", "_", "_", "_", "_", "_"], "playerSymbol": "X", "isComputer": true}, "output": {"value": 0, "place": -1}}, {"input": {"gameBoard": ["_", "_", "_", "_", "X", "_", "_", "_", "_"], "playerSymbol": "O", "isComputer": true}, "output": {"value": 0, "place": 0}}, {"input": {"gameBoard": ["_", "_", "_", "_", "X", "_", "_", "_", "_"], "playerSymbol": "X", "isComputer": false}, "output": {"value": 0, "place": 8}}, {"input": {"gameBoard": ["_", "X", "_", "_", "O", "_", "_", "_", "_"], "playerSymbol": "O", "isComputer": false}, "output": {"value": 0, "place": 7}}, {"input": {"gameBoard": ["O", "_", "_", "_", "_", "X", "_", "_", "_"], "playerSymbol": "X", "isComputer": true}, "output": {"value": 0, "place": 4}}], "error_log": []}
{"context": "Given a square matrix, what is the maximum modulo eigenvalue and the corresponding eigenvector when calculated with a specified accuracy?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_str` (str): A string representation of a square matrix, where elements are separated by commas and rows by semicolons.\n  `eps` (float): The desired accuracy for the eigenvalue calculation.\n\nOutput:\n  `return` (dict): A dictionary containing the maximum modulo eigenvalue and the corresponding eigenvector. The dictionary has the following keys:\n    - `eigenvalue` (float): The maximum modulo eigenvalue of the matrix.\n    - `eigenvector` (list of floats): The corresponding eigenvector as a list of floats.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef power_iteration_m(A, eps):\n    \"\"\"Find the maximum modulo eigenvalue with a given accuracy.\n\n    This function applies a scalar product to accelerate convergence.\n\n    Arguments:\n    A -- square matrix\n    eps -- accuracy\n    \"\"\"\n\n    vector = np.random.rand(A.shape[0])\n    value = np.random.rand()\n    diff = 2 * eps\n    while eps < diff:\n        next_vector1 = np.dot(A, vector)\n        next_vector2 = np.dot(A.T, vector)\n        next_value = np.dot(next_vector1, next_vector2) / np.dot(vector, next_vector2)\n        diff = abs(next_value - value)\n        \n        value = next_value\n        vector = next_vector1\n\n    return value, vector / np.linalg.norm(vector, ord=2)\n\ndef power_iteration(A, eps):\n    \"\"\"Find the maximum modulo eigenvalue with a given accuracy.\n    \n    Arguments:\n    A -- square matrix\n    eps -- accuracy\n    \"\"\"\n    vector = np.random.rand(A.shape[0])\n    value = np.random.rand()\n    diff = 2 * eps\n    while eps < diff:\n        next_vector = np.dot(A, vector)\n        next_value = next_vector[0] / vector[0]\n        diff = abs(next_value - value)\n\n        value = next_value\n        vector = next_vector\n\n    return value, vector / np.linalg.norm(vector, ord=2)\n\n# main function\ndef main_solution(matrix_str, eps):\n    \"\"\"\n    Find the maximum modulo eigenvalue of a given square matrix using the power iteration method.\n\n    Arguments:\n    matrix_str (str): A string representation of a square matrix, where elements are separated by commas and rows by semicolons.\n    eps (float): The desired accuracy for the eigenvalue calculation.\n\n    Returns:\n    dict: A dictionary containing the maximum modulo eigenvalue and the corresponding eigenvector.\n    \"\"\"\n    # Convert the matrix string to a numpy array\n    A = np.array([list(map(float, row.split(','))) for row in matrix_str.split(';')])\n    \n    # Use the power_iteration_m function to find the eigenvalue and eigenvector\n    eigenvalue, eigenvector = power_iteration_m(A, eps)\n    \n    # Convert the eigenvector to a list for JSON serialization\n    eigenvector = eigenvector.tolist()\n    \n    return {\"eigenvalue\": eigenvalue, \"eigenvector\": eigenvector}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose matrix size between 2x2 and 5x5\n    n = random.randint(2, 5)\n    \n    # Generate a random square matrix with elements between -10 and 10\n    A = np.random.uniform(-10, 10, (n, n))\n    \n    # Convert matrix to string representation\n    matrix_str = ';'.join([','.join([f\"{x:.4f}\" for x in row]) for row in A])\n    \n    # Generate a random epsilon between 1e-6 and 1e-3\n    eps = 10 ** random.uniform(-6, -3)\n    \n    return {\"matrix_str\": matrix_str, \"eps\": eps}", "io_pairs": [{"input": {"matrix_str": "-2.0695,-5.2490,-0.5173;7.0771,-8.5740,-5.2887;8.6434,-1.5038,-8.8979", "eps": 1.1849242425895016e-06}, "output": {"eigenvalue": NaN, "eigenvector": [0.0, 0.0, 0.0]}}, {"input": {"matrix_str": "-9.0481,-5.5390,-6.1756;-2.1388,-7.7604,-0.1434;1.3283,-0.1569,8.3939", "eps": 0.00015767258085304424}, "output": {"eigenvalue": -11.677536944477682, "eigenvector": [0.8772264635513359, 0.4769939350554068, -0.05431866682435228]}}, {"input": {"matrix_str": "8.1915,0.1262;0.2569,-8.8524", "eps": 5.301486516898988e-05}, "output": {"eigenvalue": -8.854327720231927, "eigenvector": [0.007595130023019144, -0.9999711565839955]}}, {"input": {"matrix_str": "4.3390,2.3341;-9.9665,-9.4609", "eps": 0.00023532848310494017}, "output": {"eigenvalue": -7.495215272639111, "eigenvector": [-0.1935022689949453, 0.9810998276902344]}}, {"input": {"matrix_str": "0.1526,-1.2734;7.9539,-1.9809", "eps": 4.204909610496213e-06}, "output": {"eigenvalue": NaN, "eigenvector": [-0.0, 0.0]}}, {"input": {"matrix_str": "-0.4450,-2.8087,-4.0496;-9.6551,-1.8862,-8.2823;7.4981,-9.0556,3.9662", "eps": 1.056053194601732e-05}, "output": {"eigenvalue": -9.779686663017998, "eigenvector": [0.40311111658369314, 0.8496957889382134, 0.3398801170226282]}}, {"input": {"matrix_str": "-1.7329,3.8025;-0.2337,4.2567", "eps": 1.7820795427000185e-06}, "output": {"eigenvalue": 4.104466573753975, "eigenvector": [0.5458166645442405, 0.8379046298391006]}}, {"input": {"matrix_str": "7.0477,9.3509;9.6103,-9.1136", "eps": 1.0171104609668443e-05}, "output": {"eigenvalue": -13.48934385849959, "eigenvector": [-0.4143703853291108, 0.9101083362777225]}}, {"input": {"matrix_str": "-2.4252,5.9347;-1.9999,7.0710", "eps": 1.1720395877703074e-05}, "output": {"eigenvalue": 5.590261406022798, "eigenvector": [0.5950540741996776, 0.8036856654055516]}}, {"input": {"matrix_str": "-4.8025,-8.9335;-9.3594,4.1339", "eps": 6.415435219752774e-06}, "output": {"eigenvalue": NaN, "eigenvector": [0.0, 0.0]}}], "error_log": []}
{"context": "Given a polynomial function and an interval, what is the arc length of the function over that interval?\n\nThe input and output requirements are as follows:\n\nInput:\n  `function_str` (str): A string representing a one-variable function in SymPy syntax.\n  `variable_str` (str): A string representing the variable used in the function.\n  `lower_limit` (float): The lower limit of the interval over which to calculate the arc length.\n  `upper_limit` (float): The upper limit of the interval over which to calculate the arc length.\n\nOutput:\n  `return` (float): The arc length of the function over the specified interval, returned as a float. If the input function is invalid, returns the string \"Invalid input function\".", "reference_code": "# import necessary packages\nimport sympy\n\n# main function\ndef main_solution(function_str, variable_str, lower_limit, upper_limit):\n    # Convert the input strings to sympy expressions and symbols\n    try:\n        function_expr = sympy.sympify(function_str)\n    except sympy.SympifyError:\n        return \"Invalid input function\"\n    \n    variable_sym = sympy.Symbol(variable_str)\n    \n    # Calculate the derivative of the function\n    derivative = sympy.Derivative(function_expr, variable_sym).doit()\n    \n    # Calculate the arc length of the function between the given limits\n    length = sympy.Integral(sympy.sqrt(1 + derivative ** 2), (variable_sym, lower_limit, upper_limit)).doit().evalf()\n    \n    # Return the length as a float\n    return float(length)", "input_generator": "import random\nimport sympy\nfrom sympy.abc import x, y, z\n\ndef input_generator():\n    # Randomly choose a variable from x, y, z\n    variables = ['x', 'y', 'z']\n    variable_str = random.choice(variables)\n    \n    # Generate a random polynomial or trigonometric function\n    function_types = ['polynomial', 'trigonometric']\n    function_type = random.choice(function_types)\n    \n    if function_type == 'polynomial':\n        # Generate a polynomial of degree 1 to 3\n        degree = random.randint(1, 3)\n        coeffs = [random.randint(-5, 5) for _ in range(degree + 1)]\n        terms = []\n        for i, coeff in enumerate(coeffs):\n            if i == 0:\n                terms.append(f\"{coeff}\")\n            else:\n                if coeff == 1:\n                    terms.append(f\"{variable_str}^{i}\")\n                elif coeff == -1:\n                    terms.append(f\"-{variable_str}^{i}\")\n                else:\n                    terms.append(f\"{coeff}*{variable_str}^{i}\")\n        function_str = \" + \".join(terms).replace(\"+ -\", \"- \")\n    else:\n        # Generate a trigonometric function (sin or cos)\n        trig_func = random.choice(['sin', 'cos'])\n        coeff = random.randint(1, 3)\n        function_str = f\"{trig_func}({coeff}*{variable_str})\"\n    \n    # Generate random limits ensuring lower < upper\n    lower_limit = random.uniform(-5, 5)\n    upper_limit = lower_limit + random.uniform(0.1, 5)\n    \n    return {\n        'function_str': function_str,\n        'variable_str': variable_str,\n        'lower_limit': lower_limit,\n        'upper_limit': upper_limit\n    }", "io_pairs": [{"input": {"function_str": "0 - 4*z^1 + 0*z^2", "variable_str": "z", "lower_limit": -2.4091838641940133, "upper_limit": 0.20261167701637595}, "output": 10.768708888927678}, {"input": {"function_str": "cos(3*y)", "variable_str": "y", "lower_limit": -1.4333087394988553, "upper_limit": 0.9191405105375856}, "output": 5.247037418149089}, {"input": {"function_str": "-3 + 2*y^1 - y^2", "variable_str": "y", "lower_limit": -3.2509944569361204, "upper_limit": 0.9343416449791819}, "output": 18.838899963605993}, {"input": {"function_str": "sin(3*z)", "variable_str": "z", "lower_limit": -4.705321268854885, "upper_limit": -0.6779179022341006}, "output": 9.115672601743794}, {"input": {"function_str": "sin(3*x)", "variable_str": "x", "lower_limit": -4.080582526514601, "upper_limit": -3.4680543957186827}, "output": 1.098776698087692}, {"input": {"function_str": "sin(3*y)", "variable_str": "y", "lower_limit": 4.057657131017743, "upper_limit": 7.470303572928662}, "output": 7.823267213703845}, {"input": {"function_str": "cos(1*y)", "variable_str": "y", "lower_limit": -1.0087416619484033, "upper_limit": 3.8387039955943614}, "output": 5.701000874903489}, {"input": {"function_str": "-5 + 3*z^1 + 3*z^2", "variable_str": "z", "lower_limit": -3.0883131654564675, "upper_limit": -2.8763462462215412}, "output": 3.1641428392506334}, {"input": {"function_str": "sin(1*x)", "variable_str": "x", "lower_limit": 3.9181563370119186, "upper_limit": 5.3715239782515365}, "output": 1.5634860390134568}, {"input": {"function_str": "sin(2*z)", "variable_str": "z", "lower_limit": -1.3764779491159884, "upper_limit": 1.7187613744277832}, "output": 5.17152564839898}], "error_log": []}
{"context": "Alice wants to send a secure message to Bob using the RSA encryption algorithm. She has chosen two prime numbers `p` and `q` and wants to encrypt a message `message` that is less than the product of `p` and `q`. What are the RSA parameters `n`, `fin`, `e`, `d`, and the encrypted and decrypted versions of the message?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p` (int): A prime number used in the RSA algorithm.\n  `q` (int): Another prime number used in the RSA algorithm.\n  `message` (int): The message to be encrypted, such that `message < n`.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `n` (int): The product of `p` and `q`.\n    - `fin` (int): The Euler's totient function value of `n`.\n    - `e` (int): The public exponent in the RSA algorithm.\n    - `d` (int): The private exponent in the RSA algorithm.\n    - `encrypted_message` (int): The encrypted message.\n    - `decrypted_message` (int): The decrypted message.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef gcd(m, n):\n    if m < n:\n        (m, n) = (n, m)\n    if (m % n) == 0:\n        return n\n    else:\n        return gcd(n, m % n)\n\ndef rsaAlgo(p, q):\n    n = p * q\n    fin = (p - 1) * (q - 1)\n    e = None\n    for i in range(1, fin):\n        if gcd(i, fin) == 1:\n            e = i\n            break\n    d = None\n    for i in range(n):\n        if ((i * e) % fin) == 1:\n            d = i\n            break\n    return n, fin, e, d\n\ndef primeNum(n):\n    if n > 1:\n        for i in range(2, n):\n            if n % i == 0:\n                return False\n        return True\n    return False\n\n# main function\ndef main_solution(p, q, message):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert inputs if necessary\n    p = int(p)\n    q = int(q)\n    message = int(message)\n    \n    # Check if p and q are prime numbers\n    if not primeNum(p) or not primeNum(q):\n        raise ValueError(\"Both p and q must be prime numbers.\")\n    \n    # Calculate RSA parameters\n    n, fin, e, d = rsaAlgo(p, q)\n    \n    # Encryption\n    enc = (message ** e) % n\n    \n    # Decryption\n    dec = (enc ** d) % n\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"n\": n, \"fin\": fin, \"e\": e, \"d\": d, \"encrypted_message\": enc, \"decrypted_message\": dec}", "input_generator": "import random\n\ndef input_generator():\n    # Generate two distinct small prime numbers\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    p, q = random.sample(primes, 2)\n    \n    # Generate a message (integer) smaller than n = p*q\n    n = p * q\n    message = random.randint(1, n - 1)\n    \n    return {\"p\": p, \"q\": q, \"message\": message}", "io_pairs": [{"input": {"p": 11, "q": 83, "message": 209}, "output": {"n": 913, "fin": 820, "e": 1, "d": 1, "encrypted_message": 209, "decrypted_message": 209}}, {"input": {"p": 59, "q": 47, "message": 1465}, "output": {"n": 2773, "fin": 2668, "e": 1, "d": 1, "encrypted_message": 1465, "decrypted_message": 1465}}, {"input": {"p": 17, "q": 83, "message": 979}, "output": {"n": 1411, "fin": 1312, "e": 1, "d": 1, "encrypted_message": 979, "decrypted_message": 979}}, {"input": {"p": 5, "q": 29, "message": 137}, "output": {"n": 145, "fin": 112, "e": 1, "d": 1, "encrypted_message": 137, "decrypted_message": 137}}, {"input": {"p": 2, "q": 61, "message": 32}, "output": {"n": 122, "fin": 60, "e": 1, "d": 1, "encrypted_message": 32, "decrypted_message": 32}}, {"input": {"p": 29, "q": 89, "message": 409}, "output": {"n": 2581, "fin": 2464, "e": 1, "d": 1, "encrypted_message": 409, "decrypted_message": 409}}, {"input": {"p": 43, "q": 17, "message": 142}, "output": {"n": 731, "fin": 672, "e": 1, "d": 1, "encrypted_message": 142, "decrypted_message": 142}}, {"input": {"p": 7, "q": 41, "message": 43}, "output": {"n": 287, "fin": 240, "e": 1, "d": 1, "encrypted_message": 43, "decrypted_message": 43}}, {"input": {"p": 83, "q": 59, "message": 490}, "output": {"n": 4897, "fin": 4756, "e": 1, "d": 1, "encrypted_message": 490, "decrypted_message": 490}}, {"input": {"p": 5, "q": 89, "message": 28}, "output": {"n": 445, "fin": 352, "e": 1, "d": 1, "encrypted_message": 28, "decrypted_message": 28}}], "error_log": []}
{"context": "Given a linear equation in the form \"y = kx + b\", a specific x-coordinate, a date in the format \"dd.mm.yyyy\", and a room number in a unique tower structure, determine the y-coordinate based on the equation, validate if the date is correct, and find the floor and position of the room in the tower. What are the calculated y-coordinate, the validity of the date, and the room's position in the tower?\n\nThe input and output requirements are as follows:\n\nInput:\n  `equation` (str): A string representing a linear equation in the form \"y = kx + b\".\n  `x` (float): The x-coordinate for which the y-coordinate needs to be calculated.\n  `date` (str): A string representing a date in the format \"dd.mm.yyyy\".\n  `room` (int): An integer representing the room number in the tower, where 1 \u2264 room \u2264 2,000,000,000.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `y` (float): The calculated y-coordinate based on the equation and x-coordinate.\n    - `is_date_valid` (bool): True if the date is valid, False otherwise.\n    - `room_position` (dict): A dictionary containing:\n      - `stage` (int): The floor number where the room is located.\n      - `position` (int): The position of the room on the floor, starting from the left.", "reference_code": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\ndef parse_equation(equation):\n    \"\"\"Parses the equation string to extract k and b.\"\"\"\n    pattern = r'y\\s*=\\s*([+-]?\\d+(\\.\\d+)?)\\s*x\\s*([+-])\\s*(\\d+(\\.\\d+)?)'\n    match = re.match(pattern, equation)\n    if not match:\n        raise ValueError(\"Invalid equation format\")\n    k = float(match.group(1))\n    b = float(match.group(4))\n    if match.group(3) == '-':\n        b = -b\n    return k, b\n\ndef validate_date(date):\n    \"\"\"Validates the date string.\"\"\"\n    if len(date) != 10:\n        return False\n    date_parts = date.split('.')\n    if len(date_parts) != 3:\n        return False\n    try:\n        day = int(date_parts[0])\n        month = int(date_parts[1])\n        year = int(date_parts[2])\n    except ValueError:\n        return False\n    if not (1 <= year <= 9999):\n        return False\n    if not (1 <= month <= 12):\n        return False\n    m_days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if not (1 <= day <= m_days[month]):\n        return False\n    return True\n\ndef find_room_position(room):\n    \"\"\"Finds the floor and position of the room in the tower.\"\"\"\n    current = 0\n    prev_rooms = 0\n    current_side = 0\n    prev_stages = 0\n\n    while current < room:\n        prev_rooms += current_side ** 2\n        prev_stages += current_side\n        current_side += 1\n        current += current_side ** 2\n\n    if room == 1:\n        current_side = 1\n\n    position = (room - prev_rooms) % current_side\n    if position == 0:\n        position = current_side\n        stage = (room - prev_rooms) // current_side + prev_stages\n    else:\n        stage = 1 + (room - prev_rooms) // current_side + prev_stages\n\n    return stage, position\n\n# main function\ndef main_solution(equation, x, date, room):\n    # Convert equation string to k and b\n    k, b = parse_equation(equation)\n    \n    # Calculate y\n    y = k * x + b\n    \n    # Validate date\n    is_date_valid = validate_date(date)\n    \n    # Find room position\n    stage, position = find_room_position(room)\n    \n    # Return the results\n    return {\n        \"y\": y,\n        \"is_date_valid\": is_date_valid,\n        \"room_position\": {\n            \"stage\": stage,\n            \"position\": position\n        }\n    }", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate random k and b for the equation\n    k = round(random.uniform(-100.0, 100.0), 2)\n    b = round(random.uniform(-100.0, 100.0), 2)\n    # Randomly choose the sign for b in the equation\n    sign = random.choice(['+', '-'])\n    equation = f\"y = {k}x {sign} {abs(b)}\"\n    \n    # Generate random x\n    x = round(random.uniform(-100.0, 100.0), 2)\n    \n    # Generate a random date, which may or may not be valid\n    day = random.randint(1, 31)\n    month = random.randint(1, 12)\n    year = random.randint(1, 9999)\n    # Randomly decide if the date should be valid\n    if random.choice([True, False]):\n        # Ensure valid date\n        if month == 2:\n            day = random.randint(1, 28)\n        elif month in [4, 6, 9, 11]:\n            day = random.randint(1, 30)\n        else:\n            day = random.randint(1, 31)\n    date = f\"{day:02d}.{month:02d}.{year:04d}\"\n    \n    # Generate random room number (1 to 10000)\n    room = random.randint(1, 10000)\n    \n    return {\n        \"equation\": equation,\n        \"x\": x,\n        \"date\": date,\n        \"room\": room\n    }", "io_pairs": [{"input": {"equation": "y = -98.72x + 30.06", "x": 32.14, "date": "30.08.4682", "room": 8265}, "output": {"y": -3142.8008, "is_date_valid": true, "room_position": {"stage": 425, "position": 29}}}, {"input": {"equation": "y = 68.03x - 18.16", "x": -46.92, "date": "17.10.9983", "room": 8452}, "output": {"y": -3210.1276, "is_date_valid": true, "room_position": {"stage": 432, "position": 13}}}, {"input": {"equation": "y = -89.44x - 26.28", "x": 6.74, "date": "22.02.9694", "room": 8389}, "output": {"y": -629.1056, "is_date_valid": true, "room_position": {"stage": 430, "position": 8}}}, {"input": {"equation": "y = -28.91x + 79.79", "x": 3.65, "date": "28.08.4998", "room": 6569}, "output": {"y": -25.731499999999997, "is_date_valid": true, "room_position": {"stage": 365, "position": 17}}}, {"input": {"equation": "y = 16.59x + 76.17", "x": 6.72, "date": "03.12.5281", "room": 4097}, "output": {"y": 187.6548, "is_date_valid": true, "room_position": {"stage": 267, "position": 3}}}, {"input": {"equation": "y = 43.61x - 56.04", "x": -10.51, "date": "20.04.0755", "room": 5037}, "output": {"y": -514.3811, "is_date_valid": true, "room_position": {"stage": 306, "position": 12}}}, {"input": {"equation": "y = 87.45x - 23.56", "x": -8.33, "date": "31.02.9253", "room": 6552}, "output": {"y": -752.0185, "is_date_valid": false, "room_position": {"stage": 364, "position": 27}}}, {"input": {"equation": "y = -19.37x - 6.09", "x": 49.9, "date": "30.10.7342", "room": 2269}, "output": {"y": -972.653, "is_date_valid": true, "room_position": {"stage": 180, "position": 8}}}, {"input": {"equation": "y = -55.65x - 68.13", "x": -87.81, "date": "15.09.4353", "room": 6118}, "output": {"y": 4818.4965, "is_date_valid": true, "room_position": {"stage": 348, "position": 21}}}, {"input": {"equation": "y = -12.24x + 56.41", "x": -93.12, "date": "01.03.7102", "room": 2947}, "output": {"y": 1196.1988000000001, "is_date_valid": true, "room_position": {"stage": 214, "position": 14}}}], "error_log": []}
{"context": "In a population genetics simulation, how many generations does it take for a specific allele to either fix or fail to fix in the population, given the population size, fitness values for different types of organisms, and the number of generations to run the simulation?\n\nThe input and output requirements are as follows:\n\nInput:\n  `pop` (int): The population size.\n  `wfit` (float): The fitness value for wildtype organisms.\n  `hfit` (float): The fitness value for heterozygous organisms.\n  `dfit` (float): The fitness value for dominant organisms.\n  `en` (int): The number of generations to run the simulation.\n  `ctr` (int): A control variable (0 or 1) to determine the initial population composition.\n\nOutput:\n  `return` (dict): A dictionary containing the number of generations (`generations`) and the fixation status (`fixation`). The `fixation` value is 1 if the allele is fixed, and 0 if it is not.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef divide(population, pop):\n    newPop = []\n    for ciliate in population:\n        if random.random() <= ciliate[2]:\n            newPop.append(ciliate)\n            newPop.append(ciliate)\n        else:\n            newPop.append(ciliate)\n    return random.sample(newPop, pop)\n\ndef check(population, pop):\n    tot = sum(cil[0] for cil in population)\n    return float(tot) / (2 * pop)\n\ndef mate(population, fit):\n    random.shuffle(population)\n    newPop = []\n    while len(population):\n        mom = population.pop()\n        dad = population.pop()\n        left, right = 0, 0\n        if mom[0] == 2:\n            left += 1\n            right += 1\n        elif mom[0] == 1:\n            if random.random() < 0.5:\n                left += 1\n            if random.random() < 0.5:\n                right += 1\n        if dad[0] == 2:\n            left += 1\n            right += 1\n        elif dad[0] == 1:\n            if random.random() < 0.5:\n                left += 1\n            if random.random() < 0.5:\n                right += 1\n        newPop.append([left, left, fit[left]])\n        newPop.append([right, right, fit[right]])\n    return newPop\n\n# main function\ndef main_solution(pop, wfit, hfit, dfit, en, ctr):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    initCil = [0, 0, wfit]\n    population = [initCil for _ in range(pop - 1)]\n    \n    if ctr:\n        population.append([1, 1, hfit])\n    else:\n        population.append([1, 0, wfit])\n\n    ns = random.randint(0, en)\n    q = 1 / (2 * pop)\n\n    cont = 1\n    gen = 0\n\n    while 1:\n        for _ in range(en - ns):\n            population = divide(population, pop)\n            gen += 1\n            q = check(population, pop)\n            if q == 1:\n                cont = 0\n                fix = 1\n                break\n            if q == 0:\n                cont = 0\n                fix = 0\n                break\n        ns = 0\n        if cont:\n            population = mate(population, [wfit, hfit, dfit])\n            population = divide(population, pop)\n            gen += 1\n            q = check(population, pop)\n        if q == 1:\n            fix = 1\n            break\n        if q == 0:\n            fix = 0\n            break\n        \n        if gen >= 5000:\n            fix = 0\n            break\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"generations\": gen, \"fixation\": fix}", "input_generator": "import random\n\ndef input_generator():\n    pop = random.randint(10, 100)\n    wfit = round(random.uniform(0.1, 0.9), 2)\n    hfit = round(random.uniform(0.1, 0.9), 2)\n    dfit = round(random.uniform(0.1, 0.9), 2)\n    en = random.randint(1, 10)\n    ctr = random.choice([True, False])\n    \n    return {\n        \"pop\": pop,\n        \"wfit\": wfit,\n        \"hfit\": hfit,\n        \"dfit\": dfit,\n        \"en\": en,\n        \"ctr\": ctr\n    }", "io_pairs": [{"input": {"pop": 61, "wfit": 0.61, "hfit": 0.58, "dfit": 0.73, "en": 2, "ctr": false}, "output": {"generations": 2, "fixation": 0}}, {"input": {"pop": 58, "wfit": 0.59, "hfit": 0.87, "dfit": 0.8, "en": 9, "ctr": true}, "output": {"generations": 8, "fixation": 0}}, {"input": {"pop": 54, "wfit": 0.83, "hfit": 0.69, "dfit": 0.31, "en": 6, "ctr": false}, "output": {"generations": 1, "fixation": 0}}, {"input": {"pop": 96, "wfit": 0.74, "hfit": 0.48, "dfit": 0.9, "en": 7, "ctr": true}, "output": {"generations": 1, "fixation": 0}}, {"input": {"pop": 56, "wfit": 0.3, "hfit": 0.2, "dfit": 0.23, "en": 6, "ctr": true}, "output": {"generations": 4, "fixation": 0}}, {"input": {"pop": 12, "wfit": 0.57, "hfit": 0.79, "dfit": 0.5, "en": 10, "ctr": false}, "output": {"generations": 5, "fixation": 0}}, {"input": {"pop": 12, "wfit": 0.13, "hfit": 0.81, "dfit": 0.2, "en": 4, "ctr": false}, "output": {"generations": 5000, "fixation": 0}}, {"input": {"pop": 72, "wfit": 0.45, "hfit": 0.64, "dfit": 0.83, "en": 10, "ctr": false}, "output": {"generations": 1, "fixation": 0}}, {"input": {"pop": 80, "wfit": 0.27, "hfit": 0.13, "dfit": 0.62, "en": 1, "ctr": false}, "output": {"generations": 14, "fixation": 0}}, {"input": {"pop": 62, "wfit": 0.58, "hfit": 0.75, "dfit": 0.49, "en": 2, "ctr": true}, "output": {"generations": 5001, "fixation": 0}}], "error_log": []}
{"context": "Given the need to approximate the value of Pi to a specified number of decimal places, how can we accurately compute Pi to `n` decimal places using an efficient algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of decimal places to which the value of Pi should be calculated. It should be a positive integer.\n\nOutput:\n  `return` (str): The value of Pi rounded to `n` decimal places as a string.", "reference_code": "# import necessary packages\nfrom decimal import getcontext, Decimal\n\n# Function to calculate factorial\ndef factorial(k):\n    if k == 0:\n        return 1\n    return k * factorial(k - 1)\n\n# Function to calculate Pi using the Chudnovsky algorithm\ndef getpi(n):\n    getcontext().prec = n + 2  # Set precision to handle n decimal places\n    inverse = 0\n    for i in range(n + 1):\n        num = (-1) ** i * factorial(6 * i) * (545140134 * i + 13591409)\n        den = factorial(3 * i) * factorial(i) ** 3 * (640320 ** 3) ** (i + 0.5)\n        inverse += 12 * num / den\n    pi = Decimal(1 / inverse)\n    return round(pi, n)\n\n# main function\ndef main_solution(n):\n    # Convert input to integer\n    n = int(n)\n    # Calculate Pi to n decimal places using the Chudnovsky algorithm\n    pi_value = getpi(n)\n    # Return the result as a string\n    return str(pi_value)", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Reasonable range for n to avoid excessive computation\n    return {'n': n}", "io_pairs": [{"input": {"n": 7}, "output": "3.1415927"}, {"input": {"n": 10}, "output": "3.1415926536"}, {"input": {"n": 5}, "output": "3.14159"}, {"input": {"n": 1}, "output": "3.1"}, {"input": {"n": 4}, "output": "3.1416"}, {"input": {"n": 2}, "output": "3.14"}, {"input": {"n": 8}, "output": "3.14159265"}, {"input": {"n": 9}, "output": "3.141592654"}, {"input": {"n": 6}, "output": "3.141593"}, {"input": {"n": 3}, "output": "3.142"}], "error_log": []}
{"context": "Given a polynomial represented by a list of coefficients, what is the value of the polynomial when evaluated at a specific integer value of 'x'?\n\nThe input and output requirements are as follows:\n\nInput:\n  `coefficients` (list of int): A list of integers representing the coefficients of the polynomial in descending order of their powers.\n  `x_value` (int): The value of 'x' at which the polynomial needs to be evaluated.\n\nOutput:\n  `return` (int): The value of the polynomial evaluated at the given `x_value`.", "reference_code": "# import necessary packages\nimport math\nimport copy\nfrom itertools import zip_longest\n\n# all class and function definitions in the code file, if any\nclass Polynomial:\n    # function to get max index\n    def getMaxIndex(self, kwargs):\n        maxValue = 0\n        for key, value in kwargs.items():\n            if (int(key[1:]) > maxValue):\n                maxValue = int(key[1:])\n        return maxValue\n\n    # constructor which handles all input arguments\n    def __init__(self, *args, **kwargs):\n        self.coeffs = []\n        \n        # parse input arguments\n        for arg in args:\n            if isinstance(arg, list):\n                self.coeffs.extend(arg)\n            elif isinstance(arg, int):\n                self.coeffs.append(arg)\n        if kwargs:\n            maxIndex = self.getMaxIndex(kwargs)\n            self.coeffs = [0] * (int(maxIndex) + 1)\n            for key, value in kwargs.items():       \n                self.coeffs[int(key[1:])] = value\n\n    def __repr__(self):\n        return \"Polynomial()\"\n\n    # override string \"operator\" which provides option to print object in specific format\n    def __str__(self):\n        result = \"\"\n\n        maxPower = len(self.coeffs) - 1\n\n        for power, item in reversed(list(enumerate(self.coeffs))):\n            if (item == 0):\n                continue\n            \n            if (power == maxPower):\n                coeff = \"\" if item > 0 else \"-\"\n            else:\n                coeff = \" + \" if item > 0 else \" - \"\n\n            coeff += \"\" if power != 0 and (item == 1 or item == -1) else str(abs(item))\n\n            if (power == 0):\n                suf = \"\"\n            elif (power == 1):\n                suf = \"x\"\n            else:\n                suf = \"x^\" + str(power)\n\n            result += coeff + str(suf)\n\n        return result\n\n    # override operator \"+\" to get sum of two polynoms represented by two objects\n    def __add__(self, other):\n        return Polynomial([a + b for a, b in zip_longest(self.coeffs, other.coeffs, fillvalue=0)])\n\n    # auxiliary method for multiplying polynoms\n    def multiply(self, s, v):\n        res = [0]*(len(s)+len(v)-1)\n        for selfpow,selfcoeff in enumerate(s):\n            for valpow,valcoeff in enumerate(v):\n                res[selfpow+valpow] += selfcoeff*valcoeff\n\n        return res\n\n    # override operator \"**\" to pow polynom of M members on N exponent\n    def __pow__(self, exp):\n        # make a copy of coefficients to be able to multiple together with base coefficients\n        self.result = copy.deepcopy(self.coeffs)\n        for i in range(1, exp):\n            self.result = self.multiply(self.coeffs, self.result)\n        \n        return Polynomial(self.result)\n\n    # derivate polynom\n    def derivative(self):\n        new_list = [self.coeffs[i] * i for i in range(1, len(self.coeffs))]\n        return Polynomial(new_list)\n\n    # use val in polynom instead of \"x\" to get exact result\n    def getListWithValue(self, val):\n        return [value*val**key for key, value in enumerate(self.coeffs)]\n\n    # get value according to given argument(s), returning exact result, using argument instead of variable\n    def at_value(self, *args):\n        if (len(args) == 1):\n            return sum(self.getListWithValue(int(args[0])))\n        elif (len(args) == 2):\n            return sum(self.getListWithValue(int(args[1]))) - sum(self.getListWithValue(int(args[0])))\n        else:\n            print(\"Invalid input arguments in method at_value()\")\n\n# main function\ndef main_solution(coefficients, x_value):\n    # Convert JSON serializable input to original input variables\n    poly = Polynomial(coefficients)\n    \n    # Calculate the value of the polynomial at the given x_value\n    result = poly.at_value(x_value)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random polynomial degree between 1 and 5\n    degree = random.randint(1, 5)\n    \n    # Generate random coefficients for the polynomial\n    coefficients = [random.randint(-10, 10) for _ in range(degree + 1)]\n    \n    # Generate a random x_value between -10 and 10\n    x_value = random.randint(-10, 10)\n    \n    return {\n        'coefficients': coefficients,\n        'x_value': x_value\n    }", "io_pairs": [{"input": {"coefficients": [10, 9, -6], "x_value": -7}, "output": -347}, {"input": {"coefficients": [3, -6, 1], "x_value": 10}, "output": 43}, {"input": {"coefficients": [-4, -10, -6], "x_value": 5}, "output": -204}, {"input": {"coefficients": [10, 6, 5, -9, 6], "x_value": 7}, "output": 11616}, {"input": {"coefficients": [7, -4], "x_value": -6}, "output": 31}, {"input": {"coefficients": [-8, 3, -6, 8, -6], "x_value": -6}, "output": -9746}, {"input": {"coefficients": [-4, -6, 8, -4, 4], "x_value": 4}, "output": 868}, {"input": {"coefficients": [6, -6, 0, 9, 2], "x_value": 4}, "output": 1070}, {"input": {"coefficients": [-9, -4, 0, -10, 2], "x_value": -6}, "output": 4767}, {"input": {"coefficients": [6, 2, -5], "x_value": -7}, "output": -253}], "error_log": []}
{"context": "You are tasked with navigating through a randomly generated maze. The maze is represented as a grid of cells, and you start at the top-left corner and need to reach the bottom-right corner. Given the dimensions of the maze, what is the shortest path from the start to the end? The path should be returned as a sequence of cell indices, starting from the top-left cell (index 0) to the bottom-right cell.\n\nThe input and output requirements are as follows:\n\nInput:\n  `maze_width` (int): The width of the maze.\n  `maze_height` (int): The height of the maze.\n\nOutput:\n  `return` (str): A string representing the solution path of the maze. Each cell in the path is separated by a comma.", "reference_code": "# import necessary packages\nfrom random import shuffle, randrange\nfrom math import floor, ceil\nfrom collections import defaultdict\nimport string\nimport random\n\n# all class and function definitions in the code file, if any\ndef make_maze(w, h):\n    # Makes a square grid:\n    vis = [[0] * w + [1] for _ in range(h)] + [[1] * (w + 1)]\n    con = [[0] * w*h for _ in range(w*h)]\n    ver = [[\"|  \"] * w + ['|'] for _ in range(h)] + [[]]\n    hor = [[\"+--\"] * w + ['+'] for _ in range(h + 1)]\n    # Carve Out Maze (break walls and build connections):\n    def walk(x, y):\n        vis[y][x] = 1\n        d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]\n        shuffle(d)\n        for (xx, yy) in d:\n            if vis[yy][xx]: continue\n            if xx == x:\n                hor[max(y, yy)][x] = \"+  \"\n                con[(max(y, yy)*w) + x][(max(y, yy)*w) + x - w] = 1\n                con[(max(y, yy)*w) + x - w][(max(y, yy)*w) + x] = 1\n            if yy == y:\n                ver[y][max(x, xx)] = \"   \"\n                con[(y*w) + max(x, xx)][(y*w) + max(x, xx) - 1] = 1\n                con[(y*w) + max(x, xx) - 1][(y*w) + max(x, xx)] = 1\n            walk(xx, yy)\n    walk(randrange(w), randrange(h))\n    # Turn Maze into string:\n    s = \"\"\n    for (a, b) in zip(hor, ver):\n        s += ''.join(a + ['\\n'] + b + ['\\n'])\n    return s, con\n\ndef Dijkstra(Graph, source):\n   # Graph[u][v] is the weight from u to v (however 0 means infinity)\n   infinity = float('infinity')\n   n = len(Graph)\n   dist = [infinity]*n   # Unknown distance function from source to v\n   previous = [infinity]*n # Previous node in optimal path from source\n   dist[source] = 0        # Distance from source to source\n   Q = list(range(n)) # All nodes in the graph are unoptimized - thus are in Q\n   while Q:           # The main loop\n       u = min(Q, key=lambda n:dist[n])                 # vertex in Q with smallest dist[]\n       Q.remove(u)\n       if dist[u] == infinity:\n           break # all remaining vertices are inaccessible from source\n       for v in range(n):               # each neighbor v of u\n           if Graph[u][v] and (v in Q): # where v has not yet been visited\n               alt = dist[u] + Graph[u][v]\n               if alt < dist[v]:       # Relax (u,v,a)\n                   dist[v] = alt\n                   previous[v] = u\n   return dist,previous\n\ndef getSolution(Graph):\n    predecessor = Dijkstra(Graph, 0)[1]\n    cell = len(predecessor)-1\n    solution = []\n    while cell:\n        solution = [cell] + solution\n        cell = predecessor[cell]\n    return [0] + solution\n\n# main function\ndef main_solution(maze_width, maze_height):\n    # Generate the maze and adjacency map\n    maze, adjMap = make_maze(maze_width, maze_height)\n    \n    # Solve the maze to get the solution path\n    solution = getSolution(adjMap)\n    \n    # Convert the solution path to a JSON serializable format\n    solution_serializable = ','.join(map(str, solution))\n    \n    return solution_serializable", "input_generator": "import random\n\ndef input_generator():\n    maze_width = random.randint(5, 15)\n    maze_height = random.randint(5, 15)\n    return {\n        'maze_width': maze_width,\n        'maze_height': maze_height\n    }", "io_pairs": [{"input": {"maze_width": 11, "maze_height": 9}, "output": "0,1,2,3,14,25,26,37,48,49,38,27,16,17,28,29,40,41,42,43,54,65,76,75,86,97,98"}, {"input": {"maze_width": 6, "maze_height": 5}, "output": "0,1,2,3,4,10,16,17,23,29"}, {"input": {"maze_width": 8, "maze_height": 7}, "output": "0,1,2,3,4,5,6,14,22,23,31,30,29,37,38,46,54,55"}, {"input": {"maze_width": 12, "maze_height": 5}, "output": "0,1,2,3,4,5,17,16,28,29,41,53,54,55,43,44,32,31,30,18,19,7,8,20,21,22,23,35,47,46,45,57,58,59"}, {"input": {"maze_width": 5, "maze_height": 10}, "output": "0,5,6,7,2,3,8,9,14,19,24,29,28,27,26,25,30,31,36,41,42,37,32,33,38,39,44,43,48,49"}, {"input": {"maze_width": 13, "maze_height": 6}, "output": "0,13,14,1,2,3,16,15,28,29,42,41,54,67,68,69,70,71,72,73,74,75,62,63,76,77"}, {"input": {"maze_width": 11, "maze_height": 8}, "output": "0,1,2,13,12,11,22,23,34,33,44,55,66,77,78,67,68,69,80,81,82,71,72,73,74,75,76,87"}, {"input": {"maze_width": 5, "maze_height": 7}, "output": "0,5,10,15,16,17,12,13,14,19,24,29,34"}, {"input": {"maze_width": 12, "maze_height": 13}, "output": "0,1,13,14,2,3,15,16,28,29,17,18,6,7,8,9,10,11,23,35,47,59,71,83,95,107,119,131,143,142,154,155"}, {"input": {"maze_width": 10, "maze_height": 11}, "output": "0,1,2,12,11,10,20,30,31,41,40,50,60,70,80,81,82,83,84,85,95,96,97,107,108,98,99,109"}], "error_log": []}
{"context": "Given a string of length 10 where each character represents the presence ('o'), absence ('x'), or indifference ('?') of digits from 0 to 9 in a 4-digit combination, how many valid 4-digit combinations can be formed that include all digits marked with 'o' and exclude all digits marked with 'x'?\n\nThe input and output requirements are as follows:\n\nInput:\n  `s` (str): A string of length 10, where each character can be either 'o', 'x', or '?'. The string represents the presence ('o'), absence ('x'), or indifference ('?') of digits from 0 to 9 in a 4-digit combination.\n\nOutput:\n  `return` (int): The number of valid 4-digit combinations that include all digits marked with 'o' and exclude all digits marked with 'x'.", "reference_code": "# import necessary packages\nfrom itertools import product\n\n# main function\ndef main_solution(s):\n    # Convert the input string to a list of characters\n    s = list(s)\n    \n    exist = []\n    not_exist = []\n    \n    # Populate the exist and not_exist lists based on the input string\n    for i in range(10):\n        if s[i] == \"o\":\n            exist.append(i)\n        if s[i] == \"x\":\n            not_exist.append(i)\n    \n    exist = set(exist)\n    not_exist = set(not_exist)\n    \n    cnt = 0\n    \n    # Generate all possible 4-digit combinations using product\n    for prod in product(range(10), repeat=4):\n        prod = set(prod)\n        # Check if the combination contains all 'o' digits and no 'x' digits\n        if (prod >= exist) and prod.isdisjoint(not_exist):\n            cnt += 1\n    \n    # Return the count of valid combinations\n    return cnt", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random 10-character string consisting of 'o', 'x', and '?'\n    s = []\n    for _ in range(10):\n        choice = random.choice(['o', 'x', '?'])\n        s.append(choice)\n    return {'s': ''.join(s)}", "io_pairs": [{"input": {"s": "?xxo??o?o?"}, "output": 156}, {"input": {"s": "ox?xx?o?x?"}, "output": 302}, {"input": {"s": "x?x??oxx??"}, "output": 671}, {"input": {"s": "o?oxo???xo"}, "output": 24}, {"input": {"s": "oxxoo??oox"}, "output": 0}, {"input": {"s": "xxo?oooxo?"}, "output": 0}, {"input": {"s": "o??o?ox???"}, "output": 180}, {"input": {"s": "ox??x?xxo?"}, "output": 302}, {"input": {"s": "oo?ox?ooox"}, "output": 0}, {"input": {"s": "oooo?o?ox?"}, "output": 0}], "error_log": []}
{"context": "Given a list of integers representing the preorder traversal of a binary search tree, what is the corresponding postorder traversal of the same tree?\n\nThe input and output requirements are as follows:\n\nInput:\n  `preorder` (list of integers): A list of integers representing the preorder traversal of a binary search tree.\n\nOutput:\n  `return` (list of integers): A list of integers representing the postorder traversal of the binary search tree constructed from the input `preorder` list.", "reference_code": "# import necessary packages\nimport sys\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, newNode):\n        if self.root is None:\n            self.root = newNode\n        else:\n            self.currNode = self.root\n            while True:\n                if newNode.data < self.currNode.data:\n                    if self.currNode.left is not None:\n                        self.currNode = self.currNode.left\n                    else:\n                        self.currNode.left = newNode\n                        break\n                else:\n                    if self.currNode.right is not None:\n                        self.currNode = self.currNode.right\n                    else:\n                        self.currNode.right = newNode\n                        break\n\n    def postOrder(self, root):\n        result, stack = [], []\n        stack.append(root)\n\n        while stack:\n            curr = stack.pop()\n            result.append(curr.data)\n\n            if curr.left:\n                stack.append(curr.left)\n            if curr.right:\n                stack.append(curr.right)\n\n        result.reverse()\n        return result\n\n# main function\ndef main_solution(preorder):\n    # Convert the input list to a binary tree\n    tree = BinaryTree()\n    for value in preorder:\n        node = Node(value)\n        tree.insert(node)\n\n    # Get the postorder traversal result\n    postorder_result = tree.postOrder(tree.root)\n\n    # Return the postorder traversal result as a list of integers\n    return postorder_result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random length for the preorder list between 5 and 20\n    length = random.randint(5, 20)\n    \n    # Generate a random preorder list with unique elements\n    preorder = random.sample(range(1, 100), length)\n    \n    return {'preorder': preorder}", "io_pairs": [{"input": {"preorder": [52, 17, 9, 31, 19, 93, 40, 45, 62, 56, 38]}, "output": [9, 19, 38, 45, 40, 31, 17, 56, 62, 93, 52]}, {"input": {"preorder": [7, 28, 17, 89, 4, 83, 61, 98, 12, 16, 45, 57, 55]}, "output": [4, 16, 12, 17, 55, 57, 45, 61, 83, 98, 89, 28, 7]}, {"input": {"preorder": [70, 31, 71, 52, 24, 73]}, "output": [24, 52, 31, 73, 71, 70]}, {"input": {"preorder": [94, 21, 93, 27, 97]}, "output": [27, 93, 21, 97, 94]}, {"input": {"preorder": [49, 24, 34, 42, 59, 87, 6, 99, 74, 32, 12, 55, 57, 75]}, "output": [12, 6, 32, 42, 34, 24, 57, 55, 75, 74, 99, 87, 59, 49]}, {"input": {"preorder": [3, 67, 21, 32, 71, 12, 82, 23, 46, 95, 22, 27, 96, 15, 26]}, "output": [15, 12, 22, 26, 27, 23, 46, 32, 21, 96, 95, 82, 71, 67, 3]}, {"input": {"preorder": [44, 65, 64, 50, 2, 86, 19, 62, 56, 99, 78, 95]}, "output": [19, 2, 56, 62, 50, 64, 78, 95, 99, 86, 65, 44]}, {"input": {"preorder": [24, 86, 39, 6, 40, 61, 82, 34, 22, 96, 13, 1, 99, 7, 55, 66]}, "output": [1, 7, 13, 22, 6, 34, 55, 66, 82, 61, 40, 39, 99, 96, 86, 24]}, {"input": {"preorder": [88, 21, 83, 92, 75, 77, 35, 25, 23, 72, 34]}, "output": [23, 34, 25, 72, 35, 77, 75, 83, 21, 92, 88]}, {"input": {"preorder": [49, 19, 27, 91, 46, 41, 87, 45, 55]}, "output": [45, 41, 46, 27, 19, 55, 87, 91, 49]}], "error_log": []}
{"context": "In a game of recursive combat, two players draw cards from their decks and compare them. The player with the higher card wins the round and takes both cards, placing them at the bottom of their deck in a specific order. The game continues until one player has all the cards. Given the initial decks of cards for both players, what is the final score of the winning player's deck?\n\nThe input and output requirements are as follows:\n\nInput:\n  `player1_deck` (list of integers): A list representing the deck of cards for Player 1. Each integer represents the value of a card.\n  `player2_deck` (list of integers): A list representing the deck of cards for Player 2. Each integer represents the value of a card.\n\nOutput:\n  `return` (integer): The final score of the winning player's deck. The score is calculated by summing the product of each card's value and its position (from the bottom of the deck).", "reference_code": "# import necessary packages\nimport re\nfrom copy import deepcopy\n\n# main function\ndef main_solution(player1_deck, player2_deck):\n    # Convert input lists to JSON serializable format\n    players = [player1_deck, player2_deck]\n    \n    # Call the recursive_combat function with verbose set to False\n    winner = recursive_combat(players, verbose=False)\n    \n    # Calculate the final score based on the winner's deck\n    res = 0\n    for p in players:\n        r = reversed(p)\n        for pos, value in enumerate(r):\n            res += (pos + 1) * value\n    \n    # Return the final score as the output\n    return res\n\n# Define the recursive_combat function without verbose prints\ndef recursive_combat(players, count=1, game=1, verbose=False):\n    MEMORY = set()\n    p1, p2 = players\n    new_game_count = 1\n    while p1 and p2:\n        if len(p1) > 1 and len(p2) > 1:\n            current_state = (tuple(p1), tuple(p2))\n            if current_state in MEMORY:\n                return 0\n            else:\n                MEMORY.add(current_state)\n        n1, n2 = p1.pop(0), p2.pop(0)\n        if len(p1) >= n1 and len(p2) >= n2:\n            new_p1 = deepcopy(p1[:n1])\n            new_p2 = deepcopy(p2[:n2])\n            new_game_count += 1\n            winner = recursive_combat([new_p1, new_p2], game=new_game_count, verbose=verbose)\n            update_winner(winner, players, n1, n2)\n        else:\n            if n1 > n2:\n                p1 += [n1, n2]\n            else:\n                p2 += [n2, n1]\n        count += 1\n        if not p1:\n            return 1\n        elif not p2:\n            return 0\n\ndef update_winner(ind, players, n1, n2):\n    if ind == 0:\n        players[0] += [n1, n2]\n    elif ind == 1:\n        players[1] += [n2, n1]\n    else:\n        raise ValueError", "input_generator": "import random\n\ndef input_generator():\n    # Generate random deck sizes between 5 and 10 for each player\n    deck_size1 = random.randint(5, 10)\n    deck_size2 = random.randint(5, 10)\n    \n    # Generate unique card values for each deck to avoid trivial cases\n    all_cards = list(range(1, 100))\n    random.shuffle(all_cards)\n    \n    player1_deck = all_cards[:deck_size1]\n    player2_deck = all_cards[deck_size1:deck_size1 + deck_size2]\n    \n    return {\n        'player1_deck': player1_deck,\n        'player2_deck': player2_deck\n    }", "io_pairs": [{"input": {"player1_deck": [], "player2_deck": [82, 29, 77, 8, 96, 81, 79, 16, 85, 47, 67, 28]}, "output": 4677}, {"input": {"player1_deck": [24, 86, 18, 95, 2, 54, 16], "player2_deck": [85, 34, 94, 21, 52, 27]}, "output": 2534}, {"input": {"player1_deck": [97, 35, 75, 4, 98, 93, 65, 9, 79, 76, 18, 1], "player2_deck": []}, "output": 4786}, {"input": {"player1_deck": [79, 39, 90, 21, 82, 11, 99, 44, 72, 67], "player2_deck": [19, 84, 59]}, "output": 3578}, {"input": {"player1_deck": [41, 37, 77, 70, 68, 63, 97, 53, 89, 28, 96, 49, 79, 8], "player2_deck": []}, "output": 6514}, {"input": {"player1_deck": [43, 82, 11], "player2_deck": [93, 29, 81, 61, 78, 19, 91, 13, 64, 46]}, "output": 3710}, {"input": {"player1_deck": [30, 14, 57, 42, 47, 25, 87, 82, 63, 48, 93, 32, 66, 17], "player2_deck": []}, "output": 4948}, {"input": {"player1_deck": [31, 24, 87, 51, 86, 38, 66, 60, 48, 3, 90, 71, 30, 1], "player2_deck": []}, "output": 5438}, {"input": {"player1_deck": [81, 61, 73, 60, 39, 20, 25, 14, 96, 50, 72, 42], "player2_deck": []}, "output": 4305}, {"input": {"player1_deck": [67, 31, 70, 20, 79, 13, 60, 59], "player2_deck": [50, 72, 49, 61, 9]}, "output": 2623}], "error_log": []}
{"context": "Given a mathematical function and an interval, determine the approximate root of the function within the specified interval using the bisection method. What is the approximate root of the function `f(x)` within the interval `[x0, x1]`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `f_str` (str): A string representation of the function `f(x)` for which the root is to be found. The function should be in a format that can be evaluated using `eval`.\n  `x0` (float): The lower bound of the interval in which the root is expected.\n  `x1` (float): The upper bound of the interval in which the root is expected.\n\nOutput:\n  `return` (float): The approximate root of the function `f(x)` within the interval `[x0, x1]`.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef bissection(f, x0, x1):\n    \"\"\" R\u00e9solution de l'\u00e9quation f(x)=0 par la m\u00e9thode de la bissection.\n    R\u00e9f : \"M\u00e9thodes de calcul num\u00e9rique\" - J.P. Nougier 3\u00e8me \u00e9dition\n    editions Masson page 137.\n    Il doit exister une solution unique dans l'interval l'interval [x0,x1] \"\"\"\n    epsilon = 0.000001\n    i = 0\n    while x1 - x0 >= 2 * epsilon:\n        x2 = 1 / 2. * (x0 + x1)\n        x = f(x2) * f(x1)\n        if x > 0:\n            x1 = x2\n        else:\n            x0 = x2\n        i = i + 1\n    return (x0 + x1) / 2.\n\n# main function\ndef main_solution(f_str, x0, x1):\n    # Convert the function string to a callable function\n    f = eval(\"lambda x: \" + f_str)\n    \n    # Call the bissection method\n    result = bissection(f, x0, x1)\n    \n    # Return the result as a float\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random function from a set of possible functions\n    functions = [\n        \"x**2 - 2\",  # root at sqrt(2)\n        \"math.sin(x)\",  # root at 0\n        \"math.cos(x) - x\",  # root around 0.739\n        \"math.exp(x) - 2\",  # root at ln(2)\n        \"x**3 - x - 2\"  # root around 1.521\n    ]\n    f_str = random.choice(functions)\n    \n    # Generate x0 and x1 such that f(x0) * f(x1) < 0\n    if f_str == \"x**2 - 2\":\n        x0 = random.uniform(1.0, 1.5)\n        x1 = random.uniform(1.5, 2.0)\n    elif f_str == \"math.sin(x)\":\n        x0 = random.uniform(-1.0, -0.5)\n        x1 = random.uniform(0.5, 1.0)\n    elif f_str == \"math.cos(x) - x\":\n        x0 = random.uniform(0.0, 0.5)\n        x1 = random.uniform(0.5, 1.0)\n    elif f_str == \"math.exp(x) - 2\":\n        x0 = random.uniform(0.0, 0.5)\n        x1 = random.uniform(0.5, 1.0)\n    elif f_str == \"x**3 - x - 2\":\n        x0 = random.uniform(1.0, 1.5)\n        x1 = random.uniform(1.5, 2.0)\n    \n    return {\"f_str\": f_str, \"x0\": x0, \"x1\": x1}", "io_pairs": [{"input": {"f_str": "x**3 - x - 2", "x0": 1.3558933440355043, "x1": 1.6569468846896216}, "output": 1.5213801132461187}, {"input": {"f_str": "math.cos(x) - x", "x0": 0.4652537793738685, "x1": 0.8175960415380431}, "output": 0.7390850232097013}, {"input": {"f_str": "math.cos(x) - x", "x0": 0.3616896040371643, "x1": 0.9016230263988028}, "output": 0.7390847227351602}, {"input": {"f_str": "x**2 - 2", "x0": 1.4648229507743378, "x1": 1.7593964387468062}, "output": 1.4648235126286773}, {"input": {"f_str": "x**3 - x - 2", "x0": 1.1910169675162816, "x1": 1.9427004766048988}, "output": 1.5213803270753044}, {"input": {"f_str": "math.cos(x) - x", "x0": 0.16275006835442757, "x1": 0.525866230468134}, "output": 0.16275076094354293}, {"input": {"f_str": "x**2 - 2", "x0": 1.292305295463546, "x1": 1.9804816104663392}, "output": 1.414212948020999}, {"input": {"f_str": "math.exp(x) - 2", "x0": 0.33421080711212664, "x1": 0.9308901755743}, "output": 0.6931467564381311}, {"input": {"f_str": "math.cos(x) - x", "x0": 0.34670778111385314, "x1": 0.6331378753078747}, "output": 0.3467083274359017}, {"input": {"f_str": "x**2 - 2", "x0": 1.4483558770039167, "x1": 1.525312020882803}, "output": 1.4483564641326998}], "error_log": []}
{"context": "In the Game of Life, a cellular automaton devised by the British mathematician John Conway, cells on a grid evolve over discrete time steps according to specific rules. Given an initial configuration of live and dead cells on a grid, what will be the state of the grid after one iteration of the Game of Life rules?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (List[List[int]]): A 2D list representing the initial state of the game board. Each element in the list is either 0 (dead cell) or 1 (live cell).\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the updated state of the game board after one iteration of the Game of Life rules. Each element in the list is either 0 (dead cell) or 1 (live cell).", "reference_code": "# import necessary packages\nimport numpy as np\nfrom copy import deepcopy\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\n        # count # of neighbours that are 0 or 1\n        # determine next state based on counts\n        # live is 1\n        def ck(x, y, n, m, b):\n            cnt = 0\n            rg = [-1, 0, 1]\n            for i, j in product(rg, rg):\n                if i == j == 0:\n                    continue\n                xx, yy = x + i, y + j\n                if 0 <= xx < n and 0 <= yy < m:\n                    cnt += b[xx][yy]\n            return cnt\n\n        n, m = len(board), len(board[0])\n        board2 = deepcopy(board)\n        for i in range(n):\n            for j in range(m):\n                cnt = ck(i, j, n, m, board2)\n                if board2[i][j]:\n                    if cnt in [2, 3]:\n                        board[i][j] = 1\n                    else:\n                        board[i][j] = 0\n                elif ck(i, j, n, m, board2) == 3:\n                    board[i][j] = 1\n\n# main function\ndef main_solution(board: List[List[int]]) -> List[List[int]]:\n    # Convert input to a numpy array for easier manipulation\n    board_np = np.array(board)\n    \n    # Create an instance of the Solution class\n    sol = Solution()\n    \n    # Call the gameOfLife method to update the board\n    sol.gameOfLife(board_np)\n    \n    # Convert the numpy array back to a list of lists\n    updated_board = board_np.tolist()\n    \n    # Return the updated board\n    return updated_board", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    rows = random.randint(3, 10)\n    cols = random.randint(3, 10)\n    board = [[random.randint(0, 1) for _ in range(cols)] for _ in range(rows)]\n    return {'board': board}", "io_pairs": [], "error_log": ["STDERR: Traceback (most recent call last):\n  File \"<string>\", line 57, in <module>\n  File \"<string>\", line 58, in Solution\nNameError: name 'List' is not defined. Did you mean: 'list'?\n"]}
{"context": "In a space mission simulation, two critical operations need to be performed concurrently: a countdown from a specified number and a countup to another specified number. The countdown operation will start from a given number and decrement until it reaches zero, at which point it will announce \"Blastoff!\". The countup operation will start from zero and increment until it reaches a given number, at which point it will announce \"Counting up complete!\". Given the numbers for the countdown and countup operations, what are the final messages from these two operations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `countdown_n` (int): The number from which the countdown will start.\n  `countup_n` (int): The number up to which the countup will proceed.\n\nOutput:\n  `return` (list of str): A list containing the final messages from the countdown and countup generators. The list will contain \"Blastoff!\" from the countdown generator and \"Counting up complete!\" from the countup generator.", "reference_code": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass TaskScheduler:\n    def __init__(self):\n        self._task_queue = deque()\n\n    def new_task(self, task):\n        self._task_queue.append(task)\n\n    def run(self):\n        while self._task_queue:\n            task = self._task_queue.popleft()\n            try:\n                next(task)\n                self._task_queue.append(task)\n            except StopIteration:\n                pass\n\n# main function\ndef main_solution(countdown_n, countup_n):\n    # Convert input variables to the required format\n    countdown_n = int(countdown_n)\n    countup_n = int(countup_n)\n\n    # Define the generator functions\n    def countdown(n):\n        while n > 0:\n            yield\n            n -= 1\n        yield 'Blastoff!'\n\n    def countup(n):\n        x = 0\n        while x < n:\n            yield\n            x += 1\n        yield 'Counting up complete!'\n\n    # Create a TaskScheduler instance\n    sched = TaskScheduler()\n\n    # Add tasks to the scheduler\n    sched.new_task(countdown(countdown_n))\n    sched.new_task(countup(countup_n))\n\n    # Run the scheduler and collect results\n    results = []\n    while sched._task_queue:\n        task = sched._task_queue.popleft()\n        try:\n            next(task)\n            sched._task_queue.append(task)\n        except StopIteration as e:\n            results.append(str(e))\n\n    # Return the results as a JSON serializable output\n    return results", "input_generator": "import random\n\ndef input_generator():\n    countdown_n = random.randint(1, 20)\n    countup_n = random.randint(1, 20)\n    return {'countdown_n': countdown_n, 'countup_n': countup_n}", "io_pairs": [{"input": {"countdown_n": 8, "countup_n": 15}, "output": ["", ""]}, {"input": {"countdown_n": 19, "countup_n": 2}, "output": ["", ""]}, {"input": {"countdown_n": 3, "countup_n": 16}, "output": ["", ""]}, {"input": {"countdown_n": 2, "countup_n": 2}, "output": ["", ""]}, {"input": {"countdown_n": 10, "countup_n": 12}, "output": ["", ""]}, {"input": {"countdown_n": 11, "countup_n": 8}, "output": ["", ""]}, {"input": {"countdown_n": 16, "countup_n": 11}, "output": ["", ""]}, {"input": {"countdown_n": 14, "countup_n": 16}, "output": ["", ""]}, {"input": {"countdown_n": 5, "countup_n": 6}, "output": ["", ""]}, {"input": {"countdown_n": 19, "countup_n": 1}, "output": ["", ""]}], "error_log": []}
{"context": "Given a mathematical function and a specific value, what is the derivative of the function evaluated at that value, expressed as a fraction?\n\nThe input and output requirements are as follows:\n\nInput:\n- `function` (str): A string representing the mathematical function in terms of `x`. For example, \"sin(x) + x^2\".\n- `value` (str): A string representing the value at which the derivative of the function should be evaluated. This can be a decimal number (e.g., \"3.14\") or a fraction (e.g., \"1/2\").\n\nOutput:\n- `return` (str): A string representing the evaluated derivative of the function at the given value, converted to a fraction. For example, \"1/2\".", "reference_code": "# import necessary packages\nfrom sympy import Symbol, diff, evalf\nfrom fractions import Fraction\n\n# main function\ndef main_solution(function, value):\n    # Convert the value to a float if it is a fraction\n    try:\n        value = float(value)\n    except ValueError:\n        number, denom = value.split(\"/\")\n        value = float(number) / float(denom)\n\n    # Define the symbol x\n    x = Symbol(\"x\")\n\n    # Calculate the derivative of the function\n    derivative = diff(function, x)\n\n    # Evaluate the derivative at the given value and round to 1 decimal place\n    evaluate = round(derivative.evalf(subs={x: value}), 1)\n\n    # Convert the evaluated result to a fraction\n    answer = str(Fraction(str(evaluate)))\n\n    # Return the final answer as a string\n    return answer", "input_generator": "import random\nfrom sympy import sympify\nfrom fractions import Fraction\n\ndef input_generator():\n    # Generate a random polynomial function of degree 1 to 3\n    degree = random.randint(1, 3)\n    coefficients = [random.randint(-10, 10) for _ in range(degree + 1)]\n    terms = []\n    for i, coeff in enumerate(coefficients):\n        if i == 0:\n            terms.append(f\"{coeff}\")\n        else:\n            if coeff == 1:\n                terms.append(f\"x**{i}\")\n            elif coeff == -1:\n                terms.append(f\"-x**{i}\")\n            else:\n                terms.append(f\"{coeff}*x**{i}\")\n    function_str = \" + \".join(terms).replace(\"+ -\", \"- \")\n    function = sympify(function_str)\n    \n    # Generate a random value, either integer, float, or fraction\n    value_type = random.choice([\"int\", \"float\", \"fraction\"])\n    if value_type == \"int\":\n        value = random.randint(-10, 10)\n    elif value_type == \"float\":\n        value = round(random.uniform(-10, 10), 1)\n    else:\n        numerator = random.randint(-20, 20)\n        denominator = random.randint(1, 20)\n        value = f\"{numerator}/{denominator}\"\n    \n    return {\"function\": function, \"value\": value}", "io_pairs": [], "error_log": []}
{"context": "Given a set of data points, what are the coefficients of the quadratic polynomial that best fits these points?\n\nThe input and output requirements are as follows:\n\nInput:\n  `xi` (list of floats): List of x-coordinates of the data points.\n  `yi` (list of floats): List of y-coordinates of the data points.\n\nOutput:\n  `return` (list of floats): List of polynomial coefficients [c0, c1, c2] that represent the polynomial \\( c0 + c1 \\cdot x + c2 \\cdot x^2 \\).", "reference_code": "# import necessary packages\nimport numpy as np\nfrom numpy.linalg import solve\n\n# main function\ndef main_solution(xi, yi):\n    # Convert input lists to numpy arrays\n    xi = np.array(xi)\n    yi = np.array(yi)\n    \n    # Define the linear system to be solved\n    A = np.array([np.ones(len(xi)), xi, xi ** 2])\n    A = A.T\n    b = yi\n    \n    # Solve the linear system\n    c = solve(A, b)\n    \n    # Return the polynomial coefficients as a list\n    return c.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random number of points between 3 and 10\n    n = random.randint(3, 10)\n    \n    # Generate random xi values sorted to avoid ill-conditioned matrices\n    xi = sorted(np.round(np.random.uniform(-10, 10, n), 2))\n    \n    # Generate random yi values\n    yi = np.round(np.random.uniform(-20, 20, n), 2)\n    \n    return {'xi': xi.tolist(), 'yi': yi.tolist()}", "io_pairs": [], "error_log": []}
{"context": "Given a cryptographic algorithm that generates a sequence of bits using the Blum-Blum-Shub (BBS) pseudorandom number generator, what are the proportions of '1's and '0's in the generated bit string when using specific prime numbers `p` and `q` that satisfy `p % 4 == 3` and `q % 4 == 3`, and generating a specified number of bits `nb`?\n\nThe input and output requirements are as follows:\n\nInput:\n- `nb` (int): The number of bits to generate.\n- `p` (int): A prime number that satisfies `p % 4 == 3`.\n- `q` (int): Another prime number that satisfies `q % 4 == 3`.\n\nOutput:\n- `return` (dict): A dictionary containing the proportions of '1's and '0's in the generated bit string.\n  - `\"proportion_1\"` (float): The proportion of '1's in the bit string.\n  - `\"proportion_0\"` (float): The proportion of '0's in the bit string.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef mod3plus4(a):\n    return a % 4 == 3\n\ndef pgcd(a, b):\n    while a % b != 0:\n        a, b = b, a % b\n    return b\n\ndef findX(n):\n    for i in range(round(n / 2), n):\n        if pgcd(i, n) == 1:\n            return i\n    return -1\n\ndef BBS(nb, p, q):\n    bits = \"\"\n    if mod3plus4(p) and mod3plus4(q):\n        n = p * q\n        x = findX(n)\n        x0 = xi = x**2 % n\n        for i in range(nb):\n            xiPlus1 = xi**2 % n\n            if xi % 2 == 0:\n                bits += \"0\"\n            else:\n                bits += \"1\"\n            xi = xiPlus1\n    return bits\n\n# main function\ndef main_solution(nb, p, q):\n    # Convert inputs to appropriate types if necessary\n    nb = int(nb)\n    p = int(p)\n    q = int(q)\n    \n    # Call the BBS function to generate the bit string\n    bit_string = BBS(nb, p, q)\n    \n    # Calculate the proportion of '1's and '0's in the bit string\n    nb1 = bit_string.count('1')\n    nb0 = bit_string.count('0')\n    proportion_1 = nb1 / len(bit_string)\n    proportion_0 = nb0 / len(bit_string)\n    \n    # Return the proportions as a dictionary\n    return {\n        \"proportion_1\": proportion_1,\n        \"proportion_0\": proportion_0\n    }", "input_generator": "import random\n\ndef input_generator():\n    # Generate p and q as primes congruent to 3 mod 4\n    primes = [x for x in range(100, 1000) if mod3plus4(x) and all(x % i != 0 for i in range(2, int(x**0.5) + 1))]\n    p = random.choice(primes)\n    q = random.choice([x for x in primes if x != p])\n    # Generate nb between 10 and 1000\n    nb = random.randint(10, 1000)\n    return {\"nb\": nb, \"p\": p, \"q\": q}", "io_pairs": [{"input": {"nb": 600, "p": 859, "q": 811}, "output": {"proportion_1": 0.5216666666666666, "proportion_0": 0.47833333333333333}}, {"input": {"nb": 965, "p": 307, "q": 283}, "output": {"proportion_1": 0.4538860103626943, "proportion_0": 0.5461139896373057}}, {"input": {"nb": 678, "p": 151, "q": 691}, "output": {"proportion_1": 0.5206489675516224, "proportion_0": 0.47935103244837757}}, {"input": {"nb": 632, "p": 367, "q": 151}, "output": {"proportion_1": 0.5316455696202531, "proportion_0": 0.46835443037974683}}, {"input": {"nb": 465, "p": 263, "q": 487}, "output": {"proportion_1": 0.5075268817204301, "proportion_0": 0.4924731182795699}}, {"input": {"nb": 786, "p": 607, "q": 631}, "output": {"proportion_1": 0.49363867684478374, "proportion_0": 0.5063613231552163}}, {"input": {"nb": 148, "p": 547, "q": 443}, "output": {"proportion_1": 0.38513513513513514, "proportion_0": 0.6148648648648649}}, {"input": {"nb": 264, "p": 359, "q": 383}, "output": {"proportion_1": 0.5340909090909091, "proportion_0": 0.4659090909090909}}, {"input": {"nb": 222, "p": 643, "q": 599}, "output": {"proportion_1": 0.5045045045045045, "proportion_0": 0.4954954954954955}}, {"input": {"nb": 343, "p": 947, "q": 659}, "output": {"proportion_1": 0.49854227405247814, "proportion_0": 0.5014577259475219}}], "error_log": []}
{"context": "Given a simple pendulum with a known length and initial conditions, how can we determine the period of oscillation by simulating its motion over a specified time interval?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_theta` (float): The initial angle of the pendulum in radians.\n  `initial_angVel` (float): The initial angular velocity of the pendulum in radians per second.\n  `initial_angAcc` (float): The initial angular acceleration of the pendulum in radians per second squared.\n  `time_start` (float): The start time of the simulation in seconds.\n  `time_end` (float): The end time of the simulation in seconds.\n  `num_steps` (int): The number of time steps to simulate.\n\nOutput:\n  `return` (dict): A dictionary containing the key `period` with the value being the calculated period of the pendulum in seconds.", "reference_code": "# import necessary packages\nimport math\nimport numpy as np\nimport scipy.signal as sig\n\n# Constants\ng = -9.81\nl = 0.38\n\n# Function to update the system\ndef update_system(angAcc, theta, angVel, time1, time2):\n    dt = time2 - time1\n    newTheta = theta + angVel * dt\n    newAngVel = angVel + angAcc * dt\n    newAngAcc = (g / l) * math.cos((math.pi / 2) - newTheta)\n    return newTheta, newAngVel, newAngAcc\n\n# Main function\ndef main_solution(initial_theta, initial_angVel, initial_angAcc, time_start, time_end, num_steps):\n    # Convert inputs to appropriate types\n    initial_theta = float(initial_theta)\n    initial_angVel = float(initial_angVel)\n    initial_angAcc = float(initial_angAcc)\n    time_start = float(time_start)\n    time_end = float(time_end)\n    num_steps = int(num_steps)\n\n    # Setting the initial conditions\n    theta = [initial_theta]\n    angVel = [initial_angVel]\n    angAcc = [initial_angAcc]\n    time = np.linspace(time_start, time_end, num_steps)\n\n    # Updating the position and velocity using previous values and time step\n    for i in range(1, len(time)):\n        newTheta, newAngVel, newAngAcc = update_system(angAcc[i-1], theta[i-1], angVel[i-1], time[i-1], time[i])\n        theta.append(newTheta)\n        angVel.append(newAngVel)\n        angAcc.append(newAngAcc)\n\n    # Determining period by averaging time differences\n    theta_pks, _ = sig.find_peaks(theta)\n    peaks = time[theta_pks[1:]]\n    time_difference = np.diff(peaks)\n    period = np.sum(time_difference) / len(time_difference)\n\n    # Return the period as a JSON serializable output\n    return {\"period\": period}", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    initial_theta = random.uniform(-np.pi/4, np.pi/4)  # Reasonable initial angle (-45 to 45 degrees)\n    initial_angVel = random.uniform(-1.0, 1.0)         # Reasonable initial angular velocity\n    initial_angAcc = random.uniform(-2.0, 2.0)         # Reasonable initial angular acceleration\n    time_start = 0.0\n    time_end = random.uniform(5.0, 20.0)               # Simulation duration between 5 and 20 seconds\n    num_steps = random.randint(100, 1000)              # Number of steps between 100 and 1000\n    \n    return {\n        \"initial_theta\": initial_theta,\n        \"initial_angVel\": initial_angVel,\n        \"initial_angAcc\": initial_angAcc,\n        \"time_start\": time_start,\n        \"time_end\": time_end,\n        \"num_steps\": num_steps\n    }", "io_pairs": [{"input": {"initial_theta": 0.12318457164946583, "initial_angVel": 0.38428322670299275, "initial_angAcc": -1.4077881485101154, "time_start": 0.0, "time_end": 19.810800422168715, "num_steps": 924}, "output": {"period": 1.3491335994047726}}, {"input": {"initial_theta": -0.3417556831216248, "initial_angVel": 0.3362353411346306, "initial_angAcc": 1.9755844574069097, "time_start": 0.0, "time_end": 6.947342669114363, "num_steps": 623}, "output": {"period": 1.2658609364945785}}, {"input": {"initial_theta": -0.5030822463390808, "initial_angVel": 0.19460636262483044, "initial_angAcc": 1.5579639470416193, "time_start": 0.0, "time_end": 17.36001896994004, "num_steps": 769}, "output": {"period": 1.5144808215963312}}, {"input": {"initial_theta": -0.601979466389442, "initial_angVel": -0.4223064584235745, "initial_angAcc": 1.5592103071793466, "time_start": 0.0, "time_end": 17.146689340551397, "num_steps": 198}, "output": {"period": NaN}}, {"input": {"initial_theta": 0.3366925443452229, "initial_angVel": -0.061220688358742725, "initial_angAcc": 0.11188452428990248, "time_start": 0.0, "time_end": 15.445360620661274, "num_steps": 561}, "output": {"period": 1.406631056524509}}, {"input": {"initial_theta": -0.5854911046024065, "initial_angVel": -0.4191444780880631, "initial_angAcc": -1.8802016691506482, "time_start": 0.0, "time_end": 19.089889898754933, "num_steps": 929}, "output": {"period": 1.5976811589116018}}, {"input": {"initial_theta": 0.015396843584342568, "initial_angVel": 0.025625788397950044, "initial_angAcc": -0.4494611716203707, "time_start": 0.0, "time_end": 5.685504778180389, "num_steps": 942}, "output": {"period": 1.238606248168948}}, {"input": {"initial_theta": -0.0977758413272366, "initial_angVel": -0.6954045210523314, "initial_angAcc": 0.453004110752381, "time_start": 0.0, "time_end": 5.483540487010617, "num_steps": 891}, "output": {"period": 1.241498211384988}}, {"input": {"initial_theta": 0.0076222264323330124, "initial_angVel": -0.020764010579031433, "initial_angAcc": 1.8769613860300356, "time_start": 0.0, "time_end": 11.02595881444752, "num_steps": 312}, "output": {"period": 1.261122528616184}}, {"input": {"initial_theta": -0.25204257640689043, "initial_angVel": -0.5020394587396801, "initial_angAcc": -0.8160299622209011, "time_start": 0.0, "time_end": 7.788487897059764, "num_steps": 165}, "output": {"period": 1.4247233958036154}}], "error_log": []}
{"context": "In a game of Tic Tac Toe, a player can place either an \"X\" or an \"O\" on a 3x3 grid. Given a specific state of the game board, determine the current status of the game. The possible outcomes are: one player has won, the game is a draw, the game is still ongoing, or the game state is impossible due to invalid moves. What is the current status of the game based on the provided board configuration?\n\nThe input and output requirements are as follows:\n\nInput:\n  `moves` (list of lists of strings): A 3x3 matrix representing the Tic Tac Toe board. Each element can be \"X\", \"O\", or \"_\" (empty).\n\nOutput:\n  `return` (string): The result of the Tic Tac Toe game. Possible values are:\n  - \"X wins\" if X has won the game.\n  - \"O wins\" if O has won the game.\n  - \"Draw\" if the game is a draw.\n  - \"Game not finished\" if the game is still ongoing.\n  - \"Impossible\" if the game state is invalid (e.g., more than one player has more than one extra move).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef check_diagonal(moves):\n    ''' checks if there is a winning game in the diagonals'''\n    dia = \"\"\n    dia_check = []\n    exes = [\"X\", \"X\", \"X\"]\n    oohs = [\"O\", \"O\", \"O\"]\n    for i in range(3):\n        if moves[i][i] == \"X\" or moves[i][i] == \"O\":\n            dia_check.append(moves[i][i])\n        else:\n            dia_check.append(\" \")\n    if dia_check == exes or dia_check == oohs:\n        dia = dia_check[0]\n        return dia\n    else:\n        for i in range(3):\n            j = 2\n            check_dia = []\n            for i in range(3):\n                check_dia.append(moves[i][j])\n                j -= 1\n            if check_dia == exes or check_dia == oohs:\n                dia = check_dia[0]\n        return dia\n\ndef check_columns(moves):\n    ''' checks if there is a winning game in the columns'''\n    col = \"\"\n    check = [[], [], []]\n    exes = [\"X\", \"X\", \"X\"]\n    oohs = [\"O\", \"O\", \"O\"]\n    for i in range(len(moves)):\n        for j in range(len(moves)):\n            if moves[j][i] == \"X\" or moves[j][i] == \"O\":\n                check[j].append(moves[j][i])\n            else:\n                check[j].append(\" \")\n    for i in range(len(check)):\n        if check[i] == exes or check[i] == oohs:\n            col = check[i][0]\n            return col\n    return col\n\ndef check_rows(moves):\n    ''' checks if there is a winning game in the rows '''\n    rows = \"\"\n    check = [[], [], []]\n    exes = [\"X\", \"X\", \"X\"]\n    oohs = [\"O\", \"O\", \"O\"]\n    for i in range(len(moves)):\n        for j in range(len(moves)):\n            if moves[i][j] == \"X\" or moves[i][j] == \"O\":\n                check[i].append(moves[i][j])\n            else:\n                check[i].append(\" \")\n    for i in range(len(check)):\n        if check[i] == exes or check[i] == oohs:\n            rows = check[i][0]\n            return rows\n    return rows\n\ndef check_x_o(moves):\n    ''' returns a true / false flag if there are more X's (O's) than O's (X's) '''\n    x_list = [char for group in moves for char in group if char == \"X\"]\n    o_list = [char for group in moves for char in group if char == \"O\"]\n    difference = abs(len(x_list) - len(o_list))\n    if difference >= 2:\n        return True\n    return False\n\ndef draw_case(diagonal, column, rows, moves):\n    ''' returns a true / false flag to see if the game is a draw'''\n    count = [char for words in moves for char in words if char == \"X\" or char == \"O\"]\n    if len(diagonal) == 0 and len(column) == 0 and len(rows) == 0 and len(count) == 9:\n        return True\n    return False\n\n# main function\ndef main_solution(moves):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    if check_x_o(moves):\n        return \"Impossible\"\n    \n    diag = check_diagonal(moves)\n    col = check_columns(moves)\n    row = check_rows(moves)\n    \n    if draw_case(diag, col, row, moves):\n        return \"Draw\"\n    elif len(diag) == 1:\n        return f\"{diag} wins\"\n    elif len(col) == 1:\n        return f\"{col} wins\"\n    elif len(row) == 1:\n        return f\"{row} wins\"\n    else:\n        return \"Game not finished\"\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    moves = [[' ' for _ in range(3)] for _ in range(3)]\n    players = ['X', 'O']\n    current_player = random.choice(players)\n    total_moves = random.randint(0, 9)\n    \n    for _ in range(total_moves):\n        while True:\n            i, j = random.randint(0, 2), random.randint(0, 2)\n            if moves[i][j] == ' ':\n                moves[i][j] = current_player\n                current_player = 'O' if current_player == 'X' else 'X'\n                break\n    \n    # Ensure some randomness in the outcome\n    if random.random() < 0.3:\n        # Force a win condition\n        winner = random.choice(['X', 'O'])\n        if random.choice([True, False]):\n            # Row win\n            row = random.randint(0, 2)\n            for j in range(3):\n                moves[row][j] = winner\n        else:\n            # Column win\n            col = random.randint(0, 2)\n            for i in range(3):\n                moves[i][col] = winner\n    elif random.random() < 0.2:\n        # Force a diagonal win\n        winner = random.choice(['X', 'O'])\n        if random.choice([True, False]):\n            for i in range(3):\n                moves[i][i] = winner\n        else:\n            for i in range(3):\n                moves[i][2 - i] = winner\n    elif random.random() < 0.1:\n        # Force a draw\n        for i in range(3):\n            for j in range(3):\n                if moves[i][j] == ' ':\n                    moves[i][j] = random.choice(['X', 'O'])\n    \n    return {'moves': moves}", "io_pairs": [{"input": {"moves": [["X", "O", "O"], ["X", "O", "X"], ["O", "X", "X"]]}, "output": "O wins"}, {"input": {"moves": [["X", "X", "X"], ["O", "X", "O"], ["O", "X", "O"]]}, "output": "X wins"}, {"input": {"moves": [["X", "O", "X"], ["X", "X", " "], ["X", "O", " "]]}, "output": "Impossible"}, {"input": {"moves": [["X", "X", "X"], ["O", "X", "O"], ["X", "X", "O"]]}, "output": "Impossible"}, {"input": {"moves": [["X", " ", "O"], [" ", " ", "O"], [" ", " ", "O"]]}, "output": "Impossible"}, {"input": {"moves": [["X", " ", "O"], ["X", " ", "O"], ["X", " ", "X"]]}, "output": "Impossible"}, {"input": {"moves": [["O", " ", " "], [" ", " ", " "], [" ", " ", " "]]}, "output": "Game not finished"}, {"input": {"moves": [["O", " ", " "], ["X", " ", " "], [" ", " ", " "]]}, "output": "Game not finished"}, {"input": {"moves": [["O", " ", "O"], ["X", "X", " "], ["O", "X", "O"]]}, "output": "Game not finished"}, {"input": {"moves": [["X", "X", "X"], ["X", "X", "O"], ["X", "O", "O"]]}, "output": "Impossible"}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, given an initial state of the board and the player who wishes to win, what is the optimal outcome for the player according to the minimax algorithm? The initial state is represented by a string of 9 characters separated by commas, where each character can be 'X', 'O', or ' ' (space). The player is either 'X' or 'O'.\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_state` (str): A string representing the initial state of the Tic-Tac-Toe board. The string should contain 9 characters separated by commas, where each character can be 'X', 'O', or ' ' (space). For example, \"X,O, , ,X, , , ,O\".\n  `player` (str): A string representing the player ('X' or 'O') who wishes to win.\n\nOutput:\n  `return` (dict): A dictionary containing the minimax value for the current state of the board. The key is \"minimax_value\" and the value is an integer (-1, 0, or 1) representing the outcome for the player: 1 for a win, 0 for a draw, and -1 for a loss.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef GameOver(state):\n    if state[0] == state[3] == state[6] == \"X\":\n        return True, \"Player X\"\n    elif state[0] == state[3] == state[6] == \"O\":\n        return True, \"Player O\"\n    elif state[1] == state[4] == state[7] == \"X\":\n        return True, \"Player X\"\n    elif state[1] == state[4] == state[7] == \"O\":\n        return True, \"Player O\"\n    elif state[2] == state[5] == state[8] == \"X\":\n        return True, \"Player X\"\n    elif state[2] == state[5] == state[8] == \"O\":\n        return True, \"Player O\"\n    elif state[0] == state[1] == state[2] == \"X\":\n        return True, \"Player X\"\n    elif state[0] == state[1] == state[2] == \"O\":\n        return True, \"Player O\"\n    elif state[3] == state[4] == state[5] == \"X\":\n        return True, \"Player X\"\n    elif state[3] == state[4] == state[5] == \"O\":\n        return True, \"Player O\"\n    elif state[6] == state[7] == state[8] == \"X\":\n        return True, \"Player X\"\n    elif state[6] == state[7] == state[8] == \"O\":\n        return True, \"Player O\"\n    elif state[0] == state[4] == state[8] == \"X\":\n        return True, \"Player X\"\n    elif state[0] == state[4] == state[8] == \"O\":\n        return True, \"Player O\"\n    elif state[2] == state[4] == state[6] == \"X\":\n        return True, \"Player X\"\n    elif state[2] == state[4] == state[6] == \"O\":\n        return True, \"Player O\"\n    for i in range(9):\n        if state[i] == \" \":\n            return False, \" \"\n    return True, \"No one\"\n\ndef legal_pos(state):\n    pos = []\n    for i in range(len(state)):\n        if state[i] == \" \":\n            pos.append(i)\n    return pos\n\ndef sts(state, turn):\n    sts = []\n    temp = list(state)\n    for pos in legal_pos(state):\n        temp[pos] = turn\n        sts.append(temp)\n        temp = list(state)\n    return sts\n\ndef switch(turn):\n    if turn == \"X\":\n        return \"O\"\n    else:\n        return \"X\"\n\ndef minimax(S, player, turn):\n    if GameOver(S)[0]:\n        player = \"Player \" + player\n        if GameOver(S)[1] == player:\n            return 1\n        elif GameOver(S)[1] == \"No one\":\n            return 0\n        else:\n            return -1\n\n    if player == turn:\n        values = []\n        for item in sts(S, turn):\n            values.append(minimax(item, player, switch(turn)))\n        return max(values)\n    else:\n        values = []\n        for item in sts(S, turn):\n            values.append(minimax(item, player, switch(turn)))\n        return min(values)\n\n# main function\ndef main_solution(initial_state, player):\n    # Convert the initial_state string to a list\n    state = initial_state.split(\",\")\n    \n    # Determine the next turn based on the number of moves already made\n    turn = \"X\" if state.count(\"X\") == state.count(\"O\") else \"O\"\n    \n    # Get the minimax value for the current state\n    value = minimax(state, player, turn)\n    \n    # Return the value as a dictionary\n    return {\"minimax_value\": value}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random initial state for the Tic-Tac-Toe board\n    symbols = ['X', 'O', ' ']\n    state = [random.choice(symbols) for _ in range(9)]\n    \n    # Ensure the state is not already a terminal state\n    while GameOver(state)[0]:\n        state = [random.choice(symbols) for _ in range(9)]\n    \n    # Randomly choose a player\n    player = random.choice(['X', 'O'])\n    \n    # Convert the state list to a comma-separated string\n    initial_state = \",\".join(state)\n    \n    return {\"initial_state\": initial_state, \"player\": player}", "io_pairs": [{"input": {"initial_state": " , ,X, ,X, ,O,O, ", "player": "O"}, "output": {"minimax_value": -1}}, {"input": {"initial_state": "O,X,O, ,X, ,X, ,X", "player": "X"}, "output": {"minimax_value": 0}}, {"input": {"initial_state": " ,O,O, ,X,O, , ,X", "player": "O"}, "output": {"minimax_value": 1}}, {"input": {"initial_state": "O,O, ,X,X,O, , , ", "player": "X"}, "output": {"minimax_value": -1}}, {"input": {"initial_state": " , , , , ,O,O, , ", "player": "O"}, "output": {"minimax_value": 1}}, {"input": {"initial_state": " ,O,O,O, ,X,X,X,O", "player": "X"}, "output": {"minimax_value": -1}}, {"input": {"initial_state": "X, ,X,X, ,O, ,X,O", "player": "O"}, "output": {"minimax_value": -1}}, {"input": {"initial_state": "X,O,O,X,O, , ,X,X", "player": "O"}, "output": {"minimax_value": 1}}, {"input": {"initial_state": "O,X,O,X,X, , , ,X", "player": "X"}, "output": {"minimax_value": 1}}, {"input": {"initial_state": "O, ,O,O,X, ,X, , ", "player": "X"}, "output": {"minimax_value": -1}}], "error_log": []}
{"context": "Given a function \\( f(x) = 2x_0^2 + 2x_0x_1 + x_1^2 \\), we want to find the minimum value of this function using the gradient descent method. What are the final values of \\( x \\) and \\( y \\) (denoted as `final_x`) and the corresponding minimum value of the function \\( f(x) \\) (denoted as `final_f_x`) when starting from a random initial point `initial_x` with a given learning rate `rho` and precision `precision`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_x` (list of float): A list containing the initial values for the variables x and y.\n  `rho` (float): The learning rate for the gradient descent algorithm.\n  `precision` (float): The precision threshold for stopping the gradient descent algorithm.\n\nOutput:\n  `return` (dict): A dictionary containing the final values of x and y (`final_x`) and the final value of the function f(x) (`final_f_x`).", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(initial_x, rho, precision):\n    # Convert JSON serializable inputs to numpy array\n    x = np.array(initial_x)\n    \n    def f(x):\n        return 2*x[0]**2 + 2*x[0]*x[1] + x[1]**2\n\n    def df(x):\n        dx = 4*x[0] + 2*x[1]\n        dy = 2*x[0] + 2*x[1]\n        return np.array([dx, dy])\n    \n    diff = 100\n    \n    while diff > precision:\n        dr = df(x)\n        prev_x = x\n        x = x - rho * dr\n        diff = np.dot(x - prev_x, x - prev_x)\n    \n    # Convert numpy array to list for JSON serialization\n    final_x = x.tolist()\n    final_f_x = f(x)\n    \n    return {\"final_x\": final_x, \"final_f_x\": final_f_x}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    initial_x = [random.uniform(-10.0, 10.0), random.uniform(-10.0, 10.0)]\n    rho = random.uniform(0.001, 0.1)\n    precision = random.uniform(1e-6, 1e-4)\n    return {\"initial_x\": initial_x, \"rho\": rho, \"precision\": precision}", "io_pairs": [{"input": {"initial_x": [6.422636815519322, -3.564504118032139], "rho": 0.07775256470245351, "precision": 7.058593704238809e-05}, "output": {"final_x": [0.0669148693868426, -0.10827053302065101], "final_f_x": 0.006187890659650908}}, {"input": {"initial_x": [-4.978354468452162, 6.545422658183863], "rho": 0.06481105851076051, "precision": 3.064024165221696e-05}, "output": {"final_x": [-0.054604782884767174, 0.08835239465586132], "final_f_x": 0.004120583614145053}}, {"input": {"initial_x": [-3.8188611945464546, 5.111818089633999], "rho": 0.08697302294626262, "precision": 3.3537371716442526e-05}, "output": {"final_x": [-0.04102146599657111, 0.06637412625080012], "final_f_x": 0.0023255180544742033}}, {"input": {"initial_x": [7.846068839387826, -4.333507454772905], "rho": 0.03651747641794855, "precision": 7.57840865489743e-05}, "output": {"final_x": [0.1586361159174063, -0.2566786271869956], "final_f_x": 0.034777751289408305}}, {"input": {"initial_x": [-9.265191337795148, 8.38657332880252], "rho": 0.06333704761781771, "precision": 4.1015388390460675e-05}, "output": {"final_x": [-0.06585015241229435, 0.1065477847674526], "final_f_x": 0.00599253985203802}}, {"input": {"initial_x": [9.230057050770387, -8.222637438699195], "rho": 0.020580783883902904, "precision": 8.502978705647528e-05}, "output": {"final_x": [0.30188753548657127, -0.48846429086038246], "final_f_x": 0.1259469697279748}}, {"input": {"initial_x": [-5.037628765200129, 0.984622420464671], "rho": 0.058594561950331296, "precision": 5.411454181686393e-05}, "output": {"final_x": [-0.08140894373712709, 0.13172243784688875], "final_f_x": 0.009158863809927746}}, {"input": {"initial_x": [4.182659972306709, -0.8463864474019083], "rho": 0.012524164372550124, "precision": 2.6323518272041513e-05}, "output": {"final_x": [0.2772248494717068, -0.44852541217769437], "final_f_x": 0.10619749994799846}}, {"input": {"initial_x": [1.8620891734091298, -4.9398225403556095], "rho": 0.049501743213630184, "precision": 3.189528802468897e-05}, "output": {"final_x": [0.07554168974390785, -0.12222902157471235], "final_f_x": 0.007886253842844483}}, {"input": {"initial_x": [-6.388079479528638, 0.9691413500046124], "rho": 0.024978378778835676, "precision": 3.878001867335238e-05}, "output": {"final_x": [-0.16635175487861886, 0.269162728256987], "final_f_x": 0.03824300259820362}}], "error_log": []}
{"context": "Given a binary tree represented by a list of integers and `None` values, where each integer represents a node's value and `None` represents a missing node, determine whether the binary tree is a Binary Search Tree (BST). A BST is defined as a binary tree where the value of every node in the left subtree is less than the node's value, and the value of every node in the right subtree is greater than the node's value. What is the result of checking if the given binary tree is a BST?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (list of integers or None): A list representing the binary tree structure. Each element in the list represents a node's value, with `None` indicating a missing node. The list is constructed in a level-order traversal manner.\n\nOutput:\n  `return` (boolean): `True` if the binary tree is a Binary Search Tree (BST), otherwise `False`.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef isBST(node, l=None, r=None):\n    if node is None:\n        return True\n\n    if l is not None and l.data > node.data:\n        return False\n\n    if r is not None and r.data < node.data:\n        return False\n\n    return isBST(node.left, l, node) and isBST(node.right, node, r)\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = Node(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            current = queue.pop(0)\n            if nodes[i] is not None:\n                current.left = Node(nodes[i])\n                queue.append(current.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                current.right = Node(nodes[i])\n                queue.append(current.right)\n            i += 1\n        return root\n\n    root = build_tree(tree_structure)\n    \n    # Call the original function with the converted input\n    result = isBST(root)\n    \n    # Convert the result to a JSON serializable output\n    return result", "input_generator": "import random\nimport json\n\ndef input_generator():\n    # Generate a random binary tree structure that may or may not be a BST\n    # The tree is represented as a list in level-order traversal with None for missing nodes\n    # The size of the tree is randomly chosen between 1 and 15 nodes\n    size = random.randint(1, 15)\n    tree = []\n    for _ in range(size):\n        # Randomly decide to include a node or None (with higher probability for nodes)\n        if random.random() < 0.8:\n            tree.append(random.randint(-100, 100))\n        else:\n            tree.append(None)\n    # Ensure at least one node is present\n    if all(x is None for x in tree):\n        tree[0] = random.randint(-100, 100)\n    return {'tree_structure': tree}", "io_pairs": [{"input": {"tree_structure": [-3, 90, null, null, null, null, 52, null, null, -96, null, 36, null, -9, -72]}, "output": false}, {"input": {"tree_structure": [38, null, 12, 45, 53]}, "output": false}, {"input": {"tree_structure": [44, 44, 85, null, 48, -49, null, null, 39, 9, -47, -61, 4, null, 76]}, "output": false}, {"input": {"tree_structure": [73, 80, 65, 51, null, -16, -53, 39, 86]}, "output": false}, {"input": {"tree_structure": [-27, 42, -69, 52, 18, null, -52, -10, 20, -9, -48, 78]}, "output": false}, {"input": {"tree_structure": [-100, -79, -8, -19, 9, null, null, -61, -17, 0, null, null, -19, null, 94]}, "output": false}, {"input": {"tree_structure": [18, 83, 99, null, 72, 95, -99, -52, 90]}, "output": false}, {"input": {"tree_structure": [-28]}, "output": true}, {"input": {"tree_structure": [74, null, 36, 82, 23, 77, null, 22]}, "output": false}, {"input": {"tree_structure": [-71, -81, -92, 22]}, "output": false}], "error_log": []}
{"context": "Given two fractions represented by their numerators and denominators, and an operation to perform on these fractions, what is the resulting fraction after performing the specified operation?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numerator1` (str): The numerator of the first fraction.\n  `denominator1` (str): The denominator of the first fraction.\n  `numerator2` (str): The numerator of the second fraction.\n  `denominator2` (str): The denominator of the second fraction.\n  `operation` (str): The operation to perform on the fractions. Possible values are \"add\", \"subtract\", \"multiply\", and \"divide\".\n\nOutput:\n  `return` (dict): A dictionary containing the result of the operation.\n    - `numerator` (str): The numerator of the resulting fraction.\n    - `denominator` (str): The denominator of the resulting fraction.", "reference_code": "# import necessary packages\nimport sympy as sm\nimport random\n\n# all class and function definitions in the code file, if any\nclass fraction(object):\n    def __init__(self, top, bottom):\n        try:\n            top = sm.simplify(top)\n            bottom = sm.simplify(bottom)\n            top = str(top)\n            bottom = str(bottom)\n    \n            self.top = top\n            self.bottom = bottom\n            \n        except:\n            print(\"Something went wrong, Please fellow python standard notation.\")\n            return None\n        \n    def __str__(self):\n        nume = \"(\" + self.top + \")\"\n        demo = \"(\" + self.bottom + \")\"\n        return nume +'/' + demo\n    \n    def __eq__(self, other):\n        if self.top == other.top and self.bottom == other.bottom:\n            return True\n        else:\n            return False\n    \n    def __mul__(self, other):\n        nume = self.paren()[0] + '*' + other.paren()[0]\n        demo = self.paren()[1] + '*' + other.paren()[1]\n        \n        try:\n            nume = str(sm.simplify(nume))\n            demo = str(sm.simplify(demo))\n            \n            return fraction(nume, demo)\n        except:\n            print(\"Something is wrong, try again with different notation please.\")\n            return None\n        \n    def paren(self):\n        nume = \"(\" + self.top + ')'\n        deno = \"(\" + self.bottom + ')'\n         \n        return (nume, deno)\n    \n    def __add__(self, other):\n        terms = fraction.adder(self, other)\n        deno = terms[0]\n        numer = terms[1] + '+' + terms[2]\n        try:\n            deno = str(sm.simplify(deno))\n            numer = str(sm.simplify(numer))\n            \n            return fraction(numer, deno)\n        except:\n            print(\"Something was wrong with addition\")\n            return None\n        \n    def adder(self, other):\n        selftop = self.paren()[0]\n        selfbottom = self.paren()[1]\n        \n        othertop = other.paren()[0]\n        otherbottom = other.paren()[0]\n        \n        deno = selfbottom + '*' + otherbottom\n        term1 = selftop + '*' + otherbottom\n        term2 = othertop + '*' + selfbottom\n        \n        return (deno, term1, term2)\n    \n    def __sub__(self, other):\n        terms = fraction.adder(self, other)\n        numer = terms[1] + '-' + terms[2]\n        denom = terms[0]\n        \n        try:\n            top = str(sm.simplify(numer))\n            bottom = str(sm.simplify(denom))\n            \n            return fraction(top, bottom)\n        \n        except:\n            print(\"Something wrong with the sub.\")\n            return None\n        \n    def get_numer(self):\n        return str(self.top)\n    \n    def get_denom(self):\n        return str(self.bottom)\n    \n    def set_numer(self, numer = ''):\n        \n        self.top = numer\n        return self\n    \n    def set_denom(self, denom):\n        try:\n            denom = str(denom)\n            if denom != '0':\n                self.bottom = denom\n                return self\n            else:\n                print(\"Division by Zero\")\n                return None\n        except:\n            print(\"Soemthing was wrong with set_denom.\")\n            \n    def reset(self):\n        numer = str(sm.simplify(self.top))\n        denom = str(sm.simplify(self.bottom))\n        \n        return fraction(numer, denom)\n            \n            \n    def __division__(self, other):\n        numer1 = self.paren()[0]\n        denom1 = self.paren()[1]\n        numer2 = other.paren()[0]\n        denom2 = other.paren()[1]\n        \n        new_numer = numer1 + '*' + denom2\n        new_denom = denom1 + '*' + numer2\n        \n        try:\n            top = str(sm.simplify(new_numer))\n            bottom = str(sm.simplify(new_denom))\n            \n            return fraction(top, bottom)\n        except:\n            print(\"something was wrong here\")\n            return None\n        \n        \n    def evaluate(self, value):\n        numer = str(sm.simplify(self.top))\n        denom = str(sm.simplify(self.bottom))\n        \n        x = value\n        numerval = eval(numer)\n        denomval = eval(denom)\n        \n        return numerval/denomval\n\n# main function\ndef main_solution(numerator1, denominator1, numerator2, denominator2, operation):\n    # Convert JSON serializable inputs to original input variables\n    frac1 = fraction(numerator1, denominator1)\n    frac2 = fraction(numerator2, denominator2)\n    \n    # Perform the operation\n    if operation == \"add\":\n        result = frac1 + frac2\n    elif operation == \"subtract\":\n        result = frac1 - frac2\n    elif operation == \"multiply\":\n        result = frac1 * frac2\n    elif operation == \"divide\":\n        result = frac1.__division__(frac2)\n    else:\n        raise ValueError(\"Invalid operation\")\n    \n    # Convert the result to JSON serializable output\n    return {\n        \"numerator\": result.get_numer(),\n        \"denominator\": result.get_denom()\n    }", "input_generator": "import random\nimport sympy as sm\n\ndef input_generator():\n    operations = [\"add\", \"subtract\", \"multiply\", \"divide\"]\n    operation = random.choice(operations)\n    \n    # Generate simple polynomial expressions or integers\n    def generate_expression():\n        x = sm.symbols('x')\n        choices = [\n            str(random.randint(1, 10)),\n            f\"{random.randint(1, 5)}*x + {random.randint(1, 5)}\",\n            f\"x**{random.randint(1, 3)}\",\n            f\"{random.randint(1, 3)}*x**2 + {random.randint(1, 3)}*x + {random.randint(1, 3)}\"\n        ]\n        return random.choice(choices)\n    \n    numerator1 = generate_expression()\n    denominator1 = generate_expression()\n    numerator2 = generate_expression()\n    denominator2 = generate_expression()\n    \n    # Ensure denominators are not zero\n    while denominator1 == '0' or denominator2 == '0':\n        denominator1 = generate_expression()\n        denominator2 = generate_expression()\n    \n    return {\n        \"numerator1\": numerator1,\n        \"denominator1\": denominator1,\n        \"numerator2\": numerator2,\n        \"denominator2\": denominator2,\n        \"operation\": operation\n    }", "io_pairs": [{"input": {"numerator1": "6", "denominator1": "2*x + 2", "numerator2": "2*x + 1", "denominator2": "4*x + 3", "operation": "subtract"}, "output": {"numerator": "-4*x**2 + 6*x + 4", "denominator": "2*(x + 1)*(2*x + 1)"}}, {"input": {"numerator1": "4*x + 5", "denominator1": "3*x**2 + 2*x + 2", "numerator2": "3*x + 1", "denominator2": "7", "operation": "multiply"}, "output": {"numerator": "(3*x + 1)*(4*x + 5)", "denominator": "21*x**2 + 14*x + 14"}}, {"input": {"numerator1": "10", "denominator1": "6", "numerator2": "3", "denominator2": "2*x**2 + 1*x + 3", "operation": "subtract"}, "output": {"numerator": "12", "denominator": "18"}}, {"input": {"numerator1": "7", "denominator1": "1*x**2 + 2*x + 1", "numerator2": "x**2", "denominator2": "2*x**2 + 3*x + 2", "operation": "subtract"}, "output": {"numerator": "x**2*(-x**2 - 2*x + 6)", "denominator": "x**2*(x**2 + 2*x + 1)"}}, {"input": {"numerator1": "x**3", "denominator1": "3*x + 5", "numerator2": "x**2", "denominator2": "9", "operation": "divide"}, "output": {"numerator": "9*x**3", "denominator": "x**2*(3*x + 5)"}}, {"input": {"numerator1": "x**3", "denominator1": "2", "numerator2": "7", "denominator2": "3*x + 4", "operation": "multiply"}, "output": {"numerator": "7*x**3", "denominator": "6*x + 8"}}, {"input": {"numerator1": "1*x + 4", "denominator1": "3*x**2 + 3*x + 2", "numerator2": "5", "denominator2": "3*x + 4", "operation": "divide"}, "output": {"numerator": "(x + 4)*(3*x + 4)", "denominator": "15*x**2 + 15*x + 10"}}, {"input": {"numerator1": "2*x + 5", "denominator1": "2*x + 3", "numerator2": "5*x + 1", "denominator2": "1*x**2 + 3*x + 2", "operation": "multiply"}, "output": {"numerator": "(2*x + 5)*(5*x + 1)", "denominator": "(2*x + 3)*(x**2 + 3*x + 2)"}}, {"input": {"numerator1": "x**2", "denominator1": "1*x**2 + 2*x + 3", "numerator2": "5*x + 1", "denominator2": "3*x**2 + 2*x + 3", "operation": "multiply"}, "output": {"numerator": "x**2*(5*x + 1)", "denominator": "(x**2 + 2*x + 3)*(3*x**2 + 2*x + 3)"}}, {"input": {"numerator1": "x**1", "denominator1": "x**2", "numerator2": "2*x + 1", "denominator2": "1", "operation": "divide"}, "output": {"numerator": "x", "denominator": "x**2*(2*x + 1)"}}], "error_log": []}
{"context": "Given a 9x9 Sudoku grid, where each cell can either be a digit from '1' to '9' or a dot '.' representing an empty cell, determine whether the grid is valid according to the Sudoku rules. Specifically, each row, column, and 3x3 sub-grid must contain unique digits from '1' to '9'. Is the provided Sudoku grid valid?\n\nThe input and output requirements are as follows:\n\nInput:\n  `grid` (list of strings): A 9x9 grid represented as a list of 9 strings, where each string contains 9 characters. Each character can be a digit from '1' to '9' or a dot '.' representing an empty cell.\n\nOutput:\n  `return` (boolean): Returns `True` if the Sudoku grid is valid according to the rules (each row, column, and 3x3 sub-grid contains unique digits from '1' to '9'), otherwise returns `False`.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(grid):\n    # Convert the input grid to a list of lists of strings\n    grid = [list(row) for row in grid]\n    \n    # Check each 3x3 sub-grid\n    for i in range(0, 7, 3):\n        for j in range(0, 7, 3):\n            check_list = [0] * 10\n            for row in range(i, i + 3):\n                for col in range(j, j + 3):\n                    if grid[row][col].isdigit():\n                        check_list[int(grid[row][col])] += 1\n                        if check_list[int(grid[row][col])] > 1:\n                            return False\n    \n    # Check each row\n    for i in range(9):\n        check_list_row = [0] * 10\n        for j in range(9):\n            if grid[i][j].isdigit():\n                check_list_row[int(grid[i][j])] += 1\n                if check_list_row[int(grid[i][j])] > 1:\n                    return False\n    \n    # Check each column\n    for i in range(9):\n        check_list_col = [0] * 10\n        for j in range(9):\n            if grid[j][i].isdigit():\n                check_list_col[int(grid[j][i])] += 1\n                if check_list_col[int(grid[j][i])] > 1:\n                    return False\n    \n    return True", "input_generator": "import random\n\ndef input_generator():\n    # Generate a valid Sudoku grid with some random elements replaced by '.'\n    grid = [['.' for _ in range(9)] for _ in range(9)]\n    \n    # Fill the grid with a valid Sudoku solution\n    for i in range(9):\n        for j in range(9):\n            grid[i][j] = str((i * 3 + i // 3 + j) % 9 + 1)\n    \n    # Randomly shuffle rows within the same block\n    for block in range(3):\n        rows = list(range(block * 3, block * 3 + 3))\n        random.shuffle(rows)\n        new_grid = [grid[i] for i in rows]\n        for i in range(3):\n            grid[block * 3 + i] = new_grid[i]\n    \n    # Randomly shuffle columns within the same block\n    for block in range(3):\n        cols = list(range(block * 3, block * 3 + 3))\n        random.shuffle(cols)\n        for i in range(9):\n            new_row = [grid[i][j] for j in cols]\n            for j in range(3):\n                grid[i][block * 3 + j] = new_row[j]\n    \n    # Randomly replace some digits with '.'\n    for i in range(9):\n        for j in range(9):\n            if random.random() < 0.5:\n                grid[i][j] = '.'\n    \n    # Convert each row to a string\n    grid = [''.join(row) for row in grid]\n    \n    return {'grid': grid}", "io_pairs": [{"input": {"grid": [".2.65497.", "...987...", "....21..5", "56.1.842.", ".347.5..9", "891...756", "..25.386.", "6.8.1..3.", "...8..29."]}, "output": true}, {"input": {"grid": [".2.4...7.", "987......", ".547..3.2", "4325.618.", ".6.8.942.", ".9....75.", "2.93....7", "87.921...", "54.6..2.1"]}, "output": true}, {"input": {"grid": [".64......", ".3.6.5897", "8.7.1.564", "...1893.2", "9.8.2367.", ".4.75691.", "1295...86", "4....71..", ".86291..."]}, "output": true}, {"input": {"grid": [".325.....", "465.97...", ".9.2...4.", ".4...5...", ".76..8.2.", "8..3.2.5.", "9....3..8", "....86.9.", ".87.2...5"]}, "output": true}, {"input": {"grid": ["9.....5.4", "6.478.2..", "3..4.68.7", "1..2.4..5", "..58.1..2", ".32.6...8", "8.69.2.53", "219345786", "5.3.781.9"]}, "output": true}, {"input": {"grid": ["56..7..1.", "...6..9..", "897.1...5", "342.56...", "9.842..5.", "675..94..", ".538.72.1", "..62915.4", "...5.4.6."]}, "output": true}, {"input": {"grid": ["465.9..31", "132..58..", "79.1...6.", "..9243...", "2.3..69..", "......342", "3.46.7..9", "9.1.5..86", ".87.2..53"]}, "output": true}, {"input": {"grid": ["7.92.354.", "4....92.3", ".2..46879", "...98.3..", "23...7.81", "8913..65.", "..2435...", "..5.6.19.", ".78...4.."]}, "output": true}, {"input": {"grid": ["5.67.8...", ".....57.8", "...1...65", ".....3576", "32.....19", "...81..4.", "768.213..", ".35.87.21", "1..3546.."]}, "output": true}, {"input": {"grid": ["8....3.4.", ".31....78", "564.79..2", ".4.6...8.", "....2.75.", ".759.1423", "...1..5.4", "1294..8.7", ".537.82.."]}, "output": true}], "error_log": []}
{"context": "Given a list of strings where each string consists of parentheses, how many valid parentheses expressions can be formed by combining these strings?\n\nThe input and output requirements are as follows:\n\nInput:\n  `pairs_list` (list of strings): A list of strings where each string represents a sequence of parentheses.\n\nOutput:\n  `return` (int): The number of valid parentheses expressions that can be formed from the given list of strings.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef get_pairs(pairs_list):\n    leftmap = {}\n    rightmap = {}\n    stack = []\n    com = 0\n    for pairs in pairs_list:\n        for s in pairs:\n            if s == \"(\":\n                stack.append(s)\n            else:\n                if len(stack) == 0:\n                    stack.append(s)\n                else:\n                    if stack[-1] == \"(\":\n                        stack.pop()\n                    else:\n                        stack.append(s)\n        if len(stack) == 0:\n            com += 1\n            continue\n        \n        ln = rn = 0\n        while len(stack) > 0:\n            top = stack.pop()\n            if top == \"(\":\n                ln += 1\n            elif top == \")\":\n                rn += 1\n        \n        if ln == 0:\n            if rn in rightmap.keys():\n                rightmap[rn] += 1\n            else:\n                rightmap.update({rn: 1})\n        \n        if rn == 0:\n            if ln in leftmap:\n                leftmap[ln] += 1\n            else:\n                leftmap.update({ln: 1})\n    \n    sumpairs = com * com\n    for key in leftmap.keys():\n        r = rightmap[key] if key in rightmap.keys() else 0\n        sumpairs += r * leftmap[key]\n        \n    return sumpairs\n\n# main function\ndef main_solution(pairs_list):\n    # Convert the input list of strings to a list of lists of characters\n    pairs = [list(i) for i in pairs_list]\n    # Call the get_pairs function to get the result\n    result = get_pairs(pairs)\n    # Return the result\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 20)\n    pairs_list = []\n    for _ in range(n):\n        length = random.randint(1, 20)\n        s = []\n        balance = 0\n        for _ in range(length):\n            if random.random() < 0.5:\n                s.append('(')\n                balance += 1\n            else:\n                if balance > 0 and random.random() < 0.7:\n                    s.append(')')\n                    balance -= 1\n                else:\n                    s.append(')')\n        pairs_list.append(''.join(s))\n    return {'pairs_list': pairs_list}", "io_pairs": [{"input": {"pairs_list": ["))())((", ")", "()((", ")()))))(()(()((()", ")((())))))))(()()()"]}, "output": 0}, {"input": {"pairs_list": ["((())())(()))()((", "))())))()((()("]}, "output": 0}, {"input": {"pairs_list": ["()"]}, "output": 1}, {"input": {"pairs_list": ["())())())(((((", "))())())))()()())", "((()()))((((", "())(()()("]}, "output": 0}, {"input": {"pairs_list": ["())())()(()", ")()))(((()(()())(()", "))())"]}, "output": 0}, {"input": {"pairs_list": [")((((((())))(((()"]}, "output": 0}, {"input": {"pairs_list": ["))(()((()()))))(", "())(()()(((", "(()((())((())())))", ")(()()()", "(()", "(())())(()()())((", "()))))((()()()(", "())(((()((()((()"]}, "output": 1}, {"input": {"pairs_list": ["()(((((())(())((((", "()))))((", ")))((((", "()(()()(("]}, "output": 0}, {"input": {"pairs_list": ["()()((", "(((()))))(", "())()())()()))()(((", "(())()((((", "))()))())))))()()((", "()(()(()()("]}, "output": 0}, {"input": {"pairs_list": ["(()((()(())))(((()", "))))))()", "())))()((()((()("]}, "output": 0}], "error_log": []}
{"context": "A researcher is studying the growth of bacteria over time. They have collected data on the number of bacteria at specific time intervals. Using this data, they want to estimate the number of bacteria at a different time point. Given the recorded time intervals and the corresponding number of bacteria, what is the estimated number of bacteria at a randomly selected time point between 0.1 and 1.3 seconds?\n\nThe input and output requirements are as follows:\n\nInput:\n  `t_values` (list of float): A list of time values in seconds at which the number of bacteria was recorded.\n  `f_values` (list of float): A list of corresponding number of bacteria values for each time in `t_values`.\n  `target_t` (float): The time value in seconds at which the number of bacteria needs to be estimated.\n\nOutput:\n  `return` (float): The estimated number of bacteria at the given `target_t` time value, rounded to 10 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef u_cal(u, n):\n    temp = u\n    for i in range(1, n):\n        temp = temp * (u - i)\n    return temp\n\ndef fact(n):\n    f = 1\n    for i in range(2, n + 1):\n        f *= i\n    return f\n\n# main function\ndef main_solution(t_values, f_values, target_t):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    n = len(t_values)\n    y = [[0 for i in range(n)] for j in range(n)]\n    \n    # Initialize the first column of the difference table\n    for i in range(n):\n        y[i][0] = f_values[i]\n    \n    # Calculating the forward difference table\n    for i in range(1, n):\n        for j in range(n - i):\n            y[j][i] = y[j + 1][i - 1] - y[j][i - 1]\n    \n    # Value to interpolate at\n    value = target_t\n    \n    # initializing u and sum\n    sum = y[0][0]\n    u = (value - t_values[0]) / (t_values[1] - t_values[0])\n    for i in range(1, n):\n        sum = sum + (u_cal(u, i) * y[0][i]) / fact(i)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return round(sum, 10)", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(3, 10)  # Reasonable size for interpolation\n    t_start = random.uniform(0, 10)\n    t_step = random.uniform(0.5, 2)\n    t_values = [round(t_start + i * t_step, 2) for i in range(n)]\n    \n    # Generate f_values with some randomness but ensuring it's not too trivial\n    base = random.uniform(1, 100)\n    f_values = [round(base + i * random.uniform(-5, 5), 2) for i in range(n)]\n    \n    # Generate target_t within a reasonable range of t_values\n    min_t = min(t_values)\n    max_t = max(t_values)\n    target_t = round(random.uniform(min_t, max_t), 2)\n    \n    return {\n        't_values': t_values,\n        'f_values': f_values,\n        'target_t': target_t\n    }", "io_pairs": [{"input": {"t_values": [4.92, 5.67, 6.42, 7.16, 7.91], "f_values": [33.21, 34.66, 24.0, 22.54, 38.63], "target_t": 5.78}, "output": 33.2010179748}, {"input": {"t_values": [7.88, 9.82, 11.76, 13.7, 15.64, 17.59], "f_values": [45.19, 47.39, 48.62, 34.55, 57.78, 69.56], "target_t": 15.24}, "output": 49.4403653868}, {"input": {"t_values": [8.65, 9.44, 10.23, 11.03, 11.82, 12.62, 13.41], "f_values": [50.74, 54.58, 52.34, 47.27, 69.79, 62.47, 34.74], "target_t": 11.2}, "output": 50.8543673529}, {"input": {"t_values": [9.03, 10.62, 12.22, 13.82, 15.42], "f_values": [71.56, 72.31, 62.06, 60.57, 80.92], "target_t": 14.75}, "output": 69.5428022583}, {"input": {"t_values": [7.02, 8.18, 9.34, 10.5, 11.66], "f_values": [54.6, 57.07, 59.39, 40.59, 48.68], "target_t": 8.16}, "output": 56.8685100244}, {"input": {"t_values": [7.34, 8.51, 9.68, 10.85, 12.02, 13.19, 14.35], "f_values": [25.92, 25.41, 31.13, 11.34, 40.8, 33.98, 24.11], "target_t": 8.11}, "output": 7.1175462684}, {"input": {"t_values": [6.37, 8.24, 10.11, 11.98], "f_values": [17.17, 19.04, 13.24, 18.0], "target_t": 10.89}, "output": 12.8948966977}, {"input": {"t_values": [9.31, 9.83, 10.35, 10.87, 11.38], "f_values": [83.82, 79.39, 86.56, 80.56, 81.57], "target_t": 11.27}, "output": 78.0295213753}, {"input": {"t_values": [5.19, 5.91, 6.64], "f_values": [5.2, 7.48, 8.07], "target_t": 6.6}, "output": 8.0791579861}, {"input": {"t_values": [2.93, 3.7, 4.48], "f_values": [37.86, 38.48, 39.37], "target_t": 4.38}, "output": 39.2520391297}], "error_log": []}
{"context": "Given a chessboard of size `N` x `N`, how many distinct ways can you place `N` queens on the board such that no two queens threaten each other? Each queen must be placed in a unique row and column, and no two queens can be on the same diagonal. What are the positions of the queens in each valid configuration?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (list of lists): A list of all possible solutions where each solution is represented as a list of integers. Each integer in the list represents the column position of the queen in the corresponding row. The length of the outer list is the number of solutions, and the length of each inner list is `N`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_available(candidate, current_col):\n    current_row = len(candidate)\n    for queen_row in range(current_row):\n        if candidate[queen_row] == current_col or abs(candidate[queen_row] - current_col) == current_row - queen_row:\n            return False\n    return True\n\ndef DFS(N, current_row, current_candidate, final_result):\n    if current_row == N:\n        final_result.append(current_candidate[:])\n        return\n    \n    for candidate_col in range(N):\n        if is_available(current_candidate, candidate_col):\n            current_candidate.append(candidate_col)\n            DFS(N, current_row + 1, current_candidate, final_result)\n            current_candidate.pop()\n\n# main function\ndef main_solution(N):\n    final_result = []\n    DFS(N, 0, [], final_result)\n    return final_result", "input_generator": "import random\n\ndef input_generator():\n    N = random.choice([4, 5, 6, 7, 8])\n    return {'N': N}", "io_pairs": [{"input": {"N": 6}, "output": [[1, 3, 5, 0, 2, 4], [2, 5, 1, 4, 0, 3], [3, 0, 4, 1, 5, 2], [4, 2, 0, 5, 3, 1]]}, {"input": {"N": 4}, "output": [[1, 3, 0, 2], [2, 0, 3, 1]]}], "error_log": []}
{"context": "Given a message consisting of uppercase alphabetic characters, how can we encrypt it using a solitaire cipher to produce a new message composed solely of uppercase alphabetic characters?\n\nThe input and output requirements are as follows:\n\nInput:\n  `message` (str): The message to be encrypted. It should be a string containing only uppercase alphabetic characters (A-Z). Any non-alphabetic characters will be removed.\n\nOutput:\n  `return` (str): The encrypted message. It is a string containing only uppercase alphabetic characters (A-Z).", "reference_code": "# import necessary packages\nimport string\nimport random\nimport re\nimport copy\n\n# all class and function definitions in the code file, if any\ndef create_deck():\n    value = {}\n    deck = []\n    jokera = create_card(1,0,deck)\n    jokerb = create_card(2,0,deck)\n    for v in range(1,14):\n        for c in range(1,3):\n            deck.append((v, c))\n            value = define_cards(deck)\n    shuffle_deck(deck)\n    return deck, value\n\ndef create_card(v,c,deck):\n    deck.append((v,c))\n\ndef shuffle_deck(deck):\n    random.shuffle(deck)\n    for x in range(int(len(deck) / 2)):\n        deck.append(deck.pop(0))\n\ndef move_card(old, new, deck):\n    if deck[old] == (1,0):\n        if old == 27:\n             deck.insert(1,(deck.pop(old)))\n        else:\n            deck.insert(new, (deck.pop(old)))\n    elif deck[old] == (2,0):\n        if old == 27:\n            deck.insert(2, (deck.pop(old)))\n        elif old == 26:\n            deck.insert(1, (deck.pop(old)))\n        else:\n            deck.insert(new, (deck.pop(old)))\n    else:\n        deck.insert(new, (deck.pop(old)))\n\ndef define_cards(deck):\n    deck.sort(key=lambda tup: tup[1])\n    value = {}\n    for x in range(len(deck)):\n        if deck[x][1] == 0:\n            value[deck[x]] = 27\n        else:\n            value[deck[x]] = x + -1\n    return value\n\ndef solitaire_keystream(length, deck, value):\n    temp_deck = copy.deepcopy(deck)\n    key = \"\"\n\n    while (len(key) != length):\n        move_card(temp_deck.index((1,0)), temp_deck.index((1,0)) + 1, temp_deck)\n        move_card(temp_deck.index((2,0)), temp_deck.index((2,0)) + 2, temp_deck)\n        \n        joker1 = min(temp_deck.index((1,0)),temp_deck.index((2,0)))\n        joker2 = max(temp_deck.index((1,0)),temp_deck.index((2,0)))\n\n        A = temp_deck[:joker1]\n        B = temp_deck[joker1:joker2 + 1]\n        C = temp_deck[joker2+1:]\n        temp_deck = C + B + A\n        \n        for i in range(value[temp_deck[len(temp_deck) - 1]]):\n            temp_deck.insert(len(temp_deck) - 2, temp_deck.pop(0))\n            \n        if value[temp_deck[0]] == 27:\n            pass\n        else:\n            key += string.ascii_uppercase[value[temp_deck[0]] - 1]\n\n    return key\n\n# main function\ndef main_solution(message):\n    # Convert message to uppercase and remove non-alphabetic characters\n    message = re.sub('[^A-Z]', '', message.upper())\n    \n    # Create deck and value dictionary\n    deck, value = create_deck()\n    \n    # Generate keystream\n    keystream = solitaire_keystream(len(message), deck, value)\n    \n    # Encrypt the message\n    encrypted_message = \"\"\n    for i in range(len(message)):\n        msg_char_value = string.ascii_uppercase.index(message[i]) + 1\n        key_char_value = string.ascii_uppercase.index(keystream[i]) + 1\n        encrypted_char_value = (msg_char_value + key_char_value - 1) % 26 + 1\n        encrypted_message += string.ascii_uppercase[encrypted_char_value - 1]\n    \n    return encrypted_message", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random message length between 5 and 20 characters\n    length = random.randint(5, 20)\n    # Generate a random message consisting of uppercase letters and possibly some non-alphabetic characters\n    message = ''.join(random.choices(string.ascii_uppercase + string.digits + string.punctuation + ' ', k=length))\n    return {'message': message}", "io_pairs": [{"input": {"message": "TIY[}I>}}&8Y\"<"}, "output": "YODEZ"}, {"input": {"message": ")@0H~7+>.60H%,*<}]S"}, "output": "QXL"}, {"input": {"message": "$_D`0E):CU`?ZC~~~"}, "output": "HPKBLF"}, {"input": {"message": "~{L: ,F1}SDC} "}, "output": "OULKJ"}, {"input": {"message": "0]A%^LR[Q>-"}, "output": "CGPZ"}, {"input": {"message": "H}^*:6$H;/@8<0E"}, "output": "DWM"}, {"input": {"message": "P0[B_KD=A[K"}, "output": "RTSCDV"}, {"input": {"message": "|GD,@+AS]/GMSS"}, "output": "QACMCISJ"}, {"input": {"message": "4D0%2]^*<K){X\\/B}-0F"}, "output": "KVAHQ"}, {"input": {"message": "7HUFH"}, "output": "TRQA"}], "error_log": []}
{"context": "Given a sum `n`, find the product of the Pythagorean triplet (a, b, c) such that a + b + c = n and a\u00b2 + b\u00b2 = c\u00b2. What is the product of the triplet if it exists?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer representing the sum of the Pythagorean triplet (a + b + c).\n\nOutput:\n  `return` (int): The product of the Pythagorean triplet (a * b * c) if such a triplet exists, otherwise `None`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef isTriplet(a, b, c):\n    if pow(c, 2) == pow(a, 2) + pow(b, 2):\n        return True\n    return False\n\ndef specialPythagoreanTriplet(n):\n    for a in range(1, n):\n        for b in range(a, n):\n            c = n - b - a\n            if (isTriplet(a, b, c)):\n                return a*b*c\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = specialPythagoreanTriplet(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random even number between 12 and 1000 to ensure it's possible to form a triplet\n    n = random.randint(12, 1000) * 2\n    return {'n': n}", "io_pairs": [{"input": {"n": 1788}, "output": 198476940}, {"input": {"n": 200}, "output": 255000}, {"input": {"n": 1040}, "output": 34710000}, {"input": {"n": 1566}, "output": 57393900}, {"input": {"n": 770}, "output": 15015000}, {"input": {"n": 1932}, "output": 130680480}, {"input": {"n": 1978}, "output": 110253720}, {"input": {"n": 72}, "output": 12960}, {"input": {"n": 1968}, "output": 202576080}, {"input": {"n": 1956}, "output": 259844820}], "error_log": []}
{"context": "Given two integers `a` and `modulo`, what is the modular inverse of `a` under `modulo`? The modular inverse exists only if `a` and `modulo` are coprime. If they are not coprime, indicate the reason why the inverse cannot be found.\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): The integer for which the modular inverse is to be found.\n  `modulo` (int): The modulus under which the inverse is to be found.\n\nOutput:\n  `return` (int or str): The modular inverse of `a` under `modulo` if `a` and `modulo` are coprime. If they are not coprime, it returns a string indicating the error.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef pgcd(a, modulo):\n    c, d = max(a, modulo), min(a, modulo)  # d\u00e9termination du Dividende et du diviseur\n    while d > 0:\n        c, d = d, c % d\n    return c\n\ndef inverse_mod(a, modulo):\n    npgcd = pgcd(a, modulo)\n    if npgcd != 1:\n        raise ValueError(\"D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux.\")\n    k = int(modulo / a) + 1\n    mo = 1\n    while mo != 0:\n        k += 1\n        mo = (1 + modulo * k) % a\n    res = ((1 + modulo * k) // a) % modulo\n    return res\n\n# main function\ndef main_solution(a, modulo):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    try:\n        result = inverse_mod(a, modulo)\n    except ValueError as e:\n        result = str(e)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random modulo between 2 and 1000\n    modulo = random.randint(2, 1000)\n    \n    # Generate a list of potential 'a' values that are coprime with modulo\n    coprime_candidates = [i for i in range(1, modulo) if math.gcd(i, modulo) == 1]\n    \n    # Decide whether to generate a valid 'a' or an invalid one (not coprime)\n    if random.choice([True, False]) and coprime_candidates:\n        a = random.choice(coprime_candidates)\n    else:\n        # Generate an 'a' that is not coprime with modulo\n        factors = []\n        temp = modulo\n        i = 2\n        while i * i <= temp:\n            if temp % i == 0:\n                factors.append(i)\n                while temp % i == 0:\n                    temp //= i\n            i += 1\n        if temp > 1:\n            factors.append(temp)\n        if factors:\n            a = random.choice(factors) * random.randint(1, modulo // max(factors))\n        else:\n            a = random.randint(1, modulo - 1)\n    \n    return {'a': a, 'modulo': modulo}", "io_pairs": [{"input": {"a": 117, "modulo": 403}, "output": "D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux."}, {"input": {"a": 24, "modulo": 196}, "output": "D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux."}, {"input": {"a": 929, "modulo": 929}, "output": "D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux."}, {"input": {"a": 48, "modulo": 234}, "output": "D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux."}, {"input": {"a": 333, "modulo": 371}, "output": 205}, {"input": {"a": 331, "modulo": 331}, "output": "D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux."}, {"input": {"a": 53, "modulo": 109}, "output": 72}, {"input": {"a": 167, "modulo": 167}, "output": "D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux."}, {"input": {"a": 695, "modulo": 874}, "output": 83}, {"input": {"a": 496, "modulo": 905}, "output": 801}], "error_log": []}
{"context": "Given a maze represented by a grid of characters, where `X` represents walls, `_` represents empty spaces, `S` represents the starting point, and `G` represents the goal point, what is the path from the starting point `S` to the goal point `G`? The path should be represented as a series of coordinates, where each coordinate is a position in the maze grid.\n\nThe input and output requirements are as follows:\n\nInput:\n  `maze_str` (str): A string representing the maze. Each line of the maze is separated by a newline character (`\\n`). The maze consists of the following symbols:\n  - `X`: Walls\n  - `_`: Empty spaces\n  - `S`: Starting point\n  - `G`: Goal point\n\nOutput:\n  `return` (str): A string representing the path from the starting point `S` to the goal point `G`. Each coordinate in the path is separated by a semicolon (`;`). Each coordinate is represented as `row,column`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef printmaze(maze):\n    xmax, ymax = len(maze), len(maze[0])\n    print ('\\nMaze Graph') \n    print ('='*(2*ymax-1)) # upper boarder\n    \n    for lists in maze:\n        for i in lists:\n            print(i,end=' ')\n        print()\n        \n    print ('='*(2*ymax-1)) # lower boarder\n\ndef search(maze, x, y, xmax, ymax, path):\n    if maze[x][y] == 'G':\n        path.append([x,y]) # Adding final value to solution path list.\n        return True\n    elif maze[x][y] == 'X':\n        return False\n    elif maze[x][y] == '+':\n        return False\n\n    # else: spot is available to move into\n    maze[x][y] = '+'    # marking as visited.\n    path.append([x,y])  # adding position's coordinates to our solution path list.\n\n    # explore neighbors clockwise (starting north), only after checking said neighbor is within bounds.\n    if ((x > 0 and search(maze, x-1, y, xmax, ymax, path))         # check north \n        or (y < ymax-1 and search(maze, x, y+1, xmax, ymax, path)) # check east\n        or (x < xmax-1 and search(maze, x+1, y, xmax, ymax, path)) # check south\n        or (y > 0 and search(maze, x, y-1, xmax, ymax, path))):    # check west\n        return True\n    \n    maze[x][y] = ' '    # not part of solution path => unmarking.\n    path.pop()          # removing unmarked spot's coordinates from solution path list.\n    return False\n\n# main function\ndef main_solution(maze_str):\n    # Convert the input string to a list of lists\n    maze = [list(line) for line in maze_str.split('\\n') if line.strip()]\n    \n    # Find starting position (S) index\n    x1, y1 = None, None\n    for i, row in enumerate(maze):\n        if 'S' in row:\n            x1 = i\n            y1 = row.index('S')\n            break\n    \n    if x1 is None or y1 is None:\n        raise ValueError(\"Starting point 'S' not found in the maze.\")\n    \n    xmax, ymax = len(maze), len(maze[0])\n    path = []\n    \n    # Perform the search\n    search(maze, x1, y1, xmax, ymax, path)\n    \n    # Reset starting position back to 'S'\n    maze[x1][y1] = 'S'\n    \n    # Convert the path to a JSON serializable format\n    path_str = ';'.join([f\"{coord[0]},{coord[1]}\" for coord in path])\n    \n    return path_str", "input_generator": "import random\n\ndef input_generator():\n    # Define possible maze components\n    wall = 'X'\n    path = ' '\n    start = 'S'\n    goal = 'G'\n    \n    # Randomly choose maze dimensions (between 5x5 and 10x10)\n    rows = random.randint(5, 10)\n    cols = random.randint(5, 10)\n    \n    # Initialize maze with walls\n    maze = [[wall for _ in range(cols)] for _ in range(rows)]\n    \n    # Randomly place start and goal\n    start_pos = (random.randint(0, rows-1), (random.randint(0, cols-1))\n    goal_pos = (random.randint(0, rows-1), (random.randint(0, cols-1)))\n    while goal_pos == start_pos:\n        goal_pos = (random.randint(0, rows-1), (random.randint(0, cols-1)))\n    \n    maze[start_pos[0]][start_pos[1]] = start\n    maze[goal_pos[0]][goal_pos[1]] = goal\n    \n    # Create a path from start to goal\n    current_pos = start_pos\n    while current_pos != goal_pos:\n        x, y = current_pos\n        # Decide next move (randomly choose direction)\n        if random.random() < 0.5:\n            # Move horizontally\n            new_y = y + 1 if goal_pos[1] > y else y - 1\n            if 0 <= new_y < cols:\n                if (x, new_y) == goal_pos:\n                    current_pos = (x, new_y)\n                else:\n                    maze[x][new_y] = path\n                    current_pos = (x, new_y)\n        else:\n            # Move vertically\n            new_x = x + 1 if goal_pos[0] > x else x - 1\n            if 0 <= new_x < rows:\n                if (new_x, y) == goal_pos:\n                    current_pos = (new_x, y)\n                else:\n                    maze[new_x][y] = path\n                    current_pos = (new_x, y)\n    \n    # Convert maze to string representation\n    maze_str = '\\n'.join(''.join(row) for row in maze)\n    \n    return {'maze_str': maze_str}", "io_pairs": [], "error_log": ["STDERR:   File \"<string>\", line 59\n    start_pos = (random.randint(0, rows-1), (random.randint(0, cols-1))\n                ^\nSyntaxError: '(' was never closed\n"]}
{"context": "Given a large integer `n`, what is the difference between the results of two mathematical functions, `R_v3` and `B`, when applied to `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer representing the target value for the computation.\n\nOutput:\n  `return` (float): A floating-point number representing the difference between the results of the functions `R_v3` and `B` for the given input `n`.", "reference_code": "# import necessary packages\nfrom math import log\n\n# all class and function definitions in the code file, if any\ndef B(n):\n    def recur_B(n):\n        if n in result: return result[n]\n\n        temp_result = 1\n        index1 = (n + 1) // 2 - 1\n        index2 = n - (n + 1) // 2\n        temp_result += (index1 * recur_B(index1) + index2 * recur_B(index2)) / n\n\n        result[n] = temp_result\n        return temp_result\n\n    result = {0: 0, 1: 1}\n    return recur_B(n)\n\ndef R_v3(n):\n    running_sum = log(n) - 1.5 + 0.5772156649 + 1 / 2 / n\n    return 3 / n + 2 * (n + 1) * running_sum / n\n\n# main function\ndef main_solution(n):\n    # Convert JSON serializable input to original input variables\n    n = int(n)\n    \n    # Compute the results using the provided functions\n    r = R_v3(n)\n    b = B(n)\n    \n    # Convert the results to JSON serializable outputs\n    result = r - b\n    \n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 1000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 676}, "output": 2.70780608657798}, {"input": {"n": 603}, "output": 2.663008549287616}, {"input": {"n": 734}, "output": 2.7524750161637}, {"input": {"n": 36}, "output": 1.164503845170275}, {"input": {"n": 203}, "output": 2.0605761420523327}, {"input": {"n": 222}, "output": 2.1307964115537894}, {"input": {"n": 155}, "output": 1.9138475841323093}, {"input": {"n": 433}, "output": 2.48828141918749}, {"input": {"n": 397}, "output": 2.4223664170757955}, {"input": {"n": 394}, "output": 2.417056171795517}], "error_log": []}
{"context": "Given a square matrix represented by a list of lists of floats, what is the estimated supremum of its eigenvalues?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_data` (list of lists of floats): A 2D list representing a square matrix. Each sublist represents a row in the matrix, and each element in the sublist is a float.\n\nOutput:\n  `supremum_eigenvalue` (float): The estimated supremum of the eigenvalues of the given matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef ncr(n, r):\n    \"\"\"\n    Calculates nCr in efficient manner. \n    This function is not my original code, but copied from below url.\n    https://stackoverflow.com/questions/4941753/is-there-a-math-ncr-function-in-python\n\n    Parameters\n    ----------\n    n, r: int \n    \"\"\"\n    r = min(r, n-r)\n    numer = reduce(op.mul, range(n, n-r, -1), 1)\n    denom = reduce(op.mul, range(1, r+1), 1)\n    return numer / denom\n\ndef flatten(l):\n    \"\"\" \n    flatten a nested list.\n    https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-list-of-lists\n    \n    Parameters\n    ----------\n    l: array-like\n    \"\"\"\n    return [item for sublist in l for item in sublist]\n\ndef split_array(a, n):\n    \"\"\"\n    Split an array into n chunks. \n    https://stackoverflow.com/questions/2130016/splitting-a-list-into-n-parts-of-approximately-equal-length\n\n    Parameters\n    ----------\n    a: array-like\n    n: int \n        number of chunks\n    \"\"\"\n    k, m = divmod(len(a), n)\n    return (a[i * k + min(i, m):(i + 1) * k + min(i + 1, m)] for i in range(n))\n\ndef supremum_eigen(X):\n    \"\"\"\n    Estimates approximate supremum of eigen values of a square matrix\n    by Gershgorin circle theorem.\n    Ref(in JP): https://qiita.com/fujiisoup/items/e7f703fc57e2dfc441ad\n\n    Parameters\n    ----------\n    X: np.ndarray (d,d)\n    \"\"\"\n    return np.max(np.sum(np.abs(X), axis=0))\n\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\ndef softmax(x):\n    if x.ndim == 1:\n        x = np.array([x])\n\n    # Avoid overflow\n    x = x - np.array([x.max(axis=1)]).T\n\n    exp_x = np.exp(x)\n    sum_exp_x = np.sum(exp_x,axis=1)[np.newaxis].T\n    return exp_x / sum_exp_x\n\n# main function\ndef main_solution(matrix_data):\n    \"\"\"\n    This function calculates the supremum of the eigenvalues of a given square matrix.\n\n    Parameters\n    ----------\n    matrix_data: list of lists of floats\n        A 2D list representing a square matrix.\n\n    Returns\n    -------\n    supremum_eigenvalue: float\n        The estimated supremum of the eigenvalues of the given matrix.\n    \"\"\"\n    # Convert the input list of lists to a numpy array\n    X = np.array(matrix_data)\n    \n    # Calculate the supremum of the eigenvalues\n    supremum_eigenvalue = supremum_eigen(X)\n    \n    # Return the result as a float\n    return supremum_eigenvalue", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.randint(2, 10)  # Random matrix size between 2x2 and 10x10\n    matrix = np.random.uniform(-10, 10, (size, size)).tolist()  # Random values between -10 and 10\n    return {'matrix_data': matrix}", "io_pairs": [{"input": {"matrix_data": [[0.8536665864621629, -3.0281613566723546], [3.6972345405871074, 4.165858320255978]]}, "output": 7.194019676928333}, {"input": {"matrix_data": [[1.2266960413060328, 1.527313329711875], [1.9375536535894629, -5.32302409729438]]}, "output": 6.850337427006255}, {"input": {"matrix_data": [[-3.8167143681303877, -0.8090491139481806], [-9.175744573662685, 0.8657750221649678]]}, "output": 12.992458941793073}, {"input": {"matrix_data": [[-6.594097440349365, -2.1035257022045766], [-9.870236837487836, 0.6904168549962169]]}, "output": 16.4643342778372}, {"input": {"matrix_data": [[9.86159260218481, -6.599535198040261, 0.9091942067658483], [5.962077266497781, -7.4276122953968855, 7.748542464307864], [0.211681144118117, 6.3096003723877345, 0.8058007017479731]]}, "output": 20.336747865824883}, {"input": {"matrix_data": [[-7.553732379376232, -4.261669637804076], [-8.633148356447029, 9.270175789860755]]}, "output": 16.18688073582326}, {"input": {"matrix_data": [[-5.120773060816928, -2.628317768173929, 9.456501698782617], [4.343509427796654, -5.702363747560392, -1.8895939221897944], [-4.599703002322844, 6.05495490894295, -0.2706327077193844]]}, "output": 14.385636424677271}, {"input": {"matrix_data": [[6.330454726045808, 8.402606850051217], [-1.1369908332106622, -0.12484277087702367]]}, "output": 8.527449620928241}, {"input": {"matrix_data": [[5.688710345825662, -4.7170465597602345], [-0.023331974895324237, -9.575766136700835]]}, "output": 14.29281269646107}, {"input": {"matrix_data": [[2.3844685390533016, -6.253828192099422], [4.378244689667039, -4.350507486854309]]}, "output": 10.604335678953731}], "error_log": []}
{"context": "A manager of an industrial plant is considering purchasing either machine A or machine B. The number of repairs needed for each machine per day follows a Poisson distribution. Machine A has a mean number of repairs `lambda_a`, and machine B has a mean number of repairs `lambda_b`. The daily operating cost for machine A is calculated as 160 + 40 * (lambda_a + lambda_a\u00b2), and for machine B, it is 128 + 40 * (lambda_b + lambda_b\u00b2). What are the daily operating costs for both machines, rounded to three decimal places?\n\nThe input and output requirements are as follows:\n\nInput:\n  `lambda_a` (float): The mean number of repairs for machine A.\n  `lambda_b` (float): The mean number of repairs for machine B.\n\nOutput:\n  `return` (dict): A dictionary containing the daily costs for both machines.\n    - `cost_a` (float): The daily cost of operating machine A, rounded to 3 decimal places.\n    - `cost_b` (float): The daily cost of operating machine B, rounded to 3 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(lambda_a, lambda_b):\n    # Calculate the daily cost for machine A\n    cost_a = 160 + 40 * (lambda_a + lambda_a ** 2)\n    \n    # Calculate the daily cost for machine B\n    cost_b = 128 + 40 * (lambda_b + lambda_b ** 2)\n    \n    # Return the costs rounded to 3 decimal places\n    return {\"cost_a\": round(cost_a, 3), \"cost_b\": round(cost_b, 3)}", "input_generator": "import random\n\ndef input_generator():\n    lambda_a = round(random.uniform(0.1, 5.0), 2)\n    lambda_b = round(random.uniform(0.1, 5.0), 2)\n    return {\"lambda_a\": lambda_a, \"lambda_b\": lambda_b}", "io_pairs": [{"input": {"lambda_a": 2.09, "lambda_b": 0.55}, "output": {"cost_a": 418.324, "cost_b": 162.1}}, {"input": {"lambda_a": 4.41, "lambda_b": 3.44}, "output": {"cost_a": 1114.324, "cost_b": 738.944}}, {"input": {"lambda_a": 4.61, "lambda_b": 3.14}, "output": {"cost_a": 1194.484, "cost_b": 647.984}}, {"input": {"lambda_a": 3.31, "lambda_b": 4.67}, "output": {"cost_a": 730.644, "cost_b": 1187.156}}, {"input": {"lambda_a": 2.75, "lambda_b": 2.82}, "output": {"cost_a": 572.5, "cost_b": 558.896}}, {"input": {"lambda_a": 1.56, "lambda_b": 2.56}, "output": {"cost_a": 319.744, "cost_b": 492.544}}, {"input": {"lambda_a": 1.68, "lambda_b": 4.81}, "output": {"cost_a": 340.096, "cost_b": 1245.844}}, {"input": {"lambda_a": 3.01, "lambda_b": 4.93}, "output": {"cost_a": 642.804, "cost_b": 1297.396}}, {"input": {"lambda_a": 3.7, "lambda_b": 3.94}, "output": {"cost_a": 855.6, "cost_b": 906.544}}, {"input": {"lambda_a": 3.25, "lambda_b": 4.39}, "output": {"cost_a": 712.5, "cost_b": 1074.484}}], "error_log": []}
{"context": "Given two lines defined by their endpoints, what are the coordinates of the intersection point of these two lines? The lines are defined by their endpoints, where each endpoint is a pair of x and y coordinates.\n\nThe input and output requirements are as follows:\n\nInput:\n  `line1` (list of lists): A list containing two lists, each representing a point on the first line. Each point is represented by a list of two floats, [x, y].\n  `line2` (list of lists): A list containing two lists, each representing a point on the second line. Each point is represented by a list of two floats, [x, y].\n\nOutput:\n  `return` (dict): A dictionary containing the coordinates of the intersection point. The keys are \"x\" and \"y\", and the values are floats representing the x and y coordinates of the intersection point.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef line_from_points(p1, p2):\n    if p1 == p2:\n        raise ValueError(\"Points are Not Distinct...\")\n    else:\n        x1, y1 = p1[0], p1[1]\n        x2, y2 = p2[0], p2[1]\n    # line for two points\n    # ((y - y1) / (x - x1)) = ((y2-y1)/(x2-x1))\n    # check if line is vertical x2 == x1\n    if x2 == x1:\n        # ax + by + c = 0\n        # ax + by = -c\n        # line is vertical -> x = -c\n        a, b, c = 1, 0, -x1\n    else:\n        m = ((y2-y1)/(x2-x1))\n        a, b, c = (-m), 1, (m*x1-y1)\n    return a, b, c\n\ndef line_intersection(line1, line2):\n    a1, b1, c1 = line_from_points(line1[0], line1[1])\n    a2, b2, c2 = line_from_points(line2[0], line2[1])\n    a = np.array([[a1, b1], [a2, b2]])\n    b = np.array([-c1, -c2])\n    x, y = np.linalg.solve(a, b)\n    return x, y \n\n# main function\ndef main_solution(line1, line2):\n    # Convert input to appropriate format if necessary\n    line1 = tuple(map(tuple, line1))\n    line2 = tuple(map(tuple, line2))\n    \n    # Calculate the intersection point\n    intersection = line_intersection(line1, line2)\n    \n    # Convert output to JSON serializable format\n    return {\"x\": float(intersection[0]), \"y\": float(intersection[1])}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate two distinct points for line1\n    while True:\n        p1 = (random.uniform(-10, 10), random.uniform(-10, 10))\n        p2 = (random.uniform(-10, 10), random.uniform(-10, 10))\n        if p1 != p2:\n            line1 = (p1, p2)\n            break\n    \n    # Generate two distinct points for line2, ensuring they are not the same as line1's points\n    while True:\n        p3 = (random.uniform(-10, 10), random.uniform(-10, 10))\n        p4 = (random.uniform(-10, 10), random.uniform(-10, 10))\n        if p3 != p4 and (p3, p4) != (p1, p2) and (p3, p4) != (p2, p1):\n            line2 = (p3, p4)\n            break\n    \n    return {\"line1\": line1, \"line2\": line2}", "io_pairs": [{"input": {"line1": [[3.211662044252, -4.31044910357193], [-6.738874161286983, 1.5186617636973914]], "line2": [[6.81612402943356, 1.621028332247299], [-3.205823273432813, -7.017178298284918]]}, "output": {"x": 1.260557711897646, "y": -3.167475174129605}}, {"input": {"line1": [[-4.198152143646563, -8.7937698381894], [4.18915421505876, 2.0055645322354536]], "line2": [[6.604775292150677, 5.770384661377486], [-9.650082348943723, 4.092604966532923]]}, "output": {"x": 7.157403608135636, "y": 5.827425368089777}}, {"input": {"line1": [[-4.437591317149792, -5.534666812673457], [-2.5893808518112493, -3.1220805488907866]], "line2": [[3.517218297221895, 2.9309851321181064], [-3.251997378482912, -5.4682784813340195]]}, "output": {"x": -26.19554594683254, "y": -33.93670405466248}}, {"input": {"line1": [[5.961421447820028, 2.741868496311046], [-2.0944282091571527, 5.4615812350819954]], "line2": [[8.919506034100365, -5.4690784824367045], [-4.020770649750947, -0.4644425694476322]]}, "output": {"x": -137.8457768559527, "y": 51.29221213572918}}, {"input": {"line1": [[2.3655384676544067, -3.3844070551260153], [-1.5922167994657226, -6.274845149549815]], "line2": [[-1.3555549640244635, -5.735035995135307], [8.885064320062405, 0.5878719649132851]]}, "output": {"x": 1.895173117249094, "y": -3.7279254981190313}}, {"input": {"line1": [[-3.2665725161306858, -7.556503415344478], [8.397454713735947, 5.588428581174515]], "line2": [[-3.9342167863362327, -0.3812908929279608], [-7.341000356947227, -1.6071402677417694]]}, "output": {"x": 6.3998162240708725, "y": 3.3371630806072163}}, {"input": {"line1": [[4.976817033513711, -5.934824502093909], [-0.5235061221314901, -7.784175124703667]], "line2": [[-5.104242397530355, 3.3071697930564348], [4.200752492773891, 8.175724266102822]]}, "output": {"x": -72.65469854007517, "y": -32.03654390976294}}, {"input": {"line1": [[4.885589298733372, -5.947036103655541], [-5.5643640090846835, 2.8006778434309574]], "line2": [[-5.514076943658752, 3.659218566217886], [-7.561324488685404, -7.2716183896166475]]}, "output": {"x": -5.6598961529244916, "y": 2.8806483315705878}}, {"input": {"line1": [[-6.299690338118791, 6.4009939352668574], [6.140530588958974, 0.93753655139537]], "line2": [[-8.206683576972555, 9.64320706726452], [7.635295119768504, -2.7038810067887287]]}, "output": {"x": -1.1384609380629496, "y": 4.134301322580797}}, {"input": {"line1": [[-8.7973340171601, 6.959506668545863], [0.748027522195418, 9.82239429724451]], "line2": [[-2.388773858984832, 2.345311399996721], [7.973213676100066, -4.9202525688299215]]}, "output": {"x": -8.91787624677065, "y": 6.9233531026002515}}], "error_log": []}
{"context": "Given a set of `n` disks stacked on rod `a`, how many steps are required to move all the disks to rod `b` using rod `c` as an auxiliary rod, following the rules of the Tower of Hanoi puzzle?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of disks to be moved.\n  `a` (str): The source rod from which disks are to be moved.\n  `b` (str): The destination rod to which disks are to be moved.\n  `c` (str): The auxiliary rod used for moving disks.\n\nOutput:\n  `return` (int): The total number of steps required to move `n` disks from rod `a` to rod `b` using rod `c`.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ncount = 0\n\ndef mov(n, a, b, c):\n    global count\n    if n <= 0:\n        return\n    if n == 1:\n        count += 1 \n    else:\n        mov(n-1, a, c, b)\n        mov(1, a, b, c)\n        mov(n-1, c, b, a)\n\n# main function\ndef main_solution(n, a, b, c):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    global count\n    count = 0\n    mov(n, a, b, c)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)\n    a = random.choice(['A', 'B', 'C'])\n    b = random.choice(['A', 'B', 'C'])\n    while b == a:\n        b = random.choice(['A', 'B', 'C'])\n    c = random.choice(['A', 'B', 'C'])\n    while c == a or c == b:\n        c = random.choice(['A', 'B', 'C'])\n    return {'n': n, 'a': a, 'b': b, 'c': c}", "io_pairs": [{"input": {"n": 1, "a": "B", "b": "A", "c": "C"}, "output": 1}, {"input": {"n": 8, "a": "B", "b": "C", "c": "A"}, "output": 255}, {"input": {"n": 4, "a": "B", "b": "C", "c": "A"}, "output": 15}, {"input": {"n": 4, "a": "A", "b": "B", "c": "C"}, "output": 15}, {"input": {"n": 9, "a": "A", "b": "C", "c": "B"}, "output": 511}, {"input": {"n": 5, "a": "A", "b": "C", "c": "B"}, "output": 31}, {"input": {"n": 2, "a": "A", "b": "B", "c": "C"}, "output": 3}, {"input": {"n": 3, "a": "A", "b": "C", "c": "B"}, "output": 7}, {"input": {"n": 6, "a": "B", "b": "C", "c": "A"}, "output": 63}, {"input": {"n": 7, "a": "A", "b": "C", "c": "B"}, "output": 127}], "error_log": []}
{"context": "Given a cost function defined by constants `a` and `b`, and initial values for parameters `z`, how would the parameters `z` and the cost function value evolve after running a gradient descent algorithm for a specified number of iterations with a given precision level?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The constant value used in the cost function.\n  `b` (float): The constant value used in the cost function.\n  `initial_z` (list of floats): The initial values for the parameters z, should be a list of two floats.\n  `num_iterations` (int): The number of iterations to run the gradient descent algorithm.\n  `precision` (float): The precision level for convergence check.\n  `NT` (float): The constant value used in the learning rate calculation.\n  `E` (float): The small constant value added to the gradient sums for numerical stability.\n\nOutput:\n  `return` (dict): A dictionary containing the final values of the parameters `z` and the final cost function value.\n    - `final_z` (list of floats): The final values of the parameters z after the gradient descent algorithm.\n    - `final_cost` (float): The final cost function value after the gradient descent algorithm.", "reference_code": "# import necessary packages\nimport numpy as np\nimport math\n\n# all class and function definitions in the code file, if any\ndef cost_function(z, a, b):\n    A = (((a - z[0]) ** 2) + (b * (z[1] - (z[0] ** 2) ** 2)))\n    return A\n\ndef gradient_1(z, a, b):\n    d_f_1 = (2 * z[0] - 2 * a + (4 * b * ((z[0] ** 3) - z[1] * z[0])))\n    return d_f_1\n\ndef gradient_2(z, a, b):\n    d_f_2 = (2 * b * (z[1] - (z[0] ** 2)))\n    return d_f_2\n\ndef descent(d_F, z, alpha):\n    z = z - alpha * d_F\n    return z\n\n# main function\ndef main_solution(a, b, initial_z, num_iterations, precision, NT, E):\n    # Convert JSON serializable inputs to appropriate types\n    z = np.array(initial_z).reshape(2, 1)\n    F = np.zeros((num_iterations, 1))\n    gradient_list_1 = []\n    gradient_list_2 = []\n    P_1 = []\n    P_2 = []\n    alpha = np.zeros((2, 1))\n\n    for i in range(num_iterations):\n        P_1.append(z.item(0))\n        P_2.append(z.item(1))\n        F[i] = cost_function(z, a, b)\n        if i > 0 and abs(float(F[i] - F[i - 1])) <= float(precision):\n            break\n        d_f = np.zeros((2, 1))\n        d_f[0] = gradient_1(z, a, b)\n        d_f[1] = gradient_2(z, a, b)\n        gradient_list_1.append((d_f.item(0) ** 2))\n        gradient_list_2.append((d_f.item(1) ** 2))\n        G1 = sum(gradient_list_1)\n        G2 = sum(gradient_list_2)\n        alpha[0] = NT / (math.sqrt(E + G1))\n        alpha[1] = NT / (math.sqrt(E + G2))\n        z = descent(d_f, z, alpha)\n\n    # Convert output to JSON serializable format\n    final_z = z.flatten().tolist()\n    final_cost = F[i].item()\n    return {\"final_z\": final_z, \"final_cost\": final_cost}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    a = random.uniform(0.1, 10.0)\n    b = random.uniform(0.1, 10.0)\n    initial_z = [random.uniform(-5.0, 5.0), random.uniform(-5.0, 5.0)]\n    num_iterations = random.randint(100, 1000)\n    precision = random.uniform(1e-6, 1e-4)\n    NT = random.uniform(0.01, 0.1)\n    E = random.uniform(1e-8, 1e-6)\n    return {\n        \"a\": a,\n        \"b\": b,\n        \"initial_z\": initial_z,\n        \"num_iterations\": num_iterations,\n        \"precision\": precision,\n        \"NT\": NT,\n        \"E\": E\n    }", "io_pairs": [{"input": {"a": 5.275109147379733, "b": 7.330016798013033, "initial_z": [3.252690669429443, -2.812988605460589], "num_iterations": 868, "precision": 4.8282675283198164e-05, "NT": 0.057780261871801165, "E": 4.1957697143321264e-07}, "output": {"final_z": [1.3627558355561826, -0.46877370651846856], "final_cost": -13.457620489080364}}, {"input": {"a": 6.50111250684871, "b": 0.29608125223118315, "initial_z": [1.7947551982440721, -1.1087404533045833], "num_iterations": 760, "precision": 9.316314069264657e-05, "NT": 0.05298561113768062, "E": 4.1376853219471683e-07}, "output": {"final_z": [2.2080900680968774, 1.593633483017135], "final_cost": 11.868476016138906}}, {"input": {"a": 6.723488382420063, "b": 4.562079058533208, "initial_z": [0.11388201725170433, 1.821132390444527], "num_iterations": 115, "precision": 4.705810271608107e-05, "NT": 0.046777641620642976, "E": 4.136857405656181e-07}, "output": {"final_z": [1.0300768019593596, 1.1769741772794953], "final_cost": 32.74293054941215}}, {"input": {"a": 0.7434936674733466, "b": 6.303058048282204, "initial_z": [-1.2069754640511632, -0.8187080222927179], "num_iterations": 510, "precision": 8.096899199900474e-05, "NT": 0.03957962716747596, "E": 5.893601781022704e-07}, "output": {"final_z": [-0.38481134745345424, 0.08791554999375085], "final_cost": 1.6881540107863713}}, {"input": {"a": 7.078179609665753, "b": 7.899547419259613, "initial_z": [-2.4553673978407287, 4.346893229111558], "num_iterations": 216, "precision": 6.824731202354013e-05, "NT": 0.021684368267490907, "E": 5.57235015292299e-07}, "output": {"final_z": [-2.111240016301279, 4.587551236913297], "final_cost": -36.345997279154574}}, {"input": {"a": 9.26433582099348, "b": 4.727092045690109, "initial_z": [2.3853001979293875, -2.425741159239394], "num_iterations": 755, "precision": 2.1667255382589724e-05, "NT": 0.059285265738315406, "E": 6.002915307038766e-07}, "output": {"final_z": [0.955438490931561, -0.28677199035694784], "final_cost": 63.733462659772485}}, {"input": {"a": 0.7506280429070699, "b": 3.6179638258802393, "initial_z": [-3.5793100267590727, -4.352674035243864], "num_iterations": 437, "precision": 5.242133295460343e-05, "NT": 0.03761025127861768, "E": 4.296714685705799e-07}, "output": {"final_z": [-2.353155756946386, -3.020205617066139], "final_cost": -112.44194274857274}}, {"input": {"a": 6.2572831264508455, "b": 2.7737210867363715, "initial_z": [2.4422962296422863, -3.641438486699804], "num_iterations": 190, "precision": 4.9601153306877916e-05, "NT": 0.09990866648695597, "E": 3.1007069473765643e-07}, "output": {"final_z": [0.9674494863558155, -1.6480163990094792], "final_cost": 20.933512273125302}}, {"input": {"a": 8.543147308561723, "b": 4.653757759162262, "initial_z": [2.438573584233165, 4.572139800849973], "num_iterations": 233, "precision": 6.624910167789921e-05, "NT": 0.08134741730900877, "E": 5.768589034087467e-07}, "output": {"final_z": [2.5498150651598035, 6.263258199057031], "final_cost": -131.3880128189253}}, {"input": {"a": 5.752300731735439, "b": 2.7826193556592274, "initial_z": [-2.7675641131710194, 1.930110280083249], "num_iterations": 813, "precision": 7.440258560281995e-05, "NT": 0.09083928290645843, "E": 4.566456158951202e-08}, "output": {"final_z": [-1.2291438136582604, 2.0372941035994256], "final_cost": 48.058253084672764}}], "error_log": []}
{"context": "Given a digital circuit described by a series of operations, where each operation defines a gate and its inputs, how can we represent the circuit as a Boolean satisfiability (SAT) problem, and what is the maximum input vertex number plus one?\n\nThe input and output requirements are as follows:\n\nInput:\n  `operations` (list of strings): A list of strings where each string represents a line of operations in the circuit description. Each string should follow the format of the original code file, such as `\"INPUT(v)\"`, `\"OUTPUT(v)\"`, or `\"gate=operation(a,b)\"`.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `\"sat_result\"` (list of lists of integers): A list of clauses where each clause is a list of integers representing the SAT problem.\n    - `\"max_input_vertex\"` (integer): The maximum input vertex number plus one.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nvertexes_match = {}\nvertex_counter = 1\nsat = []\ninput_vertexes = []\n\ndef add_vertex(v, is_input=False):\n    global vertex_counter\n    global vertexes_match\n    if v in vertexes_match.keys():\n        return vertexes_match[v]\n    vertexes_match[v] = vertex_counter\n    if is_input:\n        input_vertexes.append(vertex_counter)\n    vertex_counter += 1\n    return vertexes_match[v]\n\ndef create_new_vertex():\n    global vertex_counter\n    vertex_counter += 1\n    return vertex_counter - 1\n\ndef sat_add_and(g, h1, h2):\n    sat.extend([[-g, h1], [-g, h2], [g, -h1, -h2]])\n\ndef sat_add_or(g, h1, h2):\n    sat.extend([[g, -h1], [g, -h2], [-g, h1, h2]])\n\ndef sat_add_not(g, h):\n    sat.extend([[g, h], [-g, -h]])\n\ndef sat_add_id(g, h):\n    sat.extend([[g, -h], [-g, h]])\n\ndef parse_operation(line):\n    gate, operation = line.replace(' ', '').split('=')\n    g = add_vertex(gate)\n    if operation.startswith('AND'):\n        a, b = operation[4:-1].split(',')\n        h1, h2 = add_vertex(a), add_vertex(b)\n        sat_add_and(g, h1, h2)\n    elif operation.startswith('OR'):\n        a, b = operation[3:-1].split(',')\n        h1, h2 = add_vertex(a), add_vertex(b)\n        sat_add_or(g, h1, h2)\n    elif operation.startswith('NOT'):\n        a = operation[4:-1]\n        h = add_vertex(a)\n        sat_add_not(g, h)\n    elif operation.startswith('NAND'):\n        a, b = operation[5:-1].split(',')\n        h1, h2 = add_vertex(a), add_vertex(b)\n        g1 = create_new_vertex()\n        sat_add_and(g1, h1, h2)\n        sat_add_not(g, g1)\n    elif operation.startswith('NOR'):\n        a, b = operation[4:-1].split(',')\n        h1, h2 = add_vertex(a), add_vertex(b)\n        g1 = create_new_vertex()\n        sat_add_or(g1, h1, h2)\n        sat_add_not(g, g1)\n    elif operation.startswith('NXOR'):\n        a, b = operation[5:-1].split(',')\n        h1, h2 = add_vertex(a), add_vertex(b)\n        g1 = create_new_vertex()\n        sat_add_and(g1, h1, h2)\n        g2 = create_new_vertex()\n        sat_add_not(g2, h1)\n        g3 = create_new_vertex()\n        sat_add_not(g3, h2)\n        g4 = create_new_vertex()\n        sat_add_and(g4, g2, g3)\n        sat_add_or(g, g1, g4)\n    elif operation.startswith('XOR'):\n        a, b = operation[4:-1].split(',')\n        h1, h2 = add_vertex(a), add_vertex(b)\n        g1 = create_new_vertex()\n        sat_add_not(g1, h1)\n        g2 = create_new_vertex()\n        sat_add_not(g2, h2)\n        g3 = create_new_vertex()\n        sat_add_and(g3, g1, h2)\n        g4 = create_new_vertex()\n        sat_add_and(g4, h1, g2)\n        sat_add_or(g, g3, g4)\n    elif operation.startswith('DFF') or operation.startswith('BUFF'):\n        a = operation[4:-1]\n        h = add_vertex(a)\n        sat_add_id(g, h)\n\ndef parse_line(line):\n    if line.isspace() or line == '':\n        return\n    if line.startswith('#'):\n        return\n    if line.startswith('INPUT('):\n        add_vertex(line[6:-1], is_input=True)\n        return\n    if line.startswith('OUTPUT('):\n        sat.append([add_vertex(line[7:-1])])\n        return\n    parse_operation(line)\n\n# main function\ndef main_solution(operations):\n    global vertex_counter\n    global vertexes_match\n    global sat\n    global input_vertexes\n    \n    vertex_counter = 1\n    vertexes_match = {}\n    sat = []\n    input_vertexes = []\n    \n    for line in operations:\n        parse_line(line)\n    \n    # Convert the final SAT result to a JSON serializable format\n    sat_result = [[int(x) for x in clause] for clause in sat]\n    \n    return {\n        \"sat_result\": sat_result,\n        \"max_input_vertex\": max(input_vertexes) + 1\n    }", "input_generator": "import random\n\ndef input_generator():\n    operations = []\n    num_gates = random.randint(5, 15)\n    input_vars = [f\"i_{i}\" for i in range(random.randint(2, 5))]\n    output_vars = [f\"o_{i}\" for i in range(random.randint(1, 3))]\n    gate_types = ['AND', 'OR', 'NOT', 'NAND', 'NOR', 'XOR', 'NXOR', 'BUFF']\n    \n    # Add INPUT declarations\n    for var in input_vars:\n        operations.append(f\"INPUT({var})\")\n    \n    # Generate gates\n    used_vars = input_vars.copy()\n    for _ in range(num_gates):\n        gate_name = f\"g_{random.randint(1, 100)}\"\n        gate_type = random.choice(gate_types)\n        \n        if gate_type == 'NOT':\n            a = random.choice(used_vars)\n            operations.append(f\"{gate_name} = {gate_type}({a})\")\n        elif gate_type in ['AND', 'OR', 'NAND', 'NOR', 'XOR', 'NXOR']:\n            a, b = random.sample(used_vars, 2)\n            operations.append(f\"{gate_name} = {gate_type}({a},{b})\")\n        elif gate_type == 'BUFF':\n            a = random.choice(used_vars)\n            operations.append(f\"{gate_name} = {gate_type}({a})\")\n        \n        used_vars.append(gate_name)\n    \n    # Add OUTPUT declarations\n    for var in output_vars:\n        operations.append(f\"OUTPUT({random.choice(used_vars)})\")\n    \n    return {\"operations\": operations}", "io_pairs": [], "error_log": []}
{"context": "Given a classic puzzle of moving disks from one pillar to another using an auxiliary pillar, how many steps are required to move `n` disks from the source pillar `plfrom` to the destination pillar `plto` using the auxiliary pillar `pltmp`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of disks to be moved.\n  `plfrom` (str): The name of the source pillar (e.g., 'A').\n  `pltmp` (str): The name of the auxiliary pillar (e.g., 'B').\n  `plto` (str): The name of the destination pillar (e.g., 'C').\n\nOutput:\n  `return` (int): The total number of steps required to move `n` disks from `plfrom` to `plto` using `pltmp` as the auxiliary pillar.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef hanoi(number, plfrom, pltmp, plto):\n    i = 0\n    if number > 0:\n        i = hanoi(number - 1, plfrom, plto, pltmp)\n        i += 1\n        i += hanoi(number - 1, pltmp, plfrom, plto)\n    return i\n\n# main function\ndef main_solution(n, plfrom, pltmp, plto):\n    # Convert JSON serializable inputs to the original input variables\n    number = int(n)\n    plfrom = str(plfrom)\n    pltmp = str(pltmp)\n    plto = str(plto)\n    \n    # Call the original function\n    steps = hanoi(number, plfrom, pltmp, plto)\n    \n    # Convert the output to JSON serializable\n    return steps", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Reasonable range for Hanoi problem\n    pegs = ['A', 'B', 'C']\n    random.shuffle(pegs)\n    plfrom, pltmp, plto = pegs\n    return {'n': n, 'plfrom': plfrom, 'pltmp': pltmp, 'plto': plto}", "io_pairs": [{"input": {"n": 6, "plfrom": "A", "pltmp": "B", "plto": "C"}, "output": 63}, {"input": {"n": 6, "plfrom": "B", "pltmp": "C", "plto": "A"}, "output": 63}, {"input": {"n": 9, "plfrom": "B", "pltmp": "A", "plto": "C"}, "output": 511}, {"input": {"n": 4, "plfrom": "B", "pltmp": "A", "plto": "C"}, "output": 15}, {"input": {"n": 1, "plfrom": "B", "pltmp": "C", "plto": "A"}, "output": 1}, {"input": {"n": 9, "plfrom": "A", "pltmp": "C", "plto": "B"}, "output": 511}, {"input": {"n": 10, "plfrom": "B", "pltmp": "C", "plto": "A"}, "output": 1023}, {"input": {"n": 2, "plfrom": "A", "pltmp": "C", "plto": "B"}, "output": 3}, {"input": {"n": 5, "plfrom": "B", "pltmp": "C", "plto": "A"}, "output": 31}, {"input": {"n": 8, "plfrom": "A", "pltmp": "C", "plto": "B"}, "output": 255}], "error_log": []}
{"context": "Given a square matrix of integers, how can we determine if the matrix is singular by calculating its determinant?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of integers): A square matrix represented as a list of lists of integers. Each inner list represents a row in the matrix.\n\nOutput:\n  `return` (integer): The determinant of the input matrix. If the determinant is zero, the matrix is singular.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef mat(arr, i, j):\n    return [row[: j] + row[j+1:] for row in (arr[: i] + arr[i+1:])]\n\ndef check_singular(arr):\n    data = len(arr)\n    if (data == 2):\n        res = arr[0][0]*arr[1][1] - arr[1][0]*arr[0][1]\n        return res\n\n    determinant = 0\n    for i in range(data):\n        val = (-1)**i\n        dt = check_singular(mat(arr, 0, i))\n        determinant += (val*arr[0][i]*dt)\n    return determinant\n\n# main function\ndef main_solution(matrix):\n    # Convert the input matrix to a list of lists if it's not already\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        raise ValueError(\"Input must be a list of lists representing a matrix\")\n    \n    # Check if the matrix is square\n    size = len(matrix)\n    if any(len(row) != size for row in matrix):\n        raise ValueError(\"Input matrix must be square\")\n    \n    # Calculate the determinant to check if the matrix is singular\n    determinant = check_singular(matrix)\n    \n    # Return the determinant as the result\n    return determinant", "input_generator": "import random\n\ndef input_generator():\n    size = random.randint(2, 5)\n    matrix = []\n    for _ in range(size):\n        row = [random.randint(-10, 10) for _ in range(size)]\n        matrix.append(row)\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[6, -2, 6], [3, -10, -10], [1, 7, -10]]}, "output": 1166}, {"input": {"matrix": [[9, -4, -5], [-3, 0, 9], [-9, -2, 1]]}, "output": 444}, {"input": {"matrix": [[-4, -4], [-3, -2]]}, "output": -4}, {"input": {"matrix": [[0, -6], [-7, -9]]}, "output": -42}, {"input": {"matrix": [[3, 7], [3, 0]]}, "output": -21}, {"input": {"matrix": [[-4, 6], [5, -6]]}, "output": -6}, {"input": {"matrix": [[5, 1, -7], [-3, 6, 2], [10, 5, -1]]}, "output": 462}, {"input": {"matrix": [[4, 6], [-6, 3]]}, "output": 48}, {"input": {"matrix": [[6, 3, 9], [5, -4, 5], [-9, -5, 3]]}, "output": -651}, {"input": {"matrix": [[-7, -5], [-4, 8]]}, "output": -76}], "error_log": []}
{"context": "Given a number, how many circular primes are there below this number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `limit` (int): The upper limit (exclusive) for checking circular primes. For example, if `limit` is 100, the function will check for circular primes below 100.\n\nOutput:\n  `return` (int): The count of circular primes below the given `limit`.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    else:\n        i = 3\n        while i <= math.sqrt(n):\n            if n % i == 0:\n                return False\n            i += 2\n        return True\n\ndef is_cyclic_prime(n):\n    str_n = str(n)\n    for index in range(1, len(str_n)):\n        rotated_num = int(str_n[index:] + str_n[:index])\n        if not is_prime(rotated_num):\n            return False\n    return True\n\n# main function\ndef main_solution(limit):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    count = 0\n    for num in range(2, limit):\n        if is_prime(num):\n            if is_cyclic_prime(num):\n                count += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a reasonable limit, ensuring it's not too large or too small\n    # Cyclic primes are rare, so the limit should be chosen to potentially include some\n    # Known cyclic primes under 100 are 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, 97\n    # So setting limits between 10 and 1000 is reasonable\n    limit = random.choice([50, 100, 200, 500, 1000])\n    return {'limit': limit}", "io_pairs": [{"input": {"limit": 500}, "output": 20}, {"input": {"limit": 100}, "output": 13}, {"input": {"limit": 1000}, "output": 25}, {"input": {"limit": 200}, "output": 17}, {"input": {"limit": 50}, "output": 9}], "error_log": []}
{"context": "Imagine you have a series of bulbs that are initially off. You perform a series of operations where you toggle the state of the bulbs in a specific pattern. After completing all the operations, how many bulbs remain on? Specifically, given the number of bulbs `n`, determine the count of bulbs that are still on after `n` rounds of toggling.\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of bulbs. It should be a positive integer.\n\nOutput:\n  `return` (int): The number of bulbs that are on after `n` rounds.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(n):\n    # Convert the input to an integer if it's not already\n    n = int(n)\n    \n    # Calculate the number of bulbs that are on after n rounds\n    # The number of bulbs that are on is equal to the number of perfect squares less than or equal to n\n    result = int(math.sqrt(n))\n    \n    # Return the result as an integer\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random integer n between 1 and 10000\n    n = random.randint(1, 10000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 9122}, "output": 95}, {"input": {"n": 7201}, "output": 84}, {"input": {"n": 6167}, "output": 78}, {"input": {"n": 7197}, "output": 84}, {"input": {"n": 9065}, "output": 95}, {"input": {"n": 7729}, "output": 87}, {"input": {"n": 9949}, "output": 99}, {"input": {"n": 8585}, "output": 92}, {"input": {"n": 4169}, "output": 64}, {"input": {"n": 4807}, "output": 69}], "error_log": []}
{"context": "In a stable marriage problem, there are two sets of parties, A and B, each with their own preferences for the other set. Given the preference lists of both sets, what are the stable matches where no two parties would prefer each other over their current partners?\n\nThe input and output requirements are as follows:\n\nInput:\n  `A_preferences` (list of lists): A list of preference lists for each proposing party (A). Each inner list contains integers representing the preferences of A for the accepting parties (B).\n  `B_preferences` (list of lists): A list of preference lists for each accepting party (B). Each inner list contains integers representing the preferences of B for the proposing parties (A).\n\nOutput:\n  `return` (list of tuples): A list of tuples representing the stable matches. Each tuple contains two integers, the first being the index of the proposing party (A) and the second being the index of the accepting party (B).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass preference_list:\n    def __init__(self, input_list):\n        self.list = input_list\n    \n    def prefers(self, c1, c2):\n        return self.list.index(c1) < self.list.index(c2)\n    \n    def get(self, index):\n        return self.list[index]\n\n    def get_index(self, c):\n        return self.list.index(c)\n\n# main function\ndef main_solution(A_preferences, B_preferences):\n    # Convert JSON serializable inputs to original input variables\n    A = [preference_list(pref) for pref in A_preferences]\n    B = [preference_list(pref) for pref in B_preferences]\n    n = len(A)\n    \n    # the algorithm\n    bookmark = [0 for _ in A]\n    matchA = {}\n    matchB = {}\n    matchA[0] = A[0].get(0)\n    matchB[matchA[0]] = 0\n    bookmark[0] += 1\n    i = 1\n    while i < n:\n        a = i\n        while True:\n            b = A[a].get(bookmark[a])  # b will be proposed to\n            bookmark[a] += 1\n            if b not in matchB:  # if b is not engaged...\n                matchA[a] = b\n                matchB[b] = a\n                break\n            else:\n                a2 = matchB[b]\n                # if a is better than current suitor\n                if B[b].get_index(a) < B[b].get_index(a2):\n                    matchA[a] = b\n                    matchB[b] = a\n                    matchA.pop(a2)\n                    a = a2\n        i += 1\n    out = [(a, matchA[a]) for a in matchA]\n    return out", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(3, 10)  # Reasonable size for stable matching problem\n    candidates = list(range(n))\n    \n    A_preferences = []\n    for _ in range(n):\n        shuffled = candidates.copy()\n        random.shuffle(shuffled)\n        A_preferences.append(shuffled)\n    \n    B_preferences = []\n    for _ in range(n):\n        shuffled = list(range(n))  # B's preferences are over A's indices (0..n-1)\n        random.shuffle(shuffled)\n        B_preferences.append(shuffled)\n    \n    return {'A_preferences': A_preferences, 'B_preferences': B_preferences}", "io_pairs": [], "error_log": []}
{"context": "Given a sequence of integers, what is the sum of the distances between consecutive integers in the sequence? For example, in the sequence [1, 7, 2, 11, 8, 34, 3], the distance between 1 and 2 is 2, between 2 and 3 is 4, and between 7 and 8 is 3. What is the total sum of these distances for a given sequence of integers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `integers` (list of int): A list of integers for which the consecutive distance rating needs to be calculated.\n\nOutput:\n  `return` (int): The consecutive distance rating of the input list of integers.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(integers):\n    # Convert the input list to a JSON serializable format\n    integers = list(integers)\n    \n    # Calculate the consecutive distance rating\n    count = 0\n    for i in integers:\n        if i + 1 in integers:\n            count += abs(integers.index(i) - integers.index(i + 1))\n    \n    # Return the result as a JSON serializable output\n    return count", "input_generator": "import random\n\ndef input_generator():\n    length = random.randint(5, 20)\n    integers = random.sample(range(1, 100), length)\n    return {'integers': integers}", "io_pairs": [{"input": {"integers": [56, 33, 24, 31, 75, 98, 97, 74, 81, 52]}, "output": 4}, {"input": {"integers": [21, 39, 81, 48, 32, 88, 7]}, "output": 0}, {"input": {"integers": [75, 38, 5, 78, 79, 88, 80, 48, 63, 91, 26, 18, 12, 50, 82, 97, 35]}, "output": 3}, {"input": {"integers": [51, 57, 58, 66, 75, 20]}, "output": 1}, {"input": {"integers": [66, 56, 23, 88, 53, 41, 62, 84, 57, 47]}, "output": 7}, {"input": {"integers": [1, 34, 76, 26, 64, 67, 72, 95, 79, 25, 90, 98, 70, 28, 46, 73]}, "output": 15}, {"input": {"integers": [26, 25, 71, 40, 84, 83, 32, 68]}, "output": 2}, {"input": {"integers": [99, 7, 19, 80, 61, 62, 13, 1, 98, 25, 51, 38, 28, 71, 65]}, "output": 9}, {"input": {"integers": [85, 51, 99, 29, 87, 47, 89, 81, 98, 25, 41, 38, 42, 96]}, "output": 8}, {"input": {"integers": [48, 53, 70, 71, 77, 3, 66, 94, 86, 90, 51, 54, 78]}, "output": 19}], "error_log": []}
{"context": "In a 25x25 grid, Picobot is a simple robot that navigates based on a set of rules. Given an initial position for Picobot and a number of steps it will take, what is the average fitness of the Picobot program over a specified number of trials? The fitness is defined as the fraction of cells in the grid that Picobot has visited.\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_row` (int): The initial row position of Picobot within the 25x25 grid.\n  `initial_col` (int): The initial column position of Picobot within the 25x25 grid.\n  `steps` (int): The number of steps Picobot will take during the simulation.\n  `trials` (int): The number of trials to run to evaluate the fitness of the Picobot program.\n\nOutput:\n  `return` (dict): A dictionary containing the key `fitness` with a float value representing the average fitness of the Picobot program over the specified number of trials.", "reference_code": "# import necessary packages\nimport random\nimport operator\n\n# Constants\nHEIGHT = 25\nWIDTH = 25\nNUMSTATES = 5\n\n# all class and function definitions in the code file, if any\nclass Program:\n    def __init__(self):\n        self.rules = {}\n\n    def randomize(self):\n        Moves = ('N', 'S', 'W', 'E')\n        surrounding = ('xxxx', 'Nxxx', 'NExx', 'NxWx', 'xxxS', 'xExS', 'xxWS', 'xExx', 'xxWx')\n        for state in range(5):\n            for pattern in surrounding:\n                movedir = random.choice(Moves)\n                while movedir in pattern:\n                    movedir = random.choice(Moves)\n                self.rules[(state, pattern)] = (movedir, random.randint(0, 4))\n\n    def getMove(self, state, surrounding):\n        return self.rules[(state, surrounding)]\n\nclass World:\n    def __init__(self, initial_row, initial_col, program):\n        self.prow = initial_row\n        self.pcol = initial_col\n        self.state = 0\n        self.prog = program\n        self.room = [ [' ']*WIDTH for row in range(HEIGHT) ]\n        for col in range(WIDTH):\n            self.room[0][col] = '-'\n        for col in range(WIDTH):\n            self.room[HEIGHT-1][col] = '-' \n        for row in range(HEIGHT):\n            self.room[row][0] = '|'\n        for row in range(HEIGHT-1):\n            self.room[row][WIDTH -1] = '|'\n        self.room[0][0] = '+'\n        self.room[0][WIDTH-1] = '+'\n        self.room[HEIGHT-1][0] = '+'\n        self.room[HEIGHT-1][WIDTH-1] = '+'\n        self.room[self.prow][self.pcol] = 'P'\n\n    def getCurrentSurroundings(self):\n        state = ''\n        if self.prow == 1:\n            state += 'N'\n        else:\n            state += 'x'\n        if self.pcol == WIDTH - 2:\n            state += 'E'\n        else:\n            state += 'x'\n        if self.pcol == 1:\n            state += 'W'\n        else:\n            state += 'x'\n        if self.prow == HEIGHT - 2:\n            state += 'S'\n        else:\n            state += 'x'\n        return state\n    \n    def step(self):\n        current_surrounding = self.getCurrentSurroundings()\n        NEW = self.prog.getMove(self.state,current_surrounding)\n        nextMove = NEW[0]\n        nextState = NEW[1]\n        self.room[self.prow][self.pcol] = 'o'\n        self.state = nextState\n        if nextMove == 'N':\n            self.prow -= 1\n        elif nextMove == 'S':\n            self.prow += 1\n        elif nextMove == 'W':\n            self.pcol -= 1\n        else:\n            self.pcol += 1\n        self.room[self.prow][self.pcol] = 'P'\n    \n    def run(self, steps):\n        for turn in range(steps):\n            self.step()\n    \n    def fractionVisitedCells(self):\n        cellsVisited = 0\n        cellsTotal = 23*23\n        for col in range(WIDTH):\n            for row in range(HEIGHT):\n                if self.room[row][col] == 'o' or self.room[row][col] == 'P':\n                    cellsVisited += 1\n        return cellsVisited/cellsTotal\n\ndef evaluateFitness(program, trials, steps):\n    totalFitness = 0\n    for x in range(trials):\n        row = random.randint(1,23)\n        col = random.randint(1,23)\n        picobot = World(row, col, program)\n        picobot.run(steps)\n        totalFitness += picobot.fractionVisitedCells()\n    return totalFitness/trials\n\n# main function\ndef main_solution(initial_row, initial_col, steps, trials):\n    # Convert JSON serializable inputs to original input variables\n    initial_row = int(initial_row)\n    initial_col = int(initial_col)\n    steps = int(steps)\n    trials = int(trials)\n\n    # Create a random program\n    program = Program()\n    program.randomize()\n\n    # Evaluate the fitness of the program\n    fitness = evaluateFitness(program, trials, steps)\n\n    # Return the fitness as a JSON serializable output\n    return {\"fitness\": fitness}", "input_generator": "import random\n\ndef input_generator():\n    initial_row = random.randint(1, 23)\n    initial_col = random.randint(1, 23)\n    steps = random.randint(50, 200)\n    trials = random.randint(5, 20)\n    return {\n        \"initial_row\": initial_row,\n        \"initial_col\": initial_col,\n        \"steps\": steps,\n        \"trials\": trials\n    }", "io_pairs": [{"input": {"initial_row": 20, "initial_col": 18, "steps": 152, "trials": 9}, "output": {"fitness": 0.06490233144297415}}, {"input": {"initial_row": 11, "initial_col": 13, "steps": 160, "trials": 16}, "output": {"fitness": 0.05718336483931949}}, {"input": {"initial_row": 5, "initial_col": 11, "steps": 53, "trials": 20}, "output": {"fitness": 0.06578449905482041}}, {"input": {"initial_row": 6, "initial_col": 18, "steps": 52, "trials": 17}, "output": {"fitness": 0.04714778160791727}}, {"input": {"initial_row": 17, "initial_col": 16, "steps": 132, "trials": 17}, "output": {"fitness": 0.026909818747915044}}, {"input": {"initial_row": 23, "initial_col": 6, "steps": 102, "trials": 16}, "output": {"fitness": 0.0392249527410208}}, {"input": {"initial_row": 10, "initial_col": 3, "steps": 166, "trials": 17}, "output": {"fitness": 0.04948293116868676}}, {"input": {"initial_row": 8, "initial_col": 12, "steps": 100, "trials": 20}, "output": {"fitness": 0.017958412098298675}}, {"input": {"initial_row": 15, "initial_col": 16, "steps": 98, "trials": 9}, "output": {"fitness": 0.05881117412308338}}, {"input": {"initial_row": 8, "initial_col": 9, "steps": 92, "trials": 13}, "output": {"fitness": 0.03155445688526974}}], "error_log": []}
{"context": "Given a Markov chain with a transition probability matrix that depends on a temperature parameter \\( T \\), what is the probability distribution of the states after the transition matrix is raised to a certain power? The transition matrix is defined such that the probabilities of moving between states depend on the temperature \\( T \\). The problem requires determining the probability distribution of the states after the matrix is raised to a specified power \\( \\text{power} \\).\n\nThe input and output requirements are as follows:\n\nInput:\n  `T` (float): The temperature parameter for the transition probability matrix.\n  `power` (int): The power to which the transition probability matrix should be raised.\n\nOutput:\n  `return` (list of float): A list representing the probability distribution of states after raising the transition probability matrix to the specified power. The list contains four float values corresponding to the probabilities of being in states 1, 2, 3, and 4 respectively.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef cost(x1, x2):\n    return 2 * np.power((x1 - x2), 2) + x1\n\ndef transProb(T):\n    p21 = 0.5 * np.exp(-1 / T)\n    p24 = 0.5 * np.exp(-2 / T)\n    p22 = 1 - p21 - p24\n    p31 = 0.5 * np.exp(-2 / T)\n    p34 = 0.5 * np.exp(-3 / T)\n    p33 = 1 - p31 - p34\n    P = np.matrix([[0, 0.5, 0.5, 0], [p21, p22, 0, p24], [p31, 0, p33, p34], [0, 0.5, 0.5, 0]])\n    return P\n\ndef matPower(matrix, power):\n    sol = matrix\n    for i in range(1, power):\n        sol = np.matmul(sol, matrix)\n    return sol\n\n# main function\ndef main_solution(T, power):\n    # Convert input to float for precision\n    T = float(T)\n    power = int(power)\n    \n    # Generate transition probability matrix\n    P = transProb(T)\n    \n    # Calculate the power of the matrix\n    P_power = matPower(P, power)\n    \n    # Extract the probability distribution from the resulting matrix\n    probability_distribution = P_power[0, :].tolist()[0]\n    \n    # Return the probability distribution as a list of floats\n    return probability_distribution", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    T = random.uniform(0.1, 10.0)\n    power = random.randint(1, 20)\n    return {'T': T, 'power': power}", "io_pairs": [{"input": {"T": 2.1678835888552563, "power": 10}, "output": [0.17460488536644783, 0.2771433389732478, 0.43816749697236446, 0.11008427868794006]}, {"input": {"T": 9.266538997728636, "power": 12}, "output": [0.2583700606706614, 0.23896213365687802, 0.27072803122159034, 0.2319397744508701]}, {"input": {"T": 3.2635516024557116, "power": 19}, "output": [0.2024116048579293, 0.2750000431266201, 0.3735969456663851, 0.14899140634906555]}, {"input": {"T": 6.153070542136675, "power": 10}, "output": [0.24024172157348855, 0.2535060000667578, 0.30204713237379405, 0.20420514598595974]}, {"input": {"T": 9.814264101841143, "power": 20}, "output": [0.24142662754101055, 0.25603687828442373, 0.28449767914288526, 0.21803881503168046]}, {"input": {"T": 0.5904912725702733, "power": 5}, "output": [0.04683394841253148, 0.39539942148343166, 0.5491550897768523, 0.008611540327184461]}, {"input": {"T": 6.292060813556366, "power": 7}, "output": [0.19116023572580995, 0.301877815321399, 0.34389162128722783, 0.1630703276655632]}, {"input": {"T": 1.2644355835893202, "power": 6}, "output": [0.12231832344757253, 0.29461136527735754, 0.5276048696630349, 0.055465441612034816]}, {"input": {"T": 7.725310633257184, "power": 19}, "output": [0.22938373929122957, 0.26642173545944836, 0.30266181831619704, 0.20153270693312506]}, {"input": {"T": 8.29640669576213, "power": 2}, "output": [0.4180587168551251, 0.0819412831448749, 0.129413167397244, 0.37058683260275604]}], "error_log": []}
{"context": "In a high-dimensional cellular automaton simulation, a set of initial active cells in a 2D grid evolves over a specified number of generations. Each cell can be in an active or inactive state, and the state of each cell in the next generation depends on the number of its active neighbors. Given the initial active cells, the number of dimensions, and the number of generations, how many active cells will there be after the specified number of generations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_cells` (list of tuples): A list of tuples representing the initial active cells in a 2D grid. Each tuple contains two integers representing the coordinates of an active cell.\n  `dimensions` (int): An integer representing the number of dimensions for the simulation (e.g., 3 for 3D, 4 for 4D).\n  `generations` (int): An integer representing the number of generations to simulate.\n\nOutput:\n  `return` (int): An integer representing the number of active cells after the specified number of generations.", "reference_code": "# import necessary packages\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\ndef get_neighbors(cell: tuple) -> set:\n    dims = len(cell)\n    deltas = product(*[[-1, 0, 1]] * dims)\n    res = {tuple(c + d for c, d in zip(cell, delta)) for delta in deltas}\n    res.remove(cell)\n    return res\n\ndef next_gen(cells: set) -> set:\n    nb = {}\n    for c in cells:\n        for n in get_neighbors(c):\n            try:\n                nb[n] += 1\n            except KeyError:\n                nb[n] = 1\n    new_cells = set()\n    for c in nb:\n        active_neighbors = nb[c]\n        if active_neighbors == 3 or (active_neighbors == 2 and c in cells):\n            new_cells.add(c)\n    return new_cells\n\ndef next_gens(cells: set, n: int) -> set:\n    for _ in range(n):\n        cells = next_gen(cells)\n    return cells\n\n# main function\ndef main_solution(initial_cells: list, dimensions: int, generations: int) -> int:\n    # Convert list to set for initial_cells\n    cells = {(x, y) + (0,) * (dimensions - 2) for x, y in initial_cells}\n    final_cells = next_gens(cells, generations)\n    return len(final_cells)", "input_generator": "import random\n\ndef input_generator():\n    dimensions = random.randint(2, 4)\n    generations = random.randint(1, 10)\n    num_cells = random.randint(1, 20)\n    initial_cells = []\n    for _ in range(num_cells):\n        x = random.randint(-10, 10)\n        y = random.randint(-10, 10)\n        initial_cells.append((x, y))\n    return {\n        'initial_cells': initial_cells,\n        'dimensions': dimensions,\n        'generations': generations\n    }", "io_pairs": [{"input": {"initial_cells": [[9, 4], [8, -10], [-5, 0], [-10, -4]], "dimensions": 4, "generations": 1}, "output": 0}, {"input": {"initial_cells": [[-6, -2], [-9, 2], [5, -4], [6, 9]], "dimensions": 3, "generations": 5}, "output": 0}, {"input": {"initial_cells": [[0, 8]], "dimensions": 3, "generations": 2}, "output": 0}, {"input": {"initial_cells": [[2, 9], [6, 0]], "dimensions": 3, "generations": 6}, "output": 0}, {"input": {"initial_cells": [[8, -5]], "dimensions": 3, "generations": 6}, "output": 0}, {"input": {"initial_cells": [[-8, 1], [-3, 5], [-6, 6], [-5, -7]], "dimensions": 2, "generations": 6}, "output": 0}, {"input": {"initial_cells": [[-10, 6], [8, -10], [6, -9], [-6, 10]], "dimensions": 4, "generations": 7}, "output": 0}, {"input": {"initial_cells": [[7, -6]], "dimensions": 2, "generations": 9}, "output": 0}, {"input": {"initial_cells": [[7, 5]], "dimensions": 3, "generations": 8}, "output": 0}, {"input": {"initial_cells": [[6, 2], [10, -2]], "dimensions": 2, "generations": 2}, "output": 0}], "error_log": []}
{"context": "In a scenario where missionaries and cannibals need to cross a river using a boat that can hold up to two people, how can we determine the sequence of moves required to safely transport all missionaries and cannibals from the left side of the river to the right side without ever allowing the cannibals to outnumber the missionaries on either side of the river? Given the initial number of missionaries and cannibals on the left side, what is the list of moves that ensures all reach the right side safely?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_missionaries` (int): The initial number of missionaries on the left side of the river.\n  `initial_cannibals` (int): The initial number of cannibals on the left side of the river.\n\nOutput:\n  `return` (list of tuples): A list of 2-tuples representing the moves required to get all missionaries and cannibals from the left side of the river to the right. Each tuple represents a move with the number of missionaries and cannibals moved in that step. If it is impossible to move the animals over according to the rules of the problem, an empty list is returned.", "reference_code": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass SemanticNetsAgent:\n    def __init__(self):\n        pass\n\n    def solve(self, initial_missionaries, initial_cannibals):\n        class States:\n            def __init__(self, left_missionaries, left_cannibals, right_missionaries, right_cannibals, boat_position):\n                self.left_missionaries = left_missionaries\n                self.left_cannibals = left_cannibals\n                self.right_missionaries = right_missionaries\n                self.right_cannibals = right_cannibals\n                self.boat_position = boat_position\n                self.parent = None\n\n            def __eq__(self, other):\n                return (self.left_missionaries == other.left_missionaries and self.left_cannibals == other.left_cannibals and\n                        self.right_missionaries == other.right_missionaries and self.right_cannibals == other.right_cannibals and\n                        self.boat_position == other.boat_position)\n\n            def goal_state(self):\n                if self.left_missionaries == 0 and self.left_cannibals == 0 and self.right_missionaries == initial_missionaries \\\n                        and self.right_cannibals == initial_cannibals and self.boat_position == \"right\":\n                    return True\n                else:\n                    return False\n\n            def valid_state(self):\n                if (self.left_missionaries != 0 and self.left_cannibals > self.left_missionaries) \\\n                        or (self.right_missionaries != 0 and self.right_cannibals > self.right_missionaries) \\\n                        or self.left_missionaries < 0 or self.left_cannibals < 0 or self.right_missionaries < 0 \\\n                        or self.right_cannibals < 0:\n                    return False\n                else:\n                    return True\n\n        def successors(curr_state):\n            successor = []\n            possible_moves = [(2, 0), (0, 2), (1, 1), (1, 0), (0, 1)]\n            if curr_state.boat_position == \"left\":\n                for move in possible_moves:\n                    new_state = States(curr_state.left_missionaries - move[0], curr_state.left_cannibals - move[1],\n                                       curr_state.right_missionaries + move[0], curr_state.right_cannibals + move[1], \"right\")\n                    if new_state.valid_state():\n                        successor.append(new_state)\n                        new_state.parent = curr_state\n            else:\n                for move in possible_moves:\n                    new_state = States(curr_state.left_missionaries + move[0], curr_state.left_cannibals + move[1],\n                                       curr_state.right_missionaries - move[0], curr_state.right_cannibals - move[1], \"left\")\n                    if new_state.valid_state():\n                        successor.append(new_state)\n                        new_state.parent = curr_state\n            return successor\n\n        def bfs():\n            initial_state = States(initial_missionaries, initial_cannibals, 0, 0, \"left\")\n            if initial_state.goal_state():\n                return initial_state\n            queue = deque([])\n            explored = []\n            queue.append(initial_state)\n            while queue:\n                node = queue.popleft()\n                if node.goal_state():\n                    return node\n                explored.append(node)\n                node_children = successors(node)\n                for child in node_children:\n                    if (child not in explored) and (child not in queue):\n                        queue.append(child)\n            return None\n\n        def find_moves(result):\n            path = []\n            final_path = []\n            result_parent = result.parent\n            while result_parent:\n                move = (abs(result.left_missionaries - result_parent.left_missionaries),\n                        abs(result.left_cannibals - result_parent.left_cannibals))\n                path.append(move)\n                result = result_parent\n                result_parent = result.parent\n            for i in range(len(path)):\n                final_result = path[len(path) - 1 - i]\n                final_path.append(final_result)\n            return final_path\n\n        solution = bfs()\n        if solution:\n            return find_moves(solution)\n        else:\n            return []\n\n# main function\ndef main_solution(initial_missionaries, initial_cannibals):\n    # Convert JSON serializable inputs to the original input variables\n    agent = SemanticNetsAgent()\n    result = agent.solve(initial_missionaries, initial_cannibals)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate initial_missionaries and initial_cannibals between 1 and 5\n    initial_missionaries = random.randint(1, 5)\n    initial_cannibals = random.randint(1, 5)\n    \n    # Ensure that initial_missionaries >= initial_cannibals to have a solvable problem\n    if initial_missionaries < initial_cannibals:\n        initial_missionaries, initial_cannibals = initial_cannibals, initial_missionaries\n    \n    return {\n        'initial_missionaries': initial_missionaries,\n        'initial_cannibals': initial_cannibals\n    }", "io_pairs": [{"input": {"initial_missionaries": 3, "initial_cannibals": 2}, "output": [[0, 2], [0, 1], [2, 0], [1, 0], [2, 0], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 4, "initial_cannibals": 3}, "output": [[0, 2], [0, 1], [2, 0], [1, 0], [1, 1], [0, 1], [2, 0], [0, 1], [0, 2], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 1, "initial_cannibals": 1}, "output": [[1, 1]]}, {"input": {"initial_missionaries": 2, "initial_cannibals": 1}, "output": [[2, 0], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 2, "initial_cannibals": 2}, "output": [[0, 2], [0, 1], [2, 0], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 5, "initial_cannibals": 5}, "output": []}, {"input": {"initial_missionaries": 4, "initial_cannibals": 1}, "output": [[2, 0], [1, 0], [2, 0], [1, 0], [2, 0], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 5, "initial_cannibals": 3}, "output": [[2, 0], [1, 0], [1, 1], [1, 0], [2, 0], [1, 0], [1, 1], [1, 0], [2, 0], [1, 0], [2, 0], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 3, "initial_cannibals": 1}, "output": [[2, 0], [1, 0], [2, 0], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 3, "initial_cannibals": 3}, "output": [[0, 2], [0, 1], [0, 2], [0, 1], [2, 0], [1, 1], [2, 0], [0, 1], [0, 2], [1, 0], [1, 1]]}], "error_log": []}
{"context": "Given a standard 8x8 chessboard, two queens are placed at random positions. Can the first queen attack the second queen?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_size` (int): The size of the chessboard (e.g., 8 for an 8x8 board).\n  `queen1_row` (int): The row index (0-based) where the first queen is placed.\n  `queen1_col` (int): The column index (0-based) where the first queen is placed.\n  `queen2_row` (int): The row index (0-based) where the second queen is placed.\n  `queen2_col` (int): The column index (0-based) where the second queen is placed.\n\nOutput:\n  `return` (bool): `True` if the two queens can attack each other, `False` otherwise.", "reference_code": "# import necessary packages\nfrom typing import List\nfrom random import randint\n\n# all class and function definitions in the code file, if any\ndef create_board(size: int) -> List[List[int]]:\n    board = []\n    for i in range(size):\n        row = []\n        for j in range(size):\n            row.append(0)\n        board.append(row)\n    return board\n\ndef add_random_queen(chess_board: List[List[int]]) -> List[List[int]]:\n    random_indexes = (randint(0, len(chess_board) - 1), randint(0, len(chess_board) - 1))\n    if chess_board[random_indexes[0]][random_indexes[1]] == 1:\n        return add_random_queen(chess_board)\n    chess_board[random_indexes[0]][random_indexes[1]] = 1\n    return chess_board\n\ndef number_of_queens(board: List[List[int]]) -> int:\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 1:\n                count += 1\n    return count\n\ndef isOutsideBorder(board: List[List[int]], row: int, col: int) -> bool:\n    if row < 0 or row >= len(board):\n        return True\n    if col < 0 or col >= len(board[0]):\n        return True\n    return False\n\ndef first_queen(board: List[List[int]]) -> List[int]:\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 1:\n                return [i, j]\n    return [-1, -1]\n\ndef queens(board: List[List[int]]) -> bool:\n    if len(board) != 8:\n        return False\n    for i in range(len(board)):\n        if len(board[i]) != 8:\n            return False\n    if number_of_queens(board) != 2:\n        return False\n    \n    first_queen_pos = first_queen(board)\n    first_queen_row = first_queen_pos[0]\n    first_queen_col = first_queen_pos[1]\n\n    for j in range(len(board[first_queen_row])):\n        if board[first_queen_row][j] == 1 and j != first_queen_col:\n            return True\n\n    for i in range(len(board)):\n        if board[i][first_queen_col] == 1 and i != first_queen_row:\n            return True\n\n    diagonal_map = [[-1, -1], [-1, +1], [+1, -1], [+1, +1]]\n    for i in range(len(diagonal_map)):\n        move_row = diagonal_map[i][0]\n        move_col = diagonal_map[i][1]\n        row = first_queen_row\n        col = first_queen_col\n        while True:\n            row = row + move_row\n            col = col + move_col\n            if isOutsideBorder(board, row, col):\n                break\n            if board[row][col] == 1:\n                return True\n\n    return False\n\n# main function\ndef main_solution(board_size: int, queen1_row: int, queen1_col: int, queen2_row: int, queen2_col: int) -> bool:\n    # Create the board\n    board = create_board(board_size)\n    \n    # Place the queens on the board\n    board[queen1_row][queen1_col] = 1\n    board[queen2_row][queen2_col] = 1\n    \n    # Check if the queens can attack each other\n    return queens(board)", "input_generator": "import random\nfrom typing import Dict\n\ndef input_generator() -> Dict:\n    board_size = 8\n    queen1_row = random.randint(0, board_size - 1)\n    queen1_col = random.randint(0, board_size - 1)\n    \n    queen2_row = random.randint(0, board_size - 1)\n    queen2_col = random.randint(0, board_size - 1)\n    while (queen2_row == queen1_row and queen2_col == queen1_col):\n        queen2_row = random.randint(0, board_size - 1)\n        queen2_col = random.randint(0, board_size - 1)\n    \n    return {\n        'board_size': board_size,\n        'queen1_row': queen1_row,\n        'queen1_col': queen1_col,\n        'queen2_row': queen2_row,\n        'queen2_col': queen2_col\n    }", "io_pairs": [{"input": {"board_size": 8, "queen1_row": 4, "queen1_col": 7, "queen2_row": 2, "queen2_col": 6}, "output": false}, {"input": {"board_size": 8, "queen1_row": 0, "queen1_col": 0, "queen2_row": 4, "queen2_col": 7}, "output": false}, {"input": {"board_size": 8, "queen1_row": 7, "queen1_col": 7, "queen2_row": 1, "queen2_col": 3}, "output": false}, {"input": {"board_size": 8, "queen1_row": 0, "queen1_col": 5, "queen2_row": 4, "queen2_col": 2}, "output": false}, {"input": {"board_size": 8, "queen1_row": 1, "queen1_col": 5, "queen2_row": 0, "queen2_col": 7}, "output": false}, {"input": {"board_size": 8, "queen1_row": 5, "queen1_col": 4, "queen2_row": 4, "queen2_col": 2}, "output": false}, {"input": {"board_size": 8, "queen1_row": 3, "queen1_col": 0, "queen2_row": 6, "queen2_col": 2}, "output": false}, {"input": {"board_size": 8, "queen1_row": 2, "queen1_col": 3, "queen2_row": 5, "queen2_col": 0}, "output": true}, {"input": {"board_size": 8, "queen1_row": 5, "queen1_col": 3, "queen2_row": 4, "queen2_col": 0}, "output": false}, {"input": {"board_size": 8, "queen1_row": 4, "queen1_col": 1, "queen2_row": 7, "queen2_col": 0}, "output": false}], "error_log": []}
{"context": "Given a positive integer `limit`, find all pairs of amicable numbers `(x, di)` such that both `x` and `di` are less than or equal to `limit`. Amicable numbers are pairs of numbers where the sum of the proper divisors of each number is equal to the other number. What are the pairs of amicable numbers within the given `limit`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `limit` (int): The upper limit for finding amicable numbers. Must be a positive integer.\n\nOutput:\n  `return` (list of tuples): A list of tuples where each tuple contains a pair of amicable numbers. Each tuple is of the form `(x, di)` where `x` and `di` are amicable numbers.", "reference_code": "# import necessary packages\nimport math\nimport collections\n\n# all class and function definitions in the code file, if any\ndef primeFactors2(n, arrayprimos): \n    resta = n\n    factores = []\n    multi = 1\n    i = 0\n    while n != 1 and arrayprimos[i] < math.sqrt(n): \n        while n % arrayprimos[i] == 0:\n            factores.append(arrayprimos[i])\n            n = n / arrayprimos[i]\n        i += 1\n    # Condition if n is a prime \n    # greater than 2\n    if n > 2: \n        factores.append(n)\n    \n    frec = collections.Counter(factores)\n    for valor in frec:\n        multi *= (pow(valor, frec[valor] + 1) - 1) / (valor - 1)\n    return int(multi - resta)\n\ndef primosff(num, pr):\n    div = 0\n    while pr[div] < num:\n        if num % pr[div] == 0:\n            return False\n        else:\n            if pr[div] > math.sqrt(num):\n                return True\n            else:\n                div += 1\n    return True\n\ndef generate_primes(limit):\n    prim = 3\n    arrayprimos = [2, 3]\n    while prim < math.sqrt(limit):\n        prim += 2\n        if primosff(prim, arrayprimos):\n            arrayprimos.append(prim)\n    return arrayprimos\n\n# main function\ndef main_solution(limit):\n    # Generate prime numbers up to the square root of the limit\n    arrayprimos = generate_primes(limit)\n    \n    # Find amicable numbers\n    amicable_numbers = []\n    for x in range(220, limit):\n        if x % 2 == 0 or x % 5 == 0:\n            di = primeFactors2(x, arrayprimos)\n            if di > x and di <= limit:\n                dj = primeFactors2(di, arrayprimos)\n                if dj == x:\n                    amicable_numbers.append((x, di))\n    \n    # Return the list of amicable numbers\n    return amicable_numbers", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random limit between 1000 and 10000 to keep it reasonable\n    limit = random.randint(1000, 10000)\n    return {'limit': limit}", "io_pairs": [{"input": {"limit": 7387}, "output": [[220, 284], [2620, 2924], [5020, 5564], [6232, 6368]]}, {"input": {"limit": 5655}, "output": [[220, 284], [2620, 2924], [5020, 5564]]}, {"input": {"limit": 5993}, "output": [[220, 284], [2620, 2924], [5020, 5564]]}, {"input": {"limit": 9850}, "output": [[220, 284], [2620, 2924], [5020, 5564], [6232, 6368]]}, {"input": {"limit": 8041}, "output": [[220, 284], [2620, 2924], [5020, 5564], [6232, 6368]]}, {"input": {"limit": 5277}, "output": [[220, 284], [2620, 2924]]}, {"input": {"limit": 7488}, "output": [[220, 284], [2620, 2924], [5020, 5564], [6232, 6368]]}, {"input": {"limit": 6274}, "output": [[220, 284], [2620, 2924], [5020, 5564]]}, {"input": {"limit": 9469}, "output": [[220, 284], [2620, 2924], [5020, 5564], [6232, 6368]]}, {"input": {"limit": 3179}, "output": [[220, 284], [2620, 2924]]}], "error_log": []}
{"context": "Given a starting point on the Earth's surface defined by its latitude and longitude, and a specified distance between points, how can we generate a grid of points around the starting point, where each point is a certain distance apart from its neighbors? Specifically, what are the coordinates of each point in the grid when the grid is of a given size?\n\nThe input and output requirements are as follows:\n\nInput:\n- `start_latitude` (float): The starting latitude in degrees.\n- `start_longitude` (float): The starting longitude in degrees.\n- `point_dist` (float): The distance between points in kilometers.\n- `square_size` (int): The size of the square grid.\n\nOutput:\n- `return` (dict): A dictionary where each key is a string representing the grid coordinates (e.g., \"0,0\") and each value is a list of two floats representing the latitude and longitude of that grid point.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(start_latitude, start_longitude, point_dist, square_size):\n    # Convert input variables to the required types\n    start_latitude = float(start_latitude)\n    start_longitude = float(start_longitude)\n    point_dist = float(point_dist)\n    square_size = int(square_size)\n    \n    # Function to calculate distance on unit sphere\n    def distance_on_unit_sphere(lat1, long1, lat2, long2):\n        degrees_to_radians = math.pi / 180.0\n        phi1 = (90.0 - lat1) * degrees_to_radians\n        phi2 = (90.0 - lat2) * degrees_to_radians\n        theta1 = long1 * degrees_to_radians\n        theta2 = long2 * degrees_to_radians\n        cos = (math.sin(phi1) * math.sin(phi2) * math.cos(theta1 - theta2) + \n               math.cos(phi1) * math.cos(phi2))\n        arc = math.acos(cos)\n        return arc * 6373  # in km\n    \n    # Calculate delta\n    delta = point_dist / distance_on_unit_sphere(start_latitude, start_longitude, start_latitude + 1, start_longitude)\n    \n    # Generate places dictionary\n    places = {}\n    for x in range(int(-math.floor(square_size / 2)), int(math.ceil(square_size / 2))):\n        for y in range(int(-math.floor(square_size / 2)), int(math.ceil(square_size / 2))):\n            curr = (start_latitude + (delta * x), start_longitude + (delta * y))\n            places[f\"{x},{y}\"] = curr\n    \n    # Convert places dictionary to a JSON serializable format\n    serializable_places = {key: list(value) for key, value in places.items()}\n    \n    return serializable_places", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random start latitude (-90 to 90)\n    start_latitude = random.uniform(-90, 90)\n    # Generate random start longitude (-180 to 180)\n    start_longitude = random.uniform(-180, 180)\n    # Generate random point distance (0.1 to 100 km)\n    point_dist = random.uniform(0.1, 100)\n    # Generate random square size (1 to 10)\n    square_size = random.randint(1, 10)\n    \n    return {\n        'start_latitude': start_latitude,\n        'start_longitude': start_longitude,\n        'point_dist': point_dist,\n        'square_size': square_size\n    }", "io_pairs": [{"input": {"start_latitude": -35.78364397343283, "start_longitude": -134.68250311922316, "point_dist": 65.49776299911362, "square_size": 1}, "output": {"0,0": [-35.78364397343283, -134.68250311922316]}}, {"input": {"start_latitude": -0.9606698415926616, "start_longitude": -147.3712718802198, "point_dist": 12.166259822691114, "square_size": 2}, "output": {"-1,-1": [-1.070049308138966, -147.4806513467661], "-1,0": [-1.070049308138966, -147.3712718802198], "0,-1": [-0.9606698415926616, -147.4806513467661], "0,0": [-0.9606698415926616, -147.3712718802198]}}, {"input": {"start_latitude": -77.80393102119433, "start_longitude": -166.60513010828146, "point_dist": 5.725551142909439, "square_size": 1}, "output": {"0,0": [-77.80393102119433, -166.60513010828146]}}, {"input": {"start_latitude": 84.12559459122417, "start_longitude": 163.61481110780477, "point_dist": 77.91890333323337, "square_size": 1}, "output": {"0,0": [84.12559459122417, 163.61481110780477]}}, {"input": {"start_latitude": -54.06820888882345, "start_longitude": -36.176516645524146, "point_dist": 50.669143636674235, "square_size": 1}, "output": {"0,0": [-54.06820888882345, -36.176516645524146]}}, {"input": {"start_latitude": 62.43147083264654, "start_longitude": 50.24820942189456, "point_dist": 79.55441197432027, "square_size": 2}, "output": {"-1,-1": [61.71624534264617, 49.53298393189419], "-1,0": [61.71624534264617, 50.24820942189456], "0,-1": [62.43147083264654, 49.53298393189419], "0,0": [62.43147083264654, 50.24820942189456]}}, {"input": {"start_latitude": -45.778776858631886, "start_longitude": -134.2482129919474, "point_dist": 86.21832665202903, "square_size": 1}, "output": {"0,0": [-45.778776858631886, -134.2482129919474]}}, {"input": {"start_latitude": 20.300718178671445, "start_longitude": -170.20849302814673, "point_dist": 32.617721055673464, "square_size": 1}, "output": {"0,0": [20.300718178671445, -170.20849302814673]}}, {"input": {"start_latitude": 83.64335436070058, "start_longitude": -21.990558937700712, "point_dist": 75.85579887959639, "square_size": 1}, "output": {"0,0": [83.64335436070058, -21.990558937700712]}}, {"input": {"start_latitude": 78.30517166962915, "start_longitude": 179.83872081954337, "point_dist": 3.644757646100292, "square_size": 2}, "output": {"-1,-1": [78.27240386318485, 179.80595301309907], "-1,0": [78.27240386318485, 179.83872081954337], "0,-1": [78.30517166962915, 179.80595301309907], "0,0": [78.30517166962915, 179.83872081954337]}}], "error_log": []}
{"context": "Given a graph represented by its adjacency matrix and a set number of colors, how can we determine all possible ways to color the vertices of the graph such that no two adjacent vertices share the same color?\n\nThe input and output requirements are as follows:\n\nInput:\n  `adjacency_matrix` (list of lists of integers): A 2D list representing the adjacency matrix of the graph. Each element is either 0 or 1, where 1 indicates an edge between two vertices and 0 indicates no edge.\n  `num_colors` (integer): The number of colors available for coloring the graph.\n\nOutput:\n  `return` (list of lists of integers): A list of all possible colorings of the graph. Each inner list represents a valid coloring of the graph, where each element corresponds to the color assigned to the respective vertex.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef safe(A, v, colour, c):\n    ans = True\n    for i in range(len(A)):\n        if A[v][i] == 1 and colour[i] == c:\n            ans = False\n    return ans\n\ndef solve(A, m, colour, v, all_sols):\n    if v == len(A[0]):\n        all_sols.append(list(colour))\n    else:\n        for c in range(1, m+1):\n            if safe(A, v, colour, c):\n                colour[v] = c\n                solve(A, m, colour, v+1, all_sols)\n\n# main function\ndef main_solution(adjacency_matrix, num_colors):\n    # Convert adjacency_matrix from list of lists to a JSON serializable format\n    adjacency_matrix = [[int(x) for x in row] for row in adjacency_matrix]\n    \n    all_sols = []\n    V = len(adjacency_matrix[0])\n    colour = [None for _ in range(V)]\n    solve(adjacency_matrix, num_colors, colour, 0, all_sols)\n    \n    # Convert all_sols to a JSON serializable format\n    return [sol for sol in all_sols]", "input_generator": "import random\n\ndef input_generator():\n    # Randomly decide the number of vertices (between 2 and 5 for reasonable size)\n    V = random.randint(2, 5)\n    \n    # Generate a random adjacency matrix for a simple undirected graph\n    adjacency_matrix = [[0 for _ in range(V)] for _ in range(V)]\n    for i in range(V):\n        for j in range(i+1, V):\n            adjacency_matrix[i][j] = random.choice([0, 1])\n            adjacency_matrix[j][i] = adjacency_matrix[i][j]\n    \n    # Randomly decide the number of colors (between 1 and V)\n    num_colors = random.randint(1, V)\n    \n    return {\n        'adjacency_matrix': adjacency_matrix,\n        'num_colors': num_colors\n    }", "io_pairs": [{"input": {"adjacency_matrix": [[0, 0, 0], [0, 0, 0], [0, 0, 0]], "num_colors": 1}, "output": [[1, 1, 1]]}, {"input": {"adjacency_matrix": [[0, 1], [1, 0]], "num_colors": 1}, "output": []}, {"input": {"adjacency_matrix": [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], "num_colors": 2}, "output": [[1, 2, 1, 2]]}, {"input": {"adjacency_matrix": [[0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0]], "num_colors": 2}, "output": [[1, 1, 1, 2], [1, 1, 2, 2], [1, 2, 1, 2], [1, 2, 2, 2]]}, {"input": {"adjacency_matrix": [[0, 1, 1], [1, 0, 1], [1, 1, 0]], "num_colors": 2}, "output": []}, {"input": {"adjacency_matrix": [[0, 1], [1, 0]], "num_colors": 2}, "output": [[1, 2]]}, {"input": {"adjacency_matrix": [[0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 1], [1, 0, 1, 0]], "num_colors": 2}, "output": [[1, 1, 1, 2], [1, 2, 1, 2]]}, {"input": {"adjacency_matrix": [[0, 0], [0, 0]], "num_colors": 2}, "output": [[1, 1], [1, 2], [2, 1], [2, 2]]}, {"input": {"adjacency_matrix": [[0, 1, 1, 0], [1, 0, 1, 0], [1, 1, 0, 1], [0, 0, 1, 0]], "num_colors": 2}, "output": []}, {"input": {"adjacency_matrix": [[0, 1, 1], [1, 0, 0], [1, 0, 0]], "num_colors": 1}, "output": []}], "error_log": []}
{"context": "Given a set of article titles and a search query, which articles are most relevant to the search query based on the frequency of the search terms in the articles?\n\nThe input and output requirements are as follows:\n\nInput:\n  `userstring` (str): A string representing the search query. Words should be separated by spaces.\n  `listofarticles` (str): A comma-separated string representing the titles of the articles. Each title should be a single word or phrase.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"closest_articles\"`, whose value is a list of strings representing the titles of the articles that best match the search query.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\ndef vector_distance(vector1, vector2):\n    if len(vector1) != len(vector2):\n        raise ValueError('These two vectors do not have the same length.')\n\n    d = 0\n    for i in range(len(vector1)):\n        d = (vector1[i] - vector2[i])**2 + d\n    d = math.sqrt(d)\n    return d\n\ndef normalize(vector1):\n    length = 0\n    for value in vector1:\n        length = length + value**2\n    length = math.sqrt(length)\n    if length > 0:\n        for i in range(len(vector1)):\n            vector1[i] = vector1[i]/length\n    return vector1      \n\ndef clean_word(word):\n    word = word.strip('.')\n    word = word.strip(',')\n    word = word.strip('!')\n    word = word.strip('?')\n    return word\n\n# main function\ndef main_solution(userstring, listofarticles):\n    # Convert listofarticles to a list of strings\n    listofarticles = listofarticles.split(',')\n    \n    # Break the string into a list of words\n    userstring = userstring.lower()\n    parsedstring = userstring.split()\n    \n    # Collect the unique words in parsedstring in a dictionary\n    masterword_dictionary = {}\n    for word in parsedstring:\n        masterword_dictionary[word] = 0\n    \n    # Make a list of only the unique words in the search string\n    masterword_list = list(masterword_dictionary.keys())\n    \n    # Initialize the word matrix\n    wordmatrix = []\n    \n    # Loop through list of article filenames, open the article file, read the content of the article\n    for article_title in listofarticles:\n        word_dictionary = {}\n        words = []\n        wordvec = []\n        \n        # Simulate reading the article content\n        article_words = article_title.lower().split()\n        \n        # Clean and collect words\n        for w in article_words:\n            w = clean_word(w)\n            words.append(w)\n        \n        # Count words that are in the search string\n        for w in words:\n            if w in masterword_dictionary.keys():\n                word_dictionary[w] = word_dictionary.get(w, 0) + 1\n        \n        # Update masterword_dictionary with article counts\n        for w in masterword_dictionary.keys():\n            if w in word_dictionary.keys():\n                masterword_dictionary[w] = masterword_dictionary.get(w, 0) + 1\n        \n        # Create word vector for the article\n        for word in masterword_list:\n            if word in word_dictionary.keys():\n                wordvec.append(word_dictionary[word])\n            else:\n                wordvec.append(0)\n        \n        # Normalize the word vector\n        wordvec = normalize(wordvec)\n        wordmatrix.append(wordvec)\n    \n    # Calculate Inverse Document Frequency (IDF)\n    numarticles = len(listofarticles)\n    InverseDocumentFreq = {}\n    for w in masterword_dictionary.keys():\n        if masterword_dictionary[w] > 0:\n            InverseDocumentFreq[w] = math.log(numarticles / masterword_dictionary[w])\n        else:\n            InverseDocumentFreq[w] = 1\n    \n    # Weight the word counts using IDF\n    for row in range(len(wordmatrix)):\n        for col in range(len(wordmatrix[row])):\n            word_col = masterword_list[col]\n            wordmatrix[row][col] = wordmatrix[row][col] * InverseDocumentFreq[word_col]\n        wordmatrix[row] = normalize(wordmatrix[row])\n    \n    # Create the masterword vector\n    masterword_vec = []\n    for word in masterword_list:\n        masterword_vec.append(masterword_dictionary[word] * InverseDocumentFreq[word])\n    masterword_vec = normalize(masterword_vec)\n    \n    # Calculate distances between masterword_vec and rows in wordmatrix\n    distance = []\n    for i in range(numarticles):\n        distance.append(vector_distance(masterword_vec, wordmatrix[i][:]))\n    \n    # Find the closest article(s)\n    closest_article_score = min(distance)\n    closest_articles = [listofarticles[index] for index, score in enumerate(distance) if score == closest_article_score]\n    \n    # Return the closest articles\n    return {\"closest_articles\": closest_articles}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random user string with some words\n    words = ['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew', 'kiwi', 'lemon']\n    userstring = ' '.join(random.choices(words, k=random.randint(3, 8)))\n    \n    # Generate a list of article titles (simulated filenames)\n    num_articles = random.randint(2, 5)\n    listofarticles = []\n    for _ in range(num_articles):\n        title_words = random.choices(words, k=random.randint(2, 6))\n        title = ' '.join(title_words)\n        # Randomly add some punctuation\n        if random.random() > 0.5:\n            title += random.choice(['.', '!', '?'])\n        listofarticles.append(title)\n    listofarticles = ','.join(listofarticles)\n    \n    return {\n        'userstring': userstring,\n        'listofarticles': listofarticles\n    }", "io_pairs": [{"input": {"userstring": "cherry banana date", "listofarticles": "kiwi grape kiwi lemon honeydew!,kiwi lemon lemon apple,cherry date kiwi."}, "output": {"closest_articles": ["cherry date kiwi."]}}, {"input": {"userstring": "banana lemon lemon grape", "listofarticles": "date banana!,honeydew elderberry elderberry,cherry apple kiwi,apple cherry elderberry!"}, "output": {"closest_articles": ["date banana!"]}}, {"input": {"userstring": "apple kiwi lemon cherry", "listofarticles": "apple fig elderberry grape fig fig,honeydew honeydew?,banana kiwi grape fig date elderberry!"}, "output": {"closest_articles": ["apple fig elderberry grape fig fig", "banana kiwi grape fig date elderberry!"]}}, {"input": {"userstring": "cherry date honeydew lemon fig fig", "listofarticles": "grape kiwi grape grape fig apple,date grape,elderberry date date!,honeydew fig cherry cherry date."}, "output": {"closest_articles": ["honeydew fig cherry cherry date."]}}, {"input": {"userstring": "date elderberry cherry elderberry apple", "listofarticles": "elderberry date!,banana cherry kiwi banana date."}, "output": {"closest_articles": ["elderberry date!", "banana cherry kiwi banana date."]}}, {"input": {"userstring": "cherry apple banana elderberry lemon grape apple grape", "listofarticles": "lemon grape lemon apple lemon.,kiwi fig fig date banana?,elderberry cherry kiwi date lemon fig!"}, "output": {"closest_articles": ["lemon grape lemon apple lemon."]}}, {"input": {"userstring": "grape honeydew lemon lemon cherry honeydew banana", "listofarticles": "kiwi apple date kiwi banana grape.,lemon apple date date!"}, "output": {"closest_articles": ["kiwi apple date kiwi banana grape."]}}, {"input": {"userstring": "banana fig apple", "listofarticles": "honeydew apple elderberry!,lemon cherry banana"}, "output": {"closest_articles": ["honeydew apple elderberry!", "lemon cherry banana"]}}, {"input": {"userstring": "honeydew fig date honeydew lemon fig", "listofarticles": "fig grape grape elderberry honeydew,grape elderberry"}, "output": {"closest_articles": ["fig grape grape elderberry honeydew"]}}, {"input": {"userstring": "cherry banana grape", "listofarticles": "honeydew grape honeydew kiwi elderberry?,apple lemon,fig cherry elderberry lemon grape"}, "output": {"closest_articles": ["fig cherry elderberry lemon grape"]}}], "error_log": []}
{"context": "Given a range of even numbers starting from a lower limit (which is at least 4) to an upper limit, what are the prime number pairs that sum up to each even number within this range, according to Goldbach's Conjecture?\n\nThe input and output requirements are as follows:\n\nInput:\n  `lower_limit` (int): The lower limit of the range of even numbers (greater than or equal to 4).\n  `upper_limit` (int): The upper limit of the range of even numbers (greater than `lower_limit`).\n\nOutput:\n  `return` (str): A string containing the Goldbach's Conjecture representations for each even number in the range, formatted as \"number = prime1 + prime2\".", "reference_code": "# import necessary packages\nimport random\n\n# determine if a number is prime\ndef is_prime(num):\n    if num == 1:\n        return False\n    for i in range(2, num // 2 + 1):\n        if num % i == 0:\n            return False\n    return True\n\n# find all prime summations in the given range\ndef find_goldmans(start, end):\n    results = []\n    for i in range(start, end + 1, 2):\n        results.append(str(i))\n        for j in range(2, i // 2 + 1):\n            if is_prime(j) and is_prime(i - j):\n                results.append(\"=\")\n                results.append(str(j))\n                results.append(\"+\")\n                results.append(str(i - j))\n        results = [' {0} '.format(elem) for elem in results]\n        results.append(\"\\n\")\n    return ''.join(results).strip()\n\n# main function\ndef main_solution(lower_limit, upper_limit):\n    # all input arguments of the main_solution function should be json serializable\n    # return, the returned value must be json serializable\n    return find_goldmans(lower_limit, upper_limit)", "input_generator": "import random\n\ndef input_generator():\n    lower_limit = random.randint(2, 100) * 2  # Ensure it's even\n    upper_limit = lower_limit + random.randint(2, 20) * 2  # Ensure it's even and larger than lower_limit\n    return {'lower_limit': lower_limit, 'upper_limit': upper_limit}", "io_pairs": [{"input": {"lower_limit": 4, "upper_limit": 8}, "output": "4      =      2      +      2     \n    6    =    3    +    3   \n  8  =  3  +  5"}, {"input": {"lower_limit": 6, "upper_limit": 10}, "output": "6      =      3      +      3     \n    8    =    3    +    5   \n  10  =  3  +  7  =  5  +  5"}], "error_log": []}
{"context": "Given a set of x-values and their corresponding function values, what is the approximated value of the function at a specific point `x` using the Newton Forward Difference Method?\n\nThe input and output requirements are as follows:\n\nInput:\n  `X` (list of floats): List of x-values used for interpolation.\n  `fX` (list of floats): List of corresponding function values at the x-values.\n  `x` (float): The point at which the function value is to be approximated.\n\nOutput:\n  `return` (float): The approximated value of the function at the point `x`, rounded to 10 decimal places.", "reference_code": "# import necessary packages\nimport numpy as np\nimport math\n\n# all class and function definitions in the code file, if any\ndef DiffArray(A):\n    ans = []\n    for i in range(1, len(A)):\n        ans.append(A[i]-A[i-1])\n    return ans\n\ndef NewtonForwardDiffMethod(X, fX, x):\n    A = fX\n    factorial = 1\n    ans = 0\n    for i in range(len(X)):\n        if i == 0:\n            ans += A[0]\n        else:\n            factorial *= i\n            cur = 1\n            for j in range(i):\n                cur *= (x - X[j])\n            cur /= pow(X[1] - X[0], i)\n            cur /= factorial\n            cur *= A[0]\n            ans += cur\n        A = DiffArray(A)\n    return ans\n\n# main function\ndef main_solution(X, fX, x):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert JSON serializable inputs to the original input variables if necessary\n    X = list(X)\n    fX = list(fX)\n    \n    # Call the core function to solve the problem\n    result = NewtonForwardDiffMethod(X, fX, x)\n    \n    # Convert the result to a JSON serializable output\n    return round(result, 10)", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    # Generate a random number of points (between 3 and 10)\n    n = random.randint(3, 10)\n    \n    # Generate random X values, sorted and with reasonable spacing\n    X = sorted([round(random.uniform(0, 10), 2) for _ in range(n)])\n    \n    # Generate corresponding fX values, ensuring some variability\n    fX = [round(random.uniform(-10, 10), 2) for _ in range(n)]\n    \n    # Generate a random x value within the range of X, or slightly outside\n    if random.random() < 0.8:\n        # Within range\n        x = round(random.uniform(min(X), max(X)), 2)\n    else:\n        # Outside range\n        x = round(random.uniform(min(X) - 2, max(X) + 2), 2)\n    \n    return {\n        'X': X,\n        'fX': fX,\n        'x': round(random.uniform(min(X), max(X)), 2)\n    }", "io_pairs": [{"input": {"X": [0.58, 2.36, 7.64, 8.37, 9.77], "fX": [4.05, -7.45, -5.62, 1.9, 4.36], "x": 4.73}, "output": 3.0452776673}, {"input": {"X": [0.61, 5.53, 6.87, 7.16, 9.75, 9.75], "fX": [-7.84, -5.45, -5.87, 6.23, -5.18, 6.8], "x": 1.39}, "output": -6.1897611704}, {"input": {"X": [2.19, 3.14, 4.71, 8.21], "fX": [3.31, -4.24, 4.8, -2.06], "x": 5.24}, "output": 16.4998559557}, {"input": {"X": [0.1, 0.31, 1.86, 2.47, 2.88, 4.33, 7.57], "fX": [7.39, 6.85, 0.49, 9.28, -6.26, 5.54, 3.4], "x": 4.5}, "output": 236376.7329148791}, {"input": {"X": [1.39, 4.55, 6.24, 9.39], "fX": [8.58, 2.19, 4.75, 2.91], "x": 8.86}, "output": 1.9549193798}, {"input": {"X": [1.55, 4.02, 5.4, 6.54, 6.55, 6.76], "fX": [8.38, -2.07, -5.96, -1.69, -1.64, 8.07], "x": 1.83}, "output": 7.2433238678}, {"input": {"X": [4.92, 6.42, 7.63, 8.78], "fX": [-6.02, -5.81, -1.7, -6.78], "x": 7.87}, "output": -2.5634478519}, {"input": {"X": [2.47, 4.24, 4.33, 4.4, 6.31, 6.43, 7.74, 9.88], "fX": [-6.79, 4.66, 8.77, -1.49, -4.43, 1.84, -6.12, -6.07], "x": 8.96}, "output": 17.3710794604}, {"input": {"X": [1.18, 7.66, 8.81], "fX": [-9.18, -4.76, -7.53], "x": 8.2}, "output": -4.7162152778}, {"input": {"X": [3.93, 4.35, 5.95, 6.09, 6.78, 8.81], "fX": [9.22, 9.63, -5.74, -1.42, -4.19, -0.06], "x": 8.21}, "output": 3091.1774299005}], "error_log": []}
{"context": "Given a sequence of elevation data, what are the indices of the peaks and valleys, and what is the highest elevation point in the data?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data` (str): A comma-separated string of integers representing the elevation data.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `peaks_valleys` (list of int): A list of indices where peaks and valleys are located.\n    - `highest_point` (int): The highest elevation point in the data.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef peaks(data):\n    peaks_list = []\n    for i in range(1, len(data) - 1):\n        if data[i] > data[i - 1] and data[i] > data[i + 1]:\n            peaks_list.append(i)\n    return peaks_list\n\ndef valley(data):\n    valley_list = []\n    for i in range(1, len(data) - 1):\n        if data[i] < data[i - 1] and data[i] < data[i + 1]:\n            valley_list.append(i)\n    return valley_list\n\ndef peaks_and_valleys(data):\n    peaks_list = peaks(data)\n    valley_list = valley(data)\n    peaks_valley = peaks_list + valley_list\n    peaks_valley.sort()\n    return peaks_valley\n\ndef find_highest_point(data):\n    highest = 0\n    for point in data:\n        if point > highest:\n            highest = point\n    return highest\n\n# main function\ndef main_solution(data):\n    # Convert input to list of integers\n    data = list(map(int, data.split(',')))\n    \n    # Find peaks and valleys\n    peaks_valleys = peaks_and_valleys(data)\n    \n    # Find the highest point\n    highest_point = find_highest_point(data)\n    \n    # Return the results as a dictionary\n    return {\n        \"peaks_valleys\": peaks_valleys,\n        \"highest_point\": highest_point\n    }", "input_generator": "import random\n\ndef input_generator():\n    length = random.randint(5, 20)\n    data = [random.randint(0, 100) for _ in range(length)]\n    # Ensure at least one peak or valley by modifying some elements\n    if length >= 3:\n        for i in range(1, length - 1):\n            if random.choice([True, False]):\n                data[i] = max(data[i-1], data[i+1]) + 1  # Ensure peak\n            else:\n                data[i] = min(data[i-1], data[i+1]) - 1  # Ensure valley\n    data_str = ','.join(map(str, data))\n    return {'data': data_str}", "io_pairs": [{"input": {"data": "75,80,40,39,36,9,23,74,57,58,57,58,36,88,66,67"}, "output": {"peaks_valleys": [1, 5, 7, 8, 9, 10, 11, 12, 13, 14], "highest_point": 88}}, {"input": {"data": "34,86,87,88,89,15,14,20"}, "output": {"peaks_valleys": [4, 6], "highest_point": 89}}, {"input": {"data": "82,83,84,85,1,88,74,75,76,82,83,84,69,70"}, "output": {"peaks_valleys": [3, 4, 5, 6, 11, 12], "highest_point": 88}}, {"input": {"data": "84,38,37,76,77,78,59,60"}, "output": {"peaks_valleys": [2, 5, 6], "highest_point": 84}}, {"input": {"data": "79,80,18,53,52,31,34,35,38,39,35"}, "output": {"peaks_valleys": [1, 2, 3, 5, 9], "highest_point": 80}}, {"input": {"data": "57,55,35,11,5,4,3,2,56,57,58,31,30,63"}, "output": {"peaks_valleys": [7, 10, 12], "highest_point": 63}}, {"input": {"data": "6,34,33,34,33,32,31,3,4,74,75,76,72,73,11,12"}, "output": {"peaks_valleys": [1, 2, 3, 7, 11, 12, 13, 14], "highest_point": 76}}, {"input": {"data": "36,96,43,8,7,6,50,49,50,9,56,55,54,85,24,23,22,91,92,42"}, "output": {"peaks_valleys": [1, 5, 6, 7, 8, 9, 10, 12, 13, 16, 18], "highest_point": 96}}, {"input": {"data": "98,80,75,53,52,53,54,14,13,12,11,10,21,86,87,88,30,31"}, "output": {"peaks_valleys": [4, 6, 11, 15, 16], "highest_point": 98}}, {"input": {"data": "40,46,61,93,56,57,56,6,5,59"}, "output": {"peaks_valleys": [3, 4, 5, 8], "highest_point": 93}}], "error_log": []}
{"context": "Given two wires that are laid out on a grid, each wire follows a specific path defined by a series of movements. Each movement is described by a direction (right, left, up, down) and a number of steps. The wires can intersect at certain points. What is the minimum Manhattan distance from the origin to any intersection point of the two wires?\n\nThe input and output requirements are as follows:\n\nInput:\n  `wire_1` (str): A string representing the path of the first wire. Each movement is separated by a comma. Each movement is in the format of a direction (R, L, U, D) followed by a number of steps.\n  `wire_2` (str): A string representing the path of the second wire. Each movement is separated by a comma. Each movement is in the format of a direction (R, L, U, D) followed by a number of steps.\n\nOutput:\n  `return` (int or None): The minimum Manhattan distance from the origin to any intersection point of the two wires. If no intersection points are found, it returns `None`.", "reference_code": "# import necessary packages\nfrom collections import namedtuple\nimport random\n\n# all class and function definitions in the code file, if any\nPoint = namedtuple('Point', 'x y')\n\nclass Line:\n    def __init__(self, start, end):\n        self.start = Point(*start)\n        self.end = Point(*end)\n        if self.start.x == self.end.x:\n            step = 1 if self.end.y > self.start.y else -1\n            self.points = [\n                Point(self.start.x, y) for y in\n                range(self.start.y, self.end.y + step, step)\n            ]\n        else:\n            step = 1 if self.end.x > self.start.x else -1\n            self.points = [\n                Point(x, self.start.y) for x in\n                range(self.start.x, self.end.x + step, step)\n            ]\n        self.steps = len(self.points)\n\n    def intersect(self, line):\n        p = set(self.points) & set(line.points)\n        if p:\n            return p.pop()\n        raise ValueError('Lines do not intersect.')\n\ndef manhattan(point):\n    return abs(point.x) + abs(point.y)\n\ndef collect_lines(wire):\n    pos = [0, 0]\n    lines = []\n    for item in wire:\n        start = pos[:]\n        direction = item[0]\n        steps = int(item[1:])\n        if direction == 'R':\n            pos[0] += steps\n        elif direction == 'L':\n            pos[0] -= steps\n        elif direction == 'U':\n            pos[1] += steps\n        elif direction == 'D':\n            pos[1] -= steps\n        else:\n            raise ValueError(f'Unknown direction: {direction}')\n        lines.append(Line(start, pos[:]))\n    return lines\n\n# main function\ndef main_solution(wire_1, wire_2):\n    # Convert JSON serializable inputs to original input variables\n    wire_1 = wire_1.split(',')\n    wire_2 = wire_2.split(',')\n    \n    # Collect lines for both wires\n    lines_1 = collect_lines(wire_1)\n    lines_2 = collect_lines(wire_2)\n    \n    # Find intersection points\n    points = []\n    for line in lines_1[1:]:\n        for l in lines_2[1:]:\n            try:\n                point = line.intersect(l)\n                points.append(point)\n            except ValueError:\n                pass\n    \n    # Calculate Manhattan distances and find the minimum\n    if points:\n        min_distance = min(map(manhattan, points))\n    else:\n        min_distance = None\n    \n    # Return the minimum distance as JSON serializable output\n    return min_distance", "input_generator": "import random\nimport string\n\ndef input_generator():\n    directions = ['R', 'L', 'U', 'D']\n    wire_length = random.randint(5, 20)\n    \n    def generate_wire():\n        wire = []\n        pos = [0, 0]\n        for _ in range(wire_length):\n            direction = random.choice(directions)\n            steps = random.randint(1, 10)\n            wire.append(f\"{direction}{steps}\")\n        return ','.join(wire)\n    \n    wire_1 = generate_wire()\n    wire_2 = generate_wire()\n    \n    return {'wire_1': wire_1, 'wire_2': wire_2}", "io_pairs": [{"input": {"wire_1": "D9,R9,R6,R10,L4,U1", "wire_2": "D3,D5,U3,D9,R3,L8"}, "output": 9}, {"input": {"wire_1": "D5,R8,R6,R5,R2,R4,U2,U6,L5,R9,U5,U3,U10,L10,D4,L1,U3,D9,L1,R8", "wire_2": "L6,R10,U5,U6,R4,D10,U2,R7,R10,D1,L9,R7,L7,L1,U3,D6,R3,R9,L3,U4"}, "output": 26}, {"input": {"wire_1": "D8,U3,U1,U5,U1,D3,D2,R1,L8,U5,U9,R10,U9,R2", "wire_2": "U5,U7,R7,R3,L4,U9,U8,L7,R1,R5,U2,D8,L9,L4"}, "output": 11}, {"input": {"wire_1": "D4,R10,D3,L5,L10,L8,L2,L3,U10,L7,D3,L1,U2,R3,R3,U2,U8,D6,D1,L9", "wire_2": "L8,L6,D4,R2,U3,D4,D2,L3,D9,D9,D8,D4,R5,R2,U4,L1,D9,R3,U8,U4"}, "output": 19}, {"input": {"wire_1": "U2,R2,U10,D1,U5,D2,D8", "wire_2": "U7,U4,R10,D3,U9,L3,D1"}, "output": 13}, {"input": {"wire_1": "D1,U1,D10,L9,U4,D3,R10,R1,U1,R8,L2,D2,U1,U9,U6,L7,L7,L5,U8", "wire_2": "U2,L9,L8,U7,R4,D7,R3,D4,U4,D3,R9,R8,U10,D6,R10,R6,R9,U6,L10"}, "output": 1}, {"input": {"wire_1": "R5,R1,L7,L8,U6,L6,U5,R9,D10,L5,D4", "wire_2": "R1,R8,R1,D5,R4,R2,L5,D5,L10,R5,U7"}, "output": 4}, {"input": {"wire_1": "R5,D8,R2,L9,U2", "wire_2": "D8,U10,L5,R4,L1"}, "output": 8}, {"input": {"wire_1": "R9,R2,R6,R4,R8,L2,R10,L2,D10,L7,L3,L2,L6,U8,R7,R1", "wire_2": "D1,R8,U9,U3,D7,R8,U7,D4,R2,D2,U1,D1,D10,U1,D3,U2"}, "output": 18}, {"input": {"wire_1": "D4,D8,L8,U10,D2,U5,D5,U3,R4,L10,R9,U4,U10,D2,U3,D10,L2,D9,D6", "wire_2": "D7,R4,U5,L3,U7,U8,U7,U1,R9,U9,L1,U10,D9,L9,D7,D3,L1,R1,R8"}, "output": 7}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, what is the optimal move for player 'O' given the current state of the board and the depth parameters for both players? The board is represented by a grid of size `n x n`, and the current state of the board is provided. The depth parameters `d1` and `d2` determine the depth of the search for player 'X' and player 'O', respectively. The goal is to find the best move for player 'O' based on the minimax algorithm, which evaluates the board state and returns the value and coordinates of the optimal move.\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the Tic-Tac-Toe board (n x n).\n  `d1` (int): Depth parameter for player 'X'.\n  `d2` (int): Depth parameter for player 'O'.\n  `current_state` (list of lists of str): The current state of the Tic-Tac-Toe board, where each element is either '.', 'X', or 'O'.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `value` (int): The value of the best move according to the minimax algorithm.\n    - `x` (int): The x-coordinate of the best move.\n    - `y` (int): The y-coordinate of the best move.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass TicTacToe:\n    def __init__(self, n, d1, d2):\n        self.n = n\n        self.d1 = d1\n        self.d2 = d2\n        self.current_state = [['.' for _ in range(n)] for _ in range(n)]\n\n    def is_end(self):\n        # Check if the game has ended (win, lose, or draw)\n        # This is a placeholder implementation\n        return None\n\n    def simpleHeuristic(self):\n        # Placeholder for simple heuristic\n        return 0\n\n    def sophisticatedHeuristic(self):\n        # Placeholder for sophisticated heuristic\n        return 0\n\n    def minimax(self, max=False):\n        value = 2\n        if max:\n            value = -2\n        x = None\n        y = None\n        result = self.is_end()\n        if result == 'X':\n            return (-1, x, y)\n        elif result == 'O':\n            return (1, x, y)\n        elif result == '.':\n            return (0, x, y)\n        if self.d1 == 0:\n            return (self.simpleHeuristic(), x, y)\n        else:\n            return (self.sophisticatedHeuristic(), x, y)\n        if self.d2 == 0:\n            return (self.simpleHeuristic(), x, y)\n        else:\n            return (self.sophisticatedHeuristic(), x, y)\n\n        for i in range(self.n):\n            for j in range(self.n):\n                if self.current_state[i][j] == '.':\n                    if max:\n                        self.current_state[i][j] = 'O'\n                        (v, _, _) = self.minimax(max=False)\n                        if v > value:\n                            value = v\n                            x = i\n                            y = j\n                    else:\n                        self.current_state[i][j] = 'X'\n                        (v, _, _) = self.minimax(max=False)\n                        if v < value:\n                            value = v\n                            x = i\n                            y = j\n                    self.current_state[i][j] = '.'\n        return (value, x, y)\n\n# main function\ndef main_solution(n, d1, d2, current_state):\n    # Convert JSON serializable inputs to the original input variables\n    game = TicTacToe(n, d1, d2)\n    game.current_state = current_state\n\n    # Call the minimax function\n    (value, x, y) = game.minimax(max=True)\n\n    # Convert the output to JSON serializable format\n    return {\"value\": value, \"x\": x, \"y\": y}", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(3, 5)  # Reasonable board size between 3x3 and 5x5\n    d1 = random.randint(0, 1)\n    d2 = random.randint(0, 1)\n    \n    # Generate a random current state with some moves already made\n    current_state = []\n    symbols = ['X', 'O', '.']\n    for _ in range(n):\n        row = []\n        for _ in range(n):\n            row.append(random.choice(symbols))\n        current_state.append(row)\n    \n    return {\n        'n': n,\n        'd1': d1,\n        'd2': d2,\n        'current_state': current_state\n    }", "io_pairs": [{"input": {"n": 3, "d1": 0, "d2": 0, "current_state": [["X", "X", "O"], ["O", "X", "."], ["O", ".", "."]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 1, "d2": 1, "current_state": [[".", "O", "X"], ["X", "X", "."], [".", ".", "X"]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 1, "d2": 1, "current_state": [["O", "O", "."], ["O", "X", "."], ["X", "O", "O"]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 0, "d2": 1, "current_state": [["X", ".", "."], [".", "X", "."], [".", "X", "."]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 0, "d2": 0, "current_state": [["O", "O", "X"], ["X", ".", "X"], ["O", "X", "X"]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 0, "d2": 0, "current_state": [["O", ".", "."], ["X", ".", "X"], [".", ".", "X"]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 0, "d2": 0, "current_state": [["O", ".", "."], ["O", ".", "O"], ["X", "O", "."]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 0, "d2": 0, "current_state": [["O", "O", "O"], ["X", ".", "O"], [".", ".", "."]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 0, "d2": 0, "current_state": [["O", "O", "X"], ["X", "O", "O"], ["O", "X", "X"]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 1, "d2": 1, "current_state": [["X", "O", "X"], ["O", ".", "."], ["O", "O", "O"]]}, "output": {"value": 0, "x": null, "y": null}}], "error_log": []}
{"context": "Given a point in 3D space and a vector originating from this point, how would the vector be reflected when it encounters a surface with a given normal vector? Specifically, what are the coordinates of the reflected vector?\n\nThe input and output requirements are as follows:\n\nInput:\n  `point_coords` (list of float): A list containing the x, y, and z coordinates of a point in 3D space.\n  `vector_coords` (list of float): A list containing the x, y, and z coordinates of a vector in 3D space.\n  `normal_coords` (list of float): A list containing the x, y, and z coordinates of the normal vector in 3D space.\n\nOutput:\n  `return` (list of float): A list containing the x, y, and z coordinates of the reflected vector in 3D space.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Tuple(tuple):\n    def __new__(self, x, y, z, w):\n        return tuple.__new__(Tuple, (x, y, z, w))\n\n    @staticmethod\n    def Point(x, y, z):\n        return Tuple(x, y, z, 1.0)\n\n    @staticmethod\n    def Vector(x, y, z):\n        return Tuple(x, y, z, 0.0)\n\n    @staticmethod\n    def is_point(t):\n        return isinstance(t, Tuple) and len(t) == 4 and t[3] == 1.0\n\n    @staticmethod\n    def is_vector(t):\n        return isinstance(t, Tuple) and len(t) == 4 and t[3] == 0.0\n\n    def __add__(self, other):\n        return Tuple(self.x + other.x, self.y + other.y, self.z + other.z, self.w + other.w)\n\n    def __sub__(self, other):\n        return Tuple(self.x - other.x, self.y - other.y, self.z - other.z, self.w - other.w)\n\n    def __neg__(self):\n        return Tuple(-self.x, -self.y, -self.z, -self.w)\n\n    def __mul__(self, other):\n        return Tuple(self.x * other, self.y * other, self.z * other, self.w * other)\n\n    def __truediv__(self, other):\n        return Tuple(self.x / other, self.y / other, self.z / other, self.w / other)\n\n    def __div__(self, other):\n        return Tuple(self.x / other, self.y / other, self.z / other, self.w / other)\n\n    def mag(self):\n        return math.sqrt(sum(_ * _ for _ in self[:3]))\n\n    def norm(self):\n        return self / self.mag()\n\n    def dot(self, other):\n        return sum([a * b for a, b in zip(self, other)])\n\n    def cross(self, other):\n        assert self.w == 0 and other.w == 0\n        a, b = self, other\n        return Tuple(\n            a.y * b.z - a.z * b.y,\n            a.z * b.x - a.x * b.z,\n            a.x * b.y - a.y * b.x,\n            0.0,\n            )\n\n    @property\n    def x(self):\n        return self[0]\n\n    @property\n    def y(self):\n        return self[1]\n\n    @property\n    def z(self):\n        return self[2]\n\n    @property\n    def w(self):\n        return self[3]\n\n    def reflect(self, normal):\n        return self - normal * 2 * self.dot(normal)\n\n# create aliases so we don't need to prefix with Tuple everywhere\nPoint = Tuple.Point\nVector = Tuple.Vector\n\n# main function\ndef main_solution(point_coords, vector_coords, normal_coords):\n    # Convert JSON serializable inputs to original input variables\n    point = Point(*point_coords)\n    vector = Vector(*vector_coords)\n    normal = Vector(*normal_coords)\n    \n    # Perform the reflection operation\n    reflected_vector = vector.reflect(normal)\n    \n    # Convert the result to JSON serializable output\n    reflected_vector_coords = (reflected_vector.x, reflected_vector.y, reflected_vector.z)\n    \n    return reflected_vector_coords", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random point coordinates (x, y, z)\n    point_coords = (\n        random.uniform(-10.0, 10.0),\n        random.uniform(-10.0, 10.0),\n        random.uniform(-10.0, 10.0)\n    )\n    \n    # Generate random vector coordinates (x, y, z)\n    vector_coords = (\n        random.uniform(-5.0, 5.0),\n        random.uniform(-5.0, 5.0),\n        random.uniform(-5.0, 5.0)\n    )\n    \n    # Generate random normal vector coordinates (x, y, z) and normalize it\n    normal_x = random.uniform(-1.0, 1.0)\n    normal_y = random.uniform(-1.0, 1.0)\n    normal_z = random.uniform(-1.0, 1.0)\n    magnitude = math.sqrt(normal_x**2 + normal_y**2 + normal_z**2)\n    normal_coords = (\n        normal_x / magnitude,\n        normal_y / magnitude,\n        normal_z / magnitude\n    )\n    \n    return {\n        'point_coords': point_coords,\n        'vector_coords': vector_coords,\n        'normal_coords': normal_coords\n    }", "io_pairs": [{"input": {"point_coords": [-3.1893917993588854, 0.866227852023103, 6.202992069192717], "vector_coords": [-4.058828127059008, 0.8861127450719142, -2.2985044150871357], "normal_coords": [-0.05459189300754256, 0.31223642575313704, -0.9484345732051098]}, "output": [-3.7664080889007505, -0.7863734521096954, 2.7817604156072377]}, {"input": {"point_coords": [6.203530131554647, 7.536763772743946, -3.685245325168916], "vector_coords": [-2.469927108840262, -2.2808852535892843, 1.170874457900542], "normal_coords": [0.6387453009637698, -0.5088094694058781, -0.5771632042495536]}, "output": [-1.0737525548605875, -3.393045034548175, -0.09069345978235788]}, {"input": {"point_coords": [6.828838864668381, -5.945935705738652, 0.6028770307680009], "vector_coords": [2.973169101091244, 4.349160831548405, -4.466009321838477], "normal_coords": [-0.7485694100789659, -0.2376440701508348, 0.619006570414381]}, "output": [-6.045093363858641, 1.4861843740504779, 2.9913669005434818]}, {"input": {"point_coords": [0.0262013512203616, 5.780913060576459, 2.395378063434258], "vector_coords": [-4.354095376193376, -0.3332197294912138, -4.440243888050993], "normal_coords": [0.7509367864736485, 0.6288217317327827, 0.20168582602953133]}, "output": [2.216181661918392, 5.168618853315465, -2.675605671434693]}, {"input": {"point_coords": [-8.636043998931369, -8.589458277986664, -6.4695591706091555], "vector_coords": [-1.3457738881237304, -1.2888020058012706, 3.422600818912221], "normal_coords": [-0.7036626654626942, -0.33039981985397326, 0.6290427745983564]}, "output": [3.6161077702876314, 1.041014377163791, -1.0130982153450612]}, {"input": {"point_coords": [2.4035460718394965, -9.23952948598975, -4.865390568817358], "vector_coords": [1.36459420403048, -2.8997754114807717, -1.7643201812616995], "normal_coords": [-0.392050544080395, -0.07250030431645293, -0.9170823718512356]}, "output": [2.378649901245999, -2.7122502371071278, 0.6077530578484183]}, {"input": {"point_coords": [-8.644553735277116, 7.198478688854124, 2.399037632934462], "vector_coords": [1.9313976408550033, -3.0303853548833724, 3.9353245799893717], "normal_coords": [-0.8749607939601384, -0.4401678284384354, 0.20173222806591087]}, "output": [2.697623073041865, -2.644919186675431, 3.7586625344407762]}, {"input": {"point_coords": [6.439264841518039, 6.14178443937103, 5.764013471880203], "vector_coords": [2.6198521666784744, -0.6897378789447215, -2.9137743323093046], "normal_coords": [-0.045116924601320815, 0.9925341230411824, 0.1133158316979127]}, "output": [2.5176203903807215, 1.559274599881503, -2.6570086316437127]}, {"input": {"point_coords": [9.111963516015841, -5.558962200826246, 3.747589567411273], "vector_coords": [-3.474463887955431, 4.876464385186077, 2.709940417814332], "normal_coords": [0.18174468011588418, -0.6042305373301047, -0.7758056000103041]}, "output": [-1.4097131111009262, -1.9880307436730567, -6.103771291865318]}, {"input": {"point_coords": [3.0205856006673937, -7.242098170418984, -9.33718414300914], "vector_coords": [0.12868985352221785, -2.1358130126141592, 3.7983733458453948], "normal_coords": [-0.29379366318987776, -0.677996395938732, -0.673799800061979]}, "output": [-0.5464937807632336, -3.693954415910848, 2.2498763740348338]}], "error_log": []}
{"context": "In a drone network, each drone is connected to other drones through direct friendships. Given a list of these direct connections and the names of two drones, determine if there is any indirect connection between them through a series of mutual friends. For example, if drone A is friends with drone B, and drone B is friends with drone C, then drone A and drone C are indirectly connected. How can we determine if two given drones are connected through any series of mutual friends?\n\nThe input and output requirements are as follows:\n\nInput:\n  `network` (list of strings): A list of strings where each string represents a connection between two drones in the format \"drone1-drone2\".\n  `first` (string): The name of the first drone to check for a connection.\n  `second` (string): The name of the second drone to check for a connection.\n\nOutput:\n  `return` (boolean): `True` if there is a connection between the two drones through any depth of common friends, otherwise `False`.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(network, first, second):\n    # Convert the network tuple of strings into a dictionary for easier traversal\n    d = dict()\n    for connection in network:\n        tmp1, tmp2 = connection.split('-')\n        d.setdefault(tmp1, []).append(tmp2)\n        d.setdefault(tmp2, []).append(tmp1)\n    \n    # Initialize the BFS queue and visited list\n    future = [first]\n    visited = []\n    \n    # Perform BFS to check if there's a path from first to second\n    while len(future):\n        top = future.pop()\n        visited.append(top)\n        if top == second:\n            return True\n        for next in d.setdefault(top, []):\n            if next not in visited and next not in future:\n                future.append(next)\n    \n    return False", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random number of nodes (between 5 and 15)\n    num_nodes = random.randint(5, 15)\n    nodes = []\n    for _ in range(num_nodes):\n        # Generate random node names (e.g., 'A', 'B', ... or 'Node1', 'Node2', ...)\n        if random.choice([True, False]):\n            node = random.choice(string.ascii_uppercase)\n        else:\n            node = 'Node' + str(random.randint(1, 50))\n        nodes.append(node)\n    \n    # Ensure unique nodes\n    nodes = list(set(nodes))\n    num_nodes = len(nodes)\n    \n    # Generate random connections\n    network = []\n    max_connections = min(num_nodes * (num_nodes - 1) // 2, 20)  # Limit to 20 connections max\n    num_connections = random.randint(num_nodes - 1, max_connections)  # Ensure at least a spanning tree\n    \n    # First create a spanning tree to ensure connectivity\n    connected = [nodes[0]]\n    remaining = nodes[1:]\n    while remaining:\n        a = random.choice(connected)\n        b = random.choice(remaining)\n        network.append(f\"{a}-{b}\")\n        connected.append(b)\n        remaining.remove(b)\n    \n    # Add additional random connections\n    possible_connections = []\n    for i in range(num_nodes):\n        for j in range(i + 1, num_nodes):\n            a, b = nodes[i], nodes[j]\n            if f\"{a}-{b}\" not in network and f\"{b}-{a}\" not in network:\n                possible_connections.append((a, b))\n    \n    random.shuffle(possible_connections)\n    for _ in range(num_connections - (num_nodes - 1)):\n        if not possible_connections:\n            break\n        a, b = possible_connections.pop()\n        network.append(f\"{a}-{b}\")\n    \n    # Randomly choose first and second nodes\n    first, second = random.sample(nodes, 2)\n    \n    return {\n        'network': tuple(network),\n        'first': first,\n        'second': second\n    }", "io_pairs": [{"input": {"network": ["Node21-Node11", "Node11-Node28", "Node28-G", "Node11-Node40"], "first": "Node28", "second": "Node11"}, "output": true}, {"input": {"network": ["K-V", "V-L", "L-Y", "L-Node46", "V-C", "Y-Node17", "K-L"], "first": "C", "second": "Node46"}, "output": true}, {"input": {"network": ["Node43-Q", "Node43-Y", "Node43-I"], "first": "I", "second": "Q"}, "output": true}, {"input": {"network": ["Node13-Node28", "Node28-Node5", "Node5-Node20", "Node28-Node26", "Node26-Node5", "Node13-Node26", "Node13-Node5"], "first": "Node26", "second": "Node20"}, "output": true}, {"input": {"network": ["Node43-Node40", "Node40-Node13", "Node43-S", "Node40-I", "I-T", "Node43-Node23"], "first": "Node43", "second": "Node13"}, "output": true}, {"input": {"network": ["V-S", "V-Node48", "V-Node23", "Node48-C", "Node23-D", "D-Node48", "C-S"], "first": "V", "second": "D"}, "output": true}, {"input": {"network": ["J-W", "W-Node34", "Node34-Q"], "first": "Node34", "second": "J"}, "output": true}, {"input": {"network": ["Node8-Node35", "Node35-W", "Node35-O", "O-X", "Node8-X", "O-W", "X-W"], "first": "Node8", "second": "O"}, "output": true}, {"input": {"network": ["A-Node6", "A-Node1", "Node1-D", "Node1-Node6", "A-D"], "first": "D", "second": "Node6"}, "output": true}, {"input": {"network": ["Node24-Q", "Node24-R", "Q-S", "Node24-Z", "Z-Node32", "Node24-Node50"], "first": "Node32", "second": "Q"}, "output": true}], "error_log": []}
{"context": "Given a function \\( f(x, y) = x^2 y^2 + 2xy \\), what are the coordinates of the local minimum and the value of the function at this point when starting from a specific initial guess and using gradient descent with a given step size, precision, and maximum number of iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n- `initial_guess` (list of float): A list containing the initial guess for the x and y coordinates, e.g., `[1.0, 2.0]`.\n- `alpha` (float): The step size factor for gradient descent, e.g., `0.001`.\n- `precision` (float): The precision threshold for convergence, e.g., `0.0000001`.\n- `max_iters` (int): The maximum number of iterations allowed, e.g., `100000`.\n\nOutput:\n- `return` (dict): A dictionary containing the following keys:\n  - `local_minimum` (list of float): A list containing the x and y coordinates of the local minimum found by the gradient descent algorithm.\n  - `value_at_minimum` (float): The value of the function at the local minimum.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(initial_guess, alpha, precision, max_iters):\n    # Convert JSON serializable inputs to original input variables\n    cur_xy = np.array(initial_guess)\n    \n    # Define the function and its gradients\n    f = lambda x, y: x**2 * y**2 + 2 * x * y\n    grad_fx = lambda x, y: 2 * x * y**2 + 2 * y\n    grad_fy = lambda x, y: 2 * x**2 * y + 2 * x\n    \n    previous_step_size = 1\n    iters = 0\n    \n    # Gradient descent loop\n    while previous_step_size > precision and iters < max_iters:\n        prev_xy = cur_xy\n        cur_xy = cur_xy - alpha * np.array([grad_fx(cur_xy[0], cur_xy[1]), grad_fy(cur_xy[0], cur_xy[1])])\n        previous_step_size = np.linalg.norm(cur_xy - prev_xy)\n        iters += 1\n    \n    # Convert output to JSON serializable\n    local_minimum = cur_xy.tolist()\n    value_at_minimum = f(cur_xy[0], cur_xy[1])\n    \n    return {\"local_minimum\": local_minimum, \"value_at_minimum\": value_at_minimum}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    initial_guess = [random.uniform(-5.0, 5.0), random.uniform(-5.0, 5.0)]\n    alpha = random.uniform(0.001, 0.1)\n    precision = random.choice([1e-3, 1e-4, 1e-5, 1e-6])\n    max_iters = random.randint(100, 1000)\n    return {\n        \"initial_guess\": initial_guess,\n        \"alpha\": alpha,\n        \"precision\": precision,\n        \"max_iters\": max_iters\n    }", "io_pairs": [{"input": {"initial_guess": [2.267798567496965, -3.024361303903189], "alpha": 0.01626309289994174, "precision": 0.001, "max_iters": 602}, "output": {"local_minimum": [0.5052826733240716, -2.0016043843115736], "value_at_minimum": -0.9998705862999628}}, {"input": {"initial_guess": [3.3088962567874347, 4.378842158205812], "alpha": 0.036699713049372924, "precision": 1e-05, "max_iters": 880}, "output": {"local_minimum": [-1.6635856994606804, 0.6011450609571019], "value_at_minimum": -0.9999999968273019}}, {"input": {"initial_guess": [-2.855862092058419, 1.609241469876192], "alpha": 0.07830212046095499, "precision": 0.0001, "max_iters": 652}, "output": {"local_minimum": [-1.9860862274340487, 0.5034558904642681], "value_at_minimum": -0.9999999913156559}}, {"input": {"initial_guess": [-1.0558554683183319, -2.4027484834493773], "alpha": 0.08461616498286668, "precision": 1e-05, "max_iters": 534}, "output": {"local_minimum": [0.5519052181857919, -1.8118956371145951], "value_at_minimum": -0.9999999999714516}}, {"input": {"initial_guess": [-1.19985612391998, -1.5321104486087398], "alpha": 0.014542457596001486, "precision": 0.001, "max_iters": 251}, "output": {"local_minimum": [0.8010025413371951, -1.2210345128148192], "value_at_minimum": -0.9995182742264668}}, {"input": {"initial_guess": [3.4827804711564685, 3.6254301855706768], "alpha": 0.05590340883025722, "precision": 1e-06, "max_iters": 307}, "output": {"local_minimum": [-1.2334214640530676, 0.8107497796689724], "value_at_minimum": -0.9999999999854093}}, {"input": {"initial_guess": [-2.4647249116529824, 0.34400839270630623], "alpha": 0.00755698349707275, "precision": 1e-06, "max_iters": 860}, "output": {"local_minimum": [-2.4738126550965718, 0.404224726092863], "value_at_minimum": -0.9999999994356006}}, {"input": {"initial_guess": [1.4410464953937439, 1.17202532029029], "alpha": 0.06131937492215962, "precision": 1e-06, "max_iters": 683}, "output": {"local_minimum": [1.1326500422805483, -0.8828816665089864], "value_at_minimum": -0.9999999999836532}}, {"input": {"initial_guess": [4.08808698445301, 4.811213950779669], "alpha": 0.03321371656260804, "precision": 0.0001, "max_iters": 706}, "output": {"local_minimum": [-2.351886558650526, 0.42503421927576185], "value_at_minimum": -0.9999998647726475}}, {"input": {"initial_guess": [-2.9111397677136552, -4.594984611608101], "alpha": 0.01854106759008821, "precision": 0.0001, "max_iters": 502}, "output": {"local_minimum": [0.33262147610641685, -3.0051549272585367], "value_at_minimum": -0.9999998228161111}}], "error_log": []}
{"context": "Given two integers `m` and `n`, how does the performance of Ackermann's function vary between two different implementations (Count and Ternary) when evaluated using timeit?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The first parameter for Ackermann's function.\n  `n` (int): The second parameter for Ackermann's function.\n\nOutput:\n  `return` (str): A formatted string containing the results of timing the execution of Ackermann's function using two different implementations (Count and Ternary).", "reference_code": "# import necessary packages\nimport timeit\nimport sys\nimport json\n\n# all class and function definitions in the code file, if any\ndef ack_c(m, n):\n    global COUNT\n    COUNT += 1\n    return (n + 1) if m == 0 else (ack_c(m - 1, 1) if n == 0 else ack_c(m - 1, ack_c(m, n-1)))\n\ndef ack_t(m, n):\n    \"\"\" Ackermann's Function as a Ternary in the return \"\"\"\n    return (n + 1) if m == 0 else (ack_t(m - 1, 1) if n == 0 else ack_t(m - 1, ack_t(m, n-1)))\n\ndef t_comp(ret, cases, t='r'):\n    \"\"\" ret is a reference pointer to an empty list\n    cases is a list of dicts with the timeit args \"\"\"\n    for d in cases:\n        if 'num' not in d: d['num'] = 1\n        if t == 'r':\n            if 'rep' not in d: d['rep'] = 3\n            ret.append((\n                        d['tit'],\n                        timeit.repeat(d['stat'], d['sup'], repeat=d['rep'], number=d['num'])\n                      ))\n        else:\n            ret.append((\n                        d['tit'],\n                        timeit.timeit(d['stat'], d['sup'], number=d['num'])\n                       ))\n    return None\n\ndef t_rep(ret):\n    \"\"\" Takes a list of paired (title, results) tuples and\n    formats them into a single return string. \"\"\"\n    pr = ''\n    for c in ret:\n        pr += \"Case: {1}{0:^5}{2}\\n\".format('-', c[0], c[1])\n    return pr\n\n# main function\ndef main_solution(m, n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    global COUNT\n    COUNT = 1\n    sys.setrecursionlimit(3500)\n\n    sup = \"m ,n = {}, {}; from __main__ import ack_{{}}\".format(m, n)\n    case_c = dict(tit='Count', sup=sup.format('c'), stat=\"\"\"ack_c(m, n)\"\"\")\n    case_t = dict(tit='Ternary', sup=sup.format('t'), stat=\"\"\"ack_t(m, n)\"\"\")\n\n    run_set = (case_c, case_t)\n\n    ret_set = []\n    t_comp(ret_set, run_set, 't')\n    results = t_rep(ret_set)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return results", "input_generator": "import random\n\ndef input_generator():\n    m = random.choice([0, 1, 2, 3])  # Higher values can cause stack overflow\n    n = random.randint(0, 5)\n    return {'m': m, 'n': n}", "io_pairs": [{"input": {"m": 2, "n": 2}, "output": "Case: Count  -  8.200004231184721e-06\nCase: Ternary  -  5.89998671784997e-06\n"}, {"input": {"m": 1, "n": 5}, "output": "Case: Count  -  3.500026650726795e-06\nCase: Ternary  -  2.5999615900218487e-06\n"}, {"input": {"m": 0, "n": 0}, "output": "Case: Count  -  9.00006853044033e-07\nCase: Ternary  -  8.00006091594696e-07\n"}, {"input": {"m": 1, "n": 3}, "output": "Case: Count  -  2.7999631129205227e-06\nCase: Ternary  -  2.00001522898674e-06\n"}, {"input": {"m": 1, "n": 4}, "output": "Case: Count  -  3.100023604929447e-06\nCase: Ternary  -  2.0999577827751637e-06\n"}, {"input": {"m": 1, "n": 2}, "output": "Case: Count  -  2.2999593056738377e-06\nCase: Ternary  -  1.700012944638729e-06\n"}, {"input": {"m": 2, "n": 3}, "output": "Case: Count  -  1.0100018698722124e-05\nCase: Ternary  -  6.800051778554916e-06\n"}, {"input": {"m": 3, "n": 2}, "output": "Case: Count  -  9.200000204145908e-05\nCase: Ternary  -  6.19000056758523e-05\n"}, {"input": {"m": 0, "n": 3}, "output": "Case: Count  -  9.00006853044033e-07\nCase: Ternary  -  7.00005330145359e-07\n"}, {"input": {"m": 3, "n": 1}, "output": "Case: Count  -  1.8199963960796595e-05\nCase: Ternary  -  1.2800039257854223e-05\n"}], "error_log": []}
{"context": "Given a polynomial function and an interval, what is the arc length of the function over that interval?\n\nThe input and output requirements are as follows:\n\nInput:\n  `function_str` (str): A string representing a one-variable function in SymPy syntax.\n  `variable_str` (str): A string representing the variable used in the function.\n  `lower_limit` (float): The lower limit of the interval over which to calculate the arc length.\n  `upper_limit` (float): The upper limit of the interval over which to calculate the arc length.\n\nOutput:\n  `return` (float): The arc length of the function over the specified interval, returned as a float. If the input function is invalid, returns the string \"Invalid input function\".", "reference_code": "# import necessary packages\nimport sympy\n\n# main function\ndef main_solution(function_str, variable_str, lower_limit, upper_limit):\n    # Convert the input strings to sympy expressions and symbols\n    try:\n        function_expr = sympy.sympify(function_str)\n    except sympy.SympifyError:\n        return \"Invalid input function\"\n    \n    variable_sym = sympy.Symbol(variable_str)\n    \n    # Calculate the derivative of the function\n    derivative = sympy.Derivative(function_expr, variable_sym).doit()\n    \n    # Calculate the arc length of the function between the given limits\n    length = sympy.Integral(sympy.sqrt(1 + derivative ** 2), (variable_sym, lower_limit, upper_limit)).doit().evalf()\n    \n    # Return the length as a float\n    return float(length)", "input_generator": "import random\nimport sympy\nfrom sympy.abc import x, y, z\n\ndef input_generator():\n    # List of common functions and variables\n    functions = [\n        \"x**2\",\n        \"sin(x)\",\n        \"cos(x)\",\n        \"exp(x)\",\n        \"log(x)\",\n        \"sqrt(x)\",\n        \"x**3 - 2*x + 1\",\n        \"tan(x)\",\n        \"1/x\",\n        \"x + sin(x)\"\n    ]\n    variables = ['x', 'y', 'z']\n    \n    # Randomly select a function and variable\n    function_str = random.choice(functions)\n    variable_str = random.choice(variables)\n    \n    # Generate random limits, ensuring lower < upper\n    lower_limit = random.uniform(-10, 10)\n    upper_limit = lower_limit + random.uniform(0.1, 10)\n    \n    return {\n        'function_str': function_str,\n        'variable_str': variable_str,\n        'lower_limit': lower_limit,\n        'upper_limit': upper_limit\n    }", "io_pairs": [{"input": {"function_str": "cos(x)", "variable_str": "x", "lower_limit": 2.440423320754803, "upper_limit": 3.307160548642798}, "output": 0.9166202310498978}, {"input": {"function_str": "exp(x)", "variable_str": "z", "lower_limit": -8.024456000269616, "upper_limit": -1.125283845649288}, "output": 6.899172154620328}, {"input": {"function_str": "log(x)", "variable_str": "z", "lower_limit": -0.3958750507572155, "upper_limit": 6.797225571629205}, "output": 7.193100622386421}, {"input": {"function_str": "log(x)", "variable_str": "z", "lower_limit": 8.911494580961573, "upper_limit": 18.575734865137793}, "output": 9.66424028417622}, {"input": {"function_str": "exp(x)", "variable_str": "y", "lower_limit": -7.453285257231554, "upper_limit": -6.0161975729403}, "output": 1.4370876842912548}, {"input": {"function_str": "x + sin(x)", "variable_str": "y", "lower_limit": -2.6728314024840465, "upper_limit": 3.745855211619766}, "output": 6.418686614103812}, {"input": {"function_str": "cos(x)", "variable_str": "x", "lower_limit": -1.2331954249545003, "upper_limit": 2.2027819430142155}, "output": 4.212743037469294}, {"input": {"function_str": "sin(x)", "variable_str": "y", "lower_limit": -2.387660769041842, "upper_limit": 0.4735483971136687}, "output": 2.861209166155511}, {"input": {"function_str": "sqrt(x)", "variable_str": "z", "lower_limit": -7.040348258090203, "upper_limit": -6.072345423610376}, "output": 0.9680028344798268}, {"input": {"function_str": "log(x)", "variable_str": "y", "lower_limit": -7.37905414999438, "upper_limit": -3.8306487943379945}, "output": 3.548405355656385}], "error_log": []}
{"context": "In a game of Lingo, a hidden five-character word is chosen from a predefined list. Players attempt to guess the word by providing five-letter guesses. After each guess, they receive a clue indicating which characters are correct and in the right position, and which characters are present but in the wrong position. Given a list of possible words and a player's guess, what clue should be provided to guide the player towards the correct word?\n\nThe input and output requirements are as follows:\n\nInput:\n  `words` (list of strings): A list of five-letter words from which the hidden word is chosen.\n  `guess` (string): A five-letter string representing the user's guess.\n\nOutput:\n  `return` (string): A string representing the clue for the user's guess. Characters in the correct position are enclosed in square brackets `[ ]`, and characters present but in the wrong position are enclosed in parentheses `( )`.", "reference_code": "# import necessary packages\nfrom random import randrange\n\n# main function\ndef main_solution(words, guess):\n    # Choose a word from the list randomly\n    hidden = words[randrange(0, len(words))]\n\n    # Map to build clue\n    sym_map = {0: \"%s\", 1:\"(%s)\", 2: \"[%s]\"}\n    \n    # 0: letter not present in the hidden word\n    # 1: letter present but position is wrong\n    # 2: correct letter and position\n    cenc = [(int(guess[i] == hidden[i])) + int(guess[i] in hidden) for i in range(5)] \n    \n    # Enclose the letter with appropriate symbols using sym_map\n    clue = \"\".join([sym_map[cenc[i]] % guess[i] for i in range(5)])\n    \n    # Return the clue\n    return clue", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a list of 5-letter words\n    word_list = [\n        ''.join(random.choices(string.ascii_lowercase, k=5)) \n        for _ in range(random.randint(5, 10))\n    ]\n    # Select a random guess from the word list or generate a new 5-letter word\n    if random.random() > 0.5:\n        guess = random.choice(word_list)\n    else:\n        guess = ''.join(random.choices(string.ascii_lowercase, k=5))\n    return {'words': word_list, 'guess': guess}", "io_pairs": [{"input": {"words": ["qeatg", "uhbep", "uytif", "yekag", "posqn"], "guess": "qeatg"}, "output": "q(e)atg"}, {"input": {"words": ["dxlwx", "lkrif", "pguhh", "omkmo", "nknbt"], "guess": "omkmo"}, "output": "om(k)mo"}, {"input": {"words": ["bhfmo", "odicx", "gnlqc", "zlqaq", "jmamc", "olufa", "yjqfa"], "guess": "yjqfa"}, "output": "y(j)qf(a)"}, {"input": {"words": ["octig", "duoxk", "totbo", "yjfur", "sulbc", "gvjfc"], "guess": "gvjfc"}, "output": "gvjfc"}, {"input": {"words": ["uwazf", "rmanr", "cafai", "iccca", "zmqri", "jpakt", "utgpr"], "guess": "ztyum"}, "output": "ztyum"}, {"input": {"words": ["canlj", "axrwo", "qkblo", "leong", "fejqw", "flknb"], "guess": "axrwo"}, "output": "axr(w)o"}, {"input": {"words": ["fflxj", "djamh", "etbpk", "ljzji", "yfdwf"], "guess": "rarrl"}, "output": "rarrl"}, {"input": {"words": ["rrhtz", "qrzii", "wpoxg", "qtdoj", "qfciq"], "guess": "qfciq"}, "output": "[q]fc[i](q)"}, {"input": {"words": ["bwzjy", "nuipy", "ifior", "axbkm", "iisle", "ufogf", "esfth"], "guess": "gxpvv"}, "output": "g[x]pvv"}, {"input": {"words": ["epend", "ajrcu", "hlndd", "rlvwa", "dhsqi", "wfmkj", "wqadn", "wigoy", "hxmoi"], "guess": "wigoy"}, "output": "wigoy"}], "error_log": []}
{"context": "Given the continued fraction representation of the number e, what is the sum of the digits of the numerator after performing the continued fraction calculation for a specified number of iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `iterations` (int): The number of iterations to perform in the continued fraction calculation.\n\nOutput:\n  `return` (str): A string representing the sum of the digits of the numerator after performing the continued fraction calculation for the specified number of iterations.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef e_contfrac_term(i):\n    if i == 0:\n        return 2\n    elif i % 3 == 2:\n        return i // 3 * 2 + 2\n    else:\n        return 1\n\n# main function\ndef main_solution(iterations):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    numer = 1\n    denom = 0\n    for i in reversed(range(iterations)):\n        numer, denom = e_contfrac_term(i) * numer + denom, numer\n    result = sum(int(c) for c in str(numer))\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return str(result)", "input_generator": "import random\n\ndef input_generator():\n    iterations = random.randint(5, 20)\n    return {'iterations': iterations}", "io_pairs": [{"input": {"iterations": 17}, "output": "28"}, {"input": {"iterations": 11}, "output": "12"}, {"input": {"iterations": 15}, "output": "30"}, {"input": {"iterations": 6}, "output": "15"}, {"input": {"iterations": 16}, "output": "34"}, {"input": {"iterations": 5}, "output": "10"}, {"input": {"iterations": 9}, "output": "13"}, {"input": {"iterations": 7}, "output": "7"}, {"input": {"iterations": 13}, "output": "26"}, {"input": {"iterations": 8}, "output": "13"}], "error_log": []}
{"context": "Given two matrices, what is the result of their matrix multiplication?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_a` (list of lists of ints/floats): A 2D list representing the first matrix.\n  `matrix_b` (list of lists of ints/floats): A 2D list representing the second matrix. The dimensions of `matrix_b` should be compatible with `matrix_a` for matrix multiplication.\n\nOutput:\n  `return` (list of lists of ints/floats): A 2D list representing the result of the matrix multiplication of `matrix_a` and `matrix_b`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix_a, matrix_b):\n    # Convert JSON serializable inputs to numpy arrays\n    a = np.array(matrix_a)\n    b = np.array(matrix_b)\n    \n    # Perform matrix multiplication\n    result = np.dot(a, b)\n    \n    # Convert the result to a JSON serializable output\n    return result.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the dimensions of the matrices (m x n) and (n x p)\n    m = random.randint(1, 5)\n    n = random.randint(1, 5)\n    p = random.randint(1, 5)\n    \n    # Generate random matrices with integers between -10 and 10\n    matrix_a = [[random.randint(-10, 10) for _ in range(n)] for _ in range(m)]\n    matrix_b = [[random.randint(-10, 10) for _ in range(p)] for _ in range(n)]\n    \n    return {'matrix_a': matrix_a, 'matrix_b': matrix_b}", "io_pairs": [{"input": {"matrix_a": [[1], [2]], "matrix_b": [[4]]}, "output": [[4], [8]]}, {"input": {"matrix_a": [[10], [5]], "matrix_b": [[3, -9, 6, 8]]}, "output": [[30, -90, 60, 80], [15, -45, 30, 40]]}, {"input": {"matrix_a": [[-2, 9, 2]], "matrix_b": [[-1], [5], [-2]]}, "output": [[43]]}, {"input": {"matrix_a": [[-10], [-10]], "matrix_b": [[-3, -7, 0, 9]]}, "output": [[30, 70, 0, -90], [30, 70, 0, -90]]}, {"input": {"matrix_a": [[1]], "matrix_b": [[9, -1, 0]]}, "output": [[9, -1, 0]]}, {"input": {"matrix_a": [[-7, 2]], "matrix_b": [[5], [7]]}, "output": [[-21]]}, {"input": {"matrix_a": [[6], [8], [3]], "matrix_b": [[-9, -7]]}, "output": [[-54, -42], [-72, -56], [-27, -21]]}, {"input": {"matrix_a": [[3], [5]], "matrix_b": [[7, -3, 2, -1, 0]]}, "output": [[21, -9, 6, -3, 0], [35, -15, 10, -5, 0]]}, {"input": {"matrix_a": [[-1], [-9]], "matrix_b": [[-9, 4, 9]]}, "output": [[9, -4, -9], [81, -36, -81]]}, {"input": {"matrix_a": [[-9], [-8]], "matrix_b": [[5, -6, 10, -6, 2]]}, "output": [[-45, 54, -90, 54, -18], [-40, 48, -80, 48, -16]]}], "error_log": []}
{"context": "Given two functions \\( f(t) \\) and \\( g(t) \\), where \\( f(t) = 1.1(t - 2.5)^2 \\) and \\( g(t) = 5t + 2.5 \\), determine the roots of these functions within a specified interval and identify the points where the functions cross over each other. What are the roots of \\( f(t) \\) and \\( g(t) \\), and at which points do \\( f(t) \\) and \\( g(t) \\) intersect within the given tolerance?\n\nThe input and output requirements are as follows:\n\nInput:\n  `t0` (float): Initial guess for the root finding method.\n  `tmin` (float): Minimum value of the interval for generating t values.\n  `tmax` (float): Maximum value of the interval for generating t values.\n  `eps` (float): Tolerance for finding crossover points between f(t) and g(t).\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `tf_root` (float or None): The root of the function f(t) found using Newton's method. If no root is found, it will be `None`.\n    - `tg_root` (float or None): The root of the function g(t) found using Newton's method. If no root is found, it will be `None`.\n    - `crossover_points` (list of floats): A list of t values where f(t) and g(t) cross over within the tolerance `eps`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef f_t(t):\n    t0 = 2.5\n    c = 1.1\n    f = c*(t-t0)**2\n    return f\n\ndef dfdt(t):\n    t0 = 2.5\n    c = 1.1\n    df = 2*c*(t-t0)\n    return df\n\ndef g_t(t):\n    t0 = 2.5\n    A = 5\n    g = A*t + t0\n    return g\n\ndef dgdt(t):\n    A = 5\n    return A\n\ndef Newton(function, d_dt, t0):\n    \"\"\"\n    Implementation of Newton's Method\n    for solving f(x) = 0 when f'(x) is known\n    \"\"\"\n    t_next = 0\n    tn = float(t0)\n    abs_tn = abs(function(tn))\n    eps = 1e-5 # epsilon to set bounds\n    N = 20 # runs through 20 times\n    i = 0\n    while abs_tn > eps and i < N: # convergence criteria\n        t_next = tn - function(tn)/d_dt(tn)\n        tn = t_next\n        i += 1\n    if abs_tn < eps:\n        return t_next\n    else:\n        return np.nan\n\n# main function\ndef main_solution(t0, tmin, tmax, eps):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # Find roots using Newton's method\n    tf_root = Newton(f_t, dfdt, t0)\n    tg_root = Newton(g_t, dgdt, t0)\n    \n    # Generate t values for plotting\n    a_t = np.linspace(tmin, tmax, 1000)\n    \n    # Calculate function values\n    a_ft = f_t(a_t)\n    a_gt = g_t(a_t)\n    \n    # Find crossover points\n    sel = abs(a_ft - a_gt) < eps\n    crossover_points = a_t[sel].tolist()\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\n        \"tf_root\": tf_root.item() if not np.isnan(tf_root) else None,\n        \"tg_root\": tg_root.item() if not np.isnan(tg_root) else None,\n        \"crossover_points\": crossover_points\n    }", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    t0 = random.uniform(0.0, 5.0)\n    tmin = random.uniform(-10.0, 0.0)\n    tmax = random.uniform(5.0, 15.0)\n    eps = random.choice([1e-3, 1e-4, 1e-5, 1e-6])\n    return {\n        \"t0\": t0,\n        \"tmin\": tmin,\n        \"tmax\": tmax,\n        \"eps\": eps\n    }", "io_pairs": [{"input": {"t0": 2.494952004771222, "tmin": -3.730504838918451, "tmax": 9.611312954195284, "eps": 0.0001}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 4.892618539150787, "tmin": -3.1375460911466666, "tmax": 10.994313590445993, "eps": 0.001}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 3.139290064873763, "tmin": -6.928826111256278, "tmax": 14.590137854209505, "eps": 1e-06}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 1.881458332716619, "tmin": -6.396343081644773, "tmax": 9.25617686170649, "eps": 1e-05}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 4.33494612669756, "tmin": -4.889067090647778, "tmax": 9.56111334682861, "eps": 0.001}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 1.293426912080589, "tmin": -4.910559710321733, "tmax": 9.60657707642763, "eps": 0.001}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 2.3082901983655475, "tmin": -3.0157520542863185, "tmax": 11.372174571645562, "eps": 0.0001}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 3.0646332812976818, "tmin": -6.478654392973309, "tmax": 5.992462353094144, "eps": 0.0001}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 2.933675294985445, "tmin": -5.865327797453319, "tmax": 12.333018075897815, "eps": 1e-05}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 4.196550982068297, "tmin": -2.2016936548908017, "tmax": 12.846960230562287, "eps": 1e-06}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}], "error_log": []}
{"context": "Given a continued fraction represented as a list of integers, how can we convert it to a fraction, optionally limiting the denominator to a specified maximum value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `cfrac` (list of int): The continued fraction represented as a list of integers.\n  `limit_denom` (int, optional): The maximum allowed denominator. If None, no limit is applied.\n\nOutput:\n  `return` (dict): A dictionary containing the numerator and denominator of the resulting fraction.\n    - `numerator` (int): The numerator of the resulting fraction.\n    - `denominator` (int): The denominator of the resulting fraction.", "reference_code": "# import necessary packages\nfrom fractions import Fraction\nfrom math import floor\n\n# main function\ndef main_solution(cfrac, limit_denom=None):\n    \"\"\"\n    Convert a continued fraction to a Fraction, optionally limiting the denominator.\n    \n    Parameters:\n    cfrac (list of int): The continued fraction represented as a list of integers.\n    limit_denom (int, optional): The maximum allowed denominator. If None, no limit is applied.\n    \n    Returns:\n    dict: A dictionary containing the numerator and denominator of the resulting fraction.\n    \"\"\"\n    # Convert JSON serializable inputs to the original input variables\n    cfrac = list(cfrac)\n    if limit_denom is not None:\n        limit_denom = int(limit_denom)\n    \n    # Function to convert continued fraction to a Fraction\n    def cfrac_to_fraction(cfrac, limit_denom=None):\n        terms = cfrac[:]\n        assert limit_denom is None or limit_denom >= 1\n        ans = Fraction(terms.pop(0))\n        if terms:\n            ans = ans + (Fraction(1) / cfrac_to_fraction(terms))\n        if (\n            (limit_denom is not None)\n            and (ans.denominator > limit_denom)\n            and (len(cfrac) > 1)\n        ):\n            return cfrac_to_fraction(cfrac[:-1], limit_denom)\n        return ans\n    \n    # Convert the continued fraction to a Fraction\n    frac = cfrac_to_fraction(cfrac, limit_denom)\n    \n    # Convert the Fraction to JSON serializable output\n    return {\"numerator\": frac.numerator, \"denominator\": frac.denominator}", "input_generator": "import random\nfrom fractions import Fraction\n\ndef input_generator():\n    # Generate a random continued fraction with length between 1 and 5\n    length = random.randint(1, 5)\n    cfrac = [random.randint(1, 10) for _ in range(length)]\n    \n    # Randomly decide whether to include limit_denom\n    if random.choice([True, False]):\n        # Generate a reasonable limit_denom, ensuring it's at least 1\n        limit_denom = random.randint(1, 100)\n    else:\n        limit_denom = None\n    \n    return {\"cfrac\": cfrac, \"limit_denom\": limit_denom}", "io_pairs": [{"input": {"cfrac": [2], "limit_denom": null}, "output": {"numerator": 2, "denominator": 1}}, {"input": {"cfrac": [4, 7, 9, 8], "limit_denom": 72}, "output": {"numerator": 265, "denominator": 64}}, {"input": {"cfrac": [5, 9, 10, 1, 4], "limit_denom": 82}, "output": {"numerator": 46, "denominator": 9}}, {"input": {"cfrac": [8, 7, 5], "limit_denom": 18}, "output": {"numerator": 57, "denominator": 7}}, {"input": {"cfrac": [4, 8], "limit_denom": 5}, "output": {"numerator": 4, "denominator": 1}}, {"input": {"cfrac": [1, 10, 1, 5], "limit_denom": 37}, "output": {"numerator": 12, "denominator": 11}}, {"input": {"cfrac": [7, 10, 5, 1], "limit_denom": 65}, "output": {"numerator": 433, "denominator": 61}}, {"input": {"cfrac": [6, 5], "limit_denom": 99}, "output": {"numerator": 31, "denominator": 5}}, {"input": {"cfrac": [5], "limit_denom": 62}, "output": {"numerator": 5, "denominator": 1}}, {"input": {"cfrac": [10, 7], "limit_denom": null}, "output": {"numerator": 71, "denominator": 7}}], "error_log": []}
{"context": "Given an 8x8 chessboard and 8 queens, where each queen is initially placed in a different column but may have conflicting rows, how many distinct ways can the queens be rearranged such that no two queens threaten each other?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_queen_positions` (list of integers): A list of 8 integers representing the initial positions of the queens on an 8x8 chessboard. Each integer should be between 0 and 7, inclusive.\n\nOutput:\n  `return` (integer): The number of distinct solutions to the 8-queens problem starting from the given initial queen positions.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef update(queen, row):\n    for i in range(8):\n        queen[row] = i\n        if find_elements(queen, row):\n            if row == 7:\n                globals()[\"solutions\"] += 1\n            else:\n                update(queen, row + 1)\n            \ndef find_elements(queen, row):\n    c = 0\n    result = True\n    for i in range(row):\n        c += 1\n        current = queen[row]\n        other = queen[row - i - 1]\n        if (current == other) or (current - c == other) or (current + c == other):\n            result = False\n            break\n    return result\n\n# main function\ndef main_solution(initial_queen_positions):\n    # Convert the input list to a list of integers\n    queen = list(initial_queen_positions)\n    \n    # Initialize the solution counter\n    globals()[\"solutions\"] = 0\n    \n    # Start the recursive update process\n    for i in range(8):\n        queen[0] = i\n        update(queen, 1)\n    \n    # Return the number of solutions found\n    return globals()[\"solutions\"]", "input_generator": "import random\n\ndef input_generator():\n    # Generate a list of 8 integers, each between 0 and 7, representing initial queen positions\n    # The first few positions might be fixed or random, but the rest can be arbitrary since they'll be updated\n    initial_queen_positions = [random.randint(0, 7) for _ in range(8)]\n    return {\"initial_queen_positions\": initial_queen_positions}", "io_pairs": [{"input": {"initial_queen_positions": [3, 4, 1, 7, 4, 2, 7, 5]}, "output": 92}, {"input": {"initial_queen_positions": [2, 2, 3, 7, 0, 4, 2, 6]}, "output": 92}, {"input": {"initial_queen_positions": [0, 7, 0, 3, 7, 7, 7, 0]}, "output": 92}, {"input": {"initial_queen_positions": [1, 3, 1, 1, 1, 1, 7, 1]}, "output": 92}, {"input": {"initial_queen_positions": [2, 7, 7, 0, 4, 1, 5, 3]}, "output": 92}, {"input": {"initial_queen_positions": [1, 2, 3, 6, 4, 2, 3, 7]}, "output": 92}, {"input": {"initial_queen_positions": [4, 3, 7, 4, 0, 3, 0, 6]}, "output": 92}, {"input": {"initial_queen_positions": [7, 1, 1, 3, 2, 5, 0, 3]}, "output": 92}, {"input": {"initial_queen_positions": [4, 5, 6, 4, 1, 7, 0, 2]}, "output": 92}, {"input": {"initial_queen_positions": [2, 3, 3, 5, 7, 3, 2, 7]}, "output": 92}], "error_log": []}
{"context": "Given two sets of 2D points, what is the modified Hausdorff distance between them? The modified Hausdorff distance is a measure of similarity between two sets of points, considering the maximum of the directed distances from each point in one set to the nearest point in the other set.\n\nThe input and output requirements are as follows:\n\nInput:\n  `points_set_A` (List of tuples): Each tuple represents a 2D point in set A. Example: `[(1, 2), (3, 4)]`.\n  `points_set_B` (List of tuples): Each tuple represents a 2D point in set B. Example: `[(5, 6), (7, 8)]`.\n\nOutput:\n  `return` (Float): The modified Hausdorff distance between the two sets of 2D points.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef modified_hausdorff_distance(A, B):\n    \"\"\"\n    Calculate modified hausdorff distance for 2D points sets\n\n    A modified Hausdorff distance for object matching\n    doi: 10.1109/ICPR.1994.576361\n\n    :param A: 2D points set\n    :param B: 2D points set\n    :return: MDH - undirected distance\n    \"\"\"\n    return np.max([directed_distance(A, B), directed_distance(B, A)])\n\ndef directed_distance(A, B):\n    \"\"\"\n    Calculate directed distance between two sets of 2D points\n    :param A: 2D points set\n    :param B: 2D points set\n    :return: directed sitance\n    \"\"\"\n    Na = len(A)\n    sum = 0\n    for a in A:\n        sum += distance_between_point_and_set(a, B)\n    return sum/Na\n\ndef distance_between_point_and_set(a, B):\n    \"\"\"\n    Calculate distance between point and a set\n\n    :param a: is a 2D point\n    :param B: is set of 2D points\n    :return: distance between point and set\n    \"\"\"\n    distances = [euclid_distance(a, b) for b in B]\n    return np.min(distances)\n\ndef euclid_distance(a, b):\n    \"\"\"\n    Calculate euclid distance between two 2D points\n\n    :param a: 2D point\n    :param b: 2D point\n    :return: euclid distance\n    \"\"\"\n    dist = np.linalg.norm(a - b)\n    return dist\n\n# main function\ndef main_solution(points_set_A, points_set_B):\n    \"\"\"\n    Calculate the modified Hausdorff distance between two sets of 2D points.\n\n    :param points_set_A: List of tuples, where each tuple represents a 2D point in set A.\n    :param points_set_B: List of tuples, where each tuple represents a 2D point in set B.\n    :return: Float, the modified Hausdorff distance between the two sets.\n    \"\"\"\n    # Convert input lists to numpy arrays\n    A = np.array(points_set_A)\n    B = np.array(points_set_B)\n    \n    # Calculate the modified Hausdorff distance\n    mdh_distance = modified_hausdorff_distance(A, B)\n    \n    # Return the result as a float\n    return float(mdh_distance)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly decide the number of points in each set (between 1 and 20)\n    n_A = random.randint(1, 20)\n    n_B = random.randint(1, 20)\n    \n    # Generate random points in the range [0, 100) for both sets\n    points_set_A = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(n_A)]\n    points_set_B = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(n_B)]\n    \n    return {\n        'points_set_A': points_set_A,\n        'points_set_B': points_set_B\n    }", "io_pairs": [{"input": {"points_set_A": [[75.077755617849, 78.10726355906327], [47.23264961836134, 31.63360086366359], [69.59614460564667, 94.10831175520099], [87.6981829626213, 93.85384284532793]], "points_set_B": [[37.42926188977267, 0.4508724008638332]]}, "output": 81.02182421091915}, {"input": {"points_set_A": [[11.785662084039906, 81.74938346467908], [39.03077712560733, 22.41207222566558]], "points_set_B": [[46.01447926373099, 18.616728278292204]]}, "output": 39.88151500274127}, {"input": {"points_set_A": [[93.92859553054281, 6.459013826010763]], "points_set_B": [[71.62370160366297, 27.308684771389025], [7.214354518876798, 68.7216209307171], [31.770397043974707, 44.88711788057982]]}, "output": 70.12067112884891}, {"input": {"points_set_A": [[76.25809944645398, 99.98762087779323], [65.52770377545036, 7.878597677707511]], "points_set_B": [[47.87526480857529, 4.694199665231613], [66.76165396912981, 2.1101164484877533]]}, "output": 52.11804976900295}, {"input": {"points_set_A": [[4.973402674250971, 92.01597308375477], [54.13791792694671, 67.29395971941123]], "points_set_B": [[82.85676573866594, 53.59355601639271]]}, "output": 59.332326081720204}, {"input": {"points_set_A": [[74.00949991069325, 4.239767428813845], [18.879181106694396, 61.66980589856682]], "points_set_B": [[28.418249245570383, 4.111495689254774], [88.65467308014918, 90.7457863575514]]}, "output": 60.59132350124881}, {"input": {"points_set_A": [[65.19031939710226, 83.57853424475093]], "points_set_B": [[93.97632730549778, 47.996956856791265], [7.899598242182648, 12.873499763596497], [15.331455187062959, 44.87936141575436]]}, "output": 66.6284304779811}, {"input": {"points_set_A": [[96.25179563258705, 82.6580776231457], [70.44253825135937, 43.210339745671654], [64.35095213745174, 88.03974852690375], [7.204711389545193, 73.69548525110883]], "points_set_B": [[92.66586981612195, 33.6509683411677]]}, "output": 57.25646662561133}, {"input": {"points_set_A": [[48.53852695438064, 16.222891390758665], [75.28667494767436, 77.73690162334643], [9.103397181481366, 35.42438912492477]], "points_set_B": [[31.724472495816325, 93.14360796383009], [13.572260616923714, 3.044274743041653]]}, "output": 39.44672341199579}, {"input": {"points_set_A": [[58.285373678870954, 65.48747227867328], [25.05754173310436, 30.936920417770807], [76.32469942308802, 23.27113702781345]], "points_set_B": [[43.023937371395235, 28.824177623188973]]}, "output": 30.52120091422384}], "error_log": []}
{"context": "Given a range of numbers defined by a minimum and maximum value, and a specific number of digits, how many numbers within this range meet the criteria for either part 'a' or part 'b' of the problem? Part 'a' requires that at least two adjacent digits are the same, while part 'b' requires that at least one digit appears exactly twice consecutively.\n\nThe input and output requirements are as follows:\n\nInput:\n  `part` (str): A string indicating the part of the problem to solve, either 'a' or 'b'.\n  `digits` (int): An integer representing the number of digits in the range.\n  `minimum` (str): A string representing the minimum value of the range.\n  `maximum` (str): A string representing the maximum value of the range.\n\nOutput:\n  `return` (int): An integer representing the count of valid numbers within the specified range based on the problem part.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ncache = {}\ndef cases(part, digits, last_digit, last_digit_count, double, minimum, maximum):\n    state = (digits, last_digit, last_digit_count, double, minimum, maximum)\n    if state in cache:\n        return cache[state]\n    count = 0\n    minimum_first_digit = int(minimum[0])\n    maximum_first_digit = int(maximum[0])\n\n    min_digit = max(minimum_first_digit, last_digit)\n    max_digit = min(maximum_first_digit, 9)\n\n    for d in range(min_digit, max_digit + 1):\n        if part == 'a':\n           new_double = double or (d == last_digit)\n           new_last_digit_count = 0\n        else:\n           new_double = double or (d != last_digit and last_digit_count == 2)\n           if d == last_digit:\n               new_last_digit_count = last_digit_count + 1\n           else:\n               new_last_digit_count = 1     \n\n        new_minimum = \"0\"*(digits-1)\n        new_maximum = \"9\"*(digits-1)\n        if d == min_digit:\n            new_minimum = minimum[1:]\n        if d == max_digit:\n            new_maximum = maximum[1:]\n\n        if digits == 1:\n            if new_double or (d == last_digit and last_digit_count == 1):\n                count += 1\n        else:\n            count += cases(part, digits-1, d, new_last_digit_count, new_double, new_minimum, new_maximum)\n    cache[state] = count\n    return count\n\n# main function\ndef main_solution(part, digits, minimum, maximum):\n    # Convert JSON serializable inputs to original input variables\n    last_digit = -1\n    last_digit_count = 0\n    double = False\n    \n    # Call the original function with converted inputs\n    result = cases(part, digits, last_digit, last_digit_count, double, minimum, maximum)\n    \n    # Return the result, which is already JSON serializable\n    return result", "input_generator": "import random\n\ndef input_generator():\n    part = random.choice(['a', 'b'])\n    digits = random.randint(4, 6)\n    min_num = random.randint(1000, 5000)\n    max_num = random.randint(min_num + 1000, min_num + 5000)\n    minimum = str(min_num).zfill(digits)\n    maximum = str(max_num).zfill(digits)\n    return {\n        'part': part,\n        'digits': digits,\n        'minimum': minimum,\n        'maximum': maximum\n    }", "io_pairs": [{"input": {"part": "a", "digits": 6, "minimum": "002757", "maximum": "007466"}, "output": 205}, {"input": {"part": "b", "digits": 4, "minimum": "4725", "maximum": "6701"}, "output": 34}, {"input": {"part": "a", "digits": 6, "minimum": "002971", "maximum": "004815"}, "output": 137}, {"input": {"part": "a", "digits": 5, "minimum": "03396", "maximum": "06694"}, "output": 123}, {"input": {"part": "a", "digits": 4, "minimum": "2301", "maximum": "3586"}, "output": 95}, {"input": {"part": "b", "digits": 5, "minimum": "02288", "maximum": "06313"}, "output": 153}, {"input": {"part": "a", "digits": 5, "minimum": "03826", "maximum": "05768"}, "output": 72}, {"input": {"part": "a", "digits": 4, "minimum": "2228", "maximum": "5541"}, "output": 189}, {"input": {"part": "a", "digits": 6, "minimum": "001713", "maximum": "004993"}, "output": 269}, {"input": {"part": "b", "digits": 6, "minimum": "001416", "maximum": "003673"}, "output": 242}], "error_log": []}
{"context": "In a game of polyominoes, two players, Richard and Gabriel, take turns placing polyominoes on a grid. Given the size of the polyomino `X`, and the dimensions of the grid `R` (rows) and `C` (columns), determine who will win the game if both players play optimally. The winner is determined based on specific rules related to the size of the polyomino and the grid dimensions. Who will win the game, Richard or Gabriel?\n\nThe input and output requirements are as follows:\n\nInput:\n  `X` (int): The size of the polyomino (number of squares in the shape).\n  `R` (int): The number of rows in the grid.\n  `C` (int): The number of columns in the grid.\n\nOutput:\n  `return` (str): The name of the winner (\"RICHARD\" or \"GABRIEL\") based on the given conditions.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef getDimList(X):\n    return [(w, X-w+1) for w in range(1, (X+1)//2+1)]\n\ndef WorstBlockWillCutBoardInHalf(X, R, C):\n    a = min(R, C)\n    b = max(R, C)\n    dims = getDimList(X)\n    if a >= 2 and any([a == min(d) for d in dims]):\n        return True\n    else:\n        return False\n\ndef worstBlockWillFit(X, R, C):\n    a = min(R, C)\n    b = max(R, C)\n    if all([x <= a and y <= b for (x, y) in getDimList(X)]):\n        return True\n    else:\n        return False\n\n# main function\ndef main_solution(X, R, C):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if X >= 7:\n        return \"RICHARD\"\n\n    if R * C % X != 0:\n        return \"RICHARD\"\n\n    if X in [1, 2]:\n        return \"GABRIEL\"\n\n    if X == 3:\n        if min(R, C) == 1:\n            return \"RICHARD\"\n        else:\n            return \"GABRIEL\"\n\n    if worstBlockWillFit(X, R, C):\n        if WorstBlockWillCutBoardInHalf(X, R, C):\n            return \"RICHARD\"\n        else:\n            return \"GABRIEL\"\n    else:\n        return \"RICHARD\"", "input_generator": "import random\n\ndef input_generator():\n    X = random.randint(1, 10)\n    R = random.randint(1, 20)\n    C = random.randint(1, 20)\n    return {'X': X, 'R': R, 'C': C}", "io_pairs": [{"input": {"X": 9, "R": 7, "C": 18}, "output": "RICHARD"}, {"input": {"X": 1, "R": 16, "C": 7}, "output": "GABRIEL"}, {"input": {"X": 4, "R": 11, "C": 17}, "output": "RICHARD"}, {"input": {"X": 8, "R": 19, "C": 16}, "output": "RICHARD"}, {"input": {"X": 1, "R": 3, "C": 4}, "output": "GABRIEL"}, {"input": {"X": 9, "R": 10, "C": 8}, "output": "RICHARD"}, {"input": {"X": 1, "R": 15, "C": 9}, "output": "GABRIEL"}, {"input": {"X": 10, "R": 8, "C": 3}, "output": "RICHARD"}, {"input": {"X": 6, "R": 5, "C": 6}, "output": "GABRIEL"}, {"input": {"X": 10, "R": 12, "C": 10}, "output": "RICHARD"}], "error_log": []}
{"context": "Given two normal distributions P and Q, where P has a mean of `mean_p` and a standard deviation of `std_p`, and Q has a mean of `mean_q` and a standard deviation of `std_q`, what is the Kullback-Leibler divergence between these two distributions over a range of x values from `x_range[0]` to `x_range[1]` with a step size of `x_range[2]`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `mean_p` (float): Mean of the first normal distribution P.\n  `std_p` (float): Standard deviation of the first normal distribution P.\n  `mean_q` (float): Mean of the second normal distribution Q.\n  `std_q` (float): Standard deviation of the second normal distribution Q.\n  `x_range` (list of floats): A list containing the start, end, and step size for the range of x values.\n\nOutput:\n  `return` (dict): A dictionary containing the key `kl_divergence` with the value being the calculated KL-divergence between the two distributions as a float.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy.stats import norm\n\n# main function\ndef main_solution(mean_p, std_p, mean_q, std_q, x_range):\n  # Convert JSON serializable inputs to numpy arrays\n  x = np.arange(x_range[0], x_range[1], x_range[2])\n  p = norm.pdf(x, mean_p, std_p)\n  q = norm.pdf(x, mean_q, std_q)\n  \n  # Calculate KL-divergence\n  kl_div = np.sum(np.where(p != 0, p * np.log(p / q), 0))\n  \n  # Return the result as a JSON serializable output\n  return {\"kl_divergence\": float(kl_div)}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    mean_p = random.uniform(-10, 10)\n    std_p = random.uniform(0.1, 5)\n    mean_q = random.uniform(-10, 10)\n    std_q = random.uniform(0.1, 5)\n    start = random.uniform(-20, 0)\n    end = random.uniform(0, 20)\n    step = random.uniform(0.1, 1.0)\n    x_range = [start, end, step]\n    return {\n        \"mean_p\": mean_p,\n        \"std_p\": std_p,\n        \"mean_q\": mean_q,\n        \"std_q\": std_q,\n        \"x_range\": x_range\n    }", "io_pairs": [{"input": {"mean_p": -3.1052667443544664, "std_p": 2.4856498420989843, "mean_q": -2.9176962582095367, "std_q": 2.2566396134771423, "x_range": [-15.83583196485783, 3.2528220567735167, 0.1623104396399367]}, "output": {"kl_divergence": 0.0651664093271481}}, {"input": {"mean_p": 5.361008423231333, "std_p": 1.0616446850248173, "mean_q": -2.209479133056065, "std_q": 1.0612158592887362, "x_range": [-13.217184926391951, 10.504222918913195, 0.5532796045844929]}, "output": {"kl_divergence": 45.990087844605235}}, {"input": {"mean_p": -2.2777711997279386, "std_p": 4.278875051260172, "mean_q": -2.750359908133719, "std_q": 1.8074758127750181, "x_range": [-3.8708937228088836, 15.282905578527803, 0.2586997061492607]}, "output": {"kl_divergence": 3.2999657932976802}}, {"input": {"mean_p": 2.5017484133523666, "std_p": 4.357415501430439, "mean_q": -2.5874982416068315, "std_q": 0.407008155363053, "x_range": [-13.436255044128472, 2.1305555890804695, 0.5558351979040739]}, "output": {"kl_divergence": 21.884122904287356}}, {"input": {"mean_p": -2.6505290117132363, "std_p": 4.986728476554983, "mean_q": -1.0300246429373985, "std_q": 0.3731260778724693, "x_range": [-9.612065346688912, 8.400087039399647, 0.6481461264914966]}, "output": {"kl_divergence": 87.27356757494309}}, {"input": {"mean_p": 3.179328727758099, "std_p": 0.7643132637286185, "mean_q": -2.9121836848028266, "std_q": 1.605073865456296, "x_range": [-8.474543021540683, 3.4554757138215386, 0.4653363310031732]}, "output": {"kl_divergence": 8.503492887133056}}, {"input": {"mean_p": -6.97119582354931, "std_p": 2.0951100704522148, "mean_q": -4.907545120854159, "std_q": 3.9818462850446874, "x_range": [-17.97708469756715, 6.331169475941259, 0.4918567168397675]}, "output": {"kl_divergence": 0.8434653342453577}}, {"input": {"mean_p": -9.6934462461052, "std_p": 1.3973255007875813, "mean_q": 7.653552431221058, "std_q": 0.8718682329366663, "x_range": [-2.207142146319878, 10.262624214213282, 0.1028004246696577]}, "output": {"kl_divergence": 2.2877862080440408e-05}}, {"input": {"mean_p": -9.609847539958736, "std_p": 0.6401743315058772, "mean_q": -1.859926143423614, "std_q": 0.39552660628973046, "x_range": [-19.07859364623175, 11.280840088681783, 0.5346349518572904]}, "output": {"kl_divergence": Infinity}}, {"input": {"mean_p": -6.828726575723712, "std_p": 0.3017212474402402, "mean_q": 0.8311410692917462, "std_q": 2.059254619854719, "x_range": [-3.4256027446828554, 19.07409652310392, 0.8075006658499299]}, "output": {"kl_divergence": -1.8683802769208896e-26}}], "error_log": []}
{"context": "Given a set of elements, how can we determine the representative elements of the disjoint sets formed by grouping these elements based on certain union operations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `elements` (list of integers): A list of integers representing the elements to be grouped into disjoint sets.\n\nOutput:\n  `return` (dictionary): A dictionary where the keys are the elements from the input list and the values are the representative elements of the disjoint sets they belong to.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, data):\n        self.parent = self\n        self.rank = 0\n        self.data = data\n\ndef make_set(x):\n    \"\"\"\n    \u521b\u5efa\u96c6\u5408\n    :param x:\n    :return:\n    \"\"\"\n    node = Node(data=x)\n    return node\n\ndef find_set(node):\n    if node != node.parent:\n        node.parent = find_set(node.parent) # \u8def\u5f84\u538b\u7f29\n    return node\n\ndef _link(node1, node2):\n    if not node1 or not node2:\n        return node1 if node1 else node2\n\n    if node1.rank >= node2.rank:\n        node2.parent = node1\n        if node1.rank == node2.rank:\n            node1.rank += 1\n        return node1\n    else:\n        node1.parent = node2\n        return node2\n\ndef union_set(node1, node2):\n    _link(find_set(node1), find_set(node2))\n\n# main function\ndef main_solution(elements):\n    # elements: list of integers representing the elements to be grouped into disjoint sets\n    nodes = {elem: make_set(elem) for elem in elements}\n    \n    # Randomly union some sets\n    for _ in range(len(elements) // 2):\n        elem1, elem2 = random.sample(elements, 2)\n        union_set(nodes[elem1], nodes[elem2])\n    \n    # Find the representative of each element\n    representatives = {elem: find_set(nodes[elem]).data for elem in elements}\n    \n    # Return the representatives as a dictionary\n    return representatives", "input_generator": "import random\n\ndef input_generator():\n    num_elements = random.randint(5, 20)\n    elements = random.sample(range(1, 100), num_elements)\n    return {'elements': elements}", "io_pairs": [{"input": {"elements": [95, 8, 32, 7, 53, 55, 46, 68, 81]}, "output": {"95": 95, "8": 8, "32": 32, "7": 7, "53": 53, "55": 55, "46": 46, "68": 68, "81": 81}}, {"input": {"elements": [12, 2, 40, 53, 19, 33]}, "output": {"12": 12, "2": 2, "40": 40, "53": 53, "19": 19, "33": 33}}, {"input": {"elements": [1, 82, 4, 27, 43, 89, 74, 5, 13, 48, 95]}, "output": {"1": 1, "82": 82, "4": 4, "27": 27, "43": 43, "89": 89, "74": 74, "5": 5, "13": 13, "48": 48, "95": 95}}, {"input": {"elements": [69, 32, 16, 63, 92, 77, 59, 91, 46, 55, 93, 71]}, "output": {"69": 69, "32": 32, "16": 16, "63": 63, "92": 92, "77": 77, "59": 59, "91": 91, "46": 46, "55": 55, "93": 93, "71": 71}}, {"input": {"elements": [39, 28, 76, 80, 22, 93, 20, 49, 72]}, "output": {"39": 39, "28": 28, "76": 76, "80": 80, "22": 22, "93": 93, "20": 20, "49": 49, "72": 72}}, {"input": {"elements": [84, 95, 51, 29, 77, 66, 88, 59, 48, 18]}, "output": {"84": 84, "95": 95, "51": 51, "29": 29, "77": 77, "66": 66, "88": 88, "59": 59, "48": 48, "18": 18}}, {"input": {"elements": [2, 63, 23, 50, 95]}, "output": {"2": 2, "63": 63, "23": 23, "50": 50, "95": 95}}, {"input": {"elements": [56, 24, 17, 98, 30, 27, 26]}, "output": {"56": 56, "24": 24, "17": 17, "98": 98, "30": 30, "27": 27, "26": 26}}, {"input": {"elements": [11, 82, 49, 83, 10, 25, 17, 7, 43, 50, 45]}, "output": {"11": 11, "82": 82, "49": 49, "83": 83, "10": 10, "25": 25, "17": 17, "7": 7, "43": 43, "50": 50, "45": 45}}, {"input": {"elements": [22, 85, 2, 28, 76, 92, 12]}, "output": {"22": 22, "85": 85, "2": 2, "28": 28, "76": 76, "92": 92, "12": 12}}], "error_log": []}
{"context": "Given the amount of nitrogen fertilizer applied and whether irrigation is used, what is the projected gross profit for a crop in a year?\n\nThe input and output requirements are as follows:\n\nInput:\n  `NFert` (float): The amount of nitrogen fertilizer in kg/ha.\n  `irrigation` (bool): A boolean indicating whether irrigation is applied (True) or not (False).\n\nOutput:\n  `return` (dict): A dictionary containing the key `profit` with the value being the gross profit in dollars.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass hectareCrop(object):\n    '''Used to project yearly yield for a crop based on fertilizer and rainfall \n    inputs.\n    '''\n    def __init__(self, NFert, irrigation):\n        self.NFert = NFert\n        self.irrigation = irrigation\n        \n    def rainfall(self):\n        '''returns an annual rainfall amount based on normal probability distribution.\n        Average rainfall during growth period is 50 cm and a standard deviation of 20 cm \n        return self.rainAmt\n        '''\n        mu, sigma = 50, 20\n        rainAmt = random.gauss(mu, sigma)\n        self.rainAmt = rainAmt\n        return self.rainAmt\n        \n    def Nloss(self):\n        '''Loss of N based on amount of rainfall that occurred.  For every cm of rain,\n        3.0% loss of N occurs.\n        Runs self.rainfall() to get self.rainAmt, returns an int of NAmt remaining based\n        on yearly rainfall.  Int returned is not a object variable and does not replace\n        self.NAmt\n        '''\n        self.rainfall()\n        NAmt = self.NFert - 0.0003 * self.rainAmt * self.NFert\n        self.NAmt = int(NAmt)\n        return self.NAmt\n        \n    def cropYield(self):\n        '''Predicts the yearly yield of a crop based on rainfall and fertilizer\n        inputs.\n        Average yield is 100 bushels per acre based on average rainfall and 200 kg/ha\n        per year N fertility.  A very basic model was used to predict yield where\n        yield = rainAmt + (0.25 * N amt in kg/ha).  Need to use NAmt after rainfall\n        for calcualtion.  \n        RETURN: self.yearYield wich is the yield in bushels per acre\n        '''\n        yearYield = self.rainfall() + (0.25 * self.Nloss())\n        self.yearYield = yearYield\n        return self.yearYield\n        \n    def profit(self):\n        '''Assume $7 dollar per bushel yield.  However, a loss of $10 for each cm below \n        50 cm.  If irrigation is True, rainfall is supplemented up to 50 cm if it is \n        below.  If rainfall is 50 cm or greater, no additional irrigation takes\n        place.\n        RETURN grossProfit, not an object attribute\n        '''\n        self.cropYield()\n        if self.rainAmt < 50:\n            if self.irrigation:\n                self.rainAmt = 50\n            grossProfit = self.yearYield * 7 - (50 - self.rainAmt) * 10\n        else:\n            grossProfit = self.yearYield * 7               \n        return grossProfit\n\n# main function\ndef main_solution(NFert, irrigation):\n    # Convert JSON serializable inputs to original input variables\n    NFert = float(NFert)\n    irrigation = bool(irrigation)\n    \n    # Create an instance of hectareCrop\n    crop = hectareCrop(NFert, irrigation)\n    \n    # Calculate the profit\n    profit = crop.profit()\n    \n    # Convert the output to JSON serializable\n    return {\"profit\": profit}", "input_generator": "import random\n\ndef input_generator():\n    NFert = random.uniform(100, 300)  # Reasonable range for fertilizer amount in kg/ha\n    irrigation = random.choice([True, False])\n    return {\"NFert\": NFert, \"irrigation\": irrigation}", "io_pairs": [{"input": {"NFert": 224.32381086839177, "irrigation": true}, "output": {"profit": 676.3078494388257}}, {"input": {"NFert": 158.85502063715273, "irrigation": false}, "output": {"profit": 584.2336377568777}}, {"input": {"NFert": 271.7626265448557, "irrigation": false}, "output": {"profit": 644.6012504608138}}, {"input": {"NFert": 138.4804173268949, "irrigation": false}, "output": {"profit": 325.10664399834593}}, {"input": {"NFert": 118.30242982707495, "irrigation": false}, "output": {"profit": 517.0006125682505}}, {"input": {"NFert": 156.9529334284395, "irrigation": true}, "output": {"profit": 524.1684135047587}}, {"input": {"NFert": 109.71684017454785, "irrigation": true}, "output": {"profit": 500.60263478478623}}, {"input": {"NFert": 238.15377388402143, "irrigation": false}, "output": {"profit": 727.1924891283702}}, {"input": {"NFert": 160.88079108268317, "irrigation": false}, "output": {"profit": 591.5355183293697}}, {"input": {"NFert": 168.332152310044, "irrigation": true}, "output": {"profit": 790.735093319445}}], "error_log": []}
{"context": "In the game of Ultimate Tic Tac Toe, players make moves on a grid of 9 individual Tic Tac Toe boards. Each move sends the opponent to a specific board based on the square chosen. Given a sequence of moves, determine the status of the game after these moves. What is the status of the game after the given moves?\n\nThe input and output requirements are as follows:\n\nInput:\n  `moves` (list of tuples): A list of moves, where each move is a tuple `(board_number, square)`. `board_number` is an integer between 1 and 9 representing the board number, and `square` is an integer between 1 and 9 representing the square on the board.\n\nOutput:\n  `return` (string): A string indicating the status of the game after the moves. Possible outputs are:\n  - \"Invalid move\" if a move is made on a filled square.\n  - \"Player X wins board Y\" if a player wins a board.\n  - \"Board Y is a draw\" if a board ends in a draw.\n  - \"Game in progress\" if the game is still ongoing after the moves.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass MultiBoard:\n    def __init__(self):\n        self.multiBoard = [SingleBoard(i) for i in range(1, 10)]\n\n    def getBoard(self, board):\n        return self.multiBoard[board - 1]\n\nclass SingleBoard:\n    def __init__(self, n):\n        self.singleBoard = [\"-\" for _ in range(1, 10)]\n        self.playerIcons = {0: \"-\", 1: \"X\", 2: \"O\"}\n        self.boardNumber = n\n\n    def changeSquare(self, player, square):\n        self.singleBoard[square - 1] = self.playerIcons[player]\n\n    def getSquare(self, square):\n        return self.singleBoard[square - 1]\n\n    def getNumber(self):\n        return self.boardNumber\n\n    def countSquaresFilled(self):\n        return 9 - self.singleBoard.count(\"-\")\n\n    def getEmptySquare(self):\n        for i, j in enumerate(self.singleBoard):\n            if j == \"-\":\n                return i + 1\n\nclass Game:\n    def __init__(self):\n        self.multiBoard = MultiBoard()\n        self.currentPlayer = 1\n        self.board = None\n        self.playerIcons = {0: \"-\", 1: \"X\", 2: \"O\"}\n        self.wins = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0}\n        self.draws = []\n\n    def detectBoardWin(self):\n        if self.wins[self.board.getNumber()]:\n            return False\n        rows = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]\n        for row in rows:\n            for square in row:\n                if self.board.getSquare(square + 1) != self.playerIcons[self.currentPlayer]:\n                    break\n            else:\n                return True\n        return False\n\n    def detectBoardDraw(self):\n        if self.board.countSquaresFilled() == 9:\n            if not self.detectBoardWin():\n                return True\n        elif self.board.countSquaresFilled() == 8:\n            emptysquare = self.board.getEmptySquare()\n            self.board.changeSquare(1, emptysquare)\n            if self.detectBoardWin():\n                self.board.changeSquare(0, emptysquare)\n                return False\n            self.board.changeSquare(2, emptysquare)\n            if self.detectBoardWin():\n                self.board.changeSquare(0, emptysquare)\n                return False\n            self.board.changeSquare(0, emptysquare)\n            return True\n        return False\n\n    def detectDrawnGame(self):\n        emptyBoards = [i for i in range(1, 10) if i not in self.draws and not self.wins[i]]\n        for empty in emptyBoards:\n            self.wins[empty] = 1\n        if self.detectPlayerWin(1):\n            for empty in emptyBoards:\n                self.wins[empty] = 0\n            return False\n        for empty in emptyBoards:\n            self.wins[empty] = 2\n        if self.detectPlayerWin(2):\n            for empty in emptyBoards:\n                self.wins[empty] = 0\n            return False\n        for empty in emptyBoards:\n            self.wins[empty] = 0\n        return True\n\n    def detectPlayerWin(self, player):\n        currentPlayerWins = [k for k, v in self.wins.items() if v == player]\n        rows = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]\n        for row in rows:\n            for square in row:\n                if square + 1 not in currentPlayerWins:\n                    break\n            else:\n                return True\n        return False\n\n    def getBoardWinRow(self):\n        currentPlayerWins = [k for k, v in self.wins.items() if v == self.currentPlayer]\n        rows = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]\n        for row in rows:\n            for square in row:\n                if square + 1 not in currentPlayerWins:\n                    break\n            else:\n                return tuple([i + 1 for i in row])\n        return None\n\n    def countWins(self, player):\n        return list(self.wins.values()).count(player)\n\n    def checkBoardFilled(self, board):\n        board = self.multiBoard.getBoard(board)\n        return not any(board.getSquare(square) == \"-\" for square in range(1, 10))\n\n    def checkSquareFilled(self, square):\n        return self.board.getSquare(square) != \"-\"\n\n    def makeMove(self, square):\n        self.board.changeSquare(self.currentPlayer, square)\n\n# main function\ndef main_solution(moves):\n    game = Game()\n    game.board = game.multiBoard.getBoard(1)  # Start with board 1\n    for move in moves:\n        board_number, square = move\n        game.board = game.multiBoard.getBoard(board_number)\n        if game.checkSquareFilled(square):\n            return \"Invalid move\"\n        game.makeMove(square)\n        if game.detectBoardWin():\n            return f\"Player {game.currentPlayer} wins board {game.board.getNumber()}\"\n        if game.detectBoardDraw():\n            return f\"Board {game.board.getNumber()} is a draw\"\n        game.currentPlayer = 3 - game.currentPlayer  # Switch player\n        game.board = game.multiBoard.getBoard(square)  # Next board is determined by the square chosen\n    return \"Game in progress\"", "input_generator": "import random\n\ndef input_generator():\n    num_moves = random.randint(1, 20)\n    moves = []\n    current_board = 1\n    for _ in range(num_moves):\n        square = random.randint(1, 9)\n        moves.append((current_board, square))\n        current_board = square\n    return {'moves': moves}", "io_pairs": [{"input": {"moves": [[1, 4], [4, 7], [7, 1], [1, 7], [7, 4], [4, 5], [5, 4]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 1], [1, 9], [9, 9], [9, 7], [7, 6], [6, 8], [8, 3]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 7]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 7], [7, 4], [4, 9]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 3], [3, 6]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 4], [4, 6]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 8]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 7], [7, 5], [5, 7], [7, 8], [8, 1], [1, 2], [2, 5], [5, 4]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 9]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 8], [8, 3]]}, "output": "Game in progress"}], "error_log": []}
{"context": "Given the 3D coordinates of a Carbon (C), Nitrogen (N), and Calcium (Ca) atom, what are the bond lengths between N and C, N and Ca, and the bond angle formed by the C-N-Ca atoms?\n\nThe input and output requirements are as follows:\n\nInput:\n  `C` (list of float): Coordinates of Carbon atom in 3D space.\n  `N` (list of float): Coordinates of Nitrogen atom in 3D space.\n  `Ca` (list of float): Coordinates of Calcium atom in 3D space.\n\nOutput:\n  `return` (dict): A dictionary containing the bond lengths and angle.\n                   Keys: 'N-C bond length', 'N-Ca bond length', 'C-N-Ca bond angle'\n                   Values: Bond lengths are in Angstroms (float), and the angle is in degrees (float).", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Triad:\n    \"\"\"\n    Calculate angles and distances among a triad of points.\n    \"\"\"\n    def __init__(self, p, q, r):\n        self.p = p\n        self.q = q\n        self.r = r\n\n    def d2(self, a, b):\n        return float(sum((ia - ib) * (ia - ib) for ia, ib in zip(a, b)))\n\n    def dot(self, a, b):\n        return float(sum(ia * ib for ia, ib in zip(a, b)))\n\n    def ndot(self, a, b, c):\n        return float(sum((ia - ib) * (ic - ib) for ia, ib, ic in zip(a, b, c)))\n\n    def dPQ(self):\n        return math.sqrt(self.d2(self.p, self.q))\n\n    def dQR(self):\n        return math.sqrt(self.d2(self.q, self.r))\n\n    def angleQ(self):\n        return math.acos(self.ndot(self.p, self.q, self.r) / math.sqrt(self.d2(self.p, self.q) * self.d2(self.r, self.q)))\n\n# main function\ndef main_solution(C, N, Ca):\n    \"\"\"\n    Calculates the N-C bond length, N-Ca bond length, and C-N-Ca bond angle given the 3D coordinates of C, N, and Ca.\n    \n    Input:\n        C (list of float): Coordinates of Carbon atom in 3D space.\n        N (list of float): Coordinates of Nitrogen atom in 3D space.\n        Ca (list of float): Coordinates of Calcium atom in 3D space.\n    \n    Output:\n        dict: A dictionary containing the bond lengths and angle.\n              Keys: 'N-C bond length', 'N-Ca bond length', 'C-N-Ca bond angle'\n    \"\"\"\n    triadPoints = Triad(p=C, q=N, r=Ca)\n    nToC = triadPoints.dPQ()\n    nToCa = triadPoints.dQR()\n    bondAngle = math.degrees(triadPoints.angleQ())\n    \n    return {\n        'N-C bond length': round(nToC, 2),\n        'N-Ca bond length': round(nToCa, 2),\n        'C-N-Ca bond angle': round(bondAngle, 1)\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random coordinates for C, N, Ca in 3D space\n    # Coordinates are in a reasonable range (e.g., -10.0 to 10.0)\n    C = [round(random.uniform(-10.0, 10.0), round(random.uniform(-10.0, 10.0), 2), round(random.uniform(-10.0, 10.0), 2)]\n    N = [round(random.uniform(-10.0, 10.0), round(random.uniform(-10.0, 10.0), 2), round(random.uniform(-10.0, 10.0), 2)]\n    Ca = [round(random.uniform(-10.0, 10.0), round(random.uniform(-10.0, 10.0), 2), round(random.uniform(-10.0, 10.0), 2)]\n    \n    return {\n        'C': C,\n        'N': N,\n        'Ca': Ca\n    }", "io_pairs": [], "error_log": ["STDERR:   File \"<string>\", line 48\n    C = [round(random.uniform(-10.0, 10.0), round(random.uniform(-10.0, 10.0), 2), round(random.uniform(-10.0, 10.0), 2)]\n                                                                                                                        ^\nSyntaxError: closing parenthesis ']' does not match opening parenthesis '('\n"]}
{"context": "Given the mathematical background of Bessel functions, which are solutions to certain differential equations, how would you determine the value of the Bessel function of a specified order `m` at a given point `x`? Specifically, what is the value of the Bessel function for order `m` at `x`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The order of the Bessel function.\n  `x` (float): The value at which the Bessel function is evaluated.\n\nOutput:\n  `return` (float): The value of the Bessel function of order `m` at `x`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef integrand(theta, m, x):\n    return np.cos(m * theta - x * np.sin(theta))\n\ndef trapezium(a, b, m, x):\n    area = 0\n    h = (b - a) / 10000\n    for n in range(0, 10000):\n        area += h * ((integrand(h * n, m, x) + integrand(h * (n + 1), m, x)) / 2)\n    return area\n\ndef J(m, x):\n    return 1 / np.pi * trapezium(0, np.pi, m, x)\n\n# main function\ndef main_solution(m, x):\n    # Convert input to appropriate types if necessary\n    m = int(m)\n    x = float(x)\n    \n    # Calculate the Bessel function value\n    result = J(m, x)\n    \n    # Convert output to JSON serializable format\n    return float(result)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    m = random.randint(0, 10)\n    x = random.uniform(0.1, 10.0)\n    return {'m': m, 'x': x}", "io_pairs": [{"input": {"m": 3, "x": 7.50972347917303}, "output": -0.2592852108648439}, {"input": {"m": 9, "x": 0.7608805728861169}, "output": 4.534460200251755e-10}, {"input": {"m": 7, "x": 9.6385163893057}, "output": 0.27013455713657764}, {"input": {"m": 1, "x": 4.2463678262943}, "output": -0.15434365204448625}, {"input": {"m": 2, "x": 6.982535134938354}, "output": -0.30279896157685715}, {"input": {"m": 10, "x": 7.574642811444821}, "output": 0.04182547923663073}, {"input": {"m": 6, "x": 6.171332072759764}, "output": 0.2654057283322244}, {"input": {"m": 3, "x": 9.84368610295091}, "output": 0.020509536944434418}, {"input": {"m": 1, "x": 5.719451857942465}, "output": -0.32182057010509546}, {"input": {"m": 4, "x": 7.814842717606119}, "output": -0.059521649107047866}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = x \\cdot e^x - x^2 - 5x - 3 \\), we want to find an approximate root using an iterative method. The method involves an initial guess `xi`, a tolerance level `tol`, a maximum number of iterations `iter_max`, and a type of error calculation `error_type`. What is the estimated root, the number of iterations performed, and the final error value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `xi` (float): Initial guess for the root.\n  `tol` (float): Tolerance level for the error.\n  `iter_max` (int): Maximum number of iterations allowed.\n  `error_type` (int): Type of error calculation. If `1`, relative error is used; otherwise, absolute error is used.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `root` (float): The estimated root of the function.\n    - `iterations` (int): The number of iterations performed.\n    - `error` (float): The final error value.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef f(x): \n    return x * math.exp(x) - math.pow(x, 2) - 5 * x - 3 \n\ndef g(x): \n    return (x * math.exp(x) - math.pow(x, 2) - 3) / 5\n\n# main function\ndef main_solution(xi, tol, iter_max, error_type):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    x, fx, e = xi, f(xi), tol + 1\n    n = 0\n\n    while e > tol and fx != 0 and n < iter_max - 1:\n        x = g(xi)\n        fx = f(x)\n        e = (x - xi) \n        if error_type == 1:\n            e /= x\n        e = abs(e) \n        xi = x\n        n += 1\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"root\": x, \"iterations\": n, \"error\": e}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    xi = random.uniform(-5.0, 5.0)\n    tol = 10 ** random.uniform(-6, -2)\n    iter_max = random.randint(10, 100)\n    error_type = random.choice([0, 1])\n    return {\"xi\": xi, \"tol\": tol, \"iter_max\": iter_max, \"error_type\": error_type}", "io_pairs": [{"input": {"xi": 1.4798207454948242, "tol": 1.345240999079067e-05, "iter_max": 93, "error_type": 1}, "output": {"root": -0.7998336149915364, "iterations": 12, "error": 1.0321218812110263e-05}}, {"input": {"xi": -0.6388174360505205, "tol": 6.004312589666757e-06, "iter_max": 76, "error_type": 0}, "output": {"root": -0.7998350052433627, "iterations": 10, "error": 5.531398085789618e-06}}, {"input": {"xi": -3.1684258897699147, "tol": 0.003784351222553721, "iter_max": 89, "error_type": 1}, "output": {"root": -0.8003916093660924, "iterations": 10, "error": 0.001354117599205517}}, {"input": {"xi": -0.08614255391077297, "tol": 6.0993728866898276e-06, "iter_max": 11, "error_type": 0}, "output": {"root": -0.7998284808814623, "iterations": 10, "error": 1.8314422122411855e-05}}, {"input": {"xi": -2.8934107068651493, "tol": 0.000569171535037368, "iter_max": 89, "error_type": 1}, "output": {"root": -0.7999417411534782, "iterations": 11, "error": 0.0002544534448196457}}, {"input": {"xi": -3.853894033716606, "tol": 2.352237810801523e-05, "iter_max": 99, "error_type": 0}, "output": {"root": -0.7998454758256544, "iterations": 16, "error": 1.4982686298070647e-05}}, {"input": {"xi": -0.6935589318962272, "tol": 4.56710003700892e-06, "iter_max": 55, "error_type": 0}, "output": {"root": -0.7998359005566898, "iterations": 10, "error": 3.7772575428585142e-06}}, {"input": {"xi": -3.65087514401373, "tol": 3.04621243026585e-06, "iter_max": 41, "error_type": 0}, "output": {"root": -0.7998389185605934, "iterations": 17, "error": 2.1357148446421448e-06}}, {"input": {"xi": -0.4614699699974789, "tol": 0.0004651858229290568, "iter_max": 27, "error_type": 0}, "output": {"root": -0.7996993753387776, "iterations": 7, "error": 0.00027133407936974496}}, {"input": {"xi": 2.0017590042383873, "tol": 0.0007789795966768268, "iter_max": 58, "error_type": 1}, "output": {"root": -0.799716665394975, "iterations": 10, "error": 0.0002969075192937509}}], "error_log": []}
{"context": "Given a range of integers from `low_lim` to `up_lim`, what is the maximum number of pairs of prime numbers that can sum up to any even number within this range, according to Goldbach's Conjecture?\n\nThe input and output requirements are as follows:\n\nInput:\n  `low_lim` (int): The lower limit of the range (inclusive) for which to check Goldbach's Conjecture. Must be at least 4.\n  `up_lim` (int): The upper limit of the range (inclusive) for which to check Goldbach's Conjecture. Must be greater than `low_lim`.\n\nOutput:\n  `return` (int): The maximum number of pairs of prime numbers that add up to any even number in the given range.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    limit = int(n ** 0.5) + 1\n    div = 2\n    while div < limit:\n        if n % div == 0:\n            return False\n        div += 1\n    return True\n\ndef peel_factors(listo):\n    a = str(listo.pop(0)) + ' + ' + str(listo.pop(0))\n    while len(listo) > 0:\n        a += ' = ' + str(listo.pop(0)) + ' + ' + str(listo.pop(0))\n    return a\n\n# main function\ndef main_solution(low_lim, up_lim):\n    # Ensure the inputs are valid\n    if up_lim < low_lim or low_lim < 4:\n        raise ValueError(\"Upper limit must be greater than lower limit and lower limit must be at least 4.\")\n\n    # Create Range of values\n    a = list(range(low_lim, up_lim + 1))\n\n    max_pairs = 0\n\n    # For each even number in the range, find the pairs of primes that sum to it\n    for i in a:\n        if i % 2 == 0:\n            pairs = 0\n            factors = []\n            peel = 1\n            while peel <= (i // 2):\n                num_sum1 = i - peel\n                num_sum2 = peel\n                peel += 1\n                if is_prime(num_sum1) and is_prime(num_sum2) and num_sum1 != 1 and num_sum2 != 1:\n                    factors.append(num_sum2)\n                    factors.append(num_sum1)\n            pairs = len(factors)\n            if pairs > max_pairs:\n                max_pairs = pairs\n\n    # Return the maximum number of pairs of primes that add up to any even number in the given range\n    return max_pairs // 2", "input_generator": "import random\n\ndef input_generator():\n    low_lim = random.randint(4, 100)\n    up_lim = random.randint(low_lim + 1, low_lim + 100)\n    return {'low_lim': low_lim, 'up_lim': up_lim}", "io_pairs": [{"input": {"low_lim": 37, "up_lim": 84}, "output": 8}, {"input": {"low_lim": 99, "up_lim": 113}, "output": 8}, {"input": {"low_lim": 44, "up_lim": 82}, "output": 7}, {"input": {"low_lim": 44, "up_lim": 141}, "output": 12}, {"input": {"low_lim": 60, "up_lim": 116}, "output": 10}, {"input": {"low_lim": 65, "up_lim": 99}, "output": 9}, {"input": {"low_lim": 97, "up_lim": 165}, "output": 12}, {"input": {"low_lim": 100, "up_lim": 146}, "output": 12}, {"input": {"low_lim": 73, "up_lim": 160}, "output": 12}, {"input": {"low_lim": 75, "up_lim": 170}, "output": 13}], "error_log": []}
{"context": "Given a list of integers, is it possible to partition the list into two groups such that the sum of one group minus the sum of the other group equals 0 or a multiple of 360?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num` (int): The number of integers in the list.\n  `lists` (list of int): The list of integers.\n\nOutput:\n  `return` (bool): True if it is possible to partition the list into two groups such that the sum of one group minus the sum of the other group equals 0 or a multiple of 360, False otherwise.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(num, lists):\n    \"\"\"\n    Determines if it is possible to partition the given list of integers into two groups such that the sum of one group minus the sum of the other group equals 0 or a multiple of 360.\n\n    Args:\n        num (int): The number of integers in the list.\n        lists (list of int): The list of integers.\n\n    Returns:\n        bool: True if such a partition exists, False otherwise.\n    \"\"\"\n    def add(k, lists, count):\n        if k == len(lists):\n            return count == 0 or count % 360 == 0\n        else:\n            count = count + lists[k]\n            A = add(k + 1, lists, count)\n            count = count - 2 * lists[k]\n            B = add(k + 1, lists, count)\n            return A or B\n\n    return add(0, lists, 0)", "input_generator": "import random\n\ndef input_generator():\n    num = random.randint(1, 10)\n    lists = [random.randint(-100, 100) for _ in range(num)]\n    return {'num': num, 'lists': lists}", "io_pairs": [{"input": {"num": 1, "lists": [72]}, "output": false}, {"input": {"num": 10, "lists": [-35, -47, 79, 99, -41, 50, -89, 11, 20, 89]}, "output": true}, {"input": {"num": 9, "lists": [12, -64, 98, 25, -88, -4, 89, -63, 95]}, "output": true}, {"input": {"num": 6, "lists": [42, -1, -80, 31, 66, -88]}, "output": true}, {"input": {"num": 6, "lists": [-63, 79, -6, 65, -71, -26]}, "output": false}, {"input": {"num": 7, "lists": [29, 84, -49, -1, -22, -11, 32]}, "output": true}, {"input": {"num": 6, "lists": [-33, 2, -87, 92, 7, 46]}, "output": false}, {"input": {"num": 5, "lists": [-95, 37, -60, 79, 41]}, "output": false}, {"input": {"num": 5, "lists": [54, 54, -6, 23, -62]}, "output": false}, {"input": {"num": 1, "lists": [-15]}, "output": false}], "error_log": []}
{"context": "Given a sequence of integers, determine whether this sequence can represent the post-order traversal of a Binary Search Tree (BST). What is the result indicating whether the sequence is a valid post-order traversal of a BST?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sequence` (list of integers): A list of integers representing the sequence to be verified as the post-order traversal of a Binary Search Tree (BST).\n\nOutput:\n  `return` (string): A string indicating whether the input sequence is a valid post-order traversal of a BST. The possible values are \"Yes\" or \"No\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, sequence):\n        if not sequence:\n            return False\n        length = len(sequence)\n        root = sequence[-1]\n        index = 0\n        for i in range(length-1):\n            index = i\n            if sequence[i] > root:\n                break\n        for j in range(index+1, length-1):\n            if sequence[j] < root:\n                return False\n\n        left = True\n        if index > 0:\n            left = self.VerifySquenceOfBST(sequence[:index])\n\n        right = True\n        if index < length-1:\n            right = self.VerifySquenceOfBST(sequence[index:length-1])\n\n        return left and right\n\n# main function\ndef main_solution(sequence):\n    # Convert the input list to a JSON serializable format\n    sequence_list = list(sequence)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the VerifySquenceOfBST method\n    result = solution.VerifySquenceOfBST(sequence_list)\n    \n    # Convert the result to a JSON serializable format\n    return \"Yes\" if result else \"No\"", "input_generator": "import random\n\ndef input_generator():\n    def generate_sequence(length):\n        if random.random() < 0.5:\n            # Generate a valid BST postorder sequence\n            def build_valid_sequence(start, end):\n                if start > end:\n                    return []\n                root = random.randint(start, end)\n                left = build_valid_sequence(start, root - 1)\n                right = build_valid_sequence(root + 1, end)\n                return left + right + [root]\n            sequence = build_valid_sequence(1, length)\n        else:\n            # Generate a random sequence (may or may not be valid)\n            sequence = [random.randint(1, 100) for _ in range(length)]\n            # Occasionally make it obviously invalid\n            if random.random() < 0.3:\n                sequence.sort()  # sorted sequences are invalid for BST postorder\n        return sequence\n\n    length = random.randint(0, 20)\n    sequence = generate_sequence(length)\n    return {'sequence': sequence}", "io_pairs": [{"input": {"sequence": [1, 3, 4, 2, 5, 6, 9, 8, 7]}, "output": "Yes"}, {"input": {"sequence": [54, 79, 86, 88, 99]}, "output": "Yes"}, {"input": {"sequence": []}, "output": "No"}, {"input": {"sequence": [15, 29, 31, 46, 58, 75, 92, 99]}, "output": "Yes"}, {"input": {"sequence": [2, 1, 6, 8, 7, 5, 4, 10, 9, 12, 13, 11, 15, 14, 3]}, "output": "Yes"}, {"input": {"sequence": [84]}, "output": "Yes"}, {"input": {"sequence": [30, 57, 48, 95]}, "output": "Yes"}, {"input": {"sequence": [1, 5, 8, 7, 6, 4, 3, 2, 10, 12, 14, 16, 15, 17, 13, 11, 9]}, "output": "Yes"}, {"input": {"sequence": [1, 4, 3, 5, 7, 6, 2, 8]}, "output": "Yes"}, {"input": {"sequence": [9, 85, 46, 8, 18, 33, 22, 37, 53, 6, 73, 94]}, "output": "No"}], "error_log": []}
{"context": "Given a requirement to generate a sequence of independent standard Gaussian random variables, how many pairs of such variables can be generated using the Box-Muller method for a specified number of pairs?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_pairs` (int): The number of pairs of independent standard Gaussian random variables to generate.\n\nOutput:\n  `return` (list of float): A list containing the generated independent standard Gaussian random variables. Each pair of variables is generated using the Box-Muller method.", "reference_code": "# import necessary packages\nimport random\nimport numpy as np\n\n# main function\ndef main_solution(num_pairs):\n    # Convert the input to an integer\n    num_pairs = int(num_pairs)\n    \n    # Function to generate two independent standard Gaussian random variables using Box-Muller method\n    def box_muller():\n        u0 = random.random()\n        u1 = random.random()\n        z0 = np.sqrt(-2 * np.log(u0)) * np.cos(2 * np.pi * u1)\n        z1 = np.sqrt(-2 * np.log(u0)) * np.sin(2 * np.pi * u1)\n        return [z0, z1]\n    \n    # Generate the sequence of random variables\n    result = []\n    for _ in range(num_pairs):\n        result.extend(box_muller())\n    \n    # Return the result as a list of floats\n    return result", "input_generator": "import random\n\ndef input_generator():\n    return {'num_pairs': random.randint(1, 100)}", "io_pairs": [{"input": {"num_pairs": 4}, "output": [0.9590718139377354, 0.497666400190813, 1.4805527447277, -0.3892393306039855, -0.16589706826574505, 1.2703281860500233, -0.1674854157663331, -0.08315505388947543]}, {"input": {"num_pairs": 2}, "output": [0.8279787878795354, -0.17218089853083313, -0.2397131090553526, -0.8263631944880695]}, {"input": {"num_pairs": 8}, "output": [-1.2546138038816672, -1.5633543978189492, -1.0367685340644055, 1.041231859745943, 1.330010724090539, -0.7156770689506775, -0.02296960481331714, 0.8446165779926158, 0.6439508272716921, -0.6877267679168616, -0.3547393477373297, -1.2265442707029466, -0.47321493620080285, 0.5075705936457354, -0.36278380672507576, 0.4248551569309738]}, {"input": {"num_pairs": 7}, "output": [0.19982955493942128, -0.9341464009287237, -0.41596893063247975, 0.7599648224010516, -0.4640534611072595, -0.2610657630067721, -0.23193887320139908, 0.41233879787347594, -1.167173178302667, 1.0692616314037284, 0.02470215263199659, -1.7805149355957481, -0.773886007429506, -1.6381271157041637]}, {"input": {"num_pairs": 3}, "output": [-0.9907413348051333, -1.5042102363447243, 0.658064764348731, -0.21865604636663002, -0.5267950840045558, 0.3328832271930936]}, {"input": {"num_pairs": 5}, "output": [-0.5060280059971918, 0.24084205490417818, 0.2966804030922683, -1.6466102050980758, -0.5944013205812693, -0.28979260683395147, 0.26021064843764813, -0.6761062735865226, 1.7573340668254518, 0.31282927111243597]}, {"input": {"num_pairs": 6}, "output": [-0.20654638273815623, -1.320115953913682, 0.3060068226826752, -2.2577183046490306, -0.2938271254974449, 0.37898622807677784, -0.030442323238881117, -1.0483549473216875, -0.8961942285171605, -2.211595211431899, 0.8408664086959434, 0.21618152616699637]}, {"input": {"num_pairs": 1}, "output": [1.5453659223320773, 0.023023156195361986]}, {"input": {"num_pairs": 9}, "output": [-3.0463138422337295, 1.1941793145916448, -1.5473072631061349, -0.12131046375952875, -0.1415543853336639, 0.11830785655421493, -0.0144946808186035, -0.13114211376815632, -0.8377907714057217, 0.9909442255440816, 2.082261254296539, 0.07310088915463621, 1.3241112087172666, 1.1821064595135489, -0.37261775068902103, -0.03332781234751718, -1.6242061978287812, 0.12501793072431708]}], "error_log": []}
{"context": "Given a function that computes the sum of squares of two variables, how would the values of these variables change after applying the gradient descent algorithm with a specified learning rate and number of steps?\n\nThe input and output requirements are as follows:\n\nInput:\n  `init_x` (list of float): A list containing the initial values for the variables x0 and x1.\n  `lr` (float): The learning rate used in the gradient descent algorithm.\n  `step_num` (int): The number of steps to perform in the gradient descent algorithm.\n\nOutput:\n  `return` (list of float): A list containing the final values of x0 and x1 after performing the gradient descent algorithm.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef numerical_diff(f, x):\n    h = 1e-4\n    return (f(x+h)-f(x-h))/(2*h)\n\ndef function_2(x):\n    return x[0]**2 + x[1]**2\n\ndef numerical_grad(f, x):\n    h = 1e-4\n    grad = np.zeros_like(x)\n\n    for idx in range(x.size):\n        tmp = x[idx]\n\n        x[idx] = tmp + h\n        fxh1 = f(x)\n\n        x[idx] = tmp - h\n        fxh2 = f(x)\n\n        grad[idx] = (fxh1 - fxh2) / (2 * h)\n        x[idx] = tmp\n\n    return grad\n\ndef grad_descent(f, init_x, lr=0.01, step_num=100):\n    x = init_x\n\n    for i in range(step_num):\n        grad = numerical_grad(f, x)\n        x -= lr * grad\n\n    return x\n\n# main function\ndef main_solution(init_x, lr, step_num):\n    # Convert JSON serializable inputs to the original input variables\n    init_x = np.array(init_x)\n\n    # Call the grad_descent function\n    result = grad_descent(function_2, init_x, lr, step_num)\n\n    # Convert the result to JSON serializable output\n    return result.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    init_x = [random.uniform(-10, 10), random.uniform(-10, 10)]\n    lr = random.choice([0.001, 0.01, 0.1, 0.2])\n    step_num = random.randint(50, 200)\n    return {'init_x': init_x, 'lr': lr, 'step_num': step_num}", "io_pairs": [{"input": {"init_x": [5.17358511532594, -9.152129807240525], "lr": 0.01, "step_num": 171}, "output": [0.16347469730024167, -0.2891885639343407]}, {"input": {"init_x": [-7.852445318166783, 3.296611206322172], "lr": 0.01, "step_num": 151}, "output": [-0.371657028581682, 0.15602894075486368]}, {"input": {"init_x": [8.537359904621475, -0.8788985414331698], "lr": 0.2, "step_num": 102}, "output": [5.4263048183478615e-21, -2.660212849970537e-21]}, {"input": {"init_x": [-8.467445591165854, 9.775578993617831], "lr": 0.01, "step_num": 57}, "output": [-2.6769405670974162, 3.0905003986339246]}, {"input": {"init_x": [-7.76105885796426, 4.9773514070895], "lr": 0.01, "step_num": 176}, "output": [-0.2216717239975428, 0.1421633423406608]}, {"input": {"init_x": [3.8600703997618204, -8.556963404170174], "lr": 0.01, "step_num": 74}, "output": [0.8656151057029806, -1.918886448822425]}, {"input": {"init_x": [2.3986387097496475, 9.941391673466068], "lr": 0.2, "step_num": 133}, "output": [2.9513804255892027e-21, 2.660212849970537e-21]}, {"input": {"init_x": [-1.4415719230085138, -0.6945826655620557], "lr": 0.1, "step_num": 149}, "output": [-5.238950699240536e-15, -2.5242472867133992e-15]}, {"input": {"init_x": [5.371020164170442, -5.467715236897936], "lr": 0.1, "step_num": 181}, "output": [1.546614663748368e-17, -1.5743602867268668e-17]}, {"input": {"init_x": [-4.768792130542272, 6.694807878272119], "lr": 0.001, "step_num": 82}, "output": [-4.04680965721907, 5.681231731930655]}], "error_log": []}
{"context": "Given a set of 4 unique digits, what is the length of the longest sequence of consecutive integers starting from 1 that can be formed using these digits with the operators +, -, *, /, where each digit must be used exactly once?\n\nThe input and output requirements are as follows:\n\nInput:\n  `digits_str` (str): A string of exactly 4 unique digits (0-9) without any separators.\n\nOutput:\n  `return` (dict): A dictionary with the following keys:\n    - `longest_sequence` (int): The length of the longest sequence of consecutive integers starting from 1 that can be formed using the digits.\n    - `digits` (str): The input string of digits used to find the longest sequence.", "reference_code": "# import necessary packages\nimport itertools\nimport random\n\n# Performs the specified operation on a and b\ndef calc(a, b, op):\n    if op == 0:\n        return a + b\n    if op == 1:\n        return a - b\n    if op == 2:\n        return a * b\n    if op == 3:\n        if b != 0:\n            return float(a) / b\n        else:\n            return a + 0.123456\n\n# main function\ndef main_solution(digits_str):\n    digits = [int(d) for d in digits_str]\n    solutions = set()\n    \n    # Loop over all digit orders\n    for a, b, c, d in itertools.permutations(digits):\n        # Loop over all combinations of operations\n        for operations in itertools.product(range(4), repeat=3):\n            # The two options are:\n            # (((a ~ b) ~ c) ~ d)\n            # ((a ~ b) ~ (c ~ d))\n            answers = []\n            a_op_b = calc(a, b, operations[0])\n            answers.append(calc(calc(a_op_b, c, operations[1]), d, operations[2]))\n            answers.append(calc(a_op_b, calc(c, d, operations[1]), operations[2]))\n            for answer in answers:\n                if float(answer).is_integer() and answer > 0:\n                    solutions.add(int(answer))\n    \n    # Check if longest sequence has been improved on\n    longest_sequence = 0\n    for index, item in enumerate(sorted(list(solutions))):\n        if index != item - 1:\n            longest_sequence = index\n            break\n    \n    return {\"longest_sequence\": longest_sequence, \"digits\": digits_str}", "input_generator": "import random\n\ndef input_generator():\n    digits = random.sample(range(1, 10), 4)\n    digits_str = ''.join(map(str, digits))\n    return {\"digits_str\": digits_str}", "io_pairs": [{"input": {"digits_str": "7928"}, "output": {"longest_sequence": 22, "digits": "7928"}}, {"input": {"digits_str": "6137"}, "output": {"longest_sequence": 28, "digits": "6137"}}, {"input": {"digits_str": "9231"}, "output": {"longest_sequence": 30, "digits": "9231"}}, {"input": {"digits_str": "7243"}, "output": {"longest_sequence": 35, "digits": "7243"}}, {"input": {"digits_str": "9713"}, "output": {"longest_sequence": 15, "digits": "9713"}}, {"input": {"digits_str": "8319"}, "output": {"longest_sequence": 7, "digits": "8319"}}, {"input": {"digits_str": "2164"}, "output": {"longest_sequence": 28, "digits": "2164"}}, {"input": {"digits_str": "2718"}, "output": {"longest_sequence": 18, "digits": "2718"}}, {"input": {"digits_str": "2197"}, "output": {"longest_sequence": 28, "digits": "2197"}}, {"input": {"digits_str": "7195"}, "output": {"longest_sequence": 12, "digits": "7195"}}], "error_log": []}
{"context": "Given two integers `x` and `m`, what is the multiplicative inverse of `x` modulo `m`? The multiplicative inverse is an integer `a` such that `a * x` is congruent to 1 modulo `m`. If no such integer exists, the result should be `None`.\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (int): The integer for which the multiplicative inverse is to be found.\n  `m` (int): The modulus under which the multiplicative inverse is to be found.\n\nOutput:\n  `return` (int or None): The multiplicative inverse of `x` modulo `m` if it exists, otherwise `None`.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef multInv(x, m):\n    \"\"\" Find the multiplicative inverse of X mod M.\n        The multiplicative inverse is A such that A * X = 1 mod M. \"\"\"\n    d, a, b = extendedEuclid(x, m)\n    if d != 1:\n        raise ValueError(\"No multiplicative inverse exists\")\n    return a % m\n\ndef switched(x, y):\n    \"\"\"Returns Y, X.\"\"\"\n    return (y, x)\n\ndef extendedEuclid(x, y):\n    \"\"\"Returns d, a, b such that d is the gcd of X and Y and aX + bY = d. \"\"\"\n    swapped = False\n    if x < y:\n        swapped = True\n        x, y = switched(x, y)\n    eqs = {x: (1, 0),\n           y: (0, 1)}\n    while (x != 0):\n        if (x < y) and (x != 1):\n            x, y = switched(x, y)\n        if (x == 1 or y == 0):\n            if swapped:\n                return (x, eqs[x][1], eqs[x][0])\n            return (x, eqs[x][0], eqs[x][1])\n        scaleBy = (x // y)\n        eqs[x % y] = (eqs[x][0] - scaleBy * eqs[y][0], eqs[x][1] - scaleBy * eqs[y][1])\n        x = x % y\n    if swapped:\n        return (y, eqs[y][1], eqs[y][0])\n    return (y, eqs[y][0], eqs[y][1])\n\n# main function\ndef main_solution(x, m):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    try:\n        result = multInv(x, m)\n    except ValueError:\n        result = None\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate random x and m, ensuring they are coprime for some cases to allow inverse\n    if random.random() < 0.5:\n        # Generate coprime x and m\n        m = random.randint(2, 1000)\n        x = random.randint(1, m - 1)\n        while True:\n            d, a, b = extendedEuclid(x, m)\n            if d == 1:\n                break\n            x = random.randint(1, m - 1)\n    else:\n        # Generate non-coprime x and m\n        m = random.randint(2, 1000)\n        d = random.randint(2, min(m, 100))\n        x = random.randint(1, (m // d)) * d\n    \n    return {'x': x, 'm': m}", "io_pairs": [{"input": {"x": 750, "m": 931}, "output": 36}, {"input": {"x": 99, "m": 416}, "output": 395}, {"input": {"x": 83, "m": 90}, "output": 77}, {"input": {"x": 49, "m": 290}, "output": 219}, {"input": {"x": 197, "m": 663}, "output": 488}, {"input": {"x": 257, "m": 804}, "output": 341}, {"input": {"x": 400, "m": 961}, "output": 382}, {"input": {"x": 385, "m": 941}, "output": 22}, {"input": {"x": 538, "m": 937}, "output": 573}, {"input": {"x": 139, "m": 510}, "output": 499}], "error_log": []}
{"context": "Given a deck of cards and a series of shuffle instructions, what card will be at a specific position in the deck after all the instructions have been applied?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number_of_cards` (int): The total number of cards in the deck.\n  `instructions` (list of str): A list of instructions to shuffle the deck. Each instruction is a string describing the shuffle operation.\n  `card_position` (int): The position in the deck for which the card needs to be found.\n\nOutput:\n  `return` (int): The card at the specified position in the deck after applying all the shuffle instructions.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\ndef compute_inverse(n, a):\n    (r, u, r2, u2) = (a, 1, n, 0)\n    while r2 != 0:\n        q = r // r2\n        (r, u, r2, u2) = (r2, u2, r - q * r2, u - q * u2)\n    return u + n * math.ceil(-u / n)\n\ndef compute_power(root, exponent, n):\n    binary_exponent = [int(x) for x in str(bin(exponent))[2:]]\n    power = 1\n    r = root\n    for i, coefficient in enumerate(binary_exponent[::-1]):\n        power *= r ** coefficient\n        power = power % n\n        r = (r ** 2) % n\n    return power\n\nclass Deck(object):\n    def __init__(self, number_of_cards):\n        self.number_of_cards = number_of_cards\n        self.shuffle = (1, 0)\n\n    def get_card_position(self, x):\n        a, b = self.shuffle\n        return (a * x + b) % self.number_of_cards\n\n    def apply_shuffle(self, shuffle):\n        a1, b1 = self.shuffle\n        a2, b2 = shuffle\n        a = a1 * a2 % self.number_of_cards\n        b = (a1 * b2 + b1) % self.number_of_cards\n        self.shuffle = (a, b)\n\n    def deal(self):\n        shuffle = (-1, self.number_of_cards - 1)\n        self.apply_shuffle(shuffle)\n\n    def cut(self, n):\n        shuffle = (1, n)\n        self.apply_shuffle(shuffle)\n\n    def deal_with_increment(self, increment):\n        shuffle = (compute_inverse(self.number_of_cards, increment), 0)\n        self.apply_shuffle(shuffle)\n\n    def apply_instructions(self, instructions):\n        for instruction in instructions:\n            words = instruction.split(\" \")\n            if \" \".join(words[:-1]) == \"deal with increment\":\n                self.deal_with_increment(int(words[-1]))\n            elif instruction == \"deal into new stack\":\n                self.deal()\n            else:\n                self.cut(int(words[-1]))\n\n    def get_position_of_card(self, card):\n        a, b = self.shuffle\n        return compute_inverse(self.number_of_cards, a) * (card - b) % self.number_of_cards\n\n    def get_card_at_position(self, position):\n        a, b = self.shuffle\n        return (a * position + b) % self.number_of_cards\n\n    def apply_shuffle_repeatedly(self, n):\n        a, b = self.shuffle\n        if a == 1:\n            self.shuffle = (1, (b * n) % self.number_of_cards)\n        else:\n            power = compute_power(a, n, self.number_of_cards)\n            b = (compute_inverse(self.number_of_cards, a - 1) * (power - 1) * b) % self.number_of_cards\n            a = power % self.number_of_cards\n            self.shuffle = a, b\n\n# main function\ndef main_solution(number_of_cards, instructions, card_position):\n    # Convert JSON serializable inputs to original input variables\n    deck = Deck(number_of_cards)\n    deck.apply_instructions(instructions)\n    \n    # Get the card at the specified position\n    card = deck.get_card_at_position(card_position)\n    \n    # Convert the output to JSON serializable\n    return card", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a reasonable number of cards, e.g., between 10 and 1000\n    number_of_cards = random.randint(10, 1000)\n    \n    # Generate a list of instructions\n    instructions = []\n    num_instructions = random.randint(1, 10)\n    for _ in range(num_instructions):\n        instruction_type = random.randint(0, 2)\n        if instruction_type == 0:\n            instructions.append(\"deal into new stack\")\n        elif instruction_type == 1:\n            n = random.randint(-number_of_cards + 1, number_of_cards - 1)\n            instructions.append(f\"cut {n}\")\n        else:\n            increment = random.randint(1, number_of_cards - 1)\n            while math.gcd(increment, number_of_cards) != 1:\n                increment = random.randint(1, number_of_cards - 1)\n            instructions.append(f\"deal with increment {increment}\")\n    \n    # Generate a random card position within the deck\n    card_position = random.randint(0, number_of_cards - 1)\n    \n    return {\n        \"number_of_cards\": number_of_cards,\n        \"instructions\": instructions,\n        \"card_position\": card_position\n    }", "io_pairs": [{"input": {"number_of_cards": 590, "instructions": ["cut 569", "cut -571", "deal into new stack"], "card_position": 275}, "output": 312}, {"input": {"number_of_cards": 941, "instructions": ["deal with increment 78", "deal with increment 902", "deal into new stack", "deal into new stack", "deal with increment 335", "deal with increment 362", "cut -569"], "card_position": 294}, "output": 519}, {"input": {"number_of_cards": 105, "instructions": ["deal into new stack"], "card_position": 16}, "output": 88}, {"input": {"number_of_cards": 797, "instructions": ["cut -25", "deal with increment 291", "deal with increment 484", "deal into new stack", "cut 13", "deal into new stack"], "card_position": 250}, "output": 314}, {"input": {"number_of_cards": 338, "instructions": ["deal with increment 315"], "card_position": 333}, "output": 59}, {"input": {"number_of_cards": 738, "instructions": ["deal with increment 289", "deal into new stack", "cut -573", "deal into new stack", "cut -506", "deal with increment 521"], "card_position": 365}, "output": 512}, {"input": {"number_of_cards": 926, "instructions": ["deal into new stack", "deal with increment 649", "cut -683"], "card_position": 491}, "output": 239}, {"input": {"number_of_cards": 192, "instructions": ["cut -18", "deal into new stack", "cut 102"], "card_position": 63}, "output": 8}, {"input": {"number_of_cards": 655, "instructions": ["deal with increment 116", "cut -583", "cut -11", "cut 629", "deal into new stack"], "card_position": 143}, "output": 16}, {"input": {"number_of_cards": 63, "instructions": ["cut 30", "deal into new stack", "deal into new stack", "deal with increment 20", "deal into new stack", "deal with increment 20"], "card_position": 54}, "output": 61}], "error_log": []}
{"context": "Given a mathematical function and its derivative, how can we approximate the solution to the equation f(x) = 0 using the Newton-Raphson method, starting from a given initial guess and with specified stopping criteria and maximum iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `f_expr` (str): A string representing the mathematical function for which we are searching for a solution f(x)=0. The function should be in a format that can be evaluated using `eval`.\n  `Df_expr` (str): A string representing the derivative of the function `f_expr`. The derivative should be in a format that can be evaluated using `eval`.\n  `x0` (float): The initial guess for the solution f(x)=0.\n  `epsilon` (float): The stopping criteria for the Newton-Raphson method, where the method stops if abs(f(x)) < epsilon.\n  `max_iter` (int): The maximum number of iterations allowed for the Newton-Raphson method.\n\nOutput:\n  `return` (float or None): The approximate solution of f(x)=0 obtained by the Newton-Raphson method. If no solution is found within the maximum iterations or if the derivative is zero, it returns None.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef newton(f, Df, x0, epsilon, max_iter):\n    '''Approximate solution of f(x)=0 by Newton's method.\n\n    Parameters\n    ----------\n    f : function\n        Function for which we are searching for a solution f(x)=0.\n    Df : function\n        Derivative of f(x)\n    x0 : number\n        Initial guess for a solution f(x)=0.\n    epsilon : number\n        Stopping criteria is abs(f(x)) < epsilon.\n    max_iter : integer\n        Maximum number of iterations of Newton's method.\n\n    Returns\n    -------\n    xn : number\n        Implement Newton's method: compute the linear approximation\n        of f(x) at xn and find x intercept by the formula\n            x = xn - f(xn)/Df(xn)\n        Continue until abs(f(xn)) < epsilon and return xn.\n        If Df(xn) == 0, return None. If the number of iterations\n        exceeds max_iter, then return None.\n    '''\n\n    xn = x0\n    for n in range(0, max_iter):\n        fxn = f(xn)\n        if abs(fxn) < epsilon:\n            return xn\n        Dfxn = Df(xn)\n        if Dfxn == 0:\n            return None\n        xn = xn - fxn / Dfxn\n    return None\n\n# main function\ndef main_solution(f_expr, Df_expr, x0, epsilon, max_iter):\n    # Convert string expressions to lambda functions\n    f = eval(f_expr)\n    Df = eval(Df_expr)\n    \n    # Call the newton function with the converted inputs\n    result = newton(f, Df, x0, epsilon, max_iter)\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Randomly choose a type of function: linear, quadratic, cubic, or trigonometric\n    function_type = random.choice(['linear', 'quadratic', 'cubic', 'trigonometric'])\n    \n    if function_type == 'linear':\n        a = random.uniform(-10, 10)\n        b = random.uniform(-10, 10)\n        f_expr = f\"lambda x: {a} * x + {b}\"\n        Df_expr = f\"lambda x: {a}\"\n    elif function_type == 'quadratic':\n        a = random.uniform(-5, 5)\n        b = random.uniform(-5, 5)\n        c = random.uniform(-5, 5)\n        f_expr = f\"lambda x: {a} * x**2 + {b} * x + {c}\"\n        Df_expr = f\"lambda x: 2 * {a} * x + {b}\"\n    elif function_type == 'cubic':\n        a = random.uniform(-3, 3)\n        b = random.uniform(-3, 3)\n        c = random.uniform(-3, 3)\n        d = random.uniform(-3, 3)\n        f_expr = f\"lambda x: {a} * x**3 + {b} * x**2 + {c} * x + {d}\"\n        Df_expr = f\"lambda x: 3 * {a} * x**2 + 2 * {b} * x + {c}\"\n    else:  # trigonometric\n        a = random.uniform(0.1, 2)\n        b = random.uniform(0.1, 2)\n        f_expr = f\"lambda x: {a} * math.sin({b} * x)\"\n        Df_expr = f\"lambda x: {a * b} * math.cos({b} * x)\"\n    \n    x0 = random.uniform(-10, 10)\n    epsilon = 10 ** random.uniform(-6, -3)\n    max_iter = random.randint(10, 100)\n    \n    return {\n        'f_expr': f_expr,\n        'Df_expr': Df_expr,\n        'x0': x0,\n        'epsilon': epsilon,\n        'max_iter': max_iter\n    }", "io_pairs": [{"input": {"f_expr": "lambda x: 0.5723544567143518 * math.sin(1.6505054360872413 * x)", "Df_expr": "lambda x: 0.9446741421757974 * math.cos(1.6505054360872413 * x)", "x0": -6.922496474184843, "epsilon": 0.0008681173480416739, "max_iter": 16}, "output": -7.613322027851617}, {"input": {"f_expr": "lambda x: 1.6667260714623802 * math.sin(1.393282008909106 * x)", "Df_expr": "lambda x: 2.322219449148287 * math.cos(1.393282008909106 * x)", "x0": 2.9182707155210785, "epsilon": 0.0002991292192740366, "max_iter": 81}, "output": 2.254811733743955}, {"input": {"f_expr": "lambda x: 1.2736049328941492 * x**2 + 4.129766878394758 * x + -0.10809235853236032", "Df_expr": "lambda x: 2 * 1.2736049328941492 * x + 4.129766878394758", "x0": 7.628441303942317, "epsilon": 5.539161760569802e-06, "max_iter": 12}, "output": 0.025966030138029474}, {"input": {"f_expr": "lambda x: 0.15078751496678716 * math.sin(1.330500964172631 * x)", "Df_expr": "lambda x: 0.20062293404850537 * math.cos(1.330500964172631 * x)", "x0": 1.1951862135259148, "epsilon": 1.4210293677600021e-05, "max_iter": 48}, "output": 40.140575932110224}, {"input": {"f_expr": "lambda x: -5.723054328710515 * x + 7.3120628620329455", "Df_expr": "lambda x: -5.723054328710515", "x0": 6.594341817461416, "epsilon": 3.0303883917366317e-06, "max_iter": 27}, "output": 1.2776504366472539}, {"input": {"f_expr": "lambda x: 2.5763555129024525 * x**2 + -4.742060648235375 * x + -1.2591739367670742", "Df_expr": "lambda x: 2 * 2.5763555129024525 * x + -4.742060648235375", "x0": -7.170585305543165, "epsilon": 7.519694548540579e-05, "max_iter": 62}, "output": -0.23542166207839083}, {"input": {"f_expr": "lambda x: 1.5941593868705313 * math.sin(1.6398106849166385 * x)", "Df_expr": "lambda x: 2.6141195960504544 * math.cos(1.6398106849166385 * x)", "x0": -7.541016060041978, "epsilon": 1.4140049480983662e-06, "max_iter": 71}, "output": -7.663305723734371}, {"input": {"f_expr": "lambda x: 0.7908690395824287 * x**2 + 4.57335601766858 * x + -4.233366588163468", "Df_expr": "lambda x: 2 * 0.7908690395824287 * x + 4.57335601766858", "x0": 1.2274248738479052, "epsilon": 0.00035104881603045915, "max_iter": 92}, "output": 0.8117768438366657}, {"input": {"f_expr": "lambda x: 0.9580089551448712 * x**2 + -1.1523691617501242 * x + -3.985467408657175", "Df_expr": "lambda x: 2 * 0.9580089551448712 * x + -1.1523691617501242", "x0": -3.0585369727133216, "epsilon": 0.00022425757938832085, "max_iter": 29}, "output": -1.5250331026202155}, {"input": {"f_expr": "lambda x: 1.999361138816723 * math.sin(1.6859634417561755 * x)", "Df_expr": "lambda x: 3.3708497869129888 * math.cos(1.6859634417561755 * x)", "x0": 1.198891359594402, "epsilon": 1.354349881359645e-05, "max_iter": 36}, "output": 1.863381242903683}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = 3x - \\cos(x) - 1 \\), and an initial interval \\([a, b]\\), what are the midpoints \\( c \\) calculated during each iteration of the bisection method when performing \\( n \\) iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The initial lower bound of the interval.\n  `b` (float): The initial upper bound of the interval.\n  `n` (int): The number of iterations to perform.\n\nOutput:\n  `return` (list of floats): A list of midpoints `c` calculated during each iteration.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(a, b, n):\n    # Convert inputs to numpy arrays if necessary\n    a = np.float64(a)\n    b = np.float64(b)\n    n = int(n)\n    \n    # Function definition\n    def f(x):\n        return 3 * x - np.cos(x) - 1.0\n    \n    c = np.zeros(n)\n    \n    for i in range(n):\n        c[i] = (a + b) / 2.0\n        if np.sign(f(c[i])) == np.sign(f(a)):\n            a = c[i]\n        else:\n            b = c[i]\n    \n    # Convert output to JSON serializable format\n    return c.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    a = random.uniform(-10.0, 10.0)\n    b = random.uniform(a + 0.1, a + 20.0)  # Ensure b > a with some margin\n    n = random.randint(5, 20)\n    return {'a': a, 'b': b, 'n': n}", "io_pairs": [{"input": {"a": -8.43291480140422, "b": -4.417076396321306, "n": 5}, "output": [-6.424995598862763, -5.421035997592035, -4.919056196956671, -4.6680662966389885, -4.542571346480147]}, {"input": {"a": 1.932388582429855, "b": 17.168583747697124, "n": 12}, "output": [9.55048616506349, 13.359534956380307, 15.264059352038714, 16.21632154986792, 16.69245264878252, 16.930518198239824, 17.049550972968476, 17.1090673603328, 17.138825554014964, 17.153704650856042, 17.161144199276585, 17.164863973486852]}, {"input": {"a": -8.72591879528694, "b": -6.9977306510557025, "n": 8}, "output": [-7.861824723171321, -7.429777687113512, -7.213754169084607, -7.105742410070155, -7.051736530562929, -7.024733590809316, -7.011232120932509, -7.004481385994106]}, {"input": {"a": 8.966182326623311, "b": 28.383560629005615, "n": 16}, "output": [18.674871477814463, 23.52921605341004, 25.956388341207827, 27.16997448510672, 27.776767557056168, 28.08016409303089, 28.23186236101825, 28.307711495011933, 28.345636062008772, 28.364598345507193, 28.374079487256402, 28.37882005813101, 28.381190343568313, 28.382375486286964, 28.382968057646288, 28.38326434332595]}, {"input": {"a": -5.524781025500218, "b": 11.798917871316187, "n": 5}, "output": [3.1370684229079844, -1.1938563012961168, 0.9716060608059338, -0.11112512024509147, 0.4302404702804212]}, {"input": {"a": -4.615804444365694, "b": 10.57560276106976, "n": 17}, "output": [2.979899158352033, -0.8179526430068307, 1.0809732576726012, 0.13151030733288527, 0.6062417825027433, 0.8436075200876723, 0.7249246512952078, 0.6655832168989755, 0.6359124997008594, 0.6210771411018013, 0.6136594618022724, 0.6099506221525078, 0.6080962023276255, 0.6071689924151844, 0.6067053874589639, 0.6069371899370741, 0.6070530911761293]}, {"input": {"a": -5.7806874582898615, "b": 2.6645153675101163, "n": 9}, "output": [-1.5580860453898726, 0.5532146610601218, 1.608865014285119, 1.0810398376726205, 0.8171272493663712, 0.6851709552132466, 0.6191928081366842, 0.586203734598403, 0.6026982713675436]}, {"input": {"a": -0.8818643484415727, "b": 8.607249295548092, "n": 10}, "output": [3.8626924735532597, 1.4904140625558435, 0.3042748570571354, 0.8973444598064895, 0.6008096584318124, 0.7490770591191509, 0.6749433587754816, 0.6378765086036471, 0.6193430835177298, 0.6100763709747712]}, {"input": {"a": -0.025375617091826896, "b": 8.136935387270267, "n": 9}, "output": [4.05577988508922, 2.0152021339986965, 0.9949132584534348, 0.48476882068080396, 0.7398410395671193, 0.6123049301239616, 0.5485368754023827, 0.5804209027631722, 0.5963629164435669]}, {"input": {"a": 5.459537003489688, "b": 17.436002152479052, "n": 14}, "output": [11.44776957798437, 14.441885865231711, 15.938944008855382, 16.687473080667218, 17.061737616573133, 17.248869884526094, 17.342436018502575, 17.389219085490815, 17.412610618984935, 17.424306385731995, 17.430154269105522, 17.43307821079229, 17.43454018163567, 17.43527116705736]}], "error_log": []}
{"context": "In the context of Conway's Game of Life, given a game board with live and dead cells, what will be the state of the board after one iteration of the game rules? The rules are as follows:\n1. Any live cell with fewer than two live neighbors dies.\n2. Any live cell with more than three live neighbors dies.\n3. Any dead cell with exactly three live neighbors becomes a live cell.\n\nThe input variable names are `board`.\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (List[List[int]]): A 2D list representing the game board where each element is either 0 (dead cell) or 1 (live cell). The size of the board should be reasonable, typically less than 10x10 for simplicity.\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the updated game board after applying the rules of Conway's Game of Life. Each element is either 0 (dead cell) or 1 (live cell).", "reference_code": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\ndef count(board: List[List[int]], row: int, col: int) -> int:\n    count = 0\n    directions = ((-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1))\n\n    for i, j in directions:\n        newRow, newCol = row + i, col + j\n        if 0 <= newRow < len(board) and 0 <= newCol < len(board[0]) and (board[newRow][newCol] == 1 or board[newRow][newCol] == \"#\"):\n            count += 1\n    return count\n\n# main function\ndef main_solution(board: List[List[int]]) -> List[List[int]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    rows, cols = len(board), len(board[0])\n\n    for row in range(rows):\n        for col in range(cols):\n            neighbors = count(board, row, col)\n            if board[row][col] == 1 and (neighbors < 2 or neighbors > 3):\n                board[row][col] = '#'\n            elif board[row][col] == 0 and neighbors == 3:\n                board[row][col] = '*'\n\n    conversion_map = {'#': 0, '*': 1}\n    for row in range(rows):\n        for col in range(cols):\n            if board[row][col] in conversion_map:\n                board[row][col] = conversion_map[board[row][col]]\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return board", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(5, 15)\n    cols = random.randint(5, 15)\n    board = [[random.choice([0, 1]) for _ in range(cols)] for _ in range(rows)]\n    return {'board': board}", "io_pairs": [], "error_log": []}
{"context": "Imagine you are developing a ride-sharing app that needs to find the optimal pickup location for a passenger and a driver. Given the coordinates of the passenger's origin and the driver's destination, where should the passenger and driver meet to minimize the total travel time?\n\nThe input and output requirements are as follows:\n\nInput:\n  `origin` (list of float): A list containing the coordinates [x, y] of the starting point.\n  `destination` (list of float): A list containing the coordinates [x, y] of the ending point.\n\nOutput:\n  `return` (dict): A dictionary containing the key \"pickupLocation\" with a value of a list of floats representing the coordinates [x, y] of the optimal pickup location.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef timeOfPassenger(coordinates):\n    # Simulate time calculation for a passenger\n    return sum(coordinates) * random.uniform(0.8, 1.2)\n\ndef timeOfDriver(coordinates):\n    # Simulate time calculation for a driver\n    return sum(coordinates) * random.uniform(0.8, 1.2)\n\ndef getMidPoint(origin, destination):\n    # Calculate the midpoint between two coordinates\n    return [(origin[0] + destination[0]) / 2, (origin[1] + destination[1]) / 2]\n\ndef BinarySearch(origin, destination):\n    midpointOfOriginalRoute = getMidPoint(origin, destination)\n    \n    if abs(timeOfPassenger(midpointOfOriginalRoute) - timeOfDriver(midpointOfOriginalRoute)) < 0.1:\n        return midpointOfOriginalRoute\n    \n    if timeOfPassenger(midpointOfOriginalRoute) < timeOfDriver(midpointOfOriginalRoute):\n        return BinarySearch(midpointOfOriginalRoute, destination)\n    else:\n        return BinarySearch(origin, midpointOfOriginalRoute)\n\n# main function\ndef main_solution(origin, destination):\n    # Convert input to JSON serializable format if necessary\n    origin = list(origin)\n    destination = list(destination)\n    \n    # Call the main logic function\n    pickupLocation = BinarySearch(origin, destination)\n    \n    # Convert output to JSON serializable format\n    return {\"pickupLocation\": pickupLocation}", "input_generator": "import random\n\ndef input_generator():\n    origin = [random.uniform(-100, 100), random.uniform(-100, 100)]\n    destination = [random.uniform(-100, 100), random.uniform(-100, 100)]\n    return {\"origin\": origin, \"destination\": destination}", "io_pairs": [{"input": {"origin": [-49.284454606391016, 65.59169752598677], "destination": [-68.72603825002774, -12.58001928115604]}, "output": {"pickupLocation": [-66.6969278335392, -4.421268031481808]}}, {"input": {"origin": [-59.83046867119073, 33.23067246059594], "destination": [-63.25300177330744, -23.325397533615046]}, "output": {"pickupLocation": [-62.21889052454405, -6.237098773058955]}}, {"input": {"origin": [-32.68001436334612, 65.05725564135903], "destination": [-78.64532823800074, 27.38696987597615]}, "output": {"pickupLocation": [-77.28277481909339, 28.50363312341547]}}, {"input": {"origin": [-81.35095851962035, -53.152350176009456], "destination": [92.78810904327847, 68.21013338205944]}, "output": {"pickupLocation": [87.7057802160478, 64.66811344728117]}}, {"input": {"origin": [-12.197383117022383, -6.205846397503009], "destination": [5.735307605775915, -32.95393509488191]}, "output": {"pickupLocation": [2.128255313895575, -27.573718811073512]}}, {"input": {"origin": [-1.5178945578774972, 27.41421431882189], "destination": [-97.28891043537995, -92.89732905950608]}, "output": {"pickupLocation": [-36.19591353539953, -16.149759042650054]}}, {"input": {"origin": [83.36007333933898, 35.03943582583523], "destination": [-85.18371558790858, -69.4344815542712]}, "output": {"pickupLocation": [-59.51809164128096, -53.52533240807345]}}, {"input": {"origin": [91.45130611843456, 32.83068418211593], "destination": [92.68772924948411, -53.4519176328494]}, "output": {"pickupLocation": [92.0880386524087, -11.603084737175191]}}, {"input": {"origin": [62.979248521114556, -30.917104421145908], "destination": [55.10393653892547, -47.50772330571389]}, "output": {"pickupLocation": [58.623982091558545, -40.09217781975326]}}, {"input": {"origin": [97.36446079607998, -67.49818813154741], "destination": [-59.071518827332326, 18.876435436906732]}, "output": {"pickupLocation": [30.145875801645005, -30.384092066977274]}}], "error_log": []}
{"context": "Given a base number, an exponent, and a modulus value, what is the result of raising the base to the exponent and then taking the modulus of the result with the given modulus value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `base` (int): The base number for the exponentiation.\n  `exp` (int): The exponent to which the base is raised.\n  `modN` (int): The modulus value for the operation.\n\nOutput:\n  `return` (int): The result of the exponentiation operation modulo `modN`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef squareAndMultiply(base, exp, modN):\n    expBin = str(bin(exp)[2:])\n    z = 1\n    for i in range(len(expBin) - 1, -1, -1):\n        z = z * z % modN\n        if expBin[len(expBin) - 1 - i] == '1':\n            z = z * base % modN\n    return z\n\n# main function\ndef main_solution(base, exp, modN):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = squareAndMultiply(base, exp, modN)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    base = random.randint(1, 1000)\n    exp = random.randint(1, 1000)\n    modN = random.randint(2, 1000)\n    return {'base': base, 'exp': exp, 'modN': modN}", "io_pairs": [{"input": {"base": 260, "exp": 656, "modN": 415}, "output": 250}, {"input": {"base": 821, "exp": 570, "modN": 669}, "output": 355}, {"input": {"base": 649, "exp": 348, "modN": 283}, "output": 216}, {"input": {"base": 327, "exp": 835, "modN": 149}, "output": 16}, {"input": {"base": 924, "exp": 266, "modN": 601}, "output": 222}, {"input": {"base": 878, "exp": 988, "modN": 478}, "output": 226}, {"input": {"base": 167, "exp": 522, "modN": 536}, "output": 265}, {"input": {"base": 325, "exp": 216, "modN": 249}, "output": 64}, {"input": {"base": 530, "exp": 75, "modN": 52}, "output": 12}, {"input": {"base": 859, "exp": 189, "modN": 836}, "output": 419}], "error_log": []}
{"context": "Given a string of digits, what is the first prime number that can be formed by permuting these digits?\n\nThe input and output requirements are as follows:\n\nInput:\n  `digits` (str): A string of digits from which permutations will be generated to check for prime numbers. The string should contain only numeric characters.\n\nOutput:\n  `return` (str or None): A string representing the first prime number found by permuting the input digits. If no prime number is found, the function returns `None`.", "reference_code": "# import necessary packages\nimport itertools\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    if n % 2 == 0 and n > 2: \n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(digits):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert the input string to a list of characters\n    digit_list = list(digits)\n    \n    # Generate all permutations of the digit list\n    permutations = itertools.permutations(digit_list)\n    \n    # Check each permutation to see if it forms a prime number\n    for perm in permutations:\n        num_str = \"\".join(perm)\n        num = int(num_str)\n        if is_prime(num):\n            return num_str\n    \n    # If no prime number is found, return None\n    return None", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random length between 2 and 5 to avoid trivial or too large inputs\n    length = random.randint(2, 5)\n    \n    # Generate a string of digits, ensuring at least one odd digit (since primes > 2 are odd)\n    digits = []\n    for _ in range(length - 1):\n        digits.append(random.choice(string.digits))\n    # Ensure at least one odd digit\n    digits.append(random.choice('13579'))\n    random.shuffle(digits)\n    \n    # Join the digits into a string\n    digits_str = ''.join(digits)\n    \n    return {'digits': digits_str}", "io_pairs": [{"input": {"digits": "3137"}, "output": "3137"}, {"input": {"digits": "24035"}, "output": "20543"}, {"input": {"digits": "76951"}, "output": "76519"}, {"input": {"digits": "25292"}, "output": "25229"}, {"input": {"digits": "1903"}, "output": "1093"}, {"input": {"digits": "17374"}, "output": "13477"}, {"input": {"digits": "9161"}, "output": "9161"}, {"input": {"digits": "635"}, "output": "653"}, {"input": {"digits": "14"}, "output": "41"}, {"input": {"digits": "66641"}, "output": "64661"}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, given the current state of the board and the player whose turn it is, what is the optimal move for the player to make? The board is represented as a 3x3 grid, where each cell can be 'X', 'O', or ' '. The player can be either 'X' or 'O'. The optimal move is the one that maximizes the player's chances of winning or minimizes the opponent's chances of winning.\n\nThe input and output requirements are as follows:\n\nInput:\n  `state` (list of lists of strings): A 3x3 grid representing the Tic-Tac-Toe board. Each cell can be 'X', 'O', or ' '.\n  `player` (string): The current player, either 'X' or 'O'.\n\nOutput:\n  `return` (integer): The index of the best move for the current player. The index is a number between 1 and 9, representing the position on the board from top-left to bottom-right.", "reference_code": "# import necessary packages\nimport copy\nfrom math import inf as infinity\n\n# all class and function definitions in the code file, if any\ndef check_current_state(state):\n    '''\n    Check if the game is over\n    '''\n    # Check for winning rows\n    for row in range(3):\n        if (state[row][0] == state[row][1] == state[row][2]) and (state[row][0] is not ' '):\n            return state[row][0], \"Done\"\n    # Check for winning columns\n    for col in range(3):\n        if (state[0][col] == state[1][col] == state[2][col]) and (state[0][col] is not ' '):\n            return state[0][col], \"Done\"\n    # Check for winning diagonals\n    if (state[0][0] == state[1][1] == state[2][2]) and (state[0][0] is not ' '):\n        return state[0][0], \"Done\"\n    if (state[0][2] == state[1][1] == state[2][0]) and (state[0][2] is not ' '):\n        return state[0][2], \"Done\"\n    # Check for draw\n    draw_flag = 0\n    for i in range(3):\n        for j in range(3):\n            if state[i][j] is ' ':\n                draw_flag = 1\n    if draw_flag is 0:\n        return None, \"Draw\"\n    return None, \"Not Done\"\n\ndef play_move(state, player, block_num):\n    '''\n    Play a move on the board\n    '''\n    if state[int((block_num-1)/3)][(block_num-1)%3] is ' ':\n        state[int((block_num-1)/3)][(block_num-1)%3] = player\n    else:\n        return \"Invalid\"\n\ndef copy_game_state(state):\n    '''\n    Copy the game state\n    '''\n    new_state = [row[:] for row in state]\n    return new_state\n\n# main function\ndef main_solution(state, player):\n    '''\n    Main function to get the best move using the minimax algorithm\n    '''\n    # Convert state to a list of lists if it's not already\n    if not isinstance(state, list):\n        state = [list(row) for row in state]\n    \n    # Get the best move using the minimax algorithm\n    best_move = getBestMove(state, player)\n    \n    # Return the best move as an integer\n    return best_move\n\ndef getBestMove(state, player):\n    '''\n    Minimax Algorithm\n    '''\n    winner_loser , done = check_current_state(state)\n    if done == \"Done\" and winner_loser == 'O': # If AI won\n        return 1\n    elif done == \"Done\" and winner_loser == 'X': # If Human won\n        return -1\n    elif done == \"Draw\":    # Draw condition\n        return 0\n\n    moves = []\n    empty_cells = []\n    for i in range(3):\n        for j in range(3):\n            if state[i][j] is ' ':\n                empty_cells.append( i *3 + ( j +1))\n\n    for empty_cell in empty_cells:\n        move = {}\n        move['index'] = empty_cell\n        new_state = copy_game_state(state)\n        play_move(new_state, player, empty_cell)\n\n        if player == 'O':    # If AI\n            result = getBestMove(new_state, 'X')    # make more depth tree for human\n            move['score'] = result\n        else:\n            result = getBestMove(new_state, 'O')    # make more depth tree for AI\n            move['score'] = result\n\n        moves.append(move)\n\n    # Find best move\n    best_move = None\n    if player == 'O':   # If AI player\n        best = -infinity\n        for move in moves:\n            if move['score'] > best:\n                best = move['score']\n                best_move = move['index']\n    else:\n        best = infinity\n        for move in moves:\n            if move['score'] < best:\n                best = move['score']\n                best_move = move['index']\n\n    return best_move", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random Tic-Tac-Toe board state\n    state = [[' ' for _ in range(3)] for _ in range(3)]\n    players = ['X', 'O']\n    current_player = random.choice(players)\n    \n    # Randomly fill some cells\n    empty_cells = [(i, j) for i in range(3) for j in range(3)]\n    num_moves = random.randint(0, 8)  # Up to 8 moves to leave at least one empty cell\n    \n    for _ in range(num_moves):\n        if not empty_cells:\n            break\n        i, j = random.choice(empty_cells)\n        state[i][j] = current_player\n        current_player = 'O' if current_player == 'X' else 'X'\n        empty_cells.remove((i, j))\n    \n    # Ensure the game is not already over\n    winner, done = check_current_state(state)\n    if done == \"Done\" or done == \"Draw\":\n        # Reset to a nearly empty board if the game is already over\n        state = [[' ' for _ in range(3)] for _ in range(3)]\n        state[0][0] = 'X' if random.random() > 0.5 else 'O'\n    \n    # Randomly choose the player ('X' or 'O')\n    player = random.choice(['X', 'O'])\n    \n    return {'state': state, 'player': player}", "io_pairs": [{"input": {"state": [[" ", "O", " "], [" ", " ", " "], ["X", " ", " "]], "player": "O"}, "output": 4}, {"input": {"state": [[" ", " ", "O"], [" ", "X", "X"], [" ", " ", "O"]], "player": "X"}, "output": 4}, {"input": {"state": [[" ", "O", " "], [" ", " ", "O"], ["X", "X", " "]], "player": "X"}, "output": 9}, {"input": {"state": [[" ", " ", " "], [" ", " ", " "], [" ", " ", "X"]], "player": "O"}, "output": 1}, {"input": {"state": [["X", " ", " "], [" ", " ", " "], [" ", " ", " "]], "player": "X"}, "output": 3}, {"input": {"state": [[" ", "X", " "], ["X", "O", "O"], ["X", " ", " "]], "player": "O"}, "output": 1}, {"input": {"state": [[" ", " ", " "], [" ", "O", "X"], [" ", " ", " "]], "player": "X"}, "output": 2}, {"input": {"state": [["O", " ", " "], [" ", " ", "X"], [" ", " ", " "]], "player": "X"}, "output": 3}, {"input": {"state": [[" ", " ", " "], [" ", " ", "X"], [" ", " ", " "]], "player": "X"}, "output": 3}, {"input": {"state": [[" ", "X", "X"], [" ", "O", "X"], ["O", "O", " "]], "player": "X"}, "output": 1}], "error_log": []}
{"context": "Given the parameters of a fluid flow system, including the friction factor, pipe length, flow rate, head loss, and kinematic viscosity, what are the calculated values for the pipe diameter, Reynolds number, and friction coefficient?\n\nThe input and output requirements are as follows:\n\nInput:\n  `f` (float): The friction factor.\n  `L` (float): The length of the pipe.\n  `Q` (float): The flow rate.\n  `dH` (float): The head loss.\n  `v` (float): The kinematic viscosity.\n\nOutput:\n  `return` (dict): A dictionary containing the calculated values:\n    - `D` (float): The diameter of the pipe, rounded to 4 decimal places.\n    - `Rey` (float): The Reynolds number, rounded to 4 decimal places.\n    - `k` (float): The friction coefficient, rounded to 4 decimal places.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(f, L, Q, dH, v):\n    # Convert inputs to appropriate types\n    f = float(f)\n    L = float(L)\n    Q = float(Q)\n    dH = float(dH)\n    v = float(v)\n    \n    g = 9.81\n    e = 0.000002\n    \n    D = ((8 * f * L * (Q ** 2)) / ((math.pi ** 2) * g * dH)) ** 0.2\n    Rey = (4 * Q) / (math.pi * D * v)\n    k = (0.25 / ((math.log10((e / (3.7 * D)) + (5.74 / (Rey ** 0.9)))) ** 2))\n    \n    # Return JSON serializable outputs\n    return {\n        \"D\": round(D, 4),\n        \"Rey\": round(Rey, 4),\n        \"k\": round(k, 4)\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    f = random.uniform(0.001, 0.1)\n    L = random.uniform(10, 1000)\n    Q = random.uniform(0.1, 10)\n    dH = random.uniform(1, 100)\n    v = random.uniform(1e-6, 1e-4)\n    \n    return {\n        \"f\": f,\n        \"L\": L,\n        \"Q\": Q,\n        \"dH\": dH,\n        \"v\": v\n    }", "io_pairs": [{"input": {"f": 0.0208255586134106, "L": 934.2516745393272, "Q": 8.121469108763952, "dH": 34.588892453143714, "v": 9.528894714074436e-05}, "output": {"D": 1.2511, "Rey": 86735.9868, "k": 0.0184}}, {"input": {"f": 0.02102193255697462, "L": 813.3632570454615, "Q": 5.118953627238242, "dH": 28.94326758165448, "v": 2.869115524362145e-05}, "output": {"D": 1.0505, "Rey": 216254.2383, "k": 0.0153}}, {"input": {"f": 0.07300366546059114, "L": 867.0657736550049, "Q": 1.149970342184216, "dH": 27.490285821171728, "v": 4.579835628486924e-05}, "output": {"D": 0.7588, "Rey": 42131.2625, "k": 0.0216}}, {"input": {"f": 0.01980896671455908, "L": 183.31036648205315, "Q": 3.6784048052674065, "dH": 40.94939954510076, "v": 3.786495587208413e-05}, "output": {"D": 0.6299, "Rey": 196373.9462, "k": 0.0156}}, {"input": {"f": 0.002686320812719306, "L": 434.4191339260495, "Q": 1.3240959713761034, "dH": 32.99294106095077, "v": 2.138038855443553e-05}, "output": {"D": 0.3483, "Rey": 226408.5371, "k": 0.0152}}, {"input": {"f": 0.03253067272570069, "L": 792.329555749041, "Q": 9.264382390272353, "dH": 1.7238225194191639, "v": 6.543980520053244e-05}, "output": {"D": 2.5415, "Rey": 70923.8801, "k": 0.0192}}, {"input": {"f": 0.08067321851910077, "L": 369.5276088428934, "Q": 3.067517136023264, "dH": 27.942681864549748, "v": 8.796184445407487e-05}, "output": {"D": 0.9633, "Rey": 46093.7567, "k": 0.0212}}, {"input": {"f": 0.061863840391756, "L": 707.826458966665, "Q": 2.8534081909812166, "dH": 78.21668910640004, "v": 9.399532149844444e-05}, "output": {"D": 0.8226, "Rey": 46987.8018, "k": 0.0211}}, {"input": {"f": 0.037574597925311426, "L": 133.547305759762, "Q": 1.5160952358078077, "dH": 55.67649148989374, "v": 4.4784606551345924e-05}, "output": {"D": 0.4433, "Rey": 97234.7442, "k": 0.018}}, {"input": {"f": 0.07336240791455491, "L": 665.5627805704243, "Q": 1.0037755222509954, "dH": 10.244049135617235, "v": 7.003145153157216e-05}, "output": {"D": 0.8312, "Rey": 21955.1553, "k": 0.0252}}], "error_log": []}
{"context": "Given a 3x3 matrix with integer elements, what is the inverse of this matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_elements` (list of lists of floats): A 2D list representing the elements of a square matrix. Each sublist represents a row in the matrix.\n\nOutput:\n  `return` (list of lists of floats): A 2D list representing the elements of the inverse of the input matrix. Each sublist represents a row in the inverse matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix_elements):\n    # Convert the JSON serializable input to a numpy array\n    A = np.array(matrix_elements)\n    \n    # Calculate the inverse of the matrix\n    inverse_matrix = np.linalg.inv(A)\n    \n    # Convert the inverse matrix to a JSON serializable output\n    inverse_matrix_list = inverse_matrix.tolist()\n    \n    return inverse_matrix_list", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.choice([2, 3, 4])\n    while True:\n        matrix = np.random.rand(size, size) * 10 - 5  # Values between -5 and 5\n        if np.linalg.det(matrix) != 0:  # Ensure matrix is invertible\n            break\n    return {'matrix_elements': matrix.tolist()}", "io_pairs": [{"input": {"matrix_elements": [[4.625106595798931, 1.1305480072431653], [0.05313057086926598, -1.7044779333449176]]}, "output": [[0.2145762919878885, 0.14232440007743102], [0.006688594005998085, -0.5822534888601757]]}, {"input": {"matrix_elements": [[-1.9030740741016094, 4.348341980456695], [-2.766067134453624, 4.762609683446419]]}, "output": [[1.6067062657912192, -1.4669495865021311], [0.9331559149121272, -0.6420179780324168]]}, {"input": {"matrix_elements": [[1.5764626995228062, -4.859725697608692], [-2.3973781427119634, 2.771755482791005]]}, "output": [[-0.38068172886620993, -0.6674502104775736], [-0.32926355220723774, -0.21651640978919823]]}, {"input": {"matrix_elements": [[-4.235834806004577, -2.1759608415074227], [1.4877246049541712, 1.1092604470863403]]}, "output": [[-0.7590325573941299, -1.488942589323485], [1.0180038552376525, 2.8984505252538493]]}, {"input": {"matrix_elements": [[-2.7637474750119875, 1.1941891178805548], [0.18632668756148263, -3.149123414573097]]}, "output": [[-0.3713206847292455, -0.14080969926284495], [-0.02197022602813458, -0.32588008462643675]]}, {"input": {"matrix_elements": [[2.6517343785590066, 4.974687744023809, 3.6854884782428528], [-0.2897970691514695, 0.5447027428228317, -4.7445549819720725], [-2.6418725686229116, 2.829428766225133, 2.6081127809415907]]}, "output": [[0.13775763044581918, -0.02363283436032576, -0.23765515292507158], [0.12333051686138763, 0.15453152171627071, 0.10683974418532559], [0.005744840844984045, -0.1915833062508595, 0.026781788591234947]]}, {"input": {"matrix_elements": [[2.796844307525558, -1.1552917290018616], [2.381994371675863, 2.0787527259537804]]}, "output": [[0.24267920480349, 0.13487187514406393], [-0.2780804531233793, 0.3265111545184144]]}, {"input": {"matrix_elements": [[0.6429098153934607, -1.5399440042901205], [-3.9147403412910107, -1.6888871743495324]]}, "output": [[0.23739386815009994, -0.21645807337827927], [-0.5502649120301627, -0.09036888328949642]]}, {"input": {"matrix_elements": [[-3.688261896811844, -1.9325709677066651], [-3.996719237296862, 2.271944846195919]]}, "output": [[-0.14108416886865544, -0.12000958967604963], [-0.2481899209567207, 0.22903520970277866]]}, {"input": {"matrix_elements": [[4.83990107435903, -2.5715422907527374], [-0.7210176701705056, 4.869643006397119]]}, "output": [[0.22425804447807246, 0.11842532289518777], [0.03320449004868742, 0.22288836142140905]]}], "error_log": []}
{"context": "Given a set of data points, each with the same number of dimensions, what are the mean and covariance matrix of the data set?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data_points` (list of lists): A list of lists where each inner list represents a data point with the same number of dimensions. Each inner list should contain numerical values.\n\nOutput:\n  `mean` (list): A list representing the mean of the data set. The length of the list is equal to the number of dimensions in each data point.\n  `cov` (list of lists): A list of lists representing the covariance matrix of the data set. The size of the matrix is (number of dimensions) x (number of dimensions).", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(data_points):\n    \"\"\"\n    Calculate the mean and covariance of a data set.\n\n    Args:\n        data_points (list of lists): A list of lists where each inner list represents a data point with the same number of dimensions.\n\n    Returns:\n        mean (list): A list representing the mean of the data set.\n        cov (list of lists): A list of lists representing the covariance matrix of the data set.\n    \"\"\"\n    # Convert the input list of lists to a numpy array\n    X = np.array(data_points)\n    \n    # Calculate the mean and covariance using the provided function\n    mean, cov = mean_cov(X)\n    \n    # Convert the numpy arrays to lists for JSON serialization\n    mean_list = mean.tolist()[0]\n    cov_list = cov.tolist()\n    \n    return mean_list, cov_list\n\ndef mean_cov(X):\n    \"\"\"\n    X is a numpy.ndarray of shape (n, d) containing the data set:\n    n is the number of data points\n    d is the number of dimensions in each data point\n    Returns: mean, cov:\n        mean numpy.ndarray of shape (1, d) containing the mean of the data set\n        cov numpy.ndarray of shape (d, d) containing the covariance matrix\n            of the data set\n    \"\"\"\n    if not isinstance(X, np.ndarray) or len(X.shape) != 2:\n        raise TypeError(\"X must be a 2D numpy.ndarray\")\n    if X.shape[0] < 2:\n        raise ValueError(\"X must contain multiple data points\")\n    d = X.shape[1]\n    mean = np.mean(X, axis=0)\n    a = X - mean\n    c = np.matmul(a.T, a)\n    cov = c/(X.shape[0] - 1)\n    return mean.reshape((1, d)), cov", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the number of data points (between 2 and 100)\n    n = random.randint(2, 100)\n    # Randomly choose the number of dimensions (between 1 and 10)\n    d = random.randint(1, 10)\n    # Generate random data points\n    data_points = [[random.uniform(-10, 10) for _ in range(d)] for _ in range(n)]\n    return {'data_points': data_points}", "io_pairs": [{"input": {"data_points": [[-2.218801226974099, -0.6616968438857924], [-4.411197769552018, -7.545466291608404], [-7.40481303439646, 6.900000884410662], [7.407985863835272, 1.1209548528953643]]}, "output": [[-1.6567065417718263, -0.0465518495470425], [[41.037516339291706, -2.7816573172726007], [-2.7816573172726007, 35.409929319773234]]]}, {"input": {"data_points": [[-5.814795322440796, 1.054679705921167, -8.933951922659295], [1.749209345872071, 6.742828245637934, -6.888307273472519]]}, "output": [[-2.0327929882843625, 3.8987539757795506, -7.911129598065907], [[28.607083311129422, 21.512591054237323, 7.736632838079007], [21.512591054237323, 16.177516904940997, 5.817965312025591], [7.736632838079007, 5.817965312025591, 2.092331015373245]]]}, {"input": {"data_points": [[2.9049416850879677, -2.0141633709961093, 0.7731272145243491], [-1.0498711584800482, 1.2035341589236754, -5.92726462174787], [0.4675001184740939, 6.113667226442384, 9.067216475133073]]}, "output": [[0.7741902150273378, 1.767679338123317, 1.304359689303184], [[3.9806802684055125, -4.181001463326814, 4.839105449875533], [-4.181001463326814, 16.754102392574993, 19.913002612212182], [4.839105449875533, 19.913002612212182, 56.42027179787471]]]}, {"input": {"data_points": [[1.4757212241385016, 3.927324740907853], [-0.1212659704331287, -6.538394171143683], [2.303970038768803, -4.301234481755378]]}, "output": [[1.219475097491392, -2.304101303997069], [[1.5196889831486629, 2.553994149880985], [2.553994149880985, 30.374223783795543]]]}, {"input": {"data_points": [[-7.1307049995632354], [6.210230562326924], [-9.295739950377905], [-8.366846110182195], [-4.267751704717899]]}, "output": [[-4.570162440502862], [[39.902648358696354]]]}, {"input": {"data_points": [[2.9013054645169944], [-8.872028369197231], [-2.092051418845438], [-7.927836884144092]]}, "output": [[-3.9976528019174418], [[30.144275294750624]]]}, {"input": {"data_points": [[-5.6514236187625055, 7.0126462746696845], [-0.28655872024534546, -0.8045626771308783], [-1.6352796345263307, 4.833306172839848]]}, "output": [[-2.5244206578447272, 3.6804632567928848], [[7.788372664346149, -9.71578752989772], [-9.71578752989772, 16.273974040837462]]]}, {"input": {"data_points": [[2.395888779768857, -7.936163316901512, -7.020583074430595], [0.41289742963275344, -4.024094492846945, 1.1764377771314223]]}, "output": [[1.4043931047008051, -5.9801289048742285, -2.9220726486495865], [[1.966127347357303, -3.8787993196186616, -8.127310722766378], [-3.8787993196186616, 7.652141242069839, 16.033654861760493], [-8.127310722766378, 16.033654861760493, 33.59557542047125]]]}, {"input": {"data_points": [[3.181453672676737], [-3.6251139777903107], [-6.266105252190317], [3.7354372212641103]]}, "output": [[-0.7435820840099452], [[24.756335942083037]]]}, {"input": {"data_points": [[8.526492280940342, 4.813365095809294, -7.592075282051061], [-8.256682213208212, 6.584118777292623, 8.69402765173323], [7.022706859271814, 9.167974151732658, 9.615086878456594], [4.744296936603172, 8.869071064642707, 1.1800211979431285]]}, "output": [[3.0092034659017792, 7.358632272369321, 2.974265111520473], [[58.826471614662864, 1.521719542300497, -33.06532092065503], [1.521719542300497, 4.211133178584037, 10.58984914350885], [-33.06532092065503, 10.58984914350885, 63.894352596954825]]]}], "error_log": []}
{"context": "In a festive logistics operation, Santa's elves need to calculate the total weighted reindeer weariness for a set of trips. Each trip consists of multiple stops, and each stop has a specific weight. The weariness is calculated based on the distance traveled and the weight carried at each stop. Given the details of all trips, including the latitude, longitude, and weight of each stop, what is the total weighted reindeer weariness?\n\nThe input and output requirements are as follows:\n\nInput:\n  `all_trips_data` (list of dictionaries): Each dictionary represents a trip with keys `'TripId'` (str), `'Latitude'` (float), `'Longitude'` (float), and `'Weight'` (float).\n\nOutput:\n  `return` (float): The total weighted reindeer weariness, which is the sum of the weighted distances for all trips.", "reference_code": "# import necessary packages\nimport pandas as pd\nimport numpy as np\nfrom math import radians, cos, sin, asin, sqrt\n\n# all class and function definitions in the code file, if any\ndef haversine(lat1, lon1, lat2, lon2):\n    \"\"\" Calculate the great-circle distance between two points on the Earth surface.\n    Takes 4 numbers, containing the latitude and longitude of each point in decimal degrees.\n\n    The default returned unit is kilometers.\n    \"\"\"\n    avg_earth_radius = 6371.0\n    lat1, lon1, lat2, lon2 = map(radians, (lat1, lon1, lat2, lon2))\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    d = sin(dlat * 0.5) ** 2 + cos(lat1) * cos(lat2) * sin(dlon * 0.5) ** 2\n    c = 2.0 * avg_earth_radius\n    return c  * asin(sqrt(d))\n\ndef weighted_trip_length(stops_latitude, stops_longitude, weights):\n    north_pole = (90,0)\n    sleigh_weight = 10\n    dist = 0.0\n    prev_lat, prev_lon = north_pole\n    prev_weight = np.sum(weights) + sleigh_weight\n    for lat, lon, weight in zip(stops_latitude, stops_longitude, weights):\n        dist += haversine(lat, lon, prev_lat, prev_lon) * prev_weight\n        prev_lat, prev_lon = lat, lon\n        prev_weight -= weight\n    dist += haversine(north_pole[0], north_pole[1], prev_lat, prev_lon) * sleigh_weight\n    return dist\n\ndef weighted_reindeer_weariness(all_trips, weight_limit = 1000):\n    uniq_trips = all_trips['TripId'].unique()\n    \n    if any(all_trips.groupby('TripId')['Weight'].sum() > weight_limit):\n        raise Exception(\"One of the sleighs over weight limit!\")\n \n    dist = 0.0\n    for t in uniq_trips:\n        this_trip = all_trips[all_trips['TripId']==t]\n        dist += weighted_trip_length(this_trip['Latitude'], this_trip['Longitude'], this_trip['Weight'])\n    \n    return dist    \n\n# main function\ndef main_solution(all_trips_data):\n    # Convert input data to DataFrame\n    all_trips = pd.DataFrame(all_trips_data)\n    \n    # Calculate weighted reindeer weariness\n    weariness = weighted_reindeer_weariness(all_trips)\n    \n    # Return the result as a float\n    return weariness", "input_generator": "import numpy as np\nimport pandas as pd\nimport random\n\ndef input_generator():\n    num_trips = random.randint(1, 5)\n    trip_ids = []\n    latitudes = []\n    longitudes = []\n    weights = []\n    \n    for trip_id in range(num_trips):\n        num_stops = random.randint(1, 10)\n        trip_ids.extend([trip_id] * num_stops)\n        # Generate random latitudes (-90 to 90) and longitudes (-180 to 180)\n        trip_lats = [random.uniform(-90, 90) for _ in range(num_stops)]\n        trip_lons = [random.uniform(-180, 180) for _ in range(num_stops)]\n        trip_weights = [random.uniform(1, 100) for _ in range(num_stops)]\n        \n        latitudes.extend(trip_lats)\n        longitudes.extend(trip_lons)\n        weights.extend(trip_weights)\n    \n    all_trips_data = {\n        'TripId': trip_ids,\n        'Latitude': latitudes,\n        'Longitude': longitudes,\n        'Weight': weights\n    }\n    \n    return {'all_trips_data': all_trips_data}", "io_pairs": [], "error_log": []}
{"context": "Given a mathematical function that calculates a specific value based on an integer input, what is the result of the function when applied to a randomly chosen integer between 2 and 10?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer representing the input value for the function.\n\nOutput:\n  `return` (float): A floating-point number representing the result of the calculation.", "reference_code": "# import necessary packages\nfrom math import pi, atan, sqrt, log, factorial\n\n# main function\ndef main_solution(n):\n    # Convert the input to the required format for the original function\n    n = int(n)\n    \n    # Calculate the result using the original function logic\n    result = (-1) * (1 * n * (pi * n - atan(sqrt(sqrt(5) - 1))) - log(factorial(n))) / log(n)\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\nfrom math import factorial\n\ndef input_generator():\n    n = random.randint(1, 20)  # Reasonable range to avoid factorial becoming too large\n    return {'n': n}", "io_pairs": [{"input": {"n": 6}, "output": -56.641746476112694}, {"input": {"n": 3}, "output": -21.816363518581}, {"input": {"n": 13}, "output": -193.95287965710807}, {"input": {"n": 2}, "output": -14.710666769527684}, {"input": {"n": 20}, "output": -399.74726485522126}, {"input": {"n": 12}, "output": -169.96321782439395}, {"input": {"n": 5}, "output": -43.22062284210694}, {"input": {"n": 7}, "output": -71.71189116741844}, {"input": {"n": 15}, "output": -246.07550798543315}, {"input": {"n": 16}, "output": -274.17096636390755}], "error_log": []}
{"context": "Given a list of words, each composed of alphabetic characters and having no more than 10 unique characters, determine the highest square number that can be formed by mapping the letters of these words to digits in such a way that the anagram property between the words and the numbers is preserved. What is the largest square number that can be derived from these mappings?\n\nThe input and output requirements are as follows:\n\nInput:\n  `words` (list of strings): A list of words where each word is a string. The words should be composed of alphabetic characters and should not exceed 10 unique characters.\n\nOutput:\n  `return` (int): The highest square number found that can be formed by mapping letters to digits in a way that preserves the anagram property between words and numbers.", "reference_code": "# import necessary packages\nfrom collections import defaultdict\nfrom itertools import groupby\nfrom math import floor, ceil, sqrt\nimport random\n\n# all class and function definitions in the code file, if any\nclass Word:\n    def __init__(self, word):\n        self._raw = word\n        self._value = word.upper()\n\n    @property\n    def raw(self):\n        return self._raw\n\n    @property\n    def value(self):\n        return self._value\n\n    @property\n    def letters(self):\n        return set(self.value)\n\n    @property\n    def occurences(self):\n        word = self.value\n        return { c: word.count(c) for c in word }\n\n    @property\n    def sorted_characters(self):\n        return ''.join(sorted(self.value))\n\n    @property\n    def sorted_letter_counts(self):\n        return [ n for n in sorted(self.occurences.values()) ]\n\n    def count(self, char):\n        return self.occurences.get(char.upper(), 0)\n\n    def is_anagram_of(self, other):\n        return self.occurences == other.occurences\n\n    def __len__(self):\n        return len(self._value)\n\n    def __repr__(self):\n        return '{}({!r})'.format(self.__class__.__name__, self.raw)\n\n    def __str__(self):\n        return self.raw\n\ndef group_anagrams(words):\n    key = lambda w: w.sorted_characters\n    words = sorted(words, key=key)\n    anagrams = groupby(words, key)\n    return [ list(g) for _, g in anagrams ]\n\n# main function\ndef main_solution(words):\n    words = [Word(word) for word in words if len(word) <= 10]\n    anagrams = group_anagrams(words)\n    anagrams = [g for g in anagrams if len(g) > 1]\n\n    square_anagrams_for_digits = {}\n\n    for digits in range(1, 10 + 1):\n        lo = ceil(sqrt(10 ** (digits - 1)))\n        hi = floor(sqrt(10 ** digits - 1))\n\n        squares = []\n\n        for base in range(lo, hi + 1):\n            square = base ** 2\n            square = Word(str(square))\n            squares.append(square)\n\n        square_anagrams = [g for g in group_anagrams(squares) if len(g) > 1]\n        square_anagrams_for_digits[digits] = square_anagrams\n\n    compatibles = defaultdict(list)\n\n    for group in anagrams:\n        for word in group:\n            for numbers in square_anagrams_for_digits[len(word)]:\n                for number in numbers:\n                    char_map, digit_map = {}, {}\n                    compatible = True\n                    for char, digit in zip(word.value, number.value):\n                        if char_map.get(char, digit) != digit or \\\n                                digit_map.get(digit, char) != char:\n                            compatible = False\n                            break\n                        char_map[char] = digit\n                        digit_map[digit] = char\n                    if not compatible:\n                        continue\n                    items = sorted(char_map.items())\n                    chars = ''.join(str(k) for k, _ in items)\n                    numbers = ''.join(str(v) for _, v in items)\n                    compatibles[chars + numbers].append((word, number))\n\n    compatibles = {k: v for k, v in compatibles.items() if len(v) > 1}\n\n    highest = 0\n\n    for pairs in compatibles.values():\n        for word, number in pairs:\n            number = int(number.value)\n            highest = max(highest, number)\n\n    return highest", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a list of words with some anagrams and some non-anagrams\n    words = []\n    \n    # Common words that can form anagrams\n    base_words = [\n        'listen', 'silent', 'enlist', 'triangle', 'integral', 'altering',\n        'evil', 'vile', 'live', 'leap', 'peal', 'pale', 'plea',\n        'earth', 'heart', 'hater', 'rat', 'tar', 'art'\n    ]\n    \n    # Add some random words\n    for _ in range(random.randint(5, 15)):\n        length = random.randint(3, 10)\n        word = ''.join(random.choices(string.ascii_lowercase, k=length))\n        words.append(word)\n    \n    # Add some anagram groups from base_words\n    num_anagram_groups = random.randint(1, 3)\n    for _ in range(num_anagram_groups):\n        group_size = random.randint(2, 4)\n        group = random.sample(base_words, group_size)\n        words.extend(group)\n    \n    # Shuffle the words to mix anagrams and non-anagrams\n    random.shuffle(words)\n    \n    return {'words': words}", "io_pairs": [{"input": {"words": ["silent", "dzctq", "omsuxul", "dhoscqy", "yxxhjppmq", "rcmezi", "tizmr", "peal", "jwcfjtj", "pzcyxlp"]}, "output": 0}, {"input": {"words": ["pri", "efdpd", "enlist", "silent", "silent", "tsc", "lbphs", "peal", "evil", "ecas"]}, "output": 863041}, {"input": {"words": ["tsqpij", "hnqhkl", "tar", "ansftynbci", "katv", "bvsov", "xqckxifn", "rat", "heart", "vile"]}, "output": 961}, {"input": {"words": ["dkqpgnost", "listen", "heart", "nvmclj", "leap", "yhirwry", "hishisyic", "fdrfuqlfho"]}, "output": 0}, {"input": {"words": ["bpbtdtko", "heart", "tod", "silent", "heart", "vile", "ljmp", "qxgrxfzf", "wojksnt", "pbpzb"]}, "output": 96721}, {"input": {"words": ["lygiqsy", "integral", "sdzdy", "kgurhgladg", "rat", "wdondazxn", "ppx", "qgdy", "frpkc", "jkdvk"]}, "output": 0}, {"input": {"words": ["triangle", "gikfi", "altering", "ugkagxn", "cfraqo", "tar", "ialewqbdih", "gcbytrxaol", "yjgit"]}, "output": 0}, {"input": {"words": ["hater", "ijtbeu", "pale", "silent", "listen", "integral", "vfaypz", "pale", "gnoahafy", "integral", "piv", "mrqnsqtl"]}, "output": 98327056}, {"input": {"words": ["art", "frsaiqo", "rout", "txtrol", "silent", "earth", "zeq", "qqkveguq", "dyngxffw"]}, "output": 0}, {"input": {"words": ["evil", "jxtzxf", "hcpm", "qlwznx", "tar", "exwqup", "plea", "ikaqq", "wuhowifhba", "pbloxhcf"]}, "output": 0}], "error_log": []}
{"context": "Given a neural network with a specific architecture, how would the network respond to a particular input vector? Specifically, what would be the output of the network for a given set of input values?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sizes` (list of int): A list representing the number of neurons in each layer of the neural network.\n  `input_data` (list of float): A list of input values to the neural network. The length of this list should match the number of neurons in the input layer.\n\nOutput:\n  `return` (list of float): A list representing the output values from the neural network. The length of this list corresponds to the number of neurons in the output layer.", "reference_code": "# import necessary packages\nimport random\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef sigmoid(z):\n    \"\"\"The sigmoid function.\"\"\"\n    return 1.0 / (1.0 + np.exp(-z))\n\nsigmoid_vec = np.vectorize(sigmoid)\n\ndef sigmoid_prime(z):\n    \"\"\"Derivative of the sigmoid function.\"\"\"\n    return sigmoid(z) * (1 - sigmoid(z))\n\nsigmoid_prime_vec = np.vectorize(sigmoid_prime)\n\ndef init_network(sizes):\n    num_layers = len(sizes)\n    biases = [np.random.randn(y, 1) for y in sizes[1:]]\n    weights = [np.random.randn(y, x) for x, y in zip(sizes[:-1], sizes[1:])]\n    return weights, biases, num_layers\n\ndef feedforward(weights, biases, X):\n    \"\"\"\n    Return the output of the network if ``a`` is input.\n    \"\"\"\n    a = X\n    for b, w in zip(biases, weights):\n        a = sigmoid_vec(np.dot(w, a) + b)\n    return a\n\ndef backprop(weights, biases, X, z, num_layers=3):\n    \"\"\"\n    Return a tuple ``(nabla_b, nabla_w)`` representing the\n    gradient for the cost function C_x.  ``nabla_b`` and\n    ``nabla_w`` are layer-by-layer lists of numpy arrays, similar\n    to ``biases`` and ``weights``.\n    \"\"\"\n    nabla_b = [np.zeros(b.shape) for b in biases]\n    nabla_w = [np.zeros(w.shape) for w in weights]\n    # feedforward\n    activation = X\n    activations = [X] # list to store all the activations, layer by layer\n    zs = [] # list to store all the z vectors, layer by layer\n    for b, w in zip(biases, weights):\n        z = np.dot(w, activation) + b\n        zs.append(z)\n        activation = sigmoid_vec(z)\n        activations.append(activation)\n    # backward pass\n    delta = (activations[-1] - z) * sigmoid_prime_vec(zs[-1])\n    nabla_b[-1] = delta\n    nabla_w[-1] = np.dot(delta, activations[-2].transpose())\n    # Note that the variable l in the loop below is used a little\n    # differently to the notation in Chapter 2 of the book.  Here,\n    # l = 1 means the last layer of neurons, l = 2 is the\n    # second-last layer, and so on.  It's a renumbering of the\n    # scheme in the book, used here to take advantage of the fact\n    # that Python can use negative indices in lists.\n    for l in range(2, num_layers):\n        z = zs[-l]\n        spv = sigmoid_prime_vec(z)\n        delta = np.dot(weights[-l+1].transpose(), delta) * spv\n        nabla_b[-l] = delta\n        nabla_w[-l] = np.dot(delta, activations[-l-1].transpose())\n    return (nabla_b, nabla_w)\n\n# main function\ndef main_solution(sizes, input_data):\n    # Convert input_data to a numpy array\n    input_data = np.array(input_data).reshape(-1, 1)\n    \n    # Initialize the network\n    weights, biases, num_layers = init_network(sizes)\n    \n    # Feedforward to get the output\n    output = feedforward(weights, biases, input_data)\n    \n    # Convert the output to a list for JSON serialization\n    output = output.flatten().tolist()\n    \n    return output", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    # Randomly choose the number of layers (between 2 and 5)\n    num_layers = random.randint(2, 5)\n    \n    # Generate random layer sizes (between 1 and 10 neurons per layer)\n    sizes = [random.randint(1, 10) for _ in range(num_layers)]\n    \n    # Generate random input data matching the input layer size\n    input_size = sizes[0]\n    input_data = [random.uniform(-1.0, 1.0) for _ in range(input_size)]\n    \n    return {\n        'sizes': sizes,\n        'input_data': input_data\n    }", "io_pairs": [{"input": {"sizes": [10, 4], "input_data": [0.24422437298101474, 0.715524172388232, -0.6210732613353858, -0.9172841645491858, -0.5819594667762003, -0.16598794709072817, 0.6390133992315279, -0.07297138314571328, -0.7639251252845314, -0.269913986407611]}, "output": [0.03666162406791732, 0.0676196008219756, 0.3002670984052063, 0.25940004899895514]}, {"input": {"sizes": [8, 6, 10, 4, 4], "input_data": [0.9176263704576291, -0.29295022888172517, -0.9697590747919667, -0.5059694542292519, 0.2234656651341611, 0.27141463774817254, -0.9251468513161591, 0.23752452987232453]}, "output": [0.4132268046858961, 0.8605834931326756, 0.3272326320724333, 0.03036679739383547]}, {"input": {"sizes": [1, 3, 4, 4], "input_data": [-0.38420858351404696]}, "output": [0.5692789209076922, 0.14797171919561447, 0.6034848315128751, 0.15143509178231654]}, {"input": {"sizes": [2, 3], "input_data": [-0.15359044665382782, 0.7947654306121255]}, "output": [0.9048665192146785, 0.636457973394164, 0.1971770795275625]}, {"input": {"sizes": [7, 10, 10, 10, 9], "input_data": [-0.578212524663569, -0.8498499852356454, 0.5317856388389384, -0.7765054100747453, -0.41167938963845696, 0.5508265929800138, 0.21072941019980918]}, "output": [0.9763806639149162, 0.06385326708757241, 0.3641105769896496, 0.9025166687343802, 0.11510625278205251, 0.2622833373261822, 0.7565889812019966, 0.8669159673120286, 0.11933439623944989]}, {"input": {"sizes": [2, 9, 10, 4, 7], "input_data": [0.27559928171476167, 0.894320219375728]}, "output": [0.7918552723833637, 0.5778832691308539, 0.6054153349293862, 0.7899090578348905, 0.30635577396917496, 0.09343503629463902, 0.30819443616853814]}, {"input": {"sizes": [8, 6], "input_data": [-0.09670232987854566, -0.7341161240033531, -0.11007571737225375, 0.4904548105083346, 0.45221044169569535, 0.48512005468006336, 0.908010880634528, 0.7103150108009377]}, "output": [0.9702009028429545, 0.4108637730146186, 0.9450597130896077, 0.29351875182987563, 0.349165473555921, 0.398577944329915]}, {"input": {"sizes": [1, 3, 1, 6, 10], "input_data": [0.1997880708065689]}, "output": [0.24263376922126698, 0.2841513716128686, 0.8564859865198771, 0.4396105441068212, 0.9046170779910638, 0.9398174409311035, 0.47429290676395547, 0.7289807135544938, 0.23991881443570887, 0.9330484151418554]}, {"input": {"sizes": [3, 10], "input_data": [-0.7421975065864534, -0.8142228683953545, -0.4849400348719968]}, "output": [0.5208424611825756, 0.3405366101001066, 0.025706553706569362, 0.6434953352586107, 0.6297119607617677, 0.22836014328067986, 0.6489954213221737, 0.16249571856087158, 0.7020431581605083, 0.028937745559954056]}, {"input": {"sizes": [6, 6], "input_data": [0.7211527818018848, 0.8654680664875474, -0.2516602580701621, -0.30718653928382733, -0.26736696945822835, 0.702500412910328]}, "output": [0.02633614740855577, 0.43564483948437227, 0.543117558363237, 0.8857133401873369, 0.7535740648586139, 0.34369221102531883]}], "error_log": []}
{"context": "Given a partially filled Tic Tac Toe board, what is the optimal move for the current player to maximize their chances of winning or forcing a draw?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists of strings/None): A 3x3 grid representing the Tic Tac Toe board. Each cell can be `\"X\"`, `\"O\"`, or `None` (representing an empty cell).\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"optimal_action\"` whose value is a tuple `(i, j)` representing the optimal move for the current player on the board. If the game is over, the value will be `None`.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    x_count = sum(row.count(X) for row in board)\n    o_count = sum(row.count(O) for row in board)\n    return X if x_count == o_count else O\n\n# Function to get all possible actions\ndef actions(board):\n    possible_actions = []\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == EMPTY:\n                possible_actions.append((i, j))\n    return possible_actions\n\n# Function to get the result of an action\ndef result(board, action):\n    new_board = [row[:] for row in board]\n    new_board[action[0]][action[1]] = player(board)\n    return new_board\n\n# Function to determine the winner\ndef winner(board):\n    lines = [\n        [(0, 0), (0, 1), (0, 2)],\n        [(1, 0), (1, 1), (1, 2)],\n        [(2, 0), (2, 1), (2, 2)],\n        [(0, 0), (1, 0), (2, 0)],\n        [(0, 1), (1, 1), (2, 1)],\n        [(0, 2), (1, 2), (2, 2)],\n        [(0, 0), (1, 1), (2, 2)],\n        [(2, 0), (1, 1), (0, 2)],\n    ]\n    for line in lines:\n        if board[line[0][0]][line[0][1]] == board[line[1][0]][line[1][1]] == board[line[2][0]][line[2][1]] != EMPTY:\n            return board[line[0][0]][line[0][1]]\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or not any(EMPTY in row for row in board)\n\n# Function to get the utility of the board\ndef utility(board):\n    win = winner(board)\n    if win == X:\n        return 1\n    elif win == O:\n        return -1\n    else:\n        return 0\n\n# Minimax functions\ndef max_value(board):\n    if terminal(board):\n        return utility(board)\n    v = -math.inf\n    for action in actions(board):\n        v = max(v, min_value(result(board, action)))\n    return v\n\ndef min_value(board):\n    if terminal(board):\n        return utility(board)\n    v = math.inf\n    for action in actions(board):\n        v = min(v, max_value(result(board, action)))\n    return v\n\n# Function to get the optimal action using minimax\ndef minimax(board):\n    if terminal(board):\n        return None\n    if player(board) == X:\n        best_score = -math.inf\n        best_action = None\n        for action in actions(board):\n            score = min_value(result(board, action))\n            if score > best_score:\n                best_score = score\n                best_action = action\n        return best_action\n    else:\n        best_score = math.inf\n        best_action = None\n        for action in actions(board):\n            score = max_value(result(board, action))\n            if score < best_score:\n                best_score = score\n                best_action = action\n        return best_action\n\n# Main function\ndef main_solution(board):\n    \"\"\"\n    Returns the optimal action for the current player on the board.\n    \"\"\"\n    action = minimax(board)\n    return {\"optimal_action\": action}", "input_generator": "import random\n\ndef input_generator():\n    board = [[None, None, None], [None, None, None], [None, None, None]]\n    symbols = ['X', 'O']\n    current_symbol = random.choice(symbols)\n    \n    # Randomly fill the board with some moves\n    moves = random.randint(0, 8)\n    for _ in range(moves):\n        empty_positions = [(i, j) for i in range(3) for j in range(3) if board[i][j] is None]\n        if not empty_positions:\n            break\n        pos = random.choice(empty_positions)\n        board[pos[0]][pos[1]] = current_symbol\n        current_symbol = 'O' if current_symbol == 'X' else 'X'\n    \n    return {\"board\": board}", "io_pairs": [{"input": {"board": [["O", "X", null], ["O", null, "O"], ["X", null, "X"]]}, "output": {"optimal_action": [1, 1]}}, {"input": {"board": [[null, null, null], [null, null, null], [null, null, null]]}, "output": {"optimal_action": [0, 0]}}, {"input": {"board": [["X", "O", "X"], ["O", "X", "O"], [null, "X", "O"]]}, "output": {"optimal_action": [2, 0]}}, {"input": {"board": [["O", "X", "O"], ["X", "O", "O"], [null, "X", "X"]]}, "output": {"optimal_action": [2, 0]}}, {"input": {"board": [[null, null, "O"], ["X", "O", null], ["X", null, null]]}, "output": {"optimal_action": [0, 0]}}, {"input": {"board": [["X", "O", null], ["O", "X", "O"], [null, "O", "X"]]}, "output": {"optimal_action": null}}, {"input": {"board": [[null, null, "X"], [null, "X", "X"], ["O", "O", "O"]]}, "output": {"optimal_action": null}}, {"input": {"board": [[null, null, "X"], [null, null, null], [null, null, null]]}, "output": {"optimal_action": [1, 1]}}, {"input": {"board": [[null, null, "X"], ["O", null, null], ["O", "X", null]]}, "output": {"optimal_action": [0, 0]}}, {"input": {"board": [[null, null, null], [null, null, null], ["O", null, "X"]]}, "output": {"optimal_action": [0, 0]}}], "error_log": []}
{"context": "In a game of Connect Four, the AI is about to make its move. Given the current state of the board, what will be the updated board state and the result of the game after the AI's move?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_state` (list of strings): A list of 7 strings, each string representing a column of the Connect Four board. Each string has 6 characters, representing the cells in that column. The characters can be `'_'` (empty), `'X'`, or `'O'`.\n\nOutput:\n  `return` (dictionary): A dictionary with two keys:\n  - `board_state` (list of strings): The updated board state after the AI's move.\n  - `result` (string): A string indicating the result of the game after the AI's move. Possible values are `'I won, yay!'`, `'You won, well done!'`, or `'It\\'s a draw.'`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef transform(x):\n    if x == 'X':\n        return -1.01\n    else:\n        return 1\n\ndef endtext(x):\n    if x > 90000:\n        return 'I won, yay!'\n    if x < -90000:\n        return 'You won, well done!'\n    else:\n        return 'It\\'s a draw.'\n\ndef setup():\n    board = []\n    for i in range(7):\n        board.append(['_', '_', '_', '_', '_', '_'])\n    return board\n\ndef move(column, player, board):\n    done = False\n    for i in range(6):\n        if board[column-1][i] == '_' and done == False:\n            board[column-1][i] = player\n            done = True\n    return board\n\ndef evaluate(board):\n    w = 0\n    # check for winners vertically:\n    for c in range(7):\n        for r in range(3):\n            if board[c][r]==board[c][r+1]==board[c][r+2]==board[c][r+3]!='_':\n                w += transform(board[c][r])*100000\n    # horizontally:\n    for c in range(4):\n        for r in range(6):\n            if board[c][r]==board[c+1][r]==board[c+2][r]==board[c+3][r]!='_':\n                w += transform(board[c][r])*100000\n    # / diagonally:\n    for c in range(4):\n        for r in range(3):\n            if board[c][r]==board[c+1][r+1]==board[c+2][r+2]==board[c+3][r+3]!='_':\n                w += transform(board[c][r])*100000\n    # \\ diagonally:\n    for c in range(3,7):\n        for r in range(3):\n            if board[c][r]==board[c-1][r+1]==board[c-2][r+2]==board[c-3][r+3]!='_':\n                w += transform(board[c][r])*100000\n    return w\n\ndef get_move_o(board):\n    copy = [row[:] for row in board]\n    pos_moves = {}\n    for a in range(1,8):\n        if copy[a-1][5] == '_':\n            move(a, 'O', copy)\n            if evaluate(copy) > 90000:\n                pos_moves[evaluate(copy)] = a\n            else:\n                listb = []\n                for b in range(1,8):\n                    if copy[b-1][5] == '_':\n                        move(b, 'X', copy)\n                        if evaluate(copy) > 90000:\n                            listb.append(evaluate(copy))\n                        else:\n                            listc = []\n                            for c in range(1,8):\n                                if board[c-1][5] == '_':\n                                    move(c, 'O', copy)\n                                    if evaluate(copy) > 90000:\n                                        listc.append(evaluate(copy))\n                                    else:\n                                        listd = []\n                                        for d in range(1,8):\n                                            if board[d-1][5] == '_':\n                                                move(d, 'X', copy)\n                                                listd.append(evaluate(copy))\n                                                move(d, '_', copy)\n                                        if listd != []:\n                                            listc.append(evaluate(copy))\n                                    move(c, '_', copy)\n                            if listc != []:\n                                listb.append(max(listc))\n                        move(b, '_', copy)\n                if listb != []:\n                    pos_moves[min(listb)] = a\n            move(a, '_', board)\n    if pos_moves == {}:\n        return None\n    else:\n        return pos_moves[max(pos_moves)]\n\n# main function\ndef main_solution(board_state):\n    board = [list(row) for row in board_state]\n    move_o = get_move_o(board)\n    if move_o is not None:\n        board = move(move_o, 'O', board)\n    evaluation = evaluate(board)\n    result = endtext(evaluation)\n    return {\"board_state\": [''.join(row) for row in board], \"result\": result}", "input_generator": "import random\n\ndef input_generator():\n    board = []\n    for _ in range(7):\n        row = []\n        for _ in range(6):\n            cell = random.choice(['_', 'X', 'O'])\n            row.append(cell)\n        board.append(''.join(row))\n    \n    return {\"board_state\": board}", "io_pairs": [{"input": {"board_state": ["XXO_XX", "_XOXXX", "XOXO_O", "OXOOOO", "X_O_XX", "_XO_X_", "_OXX__"]}, "output": {"board_state": ["XXO_XX", "_XOXXX", "XOXO_O", "OXOOOO", "X_O_XX", "OXO_X_", "_OXX__"], "result": "You won, well done!"}}, {"input": {"board_state": ["_XOXXX", "X_XO_O", "X___X_", "XXXO_O", "XOX_OO", "X__XX_", "OO__O_"]}, "output": {"board_state": ["_XOXXX", "X_XO_O", "XO__X_", "XXXO_O", "XOX_OO", "X__XX_", "OO__O_"], "result": "You won, well done!"}}, {"input": {"board_state": ["X___XO", "OOXXXX", "____XO", "XX_XOO", "OXX__X", "X_XXOO", "X_OOO_"]}, "output": {"board_state": ["X___XO", "OOXXXX", "____XO", "XX_XOO", "OXX__X", "X_XXOO", "XOOOO_"], "result": "You won, well done!"}}, {"input": {"board_state": ["_OXXXO", "XOX__O", "_OOOOX", "OXOXXX", "OXOXXX", "___X_X", "O__OOO"]}, "output": {"board_state": ["_OXXXO", "XOX__O", "_OOOOX", "OXOXXX", "OXOXXX", "___X_X", "O__OOO"], "result": "It's a draw."}}, {"input": {"board_state": ["OOX_O_", "OXOOO_", "_O_XXO", "XOXOXO", "___OX_", "_O__OX", "XO_X_X"]}, "output": {"board_state": ["OOXOO_", "OXOOO_", "_O_XXO", "XOXOXO", "___OX_", "_O__OX", "XO_X_X"], "result": "It's a draw."}}, {"input": {"board_state": ["_XOO_X", "XOOOOX", "OOXOOX", "OOXOO_", "XXXXXX", "XXXXXO", "OXO_O_"]}, "output": {"board_state": ["_XOO_X", "XOOOOX", "OOXOOX", "OOXOOO", "XXXXXX", "XXXXXO", "OXO_O_"], "result": "You won, well done!"}}, {"input": {"board_state": ["XO_OO_", "___OXO", "O_X_OX", "O_____", "_O_OX_", "OX_XO_", "O__OO_"]}, "output": {"board_state": ["XO_OO_", "___OXO", "O_X_OX", "O_____", "_O_OX_", "OX_XO_", "OO_OO_"], "result": "It's a draw."}}, {"input": {"board_state": ["_OXOOO", "_X___O", "O_O_OX", "OOXOXX", "OXXOOO", "X_XXOX", "__X_OO"]}, "output": {"board_state": ["_OXOOO", "_X___O", "O_O_OX", "OOXOXX", "OXXOOO", "X_XXOX", "__X_OO"], "result": "You won, well done!"}}, {"input": {"board_state": ["XOX_O_", "XXO_OO", "OOX_XX", "XO_X__", "XOXXXX", "XX_O__", "X__XOO"]}, "output": {"board_state": ["XOXOO_", "XXO_OO", "OOX_XX", "XO_X__", "XOXXXX", "XX_O__", "X__XOO"], "result": "You won, well done!"}}, {"input": {"board_state": ["X_X_XX", "_XXOOO", "XOO_XO", "_OOXOX", "_OO__X", "OXOOXO", "OX__OO"]}, "output": {"board_state": ["X_X_XX", "_XXOOO", "XOO_XO", "_OOXOX", "_OO__X", "OXOOXO", "OX__OO"], "result": "I won, yay!"}}], "error_log": []}
{"context": "Given a mathematical algorithm to approximate the value of Pi, how would the calculated value of Pi change after a certain number of iterations? Specifically, what is the value of Pi after `n` iterations using Bellard's Big Pi algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of iterations to perform in the Bellard's Big Pi calculation.\n\nOutput:\n  `return` (str): A string representation of the calculated value of Pi after `n` iterations.", "reference_code": "# import necessary packages\nfrom decimal import Decimal\n\n# all class and function definitions in the code file, if any\nclass Value:\n    def bellardBig(self, n):\n        pi = Decimal(0)\n        k = 0\n        while k < n:\n            pi += (Decimal(-1)**k/(1024**k))*( Decimal(256)/(10*k+1) + Decimal(1)/(10*k+9) - Decimal(64)/(10*k+3) - Decimal(32)/(4*k+1) - Decimal(4)/(10*k+5) - Decimal(4)/(10*k+7) -Decimal(1)/(4*k+3))\n            k += 1\n        pi = pi * 1/(2**6)\n        return pi\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    instan = Value()\n    pi_value = instan.bellardBig(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return str(pi_value)", "input_generator": "import random\nfrom decimal import Decimal\n\ndef input_generator():\n    n = random.randint(1, 10)\n    return {'n': n}", "io_pairs": [{"input": {"n": 3}, "output": "3.141592653642050769944283786"}, {"input": {"n": 9}, "output": "3.141592653589793238462643383"}, {"input": {"n": 4}, "output": "3.141592653589755368080512995"}, {"input": {"n": 1}, "output": "3.141765873015873015873015873"}, {"input": {"n": 7}, "output": "3.141592653589793238462663227"}, {"input": {"n": 10}, "output": "3.141592653589793238462643383"}, {"input": {"n": 6}, "output": "3.141592653589793238438850569"}, {"input": {"n": 8}, "output": "3.141592653589793238462643366"}, {"input": {"n": 2}, "output": "3.141592571868390306374052505"}, {"input": {"n": 5}, "output": "3.141592653589793267843375631"}], "error_log": []}
{"context": "Given a 2D grid of cells represented by a matrix, where each cell can either be empty (0) or occupied (1), how would you ensure that every row and column that contains at least one occupied cell is entirely filled with occupied cells? The matrix should be mutated in place without creating a new copy. What would be the resulting matrix after applying this transformation?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of integers): A 2D matrix where each element is either 0 or 1. The matrix represents a grid of cells.\n\nOutput:\n  `return` (list of lists of integers): A 2D matrix where every row and column that originally contained at least one 1 is now filled entirely with 1s. The matrix is mutated in place.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef ones_infection(arr):\n    rows = []\n    cols = []\n    \n    for x in range(len(arr)): \n        for y in range(len(arr[x])): \n            if arr[x][y]:\n                rows.append(x)\n                cols.append(y)\n    \n    for x in rows:\n        arr[x] = [1] * len(arr[x])\n    \n    for x in cols:\n        for y in range(len(arr)):\n            arr[y][x] = 1\n        \n    return arr\n\n# main function\ndef main_solution(matrix):\n    # Convert the input matrix to a list of lists if it's not already\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        raise ValueError(\"Input must be a list of lists representing a matrix\")\n    \n    # Call the ones_infection function to mutate the matrix\n    result_matrix = ones_infection(matrix)\n    \n    # Convert the result matrix to a JSON serializable format\n    return result_matrix", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(2, 10)\n    cols = random.randint(2, 10)\n    matrix = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n    # Randomly place some 1s in the matrix\n    num_ones = random.randint(1, rows * cols // 2)\n    for _ in range(num_ones):\n        x = random.randint(0, rows - 1)\n        y = random.randint(0, cols - 1)\n        matrix[x][y] = 1\n    \n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[1, 1, 1, 1], [1, 1, 1, 1]]}, "output": [[1, 1, 1, 1], [1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]]}, "output": [[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]}, "output": [[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]}, "output": [[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]]}, "output": [[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1], [1, 1], [1, 1], [1, 1], [1, 1]]}, "output": [[1, 1], [1, 1], [1, 1], [1, 1], [1, 1]]}, {"input": {"matrix": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]}, "output": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1], [1, 1, 1], [1, 1, 1]]}, "output": [[1, 1, 1], [1, 1, 1], [1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1, 1], [0, 0, 1, 1], [1, 1, 1, 1]]}, "output": [[1, 1, 1, 1], [0, 0, 1, 1], [1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]}, "output": [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]}], "error_log": []}
{"context": "Given a double pendulum system with two masses connected by rigid rods, what are the final positions of the pendulums after a certain period of time, given their initial angles and angular velocities?\n\nThe input and output requirements are as follows:\n\nInput:\n  `th1` (float): Initial angle of the first pendulum in degrees.\n  `th2` (float): Initial angle of the second pendulum in degrees.\n  `w1` (float): Initial angular velocity of the first pendulum in degrees per second.\n  `w2` (float): Initial angular velocity of the second pendulum in degrees per second.\n  `t_end` (float): End time for the simulation in seconds.\n  `dt` (float): Time step for the simulation in seconds.\n\nOutput:\n  `return` (dict): A dictionary containing the final positions of the pendulums.\n    - `x1_final` (float): Final x-coordinate of the first pendulum.\n    - `y1_final` (float): Final y-coordinate of the first pendulum.\n    - `x2_final` (float): Final x-coordinate of the second pendulum.\n    - `y2_final` (float): Final y-coordinate of the second pendulum.", "reference_code": "# import necessary packages\nimport numpy as np\nimport scipy.integrate as integrate\n\n# Constants\nG = 9.8  # acceleration due to gravity, in m/s^2\nL1 = 1.0  # length of pendulum 1 in m\nL2 = 1.0  # length of pendulum 2 in m\nM1 = 1.0  # mass of pendulum 1 in kg\nM2 = 1.0  # mass of pendulum 2 in kg\n\ndef derivs(state, t):\n    dydx = np.zeros_like(state)\n    dydx[0] = state[1]\n\n    delta = state[2] - state[0]\n    den1 = (M1 + M2) * L1 - M2 * L1 * np.cos(delta) * np.cos(delta)\n    dydx[1] = ((M2 * L1 * state[1] * state[1] * np.sin(delta) * np.cos(delta)\n                + M2 * G * np.sin(state[2]) * np.cos(delta)\n                + M2 * L2 * state[3] * state[3] * np.sin(delta)\n                - (M1 + M2) * G * np.sin(state[0]))\n               / den1)\n\n    dydx[2] = state[3]\n\n    den2 = (L2 / L1) * den1\n    dydx[3] = ((- M2 * L2 * state[3] * state[3] * np.sin(delta) * np.cos(delta)\n                + (M1 + M2) * G * np.sin(state[0]) * np.cos(delta)\n                - (M1 + M2) * L1 * state[1] * state[1] * np.sin(delta)\n                - (M1 + M2) * G * np.sin(state[2]))\n               / den2)\n\n    return dydx\n\n# main function\ndef main_solution(th1, th2, w1, w2, t_end, dt):\n    # Convert angles and angular velocities to radians\n    state = np.radians([th1, w1, th2, w2])\n    \n    # Create time array\n    t = np.arange(0, t_end, dt)\n    \n    # Integrate the ODE\n    y = integrate.odeint(derivs, state, t)\n    \n    # Extract the final positions of the pendulums\n    x1_final = L1 * np.sin(y[-1, 0])\n    y1_final = -L1 * np.cos(y[-1, 0])\n    x2_final = L2 * np.sin(y[-1, 2]) + x1_final\n    y2_final = -L2 * np.cos(y[-1, 2]) + y1_final\n    \n    # Return the final positions as a dictionary\n    return {\n        \"x1_final\": x1_final,\n        \"y1_final\": y1_final,\n        \"x2_final\": x2_final,\n        \"y2_final\": y2_final\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate random initial angles between -90 and 90 degrees\n    th1 = random.uniform(-90, 90)\n    th2 = random.uniform(-90, 90)\n    # Generate random initial angular velocities between -10 and 10 rad/s\n    w1 = random.uniform(-10, 10)\n    w2 = random.uniform(-10, 10)\n    # Generate random end time between 1 and 10 seconds\n    t_end = random.uniform(1, 10)\n    # Generate random time step between 0.01 and 0.1 seconds\n    dt = random.uniform(0.01, 0.1)\n    \n    return {\n        \"th1\": th1,\n        \"th2\": th2,\n        \"w1\": w1,\n        \"w2\": w2,\n        \"t_end\": t_end,\n        \"dt\": dt\n    }", "io_pairs": [{"input": {"th1": 52.23735417965656, "th2": -15.98434326479709, "w1": 0.07037187056217142, "w2": 5.756574821046739, "t_end": 5.723921371423828, "dt": 0.03846091840977276}, "output": {"x1_final": -0.00823361513500529, "y1_final": -0.9999661032164083, "x2_final": 0.3799387636002608, "y2_final": -1.9215528893559477}}, {"input": {"th1": 49.23663014949844, "th2": 29.651993466293078, "w1": 0.23209656066869755, "w2": 2.58912783950346, "t_end": 3.029343781310267, "dt": 0.08309449216262321}, "output": {"x1_final": 0.3131240778396865, "y1_final": -0.9497122258226678, "x2_final": 1.1573479918391667, "y2_final": -1.4857028815540883}}, {"input": {"th1": 48.00139598903567, "th2": 79.908332381458, "w1": -0.20156662107109824, "w2": 1.6086519701743747, "t_end": 2.5586593307932004, "dt": 0.040951136730492194}, "output": {"x1_final": 0.6766470857366729, "y1_final": -0.7363074910416623, "x2_final": 1.544248479261444, "y2_final": -1.2335678071275886}}, {"input": {"th1": -70.83018038414255, "th2": 57.630538904496404, "w1": -6.239916828643654, "w2": 8.075424623806878, "t_end": 4.8212235842647395, "dt": 0.029746213319817305}, "output": {"x1_final": 0.7232996518505627, "y1_final": -0.6905342957687581, "x2_final": -0.27215763929184866, "y2_final": -0.785743441922962}}, {"input": {"th1": -59.68751049486535, "th2": -21.69520776753025, "w1": -9.493302050772153, "w2": -1.496575980799804, "t_end": 4.305494220126228, "dt": 0.045884468169250084}, "output": {"x1_final": 0.7530222263530544, "y1_final": -0.6579950809985508, "x2_final": 1.3399118575415305, "y2_final": -1.467662025367317}}, {"input": {"th1": 81.7425427043897, "th2": -55.37392302291008, "w1": -9.241935277921725, "w2": 3.1675191943073138, "t_end": 7.475079783970463, "dt": 0.022024481249133122}, "output": {"x1_final": -0.1276598488148068, "y1_final": -0.9918180090120267, "x2_final": 0.8391077397439541, "y2_final": -1.2474748683220764}}, {"input": {"th1": -87.51399012883192, "th2": 60.14426580454216, "w1": 8.808411657062955, "w2": 8.915257416930547, "t_end": 7.715203568517301, "dt": 0.025705529391943413}, "output": {"x1_final": 0.6368657189457055, "y1_final": -0.7709747440946231, "x2_final": 1.4710785427385518, "y2_final": -1.322417365424862}}, {"input": {"th1": 20.97230524621672, "th2": 63.40310494456992, "w1": -1.0796057511916963, "w2": -9.885191970907128, "t_end": 6.601168531047019, "dt": 0.06121074813977278}, "output": {"x1_final": -0.43870491066281736, "y1_final": -0.8986311820543117, "x2_final": -1.1953592129075656, "y2_final": -1.5524463446916683}}, {"input": {"th1": 75.88745880235786, "th2": 51.977037436905505, "w1": -7.267291081652482, "w2": -7.592371099086446, "t_end": 6.948498978561275, "dt": 0.08809541580188254}, "output": {"x1_final": -0.8204109536155038, "y1_final": -0.571774314907289, "x2_final": -1.78900522520644, "y2_final": -0.8204209256648538}}, {"input": {"th1": -80.70328338231019, "th2": 3.563204159698145, "w1": 4.696430357903576, "w2": 1.325770082778721, "t_end": 4.34897762972558, "dt": 0.0930627350032114}, "output": {"x1_final": 0.8840933905309344, "y1_final": -0.46731025755863387, "x2_final": 1.2125394912654266, "y2_final": -1.411832972432293}}], "error_log": []}
{"context": "In a baseball game, a player tries to guess a 3-digit number. After each guess, the player is given feedback in the form of strikes and balls. A strike indicates that one of the guessed digits is correct and in the correct position, while a ball indicates that one of the guessed digits is correct but in the wrong position. Given a set of guesses and their corresponding strikes and balls, how many possible 3-digit numbers could be the correct answer?\n\nThe input and output requirements are as follows:\n\nInput:\n  `baseballs` (list of lists): A list of lists where each inner list contains three elements:\n    - The first element is a 3-digit number (int) representing the guess.\n    - The second element is an integer representing the number of strikes.\n    - The third element is an integer representing the number of balls.\n\nOutput:\n  `return` (int): The number of possible 3-digit numbers that could be the correct answer based on the given baseballs data.", "reference_code": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(baseballs):\n    # Convert the input list of tuples to a list of lists for JSON serialization\n    baseballs = [list(baseball) for baseball in baseballs]\n    \n    def strikes(answer, standard):\n        strike_point = 0\n        for i in range(3):\n            if answer[i] == str(standard[i]):\n                strike_point += 1\n        return strike_point\n\n    def balls(answer, standard):\n        ball_point = 0\n        for i in range(3):\n            for j in range(3):\n                if answer[i] == str(standard[j]) and i != j:\n                    ball_point += 1\n                    break\n        return ball_point\n\n    def is_possible(baseballs, permutaion):\n        for baseball in baseballs:\n            if baseball[1] == strikes(str(baseball[0]), permutaion) and \\\n                    baseball[2] == balls(str(baseball[0]), permutaion):\n                continue\n            else:\n                return 0\n        return 1\n\n    answer = 0\n    for permutaion in permutations([1, 2, 3, 4, 5, 6, 7, 8, 9], 3):\n        answer += is_possible(baseballs, permutaion)\n    \n    # Return the final output as an integer\n    return answer", "input_generator": "import random\nfrom itertools import permutations\n\ndef input_generator():\n    # Generate a random number of baseballs (1 to 5)\n    num_baseballs = random.randint(1, 5)\n    baseballs = []\n    \n    # Generate all possible permutations of 3 distinct digits from 1-9\n    all_possible = list(permutations(range(1, 10), 3))\n    \n    # Randomly select one permutation as the 'answer'\n    answer = random.choice(all_possible)\n    \n    for _ in range(num_baseballs):\n        # Randomly select a permutation for the baseball\n        baseball_num = random.choice(all_possible)\n        \n        # Calculate strikes and balls against the answer\n        strike = 0\n        ball = 0\n        for i in range(3):\n            if baseball_num[i] == answer[i]:\n                strike += 1\n            elif baseball_num[i] in answer:\n                ball += 1\n        \n        baseballs.append((baseball_num, strike, ball))\n    \n    return {'baseballs': baseballs}", "io_pairs": [{"input": {"baseballs": [[[2, 9, 8], 1, 1], [[5, 4, 8], 1, 0]]}, "output": 0}, {"input": {"baseballs": [[[7, 1, 8], 0, 0], [[9, 3, 6], 2, 0]]}, "output": 0}, {"input": {"baseballs": [[[2, 4, 6], 0, 1]]}, "output": 112}, {"input": {"baseballs": [[[6, 2, 9], 0, 1], [[1, 7, 8], 0, 1]]}, "output": 14}, {"input": {"baseballs": [[[4, 2, 3], 0, 1], [[8, 4, 1], 0, 0], [[2, 5, 7], 1, 1]]}, "output": 0}, {"input": {"baseballs": [[[9, 5, 1], 0, 1], [[9, 1, 2], 0, 1]]}, "output": 112}, {"input": {"baseballs": [[[1, 5, 3], 0, 0], [[4, 2, 6], 0, 1], [[4, 1, 5], 0, 0]]}, "output": 0}, {"input": {"baseballs": [[[5, 9, 4], 0, 0], [[2, 7, 3], 0, 1]]}, "output": 84}, {"input": {"baseballs": [[[9, 6, 2], 0, 2], [[8, 5, 2], 0, 0]]}, "output": 0}, {"input": {"baseballs": [[[3, 2, 9], 0, 1]]}, "output": 112}], "error_log": []}
{"context": "Imagine you have two blocks on a frictionless ramp. The first block slides down the ramp from a certain height and collides inelastically with the second block, which is initially at rest. How does the final speed of the combined blocks after the collision depend on the masses of the blocks and the height of the ramp? Specifically, what is the final speed of the blocks when the first block has a mass of `m_1`, the second block has a mass of `m_2`, and the ramp height is `h`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m_1` (float): Mass of the first block in kilograms.\n  `m_2` (float): Mass of the second block in kilograms.\n  `h` (float): Height of the ramp in meters.\n\nOutput:\n  `return` (dict): A dictionary containing the final speed of the blocks after the collision. The key is `\"final_speed\"` and the value is a float representing the final speed in meters per second.", "reference_code": "# import necessary packages\nfrom math import sqrt\n\n# all class and function definitions in the code file, if any\ndef solver(m_1, m_2, h):\n    # Calculate the speed of block m_1 at the bottom of the ramp using energy conservation\n    v_1 = sqrt(2 * 9.81 * h)\n    \n    # Calculate the final speed of the blocks after the inelastic collision using momentum conservation\n    v_f = (m_1 * v_1) / (m_1 + m_2)\n    \n    return v_f\n\n# main function\ndef main_solution(m_1, m_2, h):\n    # Convert JSON serializable inputs to the original input variables\n    m_1 = float(m_1)\n    m_2 = float(m_2)\n    h = float(h)\n    \n    # Call the solver function to get the final speed\n    final_speed = solver(m_1, m_2, h)\n    \n    # Convert the output to JSON serializable format\n    return {\"final_speed\": final_speed}", "input_generator": "import random\n\ndef input_generator():\n    m_1 = random.uniform(0.1, 10.0)\n    m_2 = random.uniform(0.1, 10.0)\n    h = random.uniform(0.1, 5.0)\n    return {\"m_1\": m_1, \"m_2\": m_2, \"h\": h}", "io_pairs": [{"input": {"m_1": 4.309035896059211, "m_2": 3.662799775050591, "h": 2.10539723115011}, "output": {"final_speed": 3.474067876755978}}, {"input": {"m_1": 6.076023706752046, "m_2": 6.758380433872941, "h": 1.945644779995271}, "output": {"final_speed": 2.9249943208834246}}, {"input": {"m_1": 7.217317469048883, "m_2": 5.88842307461768, "h": 2.3525321392928276}, "output": {"final_speed": 3.741377475829448}}, {"input": {"m_1": 5.340045633237882, "m_2": 9.331524103075935, "h": 2.6135170546255164}, "output": {"final_speed": 2.606336924502455}}, {"input": {"m_1": 0.11088218341490791, "m_2": 7.830747916714129, "h": 1.9895144440053538}, "output": {"final_speed": 0.08723186626933561}}, {"input": {"m_1": 4.139053747708395, "m_2": 7.063720476989181, "h": 1.4245298400980297}, "output": {"final_speed": 1.9532631620617507}}, {"input": {"m_1": 8.024715191121683, "m_2": 4.030302587515487, "h": 4.874543418752027}, "output": {"final_speed": 6.509958881613957}}, {"input": {"m_1": 3.679299055039359, "m_2": 7.366893160078797, "h": 4.3084407638922}, "output": {"final_speed": 3.062400996710866}}, {"input": {"m_1": 4.160956447337507, "m_2": 9.214438085475518, "h": 4.028566087561011}, "output": {"final_speed": 2.765739782323195}}, {"input": {"m_1": 5.0744783824413515, "m_2": 8.247939276438924, "h": 2.0772619362992812}, "output": {"final_speed": 2.4316636074689586}}], "error_log": []}
{"context": "Alice wants to send a secret message to Bob using the RSA encryption algorithm. She has chosen two prime numbers `p1` and `p2` to generate the public and private keys. What will be the encrypted message (`ciphertext`) and the decrypted message (`plaintext`) when Alice uses the RSA algorithm to encrypt her message?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p1` (int): A prime number used in the RSA key generation.\n  `p2` (int): Another prime number used in the RSA key generation.\n  `message` (str): The message to be encrypted using the RSA algorithm.\n\nOutput:\n  `return` (dict): A dictionary containing the encrypted message (`ciphertext`) and the decrypted message (`plaintext`). Both values are strings.", "reference_code": "# import necessary packages\nfrom sympy import isprime, gcd\nimport random\n\n# main function\ndef main_solution(p1, p2, message):\n    # Convert input variables if necessary\n    p1 = int(p1)\n    p2 = int(p2)\n    message = str(message)\n\n    # RSA_Keygen\n    def RSA_Keygen(p1, p2):\n        if not(isprime(p1) and isprime(p2)):\n            return -1, -1\n        n = p1 * p2\n        phin = (p1-1)*(p2-1)\n        f = 0\n        while f == 0:\n            m = random.randint(2, phin)\n            if gcd(phin, m) == 1:\n                f = e = m\n        i = 2\n        e1 = phin + 1\n        while e1 % e != 0:\n            e1 = (phin * i) + 1\n            i += 1\n        d = int(e1 / e)\n        publicKey = [e, n]\n        privateKey = [d, n]\n        return publicKey, privateKey\n\n    # RSA_Encryption\n    def RSA_Encryption(message, ku):\n        ciphertext = (message ** ku[0]) % ku[1]\n        return ciphertext\n\n    # RSA_Decryption\n    def RSA_Decryption(ciphertext, kr):\n        plaintext = (ciphertext ** kr[0]) % kr[1]\n        return plaintext\n\n    # Generate keys\n    ku, kr = RSA_Keygen(p1, p2)\n\n    # Encrypt message\n    ciphertext = ''.join(chr(RSA_Encryption(ord(e), ku)) for e in message)\n\n    # Decrypt message\n    plaintext = ''.join(chr(RSA_Decryption(ord(f), kr)) for f in ciphertext)\n\n    # Return results\n    return {\"ciphertext\": ciphertext, \"plaintext\": plaintext}", "input_generator": "import random\nfrom sympy import randprime\n\ndef input_generator():\n    # Generate two distinct small prime numbers\n    p1 = randprime(10, 100)\n    p2 = randprime(10, 100)\n    while p2 == p1:\n        p2 = randprime(10, 100)\n    \n    # Generate a random message of reasonable length (1-10 characters)\n    message_length = random.randint(1, 10)\n    message = ''.join(random.choice('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') for _ in range(message_length))\n    \n    return {\"p1\": p1, \"p2\": p2, \"message\": message}", "io_pairs": [{"input": {"p1": 97, "p2": 79, "message": "oA"}, "output": {"ciphertext": "\u1db4\u05ce", "plaintext": "oA"}}, {"input": {"p1": 47, "p2": 67, "message": "S8Z"}, "output": {"ciphertext": "\u0bea\u0589\u0609", "plaintext": "S8Z"}}, {"input": {"p1": 67, "p2": 83, "message": "x712mDUmla"}, "output": {"ciphertext": "\u0dfa\u0e94\u10c6\u0919\u142a\u12d9\u14ea\u142a\u06d9\u0b5f", "plaintext": "x712mDUmla"}}, {"input": {"p1": 59, "p2": 23, "message": "QM3zr"}, "output": {"ciphertext": "N\r\u052e\u04a8\u0369", "plaintext": "QM3zr"}}, {"input": {"p1": 97, "p2": 37, "message": "VqUoS"}, "output": {"ciphertext": "\u0ade\u0554\u0471\u0c49\u0ad4", "plaintext": "VqUoS"}}, {"input": {"p1": 97, "p2": 53, "message": "rI"}, "output": {"ciphertext": "\u10b3\u0fee", "plaintext": "rI"}}, {"input": {"p1": 37, "p2": 59, "message": "hoyIKq"}, "output": {"ciphertext": "\u0435\u050f\u043b\u00dd\u0535\u0344", "plaintext": "hoyIKq"}}, {"input": {"p1": 59, "p2": 19, "message": "O"}, "output": {"ciphertext": "\u007f", "plaintext": "O"}}, {"input": {"p1": 19, "p2": 83, "message": "U6u"}, "output": {"ciphertext": "\u029d\u0569\u049c", "plaintext": "U6u"}}, {"input": {"p1": 23, "p2": 61, "message": "xfMs"}, "output": {"ciphertext": "\u01c9\u0504\u024f\u023f", "plaintext": "xfMs"}}], "error_log": []}
{"context": "\u5c0f\u8d5b\u6700\u8fd1\u4e70\u4e86\u4e00\u652f\u80a1\u7968\uff0c\u4ed6\u77e5\u9053\u4ece\u4ed6\u4e70\u80a1\u7968\u7684\u90a3\u5929\u5f00\u59cb\uff0c\u80a1\u7968\u4f1a\u6709\u4ee5\u4e0b\u53d8\u5316\uff1a\u7b2c\u4e00\u5929\u4e0d\u53d8\uff0c\u4ee5\u540e\u6da8\u4e00\u5929\uff0c\u8dcc\u4e00\u5929\uff0c\u6da8\u4e24\u5929\uff0c\u8dcc\u4e00\u5929\uff0c\u6da8\u4e09\u5929\uff0c\u8dcc\u4e00\u5929...\u4f9d\u6b64\u7c7b\u63a8\u3002\u5047\u8bbe\u6bcf\u6b21\u6da8\u548c\u8dcc\u7686\u4e3a1\uff0c\u80a1\u7968\u521d\u59cb\u5355\u4ef7\u4e5f\u4e3a1\u3002\u8bf7\u95ee\uff0c\u4e70\u80a1\u7968\u7684\u7b2cn\u5929\u6bcf\u80a1\u80a1\u7968\u503c\u591a\u5c11\u94b1\uff1f\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The day number to calculate the stock price. It should be a positive integer greater than 0.\n\nOutput:\n  `return` (int): The stock price on the nth day. It will be a positive integer representing the value of the stock.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(n):\n    # n (int): The day number to calculate the stock price.\n    \n    # Initialize the stock price and other variables\n    price = 1\n    day = 0\n    up = 1\n    \n    # Loop to calculate the stock price on the nth day\n    for _ in range(1, n):\n        if day < up:\n            day += 1\n            price += 1\n        elif day == up:\n            up += 1\n            day = 0\n            price -= 1\n    \n    # Return the stock price on the nth day\n    return price", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 1000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 914}, "output": 832}, {"input": {"n": 292}, "output": 248}, {"input": {"n": 632}, "output": 564}, {"input": {"n": 772}, "output": 698}, {"input": {"n": 423}, "output": 369}, {"input": {"n": 563}, "output": 499}, {"input": {"n": 247}, "output": 207}, {"input": {"n": 343}, "output": 295}, {"input": {"n": 812}, "output": 736}, {"input": {"n": 533}, "output": 471}], "error_log": []}
{"context": "Given a string of digits, how many unique prime numbers can be formed by permuting the digits in the string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numbers` (str): A string of digits from which permutations will be generated. Each character in the string represents a digit.\n\nOutput:\n  `return` (int): The number of unique prime numbers that can be formed by permuting the digits in the input string.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef definePrime(num):\n    if num == 1 or num == 0:\n        return False\n\n    for i in range(2, num):\n        if num % i == 0:\n            return False\n    return True\n\ndef permu(level, numbers, visited, nums, permus):\n    if level == len(numbers):\n        permus.add(int(nums))\n        return\n\n    if nums != \"\":\n        permus.add(int(nums))\n\n    for i in range(len(numbers)):\n        if not visited[i]:\n            visited[i] = True\n            permu(level + 1, numbers, visited, nums + numbers[i], permus)\n            visited[i] = False\n\n# main function\ndef main_solution(numbers):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    permus = set()\n    visited = [False] * len(numbers)\n    permu(0, numbers, visited, \"\", permus)\n    \n    answer = 0\n    for prime in permus:\n        if definePrime(prime):\n            answer += 1\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return answer", "input_generator": "import random\n\ndef input_generator():\n    digits = random.randint(1, 5)\n    numbers = ''.join(random.sample('0123456789', digits))\n    return {'numbers': numbers}", "io_pairs": [{"input": {"numbers": "607"}, "output": 3}, {"input": {"numbers": "67"}, "output": 2}, {"input": {"numbers": "21"}, "output": 1}, {"input": {"numbers": "371"}, "output": 11}, {"input": {"numbers": "04"}, "output": 0}, {"input": {"numbers": "61740"}, "output": 22}, {"input": {"numbers": "314"}, "output": 6}, {"input": {"numbers": "398"}, "output": 6}, {"input": {"numbers": "09451"}, "output": 31}, {"input": {"numbers": "8"}, "output": 0}], "error_log": []}
{"context": "Given a grid of `m` rows and `n` columns, a robot starts at the top-left corner of the grid (coordinate [0,0]). The robot can move to adjacent cells (left, right, up, down) but cannot move outside the grid or to a cell where the sum of the digits of the row and column indices exceeds `k`. How many cells can the robot reach?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The number of rows in the grid.\n  `n` (int): The number of columns in the grid.\n  `k` (int): The maximum sum of the digits of the row and column indices that the robot can move to.\n\nOutput:\n  `return` (int): The number of cells the robot can reach.", "reference_code": "# import necessary packages\nfrom queue import Queue\n\n# all class and function definitions in the code file, if any\ndef digitsum(n):\n    ans = 0\n    while n:\n        ans += n % 10\n        n //= 10\n    return ans\n\n# main function\ndef main_solution(m, n, k):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # BFS implementation\n    q = Queue()\n    q.put((0, 0))\n    s = set()\n    while not q.empty():\n        x, y = q.get()\n        if (x, y) not in s and 0 <= x < m and 0 <= y < n and digitsum(x) + digitsum(y) <= k:\n            s.add((x, y))\n            for nx, ny in [(x + 1, y), (x, y + 1)]:\n                q.put((nx, ny))\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return len(s)", "input_generator": "import random\n\ndef input_generator():\n    m = random.randint(1, 100)\n    n = random.randint(1, 100)\n    k = random.randint(1, 50)\n    return {'m': m, 'n': n, 'k': k}", "io_pairs": [{"input": {"m": 54, "n": 17, "k": 40}, "output": 918}, {"input": {"m": 61, "n": 28, "k": 34}, "output": 1708}, {"input": {"m": 76, "n": 72, "k": 8}, "output": 45}, {"input": {"m": 88, "n": 24, "k": 46}, "output": 2112}, {"input": {"m": 90, "n": 66, "k": 21}, "output": 5145}, {"input": {"m": 6, "n": 58, "k": 33}, "output": 348}, {"input": {"m": 17, "n": 53, "k": 50}, "output": 901}, {"input": {"m": 57, "n": 57, "k": 17}, "output": 2615}, {"input": {"m": 64, "n": 31, "k": 21}, "output": 1950}, {"input": {"m": 90, "n": 52, "k": 4}, "output": 15}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = \\frac{\\sin(x)}{x} \\) for \\( x \\neq 0 \\) and \\( f(0) = 1 \\), how would you approximate the integral of this function over a specified interval using three different numerical integration methods: the composite trapezoidal formula, the compound Simpson's formula, and the half-trapezoidal method? What are the results of these approximations for a given interval and parameters?\n\nThe input and output requirements are as follows:\n\nInput:\n  `lower_limit` (float): The lower limit of the integration interval.\n  `upper_limit` (float): The upper limit of the integration interval.\n  `divide` (int): The number of divisions for the composite trapezoidal and Simpson's rule.\n  `deviation` (float): The acceptable deviation for the half-trapezoidal method.\n\nOutput:\n  `return` (dict): A dictionary containing the results of the integration methods.\n    - `trapezoidal_result` (float): The result of the composite trapezoidal formula.\n    - `simpson_result` (float): The result of the compound Simpson's formula.\n    - `half_trapezoidal_result` (float): The result of the half-trapezoidal method.", "reference_code": "# import necessary packages\nfrom math import sin\n\n# all class and function definitions in the code file, if any\ndef f(x):\n    if x == 0:\n        return 1\n    return sin(x) / x\n\ndef composite_trapezoidal_formula(function, lower_limit, upper_limit, divide):\n    tmp = 0\n    step = (upper_limit - lower_limit) / divide\n    for i in range(divide):\n        tmp = tmp + function(lower_limit + i * step) + function(lower_limit + (i + 1) * step)\n    return step / 2 * tmp\n\ndef compound_Simpson_formula(function, lower_limit, upper_limit, divide):\n    tmp = 0\n    step = (upper_limit - lower_limit) / divide\n    for i in range(divide):\n        tmp = tmp + function(lower_limit + i * step) + function(lower_limit + (i + 1) * step) + 4 * function(((lower_limit + i * step) + (lower_limit + (i + 1) * step)) / 2)\n    return step / 6 * tmp\n\ndef half_trapezoidal(function, lower_limit, upper_limit, deviation):\n    T_n = 1 / 2 * (function(lower_limit) + function(upper_limit))\n    length = (upper_limit - lower_limit)\n    divide = 1\n    step = length / divide\n    k = 0\n    while True:\n        tmp = 0\n        for i in range(divide):\n            tmp = tmp + function(((lower_limit + i * step) + (lower_limit + (i + 1) * step)) / 2)\n        T_2n = 1 / 2 * T_n + step / 2 * tmp\n        if abs(T_2n - T_n) < deviation:\n            return T_2n\n        T_n = T_2n\n        k = k + 1\n        divide = 2 ** k\n        step = length / divide\n\n# main function\ndef main_solution(lower_limit, upper_limit, divide, deviation):\n    # Convert JSON serializable inputs to original input variables\n    lower_limit = float(lower_limit)\n    upper_limit = float(upper_limit)\n    divide = int(divide)\n    deviation = float(deviation)\n    \n    # Calculate results using the original functions\n    trapezoidal_result = composite_trapezoidal_formula(f, lower_limit, upper_limit, divide)\n    simpson_result = compound_Simpson_formula(f, lower_limit, upper_limit, divide)\n    half_trapezoidal_result = half_trapezoidal(f, lower_limit, upper_limit, deviation)\n    \n    # Convert results to JSON serializable outputs\n    return {\n        \"trapezoidal_result\": trapezoidal_result,\n        \"simpson_result\": simpson_result,\n        \"half_trapezoidal_result\": half_trapezoidal_result\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random lower and upper limits, ensuring lower < upper\n    lower_limit = random.uniform(-10.0, 10.0)\n    upper_limit = random.uniform(lower_limit + 0.1, lower_limit + 20.0)\n    \n    # Generate a random divide value, ensuring it's a positive integer\n    divide = random.randint(1, 100)\n    \n    # Generate a small positive deviation\n    deviation = random.uniform(1e-6, 1e-3)\n    \n    return {\n        \"lower_limit\": lower_limit,\n        \"upper_limit\": upper_limit,\n        \"divide\": divide,\n        \"deviation\": deviation\n    }", "io_pairs": [{"input": {"lower_limit": -2.270915341066779, "upper_limit": 13.754785385146162, "divide": 92, "deviation": 0.0006024324342853953}, "output": {"trapezoidal_result": 3.25073663228838, "simpson_result": 3.2517731716283818, "half_trapezoidal_result": 3.2514022669343374}}, {"input": {"lower_limit": 6.9634191053563015, "upper_limit": 17.322569079431453, "divide": 23, "deviation": 0.00023903349908435638}, "output": {"trapezoidal_result": 0.11875187336853422, "simpson_result": 0.12032434013346859, "half_trapezoidal_result": 0.12017364073475037}}, {"input": {"lower_limit": 5.718907911440127, "upper_limit": 17.129289958319646, "divide": 35, "deviation": 0.0007818098675849988}, "output": {"trapezoidal_result": 0.13683494514398778, "simpson_result": 0.13833878832105326, "half_trapezoidal_result": 0.13910518809879477}}, {"input": {"lower_limit": -7.112999743807418, "upper_limit": 2.3280987120410312, "divide": 37, "deviation": 0.0009579475976803222}, "output": {"trapezoidal_result": 3.1950288959620323, "simpson_result": 3.1969229157377095, "half_trapezoidal_result": 3.1960650087310682}}, {"input": {"lower_limit": 0.8154437524555931, "upper_limit": 18.644941769654075, "divide": 53, "deviation": 0.0004264385936156238}, "output": {"trapezoidal_result": 0.736135927543711, "simpson_result": 0.7332336631562817, "half_trapezoidal_result": 0.7330081086398876}}, {"input": {"lower_limit": -2.79957039855889, "upper_limit": 2.166222898728559, "divide": 11, "deviation": 0.0007008758350065709}, "output": {"trapezoidal_result": 3.4931504111990197, "simpson_result": 3.507014784562685, "half_trapezoidal_result": 3.506522472514978}}, {"input": {"lower_limit": -2.118981361374712, "upper_limit": 17.681192678537794, "divide": 47, "deviation": 0.000811217437777185}, "output": {"trapezoidal_result": 3.202007871660296, "simpson_result": 3.2080964631573106, "half_trapezoidal_result": 3.207288517105132}}, {"input": {"lower_limit": -4.331107583636136, "upper_limit": 2.077389457365258, "divide": 74, "deviation": 0.0005175399421992506}, "output": {"trapezoidal_result": 3.3296697009395793, "simpson_result": 3.329965092311836, "half_trapezoidal_result": 3.3296918930547728}}, {"input": {"lower_limit": 3.9384993345567487, "upper_limit": 14.890035336281661, "divide": 94, "deviation": 0.0008220702793861057}, "output": {"trapezoidal_result": -0.15640513630993938, "simpson_result": -0.15649802860166212, "half_trapezoidal_result": -0.15585300750004139}}, {"input": {"lower_limit": 0.34337652574017064, "upper_limit": 11.39268645031173, "divide": 91, "deviation": 0.0004741243065668985}, "output": {"trapezoidal_result": 1.2032017043240328, "simpson_result": 1.2030122499312101, "half_trapezoidal_result": 1.2027363998202785}}], "error_log": []}
{"context": "Given a graph with a certain number of vertices and edges, determine if an Eulerian Circuit exists. If it does, provide the sequence of vertices that form the Eulerian Circuit. What is the Eulerian Circuit for the given graph?\n\nThe input and output requirements are as follows:\n\nInput:\n  `vertices` (int): The number of vertices in the graph.\n  `edges` (list of lists): A list of edges where each edge is represented as a list of two integers, representing the vertices connected by the edge.\n\nOutput:\n  `return` (str): A JSON serialized string representing the Eulerian Circuit if it exists, otherwise an empty list.", "reference_code": "# import necessary packages\nfrom collections import defaultdict\nimport json\n\n# all class and function definitions in the code file, if any\nclass Graph:\n\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        \n    def remEdge(self, u, v):\n        for i in self.graph:\n            if i == u:\n                self.graph[i].remove(v)\n        for i in self.graph:\n            if i == v:\n                self.graph[i].remove(u)\n\n    def DFS(self, v, visited):\n        visited[v] = True\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFS(i, visited)\n\n    def isConnected(self):\n        visited = defaultdict(bool)\n        for i in self.graph:\n            visited[i] = False\n        counter = 0\n        for i in self.graph:\n            counter += 1\n            if len(self.graph[i]) > 1:\n                break\n        if counter == self.V - 1:\n            return True\n        self.DFS(i, visited)\n        for i in self.graph:\n            if visited[i] == False and len(self.graph[i]) > 0:\n                return False\n        return True\n\n    def isEulerianCircuitExists(self):\n        if self.isConnected() == False:\n            return False\n        else:\n            odd = 0\n            for i in self.graph:\n                if len(self.graph[i]) % 2 != 0:\n                    odd += 1\n            if odd == 0:\n                return True\n            else: return False\n            \n    def EulerianCircuitfromHeirholzer(self):\n        stack = []\n        circuit = []\n        start_vertex = list(self.graph.keys())[0]\n        stack.append(start_vertex)\n        while stack:\n            v = stack[-1]\n            if len(self.graph[v])==0:\n                circuit.append(stack.pop())\n            else:\n                next_vertex = self.graph[v][0]\n                self.remEdge(v,next_vertex)\n                stack.append(next_vertex)\n        return circuit\n\n# main function\ndef main_solution(vertices, edges):\n    # Convert JSON serializable inputs to original input variables\n    graph = Graph(vertices)\n    for edge in edges:\n        graph.addEdge(edge[0], edge[1])\n    \n    # Check if Eulerian Circuit exists\n    if graph.isEulerianCircuitExists():\n        circuit = graph.EulerianCircuitfromHeirholzer()\n        # Convert the output to JSON serializable format\n        return json.dumps(circuit)\n    else:\n        return json.dumps([])", "input_generator": "import random\nimport json\n\ndef input_generator():\n    vertices = random.randint(3, 10)\n    edges = []\n    max_edges = min(vertices * (vertices - 1) // 2, 15)  # Limit edges to avoid too dense graphs\n    \n    # Ensure the graph is connected and has even degree for all vertices (Eulerian circuit exists)\n    # First, create a cycle to ensure connectivity\n    for i in range(vertices):\n        edges.append((i, (i + 1) % vertices))\n    \n    # Add some random edges to ensure all vertices have even degree\n    remaining_edges = max_edges - vertices\n    possible_edges = []\n    for u in range(vertices):\n        for v in range(u + 1, vertices):\n            if (u, v) not in edges and (v, u) not in edges:\n                possible_edges.append((u, v))\n    \n    # Randomly select edges to add, ensuring degrees remain even\n    random.shuffle(possible_edges)\n    added = 0\n    for edge in possible_edges:\n        if added >= remaining_edges:\n            break\n        edges.append(edge)\n        added += 1\n    \n    return {'vertices': vertices, 'edges': edges}", "io_pairs": [{"input": {"vertices": 4, "edges": [[0, 1], [1, 2], [2, 3], [3, 0], [0, 2], [1, 3]]}, "output": "[]"}, {"input": {"vertices": 3, "edges": [[0, 1], [1, 2], [2, 0]]}, "output": "[0, 2, 1, 0]"}, {"input": {"vertices": 4, "edges": [[0, 1], [1, 2], [2, 3], [3, 0], [1, 3], [0, 2]]}, "output": "[]"}], "error_log": []}
{"context": "Given a set of known data points, how can we approximate the value of a function f(x) at a specific point x using Lagrange interpolation? Specifically, what is the interpolated value of f(x) at the desired x-value based on the provided x and f(x) values?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_data_points` (int): The number of known data points.\n  `x_values` (list of float): A list of x-values corresponding to the known data points.\n  `fx_values` (list of float): A list of f(x) values corresponding to the known data points.\n  `x_desired` (float): The x-value for which the function f(x) needs to be calculated.\n\nOutput:\n  `return` (float): The interpolated value of f(x) at the desired x-value.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(num_data_points, x_values, fx_values, x_desired):\n    # Convert JSON serializable inputs to numpy array\n    matriz = np.zeros((2, num_data_points))\n    for i in range(num_data_points):\n        matriz[0, i] = x_values[i]\n        matriz[1, i] = fx_values[i]\n    \n    # Lagrange interpolation function\n    def lagrange(x):\n        L0 = ((np.poly1d([1, 0]) - float(matriz[0, 1])) / (float(matriz[0, 0]) - float(matriz[0, 1])))\n        L1 = ((np.poly1d([1, 0]) - float(matriz[0, 0])) / (float(matriz[0, 1]) - float(matriz[0, 0])))\n        px = (float(matriz[1, 0]) * L0) + (float(matriz[1, 1]) * L1)\n        return px\n    \n    # Calculate the solution\n    sol = lagrange(x_desired)\n    result = sol(x_desired)\n    \n    # Return the result as a JSON serializable output\n    return float(result)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    num_data_points = 2\n    x_values = sorted([round(random.uniform(-10, 10), 2) for _ in range(num_data_points)])\n    fx_values = [round(random.uniform(-10, 10), 2) for _ in range(num_data_points)]\n    x_desired = round(random.uniform(min(x_values), max(x_values)), 2)\n    \n    return {\n        'num_data_points': num_data_points,\n        'x_values': x_values,\n        'fx_values': fx_values,\n        'x_desired': x_desired\n    }", "io_pairs": [{"input": {"num_data_points": 2, "x_values": [-7.75, 0.4], "fx_values": [-1.64, -5.58], "x_desired": -0.12}, "output": -5.328613496932515}, {"input": {"num_data_points": 2, "x_values": [-6.97, -0.25], "fx_values": [1.79, -5.21], "x_desired": -2.94}, "output": -2.407916666666666}, {"input": {"num_data_points": 2, "x_values": [-9.38, 7.95], "fx_values": [9.91, -1.32], "x_desired": 3.76}, "output": 1.3951586843623769}, {"input": {"num_data_points": 2, "x_values": [0.91, 8.55], "fx_values": [6.52, -8.57], "x_desired": 7.76}, "output": -7.009646596858637}, {"input": {"num_data_points": 2, "x_values": [-6.57, 2.4], "fx_values": [2.36, 2.27], "x_desired": -1.59}, "output": 2.3100334448160535}, {"input": {"num_data_points": 2, "x_values": [-8.51, 3.72], "fx_values": [-6.36, -9.62], "x_desired": -2.84}, "output": -7.871381847914963}, {"input": {"num_data_points": 2, "x_values": [1.45, 5.76], "fx_values": [3.76, 6.87], "x_desired": 3.04}, "output": 4.907308584686776}, {"input": {"num_data_points": 2, "x_values": [-2.09, 5.1], "fx_values": [8.49, 5.19], "x_desired": 3.65}, "output": 5.855507649513213}, {"input": {"num_data_points": 2, "x_values": [4.12, 8.54], "fx_values": [-5.17, -0.19], "x_desired": 6.46}, "output": -2.5335294117647065}, {"input": {"num_data_points": 2, "x_values": [-7.71, -1.69], "fx_values": [4.65, 8.66], "x_desired": -2.21}, "output": 8.313621262458472}], "error_log": []}
{"context": "Given a stochastic differential equation (SDE) with coefficients `a` and `b`, and a time interval up to `y`, what are the strong and weak convergence errors when solving the SDE using the Euler-Maruyama method with `nsteps` discretization steps?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The coefficient for the deterministic part of the SDE.\n  `b` (float): The coefficient for the stochastic part of the SDE.\n  `y` (int): The time up to which the solution is computed.\n  `nsteps` (int): The number of steps in the discretization of the time interval.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `error_strong` (float): The average absolute difference between the numerical and analytic solutions (strong convergence error).\n    - `error_weak` (float): The absolute difference between the average values of the numerical and analytic solutions (weak convergence error).", "reference_code": "# import necessary packages\nimport numpy as np\nfrom math import exp, log, sqrt\n\n# function implementing Euler-Maruyama method\n# probe_fnctn is the the expression for dy/dx\ndef euler_maruyama_method(a, b, rwalk, h):\n    output_list = list()\n    \n    # setting initial values for X(t) and t\n    y = 1.0\n    t = 0\n    w_prev = 0\n    \n    for W_n in rwalk:\n        output_list.append(y)\n        y += a*h + b*(W_n - w_prev)\n        w_prev = W_n\n        t += h\n    output_list.append(y)\n    return output_list\n\n# main function\ndef main_solution(a, b, y, nsteps):\n    # all input arguments of the main_solution function should be json serializable\n    h = 1.0 / (float(nsteps))\n    \n    # creation of 'x' axis (with re-scaling)\n    t = np.arange(1, nsteps * y + 1, int(nsteps / nsteps))\n    steps = np.random.randint(0, 2, size=nsteps * y)\n    steps = np.where(steps > 0, 1, -1)\n    steps = steps * (1 / sqrt(nsteps))\n    rwalk = steps.cumsum()\n\n    buff_list1 = euler_maruyama_method(a, b, rwalk, h)\n    \n    # adjusting output to analytic solution X(t)\n    buff_list2 = [1]\n    for indx, z in enumerate(rwalk):\n        buff_list2.append(exp(t[indx] / nsteps + z))\n    \n    # STRONG convergence\n    error_strong = sum(abs(elem1 - elem2) for elem1, elem2 in zip(buff_list1, buff_list2)) / len(buff_list1)\n    \n    # WEAK convergence\n    error_weak_1 = sum(buff_list1) / len(buff_list1)\n    error_weak_2 = sum(buff_list2) / len(buff_list2)\n    error_weak = abs(error_weak_1 - error_weak_2)\n    \n    # return, the returned value must be json serializable\n    return {\n        \"error_strong\": error_strong,\n        \"error_weak\": error_weak\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    a = random.uniform(0.1, 2.0)\n    b = random.uniform(0.1, 2.0)\n    y = random.randint(1, 10)\n    nsteps = random.randint(100, 1000)\n    return {\n        \"a\": a,\n        \"b\": b,\n        \"y\": y,\n        \"nsteps\": nsteps\n    }", "io_pairs": [{"input": {"a": 0.6230158356724722, "b": 0.9096547581703438, "y": 9, "nsteps": 703}, "output": {"error_strong": 41.40742783018995, "error_weak": 41.40742573267821}}, {"input": {"a": 1.9794561149053025, "b": 1.74454210155597, "y": 7, "nsteps": 855}, "output": {"error_strong": 498.8184743009776, "error_weak": 498.81415726754113}}, {"input": {"a": 0.9112574947547921, "b": 1.842488386210186, "y": 4, "nsteps": 819}, "output": {"error_strong": 26.91464122206988, "error_weak": 26.90195682354812}}, {"input": {"a": 1.9572085625880629, "b": 0.634245929672705, "y": 3, "nsteps": 632}, "output": {"error_strong": 2.6091972794333165, "error_weak": 1.2187457380091158}}, {"input": {"a": 0.5316529680717602, "b": 1.4893806085188712, "y": 4, "nsteps": 582}, "output": {"error_strong": 8.245262721540222, "error_weak": 8.245262721540207}}, {"input": {"a": 0.9509408357969423, "b": 1.5842508611041894, "y": 9, "nsteps": 307}, "output": {"error_strong": 46.374656520370415, "error_weak": 46.374389857536976}}, {"input": {"a": 1.6239429519809445, "b": 1.0543306241774162, "y": 6, "nsteps": 218}, "output": {"error_strong": 1.2310167454413459, "error_weak": 1.191520134260851}}, {"input": {"a": 0.8779325450229136, "b": 0.6527872630225915, "y": 3, "nsteps": 452}, "output": {"error_strong": 26.943478285284954, "error_weak": 26.940351501687697}}, {"input": {"a": 1.4271093795416059, "b": 1.8074487252307683, "y": 3, "nsteps": 394}, "output": {"error_strong": 1.6308199735004418, "error_weak": 1.623371078553989}}, {"input": {"a": 1.8415929727237563, "b": 0.6703810216027086, "y": 8, "nsteps": 793}, "output": {"error_strong": 25.781095382469708, "error_weak": 25.326703786736587}}], "error_log": []}
{"context": "Given a set of vectors in 3-dimensional space, we need to determine the effect of rotating one of the vectors after orthogonalizing the set using the Gram-Schmidt process. Specifically, what is the resulting vector when the first vector in the orthogonal basis is rotated by a given angle?\n\nThe input and output requirements are as follows:\n\nInput:\n- `vectors` (list of lists of floats): A list of vectors, where each vector is represented as a list of its components.\n- `angle` (float): The angle in radians by which to rotate the first vector in the orthogonal basis.\n\nOutput:\n- `return` (list of lists of floats): A list containing the rotated vector as a list of its components.", "reference_code": "# import necessary packages\nfrom math import sqrt, sin, cos\nimport random\n\n# all class and function definitions in the code file, if any\nclass Vector:\n    def __init__(self, *comps):\n        self.components = tuple(comps)\n    \n    def __len__(self):\n        return len(self.components)\n    \n    def __eq__(self, other):\n        selfDim = len(self.components)\n        if selfDim != len(other.components):\n            return False\n        \n        for i in range(selfDim):\n            if self.components[i] != other.components[i]:\n                return False\n        return True\n    \n    def __neq__(self, other):\n        return not self.__eq__(other)\n    \n    def iszero(self, zeroVal=0):\n        return all(c == zeroVal for c in self.components)\n    \n    def __abs__(self):\n        total = None\n        for c in self.components:\n            if total is None:\n                total = c * c\n            else:\n                total += c * c\n        \n        if total is None:\n            return 0\n        else:\n            return sqrt(total)\n    \n    def __getitem__(self, key):\n        return self.components[key]\n    \n    def __add__(self, other):\n        if not isinstance(other, Vector):\n            raise TypeError(\"Vectors can only be added to other Vectors\")\n        \n        selfDim, otherDim = len(self), len(other)\n        if selfDim != otherDim:\n            raise ValueError(f\"Vector dimensions do not match: {selfDim} and {otherDim}\")\n        \n        return Vector(*(self.components[i] + other.components[i] for i in range(selfDim)))\n    \n    def __sub__(self, other):\n        if not isinstance(other, Vector):\n            raise TypeError(\"Vectors can only be added to other Vectors\")\n        \n        selfDim, otherDim = len(self), len(other)\n        if selfDim != otherDim:\n            raise ValueError(f\"Vector dimensions do not match: {selfDim} and {otherDim}\")\n        \n        return Vector(*(self.components[i] - other.components[i] for i in range(selfDim)))\n    \n    def __mul__(self, other):\n        selfDim = len(self)\n        if isinstance(other, Vector):\n            otherDim = len(other)\n            if selfDim != otherDim:\n                raise ValueError(f\"Vector dimensions do not match: {selfDim} and {otherDim}\")\n            \n            dot = None\n            for i in range(selfDim):\n                prod = self.components[i] * other.components[i]\n                \n                if dot is None:\n                    dot = prod\n                else:\n                    dot += prod\n            return dot\n        else:\n            return Vector(*(other * self.components[i] for i in range(selfDim)))\n    \n    def __rmul__(self, other):\n        return self.__mul__(other)\n    \n    def __div__(self, other):\n        return self.__truediv__(other)\n    \n    def __truediv__(self, other):\n        selfDim = len(self)\n        return Vector(*(self.components[i] / other for i in range(selfDim)))\n    \n    def __floordiv__(self, other):\n        selfDim = len(self)\n        return Vector(*(self.components[i] // other for i in range(selfDim)))\n    \n    def __repr__(self):\n        return 'Vector(' + ', '.join(map(str, self.components)) + ')'\n    \n    def rotate(self, rotand, angle):\n        \"\"\"\n        Rotate the `rotand` about the rotator defined by `self`\n        by an angle of `angle` counterclockwise.\n        Note: Uses Rodriguez Rotation Formula\n        \n        Args:\n            rotand (Vector) -- Vector to rotate around self\n            angle (float) -- angle by which to rotate in radians\n        \n        Returns:\n            Vector -- rotated vector\n        \"\"\"\n        \n        c, s = cos(angle), sin(angle)\n        selfMag = abs(self)\n        \n        total = rotand * c\n        total += cross(self, rotand) * (s / selfMag)\n        total += self * (self * rotand) * ((1 - c) / (selfMag * selfMag))\n        return total\n\ndef gramschmidt(*vectors):\n    basis, first = [], True\n    for v in vectors:\n        if first:\n            basis.append(v)\n        else:\n            for b in basis:\n                v -= (v * b) / (b * b) * b\n            \n            if not v.iszero():\n                basis.append(v)\n    \n    return basis\n\ndef zero(dims=3, zeroVal=0):\n    return Vector(*(zeroVal for i in range(dims)))\n\ndef cross(vec1, vec2):\n    if not isinstance(vec1, Vector) or not isinstance(vec2, Vector):\n        raise TypeError(\"Cross Product only defined between Vectors\")\n    \n    dim1, dim2 = len(vec1), len(vec2)\n    if dim1 != dim2:\n        raise ValueError(f\"Vector dimensions do not match: {dim1} and {dim2}\")\n    \n    if dim1 == 2:\n        return vec1.components[0] * vec2.components[1] - vec1.components[1] * vec2.components[0]\n    elif dim1 == 3:\n        x = vec1.components[1] * vec2.components[2] - vec1.components[2] * vec2.components[1]\n        y = vec1.components[2] * vec2.components[0] - vec1.components[0] * vec2.components[2]\n        z = vec1.components[0] * vec2.components[1] - vec1.components[1] * vec2.components[0]\n        return Vector(x, y, z)\n    else:\n        raise ValueError(f\"Cross Product not defined on Vectors of dimension {dim1}\")\n\n# main function\ndef main_solution(vectors, angle):\n    # Convert JSON serializable inputs to original input variables\n    vectors = [Vector(*v) for v in vectors]\n    \n    # Apply Gram-Schmidt process to orthogonalize the vectors\n    orthogonal_basis = gramschmidt(*vectors)\n    \n    # Rotate the first vector in the orthogonal basis by the given angle\n    rotated_vector = orthogonal_basis[0].rotate(orthogonal_basis[0], angle)\n    \n    # Convert the result to JSON serializable output\n    return [list(rotated_vector.components)]", "input_generator": "import random\nimport math\nfrom math import pi\n\ndef input_generator():\n    # Randomly choose the number of vectors (between 2 and 4)\n    num_vectors = random.randint(2, 4)\n    # Randomly choose the dimension of vectors (2 or 3)\n    dim = random.choice([2, 3])\n    \n    vectors = []\n    for _ in range(num_vectors):\n        # Generate random components for each vector\n        components = [round(random.uniform(-10, 10), 2) for _ in range(dim)]\n        vectors.append(components)\n    \n    # Generate a random angle between 0 and 2*pi\n    angle = round(random.uniform(0, 2 * pi), 2)\n    \n    return {\n        'vectors': vectors,\n        'angle': angle\n    }", "io_pairs": [{"input": {"vectors": [[1.31, -0.79, -7.3], [4.22, -7.1, -4.52]], "angle": 2.43}, "output": [[1.31, -0.7900000000000001, -7.3]]}, {"input": {"vectors": [[-1.95, 5.68, 4.3], [-6.21, 3.34, 4.24]], "angle": 6.23}, "output": [[-1.95, 5.68, 4.3]]}, {"input": {"vectors": [[7.28, -2.09, -4.22], [-8.09, 3.03, -8.9]], "angle": 4.53}, "output": [[7.28, -2.09, -4.22]]}, {"input": {"vectors": [[-5.76, -7.31, 4.86], [2.5, -9.32, -9.67]], "angle": 4.14}, "output": [[-5.759999999999998, -7.309999999999998, 4.859999999999998]]}, {"input": {"vectors": [[8.08, -0.41, -9.2], [-1.57, -1.6, 2.46]], "angle": 1.44}, "output": [[8.08, -0.41, -9.2]]}, {"input": {"vectors": [[9.7, -2.39, -0.44], [4.51, 2.82, -6.3], [-4.6, -6.05, 2.07]], "angle": 2.31}, "output": [[9.700000000000005, -2.3900000000000006, -0.44000000000000017]]}, {"input": {"vectors": [[-4.37, 8.69, 5.53], [-8.28, 0.56, -7.25], [-3.37, 6.98, 2.18]], "angle": 2.48}, "output": [[-4.369999999999999, 8.689999999999998, 5.53]]}, {"input": {"vectors": [[-0.35, 5.96, -3.46], [-4.08, -5.49, -4.09]], "angle": 2.78}, "output": [[-0.35, 5.960000000000002, -3.460000000000001]]}, {"input": {"vectors": [[-1.86, -0.8, -0.34], [9.32, 7.35, 3.41]], "angle": 2.03}, "output": [[-1.8599999999999994, -0.7999999999999998, -0.33999999999999997]]}, {"input": {"vectors": [[1.63, -8.01, 9.27], [1.29, -2.34, 4.38]], "angle": 0.38}, "output": [[1.63, -8.01, 9.27]]}], "error_log": []}
