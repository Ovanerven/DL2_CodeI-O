{"context": "Given a position in the Fibonacci sequence and a modulo value, what is the result of the Fibonacci number at that position modulo the given value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The position in the Fibonacci sequence.\n  `m` (int): The modulo value.\n\nOutput:\n  `return` (int): The result of the Fibonacci number at position `n` modulo `m`.", "reference_code": "# import necessary packages\nimport sys\n\n# main function\ndef main_solution(n, m):\n    # Convert JSON serializable inputs to the required format\n    n = int(n)\n    m = int(m)\n\n    # Function to calculate the huge Fibonacci number modulo m\n    def get_fibonacci_huge(n, m):\n        if n == 0:\n            return 0\n\n        fib = {0: 0, 1: 1}\n        mod = {0: 0, 1: 1}\n\n        i = 2\n\n        while True:\n            fib.setdefault(i, mod.get(i - 1) + mod.get(i - 2))\n            mod.setdefault(i, fib.get(i) % m)\n            if mod[i - 1] == 0 and mod[i] == 1:\n                break\n            i += 1\n\n        remainder = n % (i - 1)\n        return fib.get(remainder) % m\n\n    # Get the result\n    result = get_fibonacci_huge(n, m)\n\n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(0, 10**6)\n    m = random.randint(2, 10**5)\n    return {'n': n, 'm': m}", "io_pairs": [{"input": {"n": 340285, "m": 31490}, "output": 4655}, {"input": {"n": 390036, "m": 42507}, "output": 20637}, {"input": {"n": 139445, "m": 33630}, "output": 22535}, {"input": {"n": 689468, "m": 59713}, "output": 19198}, {"input": {"n": 609839, "m": 8596}, "output": 1}, {"input": {"n": 912697, "m": 87976}, "output": 34985}, {"input": {"n": 94681, "m": 65449}, "output": 37911}, {"input": {"n": 126165, "m": 27690}, "output": 24260}, {"input": {"n": 462534, "m": 16760}, "output": 1712}, {"input": {"n": 864018, "m": 41226}, "output": 24892}], "error_log": []}
{"context": "In a game of strategy, a player is faced with a pile of cakes, one of which is poisoned. The player must decide whether to go first or second and then make moves to avoid eating the last cake. Each move consists of taking one, two, or three cakes, but the player cannot repeat the opponent's previous move. Given the initial number of cakes and whether the player is making the first move, what will be the outcome of the game for the player?\n\nThe input and output requirements are as follows:\n\nInput:\n  `cakes` (int): The number of cakes initially on the table.\n  `is_first_move` (bool): A boolean indicating whether the player is making the first move.\n\nOutput:\n  `return` (str): A string indicating the result of the game. Possible values are \"Won\", \"Lost\", or \"Invalid move\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Player:\n    def __init__(self, cakes):\n        pass\n\n    def firstmove(self, cakes):\n        return cakes > 2 and cakes % 4 != 2\n\n    def move(self, cakes, last):\n        return 3 if cakes % 4 < 3 else 1\n\n# main function\ndef main_solution(cakes, is_first_move):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    player = Player(cakes)\n    if is_first_move:\n        if not player.firstmove(cakes):\n            return \"Invalid first move\"\n        last_move = 0\n    else:\n        last_move = random.choice([1, 2, 3])\n    \n    while cakes > 0:\n        if cakes == 1:\n            return \"Lost\"\n        move = player.move(cakes, last_move)\n        if move == last_move:\n            return \"Invalid move\"\n        cakes -= move\n        last_move = move\n    \n    return \"Won\"", "input_generator": "import random\n\ndef input_generator():\n    cakes = random.randint(1, 100)\n    is_first_move = random.choice([True, False])\n    return {'cakes': cakes, 'is_first_move': is_first_move}", "io_pairs": [{"input": {"cakes": 25, "is_first_move": false}, "output": "Invalid move"}, {"input": {"cakes": 79, "is_first_move": false}, "output": "Invalid move"}, {"input": {"cakes": 39, "is_first_move": true}, "output": "Won"}, {"input": {"cakes": 18, "is_first_move": false}, "output": "Won"}, {"input": {"cakes": 3, "is_first_move": true}, "output": "Won"}, {"input": {"cakes": 47, "is_first_move": true}, "output": "Won"}, {"input": {"cakes": 78, "is_first_move": false}, "output": "Won"}, {"input": {"cakes": 80, "is_first_move": false}, "output": "Invalid move"}, {"input": {"cakes": 8, "is_first_move": false}, "output": "Invalid move"}, {"input": {"cakes": 43, "is_first_move": false}, "output": "Won"}], "error_log": []}
{"context": "In an alien language that uses the Latin alphabet, the order of letters is unknown. You have received a list of words that are sorted lexicographically according to the rules of this language. What is the order of the letters in this alien language based on the given list of words?\n\nThe input and output requirements are as follows:\n\nInput:\n  `words` (List[str]): A list of non-empty strings representing words sorted lexicographically by the rules of the alien language.\n\nOutput:\n  `return` (str): A string representing the order of letters in the alien language. If the order is invalid, it returns an empty string.", "reference_code": "# import necessary packages\nfrom collections import defaultdict, deque\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def alienOrder(self, words: List[str]) -> str:\n        G = self.construct_graph(words)\n        visited = defaultdict(int)  # 0 not visited, 1 visiting, 2 visited\n        ret = deque()\n        for u in G.keys():\n            if visited[u] == 0:\n                if not self.topo_dfs(G, u, visited, ret):\n                    return \"\"\n\n        return \"\".join(ret)\n\n    def construct_graph(self, words):\n        G = defaultdict(list)\n        # need to initialize, consider test case [\"z\", \"z\"]\n        for w in words:  # error\n            for c in w:\n                G[c]\n\n        for i in range(len(words) - 1):  # compare word_i and word_{i+1}\n            for c1, c2 in zip(words[i], words[i+1]):\n                if c1 != c2:  # lexical order\n                    G[c1].append(c2)\n                    break  # need to break for lexical order\n\n        return G\n\n    def topo_dfs(self, G, u, visited, ret):\n        \"\"\"\n        Topological sort\n        G = defaultdict(list)\n        visited = defaultdict(int)  # 0 not visited, 1 visiting, 2 visited\n\n        pre-condition: u is not visited (0)\n        \"\"\"\n        visited[u] = 1\n        for nbr in G[u]:\n            if visited[nbr] == 1:\n                return False\n            if visited[nbr] == 0:\n                if not self.topo_dfs(G, nbr, visited, ret):\n                    return False\n\n        visited[u] = 2\n        ret.appendleft(u)  # visit larger first\n        return True\n\n# main function\ndef main_solution(words: List[str]) -> str:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.alienOrder(words)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nfrom typing import List\n\ndef input_generator():\n    # Define possible characters for the alien language\n    chars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n             'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    \n    # Randomly select a subset of characters to use\n    num_chars = random.randint(3, 10)\n    selected_chars = random.sample(chars, num_chars)\n    \n    # Generate a random order for the selected characters\n    random_order = selected_chars.copy()\n    random.shuffle(random_order)\n    \n    # Generate words based on the random order\n    num_words = random.randint(2, 10)\n    words = []\n    for _ in range(num_words):\n        word_length = random.randint(1, 5)\n        word = ''.join(random.choices(random_order, k=word_length))\n        words.append(word)\n    \n    # Ensure the words are lexically ordered based on the random_order\n    words.sort(key=lambda word: [random_order.index(c) for c in word])\n    \n    return {'words': words}", "io_pairs": [{"input": {"words": ["khhh", "hcckk", "hkcy"]}, "output": "yckh"}, {"input": {"words": ["azcwz", "pz", "cn", "xwa"]}, "output": "nwzapcx"}, {"input": {"words": ["w", "w", "wi", "wi", "winp", "wkwm", "p", "pinwp", "nm"]}, "output": "mikwpn"}, {"input": {"words": ["qwc", "qtqc", "w", "f", "t", "tqt", "twqf"]}, "output": "cqwft"}, {"input": {"words": ["w", "swwew", "ssw", "ses", "ew", "ee"]}, "output": "wse"}, {"input": {"words": ["wewv", "wem", "o", "e", "eu", "em", "eoemo"]}, "output": "uvwmoe"}, {"input": {"words": ["vtsks", "dyvc", "kct", "rcyy"]}, "output": "cystvdkr"}, {"input": {"words": ["bexx", "u", "xzsp"]}, "output": "pszebux"}, {"input": {"words": ["t", "tsuy", "tauyu", "ssy", "sycty", "suuc", "yca", "a", "u"]}, "output": "ctsyau"}, {"input": {"words": ["au", "d", "d", "wu"]}, "output": "uadw"}], "error_log": []}
