{"context": "Given a position in the Fibonacci sequence and a modulo value, what is the result of the Fibonacci number at that position modulo the given value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The position in the Fibonacci sequence.\n  `m` (int): The modulo value.\n\nOutput:\n  `return` (int): The result of the Fibonacci number at position `n` modulo `m`.", "reference_code": "# import necessary packages\nimport sys\n\n# main function\ndef main_solution(n, m):\n    # Convert JSON serializable inputs to the required format\n    n = int(n)\n    m = int(m)\n\n    # Function to calculate the huge Fibonacci number modulo m\n    def get_fibonacci_huge(n, m):\n        if n == 0:\n            return 0\n\n        fib = {0: 0, 1: 1}\n        mod = {0: 0, 1: 1}\n\n        i = 2\n\n        while True:\n            fib.setdefault(i, mod.get(i - 1) + mod.get(i - 2))\n            mod.setdefault(i, fib.get(i) % m)\n            if mod[i - 1] == 0 and mod[i] == 1:\n                break\n            i += 1\n\n        remainder = n % (i - 1)\n        return fib.get(remainder) % m\n\n    # Get the result\n    result = get_fibonacci_huge(n, m)\n\n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(0, 10**6)\n    m = random.randint(2, 10**5)\n    return {'n': n, 'm': m}", "io_pairs": [{"input": {"n": 340285, "m": 31490}, "output": 4655}, {"input": {"n": 390036, "m": 42507}, "output": 20637}, {"input": {"n": 139445, "m": 33630}, "output": 22535}, {"input": {"n": 689468, "m": 59713}, "output": 19198}, {"input": {"n": 609839, "m": 8596}, "output": 1}, {"input": {"n": 912697, "m": 87976}, "output": 34985}, {"input": {"n": 94681, "m": 65449}, "output": 37911}, {"input": {"n": 126165, "m": 27690}, "output": 24260}, {"input": {"n": 462534, "m": 16760}, "output": 1712}, {"input": {"n": 864018, "m": 41226}, "output": 24892}], "error_log": []}
{"context": "In a game of strategy, a player is faced with a pile of cakes, one of which is poisoned. The player must decide whether to go first or second and then make moves to avoid eating the last cake. Each move consists of taking one, two, or three cakes, but the player cannot repeat the opponent's previous move. Given the initial number of cakes and whether the player is making the first move, what will be the outcome of the game for the player?\n\nThe input and output requirements are as follows:\n\nInput:\n  `cakes` (int): The number of cakes initially on the table.\n  `is_first_move` (bool): A boolean indicating whether the player is making the first move.\n\nOutput:\n  `return` (str): A string indicating the result of the game. Possible values are \"Won\", \"Lost\", or \"Invalid move\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Player:\n    def __init__(self, cakes):\n        pass\n\n    def firstmove(self, cakes):\n        return cakes > 2 and cakes % 4 != 2\n\n    def move(self, cakes, last):\n        return 3 if cakes % 4 < 3 else 1\n\n# main function\ndef main_solution(cakes, is_first_move):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    player = Player(cakes)\n    if is_first_move:\n        if not player.firstmove(cakes):\n            return \"Invalid first move\"\n        last_move = 0\n    else:\n        last_move = random.choice([1, 2, 3])\n    \n    while cakes > 0:\n        if cakes == 1:\n            return \"Lost\"\n        move = player.move(cakes, last_move)\n        if move == last_move:\n            return \"Invalid move\"\n        cakes -= move\n        last_move = move\n    \n    return \"Won\"", "input_generator": "import random\n\ndef input_generator():\n    cakes = random.randint(1, 100)\n    is_first_move = random.choice([True, False])\n    return {'cakes': cakes, 'is_first_move': is_first_move}", "io_pairs": [{"input": {"cakes": 25, "is_first_move": false}, "output": "Invalid move"}, {"input": {"cakes": 79, "is_first_move": false}, "output": "Invalid move"}, {"input": {"cakes": 39, "is_first_move": true}, "output": "Won"}, {"input": {"cakes": 18, "is_first_move": false}, "output": "Won"}, {"input": {"cakes": 3, "is_first_move": true}, "output": "Won"}, {"input": {"cakes": 47, "is_first_move": true}, "output": "Won"}, {"input": {"cakes": 78, "is_first_move": false}, "output": "Won"}, {"input": {"cakes": 80, "is_first_move": false}, "output": "Invalid move"}, {"input": {"cakes": 8, "is_first_move": false}, "output": "Invalid move"}, {"input": {"cakes": 43, "is_first_move": false}, "output": "Won"}], "error_log": []}
{"context": "In an alien language that uses the Latin alphabet, the order of letters is unknown. You have received a list of words that are sorted lexicographically according to the rules of this language. What is the order of the letters in this alien language based on the given list of words?\n\nThe input and output requirements are as follows:\n\nInput:\n  `words` (List[str]): A list of non-empty strings representing words sorted lexicographically by the rules of the alien language.\n\nOutput:\n  `return` (str): A string representing the order of letters in the alien language. If the order is invalid, it returns an empty string.", "reference_code": "# import necessary packages\nfrom collections import defaultdict, deque\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def alienOrder(self, words: List[str]) -> str:\n        G = self.construct_graph(words)\n        visited = defaultdict(int)  # 0 not visited, 1 visiting, 2 visited\n        ret = deque()\n        for u in G.keys():\n            if visited[u] == 0:\n                if not self.topo_dfs(G, u, visited, ret):\n                    return \"\"\n\n        return \"\".join(ret)\n\n    def construct_graph(self, words):\n        G = defaultdict(list)\n        # need to initialize, consider test case [\"z\", \"z\"]\n        for w in words:  # error\n            for c in w:\n                G[c]\n\n        for i in range(len(words) - 1):  # compare word_i and word_{i+1}\n            for c1, c2 in zip(words[i], words[i+1]):\n                if c1 != c2:  # lexical order\n                    G[c1].append(c2)\n                    break  # need to break for lexical order\n\n        return G\n\n    def topo_dfs(self, G, u, visited, ret):\n        \"\"\"\n        Topological sort\n        G = defaultdict(list)\n        visited = defaultdict(int)  # 0 not visited, 1 visiting, 2 visited\n\n        pre-condition: u is not visited (0)\n        \"\"\"\n        visited[u] = 1\n        for nbr in G[u]:\n            if visited[nbr] == 1:\n                return False\n            if visited[nbr] == 0:\n                if not self.topo_dfs(G, nbr, visited, ret):\n                    return False\n\n        visited[u] = 2\n        ret.appendleft(u)  # visit larger first\n        return True\n\n# main function\ndef main_solution(words: List[str]) -> str:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.alienOrder(words)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nfrom typing import List\n\ndef input_generator():\n    # Define possible characters for the alien language\n    chars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n             'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    \n    # Randomly select a subset of characters to use\n    num_chars = random.randint(3, 10)\n    selected_chars = random.sample(chars, num_chars)\n    \n    # Generate a random order for the selected characters\n    random_order = selected_chars.copy()\n    random.shuffle(random_order)\n    \n    # Generate words based on the random order\n    num_words = random.randint(2, 10)\n    words = []\n    for _ in range(num_words):\n        word_length = random.randint(1, 5)\n        word = ''.join(random.choices(random_order, k=word_length))\n        words.append(word)\n    \n    # Ensure the words are lexically ordered based on the random_order\n    words.sort(key=lambda word: [random_order.index(c) for c in word])\n    \n    return {'words': words}", "io_pairs": [{"input": {"words": ["khhh", "hcckk", "hkcy"]}, "output": "yckh"}, {"input": {"words": ["azcwz", "pz", "cn", "xwa"]}, "output": "nwzapcx"}, {"input": {"words": ["w", "w", "wi", "wi", "winp", "wkwm", "p", "pinwp", "nm"]}, "output": "mikwpn"}, {"input": {"words": ["qwc", "qtqc", "w", "f", "t", "tqt", "twqf"]}, "output": "cqwft"}, {"input": {"words": ["w", "swwew", "ssw", "ses", "ew", "ee"]}, "output": "wse"}, {"input": {"words": ["wewv", "wem", "o", "e", "eu", "em", "eoemo"]}, "output": "uvwmoe"}, {"input": {"words": ["vtsks", "dyvc", "kct", "rcyy"]}, "output": "cystvdkr"}, {"input": {"words": ["bexx", "u", "xzsp"]}, "output": "pszebux"}, {"input": {"words": ["t", "tsuy", "tauyu", "ssy", "sycty", "suuc", "yca", "a", "u"]}, "output": "ctsyau"}, {"input": {"words": ["au", "d", "d", "wu"]}, "output": "uadw"}], "error_log": []}
{"context": "Given a binary search tree, how can we transform it into an ordered doubly linked list where each node's left pointer points to the previous node and the right pointer points to the next node in the sequence? What is the sequence of values in the resulting doubly linked list?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (dict): A dictionary representing the structure of the binary search tree. Each key-value pair represents a node in the tree. The keys are:\n    - `value` (int): The value of the node.\n    - `left` (dict or None): The left child of the node, represented as another tree structure dictionary. If there is no left child, this is `None`.\n    - `right` (dict or None): The right child of the node, represented as another tree structure dictionary. If there is no right child, this is `None`.\n\nOutput:\n  `return` (list of int): A list of integers representing the values of the nodes in the doubly linked list, in the order they appear from head to tail.", "reference_code": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    left, right = None, None\n    def __init__(self, data):\n        self.value = data\n\ndef in_order_to_queue(head, queue):\n    if not head:\n        return\n    in_order_to_queue(head.left, queue)\n    queue.append(head)\n    in_order_to_queue(head.right, queue)\n\ndef process(head):\n    if not head:\n        return None\n    leftE = process(head.left)\n    rightE = process(head.right)\n    leftS = leftE.right if leftE else None\n    rightS = rightE.right if rightE else None\n    if leftE and rightE:\n        leftE.right = head\n        head.right = rightS\n        rightS.left = head\n        rightE.right = leftS\n        return rightE\n    elif leftE:\n        leftE.right = head\n        head.left = leftE\n        head.right = leftS\n        return head\n    elif rightE:\n        head.right = rightS\n        rightS.left = head\n        rightE.right = head\n        return rightE\n    else:\n        head.right = head\n        return head\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(structure):\n        if not structure:\n            return None\n        node = Node(structure['value'])\n        node.left = build_tree(structure['left'])\n        node.right = build_tree(structure['right'])\n        return node\n\n    head = build_tree(tree_structure)\n    \n    # Convert the binary search tree to a doubly linked list\n    if not head:\n        return None\n    last = process(head)\n    head = last.right\n    last.right = None\n    \n    # Convert the doubly linked list back to a JSON serializable output\n    result = []\n    cur = head\n    while cur:\n        result.append(cur.value)\n        cur = cur.right\n    \n    return result", "input_generator": "import random\nfrom collections import deque\n\ndef input_generator():\n    def generate_tree(depth):\n        if depth == 0 or random.random() < 0.3:\n            return None\n        value = random.randint(1, 100)\n        left = generate_tree(depth - 1)\n        right = generate_tree(depth - 1)\n        return {'value': value, 'left': left, 'right': right}\n    \n    tree_structure = generate_tree(random.randint(1, 5))\n    return {'tree_structure': tree_structure}", "io_pairs": [{"input": {"tree_structure": {"value": 99, "left": null, "right": null}}, "output": [99]}, {"input": {"tree_structure": {"value": 42, "left": null, "right": null}}, "output": [42]}, {"input": {"tree_structure": {"value": 29, "left": null, "right": null}}, "output": [29]}, {"input": {"tree_structure": {"value": 68, "left": null, "right": null}}, "output": [68]}, {"input": {"tree_structure": {"value": 34, "left": null, "right": null}}, "output": [34]}, {"input": {"tree_structure": {"value": 27, "left": null, "right": null}}, "output": [27]}, {"input": {"tree_structure": {"value": 63, "left": null, "right": null}}, "output": [63]}, {"input": {"tree_structure": {"value": 53, "left": null, "right": null}}, "output": [53]}, {"input": {"tree_structure": {"value": 47, "left": null, "right": {"value": 34, "left": null, "right": null}}}, "output": [47, 34]}, {"input": {"tree_structure": {"value": 84, "left": {"value": 63, "left": null, "right": null}, "right": null}}, "output": [63, 84]}], "error_log": []}
{"context": "Given a grid of size R x C, where R is the number of rows and C is the number of columns, and a number M representing the number of mines to be placed in the grid, what is the arrangement of the mines such that there is a safe path from the top-left corner (marked as 'c') to the bottom-right corner without stepping on a mine? The grid should be represented as a string where 'c' marks the starting point, '.' marks safe cells, and '*' marks mines. If no such arrangement is possible, return \"Impossible\".\n\nThe input and output requirements are as follows:\n\nInput:\n- `R` (int): Number of rows in the grid.\n- `C` (int): Number of columns in the grid.\n- `M` (int): Number of mines to be placed in the grid.\n\nOutput:\n- `return` (str): A string representation of the grid with 'c' marking the starting point, '.' marking safe cells, and '*' marking mines. If no valid configuration is possible, returns \"Impossible\".", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(R, C, M):\n    \"\"\"\n    Solves the problem of placing mines in a grid of size R x C with M mines, ensuring that there is a path from the top-left corner to the bottom-right corner without stepping on a mine.\n\n    Args:\n    R (int): Number of rows in the grid.\n    C (int): Number of columns in the grid.\n    M (int): Number of mines to be placed in the grid.\n\n    Returns:\n    str: A string representation of the grid with 'c' marking the starting point, '.' marking safe cells, and '*' marking mines. If no valid configuration is possible, returns \"Impossible\".\n    \"\"\"\n    blanks = R * C - M\n    if blanks <= 0:\n        return \"Impossible\"\n    \n    grid = [['*' for _ in range(C)] for _ in range(R)]\n    \n    if blanks == 1:\n        grid[0][0] = 'c'\n        return '\\n'.join(''.join(row) for row in grid)\n    \n    if R == 1:\n        for i in range(blanks):\n            grid[0][i] = '.'\n        grid[0][0] = 'c'\n        return '\\n'.join(''.join(row) for row in grid)\n    \n    if C == 1:\n        for i in range(blanks):\n            grid[i][0] = '.'\n        grid[0][0] = 'c'\n        return '\\n'.join(''.join(row) for row in grid)\n    \n    if blanks in [2, 3, 5, 7]:\n        return \"Impossible\"\n    \n    rows = 2\n    columns = 2\n    found_match = False\n    \n    while not found_match:\n        leftover = blanks - rows * columns\n        if leftover < 0 or columns > C:\n            rows += 1\n            columns = 2\n        elif leftover == 0:\n            found_match = True\n        elif rows != R and columns != C:\n            if leftover >= 2 and (leftover <= columns or leftover <= rows):\n                found_match = True\n            elif leftover < rows + columns and leftover >= 5:\n                found_match = True\n            else:\n                columns += 1\n        elif rows == R and (leftover <= rows and leftover > 1):\n            found_match = True\n        elif columns == C and (leftover <= columns and leftover > 1):\n            found_match = True\n        else:\n            columns += 1\n        if rows > R:\n            break\n    \n    if not found_match:\n        return \"Impossible\"\n    \n    for i in range(rows):\n        for j in range(columns):\n            grid[i][j] = '.'\n    \n    if leftover <= columns:\n        for i in range(leftover):\n            grid[rows][i] = '.'\n    elif leftover <= rows:\n        for i in range(leftover):\n            grid[i][columns] = '.'\n    else:\n        extra = leftover - 2\n        while C < extra:\n            extra -= 1\n        for i in range(extra):\n            grid[rows][i] = '.'\n        leftover -= extra\n        for i in range(leftover):\n            grid[i][columns] = '.'\n    \n    grid[0][0] = 'c'\n    return '\\n'.join(''.join(row) for row in grid)", "input_generator": "import random\n\ndef input_generator():\n    R = random.randint(1, 20)\n    C = random.randint(1, 20)\n    max_mines = R * C - 1\n    M = random.randint(0, max_mines) if max_mines > 0 else 0\n    return {'R': R, 'C': C, 'M': M}", "io_pairs": [{"input": {"R": 2, "C": 2, "M": 0}, "output": "c.\n.."}, {"input": {"R": 11, "C": 6, "M": 17}, "output": "c.....\n......\n......\n.....*\n.....*\n.....*\n.....*\n.....*\n......\n******\n******"}, {"input": {"R": 5, "C": 19, "M": 71}, "output": "c.......***********\n........***********\n........***********\n*******************\n*******************"}, {"input": {"R": 10, "C": 3, "M": 3}, "output": "c..\n...\n...\n...\n...\n...\n...\n...\n...\n***"}, {"input": {"R": 10, "C": 4, "M": 34}, "output": "c.**\n..**\n..**\n****\n****\n****\n****\n****\n****\n****"}, {"input": {"R": 15, "C": 4, "M": 20}, "output": "c...\n....\n....\n....\n....\n....\n....\n....\n....\n....\n****\n****\n****\n****\n****"}, {"input": {"R": 16, "C": 5, "M": 53}, "output": "c....\n.....\n....*\n....*\n....*\n.....\n*****\n*****\n*****\n*****\n*****\n*****\n*****\n*****\n*****\n*****"}, {"input": {"R": 16, "C": 1, "M": 6}, "output": "c\n.\n.\n.\n.\n.\n.\n.\n.\n.\n*\n*\n*\n*\n*\n*"}, {"input": {"R": 1, "C": 18, "M": 13}, "output": "c....*************"}, {"input": {"R": 12, "C": 7, "M": 67}, "output": "c.....*\n......*\n.....**\n*******\n*******\n*******\n*******\n*******\n*******\n*******\n*******\n*******"}], "error_log": []}
{"context": "Given a chessboard of a certain width, how many distinct ways can you place N queens on the board such that no two queens threaten each other? The queens must be placed in such a way that no two queens share the same row, column, or diagonal. The width of the chessboard is denoted by `board_width`.\n\nThe input and output requirements are as follows:\n\nInput:\n- `board_width` (int): The width of the chessboard, which is also the number of queens to be placed. It must be a positive integer.\n\nOutput:\n- `return` (int): The number of distinct solutions to the N-Queens problem for the given board width.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef isInt(strNum):\n    try:\n        int(strNum)\n        return True\n    except ValueError:\n        return False\n\ndef check(grid, qY, qX, w):\n    # Check all directions for conflicts\n    directions = [(-1, -1), (-1, 1), (1, -1), (1, 1), (0, 1), (1, 0)]\n    for dy, dx in directions:\n        y, x = qY + dy, qX + dx\n        while 0 <= y < w and 0 <= x < w:\n            if grid[y][x] == \"Q\":\n                return False\n            y += dy\n            x += dx\n    return True\n\ndef nFor(grid, y, depth, size, answers):\n    if depth <= 0:\n        return\n    for i in range(size):\n        if check(grid, y, i, size):\n            grid[y][i] = \"Q\"\n            if depth == 1:\n                answers[0] += 1\n            nFor(grid, y + 1, depth - 1, size, answers)\n        grid[y][i] = \"\"\n\n# main function\ndef main_solution(board_width):\n    # Initialize the grid and other variables\n    grid = [[\" \" for _ in range(board_width)] for _ in range(board_width)]\n    answers = [0]\n    \n    # Start the recursive function to find solutions\n    nFor(grid, 0, board_width, board_width, answers)\n    \n    # Return the number of solutions found\n    return answers[0]", "input_generator": "import random\n\ndef input_generator():\n    return {'board_width': random.randint(1, 10)}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "In a secret communication system, a message needs to be encrypted using a transposition cipher. The encryption process involves rearranging the characters of the message based on a key and repeating the process a specified number of times. Given a key, the number of stages, and a plaintext message, what is the resulting encrypted text?\n\nThe input and output requirements are as follows:\n\nInput:\n  `key` (str): A string representing the key used for the transposition cipher.\n  `stage` (int): An integer representing the number of times the transposition cipher should be applied.\n  `plaintext` (str): A string representing the plaintext message to be encrypted.\n\nOutput:\n  `return` (str): A string representing the encrypted text after applying the transposition cipher.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# Method used to encrypt a plain text message given a specific key.\n# The stage will determine the number of time the transposition cipher\n# needs to be completed on the plain text\ndef Transpose_Encrypt(key, stage, plaintext):\n    # Removing non alphabetic characters\n    plaintext = ''.join(char for char in plaintext.lower() if 'a' <= char <= 'z')\n\n    # Getting the lengths of the key and message\n    kLen = len(key)\n    sLen = len(plaintext)\n\n    # Calculating and adding, if necessary, the padding\n    padLen = 0\n    if (sLen % kLen > 0):\n        padLen = kLen - (sLen % kLen)\n    if (padLen > 0):\n        plaintext = plaintext.ljust(sLen + padLen, 'x')\n        sLen = len(plaintext)\n\n    # Getting the order in which the columns will be read\n    kList = [char for char in key.lower()]\n    kListSorted = [char for char in key.lower()]\n    kListSorted.sort()\n    kIndex = []\n    for i in range(kLen):\n        kIndex.append(kList.index(kListSorted[i]))\n        kList[kList.index(kListSorted[i])] = \" \"\n\n    # For loop to do the encryption multiple times if the stage is\n    # greater than 1\n    for sNum in range(stage):\n        if (sNum < 1):\n            sText = plaintext\n\n        # Creating and populating the transposition matrix\n        nCol = kLen\n        nRow = sLen // kLen\n        trans = np.full((nRow, nCol), '')\n\n        tCounter = 0\n        for i in range(nRow):\n            for j in range(nCol):\n                trans[i][j] = sText[tCounter]\n                tCounter += 1\n\n        # Encrypting the plaintext string\n        encryptText = \"\"\n        for i in range(nCol):\n            for j in range(nRow):\n                encryptText += trans[j][kIndex[i]]\n\n        if (stage > 1):\n            sText = encryptText\n\n    # Returning the encrypted string\n    return encryptText\n\n# main function\ndef main_solution(key, stage, plaintext):\n    # Convert input variables to the required format if necessary\n    key = str(key)\n    stage = int(stage)\n    plaintext = str(plaintext)\n\n    # Call the encryption function\n    encrypted_text = Transpose_Encrypt(key, stage, plaintext)\n\n    # Return the encrypted text as a string\n    return encrypted_text", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random key (letters only, length between 3 and 10)\n    key_length = random.randint(3, 10)\n    key = ''.join(random.choice(string.ascii_letters) for _ in range(key_length))\n    \n    # Generate a random stage (between 1 and 5)\n    stage = random.randint(1, 5)\n    \n    # Generate a random plaintext (length between 10 and 50, letters and possibly other characters)\n    plaintext_length = random.randint(10, 50)\n    plaintext = ''.join(random.choice(string.ascii_letters + string.digits + string.punctuation + ' ') for _ in range(plaintext_length))\n    \n    return {'key': key, 'stage': stage, 'plaintext': plaintext}", "io_pairs": [{"input": {"key": "OQkevVUDd", "stage": 3, "plaintext": "\\CXGG8?4wN(&0[v]tqj"}, "output": "xxtwxgcxxjnxqxxxvg"}, {"input": {"key": "TNlz", "stage": 3, "plaintext": "e_:]|G,xX}0dD$LsF>h+>o4EM)@(aIswtMj)@xofp\\g4.&`aJ$"}, "output": "apaxfgejshjoixowfxdsdelmmgtx"}, {"input": {"key": "hZeHVjmPFd", "stage": 1, "plaintext": "#_X?&g^Rjp]x82l3yU-3T.[KB#$`4>cQq7VA=D8"}, "output": "txrcuxxkjqxvlaydpqgb"}, {"input": {"key": "bvDuTG", "stage": 1, "plaintext": "*4kT[T.oV] 4-uFxVr$4}JfpZIB+"}, "output": "kfptviufxvjxorbtxz"}, {"input": {"key": "hhYmN", "stage": 2, "plaintext": "JM4C)NmfXp%nw"}, "output": "jnfmxcnpmw"}, {"input": {"key": "pxBuRlk", "stage": 2, "plaintext": "Q%d=xD$[t/={e856Gx>P/\\ (W/}=o@Q{iVWJS:/E,{w9Bj6pC"}, "output": "sitxjxdcvqxjxxwogxwpxbqdwepe"}, {"input": {"key": "dJhNc", "stage": 3, "plaintext": "06Lu,!Y;5uW_@[ic{x]"}, "output": "luycwuxxxi"}, {"input": {"key": "Vdwk", "stage": 1, "plaintext": "2z^+I^t'oN.l}Hefo?]f'M&ax"}, "output": "iloxoemxznfathfx"}, {"input": {"key": "uwnsAZ", "stage": 1, "plaintext": "V^7_V]Fwe079E|H`^d>Kwg;$&)TS9"}, "output": "egxfkxwwxvhsvdxetx"}, {"input": {"key": "kZnT", "stage": 4, "plaintext": "iA_ym?g1R9O CC+W\\%{{ 0j:;tMz5\\G>VP9;<@M"}, "output": "iymjcxotwacmmpxrgvgz"}], "error_log": []}
{"context": "Given a square matrix of size \\( n \\times n \\) and an integer exponent \\( x \\), what is the resulting matrix when the original matrix is raised to the power \\( x \\), with each element of the resulting matrix taken modulo 1000?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the square matrix (n x n).\n  `x` (int): The exponent to which the matrix should be raised.\n  `a` (list of lists of int): The n x n matrix represented as a list of lists of integers.\n\nOutput:\n  `return` (list of lists of int): The resulting n x n matrix after raising the input matrix `a` to the power `x`, with each element modulo 1000.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef multi_mat(n, m1, m2): \n    result = [[0 for _ in range(n)] for _ in range(n)] #\uacc4\uc0b0 \uacb0\uacfc \ub2f4\ub294 \ud589\ub82c\n\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                result[i][j] += m1[i][k] * m2[k][j] #\ud589\ub82c \uacc4\uc0b0 \uac12\uc744 \uacb0\uacfc \ub2f4\ub294 \ud589\ub82c\uc5d0 \ub123\uc5b4\uc90c\n            result[i][j] %= 1000 #1000\uc73c\ub85c \ub098\ub208 \ub098\uba38\uc9c0\n    \n    return result\n\ndef dev(n, x, mat):\n    if x == 1: #\uc885\ub8cc : x // 2 = n = 0\n        return mat \n    else:\n        tmp = dev(n, x // 2, mat)\n        if x % 2 == 0: #\uc9dd\uc218 \uc81c\uacf1\n            return multi_mat(n, tmp, tmp)\n        else: #\ud640\uc218 \uc81c\uacf1\n            return multi_mat(n, multi_mat(n, tmp, tmp), mat)\n\n# main function\ndef main_solution(n, x, a):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # convert input to the required format for the original functions\n    a = [[int(val) for val in row] for row in a]\n    \n    # call the original function\n    result = dev(n, x, a)\n    \n    # convert the result to a JSON serializable format\n    result = [[val % 1000 for val in row] for row in result]\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Matrix size between 1x1 and 10x10\n    x = random.randint(1, 20)  # Exponent between 1 and 20\n    \n    # Generate a random n x n matrix with elements between 0 and 999\n    a = [[random.randint(0, 999) for _ in range(n)] for _ in range(n)]\n    \n    return {\n        'n': n,\n        'x': x,\n        'a': a\n    }", "io_pairs": [{"input": {"n": 1, "x": 15, "a": [[986]]}, "output": [[776]]}, {"input": {"n": 1, "x": 10, "a": [[302]]}, "output": [[24]]}, {"input": {"n": 2, "x": 2, "a": [[178, 123], [477, 243]]}, "output": [[355, 783], [817, 720]]}, {"input": {"n": 1, "x": 1, "a": [[433]]}, "output": [[433]]}, {"input": {"n": 2, "x": 7, "a": [[28, 606], [255, 827]]}, "output": [[982, 794], [745, 783]]}, {"input": {"n": 2, "x": 19, "a": [[58, 608], [802, 503]]}, "output": [[416, 424], [806, 751]]}, {"input": {"n": 1, "x": 7, "a": [[329]]}, "output": [[409]]}, {"input": {"n": 1, "x": 12, "a": [[356]]}, "output": [[536]]}, {"input": {"n": 2, "x": 10, "a": [[98, 693], [447, 905]]}, "output": [[836, 721], [859, 615]]}, {"input": {"n": 2, "x": 18, "a": [[178, 398], [812, 486]]}, "output": [[768, 400], [600, 168]]}], "error_log": []}
{"context": "Given a puzzle with a starting configuration and a goal configuration, what is the sequence of moves required to transform the starting configuration into the goal configuration using the A* search algorithm with the Manhattan distance heuristic? If the puzzle is unsolvable, indicate so.\n\nThe input and output requirements are as follows:\n\nInput:\n  `init_state` (list of lists of integers): The initial state of the puzzle represented as a 2D list of integers.\n  `goal_state` (list of lists of integers): The goal state of the puzzle represented as a 2D list of integers.\n\nOutput:\n  `return` (list of strings): The sequence of moves to solve the puzzle, or [\"UNSOLVABLE\"] if the puzzle is unsolvable.", "reference_code": "# import necessary packages\nimport math\nfrom datetime import datetime\nfrom queue import PriorityQueue\n\n# all class and function definitions in the code file, if any\nclass Puzzle(object):\n    def __init__(self, init_state, goal_state):\n        self.init_state = init_state\n        self.goal_state = goal_state\n        self.actions = list()\n        self.solvable = False\n        self.maxSize = 1\n        self.solutionDepth = 0\n        self.runtime = 0\n        self.goal_position = {}\n        for x, row in enumerate(goal_state):\n            for y, num in enumerate(row):\n                self.goal_position[num] = (x, y)\n\n    def solve(self):\n        if not self.isSolvable(self.init_state):\n            return [\"UNSOLVABLE\"]\n\n        startTime = datetime.now()\n        stack = PriorityQueue()\n        stack.put([len(self.actions) + self.gethn(self.init_state), self.init_state, self.actions])\n        visited = set()\n        max_stack = 1\n        generated = 1\n\n        while stack.qsize() > 0:\n            if stack.qsize() > max_stack:\n                max_stack = stack.qsize()\n            currNode = stack.get()\n            if self.tuplifyStates(currNode[1]) in visited:\n                continue\n            visited.add(self.tuplifyStates(currNode[1]))\n            if currNode[1] == self.goal_state:\n                endTime = datetime.now()\n                delta = endTime - startTime\n                self.solvable = True\n                self.maxSize = max_stack\n                self.solutionDepth = len(currNode[2])\n                self.runtime = delta\n                self.generated = generated\n                self.explored = len(visited)\n                return currNode[2]\n            successors = self.findSuccessors(currNode)\n            for successor in successors:\n                if self.tuplifyStates(successor[1]) in visited:\n                    continue\n                hn = self.gethn(successor[1]) + len(successor[2])\n                successor[0] = hn\n                stack.put(successor)\n                generated += 1\n            del(currNode)\n\n    def gethn(self, state):\n        distance = 0\n        for x, row in enumerate(state):\n            for y, num in enumerate(row):\n                if num == 0:\n                    continue\n                distance += abs(self.goal_position[num][0] - x) + abs(self.goal_position[num][1] - y)\n        return distance\n\n    def isEven(self, n):\n        return n % 2 == 0\n\n    def checkSmallerAfter(self, arr, i):\n        arrLen = len(arr)\n        check = int(arr[i])\n        count = 0\n        for x in range(i, arrLen):\n            if (int(arr[x]) < check) and int(arr[x]):\n                count = count + 1\n        return count\n\n    def isSolvable(self, state):\n        arrLen = len(state)\n        arrStore = []\n        for arrH in state:\n            for arrV in arrH:\n                arrStore.append(arrV)\n        arrStoreLen = len(arrStore)\n        count = 0\n        for i in range(arrStoreLen):\n            count = count + self.checkSmallerAfter(arrStore, i)\n        if self.isEven(arrLen):\n            [r, c] = self.findBlankSpace(state)\n            countFromBottom = arrLen - r\n            if self.isEven(countFromBottom):\n                return not self.isEven(count)\n            else:\n                return self.isEven(count)\n        else:\n            return self.isEven(count)\n\n    def findSuccessors(self, node):\n        successors = []\n        blankSpace = self.findBlankSpace(node[1])\n        if blankSpace[0] != len(node[1]) - 1:\n            successors.append(self.slideUp(node))\n        if blankSpace[0] != 0:\n            successors.append(self.slideDown(node))\n        if blankSpace[1] != len(node[1]) - 1:\n            successors.append(self.slideLeft(node))\n        if blankSpace[1] != 0:\n            successors.append(self.slideRight(node))\n        return successors\n\n    def findBlankSpace(self, state):\n        for i in range(len(state[0])):\n            for j in range(len(state[0])):\n                if state[i][j] == 0:\n                    return [i, j]\n\n    def slideUp(self, node):\n        state = node[1]\n        n = len(node[1])\n        blankSpace = self.findBlankSpace(state)\n        moves = []\n        for move in node[2]:\n            moves.append(move)\n        moves.append(\"UP\")\n        newState = [[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(n):\n                newState[i][j] = state[i][j]\n        newState[blankSpace[0]][blankSpace[1]] = newState[blankSpace[0] + 1][blankSpace[1]]\n        newState[blankSpace[0] + 1][blankSpace[1]] = 0\n        return [node[0], newState, moves]\n\n    def slideDown(self, node):\n        state = node[1]\n        n = len(node[1])\n        blankSpace = self.findBlankSpace(state)\n        moves = []\n        for move in node[2]:\n            moves.append(move)\n        moves.append(\"DOWN\")\n        newState = [[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(n):\n                newState[i][j] = state[i][j]\n        newState[blankSpace[0]][blankSpace[1]] = newState[blankSpace[0] - 1][blankSpace[1]]\n        newState[blankSpace[0] - 1][blankSpace[1]] = 0\n        return [node[0], newState, moves]\n\n    def slideLeft(self, node):\n        state = node[1]\n        n = len(node[1])\n        blankSpace = self.findBlankSpace(state)\n        moves = []\n        for move in node[2]:\n            moves.append(move)\n        moves.append(\"LEFT\")\n        newState = [[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(n):\n                newState[i][j] = state[i][j]\n        newState[blankSpace[0]][blankSpace[1]] = newState[blankSpace[0]][blankSpace[1] + 1]\n        newState[blankSpace[0]][blankSpace[1] + 1] = 0\n        return [node[0], newState, moves]\n\n    def slideRight(self, node):\n        state = node[1]\n        n = len(node[1])\n        blankSpace = self.findBlankSpace(state)\n        moves = []\n        for move in node[2]:\n            moves.append(move)\n        moves.append(\"RIGHT\")\n        newState = [[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(n):\n                newState[i][j] = state[i][j]\n        newState[blankSpace[0]][blankSpace[1]] = newState[blankSpace[0]][blankSpace[1] - 1]\n        newState[blankSpace[0]][blankSpace[1] - 1] = 0\n        return [node[0], newState, moves]\n\n    def stringifyStates(self, state):\n        return ''.join(''.join(map(str, row)) for row in state)\n\n    def tuplifyStates(self, state):\n        return tuple(map(tuple, state))\n\n# main function\ndef main_solution(init_state, goal_state):\n    puzzle = Puzzle(init_state, goal_state)\n    result = puzzle.solve()\n    return result", "input_generator": "import random\n\ndef input_generator():\n    size = random.choice([3, 4])  # Generate 3x3 or 4x4 puzzles\n    numbers = list(range(size * size))\n    random.shuffle(numbers)\n    \n    # Ensure the initial state is solvable\n    while True:\n        init_state = [numbers[i*size:(i+1)*size] for i in range(size)]\n        puzzle = Puzzle(init_state, [[i*size + j + 1 for j in range(size)] for i in range(size)])\n        puzzle.goal_state[-1][-1] = 0  # Set the last element to 0 for the goal state\n        if puzzle.isSolvable(init_state):\n            break\n        random.shuffle(numbers)\n    \n    goal_state = [[i*size + j + 1 for j in range(size)] for i in range(size)]\n    goal_state[-1][-1] = 0\n    \n    return {\n        'init_state': init_state,\n        'goal_state': goal_state\n    }", "io_pairs": [], "error_log": []}
{"context": "Given a string of characters, how can we determine all possible palindrome permutations that can be formed from it? Specifically, what are the unique palindrome permutations for the given input string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string of characters for which palindrome permutations need to be generated. The string should contain only lowercase letters and should not be empty.\n\nOutput:\n  `return` (list of str): A list of strings, where each string is a unique palindrome permutation of the input string. If no palindrome permutations can be formed, the list will be empty.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\ndef count_letters(string):\n    counts = {'odd': ''}\n    i = 0\n\n    while (i < len(string)):\n        if (string[i] in counts):\n            counts[string[i]] += 1\n        else:\n            counts[string[i]] = 1\n        i += 1\n\n    return counts\n\ndef can_make_palindrome(string, counts):\n    odd = 0\n\n    for k, v in counts.items():\n        if (k != 'odd' and counts[k] & 1):\n            odd += 1\n            counts['odd'] = k\n            if (odd > 1):\n                break\n\n    if (len(string) & 1):\n        return odd == 1\n    else:\n        return odd == 0\n\ndef permute_palindromes(string):\n    palindromes = []\n    counts = count_letters(string)\n\n    if (can_make_palindrome(string, counts)):\n        initial = \"\"\n\n        for k, v in counts.items():\n            if (k != 'odd'):\n                initial += (counts[k] // 2) * k\n\n        permute(list(initial), 0, palindromes, counts['odd'])\n\n    return palindromes\n\ndef swap(string, x, y):\n    temp = string[x]\n    string[x] = string[y]\n    string[y] = temp\n\n    return string\n\ndef permute(string_list, start, palindromes, separator=''):\n    palindrome = \"\".join(string_list) + separator + \"\".join(string_list[::-1])\n    palindromes.append(palindrome)\n\n    i = start\n\n    for i in range(start, len(string_list)):\n        if (string_list[start] != string_list[i]):\n            swap(string_list, start, i)\n            permute(string_list, i+1, palindromes, separator)\n            swap(string_list, start, i)\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a JSON serializable format\n    input_string = str(input_string)\n\n    # Call the permute_palindromes function\n    palindromes = permute_palindromes(input_string)\n\n    # Convert the output to a JSON serializable format\n    palindromes = [str(p) for p in palindromes]\n\n    return palindromes", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 10)\n    chars = random.choices(string.ascii_lowercase, k=length)\n    \n    # Ensure the string can potentially form a palindrome\n    if random.choice([True, False]):\n        half = length // 2\n        first_half = random.choices(string.ascii_lowercase, k=half)\n        second_half = first_half.copy()\n        random.shuffle(second_half)\n        if length % 2 == 1:\n            middle_char = random.choice(string.ascii_lowercase)\n            input_string = ''.join(first_half + [middle_char] + second_half)\n        else:\n            input_string = ''.join(first_half + second_half)\n    else:\n        input_string = ''.join(chars)\n    \n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "zz"}, "output": ["zz"]}, {"input": {"input_string": "useiesu"}, "output": ["useiesu", "sueieus", "esuiuse"]}, {"input": {"input_string": "yjpejepy"}, "output": ["yjpeepjy", "jypeepyj", "jyeppeyj", "pjyeeyjp", "ejpyypje"]}, {"input": {"input_string": "cyhhcy"}, "output": ["cyhhyc", "ychhcy", "hyccyh"]}, {"input": {"input_string": "rcwrfmjt"}, "output": []}, {"input": {"input_string": "qgqqqgq"}, "output": ["qqgqgqq", "gqqqqqg"]}, {"input": {"input_string": "fl"}, "output": []}, {"input": {"input_string": "d"}, "output": ["d"]}, {"input": {"input_string": "evve"}, "output": ["evve", "veev"]}, {"input": {"input_string": "jlj"}, "output": ["jlj"]}], "error_log": []}
{"context": "Given a function \\( f(x) = (x - 3)^2 \\), we want to find the minimum value of this function using Newton's method with backtracking line search. What are the final values of \\( x \\) and \\( f(x) \\) after the method converges, and how many iterations were required to achieve this result, given an initial starting point \\( x_0 \\) and a tolerance level \\( \\epsilon \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x0` (float): The initial starting point for the Newton's method.\n  `error` (float): The tolerance level for stopping the iteration.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `final_x` (float): The final x value after the Newton's method converges.\n    - `final_y` (float): The final y value (objective function value) after the Newton's method converges.\n    - `iterations` (int): The number of iterations taken to converge.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef f(x):\n    return (x - 3) ** 2\n\ndef f_grad(x):\n    return 2 * (x - 3)\n\ndef f_grad_2(x):\n    return 2\n\ndef BacktrackingLineSearch(x0):\n    alpha = 1\n    x = x0\n    rho = 0.8\n    c = 1e-4\n\n    while f(x + alpha * (-f_grad(x))) > f(x) + c * alpha * f_grad(x) * (-f_grad(x)):\n        alpha *= rho\n\n    return alpha\n\n# main function\ndef main_solution(x0, error):\n    # Convert input variables if necessary\n    x0 = float(x0)\n    error = float(error)\n\n    curve_y = [f(x0)]\n    curve_x = [x0]\n\n    lambda_squre = 1\n    while lambda_squre / 2 > error:\n        stepSize = BacktrackingLineSearch(x0)\n        xnt = - (1 / f_grad_2(x0)) * (f_grad(x0))\n        x0 = x0 + stepSize * xnt\n\n        y1 = f(x0)\n        lambda_squre = (f_grad(x0)) * (1 / f_grad_2(x0)) * (f_grad(x0))\n\n        curve_x.append(x0)\n        curve_y.append(y1)\n\n    # Convert output variables if necessary\n    return {\"final_x\": x0, \"final_y\": y1, \"iterations\": len(curve_x)}", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    x0 = random.uniform(-10.0, 10.0)\n    error = 10 ** random.uniform(-6, -2)\n    return {\"x0\": x0, \"error\": error}", "io_pairs": [{"input": {"x0": -6.32276755966668, "error": 8.174121150832476e-06}, "output": {"final_x": 2.9994033428761813, "final_y": 3.5599972340364345e-07, "iterations": 7}}, {"input": {"x0": -5.253315457022902, "error": 0.00030021917042758503}, "output": {"final_x": 2.986794695268763, "final_y": 0.0001743800730448256, "iterations": 5}}, {"input": {"x0": -9.111672486847215, "error": 0.009442506307741325}, "output": {"final_x": 2.9031066201052225, "final_y": 0.009388327067433679, "iterations": 4}}, {"input": {"x0": -2.5019160441435195, "error": 0.0005055234397830798}, "output": {"final_x": 2.9911969343293703, "final_y": 7.749396520141944e-05, "iterations": 5}}, {"input": {"x0": 2.582233425609976, "error": 1.707911798559525e-05}, "output": {"final_x": 2.99665786740488, "final_y": 1.1169850283364702e-05, "iterations": 4}}, {"input": {"x0": 4.774683367287736, "error": 0.0023315470359910697}, "output": {"final_x": 3.014197466938302, "final_y": 0.00020156806746417948, "iterations": 4}}, {"input": {"x0": 1.5219162351567483, "error": 8.187496274455318e-05}, "output": {"final_x": 2.997635065976251, "final_y": 5.5929129366858415e-06, "iterations": 5}}, {"input": {"x0": -7.848742743941683, "error": 0.000488605174721849}, "output": {"final_x": 2.9826420116096934, "final_y": 0.0003012997609580172, "iterations": 5}}, {"input": {"x0": -0.1496260068382469, "error": 1.5771048304334196e-06}, "output": {"final_x": 2.9989921196778115, "final_y": 1.0158227438547123e-06, "iterations": 6}}, {"input": {"x0": 5.362714135113119, "error": 9.750365286044056e-06}, "output": {"final_x": 3.0007560685232364, "final_y": 5.716396118288666e-07, "iterations": 6}}], "error_log": []}
{"context": "Given a sequence of characters, what are all the possible unique arrangements of these characters?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_list` (str or list): A string or list of characters for which permutations need to be generated. If a string is provided, it will be converted to a list of characters.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input characters.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef permutation(lst):\n    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return [lst]\n    l = []\n    for i in range(len(lst)):\n        m = lst[i]\n        rem_lst = lst[:i] + lst[i+1:]\n        for p in permutation(rem_lst):\n            l.append([m] + p)\n    return l\n\n# main function\ndef main_solution(input_list):\n    # Convert the input list to a list of characters if it's a string\n    if isinstance(input_list, str):\n        input_list = list(input_list)\n    \n    # Get all permutations of the input list\n    permutations = permutation(input_list)\n    \n    # Convert the permutations to a JSON serializable format\n    permutations_serializable = [''.join(p) for p in permutations]\n    \n    return permutations_serializable", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    input_type = random.choice(['str', 'list'])\n    \n    if input_type == 'str':\n        chars = random.choices(string.ascii_letters, k=length)\n        input_list = ''.join(chars)\n    else:\n        input_list = random.sample(range(10), length)\n    \n    return {'input_list': input_list}", "io_pairs": [{"input": {"input_list": "K"}, "output": ["K"]}, {"input": {"input_list": "goK"}, "output": ["goK", "gKo", "ogK", "oKg", "Kgo", "Kog"]}, {"input": {"input_list": "Q"}, "output": ["Q"]}, {"input": {"input_list": "aSr"}, "output": ["aSr", "arS", "Sar", "Sra", "raS", "rSa"]}, {"input": {"input_list": "l"}, "output": ["l"]}, {"input": {"input_list": "YF"}, "output": ["YF", "FY"]}, {"input": {"input_list": "xRw"}, "output": ["xRw", "xwR", "Rxw", "Rwx", "wxR", "wRx"]}, {"input": {"input_list": "o"}, "output": ["o"]}, {"input": {"input_list": "b"}, "output": ["b"]}, {"input": {"input_list": "kdQ"}, "output": ["kdQ", "kQd", "dkQ", "dQk", "Qkd", "Qdk"]}], "error_log": []}
{"context": "Given a square matrix, what is the determinant of the matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of floats): A 2D list representing a square matrix. Each sublist represents a row in the matrix.\n\nOutput:\n  `return` (float): The determinant of the input matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix):\n    # Convert the input matrix to a numpy array\n    matrix = np.array(matrix)\n    \n    # Calculate the determinant of the matrix\n    determinant = np.linalg.det(matrix)\n    \n    # Return the determinant as a float\n    return float(determinant)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.randint(2, 5)\n    matrix = np.random.randint(-10, 10, size=(size, size)).tolist()\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[9, -6], [2, 3]]}, "output": 38.99999999999999}, {"input": {"matrix": [[-5, 2, -7], [0, -2, -8], [4, -10, -8]]}, "output": 199.99999999999991}, {"input": {"matrix": [[0, -8], [3, -4]]}, "output": 23.999999999999993}, {"input": {"matrix": [[7, 8, 5], [3, -3, 8], [-3, -9, 3]]}, "output": -2.999999999999969}, {"input": {"matrix": [[0, -2, -9], [0, 7, -1], [-3, -9, 5]]}, "output": -195.0}, {"input": {"matrix": [[4, 5, 5], [0, 6, 2], [3, -6, 9]]}, "output": 203.99999999999994}, {"input": {"matrix": [[0, -2], [3, 2]]}, "output": 6.0}, {"input": {"matrix": [[8, -6, -9], [6, 7, -7], [8, -3, -1]]}, "output": 742.0}, {"input": {"matrix": [[-7, -2, 6], [-2, -4, 6], [6, -8, -10]]}, "output": -408.0000000000003}, {"input": {"matrix": [[9, 4], [8, -6]]}, "output": -85.99999999999997}], "error_log": []}
{"context": "Given a binary tree, determine whether it is symmetrical. A binary tree is symmetrical if it looks the same when reflected across its central axis. What is the result of checking the symmetry of the given binary tree structure?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (list of int or None): A list representing the structure of the binary tree. Each element in the list corresponds to a node's value, with `None` indicating a missing node. The list is structured such that the index represents the node's position in a level-order traversal of the tree. For example, the root node is at index 0, its left child is at index 1, its right child is at index 2, and so on.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetrical. `True` if the tree is symmetrical, `False` otherwise.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isSymmetrical(self, pRoot):\n        def isSame(p, q):\n            if p == None and q == None: return True\n            if p == None or q == None: return False\n            if p.val != q.val: return False\n            return isSame(p.left, q.right) and isSame(p.right, q.left)\n\n        return isSame(pRoot, pRoot)\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(node_list):\n        if not node_list:\n            return None\n        nodes = [TreeNode(val) if val is not None else None for val in node_list]\n        n = len(nodes)\n        for i in range(n):\n            if nodes[i] is not None:\n                left_index = 2 * i + 1\n                right_index = 2 * i + 2\n                if left_index < n:\n                    nodes[i].left = nodes[left_index]\n                if right_index < n:\n                    nodes[i].right = nodes[right_index]\n        return nodes[0]\n\n    pRoot = build_tree(tree_structure)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution()\n    result = solution.isSymmetrical(pRoot)\n    \n    # Convert the result to a JSON serializable output\n    return result", "input_generator": "import random\nfrom random import choice, randint\n\ndef input_generator():\n    def generate_symmetric_tree(depth):\n        if depth == 0:\n            return [random.randint(1, 100)]\n        left = generate_symmetric_tree(depth - 1)\n        right = left.copy()\n        val = random.randint(1, 100)\n        return [val] + left + right\n    \n    def generate_asymmetric_tree(depth):\n        if depth == 0:\n            return [random.randint(1, 100)]\n        left = generate_asymmetric_tree(depth - 1)\n        right = generate_asymmetric_tree(depth - 1)\n        if random.random() < 0.5:\n            right[-1] = random.randint(1, 100) if right[-1] is not None else None\n        val = random.randint(1, 100)\n        return [val] + left + right\n    \n    if random.random() < 0.5:\n        depth = randint(0, 3)\n        tree = generate_symmetric_tree(depth)\n    else:\n        depth = randint(1, 3)\n        tree = generate_asymmetric_tree(depth)\n    \n    # Randomly replace some nodes with None\n    for i in range(len(tree)):\n        if random.random() < 0.2:\n            tree[i] = None\n    \n    return {'tree_structure': tree}", "io_pairs": [{"input": {"tree_structure": [17, 67, 67]}, "output": true}, {"input": {"tree_structure": [34]}, "output": true}, {"input": {"tree_structure": [43, 48, null, 42, 42, 5, 42, 42, 48, 5, 42, 42, 5, 42, 42]}, "output": false}, {"input": {"tree_structure": [83, 4, 96, 59, null, 66, 5]}, "output": false}, {"input": {"tree_structure": [null]}, "output": true}, {"input": {"tree_structure": [74, 91, 91]}, "output": true}, {"input": {"tree_structure": [62, 72, null, 26, null, 50, null]}, "output": false}, {"input": {"tree_structure": [14, 19, 19]}, "output": true}, {"input": {"tree_structure": [53, 33, 49, null, 34, 96, null]}, "output": false}, {"input": {"tree_structure": [38, null, 58]}, "output": false}], "error_log": []}
{"context": "Given a range of integers, what are the palindromic prime numbers within that range?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start` (int): The starting point of the range within which to search for palindromic primes.\n  `end` (int): The ending point of the range within which to search for palindromic primes.\n\nOutput:\n  `return` (list of str): A list of strings representing the palindromic primes found between the `start` and `end` values.", "reference_code": "# import necessary packages\nimport sys\nsys.setrecursionlimit(30000)\n\n# all class and function definitions in the code file, if any\ndef isprime(n, i):\n    if n == 1:\n        return False\n    if n == 2:\n        return True\n    \n    if i > int(n**0.5)+1:\n        return True\n    if n%i == 0:\n        return False\n    if i == 2:\n        i += 1\n    else:\n        i += 2\n        \n    return isprime(n,i)\n\ndef palincheck(word):\n    if len(word) < 2: return True\n    if word[0] != word[-1]: return False\n    return palincheck(word[1:-1])\n\ndef find_palindromic_primes(start, end):\n    palindromic_primes = []\n    \n    def ispalin(n, e):\n        if n > e:\n            return\n        \n        n_str = str(n)\n        if palincheck(n_str) == True:\n            if isprime(int(n_str), 2) == True:\n                palindromic_primes.append(n_str)\n         \n        ispalin(int(n_str)+1, e)\n    \n    ispalin(start, end)\n    return palindromic_primes\n\n# main function\ndef main_solution(start, end):\n    # Convert inputs to integers\n    start = int(start)\n    end = int(end)\n    \n    # Find palindromic primes in the given range\n    palindromic_primes = find_palindromic_primes(start, end)\n    \n    # Convert the list of palindromic primes to a JSON serializable format\n    return palindromic_primes", "input_generator": "import random\n\ndef input_generator():\n    # Generate a reasonable range for start and end\n    # Palindromic primes are rare, so we need to choose ranges carefully\n    # Common ranges where palindromic primes exist: 2-1000, but sometimes larger\n    \n    # Randomly choose between small, medium, and large ranges\n    choice = random.randint(0, 2)\n    \n    if choice == 0:\n        # Small range with high probability of palindromic primes\n        start = random.randint(2, 100)\n        end = start + random.randint(10, 100)\n    elif choice == 1:\n        # Medium range with some palindromic primes\n        start = random.randint(100, 1000)\n        end = start + random.randint(50, 200)\n    else:\n        # Larger range, fewer palindromic primes\n        start = random.randint(1000, 10000)\n        end = start + random.randint(100, 500)\n    \n    return {'start': str(start), 'end': str(end)}", "io_pairs": [{"input": {"start": "478", "end": "630"}, "output": []}, {"input": {"start": "5780", "end": "6186"}, "output": []}, {"input": {"start": "671", "end": "800"}, "output": ["727", "757", "787", "797"]}, {"input": {"start": "221", "end": "402"}, "output": ["313", "353", "373", "383"]}, {"input": {"start": "503", "end": "584"}, "output": []}, {"input": {"start": "8333", "end": "8440"}, "output": []}, {"input": {"start": "326", "end": "456"}, "output": ["353", "373", "383"]}, {"input": {"start": "1269", "end": "1744"}, "output": []}, {"input": {"start": "3989", "end": "4224"}, "output": []}, {"input": {"start": "64", "end": "158"}, "output": ["101", "131", "151"]}], "error_log": []}
{"context": "Given a string, how can we generate all unique permutations of the string in lexicographical order?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string for which all unique permutations need to be generated.\n\nOutput:\n  `return` (list of str): A list of all unique permutations of the input string, sorted in lexicographical order.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def Permutation(self, ss):\n        if not ss:\n            return []\n         \n        def Permutation(startIdx):\n            if startIdx >= len(arrSs):\n                clone = ''.join(arrSs)\n                res.append(clone)\n            else:\n                changeIdx = startIdx\n                while changeIdx < len(arrSs):\n                    arrSs[changeIdx], arrSs[startIdx] = arrSs[startIdx], arrSs[changeIdx]\n                    Permutation(startIdx + 1)\n                    arrSs[changeIdx], arrSs[startIdx] = arrSs[startIdx], arrSs[changeIdx]\n                    changeIdx += 1\n         \n        res = []\n        arrSs = list(ss)\n        Permutation(0)\n        res = list(set(res))\n        return sorted(res)\n\n# main function\ndef main_solution(input_string):\n  # Convert the input string to a JSON serializable format\n  input_string = str(input_string)\n  \n  # Create an instance of the Solution class\n  solution = Solution()\n  \n  # Call the Permutation method to get the result\n  result = solution.Permutation(input_string)\n  \n  # Convert the result to a JSON serializable format\n  result = list(result)\n  \n  # Return the result\n  return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 6)\n    chars = random.choices(string.ascii_letters, k=length)\n    input_string = ''.join(chars)\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "k"}, "output": ["k"]}, {"input": {"input_string": "Ox"}, "output": ["Ox", "xO"]}, {"input": {"input_string": "Wbs"}, "output": ["Wbs", "Wsb", "bWs", "bsW", "sWb", "sbW"]}, {"input": {"input_string": "rzw"}, "output": ["rwz", "rzw", "wrz", "wzr", "zrw", "zwr"]}, {"input": {"input_string": "O"}, "output": ["O"]}, {"input": {"input_string": "Gh"}, "output": ["Gh", "hG"]}, {"input": {"input_string": "Rb"}, "output": ["Rb", "bR"]}, {"input": {"input_string": "cGH"}, "output": ["GHc", "GcH", "HGc", "HcG", "cGH", "cHG"]}, {"input": {"input_string": "Qmy"}, "output": ["Qmy", "Qym", "mQy", "myQ", "yQm", "ymQ"]}, {"input": {"input_string": "JtFJ"}, "output": ["FJJt", "FJtJ", "FtJJ", "JFJt", "JFtJ", "JJFt", "JJtF", "JtFJ", "JtJF", "tFJJ", "tJFJ", "tJJF"]}], "error_log": []}
{"context": "Given a set of scrabble tiles, what are the valid words that can be formed using all the tiles?\n\nThe input and output requirements are as follows:\n\nInput:\n  `letters` (str): A string of characters representing the tiles or letters to be used to find anagrams.\n\nOutput:\n  `return` (list of str): A list of strings representing the valid words that can be formed from the given letters.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef ana(beg, end):\n    if len(end) == 1:\n        return [beg + end]\n    \n    f = []\n    for i in range(len(end)):\n        f += [beg + end[i]]\n        f += ana(beg + end[i], end[:i] + end[i+1:])\n    return f\n\ndef anagrams(letters):\n    # Mock dictionary for demonstration purposes\n    dictionary = [\"cat\", \"dog\", \"act\", \"god\", \"tac\", \"odg\"]\n    \n    real_words = []\n    words = ana(\"\", letters)\n    \n    for word in words:\n        if len(word) > 1 and (word in dictionary):\n            real_words.append(word)\n    return real_words\n\n# main function\ndef main_solution(letters):\n    # Convert input to string if necessary\n    letters = str(letters)\n    \n    # Call the anagrams function to get the real words\n    real_words = anagrams(letters)\n    \n    # Return the result as a list of strings\n    return real_words", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Define some common letters that can form actual words (from the mock dictionary)\n    common_letters = ['c', 'a', 't', 'd', 'o', 'g']\n    \n    # Randomly decide the length of the input (between 2 and 6 characters)\n    length = random.randint(2, 6)\n    \n    # Randomly decide whether to use common letters or random letters\n    if random.choice([True, False]):\n        letters = random.sample(common_letters, length)\n    else:\n        letters = random.choices(string.ascii_lowercase, k=length)\n    \n    # Join the letters into a string\n    letters_str = ''.join(letters)\n    \n    return {'letters': letters_str}", "io_pairs": [{"input": {"letters": "gaodct"}, "output": ["god", "act", "odg", "dog", "cat", "tac"]}, {"input": {"letters": "vvs"}, "output": []}, {"input": {"letters": "xla"}, "output": []}, {"input": {"letters": "yqeeuj"}, "output": []}, {"input": {"letters": "tc"}, "output": []}, {"input": {"letters": "vler"}, "output": []}, {"input": {"letters": "ruxacu"}, "output": []}, {"input": {"letters": "acgtod"}, "output": ["act", "cat", "god", "tac", "odg", "dog"]}, {"input": {"letters": "tcgoa"}, "output": ["tac", "cat", "act"]}, {"input": {"letters": "cw"}, "output": []}], "error_log": []}
{"context": "In a classroom setting, students are called randomly using a Rolodex system. Given the number of students in the class, what is the expected number of tries required to call each student at least once?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of students in the class. It should be a positive integer.\n\nOutput:\n  `return` (float): The expected number of Rolodex tries to call all students at least once.", "reference_code": "# import necessary packages\nfrom math import factorial\n\n# all class and function definitions in the code file, if any\ndef f(x):\n    return float(x)\n\ndef product(iterable):\n    prod = 1\n    for n in iterable:\n        prod *= n\n    return prod\n\ndef npr(n, r):\n    assert 0 <= r <= n\n    return product(range(n - r + 1, n + 1))\n\ndef ncr(n, r):\n    assert 0 <= r <= n\n    if r > n // 2:\n        r = n - r\n    return npr(n, r) // factorial(r)\n\ndef rolodex(n):\n    inf = int(1e3)\n    so = 0.0\n    for r in range(n, inf):\n        si = 0.0\n        for i in range(n):\n            p1 = f(ncr(n,i))\n            p2 = f((-1)**i)\n            p3 = (1.0 - f((i+1))/f(n))**f((r-1))\n            si += p1*p2*p3\n        so += f(r)*si \n    return so\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = rolodex(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Reasonable range to avoid excessive computation\n    return {'n': n}", "io_pairs": [{"input": {"n": 2}, "output": 2.9999999999999996}, {"input": {"n": 4}, "output": 7.3541666666666625}, {"input": {"n": 7}, "output": 16.64692613196883}, {"input": {"n": 5}, "output": 10.21477777777779}, {"input": {"n": 3}, "output": 4.916666666666667}, {"input": {"n": 10}, "output": 27.453430416984062}, {"input": {"n": 9}, "output": 23.724643043219704}, {"input": {"n": 6}, "output": 13.335339506172836}, {"input": {"n": 1}, "output": 1.0}, {"input": {"n": 8}, "output": 20.117110927521246}], "error_log": []}
{"context": "Given a tree structure where each node contains a string identifier, how can we create an empty tree structure that mimics the original tree's structure and return the contents of the nodes in postorder traversal?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (list of strings): A list representing the structure of the tree. Each string in the list represents the content of a node in the tree. The first element is the root node, and subsequent elements are the children of the root node.\n\nOutput:\n  `return` (list of strings): A list representing the contents of the nodes in the empty tree structure created by the `empty_like` function, in postorder traversal.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    def __init__(self, contents: object = None) -> object:\n        self._parent = None\n        self._children = []\n        self._contents = contents\n\n    @property\n    def contents(self):\n        return self._contents\n\n    @contents.setter\n    def contents(self, value):\n        self._contents = value\n\n    @property\n    def parent(self):\n        return getattr(self, '_parent', None)\n\n    @parent.setter\n    def parent(self, parent):\n        if not isinstance(parent, Node):\n            raise ValueError(\"A parent node must be itself a Node.\")\n        parent.add_child(self)\n\n    @property\n    def children(self):\n        return self._children\n\n    def add_child(self, child) -> None:\n        if not isinstance(child, Node):\n            raise ValueError(\"A child must be itself a Node.\")\n        descendents = [person for person in PostorderTree(self)][:-1]\n        if self in descendents:\n            raise ValueError(\"A child cannot be in its own line of descent.\")\n        for sibling in self._children:\n            if sibling is child:\n                return\n        child._parent = self\n        self._children.append(child)\n\n    def remove_child(self, orphan) -> None:\n        for i in reversed(range(len(self.children))):\n            if self._children[i] is orphan:\n                del self._children[i]\n\nclass BinaryNode(Node):\n    def __init__(self, contents=None):\n        super().__init__(contents=contents)\n        self._children = [None, None]\n\n    @property\n    def left(self):\n        return self._children[0]\n\n    @left.setter\n    def left(self, child):\n        if child is self._children[0]:\n            return\n        del self._children[0]\n        super().add_child(child)\n        self._children = list(reversed(self._children))\n\n    @property\n    def right(self):\n        return self._children[1]\n\n    @right.setter\n    def right(self, child):\n        if child is self._children[1]:\n            return\n        del self._children[1]\n        super().add_child(child)\n\n    def add_child(self, child):\n        raise NotImplementedError(\"Binary nodes have a fixed number of child nodes\")\n\n    def remove_child(self, orphan):\n        if orphan is self.left:\n            del self._children[0]\n            self._children[0] = None\n        elif orphan is self.right:\n            del self._children[1]\n            self._children[1] = None\n\nclass Tree(object):\n    def __init__(self, root=None):\n        self.root = root\n\n    @property\n    def root(self):\n        return getattr(self, '_root', None)\n\n    @root.setter\n    def root(self, root):\n        if not isinstance(root, Node):\n            contents = root\n            self._root = Node(contents)\n        else:\n            self._root = root\n\nclass PostorderTree(Tree):\n    def __init__(self, root=None):\n        super().__init__(root)\n\n    def __iter__(self):\n        for child in self.root._children:\n            for nextgen in PostorderTree(child):\n                yield nextgen\n        yield self.root\n\nLRNTree = PostorderTree\n\ndef empty_like(root, basetype=None):\n    if basetype is None:\n        basetype = type(root)\n    top = basetype()\n    for child in root.children:\n        top.add_child(empty_like(child, basetype))\n    return top\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    root = Node(tree_structure[0])\n    for child in tree_structure[1:]:\n        root.add_child(Node(child))\n    \n    # Create an empty tree structure like the input tree\n    empty_tree = empty_like(root)\n    \n    # Convert the output to JSON serializable format\n    result = []\n    for node in PostorderTree(empty_tree):\n        result.append(node.contents)\n    \n    return result", "input_generator": "import random\nfrom random import randint\n\ndef input_generator():\n    def generate_tree(depth):\n        if depth == 0:\n            return [random.choice(['A', 'B', 'C', 'D', 'E'])]\n        tree = [random.choice(['X', 'Y', 'Z', 'W'])]\n        num_children = randint(1, 3)\n        for _ in range(num_children):\n            tree.append(generate_tree(depth - 1))\n        return tree\n    \n    depth = randint(1, 4)\n    tree_structure = generate_tree(depth)\n    return {'tree_structure': tree_structure}", "io_pairs": [{"input": {"tree_structure": ["Z", ["B"], ["C"], ["C"]]}, "output": [null, null, null, null]}, {"input": {"tree_structure": ["X", ["X", ["B"]]]}, "output": [null, null]}, {"input": {"tree_structure": ["Z", ["E"], ["A"]]}, "output": [null, null, null]}, {"input": {"tree_structure": ["Z", ["D"]]}, "output": [null, null]}, {"input": {"tree_structure": ["Z", ["E"]]}, "output": [null, null]}, {"input": {"tree_structure": ["W", ["E"], ["D"]]}, "output": [null, null, null]}, {"input": {"tree_structure": ["Y", ["A"]]}, "output": [null, null]}, {"input": {"tree_structure": ["W", ["X", ["D"]], ["Z", ["D"]]]}, "output": [null, null, null]}, {"input": {"tree_structure": ["Z", ["Z", ["E"]]]}, "output": [null, null]}, {"input": {"tree_structure": ["Y", ["C"], ["C"], ["B"]]}, "output": [null, null, null, null]}], "error_log": []}
{"context": "Given a building with `n` floors and two eggs, determine the minimum number of tests required to find the highest floor from which an egg can be dropped without breaking. The eggs can be reused if they do not break, but if an egg breaks, it cannot be used again. What is the minimum number of tests needed to find the threshold floor?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of floors in the building.\n\nOutput:\n  `return` (int): The minimum number of tests required to determine the highest floor from which an egg can be dropped without breaking.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    # @param {int} n an integer\n    # @return {int} an integer\n    def dropEggs(self, n):\n        s = int(math.sqrt(2 * n))\n        while s * (s + 1) < n:\n            s += 1\n        return s\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.dropEggs(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(1, 1000000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 44913}, "output": 299}, {"input": {"n": 787839}, "output": 1255}, {"input": {"n": 567902}, "output": 1065}, {"input": {"n": 295564}, "output": 768}, {"input": {"n": 666086}, "output": 1154}, {"input": {"n": 928794}, "output": 1362}, {"input": {"n": 25549}, "output": 226}, {"input": {"n": 893012}, "output": 1336}, {"input": {"n": 277936}, "output": 745}, {"input": {"n": 5079}, "output": 100}], "error_log": []}
{"context": "In a game of Connect4, how do the rewards for each player accumulate based on a sequence of moves on a custom-sized board with multiple players?\n\nThe input and output requirements are as follows:\n\nInput:\n- `rows` (int): Number of rows in the Connect4 board.\n- `cols` (int): Number of columns in the Connect4 board.\n- `players` (int): Number of players in the game.\n- `player_tokens` (list of str): List of tokens representing each player.\n- `moves` (list of int): List of column indices where players make their moves.\n\nOutput:\n- `return` (dict): Dictionary where keys are player indices (0-based) and values are the cumulative rewards for each player.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Board:\n    def __init__(self, rows=6, cols=7, players=2):\n        self.board = np.zeros((rows, cols)).astype(int)\n        self.rows = self.board.shape[0]\n        self.cols = self.board.shape[1]\n        self.in_play = np.ones(cols).astype(int) * (self.rows - 1)\n\n    def get_board(self):\n        return self.board\n\n    def make_move(self, drop_column, player):\n        if not self.is_full(drop_column):\n            row = self.in_play[drop_column]\n            self.board[row, drop_column] = player\n            self.in_play[drop_column] -= 1\n\n    def is_full(self, drop_column):\n        return self.in_play[drop_column] < 0\n\n\nclass Connect4:\n    def __init__(self, rows=6, cols=7, players=2, player_tokens=[\"O\", \"X\"], l_reward=-1, verbose=False):\n        self.board = Board(rows=rows, cols=cols, players=players)\n        self.player_tokens = player_tokens\n        self.players = players\n        self.player_list = np.arange(players) + 1\n        self.active_player = 1\n        self.living_reward = l_reward\n        self.iteration = 0\n        self.ply = 0\n        self.verbose = verbose\n        self.invalid_move_penalty = -100\n        self.win_reward = 100\n        self.lose_reward = -100\n\n    def step(self, action):\n        self.board.make_move(action, self.active_player)\n        new_state = self.board.get_board()\n        is_done = self.check_for_win(new_state)\n        if self.check_for_draw(self.board):\n            return self.get_draw()\n\n        self.next_turn()\n        reward = self.get_reward(new_state, is_done)\n        extra_stuff = {\"turn\": self.ply, \"iteration\": self.iteration}\n        if self.board.is_full(action):\n            reward = self.invalid_move_penalty\n            extra_stuff.update({\"Error\": \"Invalid Move\"})\n        return new_state, reward, is_done, extra_stuff\n\n    def get_reward(self, new_state, done):\n        rewards = {p: 0 for p in range(self.players)}\n        if done:\n            for p in range(self.players):\n                rewards[p] = self.lose_reward\n            rewards[self.active_player - 1] = self.win_reward\n        else:\n            rewards[self.active_player - 1] = self.living_reward\n        return rewards\n\n    def get_draw(self):\n        rewards = {p: 0 for p in range(self.players)}\n        done = True\n        new_state = self.board.get_board()\n        extra_stuff = {\n            \"turn\": self.ply,\n            \"iteration\": self.iteration,\n            \"error\": \"Board is full. It's a draw\"\n        }\n        return new_state, rewards, done, extra_stuff\n\n    def next_turn(self):\n        self.active_player = self.player_list[(self.active_player - 1) % self.players]\n        self.iteration += 1\n        self.ply = self.iteration / self.players\n\n    def check_for_draw(self, board):\n        for column in range(board.cols):\n            if not board.is_full(column):\n                return False\n        return True\n\n    def check_for_win(self, board):\n        # Check for horizontal win\n        for i in range(self.board.rows):\n            hcount = 0\n            for j in range(self.board.cols):\n                if board[i, j] == self.active_player:\n                    hcount += 1\n                else:\n                    hcount = 0\n                if hcount >= 4:\n                    return True\n\n        # Check for vertical win\n        for j in range(self.board.cols):\n            vcount = 0\n            for i in range(self.board.rows):\n                if board[i, j] == self.active_player:\n                    vcount += 1\n                else:\n                    vcount = 0\n                if vcount >= 4:\n                    return True\n\n        # Diagonal Check\n        for i in range(self.board.rows - 3):\n            for j in range(self.board.cols - 3):\n                if (board[i, j] == self.active_player and\n                        board[i + 1, j + 1] == self.active_player and\n                        board[i + 2, j + 2] == self.active_player and\n                        board[i + 3, j + 3] == self.active_player):\n                    return True\n                if (board[i, j] == self.active_player and\n                        board[i - 1, j - 1] == self.active_player and\n                        board[i - 2, j - 2] == self.active_player and\n                        board[i - 3, j - 3] == self.active_player):\n                    return True\n        return False\n\n# main function\ndef main_solution(rows, cols, players, player_tokens, moves):\n    game = Connect4(rows=rows, cols=cols, players=players, player_tokens=player_tokens)\n    rewards = {p: 0 for p in range(players)}\n    done = False\n    for move in moves:\n        if not done:\n            _, step_rewards, done, _ = game.step(move)\n            for p in range(players):\n                rewards[p] += step_rewards[p]\n    return rewards", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    rows = random.choice([6, 7, 8])\n    cols = random.choice([7, 8, 9])\n    players = random.randint(2, 4)\n    player_tokens = random.sample(['O', 'X', 'Y', 'Z', 'A', 'B'], players)\n    num_moves = random.randint(5, 20)\n    moves = [random.randint(0, cols - 1) for _ in range(num_moves)]\n    \n    return {\n        'rows': rows,\n        'cols': cols,\n        'players': players,\n        'player_tokens': player_tokens,\n        'moves': moves\n    }", "io_pairs": [{"input": {"rows": 6, "cols": 7, "players": 2, "player_tokens": ["B", "Y"], "moves": [4, 4, 5, 5, 5]}, "output": {"0": -5, "1": 0}}, {"input": {"rows": 7, "cols": 7, "players": 3, "player_tokens": ["Y", "X", "O"], "moves": [6, 1, 0, 6, 3]}, "output": {"0": -5, "1": 0, "2": 0}}, {"input": {"rows": 7, "cols": 7, "players": 2, "player_tokens": ["X", "A"], "moves": [6, 1, 5, 1, 5, 5, 6, 2, 2]}, "output": {"0": -9, "1": 0}}, {"input": {"rows": 7, "cols": 7, "players": 2, "player_tokens": ["O", "A"], "moves": [5, 1, 6, 1, 1, 2, 1, 5, 5]}, "output": {"0": 94, "1": -100}}, {"input": {"rows": 7, "cols": 7, "players": 2, "player_tokens": ["X", "O"], "moves": [6, 0, 3, 4, 2, 6]}, "output": {"0": -6, "1": 0}}, {"input": {"rows": 8, "cols": 9, "players": 2, "player_tokens": ["A", "Y"], "moves": [4, 0, 8, 2, 2, 3]}, "output": {"0": -6, "1": 0}}, {"input": {"rows": 7, "cols": 7, "players": 2, "player_tokens": ["O", "A"], "moves": [1, 4, 6, 5, 2, 4]}, "output": {"0": -6, "1": 0}}, {"input": {"rows": 8, "cols": 8, "players": 2, "player_tokens": ["B", "Y"], "moves": [3, 7, 5, 4, 0, 4, 5, 3]}, "output": {"0": -8, "1": 0}}, {"input": {"rows": 8, "cols": 7, "players": 2, "player_tokens": ["Z", "X"], "moves": [2, 5, 2, 1, 5, 3, 1]}, "output": {"0": -7, "1": 0}}, {"input": {"rows": 7, "cols": 9, "players": 2, "player_tokens": ["B", "O"], "moves": [4, 8, 0, 3, 3]}, "output": {"0": -5, "1": 0}}], "error_log": []}
{"context": "Given a map of a terrain represented by a grid of cells, each cell has a specific height. Water flows from higher cells to lower cells following the rules of gravity. The goal is to determine the drainage basins formed by the water flow. Each drainage basin is labeled with a unique letter from 'a' to 'z'. What is the labeling of the drainage basins for the given map?\n\nThe input and output requirements are as follows:\n\nInput:\n  `size` (list of int): A list containing two integers representing the dimensions of the map. `size[0]` is the number of rows and `size[1]` is the number of columns.\n  `heights` (list of list of int): A 2D list representing the height of each cell in the map. The dimensions of this list should match the dimensions specified in `size`.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents a row of the map after processing. Each character in the string represents the drainage basin label for that cell.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef get_map(size, heights):\n    map = []\n    for jj in range(size[0]):\n        map.append([])\n        for kk in range(size[1]):\n            map[jj].append([heights[jj][kk], False, ' '])\n    return map\n\ndef process_loc(next_x, next_y, map, processed, next_sink):\n    if map[next_x][next_y][1] == True:\n        for (x, y) in processed:\n            map[x][y] = [map[x][y][0], True, map[next_x][next_y][2]]\n        return\n\n    processed.append((next_x, next_y))\n\n    curr_height = map[next_x][next_y][0]\n    low_x = -1\n    low_y = -1\n    if next_x > 0 and processed.count((next_x-1, next_y)) == 0:\n        if map[next_x-1][next_y][0] < curr_height:\n            curr_height = map[next_x-1][next_y][0]\n            low_x = next_x - 1\n            low_y = next_y\n    if next_y > 0 and processed.count((next_x, next_y-1)) == 0:\n        if map[next_x][next_y-1][0] < curr_height:\n            curr_height = map[next_x][next_y-1][0]\n            low_x = next_x\n            low_y = next_y - 1\n    if next_y < len(map[0])-1 and processed.count((next_x, next_y+1)) == 0:\n        if map[next_x][next_y+1][0] < curr_height:\n            curr_height = map[next_x][next_y+1][0]\n            low_x = next_x\n            low_y = next_y + 1\n    if next_x < len(map)-1 and processed.count((next_x+1, next_y)) == 0:\n        if map[next_x+1][next_y][0] < curr_height:\n            curr_height = map[next_x+1][next_y][0]\n            low_x = next_x + 1\n            low_y = next_y\n\n    if low_x < 0:\n        for (x, y) in processed:\n            map[x][y] = [map[x][y][0], True, next_sink[0][next_sink[1]]]\n        next_sink[1] = next_sink[1] + 1\n    else:\n        process_loc(low_x, low_y, map, processed, next_sink)\n\ndef process_map(map):\n    next_x = 0\n    next_y = 0\n    sink_names = [\"abcdefghijklmnopqrstuvwxyz\", 0]\n\n    while next_x < len(map) and next_y < len(map[0]):\n        process_loc(next_x, next_y, map, [], sink_names)\n        next_y = next_y + 1\n        if next_y >= len(map[0]):\n            next_x = next_x + 1\n            next_y = 0\n\n    result = []\n    for ii in range(len(map)):\n        result.append(''.join([map[ii][jj][2] for jj in range(len(map[ii]))]))\n    return result\n\n# main function\ndef main_solution(size, heights):\n    map = get_map(size, heights)\n    result = process_map(map)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(1, 10)\n    cols = random.randint(1, 10)\n    size = (rows, cols)\n    heights = []\n    for _ in range(rows):\n        row = [random.randint(1, 100) for _ in range(cols)]\n        heights.append(row)\n    return {'size': size, 'heights': heights}", "io_pairs": [{"input": {"size": [1, 5], "heights": [[1, 44, 31, 88, 25]]}, "output": ["aabcc"]}, {"input": {"size": [1, 1], "heights": [[33]]}, "output": ["a"]}, {"input": {"size": [1, 5], "heights": [[85, 74, 67, 79, 37]]}, "output": ["aaabb"]}, {"input": {"size": [3, 2], "heights": [[18, 52], [12, 16], [88, 45]]}, "output": ["aa", "aa", "aa"]}, {"input": {"size": [1, 3], "heights": [[63, 53, 67]]}, "output": ["aaa"]}, {"input": {"size": [1, 4], "heights": [[6, 39, 11, 81]]}, "output": ["aabb"]}, {"input": {"size": [2, 3], "heights": [[45, 61, 23], [98, 96, 44]]}, "output": ["abb", "abb"]}, {"input": {"size": [2, 1], "heights": [[31], [17]]}, "output": ["a", "a"]}, {"input": {"size": [1, 7], "heights": [[43, 92, 31, 49, 48, 44, 27]]}, "output": ["abbbccc"]}, {"input": {"size": [3, 1], "heights": [[38], [76], [7]]}, "output": ["a", "b", "b"]}], "error_log": []}
{"context": "Given a maze represented by a grid of cells where `0` indicates an open path and `1` indicates a wall, how can we determine if there is a path from the top row to the bottom row? The maze is provided in a specific string format where each row is a comma-separated list of integers and rows are separated by semicolons. What is the resulting maze and the solution status after attempting to solve it using a Breadth-First Search algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `maze` (str): A string representation of the maze where each row is a comma-separated list of integers (0 for open path, 1 for wall) and rows are separated by semicolons.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `solved_maze` (str): The string representation of the maze after attempting to solve it.\n    - `solved` (bool): A boolean indicating whether the maze was successfully solved (True) or not (False).", "reference_code": "# import necessary packages\nimport queue\nimport random\n\n# all class and function definitions in the code file, if any\nclass TwoDMazeSolver:\n\n    def __init__(self, maze):\n        self.maze = maze\n\n    @staticmethod\n    def find_start(maze):\n        for i in range(len(maze[0])):\n            if maze[0][i] == 0:\n                return 0, i\n        return -1, -1\n\n    @staticmethod\n    def check_bounds(row, col, maze):\n        if row < 0 or col < 0 or row >= len(maze) or col >= len(maze[0]):\n            return False\n        if maze[row][col] == 1 or maze[row][col] == 2:\n            return False\n        return True\n\n    @staticmethod\n    def get_surrounding(row, col):\n        res = []\n        for x, y in ((0, 1), (1, 0), (-1, 0), (0, -1)):\n            res.append((row + x, col + y))\n        return res\n\n    @staticmethod\n    def get_valid_moves(row, col, maze):\n        if maze[row][col] == 1:\n            return []\n        surr = TwoDMazeSolver.get_surrounding(row, col)\n        valid = [(x, y) for x, y in surr if TwoDMazeSolver.check_bounds(x, y, maze)]\n        return valid\n\ndef bfs_solve(maze):\n    row, col = TwoDMazeSolver.find_start(maze)\n    q = queue.Queue()\n    q.put((row, col))\n    while not q.empty():\n        r, c = q.get()\n        maze[r][c] = 2\n        if r == len(maze) - 1:\n            return True\n        surr = TwoDMazeSolver.get_surrounding(r, c)\n        for nr, nc in surr:\n            if TwoDMazeSolver.check_bounds(nr, nc, maze):\n                q.put((nr, nc))\n    return False\n\n# main function\ndef main_solution(maze):\n    # Convert the maze to a list of lists if it's not already\n    if isinstance(maze, str):\n        maze = [list(map(int, row.split(','))) for row in maze.split(';')]\n    \n    # Solve the maze using BFS\n    solved = bfs_solve(maze)\n    \n    # Convert the maze back to a string representation\n    maze_str = ';'.join(','.join(map(str, row)) for row in maze)\n    \n    # Return the solved maze and the result of the solution\n    return {\"solved_maze\": maze_str, \"solved\": solved}", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(5, 10)\n    cols = random.randint(5, 10)\n    maze = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n    # Set start point (top row, random column)\n    start_col = random.randint(0, cols - 1)\n    maze[0][start_col] = 0\n    \n    # Set end point (bottom row, random column)\n    end_col = random.randint(0, cols - 1)\n    maze[-1][end_col] = 0\n    \n    # Add some walls (1s)\n    for _ in range(random.randint(5, 15)):\n        row = random.randint(0, rows - 1)\n        col = random.randint(0, cols - 1)\n        if (row == 0 and col == start_col) or (row == rows - 1 and col == end_col):\n            continue\n        maze[row][col] = 1\n    \n    # Convert maze to string representation\n    maze_str = ';'.join(','.join(map(str, row)) for row in maze)\n    \n    return {\"maze\": maze_str}", "io_pairs": [{"input": {"maze": "0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0;1,1,0,0,0,1,0,0;0,0,0,0,0,0,0,0;0,0,1,0,0,1,1,0;0,0,0,0,0,0,0,1"}, "output": {"solved_maze": "2,2,2,2,2,2,2,2;2,2,2,2,2,2,2,2;1,1,2,2,2,1,2,0;2,2,2,2,2,2,0,0;0,2,1,2,2,1,1,0;0,0,0,2,0,0,0,1", "solved": true}}, {"input": {"maze": "0,0,0,0,0,0,0,1,0;0,1,0,1,0,0,0,0,0;0,0,0,0,1,0,0,0,0;0,0,0,0,0,1,0,0,0;1,0,0,0,0,0,0,1,0"}, "output": {"solved_maze": "2,2,2,2,2,2,0,1,0;2,1,2,1,2,0,0,0,0;2,2,2,2,1,0,0,0,0;2,2,2,0,0,1,0,0,0;1,2,0,0,0,0,0,1,0", "solved": true}}, {"input": {"maze": "1,0,0,0,0,0,0;0,0,0,0,0,0,0;0,0,0,0,1,0,0;0,0,1,0,1,1,0;0,0,0,0,0,1,1;0,1,0,0,0,0,0"}, "output": {"solved_maze": "1,2,2,2,2,2,2;2,2,2,2,2,2,2;2,2,2,2,1,2,0;2,2,1,2,1,1,0;2,2,2,2,0,1,1;0,1,2,0,0,0,0", "solved": true}}, {"input": {"maze": "0,1,0,0,0,0;0,0,0,0,1,0;1,0,0,0,0,0;0,0,0,0,0,1;0,1,0,1,0,1;0,0,0,0,0,0;1,1,0,0,0,1;1,0,0,0,0,0"}, "output": {"solved_maze": "2,1,2,2,2,2;2,2,2,2,1,2;1,2,2,2,2,2;2,2,2,2,2,1;2,1,2,1,2,1;2,2,2,2,2,0;1,1,2,2,0,1;1,0,2,0,0,0", "solved": true}}, {"input": {"maze": "0,0,0,0,0,0;0,0,1,0,0,1;0,0,0,1,0,1;0,1,1,1,0,0;0,0,1,0,0,0"}, "output": {"solved_maze": "2,2,2,2,2,0;2,2,1,2,0,1;2,2,2,1,0,1;2,1,1,1,0,0;2,0,1,0,0,0", "solved": true}}, {"input": {"maze": "0,0,0,1,0,0,0;0,0,1,0,1,0,1;0,0,1,0,1,0,0;1,0,0,0,1,0,0;0,0,0,0,0,0,0;0,0,0,0,0,0,0;0,0,0,0,1,0,1"}, "output": {"solved_maze": "2,2,2,1,0,0,0;2,2,1,0,1,0,1;2,2,1,2,1,0,0;1,2,2,2,1,0,0;2,2,2,2,0,0,0;0,2,2,0,0,0,0;0,2,0,0,1,0,1", "solved": true}}, {"input": {"maze": "0,0,0,0,0;0,0,0,0,0;0,0,1,0,0;0,0,1,1,0;0,1,0,0,0;0,1,0,0,1;0,0,0,1,0"}, "output": {"solved_maze": "2,2,2,2,2;2,2,2,2,2;2,2,1,2,2;2,2,1,1,0;2,1,0,0,0;2,1,0,0,1;2,0,0,1,0", "solved": true}}, {"input": {"maze": "0,1,0,1,1;0,0,1,0,0;0,0,0,0,1;0,0,1,0,0;0,0,0,0,1"}, "output": {"solved_maze": "2,1,0,1,1;2,2,1,0,0;2,2,2,0,1;2,2,1,0,0;2,0,0,0,1", "solved": true}}, {"input": {"maze": "0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0;0,0,0,0,0,0,1,0;0,0,1,0,0,0,0,0;0,0,0,0,0,0,0,1;1,0,1,0,0,0,1,0"}, "output": {"solved_maze": "2,2,2,2,2,2,2,0;2,2,2,2,2,2,0,0;2,2,2,2,2,0,1,0;2,2,1,2,0,0,0,0;2,2,2,0,0,0,0,1;1,2,1,0,0,0,1,0", "solved": true}}, {"input": {"maze": "1,1,0,0,0,0,0;0,0,0,0,0,0,0;0,0,0,1,0,0,0;0,1,1,0,1,0,0;0,0,0,1,0,1,0"}, "output": {"solved_maze": "1,1,2,2,2,2,2;2,2,2,2,2,2,2;2,2,2,1,2,2,2;2,1,1,0,1,2,0;2,0,0,1,0,1,0", "solved": true}}], "error_log": []}
{"context": "Given a binary tree, determine if it is symmetrical. A binary tree is symmetrical if it looks the same when reflected across its center. What is the symmetry status of the given binary tree?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (str): A JSON string representing the structure of the binary tree. Each node is represented by an integer or `null` for a non-existent node. The tree is serialized in a level-order traversal format.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetrical. `True` if the tree is symmetrical, `False` otherwise.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isSymmetrical(self, pRoot):\n        if not pRoot:\n            return True\n        return self.isMirror(pRoot.left, pRoot.right)\n\n    def isMirror(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        if left.val != right.val:\n            return False\n        outside = self.isMirror(left.left, right.right)\n        inside = self.isMirror(left.right, right.left)\n        return outside and inside\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            node = queue.pop(0)\n            if nodes[i] is not None:\n                node.left = TreeNode(nodes[i])\n                queue.append(node.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                node.right = TreeNode(nodes[i])\n                queue.append(node.right)\n            i += 1\n        return root\n\n    tree_structure = json.loads(tree_structure)\n    root = build_tree(tree_structure)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution()\n    result = solution.isSymmetrical(root)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import json\nimport random\n\ndef input_generator():\n    def generate_symmetric_tree(depth):\n        if depth == 0:\n            return []\n        val = random.randint(1, 100)\n        tree = [val]\n        current_level = [tree]\n        for _ in range(depth - 1):\n            next_level = []\n            for node in current_level:\n                left_val = random.randint(1, 100) if random.random() > 0.2 else None\n                right_val = left_val if left_val is not None and random.random() > 0.2 else (random.randint(1, 100) if random.random() > 0.2 else None\n                node.append(left_val)\n                node.append(right_val)\n                if left_val is not None:\n                    next_level.append([left_val])\n                if right_val is not None:\n                    next_level.append([right_val])\n            current_level = next_level\n        # Flatten the tree\n        flattened = []\n        queue = [tree]\n        while queue:\n            current = queue.pop(0)\n            flattened.append(current[0])\n            if len(current) > 1:\n                queue.append(current[1] if current[1] is not None else [None])\n            if len(current) > 2:\n                queue.append(current[2] if current[2] is not None else [None])\n        return flattened\n\n    def generate_random_tree(depth):\n        if depth == 0:\n            return []\n        val = random.randint(1, 100)\n        tree = [val]\n        current_level = [tree]\n        for _ in range(depth - 1):\n            next_level = []\n            for node in current_level:\n                left_val = random.randint(1, 100) if random.random() > 0.5 else None\n                right_val = random.randint(1, 100) if random.random() > 0.5 else None\n                node.append(left_val)\n                node.append(right_val)\n                if left_val is not None:\n                    next_level.append([left_val])\n                if right_val is not None:\n                    next_level.append([right_val])\n            current_level = next_level\n        # Flatten the tree\n        flattened = []\n        queue = [tree]\n        while queue:\n            current = queue.pop(0)\n            flattened.append(current[0])\n            if len(current) > 1:\n                queue.append(current[1] if current[1] is not None else [None])\n            if len(current) > 2:\n                queue.append(current[2] if current[2] is not None else [None])\n        return flattened\n\n    if random.random() > 0.5:\n        depth = random.randint(1, 4)\n        tree_structure = generate_symmetric_tree(depth)\n    else:\n        depth = random.randint(1, 4)\n        tree_structure = generate_random_tree(depth)\n    \n    return {'tree_structure': json.dumps(tree_structure)}", "io_pairs": [], "error_log": ["STDERR:   File \"<string>\", line 56\n    right_val = left_val if left_val is not None and random.random() > 0.2 else (random.randint(1, 100) if random.random() > 0.2 else None\n                                                                                ^\nSyntaxError: '(' was never closed\n"]}
{"context": "Given a number, how can we estimate its square root using the gradient descent algorithm, and what is the difference between this estimated value and the true square root calculated using a standard mathematical function?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num` (float): The number for which the square root is to be calculated.\n  `learning_rate` (float): The learning rate for the gradient descent algorithm. Default is 0.01.\n  `iterations` (int): The number of iterations for the gradient descent algorithm. Default is 1000.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `estimated_sqrt` (float): The estimated square root of the input number using the gradient descent algorithm.\n    - `true_sqrt` (float): The true square root of the input number calculated using the `math.sqrt` function.", "reference_code": "# import necessary packages\nimport math\nimport numpy as np\n\n# main function\ndef main_solution(num, learning_rate=0.01, iterations=1000):\n    # Convert JSON serializable inputs to original input variables\n    num = float(num)\n    learning_rate = float(learning_rate)\n    iterations = int(iterations)\n\n    # Gradient Descent Algorithm to calculate square root\n    cur = 0.0\n    for _ in range(iterations):\n        cur -= learning_rate * (cur**2 - num)\n\n    # Convert the result to JSON serializable output\n    return {\"estimated_sqrt\": cur, \"true_sqrt\": math.sqrt(num)}", "input_generator": "import random\n\ndef input_generator():\n    num = random.uniform(0.1, 1000.0)\n    learning_rate = random.choice([0.001, 0.01, 0.1, 0.05])\n    iterations = random.randint(100, 10000)\n    return {\n        \"num\": num,\n        \"learning_rate\": learning_rate,\n        \"iterations\": iterations\n    }", "io_pairs": [{"input": {"num": 211.46963909588294, "learning_rate": 0.001, "iterations": 7242}, "output": {"estimated_sqrt": 14.541995705400344, "true_sqrt": 14.541995705400375}}, {"input": {"num": 20.686683729916453, "learning_rate": 0.1, "iterations": 5957}, "output": {"estimated_sqrt": 4.548261616256968, "true_sqrt": 4.548261616256969}}, {"input": {"num": 571.3833686579435, "learning_rate": 0.01, "iterations": 5936}, "output": {"estimated_sqrt": 23.903626684207218, "true_sqrt": 23.90362668420722}}, {"input": {"num": 547.7125306927253, "learning_rate": 0.01, "iterations": 4166}, "output": {"estimated_sqrt": 23.40325897589319, "true_sqrt": 23.40325897589319}}, {"input": {"num": 625.4544722546397, "learning_rate": 0.001, "iterations": 8811}, "output": {"estimated_sqrt": 25.009087793333006, "true_sqrt": 25.00908779333304}}, {"input": {"num": 527.9119502165333, "learning_rate": 0.05, "iterations": 9870}, "output": {"estimated_sqrt": 8.690183457874596, "true_sqrt": 22.976334568780402}}, {"input": {"num": 567.0159998788863, "learning_rate": 0.001, "iterations": 3925}, "output": {"estimated_sqrt": 23.812097763088506, "true_sqrt": 23.81209776308854}}, {"input": {"num": 30.65353530225053, "learning_rate": 0.1, "iterations": 2492}, "output": {"estimated_sqrt": 5.536563492117699, "true_sqrt": 5.536563492117699}}, {"input": {"num": 219.5505113089624, "learning_rate": 0.01, "iterations": 2556}, "output": {"estimated_sqrt": 14.81723696607982, "true_sqrt": 14.817236966079824}}, {"input": {"num": 709.4103963994854, "learning_rate": 0.001, "iterations": 9829}, "output": {"estimated_sqrt": 26.6347591766752, "true_sqrt": 26.63475917667523}}], "error_log": []}
{"context": "Given a set of points on a 2D plane, how many isosceles triangles can be formed from these points? An isosceles triangle has two sides of equal length, and vertices can be shared by multiple triangles.\n\nThe input and output requirements are as follows:\n\nInput:\n  `points` (list of tuples): A list of (x, y) coordinates, where each tuple represents a point in a 2D plane. Each tuple contains two integers.\n\nOutput:\n  `return` (int): The number of isosceles triangles that can be formed from the given list of points.", "reference_code": "# import necessary packages\nfrom itertools import combinations\nimport random\n\n# main function\ndef main_solution(points):\n    \"\"\"\n    Determines the number of isosceles triangles that can be formed from a given list of (x, y) coordinates.\n    \n    Parameters:\n    points (list of tuples): A list of (x, y) coordinates.\n    \n    Returns:\n    int: The number of isosceles triangles that can be formed.\n    \"\"\"\n    triangles = 0\n    for (x1, y1), (x2, y2), (x3, y3) in combinations(points, 3):\n        a = round(((x1-x2)**2 + (y1-y2)**2)**0.5, 2)\n        b = round(((x1-x3)**2 + (y1-y3)**2)**0.5, 2)\n        c = round(((x2-x3)**2 + (y2-y3)**2)**0.5, 2)\n        collinear = 0.5 * (x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) == 0\n        if (a == b or b == c or a == c) and not collinear:\n            triangles += 1\n    return triangles", "input_generator": "import random\n\ndef input_generator():\n    num_points = random.randint(3, 10)  # Generate between 3 and 10 points\n    points = []\n    for _ in range(num_points):\n        x = random.randint(-10, 10)\n        y = random.randint(-10, 10)\n        points.append((x, y))\n    return {'points': points}", "io_pairs": [{"input": {"points": [[-4, 10], [-3, 8], [4, 8], [3, 0]]}, "output": 0}, {"input": {"points": [[8, -1], [5, -2], [-10, -3]]}, "output": 0}, {"input": {"points": [[10, 10], [5, 2], [0, -10], [8, 3], [2, -8], [8, 10], [8, 3]]}, "output": 0}, {"input": {"points": [[-3, -9], [0, 1], [-7, 6], [4, -8]]}, "output": 0}, {"input": {"points": [[-7, -5], [-10, -1], [7, 5]]}, "output": 0}, {"input": {"points": [[3, 8], [-8, -8], [-4, 9]]}, "output": 0}, {"input": {"points": [[6, 0], [5, 3], [-9, 5], [-9, -5], [1, 0], [0, -8]]}, "output": 4}, {"input": {"points": [[-1, 10], [6, -5], [5, -2], [-4, 10], [1, -8], [4, -1]]}, "output": 0}, {"input": {"points": [[9, -5], [-8, 9], [-7, -8], [2, 2], [2, 4]]}, "output": 0}, {"input": {"points": [[9, 5], [-3, 0], [-8, 3], [5, -4], [10, 0], [-4, -2]]}, "output": 1}], "error_log": []}
{"context": "Given a list of integers, can you determine if there exists a permutation of these integers such that by applying a series of addition, subtraction, or multiplication operations, the result can be exactly 42?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numbers` (list of strings): A list of strings representing integers. Each string should be a valid integer.\n\nOutput:\n  `return` (string): A string that is either \"YES\" or \"NO\". \"YES\" indicates that there exists a permutation of the input numbers that can be manipulated to reach the number 42, and \"NO\" indicates that no such permutation exists.", "reference_code": "# import necessary packages\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef check(l):\n    number = l[0]\n    l = l[1:]\n    if len(l) == 0:\n        if number == 42:\n            return True\n        else:\n            return False\n    else:\n        second_number = l.pop()\n        t1 = [number + second_number] + l\n        t2 = [number - second_number] + l\n        t3 = [number * second_number] + l\n        return check(t1) or check(t2) or check(t3)\n\ndef check_all(l):\n    for p in permutations(l):\n        if check(list(p)):\n            return True\n    return False\n\n# main function\ndef main_solution(numbers):\n    # Convert the input list of strings to integers\n    numbers = [int(num) for num in numbers]\n    \n    # Check if any permutation of the numbers can be manipulated to reach 42\n    result = check_all(numbers)\n    \n    # Return the result as a string \"YES\" or \"NO\"\n    return \"YES\" if result else \"NO\"", "input_generator": "import random\nfrom itertools import permutations\n\ndef input_generator():\n    # Generate a random list of numbers between 1 and 20\n    n = random.randint(2, 5)  # Reasonable size for permutations\n    numbers = [random.randint(1, 20) for _ in range(n)]\n    \n    # Occasionally ensure a valid case where 42 is achievable\n    if random.random() < 0.3:\n        # Create a solvable case: e.g., [20, 22, 2] -> 20 + 22 = 42\n        a = random.randint(10, 30)\n        b = 42 - a\n        numbers = [a, b] + [random.randint(1, 20) for _ in range(n-2)]\n    \n    # Convert numbers to strings to match the main_solution input format\n    return {'numbers': [str(num) for num in numbers]}", "io_pairs": [{"input": {"numbers": ["8", "19", "17"]}, "output": "NO"}, {"input": {"numbers": ["5", "17", "1", "20"]}, "output": "YES"}, {"input": {"numbers": ["11", "5", "5", "17", "11"]}, "output": "YES"}, {"input": {"numbers": ["12", "2", "15", "4"]}, "output": "YES"}, {"input": {"numbers": ["6", "8", "13", "15"]}, "output": "YES"}, {"input": {"numbers": ["10", "1", "8", "11", "17"]}, "output": "YES"}, {"input": {"numbers": ["5", "19", "11", "17", "14"]}, "output": "NO"}, {"input": {"numbers": ["30", "12", "17", "13", "11"]}, "output": "NO"}, {"input": {"numbers": ["4", "19", "11"]}, "output": "NO"}, {"input": {"numbers": ["7", "9", "1", "9", "5"]}, "output": "YES"}], "error_log": []}
{"context": "Given a mathematical series that approximates the value of \u03c0, how can we estimate \u03c0 using the first `n` terms of this series? Specifically, what is the estimated value of \u03c0 when using the first `n` terms?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of terms to use in the series approximation for estimating \u03c0.\n\nOutput:\n  `return` (dict): A dictionary containing the key `\"estimated_pi\"` with the value being the estimated value of \u03c0 based on the first `n` terms of the series.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef mysqrt(a):\n    x = a\n    while True:\n        y = ((x + (a / x)) / 2)\n        if abs(x - y) < 0.00001:\n            break\n        else:\n            x = y\n    return y\n\ndef silnia(n):\n    if n == 1 or n == 0:\n        return 1\n    else:\n        return n * silnia(n - 1)\n\ndef calculate_skladnik(n):\n    return (silnia(4 * n) * (1103 + 26390 * n) / ((silnia(n)**4) * (396**(4 * n))))\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    k = (2 * math.sqrt(2)) / 9801\n    granica = 10**(-15)\n    result = 0\n\n    for i in range(n):\n        skladnik = calculate_skladnik(i)\n        if skladnik < granica:\n            break\n        else:\n            result += skladnik\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"estimated_pi\": 1 / (k * result)}", "input_generator": "import random\n\ndef input_generator():\n    return {\"n\": random.randint(1, 10)}", "io_pairs": [{"input": {"n": 3}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 6}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 9}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 1}, "output": {"estimated_pi": 3.1415927300133055}}, {"input": {"n": 7}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 8}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 2}, "output": {"estimated_pi": 3.1415926535897936}}, {"input": {"n": 5}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 10}, "output": {"estimated_pi": 3.141592653589793}}, {"input": {"n": 4}, "output": {"estimated_pi": 3.141592653589793}}], "error_log": []}
{"context": "In a high-dimensional space, a grid of cubes follows Conway's Game of Life rules. Given an initial state of the grid and the dimension (either 3D or 4D), how many cubes will remain active after six iterations of the game?\n\nThe input and output requirements are as follows:\n\nInput:\n  `string_grid` (List[List[str]]): A 2D list of strings representing the initial state of the grid. Each string is either `.` (inactive) or `#` (active).\n  `dim` (int): An integer representing the dimension of the grid (either 3 or 4).\n\nOutput:\n  `return` (int): The number of active cubes after six iterations of the Conway's Game of Life rules.", "reference_code": "# import necessary packages\nfrom collections import defaultdict\nfrom itertools import product\nfrom typing import List, Tuple\n\n# all class and function definitions in the code file, if any\ndef get_neighbour_locations(dim: int) -> List[Tuple]:\n    # get the relative positions of all neighbours of a point in a cartesian grid\n    return [pos for pos in product(range(-1, 2), repeat=dim) if pos != (0,) * dim]\n\nclass CubeGrid:\n    \"\"\"A grid of Conway cubes.\"\"\"\n\n    def __init__(self, string_grid: List[List[str]], dim: int):\n        self.dim = dim\n        self.neighbour_pos = get_neighbour_locations(dim)\n\n        self._update = self._update_3d if dim == 3 else self._update_4d\n\n        grid = defaultdict(bool)\n        for y in range(len(string_grid)):\n            for x in range(len(string_grid[0])):\n                grid[(x, y) + (0,) * (dim - 2)] = string_grid[y][x] == \"#\"\n        self.grid = grid\n\n    @property\n    def active_cubes(self):\n        # count the number of active cubes after six iterations\n        for _ in range(6):\n            self._update()\n\n        return sum(self.grid.values())\n\n    def _get_coord_ranges(self):\n        # return the ranges of each coordinate that need to be scanned for updates\n        coord_ranges = []\n        for i in range(self.dim):\n            c_range = sorted([p[i] for p in self.grid.keys()])\n            c_lims = range(c_range[0] - 1, c_range[-1] + 2)\n            coord_ranges.append(c_lims)\n\n        return coord_ranges\n\n    def _cube_state(self, p):\n        # obtain the new state of a cube given the current state of all cubes\n        num_active_neighbours = 0\n        for q in self.neighbour_pos:\n            neighbour_pos = tuple(p[i] + q[i] for i in range(self.dim))\n            num_active_neighbours += self.grid[neighbour_pos]\n\n        if self.grid[p]:\n            new_state = 2 <= num_active_neighbours <= 3\n        else:\n            new_state = num_active_neighbours == 3\n\n        return new_state\n\n    def _update_3d(self):\n        # update the grid in 3d\n        x_range, y_range, z_range = self._get_coord_ranges()\n        new_grid = defaultdict(bool)\n\n        for x in x_range:\n            for y in y_range:\n                for z in z_range:\n                    new_grid[(x, y, z)] = self._cube_state((x, y, z))\n\n        self.grid = new_grid\n\n    def _update_4d(self):\n        # update the grid in 4d\n        x_range, y_range, z_range, w_range = self._get_coord_ranges()\n        new_grid = defaultdict(bool)\n\n        for x in x_range:\n            for y in y_range:\n                for z in z_range:\n                    for w in w_range:\n                        new_grid[(x, y, z, w)] = self._cube_state((x, y, z, w))\n\n        self.grid = new_grid\n\n# main function\ndef main_solution(string_grid: List[List[str]], dim: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    cube_grid = CubeGrid(string_grid, dim)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return cube_grid.active_cubes", "input_generator": "import random\nfrom typing import List\n\ndef input_generator():\n    dim = random.choice([3, 4])\n    size = random.randint(3, 6)\n    string_grid = []\n    for _ in range(size):\n        row = []\n        for _ in range(size):\n            row.append(random.choice(['.', '#']))\n        string_grid.append(row)\n    return {'string_grid': string_grid, 'dim': dim}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Imagine you are designing a game where players navigate through a maze. The maze is generated randomly and needs to be represented in a string format for display purposes. Given the number of junction points across and down, and the characters used to represent walls and hallways, what would the string representation of the maze look like?\n\nThe input and output requirements are as follows:\n\nInput:\n  `width` (int): Number of junction points across (maze width is twice the size).\n  `height` (int): Number of junction points down (maze height is twice the size).\n  `chars` (list of str): Characters to represent walls and hallways in the maze.\n\nOutput:\n  `return` (str): A string representation of the maze.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef makeMaze(width, height):\n    \"\"\"Initializes an 2D list for the maze then begins the recurseive function.\n\n    Args:\n        width: Number of junction points accross (maze width is twice the size)\n        height: Number of junction points down (maze height is twice the size)\n\n    Returns:\n        A 2D list containing a maze of twisted passageways.\n    \"\"\"\n    maze = [[0 for j in range(width*2)] for i in range(height*2)]\n    recurseMaze(maze, int(width / 2) * 2, int(height / 2) * 2, 0, 0)\n    return maze\n\ndef recurseMaze(maze, x, y, dirx, diry):\n    \"\"\"This function is added to the call stack each time it is called.  It keeps\n    track if it's location and directions, so when functions are removed from the\n    stack and returns here the functions know where it's left off.\n\n    Args:\n        maze: The 2D list that the maze data will be stored in.\n        x: The X location of the current cell in the maze.\n        y: The Y location of the current cell in the maze.\n        dirx: The x direction that was taken to get to this cell.\n        diry: The y direction that was taken to get to this cell.\n\n    Returns:\n        Nothing\n    \"\"\"\n    if not 0 <= y < len(maze) or not 0 <= x < len(maze[0]) or maze[y][x] != 0:\n        return\n    maze[y-diry][x-dirx] = 1\n    maze[y][x] = 1\n    directions = [(1,0), (-1,0), (0,1), (0,-1)]\n    random.shuffle(directions)\n    for dx, dy in directions:\n        recurseMaze(maze, x + dx * 2, y + dy * 2, dx, dy)\n\ndef mazeString(maze, chars):\n    \"\"\"This function takes the lists of 1's and 0's and returns a string that\n    can easily be printed to the screen.\n\n    Args:\n        maze: The maze lists holding the maze information.\n        chars: The characters that should be used for drawing the maze (wall, hall)\n\n    Returns:\n        A string representing the maze that is ready for printing.\n    \"\"\"\n    s = chars[0] * (len(maze[0]) + 1) + \"\\n\"\n    for row in maze:\n        s += chars[0]\n        for cell in row:\n            s += chars[cell]\n        s += \"\\n\"\n    return s\n\n# main function\ndef main_solution(width, height, chars):\n    \"\"\"Generates a maze and returns a string representation of it.\n\n    Args:\n        width (int): Number of junction points across (maze width is twice the size).\n        height (int): Number of junction points down (maze height is twice the size).\n        chars (list of str): Characters to represent walls and hallways in the maze.\n\n    Returns:\n        str: A string representation of the maze.\n    \"\"\"\n    maze = makeMaze(width, height)\n    maze_str = mazeString(maze, chars)\n    return maze_str", "input_generator": "import random\n\ndef input_generator():\n    width = random.randint(3, 10)\n    height = random.randint(3, 10)\n    wall_char = random.choice(['#', '@', '%', 'X'])\n    hall_char = random.choice([' ', '.', '-', ' '])\n    chars = [wall_char, hall_char]\n    return {'width': width, 'height': height, 'chars': chars}", "io_pairs": [{"input": {"width": 4, "height": 4, "chars": ["%", " "]}, "output": "%%%%%%%%%\n%     % %\n% %%% % %\n%   %   %\n% % %%%%%\n% % %   %\n% % %%% %\n% %     %\n%%%%%%%%%\n"}, {"input": {"width": 6, "height": 3, "chars": ["@", "."]}, "output": "@@@@@@@@@@@@@\n@.....@...@.@\n@.@@@.@.@.@.@\n@.@...@.@.@.@\n@.@.@@@@@.@.@\n@.@.........@\n@@@@@@@@@@@@@\n"}, {"input": {"width": 4, "height": 3, "chars": ["@", "-"]}, "output": "@@@@@@@@@\n@-------@\n@-@@@@@-@\n@---@-@-@\n@@@-@-@-@\n@---@---@\n@@@@@@@@@\n"}, {"input": {"width": 3, "height": 4, "chars": ["@", " "]}, "output": "@@@@@@@\n@     @\n@ @@@ @\n@ @   @\n@ @@@ @\n@   @ @\n@@@@@ @\n@     @\n@@@@@@@\n"}, {"input": {"width": 6, "height": 3, "chars": ["X", "."]}, "output": "XXXXXXXXXXXXX\nX...........X\nX.XXXXXXX.X.X\nX.X.X...X.X.X\nX.X.X.XXXXX.X\nX...X.......X\nXXXXXXXXXXXXX\n"}, {"input": {"width": 3, "height": 5, "chars": ["@", " "]}, "output": "@@@@@@@\n@     @\n@@@@@ @\n@     @\n@ @@@ @\n@   @ @\n@@@@@ @\n@ @   @\n@ @ @@@\n@     @\n@@@@@@@\n"}, {"input": {"width": 6, "height": 3, "chars": ["#", "-"]}, "output": "#############\n#-#-----#---#\n#-#-###-###-#\n#-#---#-#---#\n#-###-###-#-#\n#---------#-#\n#############\n"}, {"input": {"width": 4, "height": 4, "chars": ["#", " "]}, "output": "#########\n#   #   #\n# # # # #\n# #   # #\n# ##### #\n#   #   #\n### #####\n#       #\n#########\n"}, {"input": {"width": 6, "height": 3, "chars": ["%", " "]}, "output": "%%%%%%%%%%%%%\n%       %   %\n% %%%%% % % %\n%     % % % %\n%%%%% %%% % %\n%         % %\n%%%%%%%%%%%%%\n"}, {"input": {"width": 3, "height": 4, "chars": ["%", "."]}, "output": "%%%%%%%\n%.....%\n%.%%%.%\n%...%.%\n%.%%%.%\n%.%.%.%\n%.%.%.%\n%.%...%\n%%%%%%%\n"}], "error_log": []}
{"context": "Given a chessboard of size `n` by `n`, how many distinct ways can you place `n` queens on the board such that no two queens threaten each other?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the chessboard and the number of queens to be placed on the board.\n\nOutput:\n  `return` (int): The total number of distinct solutions to the N-Queens problem for the given board size `n`.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def __init__(self):\n        self.result = 0\n    \n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def check(k, j):\n            for i in range(k):\n                if board[i] == j or abs(k - i) == abs(board[i] - j):\n                    return False\n            return True\n        \n        def nqueen(depth):\n            if depth == n:\n                self.result += 1\n                return\n            for i in range(n):\n                if check(depth, i):\n                    board[depth] = i                    \n                    nqueen(depth + 1)\n        \n        board = [-1 for _ in range(n)]\n        nqueen(0)\n        return self.result\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.totalNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Reasonable range for N-Queens problem\n    return {'n': n}", "io_pairs": [{"input": {"n": 5}, "output": 10}, {"input": {"n": 9}, "output": 352}, {"input": {"n": 4}, "output": 2}, {"input": {"n": 6}, "output": 4}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 8}, "output": 92}, {"input": {"n": 2}, "output": 0}, {"input": {"n": 7}, "output": 40}, {"input": {"n": 10}, "output": 724}, {"input": {"n": 3}, "output": 0}], "error_log": []}
{"context": "In a milkshake shop, there are several flavors of milkshakes available. Each customer has specific preferences for these flavors, indicating whether they prefer the milkshake to be malted or unmalted. Given the number of milkshake flavors and the preferences of multiple customers, determine whether it is possible to satisfy all customers with a single batch of milkshakes. If it is possible, what should be the malted status of each flavor? If it is impossible to satisfy all customers, indicate that it is impossible.\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_shakes` (int): The number of milkshake flavors available.\n  `customers` (list of lists of tuples): A list where each element is a list of tuples representing a customer's preferences. Each tuple contains two integers: the flavor index (0-based) and the malted preference (0 for unmalted, 1 for malted).\n\nOutput:\n  `return` (str): A string representing the result. If it is possible to satisfy all customers, it will be a space-separated string of integers representing the malted status of each flavor. If it is impossible to satisfy all customers, the string will be \"IMPOSSIBLE\".", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(num_shakes, customers):\n    shakes = [0] * num_shakes  # Create unmalted list\n    impossible = False\n    solved = False\n\n    while not impossible and not solved:  # While not finished\n        redo = False\n        for customer in customers:  # Examine all customers\n            unsatisfied = []\n            for flavor, malt in customer:  # Examine all their preferences\n                if shakes[flavor] == malt:  # If satisfied, move to next customer\n                    unsatisfied = []\n                    break\n                else:  # If unsatisfied, take note of it\n                    unsatisfied.append((flavor, malt))\n\n            for flavor, malt in unsatisfied:  # Check unsatisfied flavors\n                if malt == 1 and shakes[flavor] == 0:  # Look for a possible malted preference\n                    shakes[flavor] = 1  # Attend the malted preference\n                    redo = True  # Restart checking customers\n                    break\n\n            if redo:\n                break\n\n            if len(unsatisfied) > 0:  # If we've reached here, all insatisfactions are unmalted\n                impossible = True  # Then we can't solve it\n                break\n\n        if not redo:  # If we don't need to look into customers again\n            solved = True  # Problem was solved (might still be impossible)\n\n    result = \"IMPOSSIBLE\" if impossible else \" \".join(map(str, shakes))  # Decide result\n    return result", "input_generator": "import random\n\ndef input_generator():\n    num_shakes = random.randint(1, 10)\n    num_customers = random.randint(1, 10)\n    customers = []\n    for _ in range(num_customers):\n        num_preferences = random.randint(1, 3)\n        preferences = []\n        flavors = random.sample(range(num_shakes), min(num_preferences, num_shakes))\n        for flavor in flavors:\n            malt = random.randint(0, 1)\n            preferences.append((flavor, malt))\n        customers.append(preferences)\n    return {'num_shakes': num_shakes, 'customers': customers}", "io_pairs": [{"input": {"num_shakes": 2, "customers": [[[0, 1]]]}, "output": "1 0"}, {"input": {"num_shakes": 2, "customers": [[[0, 0], [1, 1]], [[1, 0]], [[0, 1]]]}, "output": "IMPOSSIBLE"}, {"input": {"num_shakes": 7, "customers": [[[5, 1]]]}, "output": "0 0 0 0 0 1 0"}, {"input": {"num_shakes": 10, "customers": [[[3, 0], [7, 1], [6, 0]]]}, "output": "0 0 0 0 0 0 0 0 0 0"}, {"input": {"num_shakes": 1, "customers": [[[0, 0]], [[0, 0]]]}, "output": "0"}, {"input": {"num_shakes": 1, "customers": [[[0, 1]]]}, "output": "1"}, {"input": {"num_shakes": 5, "customers": [[[3, 1]]]}, "output": "0 0 0 1 0"}, {"input": {"num_shakes": 3, "customers": [[[1, 1]]]}, "output": "0 1 0"}, {"input": {"num_shakes": 8, "customers": [[[3, 1]]]}, "output": "0 0 0 1 0 0 0 0"}, {"input": {"num_shakes": 10, "customers": [[[4, 1]], [[1, 0], [8, 0]]]}, "output": "0 0 0 0 1 0 0 0 0 0"}], "error_log": []}
{"context": "Given a variable \\( x \\) and a degree \\( n \\), what is the value of the \\( n \\)-th Legendre polynomial \\( P_n(x) \\) rounded to three decimal places?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): The value of the variable \\( x \\) for which the Legendre polynomial \\( P_n(x) \\) is to be calculated.\n  `n` (int): The degree \\( n \\) of the Legendre polynomial \\( P_n(x) \\).\n\nOutput:\n  `return` (float): The value of the Legendre polynomial \\( P_n(x) \\) rounded to 3 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef pol(x, n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return x\n    else:\n        return ((((2 * n - 1) * x * pol(x, n - 1)) - ((n - 1) * pol(x, n - 2))) / n)\n\n# main function\ndef main_solution(x, n):\n    # Convert input variables to appropriate types\n    x = float(x)\n    n = int(n)\n    \n    # Calculate the Legendre polynomial value\n    result = pol(x, n)\n    \n    # Return the result rounded to 3 decimal places\n    return round(result, 3)", "input_generator": "import random\n\ndef input_generator():\n    x = random.uniform(-1.0, 1.0)\n    n = random.randint(0, 10)\n    return {'x': x, 'n': n}", "io_pairs": [{"input": {"x": 0.053929275802870436, "n": 2}, "output": -0.496}, {"input": {"x": 0.8175153510980546, "n": 3}, "output": 0.14}, {"input": {"x": -0.959516950356126, "n": 10}, "output": -0.261}, {"input": {"x": 0.13786078389212086, "n": 3}, "output": -0.2}, {"input": {"x": -0.34158960386076975, "n": 0}, "output": 1}, {"input": {"x": 0.46991021435285973, "n": 2}, "output": -0.169}, {"input": {"x": 0.24701905461809703, "n": 9}, "output": 0.182}, {"input": {"x": 0.7508255852170751, "n": 7}, "output": -0.038}, {"input": {"x": 0.7630881575311748, "n": 0}, "output": 1}, {"input": {"x": -0.7665914301449865, "n": 2}, "output": 0.381}], "error_log": []}
{"context": "Given a positive integer, what are the unique ways to partition it into sums of smaller integers? For example, for the number 4, the partitions could be [1, 1, 1, 1], [1, 1, 2], [2, 2], and [1, 3]. What are the unique additive partitions for a given number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number` (int): The integer for which additive partitions are to be calculated.\n\nOutput:\n  `return` (str): A JSON string representing the list of all unique additive partitions of the input number. Each partition is a list of integers.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nbase_cases = {1: [[1]],\n              2: [[1, 1]]}\n\ndef additive_partitions(number):\n    partitions = []\n\n    if number == 1 or number == 2:\n        return base_cases.get(number)\n\n    for x in range(1, number // 2 + 1):\n        partitions.append([x, (number - x)])\n\n        sub_list_x = additive_partitions(x)\n        sub_list_c = additive_partitions(number - x)\n\n        sub_partitions_list = [sub_x + sub_c for sub_x in sub_list_x for sub_c in sub_list_c]\n\n        for element in sub_partitions_list:\n            element.sort()\n\n        partitions.extend([element for element in sub_partitions_list if element not in partitions])\n\n    return partitions\n\n# main function\ndef main_solution(number):\n    # Convert the input to an integer\n    number = int(number)\n    \n    # Get the additive partitions\n    partitions = additive_partitions(number)\n    \n    # Convert the partitions to a JSON serializable format\n    partitions_json = json.dumps(partitions)\n    \n    # Return the JSON string\n    return partitions_json", "input_generator": "import random\n\ndef input_generator():\n    number = random.randint(1, 10)\n    return {'number': str(number)}", "io_pairs": [{"input": {"number": "5"}, "output": "[[1, 4], [1, 1, 3], [1, 1, 1, 2], [1, 1, 1, 1, 1], [1, 2, 2], [2, 3]]"}, {"input": {"number": "3"}, "output": "[[1, 2], [1, 1, 1]]"}, {"input": {"number": "1"}, "output": "[[1]]"}, {"input": {"number": "4"}, "output": "[[1, 3], [1, 1, 2], [1, 1, 1, 1], [2, 2]]"}, {"input": {"number": "2"}, "output": "[[1, 1]]"}], "error_log": []}
{"context": "Given a function \\( f(x) = e^{-x^2} \\), you are tasked with determining the integral of this function over a specified interval using the Romberg integration method. What is the result of the Romberg integration for the function \\( f(x) \\) over the interval \\([Lim\\_inf, Lim\\_sup]\\) with \\( k \\) iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `Lim_inf` (float): The inferior limit of the interval for integration.\n  `Lim_sup` (float): The superior limit of the interval for integration.\n  `k` (int): The number of iterations for the Romberg method.\n\nOutput:\n  `return` (dict): A dictionary containing the result of the Romberg integration. The key is `\"result\"` and the value is a float representing the computed integral.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# Function to be solved -----------------------------------\n\ndef f(x):\n    return np.exp(-x**2)\n\ndef romberg(col1):\n    n = len(col1)\n    for j in range(n - 1):\n        temp_col = [0] * (n - 1 - j)\n        for i in range(n - 1 - j):\n            power = j + 1\n            temp_col[i] = (4 ** power * col1[i + 1] - col1[i]) / (4 ** power - 1)\n        col1[:n - 1 - j] = temp_col\n    return col1[0]\n\ndef trapezio(f, a, b, h):                            \n    n = int((b - a) / h)\n    soma = 0\n    for k in range(1, n):\n        soma += f(a + k * h)\n    return (h / 2) * (f(a) + 2 * soma + f(b))\n\n# main function\ndef main_solution(Lim_inf, Lim_sup, k):\n    # Convert input variables if necessary\n    hs = [0.5 / 2 ** i for i in range(k)]\n    \n    # Calculate the first column of the Romberg table\n    col1 = [trapezio(f, Lim_inf, Lim_sup, hi) for hi in hs]\n    \n    # Calculate the Romberg integration result\n    result = romberg(col1)\n    \n    # Return the result as a JSON serializable output\n    return {\"result\": result}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    Lim_inf = random.uniform(-5.0, 0.0)\n    Lim_sup = random.uniform(0.0, 5.0)\n    k = random.randint(2, 6)\n    return {\"Lim_inf\": Lim_inf, \"Lim_sup\": Lim_sup, \"k\": k}", "io_pairs": [{"input": {"Lim_inf": -0.3898453966195836, "Lim_sup": 0.2203386054429296, "k": 5}, "output": {"result": 0.583807456152122}}, {"input": {"Lim_inf": -1.668348471924777, "Lim_sup": 4.697136209058286, "k": 4}, "output": {"result": 1.7562319434382956}}, {"input": {"Lim_inf": -2.1119769022888386, "Lim_sup": 1.5902273243220422, "k": 2}, "output": {"result": 1.7204331288607797}}, {"input": {"Lim_inf": -0.9178493939742456, "Lim_sup": 2.104375842397486, "k": 6}, "output": {"result": 1.5977076793059068}}, {"input": {"Lim_inf": -0.46552217758939207, "Lim_sup": 3.3736750161199334, "k": 4}, "output": {"result": 1.3201979254592848}}, {"input": {"Lim_inf": -1.6663941841158199, "Lim_sup": 2.598062096410291, "k": 4}, "output": {"result": 1.7558805431970286}}, {"input": {"Lim_inf": -3.6301458235398036, "Lim_sup": 2.7709804709108647, "k": 4}, "output": {"result": 1.7723558287513415}}, {"input": {"Lim_inf": -2.5302524886095723, "Lim_sup": 0.12242987836054209, "k": 2}, "output": {"result": 0.8545018513596648}}, {"input": {"Lim_inf": -4.757312055737871, "Lim_sup": 0.260210886063883, "k": 2}, "output": {"result": 1.123605752824827}}, {"input": {"Lim_inf": -3.34410871222931, "Lim_sup": 1.2490677046682803, "k": 6}, "output": {"result": 1.7023030428939323}}], "error_log": []}
{"context": "In a city, there is a grid-like structure representing the layout of houses. Some houses are quarantined due to a recent outbreak, and you need to navigate from the top-left corner of the grid to a specific destination house. Given the number of rows (`M`) and columns (`N`) in the grid, a list of quarantined house numbers, and the destination house number, what is the shortest path to reach the destination house from the source, expressed as a sequence of directions (UP, LEFT, RIGHT, DOWN)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `M` (int): Number of rows in the grid.\n  `N` (int): Number of columns in the grid.\n  `housesquarantined` (list of int): List of house numbers that are quarantined.\n  `Destinationhouse` (int): House number of the destination.\n\nOutput:\n  `return` (str): A string representing the directions to reach the destination from the source. If the destination cannot be reached, it returns \"Destination can't be reached\".", "reference_code": "# import necessary packages\nfrom collections import deque\nimport math\n\n# all class and function definitions in the code file, if any\n# Below lists details all 4 possible movements from a cell\nrow = [-1, 0, 0, 1]\ncol = [0, -1, 1, 0]\nstring = [\"U\",\"L\",\"R\",\"D\"]\n\n# Function to check if it is possible to go to position (row, col)\n# from current position. The function returns false if row, col\n# is not a valid position or has value 0 or it is already visited\ndef isValid(mat, visited, row, col):\n    return (row >= 0) and (row < len(mat)) and (col >= 0) and (col < len(mat[0])) \\\n           and mat[row][col] == 1 and not visited[row][col]\n\n# Find Shortest Possible Route in a matrix mat from source \n# cell (i, j) to destination cell (x, y) and returns the directions\ndef BFS(mat, i, j, x, y):\n    # construct a matrix to keep track of visited cells\n    visited = [[False for _ in range(len(mat[0]))] for _ in range(len(mat))]\n\n    # create an empty queue\n    q = deque()\n\n    # mark source cell as visited and enqueue the source node\n    visited[i][j] = True\n\n    # (i, j, dist) represents matrix cell coordinates and its\n    # minimum distance from the source\n    q.append((i, j, 0, \"\"))\n\n    # stores length of longest path from source to destination\n    min_dist = float('inf')\n    directions = \"\"\n\n    #  run till queue is empty\n    while q:\n        # pop front node from queue and process it\n        (i, j, dist, path) = q.popleft()\n\n        # (i, j) represents current cell and dist stores its\n        # minimum distance from the source\n\n        # if destination is found, update min_dist and stop\n        if i == x and j == y:\n            min_dist = dist\n            directions = path\n            break\n\n        # check for all 4 possible movements from current cell\n        # and enqueue each valid movement\n        for k in range(4):\n            # check if it is possible to go to position\n            # (i + row[k], j + col[k]) from current position\n            if isValid(mat, visited, i + row[k], j + col[k]):\n                # mark next cell as visited and enqueue it\n                visited[i + row[k]][j + col[k]] = True\n                q.append((i + row[k], j + col[k], dist + 1, path + string[k]))\n\n    if min_dist == float('inf'):\n        return \"Destination can't be reached\"\n    else:\n        return directions\n\n# This function is to convert decimal house numbers to the specific coordinates\n# in terms of i and j pointing a specific cell in the grid\ndef convert(housenumber, M, N):\n    i = math.ceil(housenumber / N) - 1\n    j = housenumber - (N * (i)) - 1\n    return (i, j)\n\n# main function\ndef main_solution(M, N, housesquarantined, Destinationhouse):\n    # Convert JSON serializable inputs to original input variables\n    mat = [[1 for _ in range(N)] for _ in range(M)]\n    i, j = convert(Destinationhouse, M, N)\n\n    for house in housesquarantined:\n        quarantine_index_i, quarantine_index_j = convert(house, M, N)\n        mat[quarantine_index_i][quarantine_index_j] = 0\n\n    # Call the BFS function and get the result\n    result = BFS(mat, 0, 0, i, j)\n\n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    M = random.randint(2, 10)\n    N = random.randint(2, 10)\n    total_houses = M * N\n    Destinationhouse = random.randint(1, total_houses)\n    \n    # Ensure at least one non-quarantined house exists (excluding (0,0) which is the start)\n    max_quarantined = min(total_houses - 2, random.randint(1, total_houses // 2))\n    housesquarantined = random.sample(range(1, total_houses + 1), max_quarantined)\n    \n    return {\n        'M': M,\n        'N': N,\n        'housesquarantined': housesquarantined,\n        'Destinationhouse': Destinationhouse\n    }", "io_pairs": [{"input": {"M": 5, "N": 3, "housesquarantined": [11, 2, 9, 3, 4, 7, 13], "Destinationhouse": 3}, "output": "Destination can't be reached"}, {"input": {"M": 7, "N": 4, "housesquarantined": [11, 23, 5, 24, 25, 12, 3, 1], "Destinationhouse": 3}, "output": "Destination can't be reached"}, {"input": {"M": 5, "N": 4, "housesquarantined": [17, 19, 8, 10, 20, 14, 7, 12, 11], "Destinationhouse": 18}, "output": "Destination can't be reached"}, {"input": {"M": 5, "N": 4, "housesquarantined": [10, 11, 12, 5, 9, 15, 6, 1], "Destinationhouse": 12}, "output": "Destination can't be reached"}, {"input": {"M": 3, "N": 7, "housesquarantined": [1, 9, 21, 13, 18, 8], "Destinationhouse": 7}, "output": "RRRRRR"}, {"input": {"M": 3, "N": 7, "housesquarantined": [7, 1, 5], "Destinationhouse": 21}, "output": "RRRDRRRD"}, {"input": {"M": 8, "N": 8, "housesquarantined": [10, 45, 58, 20, 48, 7, 26, 49, 53, 46, 6], "Destinationhouse": 24}, "output": "RRRRDRRRD"}, {"input": {"M": 3, "N": 6, "housesquarantined": [17, 7, 14, 8], "Destinationhouse": 5}, "output": "RRRR"}, {"input": {"M": 6, "N": 2, "housesquarantined": [3, 4, 5, 6, 10, 11], "Destinationhouse": 5}, "output": "Destination can't be reached"}, {"input": {"M": 6, "N": 7, "housesquarantined": [40, 28, 26, 11], "Destinationhouse": 38}, "output": "RRDDDDD"}], "error_log": []}
{"context": "Given the Euler angles (yaw, pitch, roll) of an object in radians, what is the normalized quaternion representation of these angles, and what are the corresponding Euler angles when converted back from this quaternion?\n\nThe input and output requirements are as follows:\n\nInput:\n  `yaw` (float): The yaw angle in radians.\n  `pitch` (float): The pitch angle in radians.\n  `roll` (float): The roll angle in radians.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `normalized_quaternion` (tuple): A tuple of four floats representing the normalized quaternion (w, x, y, z).\n    - `converted_euler_angles` (tuple): A tuple of three floats representing the Euler angles (yaw, pitch, roll) converted back from the normalized quaternion.", "reference_code": "# import necessary packages\nfrom math import pi, sin, cos, asin, acos, atan2, sqrt\nimport random\n\n# all class and function definitions in the code file, if any\ndef quaternion_mgnitude(w, x, y, z):\n    return sqrt(w*w + x*x + y*y + z*z)\n\ndef quaternion_normalise(w, x, y, z):\n    mag = sqrt(w*w + x*x + y*y + z*z)\n    return w/mag, x/mag, y/mag, z/mag\n\ndef quaternion_from_axis_angle(vector, theta):\n    sin_half_theta = sin(theta/2)\n    return cos(theta/2), vector[0]*sin_half_theta, vector[1]*sin_half_theta, vector[2]*sin_half_theta\n\ndef quaternion_to_rotation_matrix_rows(w, x, y, z):\n    x2 = x*x\n    y2 = y*2\n    z2 = z*2\n    row0 = (1 - 2*y2 - 2*z2,\n            2*x*y - 2*w*z,\n            2*x*z + 2*w*y)\n    row1 = (2*x*y + 2*w*z,\n            1 - 2*x2 - 2*z2,\n            2*y*z - 2*w*x)\n    row2 = (2*x*z - 2*w*y,\n            2*y*z + 2*w*x,\n            1 - 2*x2 - 2*y2)\n    return row0, row1, row2\n\ndef quaternion_from_rotation_matrix_rows(row0, row1, row2):\n    trace = row0[0] + row1[1] + row2[2]\n    if trace > row2[2]:\n        S = sqrt(1.0 + trace) *  2\n        w = 0.25 * S\n        x = (row2[1] - row1[2]) / S\n        y = (row0[2] - row2[0]) / S\n        z = (row1[0] - row0[1]) / S\n    elif row0[0] < row1[1] and row0[0] < row2[2]:\n        S = sqrt(1.0 + row0[0] - row1[1] - row2[2]) * 2\n        w = (row2[1] - row1[2]) / S\n        x = 0.25 * S\n        y = (row0[1] + row1[0]) / S\n        z = (row0[2] + row2[0]) / S\n    elif row1[1] < row2[2]:\n        S = sqrt(1.0 + row1[1] - row0[0] - row2[2]) * 2\n        w = (row0[2] - row2[0]) / S\n        x = (row0[1] + row1[0]) / S\n        y = 0.25 * S\n        z = (row1[2] + row2[1]) / S\n    else:\n        S = sqrt(1.0 + row2[2] - row0[0] - row1[1]) * 2\n        w = (row1[0] - row0[1]) / S\n        x = (row0[2] + row2[0]) / S\n        y = (row1[2] + row2[1]) / S\n        z = 0.25 * S\n    return w, x, y, z\n\ndef quaternion_from_euler_angles(yaw, pitch, roll):\n    return (cos(roll/2)*cos(pitch/2)*cos(yaw/2) + sin(roll/2)*sin(pitch/2)*sin(yaw/2),\n            sin(roll/2)*cos(pitch/2)*cos(yaw/2) - cos(roll/2)*sin(pitch/2)*sin(yaw/2),\n            cos(roll/2)*sin(pitch/2)*cos(yaw/2) + sin(roll/2)*cos(pitch/2)*sin(yaw/2),\n            cos(roll/2)*cos(pitch/2)*sin(yaw/2) - sin(roll/2)*sin(pitch/2)*cos(yaw/2))\n\ndef quaternion_to_euler_angles(w, x, y, z):\n    w2 = w*w\n    x2 = x*x\n    y2 = y*y\n    z2 = z*z\n    return (atan2(2.0 * (x*y + z*w), (w2 + x2 - y2 - z2)),\n            asin(2.0 * (w*y - x*z) / (w2 + x2 + y2 + z2)),\n            atan2(2.0 * (y*z + x*w), (w2 - x2 - y2 + z2)))\n\ndef quaternion_multiply(a, b):\n    a_w, a_x, a_y, a_z = a\n    b_w, b_x, b_y, b_z = b\n    return (a_w*b_w - a_x*b_x - a_y*b_y - a_z*b_z,\n            a_w*b_x + a_x*b_w + a_y*b_z - a_z*b_y,\n            a_w*b_y - a_x*b_z + a_y*b_w + a_z*b_x,\n            a_w*b_z + a_x*b_y - a_y*b_x + a_z*b_w)\n\ndef quaternion_scalar_multiply(q, s):\n    w, x, y, z = q\n    return (w*s, x*s, y*s, z*s)\n\n# main function\ndef main_solution(yaw, pitch, roll):\n    # Convert Euler angles to quaternion\n    quaternion = quaternion_from_euler_angles(yaw, pitch, roll)\n    \n    # Normalize the quaternion\n    normalized_quaternion = quaternion_normalise(*quaternion)\n    \n    # Convert the normalized quaternion back to Euler angles\n    euler_angles = quaternion_to_euler_angles(*normalized_quaternion)\n    \n    # Return the normalized quaternion and the converted Euler angles\n    return {\n        \"normalized_quaternion\": normalized_quaternion,\n        \"converted_euler_angles\": euler_angles\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    yaw = random.uniform(-math.pi, math.pi)\n    pitch = random.uniform(-math.pi/2, math.pi/2)\n    roll = random.uniform(-math.pi, math.pi)\n    return {\n        \"yaw\": yaw,\n        \"pitch\": pitch,\n        \"roll\": roll\n    }", "io_pairs": [{"input": {"yaw": -2.8381463151709205, "pitch": -1.0631763070184712, "roll": 1.6612130422958966}, "output": {"normalized_quaternion": [0.45783510405446426, -0.24174779269507868, -0.6808111343334422, -0.5181131358980458], "converted_euler_angles": [-2.8381463151709205, -1.063176307018471, 1.6612130422958968]}}, {"input": {"yaw": -3.10267811611857, "pitch": 1.497337065723252, "roll": -2.2341260673072973}, "output": {"normalized_quaternion": [0.6179241130042716, 0.2854837420882485, 0.664149640310798, -0.3091505763316835], "converted_euler_angles": [-3.102678116118569, 1.4973370657232516, -2.234126067307297]}}, {"input": {"yaw": 0.31250775335806225, "pitch": 0.5515361692835543, "roll": 1.1764100491876324}, "output": {"normalized_quaternion": [0.8142632928272789, 0.49214761741976154, 0.306850877356873, -0.02466884041551998], "converted_euler_angles": [0.31250775335806225, 0.5515361692835544, 1.1764100491876321]}}, {"input": {"yaw": 2.224461999673853, "pitch": -1.1959568436671373, "roll": 0.31897012890280196}, "output": {"normalized_quaternion": [0.28103742692435013, 0.5565052764728631, -0.12835157876801245, 0.7712624158827923], "converted_euler_angles": [2.224461999673853, -1.1959568436671373, 0.318970128902802]}}, {"input": {"yaw": -2.2494378088973286, "pitch": 0.7926925712579687, "roll": 1.1444231565056873}, "output": {"normalized_quaternion": [0.14600005758606474, 0.5083016383081759, -0.31061284286645335, -0.7898310512536908], "converted_euler_angles": [-2.2494378088973286, 0.7926925712579689, 1.1444231565056875]}}, {"input": {"yaw": -0.9218887253678787, "pitch": -1.4929768421632337, "roll": -0.6402350729546393}, "output": {"normalized_quaternion": [0.529017437914723, -0.49358952619325036, -0.4745492476865507, -0.5013112222308549], "converted_euler_angles": [-0.9218887253678794, -1.4929768421632335, -0.6402350729546397]}}, {"input": {"yaw": 2.159750679906831, "pitch": 1.4360583053845648, "roll": 1.795294963379078}, "output": {"normalized_quaternion": [0.6749901066571946, -0.08413410909862414, 0.7126525398254392, 0.17156970910227945], "converted_euler_angles": [2.1597506799068293, 1.436058305384564, 1.7952949633790765]}}, {"input": {"yaw": 0.037230594431545416, "pitch": -1.217068526658188, "roll": 0.47678225071285096}, "output": {"normalized_quaternion": [0.7946318231572737, 0.20405599226488383, -0.5517955330252943, 0.14981023790072712], "converted_euler_angles": [0.037230594431545375, -1.2170685266581882, 0.47678225071285113]}}, {"input": {"yaw": 2.616645641118513, "pitch": -0.7322141231145395, "roll": 2.8855518988368463}, "output": {"normalized_quaternion": [-0.3119620681504707, 0.28443065268978474, 0.8825106642575765, 0.2072529838564338], "converted_euler_angles": [2.616645641118513, -0.7322141231145394, 2.8855518988368463]}}, {"input": {"yaw": -2.7250283984663706, "pitch": 0.6341000530018994, "roll": -2.9226138520532556}, "output": {"normalized_quaternion": [0.3246692877845992, -0.1619664044717436, 0.9311017533063563, -0.037500165089851024], "converted_euler_angles": [-2.7250283984663706, 0.6341000530018995, -2.9226138520532556]}}], "error_log": []}
{"context": "Given the classic n-queens puzzle, where you need to place `n` queens on an `n`\u00d7`n` chessboard such that no two queens can attack each other, what are the distinct configurations of the queens' placements for a given board size `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (List[List[str]]): A list of all distinct solutions to the n-queens puzzle. Each solution is represented as a list of strings, where each string represents a row on the chessboard. 'Q' indicates a queen, and '.' indicates an empty space.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        result = []\n\n        def isVaild(j, set):\n            for i in range(0, len(set)):\n                if set[i] == j or abs(i - len(set)) == abs(set[i] - j):\n                    return False\n            return True\n\n        def callback(i, set):\n            if len(set) == n:\n                temp = []\n                for k in range(0, n):\n                    row = '.' * set[k] + 'Q' + '.' * (n - set[k] - 1)\n                    temp.append(row)\n                result.append(temp)\n                return\n                \n            for j in range(0, n):\n                if isVaild(j, set):\n                    set.append(j)\n                    callback(i + 1, set)\n                    set.pop()\n\n        for i in range(0, n):\n            callback(0, [i])\n\n        return result\n\n# main function\ndef main_solution(n):\n    # Convert JSON serializable input to the original input variables\n    n = int(n)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    s = Solution()\n    result = s.solveNQueens(n)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.choice([4, 5, 6, 7, 8])\n    return {'n': n}", "io_pairs": [{"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}], "error_log": []}
{"context": "In a simplified version of Yahtzee, a player rolls a set of dice and must decide which dice to hold to maximize their expected score. Given a specific hand of dice and the number of sides on each die, what is the optimal strategy for holding the dice to achieve the highest expected score?\n\nThe input and output requirements are as follows:\n\nInput:\n  `hand` (list of integers): A list of integers representing the dice in the hand. Each integer should be between 1 and `num_die_sides`.\n  `num_die_sides` (integer): An integer representing the number of sides on each die. This should be a positive integer.\n\nOutput:\n  `return` (dictionary): A dictionary with the following keys:\n    - `expected_score` (float): The expected score when holding the optimal dice.\n    - `dice_to_hold` (list of integers): A list of integers representing the dice to hold for the optimal strategy.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef gen_all_sequences(outcomes, length):\n    \"\"\"\n    Iterative function that enumerates the set of all sequences of\n    outcomes of given length.\n    \"\"\"\n    answer_set = set([()])\n    for dummy_idx in range(length):\n        temp_set = set()\n        for partial_sequence in answer_set:\n            for item in outcomes:\n                new_sequence = list(partial_sequence)\n                new_sequence.append(item)\n                temp_set.add(tuple(new_sequence))\n        answer_set = temp_set\n    return answer_set\n\ndef score(hand):\n    \"\"\"\n    Compute the maximal score for a Yahtzee hand according to the\n    upper section of the Yahtzee score card.\n\n    hand: full yahtzee hand\n\n    Returns an integer score \n    \"\"\"\n    roll = {}\n    for dice in hand:\n        roll[dice] = roll.get(dice, 0) + dice\n        \n    max_dice = None\n    max_val = 0\n    \n    for dice, val in roll.items():\n        if max_dice == None:\n            max_dice = dice\n            max_val = val\n        elif val > max_val:\n            max_dice = dice\n            max_val = val\n            \n    return max_val\n\ndef expected_value(held_dice, num_die_sides, num_free_dice):\n    \"\"\"\n    Compute the expected value based on held_dice given that there\n    are num_free_dice to be rolled, each with num_die_sides.\n\n    held_dice: dice that you will hold\n    num_die_sides: number of sides on each die\n    num_free_dice: number of dice to be rolled\n\n    Returns a floating point expected value\n    \"\"\"\n    die = [num + 1 for num in range(num_die_sides)]\n    outcomes = gen_all_sequences(die, num_free_dice)\n    \n    total = 0\n    n_cases = 0\n    for num in outcomes:\n        hand = held_dice + num\n        total = total + score(hand)\n        n_cases = n_cases + 1\n    \n    return total / float(n_cases)\n\ndef gen_all_holds(hand):\n    \"\"\"\n    Generate all possible choices of dice from hand to hold.\n\n    hand: full yahtzee hand\n\n    Returns a set of tuples, where each tuple is dice to hold\n    \"\"\"\n    power_set = set([()])\n    \n    for roll in hand:\n        temp_set = set(power_set)\n        for subset in power_set:\n            new_subset = list(subset)\n            new_subset.append(roll)\n            temp_set.add(tuple(new_subset))\n        power_set = temp_set\n    \n    return power_set\n\ndef strategy(hand, num_die_sides):\n    \"\"\"\n    Compute the hold that maximizes the expected value when the\n    discarded dice are rolled.\n\n    hand: full yahtzee hand\n    num_die_sides: number of sides on each die\n\n    Returns a tuple where the first element is the expected score and\n    the second element is a tuple of the dice to hold\n    \"\"\"\n    all_holds = gen_all_holds(hand)\n    hand_length = len(hand)\n\n    max_val = 0\n    max_held = None\n    \n    for held_dice in all_holds:\n        free_dice = hand_length - len(held_dice) \n        held_val = expected_value(held_dice, num_die_sides, free_dice)\n        \n        if(held_val >= max_val):\n            max_val = held_val\n            max_held = held_dice\n  \n    return (max_val, max_held)\n\n# main function\ndef main_solution(hand, num_die_sides):\n    \"\"\"\n    Compute the optimal strategy for a given Yahtzee hand and number of die sides.\n\n    hand: list of integers representing the dice in the hand\n    num_die_sides: integer representing the number of sides on each die\n\n    Returns a dictionary with keys 'expected_score' and 'dice_to_hold'\n    \"\"\"\n    hand = tuple(hand)  # Convert list to tuple for compatibility with existing functions\n    expected_score, dice_to_hold = strategy(hand, num_die_sides)\n    return {\n        'expected_score': expected_score,\n        'dice_to_hold': list(dice_to_hold)  # Convert tuple to list for JSON serialization\n    }", "input_generator": "import random\n\ndef input_generator():\n    num_die_sides = random.randint(4, 8)  # Reasonable number of sides (e.g., 4 to 8)\n    hand_size = random.randint(3, 5)  # Reasonable hand size (e.g., 3 to 5 dice)\n    hand = tuple(random.randint(1, num_die_sides) for _ in range(hand_size))\n    return {\n        'hand': list(hand),\n        'num_die_sides': num_die_sides\n    }", "io_pairs": [{"input": {"hand": [4, 3, 2], "num_die_sides": 5}, "output": {"expected_score": 6.16, "dice_to_hold": [4]}}, {"input": {"hand": [2, 3, 4, 6, 5], "num_die_sides": 6}, "output": {"expected_score": 10.691358024691358, "dice_to_hold": [6]}}, {"input": {"hand": [5, 1, 3, 5, 3], "num_die_sides": 6}, "output": {"expected_score": 12.657407407407407, "dice_to_hold": [5, 5]}}, {"input": {"hand": [5, 1, 2], "num_die_sides": 5}, "output": {"expected_score": 7.16, "dice_to_hold": [5]}}, {"input": {"hand": [2, 2, 3, 1, 4], "num_die_sides": 5}, "output": {"expected_score": 8.5504, "dice_to_hold": [4]}}, {"input": {"hand": [6, 5, 5], "num_die_sides": 7}, "output": {"expected_score": 10.714285714285714, "dice_to_hold": [5, 5]}}, {"input": {"hand": [1, 2, 5, 6, 2], "num_die_sides": 8}, "output": {"expected_score": 11.1025390625, "dice_to_hold": [6]}}, {"input": {"hand": [6, 5, 8], "num_die_sides": 8}, "output": {"expected_score": 10.1875, "dice_to_hold": [8]}}, {"input": {"hand": [4, 4, 2, 4], "num_die_sides": 5}, "output": {"expected_score": 12.8, "dice_to_hold": [4, 4, 4]}}, {"input": {"hand": [5, 3, 2], "num_die_sides": 5}, "output": {"expected_score": 7.16, "dice_to_hold": [5]}}], "error_log": []}
{"context": "Given a matrix, how can we obtain its representation after rotating it 180 degrees?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of integers): A 2D list representing the matrix to be rotated. Each sublist represents a row in the matrix.\n\nOutput:\n  `return` (list of lists of integers): A 2D list representing the matrix after being rotated 180 degrees. Each sublist represents a row in the rotated matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix):\n    # Convert the input list to a numpy array\n    matrix = np.array(matrix)\n    \n    # Rotate the matrix 180 degrees\n    rotated_matrix = np.rot90(matrix, 2)\n    \n    # Convert the numpy array back to a list\n    rotated_matrix = rotated_matrix.tolist()\n    \n    # Return the rotated matrix\n    return rotated_matrix", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    rows = random.randint(1, 10)\n    cols = random.randint(1, 10)\n    matrix = [[random.randint(0, 100) for _ in range(cols)] for _ in range(rows)]\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[94, 85, 55, 45, 84], [32, 66, 30, 85, 8]]}, "output": [[8, 85, 30, 66, 32], [84, 45, 55, 85, 94]]}, {"input": {"matrix": [[39, 62, 4, 23], [18, 58, 25, 75]]}, "output": [[75, 25, 58, 18], [23, 4, 62, 39]]}, {"input": {"matrix": [[62], [65]]}, "output": [[65], [62]]}, {"input": {"matrix": [[1, 42, 88, 44], [52, 15, 98, 70]]}, "output": [[70, 98, 15, 52], [44, 88, 42, 1]]}, {"input": {"matrix": [[18], [66]]}, "output": [[66], [18]]}, {"input": {"matrix": [[39, 26, 77], [95, 47, 4]]}, "output": [[4, 47, 95], [77, 26, 39]]}, {"input": {"matrix": [[99, 92, 11], [63, 60, 85]]}, "output": [[85, 60, 63], [11, 92, 99]]}, {"input": {"matrix": [[42]]}, "output": [[42]]}, {"input": {"matrix": [[65, 96, 59, 46], [37, 46, 9, 67], [10, 41, 35, 18]]}, "output": [[18, 35, 41, 10], [67, 9, 46, 37], [46, 59, 96, 65]]}, {"input": {"matrix": [[83, 6, 96, 92, 62, 51, 62, 5, 94, 72]]}, "output": [[72, 94, 5, 62, 51, 62, 92, 96, 6, 83]]}], "error_log": []}
{"context": "Given a sequence of integers that forms a quadratic sequence, what would be the next set of integers in the sequence that matches the same quadratic pattern?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_list` (str): A JSON string representing a list of integers. The list should contain at least three integers to form a valid quadratic sequence.\n\nOutput:\n  `return` (str): A JSON string representing a list of integers. This list is the continuation of the quadratic sequence derived from the input list.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef quad_sequence(lst):\n    x = len(lst)\n    for n in range(x - 1, 2 * x - 1):\n        p = lst[-1]\n        lst.append(p + (lst[1] - lst[0]) + (lst[0] - 2 * lst[1] + lst[2]) * n)\n    return lst[x:]\n\n# main function\ndef main_solution(input_list):\n    # Convert input_list to a list of integers\n    input_list = json.loads(input_list)\n    \n    # Call the quad_sequence function\n    result = quad_sequence(input_list)\n    \n    # Convert the result to a JSON serializable format\n    result_json = json.dumps(result)\n    \n    return result_json", "input_generator": "import json\nimport random\n\ndef input_generator():\n    # Generate a random quadratic sequence initial terms\n    a = random.randint(-10, 10)\n    b = random.randint(-10, 10)\n    c = random.randint(-10, 10)\n    input_list = [a, b, c]\n    \n    return {'input_list': json.dumps(input_list)}", "io_pairs": [{"input": {"input_list": "[-6, 2, -4]"}, "output": "[-24, -58, -106]"}, {"input": {"input_list": "[-4, 9, 5]"}, "output": "[-16, -54, -109]"}, {"input": {"input_list": "[5, -7, 6]"}, "output": "[44, 107, 195]"}, {"input": {"input_list": "[3, 5, -2]"}, "output": "[-18, -43, -77]"}, {"input": {"input_list": "[-10, -10, -8]"}, "output": "[-4, 2, 10]"}, {"input": {"input_list": "[8, -7, 5]"}, "output": "[44, 110, 203]"}, {"input": {"input_list": "[-5, -7, -10]"}, "output": "[-14, -19, -25]"}, {"input": {"input_list": "[10, 10, -4]"}, "output": "[-32, -74, -130]"}, {"input": {"input_list": "[2, 0, 6]"}, "output": "[20, 42, 72]"}, {"input": {"input_list": "[1, 4, -6]"}, "output": "[-29, -65, -114]"}], "error_log": []}
{"context": "Given a number of iterations `n`, what is the value of the sum `S` calculated by iterating from 1 to `n`, where each term in the sum is given by the formula: \n\n\\[ S = \\sum_{k=1}^{n} \\frac{(-1)^k \\cdot (k^3 - 27)}{3 \\cdot (k+2)!} \\]\n\nThe result should be rounded to 6 decimal places.\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer representing the number of iterations for the calculation.\n\nOutput:\n  `return` (float): A float representing the calculated sum `S` with 6 decimal places.", "reference_code": "# import necessary packages\nimport random\nimport math\n\n# main function\ndef main_solution(n):\n    # Convert the input to the required type if necessary\n    n = int(n)\n    \n    # Initialize variables\n    k = 1\n    s = 0\n    \n    # Calculate the sum using the given formula\n    while k <= n:\n        s += ((-1)**k * (k**3 - 27)) / (3*math.factorial(k+2))\n        k += 1\n    \n    # Return the result as a float with 6 decimal places\n    return round(s, 6)", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(1, 20)\n    return {'n': n}", "io_pairs": [{"input": {"n": 18}, "output": 1.192515}, {"input": {"n": 20}, "output": 1.192515}, {"input": {"n": 19}, "output": 1.192515}, {"input": {"n": 2}, "output": 1.180556}, {"input": {"n": 1}, "output": 1.444444}, {"input": {"n": 7}, "output": 1.192476}, {"input": {"n": 16}, "output": 1.192515}, {"input": {"n": 10}, "output": 1.192515}, {"input": {"n": 11}, "output": 1.192515}, {"input": {"n": 13}, "output": 1.192515}], "error_log": []}
{"context": "Given a non-perfect square integer, what is the sum of the first 100 decimals of its square root when calculated using a specific sequence period and term?\n\nThe input and output requirements are as follows:\n\nInput:\n  `value` (int): The integer value for which the sequence period and decimals are to be calculated. Must be a non-perfect square.\n  `term` (int): The number of terms to consider in the sequence for calculating the decimals.\n\nOutput:\n  `return` (int): The sum of the first 100 decimals of the square root of the given `value`.", "reference_code": "# import necessary packages\nimport math\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef get_sequence_period(i):\n    sequence = [int(math.sqrt(i))]\n    num = -sequence[-1]\n    den = 1\n    orig_num = -num\n    orig_den = int(i - orig_num**2)\n    start = True\n\n    while True:\n        num = -num\n        den = int((i - num**2) / den)\n        if [orig_num, orig_den] == [num, den] and not start:\n            return sequence\n        # Finds the square root of the multiple of den that achieves the (num-den*mul)**2 closest to i\n        mul = int(((2 * num * den + math.sqrt(4 * (num**2) * (den**2) - 4 * (den**2) * ((num**2) - i))) / (2 * (den**2))))\n        sequence.append(mul)\n        num = num - den * mul\n\n        start = False\n\ndef decimals_n_value(value, term):\n    sequence = get_sequence_period(value)\n    sequence = sequence + (sequence[1:]) * (math.ceil(term / len(sequence[1:])))\n    a_num = sequence[0]\n    b_num = sequence[1] * sequence[0] + 1\n\n    a_den = 1\n    b_den = sequence[1]\n    for i in sequence[2:term]:\n        tmp_num = b_num\n        tmp_den = b_den\n        b_num = b_num * i + a_num\n        b_den = b_den * i + a_den\n        a_num = tmp_num\n        a_den = tmp_den\n    return b_num, b_den\n\ndef division(a, b):\n    quot = a // b\n    res = a % b\n    q = [quot]\n    while len(q) < 100:\n        if res < b:\n            res *= 10\n            while res < b:\n                res *= 10\n                q.append(0)\n        if len(q) == 100:\n            break\n        quot = res // b\n        res = res % b\n        q.append(quot)\n        if res == 0:\n            break\n    return q\n\n# main function\ndef main_solution(value, term):\n    # Convert JSON serializable inputs to the original input variables\n    value = int(value)\n    term = int(term)\n    \n    # Invoke the core logic\n    a, b = decimals_n_value(value, term)\n    decimals = division(a, b)\n    \n    # Convert the output to JSON serializable format\n    return sum(decimals)", "input_generator": "import random\nimport math\n\ndef input_generator():\n    non_square_numbers = [i for i in range(2, 100) if not math.isqrt(i) ** 2 == i]\n    value = random.choice(non_square_numbers)\n    term = random.randint(1, 50)\n    return {'value': value, 'term': term}", "io_pairs": [{"input": {"value": 20, "term": 26}, "output": 504}, {"input": {"value": 47, "term": 19}, "output": 447}, {"input": {"value": 38, "term": 9}, "output": 453}, {"input": {"value": 84, "term": 1}, "output": 598}, {"input": {"value": 5, "term": 28}, "output": 428}, {"input": {"value": 86, "term": 31}, "output": 444}, {"input": {"value": 65, "term": 48}, "output": 440}, {"input": {"value": 17, "term": 45}, "output": 441}, {"input": {"value": 63, "term": 4}, "output": 31}, {"input": {"value": 21, "term": 8}, "output": 460}], "error_log": []}
{"context": "Given a network of airports and their routes, which airports have the most flights? Specifically, identify the top 10 airports with the highest number of flights to or from other airports.\n\nThe input and output requirements are as follows:\n\nInput:\n  `nodes` (int): The number of nodes (airports) in the graph.\n  `edges` (int): The number of edges (routes) in the graph.\n\nOutput:\n  `return` (list of int): A list of node indices representing the top 10 airports with the most flights.", "reference_code": "# import necessary packages\nimport networkx as nx\nimport numpy as np\nimport copy as cp\n\n# all class and function definitions in the code file, if any\ndef random_graph(nodes, edges):\n    G = nx.Graph()\n    for n in range(nodes):\n        G.add_node(n)\n    e = 0\n    while e < edges:\n        u = np.random.randint(0, nodes)\n        v = np.random.randint(0, nodes)\n        if u != v and (u, v) not in G.edges and (v, u) not in G.edges:\n            G.add_edge(u, v)\n            e += 1\n    return G\n\n# main function\ndef main_solution(nodes, edges):\n    # Convert JSON serializable inputs to original input variables\n    G = random_graph(nodes, edges)\n    \n    # Compute the top 10 airports with the most flights\n    power_dict = {}\n    for node in G.nodes:\n        value = 0\n        for edge in G.edges(data=True):\n            (u, v, d) = edge\n            w = d.get('weight', 1)  # Default weight to 1 if not present\n            if node == edge[0] or node == edge[1]:\n                value += w\n        power_dict.setdefault(value, node)\n        \n    sorted_p = sorted(power_dict)[-10:]\n    sorted_p = reversed(sorted_p)\n\n    top_airports = []\n    for i in sorted_p:\n        top_airports.append(power_dict[i])\n    \n    # Return the top 10 airports with the most flights\n    return top_airports", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    nodes = random.randint(20, 100)\n    max_edges = min(nodes * (nodes - 1) // 2, 1000)  # Ensure reasonable number of edges\n    edges = random.randint(nodes, max_edges)\n    return {'nodes': nodes, 'edges': edges}", "io_pairs": [{"input": {"nodes": 50, "edges": 855}, "output": [0, 2, 15, 19, 3, 4, 5, 1, 14, 10]}, {"input": {"nodes": 30, "edges": 150}, "output": [1, 9, 20, 4, 11, 7, 3, 6, 13, 0]}, {"input": {"nodes": 97, "edges": 594}, "output": [56, 32, 40, 0, 13, 7, 3, 5, 33, 2]}, {"input": {"nodes": 70, "edges": 546}, "output": [17, 23, 11, 0, 19, 13, 16, 7, 3, 1]}, {"input": {"nodes": 50, "edges": 250}, "output": [1, 7, 13, 0, 16, 9, 4, 5, 2, 26]}, {"input": {"nodes": 26, "edges": 53}, "output": [5, 8, 1, 16, 3, 2, 0, 10]}, {"input": {"nodes": 33, "edges": 176}, "output": [32, 31, 4, 7, 3, 6, 12, 1, 21, 5]}, {"input": {"nodes": 22, "edges": 224}, "output": [0, 1, 15]}, {"input": {"nodes": 61, "edges": 787}, "output": [29, 32, 13, 18, 11, 4, 7, 2, 28, 0]}, {"input": {"nodes": 24, "edges": 89}, "output": [12, 16, 4, 0, 2, 3, 1, 20]}], "error_log": []}
{"context": "Given a computational art generation system that uses random functions to determine the color of each pixel in an image, what are the RGB values for a randomly selected pixel when the system is configured with specific minimum and maximum depths for the random functions, and the image dimensions are set to a certain width and height?\n\nThe input and output requirements are as follows:\n\nInput:\n  `min_depth` (int): The minimum depth of the random function.\n  `max_depth` (int): The maximum depth of the random function.\n  `x_size` (int): The width of the image.\n  `y_size` (int): The height of the image.\n\nOutput:\n  `return` (dict): A dictionary containing the RGB values for a specific pixel. The keys are \"red\", \"green\", and \"blue\", each with an integer value between 0 and 255.", "reference_code": "# import necessary packages\nfrom random import randint\nfrom math import cos, sin, pi\n\n# all class and function definitions in the code file, if any\ndef build_random_function(min_depth, max_depth):\n    \"\"\" Builds a random function of depth at least min_depth and depth\n        at most max_depth (see assignment writeup for definition of depth\n        in this context)\n\n        min_depth: the minimum depth of the random function\n        max_depth: the maximum depth of the random function\n        returns: the randomly generated function represented as a nested list\n                 (see assignment writeup for details on the representation of\n                 these functions)\n    \"\"\"\n    hello = ['x','y']\n    func = ['x','y','cos_pi','sin_pi','prod','square','average']\n    if max_depth == 1:\n        return hello[randint(0,1)]\n    else:\n        block = func[randint(2,6)]\n        if block == 'prod' or block == 'average': # accounts for when a block requires two inputs\n            return [block, build_random_function(min_depth-1, max_depth-1), build_random_function(min_depth-1, max_depth-1)]\n        else:\n           return [block, build_random_function(min_depth-1, max_depth-1)]\n\ndef evaluate_random_function(f, x, y):\n    \"\"\" Evaluate the random function f with inputs x,y\n        Representation of the function f is defined in the assignment writeup\n        f: the function to evaluate\n        x: the value of x to be used to evaluate the function\n        y: the value of y to be used to evaluate the function\n        returns: the function value\n    \"\"\"\n    if f[0] == 'x': # If the first index is x or y, we've already reached the innermost layer and can stop our recursion\n        return x\n    elif f[0] == 'y':\n        return y\n    elif f[0] == 'square':\n        return evaluate_random_function(f[1],x,y)**2\n    elif f[0] == 'average':\n        return (evaluate_random_function(f[1],x,y)+evaluate_random_function(f[2],x,y))/2\n    elif f[0] == 'cos_pi':\n        return cos(pi*evaluate_random_function(f[1],x,y))\n    elif f[0] == 'sin_pi':\n        return sin(pi*evaluate_random_function(f[1],x,y))\n    elif f[0] == 'prod':\n        return evaluate_random_function(f[1],x,y)*evaluate_random_function(f[2],x,y)\n\ndef remap_interval(val, input_interval_start, input_interval_end, output_interval_start, output_interval_end):\n    \"\"\" Given an input value in the interval [input_interval_start,\n        input_interval_end], return an output value scaled to fall within\n        the output interval [output_interval_start, output_interval_end].\n    \"\"\"\n    output_interval = float(output_interval_end - output_interval_start)\n    input_interval = float(input_interval_end - input_interval_start) # doesn't really matter which we float\n    scaled_val = (output_interval*(val - input_interval_start)/(input_interval)) + output_interval_start\n    return scaled_val\n\ndef color_map(val):\n    \"\"\" Maps input value between -1 and 1 to an integer 0-255, suitable for\n        use as an RGB color code.\n\n        val: value to remap, must be a float in the interval [-1, 1]\n        returns: integer in the interval [0,255]\n    \"\"\"\n    color_code = remap_interval(val, -1, 1, 0, 255)\n    return int(color_code)\n\n# main function\ndef main_solution(min_depth, max_depth, x_size, y_size):\n    \"\"\" Generates computational art by evaluating random functions for RGB channels.\n\n        min_depth: the minimum depth of the random function\n        max_depth: the maximum depth of the random function\n        x_size: the width of the image\n        y_size: the height of the image\n        returns: a dictionary with RGB values for a specific pixel (x, y)\n    \"\"\"\n    # Generate random functions for red, green, and blue channels\n    red_function = build_random_function(min_depth, max_depth)\n    green_function = build_random_function(min_depth, max_depth)\n    blue_function = build_random_function(min_depth, max_depth)\n\n    # Choose a specific pixel to evaluate\n    x = remap_interval(randint(0, x_size-1), 0, x_size, -1, 1)\n    y = remap_interval(randint(0, y_size-1), 0, y_size, -1, 1)\n\n    # Evaluate the functions for the chosen pixel\n    red_value = color_map(evaluate_random_function(red_function, x, y))\n    green_value = color_map(evaluate_random_function(green_function, x, y))\n    blue_value = color_map(evaluate_random_function(blue_function, x, y))\n\n    # Return the RGB values as a dictionary\n    return {\n        \"red\": red_value,\n        \"green\": green_value,\n        \"blue\": blue_value\n    }", "input_generator": "import random\nfrom random import randint\n\ndef input_generator():\n    min_depth = randint(1, 5)\n    max_depth = randint(min_depth, 10)\n    x_size = randint(10, 100)\n    y_size = randint(10, 100)\n    return {\n        \"min_depth\": min_depth,\n        \"max_depth\": max_depth,\n        \"x_size\": x_size,\n        \"y_size\": y_size\n    }", "io_pairs": [{"input": {"min_depth": 2, "max_depth": 4, "x_size": 11, "y_size": 81}, "output": {"red": 140, "green": 151, "blue": 130}}, {"input": {"min_depth": 1, "max_depth": 7, "x_size": 64, "y_size": 83}, "output": {"red": 202, "green": 246, "blue": 127}}, {"input": {"min_depth": 2, "max_depth": 4, "x_size": 70, "y_size": 24}, "output": {"red": 236, "green": 157, "blue": 127}}, {"input": {"min_depth": 4, "max_depth": 7, "x_size": 74, "y_size": 53}, "output": {"red": 128, "green": 252, "blue": 31}}, {"input": {"min_depth": 1, "max_depth": 7, "x_size": 86, "y_size": 97}, "output": {"red": 254, "green": 172, "blue": 206}}, {"input": {"min_depth": 5, "max_depth": 6, "x_size": 15, "y_size": 53}, "output": {"red": 94, "green": 138, "blue": 0}}, {"input": {"min_depth": 5, "max_depth": 7, "x_size": 36, "y_size": 70}, "output": {"red": 136, "green": 254, "blue": 167}}, {"input": {"min_depth": 1, "max_depth": 7, "x_size": 40, "y_size": 71}, "output": {"red": 127, "green": 179, "blue": 177}}, {"input": {"min_depth": 5, "max_depth": 9, "x_size": 76, "y_size": 39}, "output": {"red": 252, "green": 31, "blue": 172}}, {"input": {"min_depth": 2, "max_depth": 4, "x_size": 97, "y_size": 39}, "output": {"red": 254, "green": 74, "blue": 183}}], "error_log": []}
{"context": "In the context of space exploration, a rocket needs to achieve a certain velocity to escape the gravitational pull of a planet. Given the required velocity for a rocket to escape, what is the mass of the fuel required for the rocket to achieve this escape velocity?\n\nThe input and output requirements are as follows:\n\nInput:\n  `velocity` (float): The required velocity for the rocket to escape the planet, measured in meters per second (m/s).\n\nOutput:\n  `return` (float): The mass of the fuel required for the rocket, measured in kilograms (kg).", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(velocity):\n    \"\"\"\n    Calculate the mass of the fuel required for a rocket to escape the planet.\n    \n    Args:\n    velocity (float): The required velocity for the rocket to escape the planet.\n    \n    Returns:\n    float: The mass of the fuel required for the rocket.\n    \"\"\"\n    v_e = 2550  # exhaust velocity in m/s\n    mass_rocket = 250000  # mass of the rocket in kg\n    mass_fuel = mass_rocket * (math.exp(velocity / v_e) - 1)\n    return mass_fuel", "input_generator": "import random\n\ndef input_generator():\n    velocity = random.uniform(1000, 5000)\n    return {'velocity': velocity}", "io_pairs": [{"input": {"velocity": 3816.2505074225114}, "output": 866584.4921261718}, {"input": {"velocity": 3414.376421449333}, "output": 703779.0716300359}, {"input": {"velocity": 4924.319323156235}, "output": 1474282.9032712139}, {"input": {"velocity": 1842.5871568880843}, "output": 264936.7701106374}, {"input": {"velocity": 4863.9832044083105}, "output": 1433963.1493395714}, {"input": {"velocity": 3367.6444301452307}, "output": 686459.0482606669}, {"input": {"velocity": 2793.9604493398847}, "output": 497797.0983668288}, {"input": {"velocity": 3584.2818777415796}, "output": 769493.9484871748}, {"input": {"velocity": 4752.64917087691}, "output": 1362022.541357865}, {"input": {"velocity": 3302.5874024671593}, "output": 662869.7716283689}], "error_log": []}
{"context": "Given a set of triangles defined by their vertices, how many of these triangles contain the origin (0,0) within their interior?\n\nThe input and output requirements are as follows:\n\nInput:\n  `triangles` (list of lists): A list of triangles, where each triangle is represented as a list of six integers `[x0, y0, x1, y1, x2, y2]`. Each pair of integers represents the coordinates of a vertex of the triangle.\n\nOutput:\n  `return` (int): The number of triangles that contain the origin (0,0) within their interior.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef Area(x0, y0, x1, y1, x2, y2):\n    return 0.5 * (-y1 * x2 + y0 * (-x1 + x2) + x0 * (y1 - y2) + x1 * y2)\n\ndef S(x0, y0, x1, y1, x2, y2):\n    return 1 / (2 * Area(x0, y0, x1, y1, x2, y2)) * (y0 * x2 - x0 * y2)\n\ndef T(x0, y0, x1, y1, x2, y2):\n    return 1 / (2 * Area(x0, y0, x1, y1, x2, y2)) * (x0 * y1 - y0 * x1)\n\n# main function\ndef main_solution(triangles):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    count = 0\n    for triangle in triangles:\n        (x0, y0, x1, y1, x2, y2) = triangle\n        s = S(x0, y0, x1, y1, x2, y2)\n        t = T(x0, y0, x1, y1, x2, y2)\n        if s > 0 and t > 0 and 1 - s - t > 0:\n            count += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count", "input_generator": "import random\n\ndef input_generator():\n    num_triangles = random.randint(1, 20)\n    triangles = []\n    for _ in range(num_triangles):\n        # Generate three distinct points to form a triangle\n        x0, y0 = random.uniform(-10, 10), random.uniform(-10, 10)\n        x1, y1 = random.uniform(-10, 10), random.uniform(-10, 10)\n        x2, y2 = random.uniform(-10, 10), random.uniform(-10, 10)\n        # Ensure the points are not colinear (Area != 0)\n        while abs(0.5 * (-y1 * x2 + y0 * (-x1 + x2) + x0 * (y1 - y2) + x1 * y2)) < 1e-6:\n            x2, y2 = random.uniform(-10, 10), random.uniform(-10, 10)\n        triangles.append([x0, y0, x1, y1, x2, y2])\n    return {'triangles': triangles}", "io_pairs": [{"input": {"triangles": [[1.4409058213649377, -5.145740990026835, -7.140867781504843, -4.284496855826867, 5.885251716068771, 4.486527977823814], [-0.6633566484426563, -0.7963857956738849, 6.3463564489955, -0.8587376068261321, -5.620232089485572, 8.660603527257194]]}, "output": 2}, {"input": {"triangles": [[8.20768810368454, -6.827446940418911, 1.4538964808331905, -9.993644795974488, -3.6850509882687987, -1.7446345077966168]]}, "output": 0}, {"input": {"triangles": [[-0.12015629324783994, 9.099088395363005, -0.9658779088156493, -6.089541906642209, 9.001070437539859, -9.27116347155025]]}, "output": 1}, {"input": {"triangles": [[-7.8978808884301355, 7.622072857855041, 7.194208150705094, 5.716324968456988, -5.10143958053275, 5.247809290897456]]}, "output": 0}, {"input": {"triangles": [[5.329659884734351, 4.126316509856526, 7.303646967314368, -0.21568925086332946, -3.773066458619243, -9.022638037293824], [7.714498032885938, -8.11898839881011, -6.49773030759393, -8.681573288127062, 3.816050540832645, -8.109308796571433]]}, "output": 0}, {"input": {"triangles": [[-9.123114192757711, 6.348855188914598, 5.081861459664545, -5.614103547825899, 0.12643571037027712, 2.477669792023619], [7.775510222220515, 5.305069950974751, -0.8590868140538728, -7.980713070740817, 9.805547175910807, -9.589164373021434]]}, "output": 1}, {"input": {"triangles": [[-3.919142153694944, -3.45374197722818, -9.439747621635917, -9.831139575874792, 3.3881284376053316, 0.3953991423579595], [7.718482735089779, -0.29684862874431417, -0.1816133619402649, -1.0405977659664707, 8.435723950473623, -0.17642714813594473]]}, "output": 0}, {"input": {"triangles": [[1.9369628824117626, 3.8653733951071185, 3.1147070128263046, 3.474260406633089, -6.017517853771224, 6.6315030893388], [0.7686485733436079, -6.601006338136825, -2.65608114737093, -2.139003006107039, -3.088371018831751, 0.6348728741290639]]}, "output": 0}, {"input": {"triangles": [[-8.195602729658575, -9.475923000992521, -5.516805133242471, -5.504056415775209, -4.031865240979229, 5.285257444629487], [-4.357522692501807, 8.389512050146031, -3.6024924175715833, -0.49014791373620525, 9.550026410280058, 5.223587871427881]]}, "output": 0}, {"input": {"triangles": [[0.4333970568222405, 6.170915709166941, -9.55876711264162, 4.555060337762784, 1.9499356458246666, 4.103843476435525], [-0.3881281572250046, 2.6275203187659084, -9.787959145644802, 4.211038796089239, 3.2056701776561347, 1.3864964652827965]]}, "output": 0}], "error_log": []}
{"context": "Given a non-negative integer `m`, what is the fractional representation of the Bernoulli number B(m)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The non-negative integer for which the Bernoulli number B(m) is to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing the numerator and denominator of the Bernoulli number B(m) in its fractional form.\n    - `numerator` (int): The numerator of the Bernoulli number.\n    - `denominator` (int): The denominator of the Bernoulli number.", "reference_code": "# import necessary packages\nfrom math import factorial\nfrom fractions import Fraction\n\n# all class and function definitions in the code file, if any\nbinoDict = {}\nbernDict = {}\n\ndef binomial(n, r):\n    if (n, r) in binoDict:\n        return binoDict[(n, r)]\n    b = Fraction(factorial(n) // (factorial(r) * factorial(n-r)))\n    binoDict[(n, r)] = b\n    return b\n\ndef B(m):\n    if m == 0:\n        return Fraction(1, 1)\n    if m == 1:\n        return Fraction(1, 2)\n    if m % 2 == 1:\n        return 0\n    if m in bernDict:\n        return bernDict[m]\n    sigma = Fraction(0, 1)\n    for k in range(m):\n        sigma += binomial(m, k) * B(k) / (m - k + 1)\n    ans = Fraction(1, 1) - sigma\n    bernDict[m] = ans\n    return ans\n\n# main function\ndef main_solution(m):\n    # Convert input to Fraction if necessary\n    m = int(m)\n    \n    # Calculate the Bernoulli number\n    result = B(m)\n    \n    # Convert the result to a JSON serializable format\n    return {\"numerator\": result.numerator, \"denominator\": result.denominator}", "input_generator": "import random\nfrom fractions import Fraction\n\ndef input_generator():\n    m_options = [0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n    m = random.choice(m_options)\n    return {\"m\": m}", "io_pairs": [{"input": {"m": 0}, "output": {"numerator": 1, "denominator": 1}}, {"input": {"m": 12}, "output": {"numerator": -691, "denominator": 2730}}, {"input": {"m": 10}, "output": {"numerator": 5, "denominator": 66}}, {"input": {"m": 16}, "output": {"numerator": -3617, "denominator": 510}}, {"input": {"m": 1}, "output": {"numerator": 1, "denominator": 2}}, {"input": {"m": 14}, "output": {"numerator": 7, "denominator": 6}}, {"input": {"m": 20}, "output": {"numerator": -174611, "denominator": 330}}, {"input": {"m": 4}, "output": {"numerator": -1, "denominator": 30}}, {"input": {"m": 18}, "output": {"numerator": 43867, "denominator": 798}}, {"input": {"m": 8}, "output": {"numerator": -1, "denominator": 30}}], "error_log": []}
{"context": "In a secure communication system, two prime numbers `p` and `q` are used to encrypt a message `plainText` using a modified RSA algorithm. After encryption, the cipher text undergoes a series of modifications before being sent. On the receiver side, the cipher text is decrypted back to the original message. Given the prime numbers `p` and `q`, and the original message `plainText`, what is the decrypted message after the entire encryption and decryption process?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p` (int): A prime number used in the RSA algorithm.\n  `q` (int): Another prime number used in the RSA algorithm, different from `p`.\n  `plainText` (str): The plain text message to be encrypted and then decrypted. The string should only contain lowercase and uppercase English letters.\n\nOutput:\n  `return` (str): The decrypted text message, which should be the same as the input `plainText`.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# Checks if a number is prime or not\ndef isPrime(n):\n    if (n < 2): \n        return False\n    limit = int(math.sqrt(n))\n    for i in range(2, limit+1):\n        if n % i == 0:\n            return False\n    return True\n\n# Calculates the GCD of two numbers 'a' and 'b'\ndef gcd(a, b):\n    if (b == 0):\n        return a\n    return gcd(b, a % b)\n\n# Calculates the GCD of two numbers 'a' and 'b'\n# as well as coefficients 'x' and 'y' such that ax + by = GCD(a, b)\ndef egcd(a, b):\n    if (b == 0):\n        return [a, 1, 0]\n    else:\n        ans = egcd(b, a % b)\n        temp = ans[1] - ans[2] * (a // b)\n        ans[1] = ans[2]\n        ans[2] = temp\n        return ans\n\n# Calculates the multiplicative inverse\ndef multiplicativeInverse(a, b):\n    egcdArray = egcd(a, b)\n    bMultiplier = egcdArray[2]\n\n    if (bMultiplier < 0):\n        return (bMultiplier % a + a) % a\n    else:\n        return (bMultiplier % a)\n\n# Performs the exponentiation of large numbers (Binary Exponentiation)\ndef binaryPower(a, b, n):\n    if (b == 0):\n        return 1\n    result = binaryPower(a, int(b / 2), n)\n\n    # Odd power\n    if (b % 2 == 1):\n        return (result * result * a) % n\n    # Even power\n    else:\n        return (result * result) % n\n\n# Encrypts the plaintext (single integer)\ndef encrypt(M, e, n):\n    C = binaryPower(M, e, n) % n\n    return C\n\n# Decrypts the cipher text (single integer)\ndef decrypt(C, e, n):\n    M = binaryPower(C, e, n) % n\n    return M\n\n# Converts a string to list of corresponding numbers in Unicode\ndef stringToNumber(s):\n    nums = []\n    for i in s:\n        if (i.isupper()):\n            nums.append((ord(i) - 65 + 26))\n        else:\n            nums.append((ord(i) - 97))\n    return nums\n\n# Converts a list of numbers in Unicode to string\ndef numberToString(numList):\n    s = ''\n    for num in numList:\n        if (num > 25):\n            s += chr(num + 65 - 26)\n        else:\n            s += chr(num + 97)\n    return s\n\n# Performs right shift on the cipher text\n# by a specified number of bits\ndef shiftRightCipher(cipherText, p, q):\n    bits = math.ceil(max(p, q) / min(p, q))\n\n    # Modify each cipher in the list\n    for i in range(0, len(cipherText)):\n        cipherText[i] = (cipherText[i] * bits) + abs(p - q) \n\n    # Shuffle the cipher array \n    shiftPoint = (bits) % len(cipherText)\n    result = cipherText[shiftPoint : ] + cipherText[ : shiftPoint]\n    return result\n\n# Performs left shift on the cipher text\n# by a specified number of bits\ndef shiftLeftCipher(cipherText, p, q):\n    bits = math.ceil(max(p, q) / min(p, q))\n\n    # Regain each cipher in the list\n    for i in range(0, len(cipherText)):\n        cipherText[i] = int((cipherText[i] - abs(p - q)) / bits)\n\n    # Shuffle the array of ciphers\n    shiftPoint = (len(cipherText) - bits) % len(cipherText)\n    result = cipherText[shiftPoint : ] + cipherText[ : shiftPoint]\n    return result\n\n# Encrypts a string of characters\ndef encryptString(plainText, publicKey, p, q):\n    cipherList = []\n    # Converting plaintext(string) to numList(number)\n    numList = stringToNumber(plainText)\n    \n    for number in numList:\n        # Plain text (M < n)\n        M = number\n        C = encrypt(M, publicKey[0], publicKey[1])\n        cipherList.append(C)\n    \n    # Modifying cipherList\n    modifiedCipher = shiftRightCipher(cipherList, p, q)\n    return modifiedCipher\n\n# Decrypts a string of characters\ndef decryptString(cipherText, privateKey, p, q):\n    # Regaining the original cipher\n    cipherList = shiftLeftCipher(cipherText, p, q)\n    decryptList = []\n    \n    for cipher in cipherList:\n        M = decrypt(cipher, privateKey[0], privateKey[1])\n        decryptList.append(M)\n\n    # Converting decryptList(number) to decryptText(string)\n    decryptText = numberToString(decryptList)\n    return decryptText\n\n# Performs initial RSA steps\ndef initializeRSA(p, q):\n    # Calculation of n\n    n = p * q\n\n    # Calculation of phi(n)\n    phi = (p - 1) * (q - 1)\n\n    # Select integer e such that gcd(phi, e) = 1\n    for e in range(2, phi):\n        if (gcd(phi, e) == 1):\n            break\n\n    # Calculaiton of d\n    d = multiplicativeInverse(phi, e)\n\n    # Public and private keys\n    publicKey = [e, n]\n    privateKey = [d, n]\n\n    return publicKey, privateKey\n\n# main function\ndef main_solution(p, q, plainText):\n    # Ensure p and q are prime and different\n    if not isPrime(p) or not isPrime(q) or p == q:\n        raise ValueError(\"p and q must be different prime numbers.\")\n    \n    # Initialize RSA\n    publicKey, privateKey = initializeRSA(p, q)\n    \n    # Encrypt the plain text\n    cipherText = encryptString(plainText, publicKey, p, q)\n    \n    # Decrypt the cipher text\n    decryptedText = decryptString(cipherText, privateKey, p, q)\n    \n    # Return the decrypted text\n    return decryptedText", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate two distinct primes p and q between 100 and 1000\n    primes = []\n    for num in range(100, 1000):\n        if all(num % i != 0 for i in range(2, int(math.sqrt(num)) + 1)):\n            primes.append(num)\n    p, q = random.sample(primes, 2)\n    \n    # Generate a random plaintext string of length between 5 and 20\n    length = random.randint(5, 20)\n    plainText = ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', k=length))\n    \n    return {'p': p, 'q': q, 'plainText': plainText}", "io_pairs": [{"input": {"p": 137, "q": 947, "plainText": "ImwBowfyUqdWse"}, "output": "ImwBowfyUqdWse"}, {"input": {"p": 463, "q": 563, "plainText": "CvhcAgVLqmehiwlXyr"}, "output": "CvhcAgVLqmehiwlXyr"}, {"input": {"p": 919, "q": 461, "plainText": "AdTGnIoiHrAruT"}, "output": "AdTGnIoiHrAruT"}, {"input": {"p": 443, "q": 787, "plainText": "BUDQTHoAGUxnsVeD"}, "output": "BUDQTHoAGUxnsVeD"}, {"input": {"p": 359, "q": 103, "plainText": "xkSOhqXxJZhqnf"}, "output": "xkSOhqXxJZhqnf"}, {"input": {"p": 691, "q": 907, "plainText": "SVvFtjCCbI"}, "output": "SVvFtjCCbI"}, {"input": {"p": 659, "q": 127, "plainText": "vHRHANtFbQm"}, "output": "vHRHANtFbQm"}, {"input": {"p": 229, "q": 389, "plainText": "KamcPKPOklfsP"}, "output": "KamcPKPOklfsP"}, {"input": {"p": 953, "q": 683, "plainText": "ApsKxAbTkHOOzdRH"}, "output": "ApsKxAbTkHOOzdRH"}, {"input": {"p": 449, "q": 919, "plainText": "qQcDpjzIOXfXcpdEekIU"}, "output": "qQcDpjzIOXfXcpdEekIU"}], "error_log": []}
{"context": "In a Minesweeper game, a player attempts to clear a rectangular board containing hidden mines without detonating any of them. Each square on the board can either contain a mine or be empty. If a square is empty, it displays the number of mines in the surrounding eight squares. Given the dimensions of the board and the coordinates of a square to be revealed, what is the state of the board after revealing that square?\n\nThe input and output requirements are as follows:\n\nInput:\n- `cols` (int): The number of columns in the Minesweeper board.\n- `rows` (int): The number of rows in the Minesweeper board.\n- `reveal_x` (int): The x-coordinate (column index) of the square to be revealed.\n- `reveal_y` (int): The y-coordinate (row index) of the square to be revealed.\n\nOutput:\n- `return` (list of lists of int): A 2D list representing the Minesweeper board. Each element in the list is an integer:\n  - `-1` if the square is not revealed.\n  - The number of surrounding mines if the square is revealed.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Square():\n    def __init__(self, state, revealed, value, x, y):\n        self.state = state\n        self.revealed = revealed\n        self.value = value\n        self.x, self.y = x, y\n\n    def render_square(self):\n        if self.revealed:\n            return str(self.value)\n        else:\n            return '-'\n\nclass Squares():\n    def __init__(self, cols, rows):\n        cols, rows = int(cols), int(rows)\n        self.board = [[Square(False, False, 0, x, y) for x in range(cols)] for y in range(rows)]\n        self.total_squares = cols * rows\n        self.__randomize_mines(cols, rows, self.board)\n        self.__calculate_values(cols, rows, self.board)\n\n    def __randomize_mines(self, cols, rows, board):\n        self.total_mines = int(self.total_squares / 4)\n        remaining_mines = self.total_mines\n        xrange, yrange = range(cols), range(rows)\n\n        while remaining_mines > 0:\n            x, y = random.choice(xrange), random.choice(yrange)\n            if not board[y][x].state:\n                board[y][x].state = True\n                remaining_mines -= 1\n\n    def __calculate_values(self, cols, rows, board):\n        deltas = [\n            (-1, -1), (0, 1), (1, 1),\n            (-1, 0), (1, 0),\n            (-1, 1), (0, -1), (1, -1),\n        ]\n        for y in range(rows):\n            for x in range(cols):\n                if board[y][x].state:\n                    for delta in deltas:\n                        dx, dy = x + delta[0], y + delta[1]\n                        if self.__is_within_range(dx, dy, cols, rows):\n                            board[dy][dx].value += 1\n\n    def __is_within_range(self, x, y, cols, rows):\n        return x >= 0 and x < cols and y >= 0 and y < rows\n\n# main function\ndef main_solution(cols, rows, reveal_x, reveal_y):\n    # Initialize the game board\n    game = Squares(cols, rows)\n    \n    # Reveal the specified square\n    game.board[reveal_y][reveal_x].revealed = True\n    \n    # Collect the revealed values of the board\n    revealed_values = []\n    for row in game.board:\n        revealed_values.append([square.value if square.revealed else -1 for square in row])\n    \n    # Return the revealed values of the board\n    return revealed_values", "input_generator": "import random\n\ndef input_generator():\n    cols = random.randint(5, 15)\n    rows = random.randint(5, 15)\n    reveal_x = random.randint(0, cols - 1)\n    reveal_y = random.randint(0, rows - 1)\n    return {'cols': cols, 'rows': rows, 'reveal_x': reveal_x, 'reveal_y': reveal_y}", "io_pairs": [{"input": {"cols": 6, "rows": 5, "reveal_x": 0, "reveal_y": 0}, "output": [[0, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]}, {"input": {"cols": 5, "rows": 5, "reveal_x": 3, "reveal_y": 1}, "output": [[-1, -1, -1, -1, -1], [-1, -1, -1, 1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1]]}, {"input": {"cols": 6, "rows": 6, "reveal_x": 3, "reveal_y": 0}, "output": [[-1, -1, -1, 0, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]}, {"input": {"cols": 5, "rows": 6, "reveal_x": 4, "reveal_y": 2}, "output": [[-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, 2], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1]]}, {"input": {"cols": 6, "rows": 5, "reveal_x": 5, "reveal_y": 2}, "output": [[-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, 1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]}, {"input": {"cols": 5, "rows": 6, "reveal_x": 3, "reveal_y": 5}, "output": [[-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, 2, -1]]}, {"input": {"cols": 8, "rows": 5, "reveal_x": 4, "reveal_y": 1}, "output": [[-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, 3, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1]]}, {"input": {"cols": 8, "rows": 6, "reveal_x": 2, "reveal_y": 4}, "output": [[-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, 2, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1]]}, {"input": {"cols": 5, "rows": 6, "reveal_x": 3, "reveal_y": 2}, "output": [[-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, 4, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1], [-1, -1, -1, -1, -1]]}, {"input": {"cols": 8, "rows": 5, "reveal_x": 7, "reveal_y": 2}, "output": [[-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, 1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1]]}], "error_log": []}
{"context": "Given a puzzle configuration represented as a 2D list, and a specified heuristic, what is the calculated score of the puzzle based on the heuristic? The puzzle is a square grid of a given side length, and the heuristic can be one of 'manhattan', 'hamming', or 'sietse'.\n\nThe input and output requirements are as follows:\n\nInput:\n  `puzzle` (list of lists of integers): A 2D list representing the puzzle configuration. Each sublist represents a row in the puzzle.\n  `side_length` (integer): The side length of the puzzle, which is the number of rows or columns.\n  `heuristic` (string): The heuristic to use for scoring. Possible values are 'manhattan', 'hamming', or 'sietse'.\n\nOutput:\n  `return` (integer): The calculated score of the puzzle based on the specified heuristic.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Puzzle:\n    def __init__(self, puzzle=None, parent=None, side_length=3, gen_solution=False, move_made=None):\n        if puzzle != None:\n            self.puzzle = [row.copy() for row in puzzle]\n        else:\n            self.puzzle = None\n        self.parent = parent\n        self.score = 0\n        self.h_score = 0\n        self.g_score = 0\n        self.side_length = side_length\n        self.move_made = move_made\n        if (gen_solution == True):\n            self.generate_snail_solution(self.gen_empty_puzzle(side_length), 1, 0, 0, 'right')\n        else:\n            self.snail_solution = None\n    \n    def is_solvable(self):\n        inversions = 0\n        res = []\n        sol = []\n\n        for y in range(len(self.puzzle)):\n            for x in range(len(self.puzzle[y])):\n                res.append(self.puzzle[y][x])\n\n        for y in range(len(self.snail_solution)):\n            for x in range(len(self.snail_solution[y])):\n                sol.append(self.snail_solution[y][x])\n\n        for i in range(len(res)):\n            for j in range(i + 1, len(res)):\n                if sol.index(res[i]) > sol.index(res[j]):\n                    inversions += 1\n\n        if len(self.puzzle) % 2 == 0:\n            if inversions % 2 != 0:\n                return (False)\n            else:\n                return (True)\n        else:\n            if inversions % 2 == 0:\n                return (False)\n            else:\n                return (True)\n\n    def give_score(self, g_score, heur='manhattan'):\n        self.g_score = g_score\n        score = 0\n\n        if (heur == 'hamming'):\n            for y in range(len(self.puzzle)):\n                for x in range(len(self.puzzle)):\n                    if self.puzzle[y][x] != self.snail_solution[y][x] and self.puzzle[y][x] != 0:\n                        score += 1\n        elif (heur == 'manhattan') or (heur == 'sietse'):\n            for y in range(len(self.puzzle)):\n                for x in range(len(self.puzzle)):\n                    score += manhattan_distance(self.puzzle, self.snail_solution, y, x)\n        if (heur == 'sietse'):\n            pairs = []\n            for y in range(len(self.puzzle)):\n                for x in range(len(self.puzzle)):\n                    if self.puzzle[y][x] != self.snail_solution[y][x] and self.puzzle[y][x] != 0 and self.snail_solution[y][x] != 0:\n                        pairs.append([self.puzzle[y][x], self.snail_solution[y][x]])\n            for pair in pairs:\n                if pair[::-1] in pairs:\n                    score += 1\n        self.h_score = score\n\n        self.score = self.g_score + self.h_score\n\n    def set_side_length(self, side_length):\n        self.side_length = side_length\n    \n    def gen_empty_puzzle(self, side_length):\n        return ([[0 for x in range(side_length)] for x in range(side_length)])\n\n    def generate_snail_solution(self, puzzle, ctr, y, x, direction):\n        if ctr == (self.side_length * self.side_length):\n            self.snail_solution = puzzle\n        else:\n            if direction == 'right':\n                while x < len(puzzle) and puzzle[y][x] == 0:\n                    puzzle[y][x] = ctr\n                    ctr += 1\n                    x += 1\n                self.generate_snail_solution(puzzle, ctr, y + 1, x - 1, 'down')\n            elif direction == 'down':\n                while y < len(puzzle) and puzzle[y][x] == 0:\n                    puzzle[y][x] = ctr\n                    ctr += 1\n                    y += 1\n                self.generate_snail_solution(puzzle, ctr, y - 1, x - 1, 'left')\n            elif direction == 'left':\n                while x >= 0 and puzzle[y][x] == 0:\n                    puzzle[y][x] = ctr\n                    ctr += 1\n                    x -= 1\n                self.generate_snail_solution(puzzle, ctr, y - 1, x + 1, 'up')\n            elif direction == 'up':\n                while y >= 0 and puzzle[y][x] == 0:\n                    puzzle[y][x] = ctr\n                    ctr += 1\n                    y -= 1\n                self.generate_snail_solution(puzzle, ctr, y + 1, x + 1, 'right')\n\ndef manhattan_distance(puzzle, solution, y, x):\n    for i in range(len(solution)):\n        for j in range(len(solution[i])):\n            if solution[i][j] == puzzle[y][x]:\n                return (abs(i - y) + abs(j - x))\n\n# main function\ndef main_solution(puzzle, side_length, heuristic):\n    # Convert input to JSON serializable format\n    puzzle = [[int(x) for x in row] for row in puzzle]\n    side_length = int(side_length)\n    heuristic = str(heuristic)\n\n    # Initialize the Puzzle object\n    puzzle_obj = Puzzle(puzzle=puzzle, side_length=side_length, gen_solution=True)\n\n    # Calculate the score using the given heuristic\n    puzzle_obj.give_score(0, heur=heuristic)\n\n    # Return the score as a JSON serializable output\n    return puzzle_obj.score", "input_generator": "import random\n\ndef input_generator():\n    side_length = random.choice([3, 4])\n    heuristic = random.choice(['manhattan', 'hamming', 'sietse'])\n    \n    # Generate a solvable puzzle\n    puzzle = [[0 for _ in range(side_length)] for _ in range(side_length)]\n    numbers = list(range(1, side_length * side_length)) + [0]\n    random.shuffle(numbers)\n    \n    for i in range(side_length):\n        for j in range(side_length):\n            puzzle[i][j] = numbers.pop()\n    \n    # Ensure the puzzle is solvable by swapping if necessary\n    puzzle_obj = Puzzle(puzzle=puzzle, side_length=side_length, gen_solution=True)\n    if not puzzle_obj.is_solvable():\n        # Swap two non-zero elements to make it solvable\n        non_zero = []\n        for i in range(side_length):\n            for j in range(side_length):\n                if puzzle[i][j] != 0:\n                    non_zero.append((i, j))\n        if len(non_zero) >= 2:\n            a, b = random.sample(non_zero, 2)\n            puzzle[a[0]][a[1]], puzzle[b[0]][b[1]] = puzzle[b[0]][b[1]], puzzle[a[0]][a[1]]\n    \n    return {\n        'puzzle': puzzle,\n        'side_length': side_length,\n        'heuristic': heuristic\n    }", "io_pairs": [], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, given the current state of the board and which player is currently making the move, what is the best move and its corresponding score according to the minimax algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_state` (list of int): A list of 9 integers representing the current state of the Tic-Tac-Toe board. Each integer can be -1 (O), 0 (empty), or 1 (X).\n  `max_player` (bool): A boolean indicating whether the current player is the maximizing player (True) or the minimizing player (False).\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `score` (int): The score of the best move determined by the minimax algorithm.\n    - `move` (int): The index of the best move on the board (0-8).", "reference_code": "# import necessary packages\nfrom copy import deepcopy\nfrom random import randint\n\n# all class and function definitions in the code file, if any\nclass Board(object):\n    def __init__(self):\n        self.board = [0 for _ in range(9)]\n\n    def winner(self):\n        def winning_line(a, b, c):\n            if (\n                self.board[a] != 0 and\n                self.board[a] == self.board[b] == self.board[c]\n            ):\n                return self.board[a]\n\n        lines = [\n            [0, 1, 2], [3, 4, 5], [6, 7, 8],\n            [0, 3, 6], [1, 4, 7], [2, 5, 8],\n            [0, 4, 8], [2, 4, 6]]\n\n        for a, b, c in lines:\n            res = winning_line(a, b, c)\n            if res:\n                return res\n\n    def valid_moves(self):\n        return [i for i in range(9) if self.board[i] == 0]\n\n    def is_full(self):\n        return len(self.valid_moves()) == 0\n\n    def apply(self, i, player):\n        self.board[i] = player\n\n    def __str__(self):\n        def x(i):\n            r = { -1 : 'O', 0 : '.', 1: 'X'}\n            return r[self.board[i]]\n\n        return '%s %s %s\\n%s %s %s\\n%s %s %s' % (\n            x(0), x(1), x(2), x(3), x(4), x(5), x(6), x(7), x(8))\n\n\ndef minimax(board, max_player):\n    winner = board.winner()\n    if winner:\n        return winner, None\n\n    best_move, best_score = None, 0\n    player = 1 if max_player else -1\n\n    for move in board.valid_moves():\n        new_board = deepcopy(board)\n        new_board.apply(move, player)\n        score, _ = minimax(new_board, not max_player)\n        # if the move is a winning move, pick it, and return\n        if score == player:\n            return player, move\n        if best_move is None:\n            best_score = score\n            best_move = move\n        else:\n            if (\n                (max_player and score > best_score) or\n                (not max_player and score < best_score)\n            ):\n                best_score = score\n                best_move = move\n\n    return best_score, best_move\n\n# main function\ndef main_solution(board_state, max_player):\n    # Convert JSON serializable input to original input variables\n    board = Board()\n    board.board = board_state\n\n    # Apply the minimax algorithm to determine the best move\n    score, move = minimax(board, max_player)\n\n    # Convert the output to JSON serializable format\n    return {\"score\": score, \"move\": move}", "input_generator": "import random\nfrom random import randint\n\ndef input_generator():\n    board_state = [0] * 9\n    max_player = random.choice([True, False])\n    \n    # Randomly fill some positions with -1 or 1, ensuring no winner\n    for i in range(random.randint(0, 5)):\n        pos = random.choice([idx for idx, val in enumerate(board_state) if val == 0])\n        board_state[pos] = random.choice([-1, 1])\n    \n    # Ensure no winner\n    def has_winner(board):\n        lines = [\n            [0, 1, 2], [3, 4, 5], [6, 7, 8],\n            [0, 3, 6], [1, 4, 7], [2, 5, 8],\n            [0, 4, 8], [2, 4, 6]\n        ]\n        for a, b, c in lines:\n            if board[a] != 0 and board[a] == board[b] == board[c]:\n                return True\n        return False\n    \n    while has_winner(board_state):\n        board_state = [0] * 9\n        for i in range(random.randint(0, 5)):\n            pos = random.choice([idx for idx, val in enumerate(board_state) if val == 0])\n            board_state[pos] = random.choice([-1, 1])\n    \n    return {\"board_state\": board_state, \"max_player\": max_player}", "io_pairs": [{"input": {"board_state": [-1, 0, 0, 0, 0, 0, 0, 0, 0], "max_player": true}, "output": {"score": 0, "move": 4}}, {"input": {"board_state": [0, 0, -1, 0, 1, 1, 0, 0, 1], "max_player": true}, "output": {"score": 1, "move": 0}}, {"input": {"board_state": [1, 0, 0, -1, 0, -1, 0, 1, -1], "max_player": false}, "output": {"score": -1, "move": 1}}, {"input": {"board_state": [1, -1, 0, 0, 0, 1, 0, -1, 1], "max_player": false}, "output": {"score": -1, "move": 4}}, {"input": {"board_state": [0, 0, 1, 0, 1, 0, -1, 1, 1], "max_player": false}, "output": {"score": 1, "move": 0}}, {"input": {"board_state": [0, 0, 0, 0, 0, 0, 0, 0, 0], "max_player": true}, "output": {"score": 0, "move": 0}}, {"input": {"board_state": [0, 0, 0, 0, 0, 0, 0, 1, -1], "max_player": true}, "output": {"score": 0, "move": 0}}, {"input": {"board_state": [0, 0, 0, 0, 1, 0, 0, 0, 0], "max_player": false}, "output": {"score": 0, "move": 0}}, {"input": {"board_state": [0, 0, -1, 0, 0, 0, 0, 0, 0], "max_player": true}, "output": {"score": 0, "move": 4}}, {"input": {"board_state": [0, 1, 0, 0, 1, 1, 0, -1, 0], "max_player": true}, "output": {"score": 1, "move": 0}}], "error_log": []}
{"context": "In a historical game of elimination, a group of people stand in a circle. Starting from a given person, every k-th person is eliminated until only one person remains. Given the number of people in the circle and the step count, which position in the circle will be the last remaining person?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of people in the circle.\n  `k` (int): The step count to eliminate the next person.\n\nOutput:\n  `return` (int): The position of the last remaining person in the circle.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef josephus_problem(array, k, index):\n    if len(array) == 1:\n        return array[0]\n    index = (index + k) % len(array)\n    array.pop(index)\n    return josephus_problem(array, k, index)\n\n# main function\ndef main_solution(n, k):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    array = [i for i in range(1, n + 1)]\n    index = 0\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = josephus_problem(array, k - 1, index)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 100)\n    k = random.randint(1, n)\n    return {'n': n, 'k': k}", "io_pairs": [{"input": {"n": 15, "k": 8}, "output": 15}, {"input": {"n": 23, "k": 6}, "output": 17}, {"input": {"n": 45, "k": 19}, "output": 14}, {"input": {"n": 24, "k": 16}, "output": 20}, {"input": {"n": 74, "k": 5}, "output": 8}, {"input": {"n": 59, "k": 59}, "output": 44}, {"input": {"n": 91, "k": 69}, "output": 61}, {"input": {"n": 58, "k": 29}, "output": 21}, {"input": {"n": 72, "k": 46}, "output": 1}, {"input": {"n": 34, "k": 25}, "output": 26}], "error_log": []}
{"context": "In an egg washing system, the valve position is determined by the level of dirt on the eggs and the flow rate of the washing system. Given the level of dirt on the eggs (`EggDirt`) and the flow rate of the washing system (`FlowRate`), what is the optimal valve position for the washing system?\n\nThe input and output requirements are as follows:\n\nInput:\n  `EggDirt` (float): The level of dirt on the eggs, ranging from 0.0 (no dirt) to 1.0 (very dirty).\n  `FlowRate` (float): The flow rate of the washing system, ranging from 0.0 (no flow) to 1.0 (maximum flow).\n\nOutput:\n  `return` (float): The calculated valve position for the washing system, rounded to two decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\nclass IdentityFunction:\n    def __init__(self, name, a, m, n, b):\n        self.name = name\n        self.a = a\n        self.m = m\n        self.n = n\n        self.b = b\n\n    @classmethod\n    def MakeSymmetricalTriangle(cls, name, a, b):\n        m = (a + b) / 2\n        return cls(name, a, m, m, b)\n\n    @classmethod\n    def MakeTriangle(cls, name, a, m, b):\n        return cls(name, a, m, m, b)\n\n    @classmethod\n    def MakeTrapazoid(cls, name, a, m, n, b):\n        return cls(name, a, m, n, b)\n\n    def GetName(self):\n        return self.name\n    \n    def GetMidPoint(self):\n        return (self.m + self.n) / 2\n\n    def Calculate(self, v):\n        if v < self.a:\n            return 0\n        elif v < self.m:\n            return (v - self.a) / (self.m - self.a)\n        elif v < self.n:\n            return 1\n        elif v < self.b:\n            return (self.b - v) / (self.b - self.n)\n        else:\n            return 0\n\nclass FuzzyOperator:\n    @staticmethod\n    def FuzzAnd(a, b):\n        return min(a, b)\n\n    @staticmethod \n    def FuzzOr(a, b):\n        return max(a, b)\n\n# main function\ndef main_solution(EggDirt, FlowRate):\n    # Define the membership functions for the Egg Wash system\n    EggDirtLow = IdentityFunction.MakeSymmetricalTriangle(\"Low\", 0.0, 0.5)\n    EggDirtAcceptable = IdentityFunction.MakeSymmetricalTriangle(\"Acceptable\", 0.25, 0.75)\n    EggDirtHigh = IdentityFunction.MakeSymmetricalTriangle(\"High\", 0.5, 1.0)\n\n    FlowRateLow = IdentityFunction.MakeSymmetricalTriangle(\"Low\", 0.0, 0.75)\n    FlowRateHigh = IdentityFunction.MakeSymmetricalTriangle(\"High\", 0.25, 1.0)\n\n    ValvePositionLow = IdentityFunction.MakeSymmetricalTriangle(\"Low\", 0.0, 0.5)\n    ValvePositionMedium = IdentityFunction.MakeSymmetricalTriangle(\"Medium\", 0.25, 0.75)\n    ValvePositionHigh = IdentityFunction.MakeSymmetricalTriangle(\"High\", 0.5, 1.0)\n\n    # Step 1 Fuzzification\n    EggDirtLowDOM = EggDirtLow.Calculate(EggDirt)\n    EggDirtAcceptableDOM = EggDirtAcceptable.Calculate(EggDirt)\n    EggDirtHighDOM = EggDirtHigh.Calculate(EggDirt)\n\n    FlowRateLowDOM = FlowRateLow.Calculate(FlowRate)\n    FlowRateHighDOM = FlowRateHigh.Calculate(FlowRate)\n\n    # Aggregation\n    PositionLow1 = FuzzyOperator.FuzzAnd(EggDirtLowDOM, FlowRateLowDOM)\n    PositionLow2 = FuzzyOperator.FuzzAnd(EggDirtLowDOM, FlowRateHighDOM)\n    PositionMedimum1 = EggDirtAcceptableDOM\n    PositionHigh1 = FuzzyOperator.FuzzAnd(EggDirtHighDOM, FlowRateLowDOM)\n    PositionHigh2 = FuzzyOperator.FuzzAnd(EggDirtHighDOM, FlowRateHighDOM)\n\n    # Composition\n    PositionLowDOM = FuzzyOperator.FuzzOr(PositionLow1, PositionLow2)\n    PositionMedimumDOM = PositionMedimum1\n    PositionHighDOM = FuzzyOperator.FuzzOr(PositionHigh1, PositionHigh2)\n\n    # Defuzzification\n    ValvePosition = PositionLowDOM * ValvePositionLow.GetMidPoint() + PositionMedimumDOM * ValvePositionMedium.GetMidPoint() + PositionHighDOM * ValvePositionHigh.GetMidPoint()\n    \n    return round(ValvePosition, 2)", "input_generator": "import random\n\ndef input_generator():\n    EggDirt = random.uniform(0.0, 1.0)\n    FlowRate = random.uniform(0.0, 1.0)\n    return {'EggDirt': EggDirt, 'FlowRate': FlowRate}", "io_pairs": [{"input": {"EggDirt": 0.004642439298164325, "FlowRate": 0.43122496859630166}, "output": 0.0}, {"input": {"EggDirt": 0.24601725424924603, "FlowRate": 0.08317169909829591}, "output": 0.06}, {"input": {"EggDirt": 0.24052893719998603, "FlowRate": 0.4092904458211417}, "output": 0.23}, {"input": {"EggDirt": 0.9750482084236354, "FlowRate": 0.5007430582017016}, "output": 0.07}, {"input": {"EggDirt": 0.1599161684985384, "FlowRate": 0.18658321328605432}, "output": 0.12}, {"input": {"EggDirt": 0.9441396703134721, "FlowRate": 0.7718910837381955}, "output": 0.17}, {"input": {"EggDirt": 0.03694226552067681, "FlowRate": 0.5960634271054195}, "output": 0.04}, {"input": {"EggDirt": 0.58219688884288, "FlowRate": 0.17657750197559696}, "output": 0.58}, {"input": {"EggDirt": 0.8907478134832979, "FlowRate": 0.6325683026998612}, "output": 0.33}, {"input": {"EggDirt": 0.7729881530823004, "FlowRate": 0.36356220537828}, "output": 0.68}], "error_log": []}
{"context": "Given a chessboard of size N\u00d7N, where N is the number of queens to be placed, determine the positions on the board where the queens can be placed such that no two queens can attack each other. The positions should be determined based on a given chance parameter that controls the iteration over the board positions. What are the positions where the queens can be safely placed?\n\nThe input and output requirements are as follows:\n\nInput:\n  `queens` (int): The number of queens to place on the board.\n  `chance` (int): A parameter to control the iteration over the board positions.\n\nOutput:\n  `return` (List[List[int]]): A list of positions where queens are placed. Each position is represented as a list of two integers `[row, column]`.", "reference_code": "# import necessary packages\nfrom typing import List, Generator\n\n# all class and function definitions in the code file, if any\ndef position_Generator(n: int = 4) -> Generator[List[int], None, None]:\n    \"\"\"\n    generator to send back a position [0, 0]\n    :param n: number of queens\n    :return: yields a position in the chess\n    \"\"\"\n    return ([i, j] for i in range(0, n) for j in range(0, n))\n\ndef horizontal_attack(pos: List[int], h_queens: int) -> List[List[int]]:\n    \"\"\"\n    attack the position horizontally and sends back a list of death\n    :param h_queens: number of queens\n    :param pos: position to attack from with the queen\n    :return: list of deaths\n    \"\"\"\n    list_deaths = []\n    pos_gen = position_Generator(h_queens)\n    while True:\n        try:\n            new_pos = next(pos_gen)\n        except StopIteration:\n            break\n        if pos == new_pos:\n            continue\n        if pos[0] == new_pos[0]:\n            list_deaths.append(new_pos)\n    return list_deaths\n\ndef vertical_attack(pos: List[int], v_queens: int) -> List[List[int]]:\n    \"\"\"\n    attack the position vertically and sends back a list of death\n    :param v_queens: number of queens\n    :param pos: position to attack from with the queen\n    :return: list of deaths\n    \"\"\"\n    list_deaths = []\n    pos_gen = position_Generator(v_queens)\n    while True:\n        try:\n            new_pos = next(pos_gen)\n        except StopIteration:\n            break\n        if pos == new_pos:\n            continue\n        if pos[1] == new_pos[1]:\n            list_deaths.append(new_pos)\n    return list_deaths\n\ndef diagonal_attack(pos: List[int], d_queens: int) -> List[List[int]]:\n    \"\"\"\n    attack the position diagonal and sends back a list of death\n    :param d_queens: number of queens\n    :param pos: position to attack from with the queen\n    :return: list of deaths\n    \"\"\"\n    list_deaths = []\n    pos_gen = position_Generator(d_queens)\n    while True:\n        try:\n            new_pos = next(pos_gen)\n        except StopIteration:\n            break\n        if pos == new_pos:\n            continue\n        if pos[0] + pos[1] == new_pos[0] + new_pos[1]:\n            list_deaths.append(new_pos)\n        if pos[0] - new_pos[0] == pos[1] - new_pos[1]:\n            list_deaths.append(new_pos)\n    return list_deaths\n\ndef has_horse_distance(pos: List[int], temp_queens: List[List[int]], queens: int) -> bool:\n    \"\"\"\n    check if current square is a horse movement distance from last queen\n    :param queens: number of queen to accommodate\n    :param pos: current position\n    :param temp_queens: previous queen position\n    :return: false if not a distance of horse else true\n    \"\"\"\n    pre_queen = temp_queens[-1]\n    if pre_queen[1] == queens - 3 and pos[1] != queens - 1:\n        return False\n\n    for queen in temp_queens:\n        if pos == queen:\n            return True\n        if pos[0] - 1 == queen[0] and pos[1] - 2 == queen[1]:\n            return True\n        elif pos[0] - 2 == queen[0] and pos[1] - 1 == queen[1]:\n            return True\n        elif pos[0] - 2 == queen[0] and pos[1] + 1 == queen[1]:\n            return True\n        elif pos[0] - 1 == queen[0] and pos[1] + 2 == queen[1]:\n            return True\n        elif pos[0] + 1 == queen[0] and pos[1] + 2 == queen[1]:\n            return True\n        elif pos[0] + 2 == queen[0] and pos[1] + 1 == queen[1]:\n            return True\n        elif pos[0] + 2 == queen[0] and pos[1] - 1 == queen[1]:\n            return True\n        elif pos[0] + 1 == queen[0] and pos[1] - 2 == queen[1]:\n            return True\n    return False\n\n# main function\ndef main_solution(queens: int, chance: int) -> List[List[int]]:\n    \"\"\"\n    Main function to solve the N-Queens puzzle with a given number of queens and a chance parameter.\n    :param queens: Number of queens to place on the board.\n    :param chance: A parameter to control the iteration over the board positions.\n    :return: List of positions where queens are placed.\n    \"\"\"\n    queen_positions = []\n    it = position_Generator(queens)\n    list_death = []\n    \n    for k in range(0, chance):\n        try:\n            next(it)\n        except StopIteration:\n            break\n\n    while True:\n        try:\n            square = next(it)\n        except StopIteration:\n            break\n\n        if not queen_positions:\n            queen_positions.append(square)\n\n        if has_horse_distance(square, queen_positions, queens):\n            if square not in list_death:\n                for dead in horizontal_attack(square, queens):\n                    list_death.append(dead)\n                for dead in vertical_attack(square, queens):\n                    list_death.append(dead)\n                for dead in diagonal_attack(square, queens):\n                    list_death.append(dead)\n                if square not in queen_positions:\n                    queen_positions.append(square)\n\n    return queen_positions", "input_generator": "import random\n\ndef input_generator():\n    queens = random.randint(4, 8)  # Reasonable board size between 4x4 and 8x8\n    chance = random.randint(0, queens * queens - 1)  # Chance within the range of possible squares\n    return {'queens': queens, 'chance': chance}", "io_pairs": [{"input": {"queens": 8, "chance": 53}, "output": [[6, 5], [7, 7]]}, {"input": {"queens": 8, "chance": 16}, "output": [[2, 0], [3, 2], [4, 4], [5, 1], [6, 3]]}, {"input": {"queens": 4, "chance": 10}, "output": [[2, 2], [3, 0]]}, {"input": {"queens": 4, "chance": 9}, "output": [[2, 1], [3, 3]]}, {"input": {"queens": 6, "chance": 16}, "output": [[2, 4], [3, 2], [4, 0], [5, 3]]}, {"input": {"queens": 5, "chance": 2}, "output": [[0, 2], [1, 4], [2, 1], [3, 3], [4, 0]]}, {"input": {"queens": 6, "chance": 15}, "output": [[2, 3], [3, 5], [4, 2], [5, 0]]}, {"input": {"queens": 6, "chance": 26}, "output": [[4, 2], [5, 0]]}, {"input": {"queens": 7, "chance": 26}, "output": [[3, 5], [4, 3], [5, 1], [6, 4]]}, {"input": {"queens": 8, "chance": 45}, "output": [[5, 5], [6, 7], [7, 4]]}], "error_log": []}
{"context": "The Collatz Conjecture is a famous unsolved problem in mathematics. It states that for any positive integer \\( n \\), if you repeatedly apply the following rules:\n1. If \\( n \\) is even, divide it by 2.\n2. If \\( n \\) is odd, multiply it by 3 and add 1.\n\nEventually, you will always reach the number 1. Given an upper limit \\( t \\), can you verify if the Collatz Conjecture holds true for all numbers up to \\( t \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `t` (int): The upper limit up to which the Collatz Conjecture should be verified. It should be a positive integer.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the Collatz Conjecture holds true up to the given limit `t`. Returns `True` if the conjecture holds, otherwise `False`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef collatz(x, col):\n    if x in col:\n        return True\n    else:\n        if x % 2:\n            c = collatz(3 * x + 1, col)\n            if c:\n                col.add(x)\n                return c\n        else:\n            c = collatz(x // 2, col)\n            if c:\n                col.add(x)\n                return c\n\ndef CollatzVerifyTo(t, col):\n    for i in range(1, t):\n        if not collatz(i, col):\n            return False\n    return True\n\n# main function\ndef main_solution(t):\n    # Convert JSON serializable input to original input variables\n    col = {4}\n    \n    # Invoke the core function\n    result = CollatzVerifyTo(t, col)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    t = random.randint(5, 1000)\n    return {'t': t}", "io_pairs": [{"input": {"t": 522}, "output": true}, {"input": {"t": 635}, "output": true}, {"input": {"t": 572}, "output": true}, {"input": {"t": 363}, "output": true}, {"input": {"t": 637}, "output": true}, {"input": {"t": 301}, "output": true}, {"input": {"t": 705}, "output": true}, {"input": {"t": 577}, "output": true}, {"input": {"t": 185}, "output": true}, {"input": {"t": 885}, "output": true}], "error_log": []}
{"context": "Given an angle in radians, how can we determine the sine value using both a built-in mathematical function and a custom iterative approach? Specifically, what are the sine values calculated using the built-in `sin` function and the custom `mans_sinuss` function for a given angle `x`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): The input angle in radians for which the sine function is to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `builtin_sin` (float): The sine value of `x` calculated using the built-in `sin` function, rounded to 2 decimal places.\n    - `custom_sin` (float): The sine value of `x` calculated using the custom `mans_sinuss` function, rounded to 2 decimal places.", "reference_code": "# import necessary packages\nfrom math import sin\n\n# all class and function definitions in the code file, if any\ndef mans_sinuss(x):\n    k = 0\n    a = (-1)**0 * x**1 / (1)\n    S = a\n\n    while k < 500:\n        k += 1\n        R = (-1) * x * x / ((2 * k) * (2 * k + 1))\n        a = a * R\n        S += a\n\n    return S\n\n# main function\ndef main_solution(x):\n    # Convert the input to a float if necessary\n    x = float(x)\n    \n    # Calculate the sine value using the built-in function\n    y = sin(x)\n    \n    # Calculate the sine value using the custom function\n    custom_sin = mans_sinuss(x)\n    \n    # Return the results as a dictionary\n    return {\n        \"builtin_sin\": round(y, 2),\n        \"custom_sin\": round(custom_sin, 2)\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random float between -2*pi and 2*pi for reasonable sine calculation\n    x = random.uniform(-2 * math.pi, 2 * math.pi)\n    return {\"x\": x}", "io_pairs": [{"input": {"x": 4.724640296919333}, "output": {"builtin_sin": -1.0, "custom_sin": -1.0}}, {"input": {"x": -5.394316214442142}, "output": {"builtin_sin": 0.78, "custom_sin": 0.78}}, {"input": {"x": 1.1314530513015857}, "output": {"builtin_sin": 0.91, "custom_sin": 0.91}}, {"input": {"x": 2.365784447247659}, "output": {"builtin_sin": 0.7, "custom_sin": 0.7}}, {"input": {"x": 1.1145490292124034}, "output": {"builtin_sin": 0.9, "custom_sin": 0.9}}, {"input": {"x": -4.359031084519488}, "output": {"builtin_sin": 0.94, "custom_sin": 0.94}}, {"input": {"x": -2.247272585480909}, "output": {"builtin_sin": -0.78, "custom_sin": -0.78}}, {"input": {"x": 1.5586425897266647}, "output": {"builtin_sin": 1.0, "custom_sin": 1.0}}, {"input": {"x": -5.819353766468989}, "output": {"builtin_sin": 0.45, "custom_sin": 0.45}}, {"input": {"x": -2.494976769940182}, "output": {"builtin_sin": -0.6, "custom_sin": -0.6}}], "error_log": []}
{"context": "Given a vector space of dimension `d`, a probability `prob`, a sigma value `sigma`, and a vector `x` of `d` values, what is the value of the discriminant function computed using these inputs?\n\nThe input and output requirements are as follows:\n\nInput:\n  `d` (int): The dimension of the vector space.\n  `prob` (float): The probability value between 0 and 1.\n  `sigma` (float): The sigma value for the discriminant function.\n  `x` (list of float): A list of `d` float values representing the vector `x`.\n\nOutput:\n  `return` (float): The value of the discriminant function.", "reference_code": "# import necessary packages\nimport random\nimport numpy as np\n\n# main function\ndef main_solution(d, prob, sigma, x):\n    # Convert input variables to appropriate types if necessary\n    d = int(d)\n    prob = float(prob)\n    sigma = float(sigma)\n    x = list(map(float, x))\n    \n    # creating a random mean vector of dimension d \n    mean = [random.randrange(-10, 10) for _ in range(d)]\n    \n    # Computing discriminant function\n    dis = np.log(prob)\n    for i in range(d):\n        x[i] -= mean[i]\n    dis += -0.5 * np.power(np.linalg.norm(x), 2) / np.power(sigma, 2)\n    \n    # Convert output to JSON serializable format\n    dis = float(dis)\n    \n    return dis", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    d = random.randint(1, 10)\n    prob = random.uniform(0.01, 0.99)\n    sigma = random.uniform(0.1, 5.0)\n    x = [random.uniform(-10.0, 10.0) for _ in range(d)]\n    return {'d': d, 'prob': prob, 'sigma': sigma, 'x': x}", "io_pairs": [{"input": {"d": 2, "prob": 0.58651884677867, "sigma": 1.7079258905180443, "x": [9.004493522170606, -0.9817765270117462]}, "output": -15.15629403795504}, {"input": {"d": 7, "prob": 0.48034040864101085, "sigma": 1.347363129483582, "x": [3.7685406587428023, -1.3666127963870611, -1.0712865693455793, -0.8824980835004741, 8.868644797129711, 7.623330407546998, -3.943452063414636]}, "output": -109.59367241821128}, {"input": {"d": 10, "prob": 0.8365207315720303, "sigma": 1.4650971972682765, "x": [0.3355954064787259, -5.027635585134531, -5.704033260971306, -0.8688625989082297, 0.3048956115829231, 1.3781917044942222, 0.06192492120693416, -7.203240551542313, 8.723240720722742, 7.695382939144103]}, "output": -140.59251706571573}, {"input": {"d": 7, "prob": 0.882391069852662, "sigma": 1.1776222781985908, "x": [-7.358842367221197, 5.405395470965127, -4.44310141610333, -4.920118872434558, -2.8141480274498987, 4.0763778731824, -6.340889467637085]}, "output": -137.26704878701477}, {"input": {"d": 4, "prob": 0.34351570623777694, "sigma": 1.2938528582440658, "x": [7.880323559777793, 4.159587680631521, -5.914614812732186, -5.441833804145981]}, "output": -55.38880892699943}, {"input": {"d": 7, "prob": 0.818510025876552, "sigma": 4.285598041689693, "x": [-2.35041005384212, 4.895138526047058, -3.265017160565204, 7.92052384485665, -7.93975138824099, -3.4682215238375758, -9.005406185578595]}, "output": -9.815959064586169}, {"input": {"d": 9, "prob": 0.6925297950553944, "sigma": 4.6442084016776555, "x": [-1.0693454034715941, 5.971858512985309, -0.7581597748675328, -4.8740122340481555, 0.3711326222426141, 6.815677439652369, 0.580131940575356, -1.7775551264515492, -6.7347260173017]}, "output": -9.358365343708233}, {"input": {"d": 4, "prob": 0.39297941586036067, "sigma": 4.4444721053215455, "x": [-8.341117268566443, -8.496461003169468, -7.709153508194637, -1.7047545139875098]}, "output": -17.307612437380644}, {"input": {"d": 9, "prob": 0.5865123483425305, "sigma": 4.238832823591057, "x": [2.1302334239824177, 9.395291010178727, -3.292018219929435, -7.9927234529163655, -4.543514394969483, 3.145587035843107, -7.258095306452235, 3.702157714850509, 1.222008234324468]}, "output": -15.271282730058294}, {"input": {"d": 1, "prob": 0.685281300524581, "sigma": 2.813195526392362, "x": [0.40464471212257713]}, "output": -0.4003193993720545}], "error_log": []}
{"context": "Given a mountain represented by a 2D grid where each cell contains an elevation value, determine the longest path that can be skied, starting from any point on the mountain, with the largest difference in elevation. The skier can only move to adjacent cells (north, south, east, or west) with a lower elevation. What is the sequence of elevations that form this longest path with the largest drop?\n\nThe input and output requirements are as follows:\n\nInput:\n  `grid` (list of lists of integers): A 2D grid representing the elevation map of the mountain. Each element in the grid represents the elevation at that point.\n\nOutput:\n  `return` (list of integers): A list representing the longest path with the largest difference in elevation. Each element in the list represents the elevation at a point in the path.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef getSuccessorState(px, py, grid, x, y):\n    if px < 0 or px > x-1 or py < 0 or py > y-1:\n        raise ValueError(\"Invalid point given!\")\n    options = []\n    currentElevation = grid[py][px]\n    # West option\n    if px > 0 and currentElevation > grid[py][px-1]:\n        options.append((py, px-1))\n    # East option\n    if px < x-1 and currentElevation > grid[py][px+1]:\n        options.append((py, px+1))\n    # South option\n    if py < y-1 and currentElevation > grid[py+1][px]:\n        options.append((py+1, px))\n    # North option\n    if py > 0 and currentElevation > grid[py-1][px]:\n        options.append((py-1, px))\n    return options\n\ndef dp_dfs(px, py, grid, x, y, record):\n    if (py, px) in record:\n        return record[(py, px)]\n    nextStates = getSuccessorState(px, py, grid, x, y)\n    currentElevation = grid[py][px]\n    if not nextStates:\n        return [[currentElevation]]\n    localCopy = []\n    for coords in nextStates:\n        newy, newx = coords\n        if (newy, newx) in record:\n            cache = record[(newy, newx)]\n            for route in cache:\n                newRoute = [currentElevation]\n                newRoute.extend(route)\n                localCopy.append(newRoute)\n            continue\n        possibleRoutes = dp_dfs(newx, newy, grid, x, y, record)\n        for route in possibleRoutes:\n            newRoute = list(route)\n            newRoute.insert(0, currentElevation)\n            localCopy.append(newRoute)\n    record[(py, px)] = localCopy\n    return localCopy\n\ndef selectLargestDiff(paths):\n    diff = [paths[i][0] - paths[i][-1] for i in range(len(paths))]\n    maxDiff = max(diff)\n    return [paths[i] for i in range(len(paths)) if diff[i] == maxDiff]\n\n# main function\ndef main_solution(grid):\n    x = len(grid[0])\n    y = len(grid)\n    record = {}\n    possiblePaths = {}\n    currentMax = float(\"-inf\")\n    \n    for i in range(y):\n        for j in range(x):\n            temp = dp_dfs(j, i, grid, x, y, record)\n            if not temp:\n                continue\n            for path in temp:\n                if not path:\n                    continue\n                length = len(path)\n                if length < currentMax:\n                    continue\n                currentMax = length\n                if length in possiblePaths:\n                    possiblePaths[length].append(path)\n                else:\n                    possiblePaths[length] = [path]\n    \n    ans = selectLargestDiff(possiblePaths[currentMax])[0]\n    return ans", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(3, 10)\n    cols = random.randint(3, 10)\n    grid = []\n    for _ in range(rows):\n        row = [random.randint(1, 100) for _ in range(cols)]\n        grid.append(row)\n    return {'grid': grid}", "io_pairs": [{"input": {"grid": [[70, 54, 89, 54], [92, 39, 30, 54], [76, 38, 28, 56]]}, "output": [92, 70, 54, 39, 30, 28]}, {"input": {"grid": [[35, 5, 56], [53, 91, 13], [90, 60, 81]]}, "output": [91, 53, 35, 5]}, {"input": {"grid": [[53, 15, 74], [41, 93, 12], [20, 11, 81]]}, "output": [93, 41, 20, 11]}, {"input": {"grid": [[44, 95, 94, 5], [31, 88, 48, 80], [15, 27, 66, 95]]}, "output": [95, 44, 31, 15]}, {"input": {"grid": [[19, 17, 99], [48, 72, 18], [26, 45, 17], [26, 71, 22]]}, "output": [72, 48, 19, 17]}, {"input": {"grid": [[75, 60, 3, 96], [42, 64, 2, 90], [66, 69, 64, 62]]}, "output": [69, 64, 60, 3, 2]}, {"input": {"grid": [[69, 34, 3], [14, 10, 54], [86, 53, 73]]}, "output": [86, 53, 10]}, {"input": {"grid": [[27, 61, 50], [23, 92, 5], [28, 13, 19]]}, "output": [92, 61, 50, 5]}, {"input": {"grid": [[83, 68, 94], [78, 93, 88], [75, 94, 86]]}, "output": [94, 93, 78, 75]}, {"input": {"grid": [[10, 1, 54, 69], [34, 42, 96, 42], [6, 54, 51, 5]]}, "output": [96, 42, 34, 10, 1]}], "error_log": []}
{"context": "Given a matrix with `m` rows and `n` columns, where each element is a real number, what is the Frobenius norm of the matrix? The Frobenius norm is defined as the square root of the sum of the squares of all the elements in the matrix.\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The number of rows in the matrix.\n  `n` (int): The number of columns in the matrix.\n  `a` (list of lists of floats): The matrix represented as a list of lists, where each inner list represents a row of the matrix.\n\nOutput:\n  `return` (float): The Frobenius norm of the matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(m, n, a):\n  # Convert the input list to a numpy array\n  a_np = np.array(a)\n  \n  # Compute the Frobenius norm of the matrix\n  value = np.sqrt(np.sum(a_np ** 2))\n  \n  # Return the Frobenius norm as a float\n  return float(value)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    m = random.randint(1, 10)\n    n = random.randint(1, 10)\n    a = np.random.rand(m, n).tolist()\n    return {'m': m, 'n': n, 'a': a}", "io_pairs": [{"input": {"m": 3, "n": 1, "a": [[0.6989164699786634], [0.692821545095215], [0.6715319540155821]]}, "output": 1.1914029925342402}, {"input": {"m": 1, "n": 9, "a": [[0.8976822841002258, 0.04315286513853056, 0.6208572498879602, 0.1171579435952863, 0.4390570332478225, 0.4161196400068877, 0.9396144403464135, 0.9400540413597339, 0.13136167278681699]]}, "output": 1.8321148383626078}, {"input": {"m": 2, "n": 1, "a": [[0.10098547686292791], [0.1079651566233567]]}, "output": 0.14783281632282763}, {"input": {"m": 1, "n": 8, "a": [[0.5121034533264458, 0.5263576089283621, 0.1924730975244492, 0.03891109538395765, 0.4955853376109224, 0.3549321898109047, 0.24691629899200385, 0.08953693806873919]]}, "output": 1.0091721628175339}, {"input": {"m": 1, "n": 1, "a": [[0.019584264921558625]]}, "output": 0.019584264921558625}, {"input": {"m": 2, "n": 3, "a": [[0.3183665700313767, 0.8101217344493108, 0.38492440255301685], [0.5650570518108007, 0.38906910052987076, 0.49045483846296634]]}, "output": 1.2716255260812719}, {"input": {"m": 2, "n": 3, "a": [[0.746541879359237, 0.8465374420917446, 0.22867503545439116], [0.3800321688729189, 0.5562767928979733, 0.8608606009393321]]}, "output": 1.587826182012773}, {"input": {"m": 4, "n": 2, "a": [[0.12420298751818126, 0.4806312908050494], [0.27941375724122997, 0.23174010450085258], [0.560657770113978, 0.7459373100565886], [0.3667909156873239, 0.9566494556442895]]}, "output": 1.5161403978913017}, {"input": {"m": 2, "n": 6, "a": [[0.14994554948764782, 0.18570904909050856, 0.706165954193225, 0.36673534253493956, 0.9331399670097285, 0.6227142189851824], [0.7278988956452654, 0.45411213750922463, 0.8198728402059478, 0.526500109855301, 0.519883447352417, 0.6743218110161815]]}, "output": 2.0878450758500557}, {"input": {"m": 1, "n": 9, "a": [[0.9783207681431133, 0.5428168966642217, 0.20640750310841816, 0.24908422393970764, 0.7282710657744995, 0.1589193889739503, 0.16762427294357118, 0.12334620686429854, 0.7863360046430597]]}, "output": 1.604269095227252}], "error_log": []}
{"context": "In a game of Tic Tac Toe, a player (either human or computer) needs to make the best possible move based on the current state of the board. Given the current state of the board, the symbol ('X' or 'O') of the player, and whether the player is a computer, what is the best move the player should make?\n\nThe input and output requirements are as follows:\n\nInput:\n- `gameBoard` (list of str): A list representing the current state of the Tic Tac Toe board. Each element can be either 'X', 'O', or '_' (empty). The list has exactly 9 elements.\n- `playerSymbol` (str): A string representing the symbol ('X' or 'O') of the player whose move is being calculated.\n- `isComputer` (bool): A boolean indicating whether the player is a computer (True) or a human (False).\n\nOutput:\n- `return` (dict): A dictionary containing the following keys:\n  - `value` (int): The value of the best move calculated by the alpha-beta pruning algorithm.\n  - `place` (int): The index (0-8) of the best move on the game board.", "reference_code": "# import necessary packages\nfrom random import randrange\n\n# all class and function definitions in the code file, if any\nclass Player(object):\n    def __init__(self, symbol, isComputer):\n        self.symbol = symbol\n        self.isComputer = isComputer\n    \n    def play(self, gameBoard):\n        if self.isComputer:\n            depth, alpha, beta, isMax = 9 - gameBoard.count('_'), -10, 10, True\n            value, place = self.alphaBeta(gameBoard, depth, alpha, beta, isMax)\n        else:\n            place = int(input('Enter a number from 1 to 9: ')) - 1\n            while self.isInvalid(gameBoard, place):\n                place = int(input('Enter again: ')) - 1\n\n        gameBoard[place] = self.symbol\n\n    def alphaBeta(self, gameBoard, depth, alpha, beta, isMaxPlayer):\n        value = checkIfWon(gameBoard, self.symbol)\n        if value != 0:\n            return value, -1\n        if depth == 0:\n            return value, -1\n        if isMaxPlayer:\n            value = -10\n            listOfNumbers = list(range(9))\n            while listOfNumbers:\n                random = listOfNumbers.pop(randrange(len(listOfNumbers)))\n                if gameBoard[random] == '_':\n                    gameBoard[random] = self.symbol\n                    temp_value = self.alphaBeta(gameBoard, depth - 1, alpha, beta, False)[0]\n                    if temp_value > value:\n                        value = temp_value\n                        place = random\n                    alpha = max(alpha, value)\n                    gameBoard[random] = '_'\n                    if alpha >= beta:\n                        break\n        else:\n            value = 10\n            listOfNumbers = list(range(9))\n            while listOfNumbers:\n                random = listOfNumbers.pop(randrange(len(listOfNumbers)))\n                if gameBoard[random] == '_':\n                    gameBoard[random] = self.symbol\n                    temp_value = self.alphaBeta(gameBoard, depth - 1, alpha, beta, True)[0]\n                    if temp_value < value:\n                        value = temp_value\n                        place = random\n                    beta = min(beta, value)\n                    gameBoard[random] = '_'\n                    if beta <= alpha:\n                        break\n        return value, place\n\n    def isInvalid(self, gameBoard, place):\n        if place not in list(range(9)):\n            return True\n        if gameBoard[place] != '_':\n            return True\n        return False\n\n    def isSymbolX(self):\n        return self.symbol == 'X'\n\ndef checkIfWon(gameBoard, symbol):\n    symbolToNumber = {'X': 1, 'O': -1, '_': 0}\n    gameState = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    \n    for i in range(3):\n        for j in range(3):\n            gameState[i][j] = symbolToNumber[gameBoard[i * 3 + j]]\n    \n    for i in range(3):\n        rowcount, colcount = 0, 0\n        for j in range(3):\n            rowcount += gameState[i][j]\n            colcount += gameState[j][i]\n        if rowcount == -3 or colcount == -3:\n            return -1\n        if rowcount == 3 or colcount == 3:\n            return 1\n    if gameState[1][1] == -1:\n        if (gameState[0][0] == -1 and gameState[2][2] == -1) or (gameState[0][2] == -1 and gameState[2][0] == -1):\n            return -1\n    if gameState[1][1] == 1:\n        if (gameState[0][0] == 1 and gameState[2][2] == 1) or (gameState[0][2] == 1 and gameState[2][0] == 1):\n            return 1\n\n    return 0\n\n# main function\ndef main_solution(gameBoard, playerSymbol, isComputer):\n    # Convert JSON serializable inputs to original input variables\n    player = Player(playerSymbol, isComputer)\n    \n    # Core solution code\n    depth, alpha, beta, isMax = 9 - gameBoard.count('_'), -10, 10, True\n    value, place = player.alphaBeta(gameBoard, depth, alpha, beta, isMax)\n    \n    # Convert output to JSON serializable\n    return {\"value\": value, \"place\": place}", "input_generator": "import random\nfrom random import choice, randint\n\ndef input_generator():\n    symbols = ['X', 'O']\n    playerSymbol = choice(symbols)\n    isComputer = choice([True, False])\n    \n    # Generate a random game board with some moves already made\n    gameBoard = ['_'] * 9\n    num_moves = randint(0, 4)  # Up to 4 moves already made\n    for _ in range(num_moves):\n        empty_positions = [i for i, x in enumerate(gameBoard) if x == '_']\n        if empty_positions:\n            pos = choice(empty_positions)\n            gameBoard[pos] = choice(symbols)\n    \n    return {\n        \"gameBoard\": gameBoard,\n        \"playerSymbol\": playerSymbol,\n        \"isComputer\": isComputer\n    }", "io_pairs": [{"input": {"gameBoard": ["_", "_", "_", "_", "_", "_", "O", "O", "X"], "playerSymbol": "O", "isComputer": true}, "output": {"value": 0, "place": 5}}, {"input": {"gameBoard": ["_", "_", "_", "_", "_", "O", "_", "_", "_"], "playerSymbol": "X", "isComputer": false}, "output": {"value": 0, "place": 4}}, {"input": {"gameBoard": ["X", "O", "_", "_", "_", "_", "_", "_", "_"], "playerSymbol": "X", "isComputer": true}, "output": {"value": 0, "place": 6}}, {"input": {"gameBoard": ["_", "_", "_", "X", "_", "_", "_", "_", "O"], "playerSymbol": "O", "isComputer": true}, "output": {"value": 0, "place": 1}}, {"input": {"gameBoard": ["_", "_", "_", "_", "_", "_", "_", "_", "_"], "playerSymbol": "O", "isComputer": true}, "output": {"value": 0, "place": -1}}, {"input": {"gameBoard": ["_", "_", "_", "_", "_", "_", "_", "_", "_"], "playerSymbol": "X", "isComputer": true}, "output": {"value": 0, "place": -1}}, {"input": {"gameBoard": ["_", "_", "_", "_", "X", "_", "_", "_", "_"], "playerSymbol": "O", "isComputer": true}, "output": {"value": 0, "place": 0}}, {"input": {"gameBoard": ["_", "_", "_", "_", "X", "_", "_", "_", "_"], "playerSymbol": "X", "isComputer": false}, "output": {"value": 0, "place": 8}}, {"input": {"gameBoard": ["_", "X", "_", "_", "O", "_", "_", "_", "_"], "playerSymbol": "O", "isComputer": false}, "output": {"value": 0, "place": 7}}, {"input": {"gameBoard": ["O", "_", "_", "_", "_", "X", "_", "_", "_"], "playerSymbol": "X", "isComputer": true}, "output": {"value": 0, "place": 4}}], "error_log": []}
{"context": "Given a square matrix, what is the maximum modulo eigenvalue and the corresponding eigenvector when calculated with a specified accuracy?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_str` (str): A string representation of a square matrix, where elements are separated by commas and rows by semicolons.\n  `eps` (float): The desired accuracy for the eigenvalue calculation.\n\nOutput:\n  `return` (dict): A dictionary containing the maximum modulo eigenvalue and the corresponding eigenvector. The dictionary has the following keys:\n    - `eigenvalue` (float): The maximum modulo eigenvalue of the matrix.\n    - `eigenvector` (list of floats): The corresponding eigenvector as a list of floats.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef power_iteration_m(A, eps):\n    \"\"\"Find the maximum modulo eigenvalue with a given accuracy.\n\n    This function applies a scalar product to accelerate convergence.\n\n    Arguments:\n    A -- square matrix\n    eps -- accuracy\n    \"\"\"\n\n    vector = np.random.rand(A.shape[0])\n    value = np.random.rand()\n    diff = 2 * eps\n    while eps < diff:\n        next_vector1 = np.dot(A, vector)\n        next_vector2 = np.dot(A.T, vector)\n        next_value = np.dot(next_vector1, next_vector2) / np.dot(vector, next_vector2)\n        diff = abs(next_value - value)\n        \n        value = next_value\n        vector = next_vector1\n\n    return value, vector / np.linalg.norm(vector, ord=2)\n\ndef power_iteration(A, eps):\n    \"\"\"Find the maximum modulo eigenvalue with a given accuracy.\n    \n    Arguments:\n    A -- square matrix\n    eps -- accuracy\n    \"\"\"\n    vector = np.random.rand(A.shape[0])\n    value = np.random.rand()\n    diff = 2 * eps\n    while eps < diff:\n        next_vector = np.dot(A, vector)\n        next_value = next_vector[0] / vector[0]\n        diff = abs(next_value - value)\n\n        value = next_value\n        vector = next_vector\n\n    return value, vector / np.linalg.norm(vector, ord=2)\n\n# main function\ndef main_solution(matrix_str, eps):\n    \"\"\"\n    Find the maximum modulo eigenvalue of a given square matrix using the power iteration method.\n\n    Arguments:\n    matrix_str (str): A string representation of a square matrix, where elements are separated by commas and rows by semicolons.\n    eps (float): The desired accuracy for the eigenvalue calculation.\n\n    Returns:\n    dict: A dictionary containing the maximum modulo eigenvalue and the corresponding eigenvector.\n    \"\"\"\n    # Convert the matrix string to a numpy array\n    A = np.array([list(map(float, row.split(','))) for row in matrix_str.split(';')])\n    \n    # Use the power_iteration_m function to find the eigenvalue and eigenvector\n    eigenvalue, eigenvector = power_iteration_m(A, eps)\n    \n    # Convert the eigenvector to a list for JSON serialization\n    eigenvector = eigenvector.tolist()\n    \n    return {\"eigenvalue\": eigenvalue, \"eigenvector\": eigenvector}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose matrix size between 2x2 and 5x5\n    n = random.randint(2, 5)\n    \n    # Generate a random square matrix with elements between -10 and 10\n    A = np.random.uniform(-10, 10, (n, n))\n    \n    # Convert matrix to string representation\n    matrix_str = ';'.join([','.join([f\"{x:.4f}\" for x in row]) for row in A])\n    \n    # Generate a random epsilon between 1e-6 and 1e-3\n    eps = 10 ** random.uniform(-6, -3)\n    \n    return {\"matrix_str\": matrix_str, \"eps\": eps}", "io_pairs": [{"input": {"matrix_str": "-2.0695,-5.2490,-0.5173;7.0771,-8.5740,-5.2887;8.6434,-1.5038,-8.8979", "eps": 1.1849242425895016e-06}, "output": {"eigenvalue": NaN, "eigenvector": [0.0, 0.0, 0.0]}}, {"input": {"matrix_str": "-9.0481,-5.5390,-6.1756;-2.1388,-7.7604,-0.1434;1.3283,-0.1569,8.3939", "eps": 0.00015767258085304424}, "output": {"eigenvalue": -11.677536944477682, "eigenvector": [0.8772264635513359, 0.4769939350554068, -0.05431866682435228]}}, {"input": {"matrix_str": "8.1915,0.1262;0.2569,-8.8524", "eps": 5.301486516898988e-05}, "output": {"eigenvalue": -8.854327720231927, "eigenvector": [0.007595130023019144, -0.9999711565839955]}}, {"input": {"matrix_str": "4.3390,2.3341;-9.9665,-9.4609", "eps": 0.00023532848310494017}, "output": {"eigenvalue": -7.495215272639111, "eigenvector": [-0.1935022689949453, 0.9810998276902344]}}, {"input": {"matrix_str": "0.1526,-1.2734;7.9539,-1.9809", "eps": 4.204909610496213e-06}, "output": {"eigenvalue": NaN, "eigenvector": [-0.0, 0.0]}}, {"input": {"matrix_str": "-0.4450,-2.8087,-4.0496;-9.6551,-1.8862,-8.2823;7.4981,-9.0556,3.9662", "eps": 1.056053194601732e-05}, "output": {"eigenvalue": -9.779686663017998, "eigenvector": [0.40311111658369314, 0.8496957889382134, 0.3398801170226282]}}, {"input": {"matrix_str": "-1.7329,3.8025;-0.2337,4.2567", "eps": 1.7820795427000185e-06}, "output": {"eigenvalue": 4.104466573753975, "eigenvector": [0.5458166645442405, 0.8379046298391006]}}, {"input": {"matrix_str": "7.0477,9.3509;9.6103,-9.1136", "eps": 1.0171104609668443e-05}, "output": {"eigenvalue": -13.48934385849959, "eigenvector": [-0.4143703853291108, 0.9101083362777225]}}, {"input": {"matrix_str": "-2.4252,5.9347;-1.9999,7.0710", "eps": 1.1720395877703074e-05}, "output": {"eigenvalue": 5.590261406022798, "eigenvector": [0.5950540741996776, 0.8036856654055516]}}, {"input": {"matrix_str": "-4.8025,-8.9335;-9.3594,4.1339", "eps": 6.415435219752774e-06}, "output": {"eigenvalue": NaN, "eigenvector": [0.0, 0.0]}}], "error_log": []}
{"context": "Given a polynomial function and an interval, what is the arc length of the function over that interval?\n\nThe input and output requirements are as follows:\n\nInput:\n  `function_str` (str): A string representing a one-variable function in SymPy syntax.\n  `variable_str` (str): A string representing the variable used in the function.\n  `lower_limit` (float): The lower limit of the interval over which to calculate the arc length.\n  `upper_limit` (float): The upper limit of the interval over which to calculate the arc length.\n\nOutput:\n  `return` (float): The arc length of the function over the specified interval, returned as a float. If the input function is invalid, returns the string \"Invalid input function\".", "reference_code": "# import necessary packages\nimport sympy\n\n# main function\ndef main_solution(function_str, variable_str, lower_limit, upper_limit):\n    # Convert the input strings to sympy expressions and symbols\n    try:\n        function_expr = sympy.sympify(function_str)\n    except sympy.SympifyError:\n        return \"Invalid input function\"\n    \n    variable_sym = sympy.Symbol(variable_str)\n    \n    # Calculate the derivative of the function\n    derivative = sympy.Derivative(function_expr, variable_sym).doit()\n    \n    # Calculate the arc length of the function between the given limits\n    length = sympy.Integral(sympy.sqrt(1 + derivative ** 2), (variable_sym, lower_limit, upper_limit)).doit().evalf()\n    \n    # Return the length as a float\n    return float(length)", "input_generator": "import random\nimport sympy\nfrom sympy.abc import x, y, z\n\ndef input_generator():\n    # Randomly choose a variable from x, y, z\n    variables = ['x', 'y', 'z']\n    variable_str = random.choice(variables)\n    \n    # Generate a random polynomial or trigonometric function\n    function_types = ['polynomial', 'trigonometric']\n    function_type = random.choice(function_types)\n    \n    if function_type == 'polynomial':\n        # Generate a polynomial of degree 1 to 3\n        degree = random.randint(1, 3)\n        coeffs = [random.randint(-5, 5) for _ in range(degree + 1)]\n        terms = []\n        for i, coeff in enumerate(coeffs):\n            if i == 0:\n                terms.append(f\"{coeff}\")\n            else:\n                if coeff == 1:\n                    terms.append(f\"{variable_str}^{i}\")\n                elif coeff == -1:\n                    terms.append(f\"-{variable_str}^{i}\")\n                else:\n                    terms.append(f\"{coeff}*{variable_str}^{i}\")\n        function_str = \" + \".join(terms).replace(\"+ -\", \"- \")\n    else:\n        # Generate a trigonometric function (sin or cos)\n        trig_func = random.choice(['sin', 'cos'])\n        coeff = random.randint(1, 3)\n        function_str = f\"{trig_func}({coeff}*{variable_str})\"\n    \n    # Generate random limits ensuring lower < upper\n    lower_limit = random.uniform(-5, 5)\n    upper_limit = lower_limit + random.uniform(0.1, 5)\n    \n    return {\n        'function_str': function_str,\n        'variable_str': variable_str,\n        'lower_limit': lower_limit,\n        'upper_limit': upper_limit\n    }", "io_pairs": [{"input": {"function_str": "0 - 4*z^1 + 0*z^2", "variable_str": "z", "lower_limit": -2.4091838641940133, "upper_limit": 0.20261167701637595}, "output": 10.768708888927678}, {"input": {"function_str": "cos(3*y)", "variable_str": "y", "lower_limit": -1.4333087394988553, "upper_limit": 0.9191405105375856}, "output": 5.247037418149089}, {"input": {"function_str": "-3 + 2*y^1 - y^2", "variable_str": "y", "lower_limit": -3.2509944569361204, "upper_limit": 0.9343416449791819}, "output": 18.838899963605993}, {"input": {"function_str": "sin(3*z)", "variable_str": "z", "lower_limit": -4.705321268854885, "upper_limit": -0.6779179022341006}, "output": 9.115672601743794}, {"input": {"function_str": "sin(3*x)", "variable_str": "x", "lower_limit": -4.080582526514601, "upper_limit": -3.4680543957186827}, "output": 1.098776698087692}, {"input": {"function_str": "sin(3*y)", "variable_str": "y", "lower_limit": 4.057657131017743, "upper_limit": 7.470303572928662}, "output": 7.823267213703845}, {"input": {"function_str": "cos(1*y)", "variable_str": "y", "lower_limit": -1.0087416619484033, "upper_limit": 3.8387039955943614}, "output": 5.701000874903489}, {"input": {"function_str": "-5 + 3*z^1 + 3*z^2", "variable_str": "z", "lower_limit": -3.0883131654564675, "upper_limit": -2.8763462462215412}, "output": 3.1641428392506334}, {"input": {"function_str": "sin(1*x)", "variable_str": "x", "lower_limit": 3.9181563370119186, "upper_limit": 5.3715239782515365}, "output": 1.5634860390134568}, {"input": {"function_str": "sin(2*z)", "variable_str": "z", "lower_limit": -1.3764779491159884, "upper_limit": 1.7187613744277832}, "output": 5.17152564839898}], "error_log": []}
{"context": "Alice wants to send a secure message to Bob using the RSA encryption algorithm. She has chosen two prime numbers `p` and `q` and wants to encrypt a message `message` that is less than the product of `p` and `q`. What are the RSA parameters `n`, `fin`, `e`, `d`, and the encrypted and decrypted versions of the message?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p` (int): A prime number used in the RSA algorithm.\n  `q` (int): Another prime number used in the RSA algorithm.\n  `message` (int): The message to be encrypted, such that `message < n`.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `n` (int): The product of `p` and `q`.\n    - `fin` (int): The Euler's totient function value of `n`.\n    - `e` (int): The public exponent in the RSA algorithm.\n    - `d` (int): The private exponent in the RSA algorithm.\n    - `encrypted_message` (int): The encrypted message.\n    - `decrypted_message` (int): The decrypted message.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef gcd(m, n):\n    if m < n:\n        (m, n) = (n, m)\n    if (m % n) == 0:\n        return n\n    else:\n        return gcd(n, m % n)\n\ndef rsaAlgo(p, q):\n    n = p * q\n    fin = (p - 1) * (q - 1)\n    e = None\n    for i in range(1, fin):\n        if gcd(i, fin) == 1:\n            e = i\n            break\n    d = None\n    for i in range(n):\n        if ((i * e) % fin) == 1:\n            d = i\n            break\n    return n, fin, e, d\n\ndef primeNum(n):\n    if n > 1:\n        for i in range(2, n):\n            if n % i == 0:\n                return False\n        return True\n    return False\n\n# main function\ndef main_solution(p, q, message):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert inputs if necessary\n    p = int(p)\n    q = int(q)\n    message = int(message)\n    \n    # Check if p and q are prime numbers\n    if not primeNum(p) or not primeNum(q):\n        raise ValueError(\"Both p and q must be prime numbers.\")\n    \n    # Calculate RSA parameters\n    n, fin, e, d = rsaAlgo(p, q)\n    \n    # Encryption\n    enc = (message ** e) % n\n    \n    # Decryption\n    dec = (enc ** d) % n\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"n\": n, \"fin\": fin, \"e\": e, \"d\": d, \"encrypted_message\": enc, \"decrypted_message\": dec}", "input_generator": "import random\n\ndef input_generator():\n    # Generate two distinct small prime numbers\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    p, q = random.sample(primes, 2)\n    \n    # Generate a message (integer) smaller than n = p*q\n    n = p * q\n    message = random.randint(1, n - 1)\n    \n    return {\"p\": p, \"q\": q, \"message\": message}", "io_pairs": [{"input": {"p": 11, "q": 83, "message": 209}, "output": {"n": 913, "fin": 820, "e": 1, "d": 1, "encrypted_message": 209, "decrypted_message": 209}}, {"input": {"p": 59, "q": 47, "message": 1465}, "output": {"n": 2773, "fin": 2668, "e": 1, "d": 1, "encrypted_message": 1465, "decrypted_message": 1465}}, {"input": {"p": 17, "q": 83, "message": 979}, "output": {"n": 1411, "fin": 1312, "e": 1, "d": 1, "encrypted_message": 979, "decrypted_message": 979}}, {"input": {"p": 5, "q": 29, "message": 137}, "output": {"n": 145, "fin": 112, "e": 1, "d": 1, "encrypted_message": 137, "decrypted_message": 137}}, {"input": {"p": 2, "q": 61, "message": 32}, "output": {"n": 122, "fin": 60, "e": 1, "d": 1, "encrypted_message": 32, "decrypted_message": 32}}, {"input": {"p": 29, "q": 89, "message": 409}, "output": {"n": 2581, "fin": 2464, "e": 1, "d": 1, "encrypted_message": 409, "decrypted_message": 409}}, {"input": {"p": 43, "q": 17, "message": 142}, "output": {"n": 731, "fin": 672, "e": 1, "d": 1, "encrypted_message": 142, "decrypted_message": 142}}, {"input": {"p": 7, "q": 41, "message": 43}, "output": {"n": 287, "fin": 240, "e": 1, "d": 1, "encrypted_message": 43, "decrypted_message": 43}}, {"input": {"p": 83, "q": 59, "message": 490}, "output": {"n": 4897, "fin": 4756, "e": 1, "d": 1, "encrypted_message": 490, "decrypted_message": 490}}, {"input": {"p": 5, "q": 89, "message": 28}, "output": {"n": 445, "fin": 352, "e": 1, "d": 1, "encrypted_message": 28, "decrypted_message": 28}}], "error_log": []}
{"context": "Given a linear equation in the form \"y = kx + b\", a specific x-coordinate, a date in the format \"dd.mm.yyyy\", and a room number in a unique tower structure, determine the y-coordinate based on the equation, validate if the date is correct, and find the floor and position of the room in the tower. What are the calculated y-coordinate, the validity of the date, and the room's position in the tower?\n\nThe input and output requirements are as follows:\n\nInput:\n  `equation` (str): A string representing a linear equation in the form \"y = kx + b\".\n  `x` (float): The x-coordinate for which the y-coordinate needs to be calculated.\n  `date` (str): A string representing a date in the format \"dd.mm.yyyy\".\n  `room` (int): An integer representing the room number in the tower, where 1 \u2264 room \u2264 2,000,000,000.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `y` (float): The calculated y-coordinate based on the equation and x-coordinate.\n    - `is_date_valid` (bool): True if the date is valid, False otherwise.\n    - `room_position` (dict): A dictionary containing:\n      - `stage` (int): The floor number where the room is located.\n      - `position` (int): The position of the room on the floor, starting from the left.", "reference_code": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\ndef parse_equation(equation):\n    \"\"\"Parses the equation string to extract k and b.\"\"\"\n    pattern = r'y\\s*=\\s*([+-]?\\d+(\\.\\d+)?)\\s*x\\s*([+-])\\s*(\\d+(\\.\\d+)?)'\n    match = re.match(pattern, equation)\n    if not match:\n        raise ValueError(\"Invalid equation format\")\n    k = float(match.group(1))\n    b = float(match.group(4))\n    if match.group(3) == '-':\n        b = -b\n    return k, b\n\ndef validate_date(date):\n    \"\"\"Validates the date string.\"\"\"\n    if len(date) != 10:\n        return False\n    date_parts = date.split('.')\n    if len(date_parts) != 3:\n        return False\n    try:\n        day = int(date_parts[0])\n        month = int(date_parts[1])\n        year = int(date_parts[2])\n    except ValueError:\n        return False\n    if not (1 <= year <= 9999):\n        return False\n    if not (1 <= month <= 12):\n        return False\n    m_days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if not (1 <= day <= m_days[month]):\n        return False\n    return True\n\ndef find_room_position(room):\n    \"\"\"Finds the floor and position of the room in the tower.\"\"\"\n    current = 0\n    prev_rooms = 0\n    current_side = 0\n    prev_stages = 0\n\n    while current < room:\n        prev_rooms += current_side ** 2\n        prev_stages += current_side\n        current_side += 1\n        current += current_side ** 2\n\n    if room == 1:\n        current_side = 1\n\n    position = (room - prev_rooms) % current_side\n    if position == 0:\n        position = current_side\n        stage = (room - prev_rooms) // current_side + prev_stages\n    else:\n        stage = 1 + (room - prev_rooms) // current_side + prev_stages\n\n    return stage, position\n\n# main function\ndef main_solution(equation, x, date, room):\n    # Convert equation string to k and b\n    k, b = parse_equation(equation)\n    \n    # Calculate y\n    y = k * x + b\n    \n    # Validate date\n    is_date_valid = validate_date(date)\n    \n    # Find room position\n    stage, position = find_room_position(room)\n    \n    # Return the results\n    return {\n        \"y\": y,\n        \"is_date_valid\": is_date_valid,\n        \"room_position\": {\n            \"stage\": stage,\n            \"position\": position\n        }\n    }", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate random k and b for the equation\n    k = round(random.uniform(-100.0, 100.0), 2)\n    b = round(random.uniform(-100.0, 100.0), 2)\n    # Randomly choose the sign for b in the equation\n    sign = random.choice(['+', '-'])\n    equation = f\"y = {k}x {sign} {abs(b)}\"\n    \n    # Generate random x\n    x = round(random.uniform(-100.0, 100.0), 2)\n    \n    # Generate a random date, which may or may not be valid\n    day = random.randint(1, 31)\n    month = random.randint(1, 12)\n    year = random.randint(1, 9999)\n    # Randomly decide if the date should be valid\n    if random.choice([True, False]):\n        # Ensure valid date\n        if month == 2:\n            day = random.randint(1, 28)\n        elif month in [4, 6, 9, 11]:\n            day = random.randint(1, 30)\n        else:\n            day = random.randint(1, 31)\n    date = f\"{day:02d}.{month:02d}.{year:04d}\"\n    \n    # Generate random room number (1 to 10000)\n    room = random.randint(1, 10000)\n    \n    return {\n        \"equation\": equation,\n        \"x\": x,\n        \"date\": date,\n        \"room\": room\n    }", "io_pairs": [{"input": {"equation": "y = -98.72x + 30.06", "x": 32.14, "date": "30.08.4682", "room": 8265}, "output": {"y": -3142.8008, "is_date_valid": true, "room_position": {"stage": 425, "position": 29}}}, {"input": {"equation": "y = 68.03x - 18.16", "x": -46.92, "date": "17.10.9983", "room": 8452}, "output": {"y": -3210.1276, "is_date_valid": true, "room_position": {"stage": 432, "position": 13}}}, {"input": {"equation": "y = -89.44x - 26.28", "x": 6.74, "date": "22.02.9694", "room": 8389}, "output": {"y": -629.1056, "is_date_valid": true, "room_position": {"stage": 430, "position": 8}}}, {"input": {"equation": "y = -28.91x + 79.79", "x": 3.65, "date": "28.08.4998", "room": 6569}, "output": {"y": -25.731499999999997, "is_date_valid": true, "room_position": {"stage": 365, "position": 17}}}, {"input": {"equation": "y = 16.59x + 76.17", "x": 6.72, "date": "03.12.5281", "room": 4097}, "output": {"y": 187.6548, "is_date_valid": true, "room_position": {"stage": 267, "position": 3}}}, {"input": {"equation": "y = 43.61x - 56.04", "x": -10.51, "date": "20.04.0755", "room": 5037}, "output": {"y": -514.3811, "is_date_valid": true, "room_position": {"stage": 306, "position": 12}}}, {"input": {"equation": "y = 87.45x - 23.56", "x": -8.33, "date": "31.02.9253", "room": 6552}, "output": {"y": -752.0185, "is_date_valid": false, "room_position": {"stage": 364, "position": 27}}}, {"input": {"equation": "y = -19.37x - 6.09", "x": 49.9, "date": "30.10.7342", "room": 2269}, "output": {"y": -972.653, "is_date_valid": true, "room_position": {"stage": 180, "position": 8}}}, {"input": {"equation": "y = -55.65x - 68.13", "x": -87.81, "date": "15.09.4353", "room": 6118}, "output": {"y": 4818.4965, "is_date_valid": true, "room_position": {"stage": 348, "position": 21}}}, {"input": {"equation": "y = -12.24x + 56.41", "x": -93.12, "date": "01.03.7102", "room": 2947}, "output": {"y": 1196.1988000000001, "is_date_valid": true, "room_position": {"stage": 214, "position": 14}}}], "error_log": []}
{"context": "In a population genetics simulation, how many generations does it take for a specific allele to either fix or fail to fix in the population, given the population size, fitness values for different types of organisms, and the number of generations to run the simulation?\n\nThe input and output requirements are as follows:\n\nInput:\n  `pop` (int): The population size.\n  `wfit` (float): The fitness value for wildtype organisms.\n  `hfit` (float): The fitness value for heterozygous organisms.\n  `dfit` (float): The fitness value for dominant organisms.\n  `en` (int): The number of generations to run the simulation.\n  `ctr` (int): A control variable (0 or 1) to determine the initial population composition.\n\nOutput:\n  `return` (dict): A dictionary containing the number of generations (`generations`) and the fixation status (`fixation`). The `fixation` value is 1 if the allele is fixed, and 0 if it is not.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef divide(population, pop):\n    newPop = []\n    for ciliate in population:\n        if random.random() <= ciliate[2]:\n            newPop.append(ciliate)\n            newPop.append(ciliate)\n        else:\n            newPop.append(ciliate)\n    return random.sample(newPop, pop)\n\ndef check(population, pop):\n    tot = sum(cil[0] for cil in population)\n    return float(tot) / (2 * pop)\n\ndef mate(population, fit):\n    random.shuffle(population)\n    newPop = []\n    while len(population):\n        mom = population.pop()\n        dad = population.pop()\n        left, right = 0, 0\n        if mom[0] == 2:\n            left += 1\n            right += 1\n        elif mom[0] == 1:\n            if random.random() < 0.5:\n                left += 1\n            if random.random() < 0.5:\n                right += 1\n        if dad[0] == 2:\n            left += 1\n            right += 1\n        elif dad[0] == 1:\n            if random.random() < 0.5:\n                left += 1\n            if random.random() < 0.5:\n                right += 1\n        newPop.append([left, left, fit[left]])\n        newPop.append([right, right, fit[right]])\n    return newPop\n\n# main function\ndef main_solution(pop, wfit, hfit, dfit, en, ctr):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    initCil = [0, 0, wfit]\n    population = [initCil for _ in range(pop - 1)]\n    \n    if ctr:\n        population.append([1, 1, hfit])\n    else:\n        population.append([1, 0, wfit])\n\n    ns = random.randint(0, en)\n    q = 1 / (2 * pop)\n\n    cont = 1\n    gen = 0\n\n    while 1:\n        for _ in range(en - ns):\n            population = divide(population, pop)\n            gen += 1\n            q = check(population, pop)\n            if q == 1:\n                cont = 0\n                fix = 1\n                break\n            if q == 0:\n                cont = 0\n                fix = 0\n                break\n        ns = 0\n        if cont:\n            population = mate(population, [wfit, hfit, dfit])\n            population = divide(population, pop)\n            gen += 1\n            q = check(population, pop)\n        if q == 1:\n            fix = 1\n            break\n        if q == 0:\n            fix = 0\n            break\n        \n        if gen >= 5000:\n            fix = 0\n            break\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"generations\": gen, \"fixation\": fix}", "input_generator": "import random\n\ndef input_generator():\n    pop = random.randint(10, 100)\n    wfit = round(random.uniform(0.1, 0.9), 2)\n    hfit = round(random.uniform(0.1, 0.9), 2)\n    dfit = round(random.uniform(0.1, 0.9), 2)\n    en = random.randint(1, 10)\n    ctr = random.choice([True, False])\n    \n    return {\n        \"pop\": pop,\n        \"wfit\": wfit,\n        \"hfit\": hfit,\n        \"dfit\": dfit,\n        \"en\": en,\n        \"ctr\": ctr\n    }", "io_pairs": [{"input": {"pop": 61, "wfit": 0.61, "hfit": 0.58, "dfit": 0.73, "en": 2, "ctr": false}, "output": {"generations": 2, "fixation": 0}}, {"input": {"pop": 58, "wfit": 0.59, "hfit": 0.87, "dfit": 0.8, "en": 9, "ctr": true}, "output": {"generations": 8, "fixation": 0}}, {"input": {"pop": 54, "wfit": 0.83, "hfit": 0.69, "dfit": 0.31, "en": 6, "ctr": false}, "output": {"generations": 1, "fixation": 0}}, {"input": {"pop": 96, "wfit": 0.74, "hfit": 0.48, "dfit": 0.9, "en": 7, "ctr": true}, "output": {"generations": 1, "fixation": 0}}, {"input": {"pop": 56, "wfit": 0.3, "hfit": 0.2, "dfit": 0.23, "en": 6, "ctr": true}, "output": {"generations": 4, "fixation": 0}}, {"input": {"pop": 12, "wfit": 0.57, "hfit": 0.79, "dfit": 0.5, "en": 10, "ctr": false}, "output": {"generations": 5, "fixation": 0}}, {"input": {"pop": 12, "wfit": 0.13, "hfit": 0.81, "dfit": 0.2, "en": 4, "ctr": false}, "output": {"generations": 5000, "fixation": 0}}, {"input": {"pop": 72, "wfit": 0.45, "hfit": 0.64, "dfit": 0.83, "en": 10, "ctr": false}, "output": {"generations": 1, "fixation": 0}}, {"input": {"pop": 80, "wfit": 0.27, "hfit": 0.13, "dfit": 0.62, "en": 1, "ctr": false}, "output": {"generations": 14, "fixation": 0}}, {"input": {"pop": 62, "wfit": 0.58, "hfit": 0.75, "dfit": 0.49, "en": 2, "ctr": true}, "output": {"generations": 5001, "fixation": 0}}], "error_log": []}
{"context": "Given the need to approximate the value of Pi to a specified number of decimal places, how can we accurately compute Pi to `n` decimal places using an efficient algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of decimal places to which the value of Pi should be calculated. It should be a positive integer.\n\nOutput:\n  `return` (str): The value of Pi rounded to `n` decimal places as a string.", "reference_code": "# import necessary packages\nfrom decimal import getcontext, Decimal\n\n# Function to calculate factorial\ndef factorial(k):\n    if k == 0:\n        return 1\n    return k * factorial(k - 1)\n\n# Function to calculate Pi using the Chudnovsky algorithm\ndef getpi(n):\n    getcontext().prec = n + 2  # Set precision to handle n decimal places\n    inverse = 0\n    for i in range(n + 1):\n        num = (-1) ** i * factorial(6 * i) * (545140134 * i + 13591409)\n        den = factorial(3 * i) * factorial(i) ** 3 * (640320 ** 3) ** (i + 0.5)\n        inverse += 12 * num / den\n    pi = Decimal(1 / inverse)\n    return round(pi, n)\n\n# main function\ndef main_solution(n):\n    # Convert input to integer\n    n = int(n)\n    # Calculate Pi to n decimal places using the Chudnovsky algorithm\n    pi_value = getpi(n)\n    # Return the result as a string\n    return str(pi_value)", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Reasonable range for n to avoid excessive computation\n    return {'n': n}", "io_pairs": [{"input": {"n": 7}, "output": "3.1415927"}, {"input": {"n": 10}, "output": "3.1415926536"}, {"input": {"n": 5}, "output": "3.14159"}, {"input": {"n": 1}, "output": "3.1"}, {"input": {"n": 4}, "output": "3.1416"}, {"input": {"n": 2}, "output": "3.14"}, {"input": {"n": 8}, "output": "3.14159265"}, {"input": {"n": 9}, "output": "3.141592654"}, {"input": {"n": 6}, "output": "3.141593"}, {"input": {"n": 3}, "output": "3.142"}], "error_log": []}
{"context": "Given a polynomial represented by a list of coefficients, what is the value of the polynomial when evaluated at a specific integer value of 'x'?\n\nThe input and output requirements are as follows:\n\nInput:\n  `coefficients` (list of int): A list of integers representing the coefficients of the polynomial in descending order of their powers.\n  `x_value` (int): The value of 'x' at which the polynomial needs to be evaluated.\n\nOutput:\n  `return` (int): The value of the polynomial evaluated at the given `x_value`.", "reference_code": "# import necessary packages\nimport math\nimport copy\nfrom itertools import zip_longest\n\n# all class and function definitions in the code file, if any\nclass Polynomial:\n    # function to get max index\n    def getMaxIndex(self, kwargs):\n        maxValue = 0\n        for key, value in kwargs.items():\n            if (int(key[1:]) > maxValue):\n                maxValue = int(key[1:])\n        return maxValue\n\n    # constructor which handles all input arguments\n    def __init__(self, *args, **kwargs):\n        self.coeffs = []\n        \n        # parse input arguments\n        for arg in args:\n            if isinstance(arg, list):\n                self.coeffs.extend(arg)\n            elif isinstance(arg, int):\n                self.coeffs.append(arg)\n        if kwargs:\n            maxIndex = self.getMaxIndex(kwargs)\n            self.coeffs = [0] * (int(maxIndex) + 1)\n            for key, value in kwargs.items():       \n                self.coeffs[int(key[1:])] = value\n\n    def __repr__(self):\n        return \"Polynomial()\"\n\n    # override string \"operator\" which provides option to print object in specific format\n    def __str__(self):\n        result = \"\"\n\n        maxPower = len(self.coeffs) - 1\n\n        for power, item in reversed(list(enumerate(self.coeffs))):\n            if (item == 0):\n                continue\n            \n            if (power == maxPower):\n                coeff = \"\" if item > 0 else \"-\"\n            else:\n                coeff = \" + \" if item > 0 else \" - \"\n\n            coeff += \"\" if power != 0 and (item == 1 or item == -1) else str(abs(item))\n\n            if (power == 0):\n                suf = \"\"\n            elif (power == 1):\n                suf = \"x\"\n            else:\n                suf = \"x^\" + str(power)\n\n            result += coeff + str(suf)\n\n        return result\n\n    # override operator \"+\" to get sum of two polynoms represented by two objects\n    def __add__(self, other):\n        return Polynomial([a + b for a, b in zip_longest(self.coeffs, other.coeffs, fillvalue=0)])\n\n    # auxiliary method for multiplying polynoms\n    def multiply(self, s, v):\n        res = [0]*(len(s)+len(v)-1)\n        for selfpow,selfcoeff in enumerate(s):\n            for valpow,valcoeff in enumerate(v):\n                res[selfpow+valpow] += selfcoeff*valcoeff\n\n        return res\n\n    # override operator \"**\" to pow polynom of M members on N exponent\n    def __pow__(self, exp):\n        # make a copy of coefficients to be able to multiple together with base coefficients\n        self.result = copy.deepcopy(self.coeffs)\n        for i in range(1, exp):\n            self.result = self.multiply(self.coeffs, self.result)\n        \n        return Polynomial(self.result)\n\n    # derivate polynom\n    def derivative(self):\n        new_list = [self.coeffs[i] * i for i in range(1, len(self.coeffs))]\n        return Polynomial(new_list)\n\n    # use val in polynom instead of \"x\" to get exact result\n    def getListWithValue(self, val):\n        return [value*val**key for key, value in enumerate(self.coeffs)]\n\n    # get value according to given argument(s), returning exact result, using argument instead of variable\n    def at_value(self, *args):\n        if (len(args) == 1):\n            return sum(self.getListWithValue(int(args[0])))\n        elif (len(args) == 2):\n            return sum(self.getListWithValue(int(args[1]))) - sum(self.getListWithValue(int(args[0])))\n        else:\n            print(\"Invalid input arguments in method at_value()\")\n\n# main function\ndef main_solution(coefficients, x_value):\n    # Convert JSON serializable input to original input variables\n    poly = Polynomial(coefficients)\n    \n    # Calculate the value of the polynomial at the given x_value\n    result = poly.at_value(x_value)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random polynomial degree between 1 and 5\n    degree = random.randint(1, 5)\n    \n    # Generate random coefficients for the polynomial\n    coefficients = [random.randint(-10, 10) for _ in range(degree + 1)]\n    \n    # Generate a random x_value between -10 and 10\n    x_value = random.randint(-10, 10)\n    \n    return {\n        'coefficients': coefficients,\n        'x_value': x_value\n    }", "io_pairs": [{"input": {"coefficients": [10, 9, -6], "x_value": -7}, "output": -347}, {"input": {"coefficients": [3, -6, 1], "x_value": 10}, "output": 43}, {"input": {"coefficients": [-4, -10, -6], "x_value": 5}, "output": -204}, {"input": {"coefficients": [10, 6, 5, -9, 6], "x_value": 7}, "output": 11616}, {"input": {"coefficients": [7, -4], "x_value": -6}, "output": 31}, {"input": {"coefficients": [-8, 3, -6, 8, -6], "x_value": -6}, "output": -9746}, {"input": {"coefficients": [-4, -6, 8, -4, 4], "x_value": 4}, "output": 868}, {"input": {"coefficients": [6, -6, 0, 9, 2], "x_value": 4}, "output": 1070}, {"input": {"coefficients": [-9, -4, 0, -10, 2], "x_value": -6}, "output": 4767}, {"input": {"coefficients": [6, 2, -5], "x_value": -7}, "output": -253}], "error_log": []}
{"context": "You are tasked with navigating through a randomly generated maze. The maze is represented as a grid of cells, and you start at the top-left corner and need to reach the bottom-right corner. Given the dimensions of the maze, what is the shortest path from the start to the end? The path should be returned as a sequence of cell indices, starting from the top-left cell (index 0) to the bottom-right cell.\n\nThe input and output requirements are as follows:\n\nInput:\n  `maze_width` (int): The width of the maze.\n  `maze_height` (int): The height of the maze.\n\nOutput:\n  `return` (str): A string representing the solution path of the maze. Each cell in the path is separated by a comma.", "reference_code": "# import necessary packages\nfrom random import shuffle, randrange\nfrom math import floor, ceil\nfrom collections import defaultdict\nimport string\nimport random\n\n# all class and function definitions in the code file, if any\ndef make_maze(w, h):\n    # Makes a square grid:\n    vis = [[0] * w + [1] for _ in range(h)] + [[1] * (w + 1)]\n    con = [[0] * w*h for _ in range(w*h)]\n    ver = [[\"|  \"] * w + ['|'] for _ in range(h)] + [[]]\n    hor = [[\"+--\"] * w + ['+'] for _ in range(h + 1)]\n    # Carve Out Maze (break walls and build connections):\n    def walk(x, y):\n        vis[y][x] = 1\n        d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]\n        shuffle(d)\n        for (xx, yy) in d:\n            if vis[yy][xx]: continue\n            if xx == x:\n                hor[max(y, yy)][x] = \"+  \"\n                con[(max(y, yy)*w) + x][(max(y, yy)*w) + x - w] = 1\n                con[(max(y, yy)*w) + x - w][(max(y, yy)*w) + x] = 1\n            if yy == y:\n                ver[y][max(x, xx)] = \"   \"\n                con[(y*w) + max(x, xx)][(y*w) + max(x, xx) - 1] = 1\n                con[(y*w) + max(x, xx) - 1][(y*w) + max(x, xx)] = 1\n            walk(xx, yy)\n    walk(randrange(w), randrange(h))\n    # Turn Maze into string:\n    s = \"\"\n    for (a, b) in zip(hor, ver):\n        s += ''.join(a + ['\\n'] + b + ['\\n'])\n    return s, con\n\ndef Dijkstra(Graph, source):\n   # Graph[u][v] is the weight from u to v (however 0 means infinity)\n   infinity = float('infinity')\n   n = len(Graph)\n   dist = [infinity]*n   # Unknown distance function from source to v\n   previous = [infinity]*n # Previous node in optimal path from source\n   dist[source] = 0        # Distance from source to source\n   Q = list(range(n)) # All nodes in the graph are unoptimized - thus are in Q\n   while Q:           # The main loop\n       u = min(Q, key=lambda n:dist[n])                 # vertex in Q with smallest dist[]\n       Q.remove(u)\n       if dist[u] == infinity:\n           break # all remaining vertices are inaccessible from source\n       for v in range(n):               # each neighbor v of u\n           if Graph[u][v] and (v in Q): # where v has not yet been visited\n               alt = dist[u] + Graph[u][v]\n               if alt < dist[v]:       # Relax (u,v,a)\n                   dist[v] = alt\n                   previous[v] = u\n   return dist,previous\n\ndef getSolution(Graph):\n    predecessor = Dijkstra(Graph, 0)[1]\n    cell = len(predecessor)-1\n    solution = []\n    while cell:\n        solution = [cell] + solution\n        cell = predecessor[cell]\n    return [0] + solution\n\n# main function\ndef main_solution(maze_width, maze_height):\n    # Generate the maze and adjacency map\n    maze, adjMap = make_maze(maze_width, maze_height)\n    \n    # Solve the maze to get the solution path\n    solution = getSolution(adjMap)\n    \n    # Convert the solution path to a JSON serializable format\n    solution_serializable = ','.join(map(str, solution))\n    \n    return solution_serializable", "input_generator": "import random\n\ndef input_generator():\n    maze_width = random.randint(5, 15)\n    maze_height = random.randint(5, 15)\n    return {\n        'maze_width': maze_width,\n        'maze_height': maze_height\n    }", "io_pairs": [{"input": {"maze_width": 11, "maze_height": 9}, "output": "0,1,2,3,14,25,26,37,48,49,38,27,16,17,28,29,40,41,42,43,54,65,76,75,86,97,98"}, {"input": {"maze_width": 6, "maze_height": 5}, "output": "0,1,2,3,4,10,16,17,23,29"}, {"input": {"maze_width": 8, "maze_height": 7}, "output": "0,1,2,3,4,5,6,14,22,23,31,30,29,37,38,46,54,55"}, {"input": {"maze_width": 12, "maze_height": 5}, "output": "0,1,2,3,4,5,17,16,28,29,41,53,54,55,43,44,32,31,30,18,19,7,8,20,21,22,23,35,47,46,45,57,58,59"}, {"input": {"maze_width": 5, "maze_height": 10}, "output": "0,5,6,7,2,3,8,9,14,19,24,29,28,27,26,25,30,31,36,41,42,37,32,33,38,39,44,43,48,49"}, {"input": {"maze_width": 13, "maze_height": 6}, "output": "0,13,14,1,2,3,16,15,28,29,42,41,54,67,68,69,70,71,72,73,74,75,62,63,76,77"}, {"input": {"maze_width": 11, "maze_height": 8}, "output": "0,1,2,13,12,11,22,23,34,33,44,55,66,77,78,67,68,69,80,81,82,71,72,73,74,75,76,87"}, {"input": {"maze_width": 5, "maze_height": 7}, "output": "0,5,10,15,16,17,12,13,14,19,24,29,34"}, {"input": {"maze_width": 12, "maze_height": 13}, "output": "0,1,13,14,2,3,15,16,28,29,17,18,6,7,8,9,10,11,23,35,47,59,71,83,95,107,119,131,143,142,154,155"}, {"input": {"maze_width": 10, "maze_height": 11}, "output": "0,1,2,12,11,10,20,30,31,41,40,50,60,70,80,81,82,83,84,85,95,96,97,107,108,98,99,109"}], "error_log": []}
{"context": "Given a string of length 10 where each character represents the presence ('o'), absence ('x'), or indifference ('?') of digits from 0 to 9 in a 4-digit combination, how many valid 4-digit combinations can be formed that include all digits marked with 'o' and exclude all digits marked with 'x'?\n\nThe input and output requirements are as follows:\n\nInput:\n  `s` (str): A string of length 10, where each character can be either 'o', 'x', or '?'. The string represents the presence ('o'), absence ('x'), or indifference ('?') of digits from 0 to 9 in a 4-digit combination.\n\nOutput:\n  `return` (int): The number of valid 4-digit combinations that include all digits marked with 'o' and exclude all digits marked with 'x'.", "reference_code": "# import necessary packages\nfrom itertools import product\n\n# main function\ndef main_solution(s):\n    # Convert the input string to a list of characters\n    s = list(s)\n    \n    exist = []\n    not_exist = []\n    \n    # Populate the exist and not_exist lists based on the input string\n    for i in range(10):\n        if s[i] == \"o\":\n            exist.append(i)\n        if s[i] == \"x\":\n            not_exist.append(i)\n    \n    exist = set(exist)\n    not_exist = set(not_exist)\n    \n    cnt = 0\n    \n    # Generate all possible 4-digit combinations using product\n    for prod in product(range(10), repeat=4):\n        prod = set(prod)\n        # Check if the combination contains all 'o' digits and no 'x' digits\n        if (prod >= exist) and prod.isdisjoint(not_exist):\n            cnt += 1\n    \n    # Return the count of valid combinations\n    return cnt", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random 10-character string consisting of 'o', 'x', and '?'\n    s = []\n    for _ in range(10):\n        choice = random.choice(['o', 'x', '?'])\n        s.append(choice)\n    return {'s': ''.join(s)}", "io_pairs": [{"input": {"s": "?xxo??o?o?"}, "output": 156}, {"input": {"s": "ox?xx?o?x?"}, "output": 302}, {"input": {"s": "x?x??oxx??"}, "output": 671}, {"input": {"s": "o?oxo???xo"}, "output": 24}, {"input": {"s": "oxxoo??oox"}, "output": 0}, {"input": {"s": "xxo?oooxo?"}, "output": 0}, {"input": {"s": "o??o?ox???"}, "output": 180}, {"input": {"s": "ox??x?xxo?"}, "output": 302}, {"input": {"s": "oo?ox?ooox"}, "output": 0}, {"input": {"s": "oooo?o?ox?"}, "output": 0}], "error_log": []}
{"context": "Given a list of integers representing the preorder traversal of a binary search tree, what is the corresponding postorder traversal of the same tree?\n\nThe input and output requirements are as follows:\n\nInput:\n  `preorder` (list of integers): A list of integers representing the preorder traversal of a binary search tree.\n\nOutput:\n  `return` (list of integers): A list of integers representing the postorder traversal of the binary search tree constructed from the input `preorder` list.", "reference_code": "# import necessary packages\nimport sys\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, newNode):\n        if self.root is None:\n            self.root = newNode\n        else:\n            self.currNode = self.root\n            while True:\n                if newNode.data < self.currNode.data:\n                    if self.currNode.left is not None:\n                        self.currNode = self.currNode.left\n                    else:\n                        self.currNode.left = newNode\n                        break\n                else:\n                    if self.currNode.right is not None:\n                        self.currNode = self.currNode.right\n                    else:\n                        self.currNode.right = newNode\n                        break\n\n    def postOrder(self, root):\n        result, stack = [], []\n        stack.append(root)\n\n        while stack:\n            curr = stack.pop()\n            result.append(curr.data)\n\n            if curr.left:\n                stack.append(curr.left)\n            if curr.right:\n                stack.append(curr.right)\n\n        result.reverse()\n        return result\n\n# main function\ndef main_solution(preorder):\n    # Convert the input list to a binary tree\n    tree = BinaryTree()\n    for value in preorder:\n        node = Node(value)\n        tree.insert(node)\n\n    # Get the postorder traversal result\n    postorder_result = tree.postOrder(tree.root)\n\n    # Return the postorder traversal result as a list of integers\n    return postorder_result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random length for the preorder list between 5 and 20\n    length = random.randint(5, 20)\n    \n    # Generate a random preorder list with unique elements\n    preorder = random.sample(range(1, 100), length)\n    \n    return {'preorder': preorder}", "io_pairs": [{"input": {"preorder": [52, 17, 9, 31, 19, 93, 40, 45, 62, 56, 38]}, "output": [9, 19, 38, 45, 40, 31, 17, 56, 62, 93, 52]}, {"input": {"preorder": [7, 28, 17, 89, 4, 83, 61, 98, 12, 16, 45, 57, 55]}, "output": [4, 16, 12, 17, 55, 57, 45, 61, 83, 98, 89, 28, 7]}, {"input": {"preorder": [70, 31, 71, 52, 24, 73]}, "output": [24, 52, 31, 73, 71, 70]}, {"input": {"preorder": [94, 21, 93, 27, 97]}, "output": [27, 93, 21, 97, 94]}, {"input": {"preorder": [49, 24, 34, 42, 59, 87, 6, 99, 74, 32, 12, 55, 57, 75]}, "output": [12, 6, 32, 42, 34, 24, 57, 55, 75, 74, 99, 87, 59, 49]}, {"input": {"preorder": [3, 67, 21, 32, 71, 12, 82, 23, 46, 95, 22, 27, 96, 15, 26]}, "output": [15, 12, 22, 26, 27, 23, 46, 32, 21, 96, 95, 82, 71, 67, 3]}, {"input": {"preorder": [44, 65, 64, 50, 2, 86, 19, 62, 56, 99, 78, 95]}, "output": [19, 2, 56, 62, 50, 64, 78, 95, 99, 86, 65, 44]}, {"input": {"preorder": [24, 86, 39, 6, 40, 61, 82, 34, 22, 96, 13, 1, 99, 7, 55, 66]}, "output": [1, 7, 13, 22, 6, 34, 55, 66, 82, 61, 40, 39, 99, 96, 86, 24]}, {"input": {"preorder": [88, 21, 83, 92, 75, 77, 35, 25, 23, 72, 34]}, "output": [23, 34, 25, 72, 35, 77, 75, 83, 21, 92, 88]}, {"input": {"preorder": [49, 19, 27, 91, 46, 41, 87, 45, 55]}, "output": [45, 41, 46, 27, 19, 55, 87, 91, 49]}], "error_log": []}
{"context": "In a game of recursive combat, two players draw cards from their decks and compare them. The player with the higher card wins the round and takes both cards, placing them at the bottom of their deck in a specific order. The game continues until one player has all the cards. Given the initial decks of cards for both players, what is the final score of the winning player's deck?\n\nThe input and output requirements are as follows:\n\nInput:\n  `player1_deck` (list of integers): A list representing the deck of cards for Player 1. Each integer represents the value of a card.\n  `player2_deck` (list of integers): A list representing the deck of cards for Player 2. Each integer represents the value of a card.\n\nOutput:\n  `return` (integer): The final score of the winning player's deck. The score is calculated by summing the product of each card's value and its position (from the bottom of the deck).", "reference_code": "# import necessary packages\nimport re\nfrom copy import deepcopy\n\n# main function\ndef main_solution(player1_deck, player2_deck):\n    # Convert input lists to JSON serializable format\n    players = [player1_deck, player2_deck]\n    \n    # Call the recursive_combat function with verbose set to False\n    winner = recursive_combat(players, verbose=False)\n    \n    # Calculate the final score based on the winner's deck\n    res = 0\n    for p in players:\n        r = reversed(p)\n        for pos, value in enumerate(r):\n            res += (pos + 1) * value\n    \n    # Return the final score as the output\n    return res\n\n# Define the recursive_combat function without verbose prints\ndef recursive_combat(players, count=1, game=1, verbose=False):\n    MEMORY = set()\n    p1, p2 = players\n    new_game_count = 1\n    while p1 and p2:\n        if len(p1) > 1 and len(p2) > 1:\n            current_state = (tuple(p1), tuple(p2))\n            if current_state in MEMORY:\n                return 0\n            else:\n                MEMORY.add(current_state)\n        n1, n2 = p1.pop(0), p2.pop(0)\n        if len(p1) >= n1 and len(p2) >= n2:\n            new_p1 = deepcopy(p1[:n1])\n            new_p2 = deepcopy(p2[:n2])\n            new_game_count += 1\n            winner = recursive_combat([new_p1, new_p2], game=new_game_count, verbose=verbose)\n            update_winner(winner, players, n1, n2)\n        else:\n            if n1 > n2:\n                p1 += [n1, n2]\n            else:\n                p2 += [n2, n1]\n        count += 1\n        if not p1:\n            return 1\n        elif not p2:\n            return 0\n\ndef update_winner(ind, players, n1, n2):\n    if ind == 0:\n        players[0] += [n1, n2]\n    elif ind == 1:\n        players[1] += [n2, n1]\n    else:\n        raise ValueError", "input_generator": "import random\n\ndef input_generator():\n    # Generate random deck sizes between 5 and 10 for each player\n    deck_size1 = random.randint(5, 10)\n    deck_size2 = random.randint(5, 10)\n    \n    # Generate unique card values for each deck to avoid trivial cases\n    all_cards = list(range(1, 100))\n    random.shuffle(all_cards)\n    \n    player1_deck = all_cards[:deck_size1]\n    player2_deck = all_cards[deck_size1:deck_size1 + deck_size2]\n    \n    return {\n        'player1_deck': player1_deck,\n        'player2_deck': player2_deck\n    }", "io_pairs": [{"input": {"player1_deck": [], "player2_deck": [82, 29, 77, 8, 96, 81, 79, 16, 85, 47, 67, 28]}, "output": 4677}, {"input": {"player1_deck": [24, 86, 18, 95, 2, 54, 16], "player2_deck": [85, 34, 94, 21, 52, 27]}, "output": 2534}, {"input": {"player1_deck": [97, 35, 75, 4, 98, 93, 65, 9, 79, 76, 18, 1], "player2_deck": []}, "output": 4786}, {"input": {"player1_deck": [79, 39, 90, 21, 82, 11, 99, 44, 72, 67], "player2_deck": [19, 84, 59]}, "output": 3578}, {"input": {"player1_deck": [41, 37, 77, 70, 68, 63, 97, 53, 89, 28, 96, 49, 79, 8], "player2_deck": []}, "output": 6514}, {"input": {"player1_deck": [43, 82, 11], "player2_deck": [93, 29, 81, 61, 78, 19, 91, 13, 64, 46]}, "output": 3710}, {"input": {"player1_deck": [30, 14, 57, 42, 47, 25, 87, 82, 63, 48, 93, 32, 66, 17], "player2_deck": []}, "output": 4948}, {"input": {"player1_deck": [31, 24, 87, 51, 86, 38, 66, 60, 48, 3, 90, 71, 30, 1], "player2_deck": []}, "output": 5438}, {"input": {"player1_deck": [81, 61, 73, 60, 39, 20, 25, 14, 96, 50, 72, 42], "player2_deck": []}, "output": 4305}, {"input": {"player1_deck": [67, 31, 70, 20, 79, 13, 60, 59], "player2_deck": [50, 72, 49, 61, 9]}, "output": 2623}], "error_log": []}
{"context": "Given a mathematical function and an interval, determine the approximate root of the function within the specified interval using the bisection method. What is the approximate root of the function `f(x)` within the interval `[x0, x1]`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `f_str` (str): A string representation of the function `f(x)` for which the root is to be found. The function should be in a format that can be evaluated using `eval`.\n  `x0` (float): The lower bound of the interval in which the root is expected.\n  `x1` (float): The upper bound of the interval in which the root is expected.\n\nOutput:\n  `return` (float): The approximate root of the function `f(x)` within the interval `[x0, x1]`.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef bissection(f, x0, x1):\n    \"\"\" R\u00e9solution de l'\u00e9quation f(x)=0 par la m\u00e9thode de la bissection.\n    R\u00e9f : \"M\u00e9thodes de calcul num\u00e9rique\" - J.P. Nougier 3\u00e8me \u00e9dition\n    editions Masson page 137.\n    Il doit exister une solution unique dans l'interval l'interval [x0,x1] \"\"\"\n    epsilon = 0.000001\n    i = 0\n    while x1 - x0 >= 2 * epsilon:\n        x2 = 1 / 2. * (x0 + x1)\n        x = f(x2) * f(x1)\n        if x > 0:\n            x1 = x2\n        else:\n            x0 = x2\n        i = i + 1\n    return (x0 + x1) / 2.\n\n# main function\ndef main_solution(f_str, x0, x1):\n    # Convert the function string to a callable function\n    f = eval(\"lambda x: \" + f_str)\n    \n    # Call the bissection method\n    result = bissection(f, x0, x1)\n    \n    # Return the result as a float\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random function from a set of possible functions\n    functions = [\n        \"x**2 - 2\",  # root at sqrt(2)\n        \"math.sin(x)\",  # root at 0\n        \"math.cos(x) - x\",  # root around 0.739\n        \"math.exp(x) - 2\",  # root at ln(2)\n        \"x**3 - x - 2\"  # root around 1.521\n    ]\n    f_str = random.choice(functions)\n    \n    # Generate x0 and x1 such that f(x0) * f(x1) < 0\n    if f_str == \"x**2 - 2\":\n        x0 = random.uniform(1.0, 1.5)\n        x1 = random.uniform(1.5, 2.0)\n    elif f_str == \"math.sin(x)\":\n        x0 = random.uniform(-1.0, -0.5)\n        x1 = random.uniform(0.5, 1.0)\n    elif f_str == \"math.cos(x) - x\":\n        x0 = random.uniform(0.0, 0.5)\n        x1 = random.uniform(0.5, 1.0)\n    elif f_str == \"math.exp(x) - 2\":\n        x0 = random.uniform(0.0, 0.5)\n        x1 = random.uniform(0.5, 1.0)\n    elif f_str == \"x**3 - x - 2\":\n        x0 = random.uniform(1.0, 1.5)\n        x1 = random.uniform(1.5, 2.0)\n    \n    return {\"f_str\": f_str, \"x0\": x0, \"x1\": x1}", "io_pairs": [{"input": {"f_str": "x**3 - x - 2", "x0": 1.3558933440355043, "x1": 1.6569468846896216}, "output": 1.5213801132461187}, {"input": {"f_str": "math.cos(x) - x", "x0": 0.4652537793738685, "x1": 0.8175960415380431}, "output": 0.7390850232097013}, {"input": {"f_str": "math.cos(x) - x", "x0": 0.3616896040371643, "x1": 0.9016230263988028}, "output": 0.7390847227351602}, {"input": {"f_str": "x**2 - 2", "x0": 1.4648229507743378, "x1": 1.7593964387468062}, "output": 1.4648235126286773}, {"input": {"f_str": "x**3 - x - 2", "x0": 1.1910169675162816, "x1": 1.9427004766048988}, "output": 1.5213803270753044}, {"input": {"f_str": "math.cos(x) - x", "x0": 0.16275006835442757, "x1": 0.525866230468134}, "output": 0.16275076094354293}, {"input": {"f_str": "x**2 - 2", "x0": 1.292305295463546, "x1": 1.9804816104663392}, "output": 1.414212948020999}, {"input": {"f_str": "math.exp(x) - 2", "x0": 0.33421080711212664, "x1": 0.9308901755743}, "output": 0.6931467564381311}, {"input": {"f_str": "math.cos(x) - x", "x0": 0.34670778111385314, "x1": 0.6331378753078747}, "output": 0.3467083274359017}, {"input": {"f_str": "x**2 - 2", "x0": 1.4483558770039167, "x1": 1.525312020882803}, "output": 1.4483564641326998}], "error_log": []}
{"context": "In the Game of Life, a cellular automaton devised by the British mathematician John Conway, cells on a grid evolve over discrete time steps according to specific rules. Given an initial configuration of live and dead cells on a grid, what will be the state of the grid after one iteration of the Game of Life rules?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (List[List[int]]): A 2D list representing the initial state of the game board. Each element in the list is either 0 (dead cell) or 1 (live cell).\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the updated state of the game board after one iteration of the Game of Life rules. Each element in the list is either 0 (dead cell) or 1 (live cell).", "reference_code": "# import necessary packages\nimport numpy as np\nfrom copy import deepcopy\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\n        # count # of neighbours that are 0 or 1\n        # determine next state based on counts\n        # live is 1\n        def ck(x, y, n, m, b):\n            cnt = 0\n            rg = [-1, 0, 1]\n            for i, j in product(rg, rg):\n                if i == j == 0:\n                    continue\n                xx, yy = x + i, y + j\n                if 0 <= xx < n and 0 <= yy < m:\n                    cnt += b[xx][yy]\n            return cnt\n\n        n, m = len(board), len(board[0])\n        board2 = deepcopy(board)\n        for i in range(n):\n            for j in range(m):\n                cnt = ck(i, j, n, m, board2)\n                if board2[i][j]:\n                    if cnt in [2, 3]:\n                        board[i][j] = 1\n                    else:\n                        board[i][j] = 0\n                elif ck(i, j, n, m, board2) == 3:\n                    board[i][j] = 1\n\n# main function\ndef main_solution(board: List[List[int]]) -> List[List[int]]:\n    # Convert input to a numpy array for easier manipulation\n    board_np = np.array(board)\n    \n    # Create an instance of the Solution class\n    sol = Solution()\n    \n    # Call the gameOfLife method to update the board\n    sol.gameOfLife(board_np)\n    \n    # Convert the numpy array back to a list of lists\n    updated_board = board_np.tolist()\n    \n    # Return the updated board\n    return updated_board", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    rows = random.randint(3, 10)\n    cols = random.randint(3, 10)\n    board = [[random.randint(0, 1) for _ in range(cols)] for _ in range(rows)]\n    return {'board': board}", "io_pairs": [], "error_log": ["STDERR: Traceback (most recent call last):\n  File \"<string>\", line 57, in <module>\n  File \"<string>\", line 58, in Solution\nNameError: name 'List' is not defined. Did you mean: 'list'?\n"]}
{"context": "In a space mission simulation, two critical operations need to be performed concurrently: a countdown from a specified number and a countup to another specified number. The countdown operation will start from a given number and decrement until it reaches zero, at which point it will announce \"Blastoff!\". The countup operation will start from zero and increment until it reaches a given number, at which point it will announce \"Counting up complete!\". Given the numbers for the countdown and countup operations, what are the final messages from these two operations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `countdown_n` (int): The number from which the countdown will start.\n  `countup_n` (int): The number up to which the countup will proceed.\n\nOutput:\n  `return` (list of str): A list containing the final messages from the countdown and countup generators. The list will contain \"Blastoff!\" from the countdown generator and \"Counting up complete!\" from the countup generator.", "reference_code": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass TaskScheduler:\n    def __init__(self):\n        self._task_queue = deque()\n\n    def new_task(self, task):\n        self._task_queue.append(task)\n\n    def run(self):\n        while self._task_queue:\n            task = self._task_queue.popleft()\n            try:\n                next(task)\n                self._task_queue.append(task)\n            except StopIteration:\n                pass\n\n# main function\ndef main_solution(countdown_n, countup_n):\n    # Convert input variables to the required format\n    countdown_n = int(countdown_n)\n    countup_n = int(countup_n)\n\n    # Define the generator functions\n    def countdown(n):\n        while n > 0:\n            yield\n            n -= 1\n        yield 'Blastoff!'\n\n    def countup(n):\n        x = 0\n        while x < n:\n            yield\n            x += 1\n        yield 'Counting up complete!'\n\n    # Create a TaskScheduler instance\n    sched = TaskScheduler()\n\n    # Add tasks to the scheduler\n    sched.new_task(countdown(countdown_n))\n    sched.new_task(countup(countup_n))\n\n    # Run the scheduler and collect results\n    results = []\n    while sched._task_queue:\n        task = sched._task_queue.popleft()\n        try:\n            next(task)\n            sched._task_queue.append(task)\n        except StopIteration as e:\n            results.append(str(e))\n\n    # Return the results as a JSON serializable output\n    return results", "input_generator": "import random\n\ndef input_generator():\n    countdown_n = random.randint(1, 20)\n    countup_n = random.randint(1, 20)\n    return {'countdown_n': countdown_n, 'countup_n': countup_n}", "io_pairs": [{"input": {"countdown_n": 8, "countup_n": 15}, "output": ["", ""]}, {"input": {"countdown_n": 19, "countup_n": 2}, "output": ["", ""]}, {"input": {"countdown_n": 3, "countup_n": 16}, "output": ["", ""]}, {"input": {"countdown_n": 2, "countup_n": 2}, "output": ["", ""]}, {"input": {"countdown_n": 10, "countup_n": 12}, "output": ["", ""]}, {"input": {"countdown_n": 11, "countup_n": 8}, "output": ["", ""]}, {"input": {"countdown_n": 16, "countup_n": 11}, "output": ["", ""]}, {"input": {"countdown_n": 14, "countup_n": 16}, "output": ["", ""]}, {"input": {"countdown_n": 5, "countup_n": 6}, "output": ["", ""]}, {"input": {"countdown_n": 19, "countup_n": 1}, "output": ["", ""]}], "error_log": []}
{"context": "Given a mathematical function and a specific value, what is the derivative of the function evaluated at that value, expressed as a fraction?\n\nThe input and output requirements are as follows:\n\nInput:\n- `function` (str): A string representing the mathematical function in terms of `x`. For example, \"sin(x) + x^2\".\n- `value` (str): A string representing the value at which the derivative of the function should be evaluated. This can be a decimal number (e.g., \"3.14\") or a fraction (e.g., \"1/2\").\n\nOutput:\n- `return` (str): A string representing the evaluated derivative of the function at the given value, converted to a fraction. For example, \"1/2\".", "reference_code": "# import necessary packages\nfrom sympy import Symbol, diff, evalf\nfrom fractions import Fraction\n\n# main function\ndef main_solution(function, value):\n    # Convert the value to a float if it is a fraction\n    try:\n        value = float(value)\n    except ValueError:\n        number, denom = value.split(\"/\")\n        value = float(number) / float(denom)\n\n    # Define the symbol x\n    x = Symbol(\"x\")\n\n    # Calculate the derivative of the function\n    derivative = diff(function, x)\n\n    # Evaluate the derivative at the given value and round to 1 decimal place\n    evaluate = round(derivative.evalf(subs={x: value}), 1)\n\n    # Convert the evaluated result to a fraction\n    answer = str(Fraction(str(evaluate)))\n\n    # Return the final answer as a string\n    return answer", "input_generator": "import random\nfrom sympy import sympify\nfrom fractions import Fraction\n\ndef input_generator():\n    # Generate a random polynomial function of degree 1 to 3\n    degree = random.randint(1, 3)\n    coefficients = [random.randint(-10, 10) for _ in range(degree + 1)]\n    terms = []\n    for i, coeff in enumerate(coefficients):\n        if i == 0:\n            terms.append(f\"{coeff}\")\n        else:\n            if coeff == 1:\n                terms.append(f\"x**{i}\")\n            elif coeff == -1:\n                terms.append(f\"-x**{i}\")\n            else:\n                terms.append(f\"{coeff}*x**{i}\")\n    function_str = \" + \".join(terms).replace(\"+ -\", \"- \")\n    function = sympify(function_str)\n    \n    # Generate a random value, either integer, float, or fraction\n    value_type = random.choice([\"int\", \"float\", \"fraction\"])\n    if value_type == \"int\":\n        value = random.randint(-10, 10)\n    elif value_type == \"float\":\n        value = round(random.uniform(-10, 10), 1)\n    else:\n        numerator = random.randint(-20, 20)\n        denominator = random.randint(1, 20)\n        value = f\"{numerator}/{denominator}\"\n    \n    return {\"function\": function, \"value\": value}", "io_pairs": [], "error_log": []}
{"context": "Given a set of data points, what are the coefficients of the quadratic polynomial that best fits these points?\n\nThe input and output requirements are as follows:\n\nInput:\n  `xi` (list of floats): List of x-coordinates of the data points.\n  `yi` (list of floats): List of y-coordinates of the data points.\n\nOutput:\n  `return` (list of floats): List of polynomial coefficients [c0, c1, c2] that represent the polynomial \\( c0 + c1 \\cdot x + c2 \\cdot x^2 \\).", "reference_code": "# import necessary packages\nimport numpy as np\nfrom numpy.linalg import solve\n\n# main function\ndef main_solution(xi, yi):\n    # Convert input lists to numpy arrays\n    xi = np.array(xi)\n    yi = np.array(yi)\n    \n    # Define the linear system to be solved\n    A = np.array([np.ones(len(xi)), xi, xi ** 2])\n    A = A.T\n    b = yi\n    \n    # Solve the linear system\n    c = solve(A, b)\n    \n    # Return the polynomial coefficients as a list\n    return c.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random number of points between 3 and 10\n    n = random.randint(3, 10)\n    \n    # Generate random xi values sorted to avoid ill-conditioned matrices\n    xi = sorted(np.round(np.random.uniform(-10, 10, n), 2))\n    \n    # Generate random yi values\n    yi = np.round(np.random.uniform(-20, 20, n), 2)\n    \n    return {'xi': xi.tolist(), 'yi': yi.tolist()}", "io_pairs": [], "error_log": []}
{"context": "Given a cryptographic algorithm that generates a sequence of bits using the Blum-Blum-Shub (BBS) pseudorandom number generator, what are the proportions of '1's and '0's in the generated bit string when using specific prime numbers `p` and `q` that satisfy `p % 4 == 3` and `q % 4 == 3`, and generating a specified number of bits `nb`?\n\nThe input and output requirements are as follows:\n\nInput:\n- `nb` (int): The number of bits to generate.\n- `p` (int): A prime number that satisfies `p % 4 == 3`.\n- `q` (int): Another prime number that satisfies `q % 4 == 3`.\n\nOutput:\n- `return` (dict): A dictionary containing the proportions of '1's and '0's in the generated bit string.\n  - `\"proportion_1\"` (float): The proportion of '1's in the bit string.\n  - `\"proportion_0\"` (float): The proportion of '0's in the bit string.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef mod3plus4(a):\n    return a % 4 == 3\n\ndef pgcd(a, b):\n    while a % b != 0:\n        a, b = b, a % b\n    return b\n\ndef findX(n):\n    for i in range(round(n / 2), n):\n        if pgcd(i, n) == 1:\n            return i\n    return -1\n\ndef BBS(nb, p, q):\n    bits = \"\"\n    if mod3plus4(p) and mod3plus4(q):\n        n = p * q\n        x = findX(n)\n        x0 = xi = x**2 % n\n        for i in range(nb):\n            xiPlus1 = xi**2 % n\n            if xi % 2 == 0:\n                bits += \"0\"\n            else:\n                bits += \"1\"\n            xi = xiPlus1\n    return bits\n\n# main function\ndef main_solution(nb, p, q):\n    # Convert inputs to appropriate types if necessary\n    nb = int(nb)\n    p = int(p)\n    q = int(q)\n    \n    # Call the BBS function to generate the bit string\n    bit_string = BBS(nb, p, q)\n    \n    # Calculate the proportion of '1's and '0's in the bit string\n    nb1 = bit_string.count('1')\n    nb0 = bit_string.count('0')\n    proportion_1 = nb1 / len(bit_string)\n    proportion_0 = nb0 / len(bit_string)\n    \n    # Return the proportions as a dictionary\n    return {\n        \"proportion_1\": proportion_1,\n        \"proportion_0\": proportion_0\n    }", "input_generator": "import random\n\ndef input_generator():\n    # Generate p and q as primes congruent to 3 mod 4\n    primes = [x for x in range(100, 1000) if mod3plus4(x) and all(x % i != 0 for i in range(2, int(x**0.5) + 1))]\n    p = random.choice(primes)\n    q = random.choice([x for x in primes if x != p])\n    # Generate nb between 10 and 1000\n    nb = random.randint(10, 1000)\n    return {\"nb\": nb, \"p\": p, \"q\": q}", "io_pairs": [{"input": {"nb": 600, "p": 859, "q": 811}, "output": {"proportion_1": 0.5216666666666666, "proportion_0": 0.47833333333333333}}, {"input": {"nb": 965, "p": 307, "q": 283}, "output": {"proportion_1": 0.4538860103626943, "proportion_0": 0.5461139896373057}}, {"input": {"nb": 678, "p": 151, "q": 691}, "output": {"proportion_1": 0.5206489675516224, "proportion_0": 0.47935103244837757}}, {"input": {"nb": 632, "p": 367, "q": 151}, "output": {"proportion_1": 0.5316455696202531, "proportion_0": 0.46835443037974683}}, {"input": {"nb": 465, "p": 263, "q": 487}, "output": {"proportion_1": 0.5075268817204301, "proportion_0": 0.4924731182795699}}, {"input": {"nb": 786, "p": 607, "q": 631}, "output": {"proportion_1": 0.49363867684478374, "proportion_0": 0.5063613231552163}}, {"input": {"nb": 148, "p": 547, "q": 443}, "output": {"proportion_1": 0.38513513513513514, "proportion_0": 0.6148648648648649}}, {"input": {"nb": 264, "p": 359, "q": 383}, "output": {"proportion_1": 0.5340909090909091, "proportion_0": 0.4659090909090909}}, {"input": {"nb": 222, "p": 643, "q": 599}, "output": {"proportion_1": 0.5045045045045045, "proportion_0": 0.4954954954954955}}, {"input": {"nb": 343, "p": 947, "q": 659}, "output": {"proportion_1": 0.49854227405247814, "proportion_0": 0.5014577259475219}}], "error_log": []}
{"context": "Given a simple pendulum with a known length and initial conditions, how can we determine the period of oscillation by simulating its motion over a specified time interval?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_theta` (float): The initial angle of the pendulum in radians.\n  `initial_angVel` (float): The initial angular velocity of the pendulum in radians per second.\n  `initial_angAcc` (float): The initial angular acceleration of the pendulum in radians per second squared.\n  `time_start` (float): The start time of the simulation in seconds.\n  `time_end` (float): The end time of the simulation in seconds.\n  `num_steps` (int): The number of time steps to simulate.\n\nOutput:\n  `return` (dict): A dictionary containing the key `period` with the value being the calculated period of the pendulum in seconds.", "reference_code": "# import necessary packages\nimport math\nimport numpy as np\nimport scipy.signal as sig\n\n# Constants\ng = -9.81\nl = 0.38\n\n# Function to update the system\ndef update_system(angAcc, theta, angVel, time1, time2):\n    dt = time2 - time1\n    newTheta = theta + angVel * dt\n    newAngVel = angVel + angAcc * dt\n    newAngAcc = (g / l) * math.cos((math.pi / 2) - newTheta)\n    return newTheta, newAngVel, newAngAcc\n\n# Main function\ndef main_solution(initial_theta, initial_angVel, initial_angAcc, time_start, time_end, num_steps):\n    # Convert inputs to appropriate types\n    initial_theta = float(initial_theta)\n    initial_angVel = float(initial_angVel)\n    initial_angAcc = float(initial_angAcc)\n    time_start = float(time_start)\n    time_end = float(time_end)\n    num_steps = int(num_steps)\n\n    # Setting the initial conditions\n    theta = [initial_theta]\n    angVel = [initial_angVel]\n    angAcc = [initial_angAcc]\n    time = np.linspace(time_start, time_end, num_steps)\n\n    # Updating the position and velocity using previous values and time step\n    for i in range(1, len(time)):\n        newTheta, newAngVel, newAngAcc = update_system(angAcc[i-1], theta[i-1], angVel[i-1], time[i-1], time[i])\n        theta.append(newTheta)\n        angVel.append(newAngVel)\n        angAcc.append(newAngAcc)\n\n    # Determining period by averaging time differences\n    theta_pks, _ = sig.find_peaks(theta)\n    peaks = time[theta_pks[1:]]\n    time_difference = np.diff(peaks)\n    period = np.sum(time_difference) / len(time_difference)\n\n    # Return the period as a JSON serializable output\n    return {\"period\": period}", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    initial_theta = random.uniform(-np.pi/4, np.pi/4)  # Reasonable initial angle (-45 to 45 degrees)\n    initial_angVel = random.uniform(-1.0, 1.0)         # Reasonable initial angular velocity\n    initial_angAcc = random.uniform(-2.0, 2.0)         # Reasonable initial angular acceleration\n    time_start = 0.0\n    time_end = random.uniform(5.0, 20.0)               # Simulation duration between 5 and 20 seconds\n    num_steps = random.randint(100, 1000)              # Number of steps between 100 and 1000\n    \n    return {\n        \"initial_theta\": initial_theta,\n        \"initial_angVel\": initial_angVel,\n        \"initial_angAcc\": initial_angAcc,\n        \"time_start\": time_start,\n        \"time_end\": time_end,\n        \"num_steps\": num_steps\n    }", "io_pairs": [{"input": {"initial_theta": 0.12318457164946583, "initial_angVel": 0.38428322670299275, "initial_angAcc": -1.4077881485101154, "time_start": 0.0, "time_end": 19.810800422168715, "num_steps": 924}, "output": {"period": 1.3491335994047726}}, {"input": {"initial_theta": -0.3417556831216248, "initial_angVel": 0.3362353411346306, "initial_angAcc": 1.9755844574069097, "time_start": 0.0, "time_end": 6.947342669114363, "num_steps": 623}, "output": {"period": 1.2658609364945785}}, {"input": {"initial_theta": -0.5030822463390808, "initial_angVel": 0.19460636262483044, "initial_angAcc": 1.5579639470416193, "time_start": 0.0, "time_end": 17.36001896994004, "num_steps": 769}, "output": {"period": 1.5144808215963312}}, {"input": {"initial_theta": -0.601979466389442, "initial_angVel": -0.4223064584235745, "initial_angAcc": 1.5592103071793466, "time_start": 0.0, "time_end": 17.146689340551397, "num_steps": 198}, "output": {"period": NaN}}, {"input": {"initial_theta": 0.3366925443452229, "initial_angVel": -0.061220688358742725, "initial_angAcc": 0.11188452428990248, "time_start": 0.0, "time_end": 15.445360620661274, "num_steps": 561}, "output": {"period": 1.406631056524509}}, {"input": {"initial_theta": -0.5854911046024065, "initial_angVel": -0.4191444780880631, "initial_angAcc": -1.8802016691506482, "time_start": 0.0, "time_end": 19.089889898754933, "num_steps": 929}, "output": {"period": 1.5976811589116018}}, {"input": {"initial_theta": 0.015396843584342568, "initial_angVel": 0.025625788397950044, "initial_angAcc": -0.4494611716203707, "time_start": 0.0, "time_end": 5.685504778180389, "num_steps": 942}, "output": {"period": 1.238606248168948}}, {"input": {"initial_theta": -0.0977758413272366, "initial_angVel": -0.6954045210523314, "initial_angAcc": 0.453004110752381, "time_start": 0.0, "time_end": 5.483540487010617, "num_steps": 891}, "output": {"period": 1.241498211384988}}, {"input": {"initial_theta": 0.0076222264323330124, "initial_angVel": -0.020764010579031433, "initial_angAcc": 1.8769613860300356, "time_start": 0.0, "time_end": 11.02595881444752, "num_steps": 312}, "output": {"period": 1.261122528616184}}, {"input": {"initial_theta": -0.25204257640689043, "initial_angVel": -0.5020394587396801, "initial_angAcc": -0.8160299622209011, "time_start": 0.0, "time_end": 7.788487897059764, "num_steps": 165}, "output": {"period": 1.4247233958036154}}], "error_log": []}
{"context": "In a game of Tic Tac Toe, a player can place either an \"X\" or an \"O\" on a 3x3 grid. Given a specific state of the game board, determine the current status of the game. The possible outcomes are: one player has won, the game is a draw, the game is still ongoing, or the game state is impossible due to invalid moves. What is the current status of the game based on the provided board configuration?\n\nThe input and output requirements are as follows:\n\nInput:\n  `moves` (list of lists of strings): A 3x3 matrix representing the Tic Tac Toe board. Each element can be \"X\", \"O\", or \"_\" (empty).\n\nOutput:\n  `return` (string): The result of the Tic Tac Toe game. Possible values are:\n  - \"X wins\" if X has won the game.\n  - \"O wins\" if O has won the game.\n  - \"Draw\" if the game is a draw.\n  - \"Game not finished\" if the game is still ongoing.\n  - \"Impossible\" if the game state is invalid (e.g., more than one player has more than one extra move).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef check_diagonal(moves):\n    ''' checks if there is a winning game in the diagonals'''\n    dia = \"\"\n    dia_check = []\n    exes = [\"X\", \"X\", \"X\"]\n    oohs = [\"O\", \"O\", \"O\"]\n    for i in range(3):\n        if moves[i][i] == \"X\" or moves[i][i] == \"O\":\n            dia_check.append(moves[i][i])\n        else:\n            dia_check.append(\" \")\n    if dia_check == exes or dia_check == oohs:\n        dia = dia_check[0]\n        return dia\n    else:\n        for i in range(3):\n            j = 2\n            check_dia = []\n            for i in range(3):\n                check_dia.append(moves[i][j])\n                j -= 1\n            if check_dia == exes or check_dia == oohs:\n                dia = check_dia[0]\n        return dia\n\ndef check_columns(moves):\n    ''' checks if there is a winning game in the columns'''\n    col = \"\"\n    check = [[], [], []]\n    exes = [\"X\", \"X\", \"X\"]\n    oohs = [\"O\", \"O\", \"O\"]\n    for i in range(len(moves)):\n        for j in range(len(moves)):\n            if moves[j][i] == \"X\" or moves[j][i] == \"O\":\n                check[j].append(moves[j][i])\n            else:\n                check[j].append(\" \")\n    for i in range(len(check)):\n        if check[i] == exes or check[i] == oohs:\n            col = check[i][0]\n            return col\n    return col\n\ndef check_rows(moves):\n    ''' checks if there is a winning game in the rows '''\n    rows = \"\"\n    check = [[], [], []]\n    exes = [\"X\", \"X\", \"X\"]\n    oohs = [\"O\", \"O\", \"O\"]\n    for i in range(len(moves)):\n        for j in range(len(moves)):\n            if moves[i][j] == \"X\" or moves[i][j] == \"O\":\n                check[i].append(moves[i][j])\n            else:\n                check[i].append(\" \")\n    for i in range(len(check)):\n        if check[i] == exes or check[i] == oohs:\n            rows = check[i][0]\n            return rows\n    return rows\n\ndef check_x_o(moves):\n    ''' returns a true / false flag if there are more X's (O's) than O's (X's) '''\n    x_list = [char for group in moves for char in group if char == \"X\"]\n    o_list = [char for group in moves for char in group if char == \"O\"]\n    difference = abs(len(x_list) - len(o_list))\n    if difference >= 2:\n        return True\n    return False\n\ndef draw_case(diagonal, column, rows, moves):\n    ''' returns a true / false flag to see if the game is a draw'''\n    count = [char for words in moves for char in words if char == \"X\" or char == \"O\"]\n    if len(diagonal) == 0 and len(column) == 0 and len(rows) == 0 and len(count) == 9:\n        return True\n    return False\n\n# main function\ndef main_solution(moves):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    if check_x_o(moves):\n        return \"Impossible\"\n    \n    diag = check_diagonal(moves)\n    col = check_columns(moves)\n    row = check_rows(moves)\n    \n    if draw_case(diag, col, row, moves):\n        return \"Draw\"\n    elif len(diag) == 1:\n        return f\"{diag} wins\"\n    elif len(col) == 1:\n        return f\"{col} wins\"\n    elif len(row) == 1:\n        return f\"{row} wins\"\n    else:\n        return \"Game not finished\"\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    moves = [[' ' for _ in range(3)] for _ in range(3)]\n    players = ['X', 'O']\n    current_player = random.choice(players)\n    total_moves = random.randint(0, 9)\n    \n    for _ in range(total_moves):\n        while True:\n            i, j = random.randint(0, 2), random.randint(0, 2)\n            if moves[i][j] == ' ':\n                moves[i][j] = current_player\n                current_player = 'O' if current_player == 'X' else 'X'\n                break\n    \n    # Ensure some randomness in the outcome\n    if random.random() < 0.3:\n        # Force a win condition\n        winner = random.choice(['X', 'O'])\n        if random.choice([True, False]):\n            # Row win\n            row = random.randint(0, 2)\n            for j in range(3):\n                moves[row][j] = winner\n        else:\n            # Column win\n            col = random.randint(0, 2)\n            for i in range(3):\n                moves[i][col] = winner\n    elif random.random() < 0.2:\n        # Force a diagonal win\n        winner = random.choice(['X', 'O'])\n        if random.choice([True, False]):\n            for i in range(3):\n                moves[i][i] = winner\n        else:\n            for i in range(3):\n                moves[i][2 - i] = winner\n    elif random.random() < 0.1:\n        # Force a draw\n        for i in range(3):\n            for j in range(3):\n                if moves[i][j] == ' ':\n                    moves[i][j] = random.choice(['X', 'O'])\n    \n    return {'moves': moves}", "io_pairs": [{"input": {"moves": [["X", "O", "O"], ["X", "O", "X"], ["O", "X", "X"]]}, "output": "O wins"}, {"input": {"moves": [["X", "X", "X"], ["O", "X", "O"], ["O", "X", "O"]]}, "output": "X wins"}, {"input": {"moves": [["X", "O", "X"], ["X", "X", " "], ["X", "O", " "]]}, "output": "Impossible"}, {"input": {"moves": [["X", "X", "X"], ["O", "X", "O"], ["X", "X", "O"]]}, "output": "Impossible"}, {"input": {"moves": [["X", " ", "O"], [" ", " ", "O"], [" ", " ", "O"]]}, "output": "Impossible"}, {"input": {"moves": [["X", " ", "O"], ["X", " ", "O"], ["X", " ", "X"]]}, "output": "Impossible"}, {"input": {"moves": [["O", " ", " "], [" ", " ", " "], [" ", " ", " "]]}, "output": "Game not finished"}, {"input": {"moves": [["O", " ", " "], ["X", " ", " "], [" ", " ", " "]]}, "output": "Game not finished"}, {"input": {"moves": [["O", " ", "O"], ["X", "X", " "], ["O", "X", "O"]]}, "output": "Game not finished"}, {"input": {"moves": [["X", "X", "X"], ["X", "X", "O"], ["X", "O", "O"]]}, "output": "Impossible"}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, given an initial state of the board and the player who wishes to win, what is the optimal outcome for the player according to the minimax algorithm? The initial state is represented by a string of 9 characters separated by commas, where each character can be 'X', 'O', or ' ' (space). The player is either 'X' or 'O'.\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_state` (str): A string representing the initial state of the Tic-Tac-Toe board. The string should contain 9 characters separated by commas, where each character can be 'X', 'O', or ' ' (space). For example, \"X,O, , ,X, , , ,O\".\n  `player` (str): A string representing the player ('X' or 'O') who wishes to win.\n\nOutput:\n  `return` (dict): A dictionary containing the minimax value for the current state of the board. The key is \"minimax_value\" and the value is an integer (-1, 0, or 1) representing the outcome for the player: 1 for a win, 0 for a draw, and -1 for a loss.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef GameOver(state):\n    if state[0] == state[3] == state[6] == \"X\":\n        return True, \"Player X\"\n    elif state[0] == state[3] == state[6] == \"O\":\n        return True, \"Player O\"\n    elif state[1] == state[4] == state[7] == \"X\":\n        return True, \"Player X\"\n    elif state[1] == state[4] == state[7] == \"O\":\n        return True, \"Player O\"\n    elif state[2] == state[5] == state[8] == \"X\":\n        return True, \"Player X\"\n    elif state[2] == state[5] == state[8] == \"O\":\n        return True, \"Player O\"\n    elif state[0] == state[1] == state[2] == \"X\":\n        return True, \"Player X\"\n    elif state[0] == state[1] == state[2] == \"O\":\n        return True, \"Player O\"\n    elif state[3] == state[4] == state[5] == \"X\":\n        return True, \"Player X\"\n    elif state[3] == state[4] == state[5] == \"O\":\n        return True, \"Player O\"\n    elif state[6] == state[7] == state[8] == \"X\":\n        return True, \"Player X\"\n    elif state[6] == state[7] == state[8] == \"O\":\n        return True, \"Player O\"\n    elif state[0] == state[4] == state[8] == \"X\":\n        return True, \"Player X\"\n    elif state[0] == state[4] == state[8] == \"O\":\n        return True, \"Player O\"\n    elif state[2] == state[4] == state[6] == \"X\":\n        return True, \"Player X\"\n    elif state[2] == state[4] == state[6] == \"O\":\n        return True, \"Player O\"\n    for i in range(9):\n        if state[i] == \" \":\n            return False, \" \"\n    return True, \"No one\"\n\ndef legal_pos(state):\n    pos = []\n    for i in range(len(state)):\n        if state[i] == \" \":\n            pos.append(i)\n    return pos\n\ndef sts(state, turn):\n    sts = []\n    temp = list(state)\n    for pos in legal_pos(state):\n        temp[pos] = turn\n        sts.append(temp)\n        temp = list(state)\n    return sts\n\ndef switch(turn):\n    if turn == \"X\":\n        return \"O\"\n    else:\n        return \"X\"\n\ndef minimax(S, player, turn):\n    if GameOver(S)[0]:\n        player = \"Player \" + player\n        if GameOver(S)[1] == player:\n            return 1\n        elif GameOver(S)[1] == \"No one\":\n            return 0\n        else:\n            return -1\n\n    if player == turn:\n        values = []\n        for item in sts(S, turn):\n            values.append(minimax(item, player, switch(turn)))\n        return max(values)\n    else:\n        values = []\n        for item in sts(S, turn):\n            values.append(minimax(item, player, switch(turn)))\n        return min(values)\n\n# main function\ndef main_solution(initial_state, player):\n    # Convert the initial_state string to a list\n    state = initial_state.split(\",\")\n    \n    # Determine the next turn based on the number of moves already made\n    turn = \"X\" if state.count(\"X\") == state.count(\"O\") else \"O\"\n    \n    # Get the minimax value for the current state\n    value = minimax(state, player, turn)\n    \n    # Return the value as a dictionary\n    return {\"minimax_value\": value}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random initial state for the Tic-Tac-Toe board\n    symbols = ['X', 'O', ' ']\n    state = [random.choice(symbols) for _ in range(9)]\n    \n    # Ensure the state is not already a terminal state\n    while GameOver(state)[0]:\n        state = [random.choice(symbols) for _ in range(9)]\n    \n    # Randomly choose a player\n    player = random.choice(['X', 'O'])\n    \n    # Convert the state list to a comma-separated string\n    initial_state = \",\".join(state)\n    \n    return {\"initial_state\": initial_state, \"player\": player}", "io_pairs": [{"input": {"initial_state": " , ,X, ,X, ,O,O, ", "player": "O"}, "output": {"minimax_value": -1}}, {"input": {"initial_state": "O,X,O, ,X, ,X, ,X", "player": "X"}, "output": {"minimax_value": 0}}, {"input": {"initial_state": " ,O,O, ,X,O, , ,X", "player": "O"}, "output": {"minimax_value": 1}}, {"input": {"initial_state": "O,O, ,X,X,O, , , ", "player": "X"}, "output": {"minimax_value": -1}}, {"input": {"initial_state": " , , , , ,O,O, , ", "player": "O"}, "output": {"minimax_value": 1}}, {"input": {"initial_state": " ,O,O,O, ,X,X,X,O", "player": "X"}, "output": {"minimax_value": -1}}, {"input": {"initial_state": "X, ,X,X, ,O, ,X,O", "player": "O"}, "output": {"minimax_value": -1}}, {"input": {"initial_state": "X,O,O,X,O, , ,X,X", "player": "O"}, "output": {"minimax_value": 1}}, {"input": {"initial_state": "O,X,O,X,X, , , ,X", "player": "X"}, "output": {"minimax_value": 1}}, {"input": {"initial_state": "O, ,O,O,X, ,X, , ", "player": "X"}, "output": {"minimax_value": -1}}], "error_log": []}
{"context": "Given a function \\( f(x) = 2x_0^2 + 2x_0x_1 + x_1^2 \\), we want to find the minimum value of this function using the gradient descent method. What are the final values of \\( x \\) and \\( y \\) (denoted as `final_x`) and the corresponding minimum value of the function \\( f(x) \\) (denoted as `final_f_x`) when starting from a random initial point `initial_x` with a given learning rate `rho` and precision `precision`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_x` (list of float): A list containing the initial values for the variables x and y.\n  `rho` (float): The learning rate for the gradient descent algorithm.\n  `precision` (float): The precision threshold for stopping the gradient descent algorithm.\n\nOutput:\n  `return` (dict): A dictionary containing the final values of x and y (`final_x`) and the final value of the function f(x) (`final_f_x`).", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(initial_x, rho, precision):\n    # Convert JSON serializable inputs to numpy array\n    x = np.array(initial_x)\n    \n    def f(x):\n        return 2*x[0]**2 + 2*x[0]*x[1] + x[1]**2\n\n    def df(x):\n        dx = 4*x[0] + 2*x[1]\n        dy = 2*x[0] + 2*x[1]\n        return np.array([dx, dy])\n    \n    diff = 100\n    \n    while diff > precision:\n        dr = df(x)\n        prev_x = x\n        x = x - rho * dr\n        diff = np.dot(x - prev_x, x - prev_x)\n    \n    # Convert numpy array to list for JSON serialization\n    final_x = x.tolist()\n    final_f_x = f(x)\n    \n    return {\"final_x\": final_x, \"final_f_x\": final_f_x}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    initial_x = [random.uniform(-10.0, 10.0), random.uniform(-10.0, 10.0)]\n    rho = random.uniform(0.001, 0.1)\n    precision = random.uniform(1e-6, 1e-4)\n    return {\"initial_x\": initial_x, \"rho\": rho, \"precision\": precision}", "io_pairs": [{"input": {"initial_x": [6.422636815519322, -3.564504118032139], "rho": 0.07775256470245351, "precision": 7.058593704238809e-05}, "output": {"final_x": [0.0669148693868426, -0.10827053302065101], "final_f_x": 0.006187890659650908}}, {"input": {"initial_x": [-4.978354468452162, 6.545422658183863], "rho": 0.06481105851076051, "precision": 3.064024165221696e-05}, "output": {"final_x": [-0.054604782884767174, 0.08835239465586132], "final_f_x": 0.004120583614145053}}, {"input": {"initial_x": [-3.8188611945464546, 5.111818089633999], "rho": 0.08697302294626262, "precision": 3.3537371716442526e-05}, "output": {"final_x": [-0.04102146599657111, 0.06637412625080012], "final_f_x": 0.0023255180544742033}}, {"input": {"initial_x": [7.846068839387826, -4.333507454772905], "rho": 0.03651747641794855, "precision": 7.57840865489743e-05}, "output": {"final_x": [0.1586361159174063, -0.2566786271869956], "final_f_x": 0.034777751289408305}}, {"input": {"initial_x": [-9.265191337795148, 8.38657332880252], "rho": 0.06333704761781771, "precision": 4.1015388390460675e-05}, "output": {"final_x": [-0.06585015241229435, 0.1065477847674526], "final_f_x": 0.00599253985203802}}, {"input": {"initial_x": [9.230057050770387, -8.222637438699195], "rho": 0.020580783883902904, "precision": 8.502978705647528e-05}, "output": {"final_x": [0.30188753548657127, -0.48846429086038246], "final_f_x": 0.1259469697279748}}, {"input": {"initial_x": [-5.037628765200129, 0.984622420464671], "rho": 0.058594561950331296, "precision": 5.411454181686393e-05}, "output": {"final_x": [-0.08140894373712709, 0.13172243784688875], "final_f_x": 0.009158863809927746}}, {"input": {"initial_x": [4.182659972306709, -0.8463864474019083], "rho": 0.012524164372550124, "precision": 2.6323518272041513e-05}, "output": {"final_x": [0.2772248494717068, -0.44852541217769437], "final_f_x": 0.10619749994799846}}, {"input": {"initial_x": [1.8620891734091298, -4.9398225403556095], "rho": 0.049501743213630184, "precision": 3.189528802468897e-05}, "output": {"final_x": [0.07554168974390785, -0.12222902157471235], "final_f_x": 0.007886253842844483}}, {"input": {"initial_x": [-6.388079479528638, 0.9691413500046124], "rho": 0.024978378778835676, "precision": 3.878001867335238e-05}, "output": {"final_x": [-0.16635175487861886, 0.269162728256987], "final_f_x": 0.03824300259820362}}], "error_log": []}
{"context": "Given a binary tree represented by a list of integers and `None` values, where each integer represents a node's value and `None` represents a missing node, determine whether the binary tree is a Binary Search Tree (BST). A BST is defined as a binary tree where the value of every node in the left subtree is less than the node's value, and the value of every node in the right subtree is greater than the node's value. What is the result of checking if the given binary tree is a BST?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (list of integers or None): A list representing the binary tree structure. Each element in the list represents a node's value, with `None` indicating a missing node. The list is constructed in a level-order traversal manner.\n\nOutput:\n  `return` (boolean): `True` if the binary tree is a Binary Search Tree (BST), otherwise `False`.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef isBST(node, l=None, r=None):\n    if node is None:\n        return True\n\n    if l is not None and l.data > node.data:\n        return False\n\n    if r is not None and r.data < node.data:\n        return False\n\n    return isBST(node.left, l, node) and isBST(node.right, node, r)\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = Node(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            current = queue.pop(0)\n            if nodes[i] is not None:\n                current.left = Node(nodes[i])\n                queue.append(current.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                current.right = Node(nodes[i])\n                queue.append(current.right)\n            i += 1\n        return root\n\n    root = build_tree(tree_structure)\n    \n    # Call the original function with the converted input\n    result = isBST(root)\n    \n    # Convert the result to a JSON serializable output\n    return result", "input_generator": "import random\nimport json\n\ndef input_generator():\n    # Generate a random binary tree structure that may or may not be a BST\n    # The tree is represented as a list in level-order traversal with None for missing nodes\n    # The size of the tree is randomly chosen between 1 and 15 nodes\n    size = random.randint(1, 15)\n    tree = []\n    for _ in range(size):\n        # Randomly decide to include a node or None (with higher probability for nodes)\n        if random.random() < 0.8:\n            tree.append(random.randint(-100, 100))\n        else:\n            tree.append(None)\n    # Ensure at least one node is present\n    if all(x is None for x in tree):\n        tree[0] = random.randint(-100, 100)\n    return {'tree_structure': tree}", "io_pairs": [{"input": {"tree_structure": [-3, 90, null, null, null, null, 52, null, null, -96, null, 36, null, -9, -72]}, "output": false}, {"input": {"tree_structure": [38, null, 12, 45, 53]}, "output": false}, {"input": {"tree_structure": [44, 44, 85, null, 48, -49, null, null, 39, 9, -47, -61, 4, null, 76]}, "output": false}, {"input": {"tree_structure": [73, 80, 65, 51, null, -16, -53, 39, 86]}, "output": false}, {"input": {"tree_structure": [-27, 42, -69, 52, 18, null, -52, -10, 20, -9, -48, 78]}, "output": false}, {"input": {"tree_structure": [-100, -79, -8, -19, 9, null, null, -61, -17, 0, null, null, -19, null, 94]}, "output": false}, {"input": {"tree_structure": [18, 83, 99, null, 72, 95, -99, -52, 90]}, "output": false}, {"input": {"tree_structure": [-28]}, "output": true}, {"input": {"tree_structure": [74, null, 36, 82, 23, 77, null, 22]}, "output": false}, {"input": {"tree_structure": [-71, -81, -92, 22]}, "output": false}], "error_log": []}
{"context": "Given two fractions represented by their numerators and denominators, and an operation to perform on these fractions, what is the resulting fraction after performing the specified operation?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numerator1` (str): The numerator of the first fraction.\n  `denominator1` (str): The denominator of the first fraction.\n  `numerator2` (str): The numerator of the second fraction.\n  `denominator2` (str): The denominator of the second fraction.\n  `operation` (str): The operation to perform on the fractions. Possible values are \"add\", \"subtract\", \"multiply\", and \"divide\".\n\nOutput:\n  `return` (dict): A dictionary containing the result of the operation.\n    - `numerator` (str): The numerator of the resulting fraction.\n    - `denominator` (str): The denominator of the resulting fraction.", "reference_code": "# import necessary packages\nimport sympy as sm\nimport random\n\n# all class and function definitions in the code file, if any\nclass fraction(object):\n    def __init__(self, top, bottom):\n        try:\n            top = sm.simplify(top)\n            bottom = sm.simplify(bottom)\n            top = str(top)\n            bottom = str(bottom)\n    \n            self.top = top\n            self.bottom = bottom\n            \n        except:\n            print(\"Something went wrong, Please fellow python standard notation.\")\n            return None\n        \n    def __str__(self):\n        nume = \"(\" + self.top + \")\"\n        demo = \"(\" + self.bottom + \")\"\n        return nume +'/' + demo\n    \n    def __eq__(self, other):\n        if self.top == other.top and self.bottom == other.bottom:\n            return True\n        else:\n            return False\n    \n    def __mul__(self, other):\n        nume = self.paren()[0] + '*' + other.paren()[0]\n        demo = self.paren()[1] + '*' + other.paren()[1]\n        \n        try:\n            nume = str(sm.simplify(nume))\n            demo = str(sm.simplify(demo))\n            \n            return fraction(nume, demo)\n        except:\n            print(\"Something is wrong, try again with different notation please.\")\n            return None\n        \n    def paren(self):\n        nume = \"(\" + self.top + ')'\n        deno = \"(\" + self.bottom + ')'\n         \n        return (nume, deno)\n    \n    def __add__(self, other):\n        terms = fraction.adder(self, other)\n        deno = terms[0]\n        numer = terms[1] + '+' + terms[2]\n        try:\n            deno = str(sm.simplify(deno))\n            numer = str(sm.simplify(numer))\n            \n            return fraction(numer, deno)\n        except:\n            print(\"Something was wrong with addition\")\n            return None\n        \n    def adder(self, other):\n        selftop = self.paren()[0]\n        selfbottom = self.paren()[1]\n        \n        othertop = other.paren()[0]\n        otherbottom = other.paren()[0]\n        \n        deno = selfbottom + '*' + otherbottom\n        term1 = selftop + '*' + otherbottom\n        term2 = othertop + '*' + selfbottom\n        \n        return (deno, term1, term2)\n    \n    def __sub__(self, other):\n        terms = fraction.adder(self, other)\n        numer = terms[1] + '-' + terms[2]\n        denom = terms[0]\n        \n        try:\n            top = str(sm.simplify(numer))\n            bottom = str(sm.simplify(denom))\n            \n            return fraction(top, bottom)\n        \n        except:\n            print(\"Something wrong with the sub.\")\n            return None\n        \n    def get_numer(self):\n        return str(self.top)\n    \n    def get_denom(self):\n        return str(self.bottom)\n    \n    def set_numer(self, numer = ''):\n        \n        self.top = numer\n        return self\n    \n    def set_denom(self, denom):\n        try:\n            denom = str(denom)\n            if denom != '0':\n                self.bottom = denom\n                return self\n            else:\n                print(\"Division by Zero\")\n                return None\n        except:\n            print(\"Soemthing was wrong with set_denom.\")\n            \n    def reset(self):\n        numer = str(sm.simplify(self.top))\n        denom = str(sm.simplify(self.bottom))\n        \n        return fraction(numer, denom)\n            \n            \n    def __division__(self, other):\n        numer1 = self.paren()[0]\n        denom1 = self.paren()[1]\n        numer2 = other.paren()[0]\n        denom2 = other.paren()[1]\n        \n        new_numer = numer1 + '*' + denom2\n        new_denom = denom1 + '*' + numer2\n        \n        try:\n            top = str(sm.simplify(new_numer))\n            bottom = str(sm.simplify(new_denom))\n            \n            return fraction(top, bottom)\n        except:\n            print(\"something was wrong here\")\n            return None\n        \n        \n    def evaluate(self, value):\n        numer = str(sm.simplify(self.top))\n        denom = str(sm.simplify(self.bottom))\n        \n        x = value\n        numerval = eval(numer)\n        denomval = eval(denom)\n        \n        return numerval/denomval\n\n# main function\ndef main_solution(numerator1, denominator1, numerator2, denominator2, operation):\n    # Convert JSON serializable inputs to original input variables\n    frac1 = fraction(numerator1, denominator1)\n    frac2 = fraction(numerator2, denominator2)\n    \n    # Perform the operation\n    if operation == \"add\":\n        result = frac1 + frac2\n    elif operation == \"subtract\":\n        result = frac1 - frac2\n    elif operation == \"multiply\":\n        result = frac1 * frac2\n    elif operation == \"divide\":\n        result = frac1.__division__(frac2)\n    else:\n        raise ValueError(\"Invalid operation\")\n    \n    # Convert the result to JSON serializable output\n    return {\n        \"numerator\": result.get_numer(),\n        \"denominator\": result.get_denom()\n    }", "input_generator": "import random\nimport sympy as sm\n\ndef input_generator():\n    operations = [\"add\", \"subtract\", \"multiply\", \"divide\"]\n    operation = random.choice(operations)\n    \n    # Generate simple polynomial expressions or integers\n    def generate_expression():\n        x = sm.symbols('x')\n        choices = [\n            str(random.randint(1, 10)),\n            f\"{random.randint(1, 5)}*x + {random.randint(1, 5)}\",\n            f\"x**{random.randint(1, 3)}\",\n            f\"{random.randint(1, 3)}*x**2 + {random.randint(1, 3)}*x + {random.randint(1, 3)}\"\n        ]\n        return random.choice(choices)\n    \n    numerator1 = generate_expression()\n    denominator1 = generate_expression()\n    numerator2 = generate_expression()\n    denominator2 = generate_expression()\n    \n    # Ensure denominators are not zero\n    while denominator1 == '0' or denominator2 == '0':\n        denominator1 = generate_expression()\n        denominator2 = generate_expression()\n    \n    return {\n        \"numerator1\": numerator1,\n        \"denominator1\": denominator1,\n        \"numerator2\": numerator2,\n        \"denominator2\": denominator2,\n        \"operation\": operation\n    }", "io_pairs": [{"input": {"numerator1": "6", "denominator1": "2*x + 2", "numerator2": "2*x + 1", "denominator2": "4*x + 3", "operation": "subtract"}, "output": {"numerator": "-4*x**2 + 6*x + 4", "denominator": "2*(x + 1)*(2*x + 1)"}}, {"input": {"numerator1": "4*x + 5", "denominator1": "3*x**2 + 2*x + 2", "numerator2": "3*x + 1", "denominator2": "7", "operation": "multiply"}, "output": {"numerator": "(3*x + 1)*(4*x + 5)", "denominator": "21*x**2 + 14*x + 14"}}, {"input": {"numerator1": "10", "denominator1": "6", "numerator2": "3", "denominator2": "2*x**2 + 1*x + 3", "operation": "subtract"}, "output": {"numerator": "12", "denominator": "18"}}, {"input": {"numerator1": "7", "denominator1": "1*x**2 + 2*x + 1", "numerator2": "x**2", "denominator2": "2*x**2 + 3*x + 2", "operation": "subtract"}, "output": {"numerator": "x**2*(-x**2 - 2*x + 6)", "denominator": "x**2*(x**2 + 2*x + 1)"}}, {"input": {"numerator1": "x**3", "denominator1": "3*x + 5", "numerator2": "x**2", "denominator2": "9", "operation": "divide"}, "output": {"numerator": "9*x**3", "denominator": "x**2*(3*x + 5)"}}, {"input": {"numerator1": "x**3", "denominator1": "2", "numerator2": "7", "denominator2": "3*x + 4", "operation": "multiply"}, "output": {"numerator": "7*x**3", "denominator": "6*x + 8"}}, {"input": {"numerator1": "1*x + 4", "denominator1": "3*x**2 + 3*x + 2", "numerator2": "5", "denominator2": "3*x + 4", "operation": "divide"}, "output": {"numerator": "(x + 4)*(3*x + 4)", "denominator": "15*x**2 + 15*x + 10"}}, {"input": {"numerator1": "2*x + 5", "denominator1": "2*x + 3", "numerator2": "5*x + 1", "denominator2": "1*x**2 + 3*x + 2", "operation": "multiply"}, "output": {"numerator": "(2*x + 5)*(5*x + 1)", "denominator": "(2*x + 3)*(x**2 + 3*x + 2)"}}, {"input": {"numerator1": "x**2", "denominator1": "1*x**2 + 2*x + 3", "numerator2": "5*x + 1", "denominator2": "3*x**2 + 2*x + 3", "operation": "multiply"}, "output": {"numerator": "x**2*(5*x + 1)", "denominator": "(x**2 + 2*x + 3)*(3*x**2 + 2*x + 3)"}}, {"input": {"numerator1": "x**1", "denominator1": "x**2", "numerator2": "2*x + 1", "denominator2": "1", "operation": "divide"}, "output": {"numerator": "x", "denominator": "x**2*(2*x + 1)"}}], "error_log": []}
{"context": "Given a 9x9 Sudoku grid, where each cell can either be a digit from '1' to '9' or a dot '.' representing an empty cell, determine whether the grid is valid according to the Sudoku rules. Specifically, each row, column, and 3x3 sub-grid must contain unique digits from '1' to '9'. Is the provided Sudoku grid valid?\n\nThe input and output requirements are as follows:\n\nInput:\n  `grid` (list of strings): A 9x9 grid represented as a list of 9 strings, where each string contains 9 characters. Each character can be a digit from '1' to '9' or a dot '.' representing an empty cell.\n\nOutput:\n  `return` (boolean): Returns `True` if the Sudoku grid is valid according to the rules (each row, column, and 3x3 sub-grid contains unique digits from '1' to '9'), otherwise returns `False`.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(grid):\n    # Convert the input grid to a list of lists of strings\n    grid = [list(row) for row in grid]\n    \n    # Check each 3x3 sub-grid\n    for i in range(0, 7, 3):\n        for j in range(0, 7, 3):\n            check_list = [0] * 10\n            for row in range(i, i + 3):\n                for col in range(j, j + 3):\n                    if grid[row][col].isdigit():\n                        check_list[int(grid[row][col])] += 1\n                        if check_list[int(grid[row][col])] > 1:\n                            return False\n    \n    # Check each row\n    for i in range(9):\n        check_list_row = [0] * 10\n        for j in range(9):\n            if grid[i][j].isdigit():\n                check_list_row[int(grid[i][j])] += 1\n                if check_list_row[int(grid[i][j])] > 1:\n                    return False\n    \n    # Check each column\n    for i in range(9):\n        check_list_col = [0] * 10\n        for j in range(9):\n            if grid[j][i].isdigit():\n                check_list_col[int(grid[j][i])] += 1\n                if check_list_col[int(grid[j][i])] > 1:\n                    return False\n    \n    return True", "input_generator": "import random\n\ndef input_generator():\n    # Generate a valid Sudoku grid with some random elements replaced by '.'\n    grid = [['.' for _ in range(9)] for _ in range(9)]\n    \n    # Fill the grid with a valid Sudoku solution\n    for i in range(9):\n        for j in range(9):\n            grid[i][j] = str((i * 3 + i // 3 + j) % 9 + 1)\n    \n    # Randomly shuffle rows within the same block\n    for block in range(3):\n        rows = list(range(block * 3, block * 3 + 3))\n        random.shuffle(rows)\n        new_grid = [grid[i] for i in rows]\n        for i in range(3):\n            grid[block * 3 + i] = new_grid[i]\n    \n    # Randomly shuffle columns within the same block\n    for block in range(3):\n        cols = list(range(block * 3, block * 3 + 3))\n        random.shuffle(cols)\n        for i in range(9):\n            new_row = [grid[i][j] for j in cols]\n            for j in range(3):\n                grid[i][block * 3 + j] = new_row[j]\n    \n    # Randomly replace some digits with '.'\n    for i in range(9):\n        for j in range(9):\n            if random.random() < 0.5:\n                grid[i][j] = '.'\n    \n    # Convert each row to a string\n    grid = [''.join(row) for row in grid]\n    \n    return {'grid': grid}", "io_pairs": [{"input": {"grid": [".2.65497.", "...987...", "....21..5", "56.1.842.", ".347.5..9", "891...756", "..25.386.", "6.8.1..3.", "...8..29."]}, "output": true}, {"input": {"grid": [".2.4...7.", "987......", ".547..3.2", "4325.618.", ".6.8.942.", ".9....75.", "2.93....7", "87.921...", "54.6..2.1"]}, "output": true}, {"input": {"grid": [".64......", ".3.6.5897", "8.7.1.564", "...1893.2", "9.8.2367.", ".4.75691.", "1295...86", "4....71..", ".86291..."]}, "output": true}, {"input": {"grid": [".325.....", "465.97...", ".9.2...4.", ".4...5...", ".76..8.2.", "8..3.2.5.", "9....3..8", "....86.9.", ".87.2...5"]}, "output": true}, {"input": {"grid": ["9.....5.4", "6.478.2..", "3..4.68.7", "1..2.4..5", "..58.1..2", ".32.6...8", "8.69.2.53", "219345786", "5.3.781.9"]}, "output": true}, {"input": {"grid": ["56..7..1.", "...6..9..", "897.1...5", "342.56...", "9.842..5.", "675..94..", ".538.72.1", "..62915.4", "...5.4.6."]}, "output": true}, {"input": {"grid": ["465.9..31", "132..58..", "79.1...6.", "..9243...", "2.3..69..", "......342", "3.46.7..9", "9.1.5..86", ".87.2..53"]}, "output": true}, {"input": {"grid": ["7.92.354.", "4....92.3", ".2..46879", "...98.3..", "23...7.81", "8913..65.", "..2435...", "..5.6.19.", ".78...4.."]}, "output": true}, {"input": {"grid": ["5.67.8...", ".....57.8", "...1...65", ".....3576", "32.....19", "...81..4.", "768.213..", ".35.87.21", "1..3546.."]}, "output": true}, {"input": {"grid": ["8....3.4.", ".31....78", "564.79..2", ".4.6...8.", "....2.75.", ".759.1423", "...1..5.4", "1294..8.7", ".537.82.."]}, "output": true}], "error_log": []}
{"context": "Given a list of strings where each string consists of parentheses, how many valid parentheses expressions can be formed by combining these strings?\n\nThe input and output requirements are as follows:\n\nInput:\n  `pairs_list` (list of strings): A list of strings where each string represents a sequence of parentheses.\n\nOutput:\n  `return` (int): The number of valid parentheses expressions that can be formed from the given list of strings.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef get_pairs(pairs_list):\n    leftmap = {}\n    rightmap = {}\n    stack = []\n    com = 0\n    for pairs in pairs_list:\n        for s in pairs:\n            if s == \"(\":\n                stack.append(s)\n            else:\n                if len(stack) == 0:\n                    stack.append(s)\n                else:\n                    if stack[-1] == \"(\":\n                        stack.pop()\n                    else:\n                        stack.append(s)\n        if len(stack) == 0:\n            com += 1\n            continue\n        \n        ln = rn = 0\n        while len(stack) > 0:\n            top = stack.pop()\n            if top == \"(\":\n                ln += 1\n            elif top == \")\":\n                rn += 1\n        \n        if ln == 0:\n            if rn in rightmap.keys():\n                rightmap[rn] += 1\n            else:\n                rightmap.update({rn: 1})\n        \n        if rn == 0:\n            if ln in leftmap:\n                leftmap[ln] += 1\n            else:\n                leftmap.update({ln: 1})\n    \n    sumpairs = com * com\n    for key in leftmap.keys():\n        r = rightmap[key] if key in rightmap.keys() else 0\n        sumpairs += r * leftmap[key]\n        \n    return sumpairs\n\n# main function\ndef main_solution(pairs_list):\n    # Convert the input list of strings to a list of lists of characters\n    pairs = [list(i) for i in pairs_list]\n    # Call the get_pairs function to get the result\n    result = get_pairs(pairs)\n    # Return the result\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 20)\n    pairs_list = []\n    for _ in range(n):\n        length = random.randint(1, 20)\n        s = []\n        balance = 0\n        for _ in range(length):\n            if random.random() < 0.5:\n                s.append('(')\n                balance += 1\n            else:\n                if balance > 0 and random.random() < 0.7:\n                    s.append(')')\n                    balance -= 1\n                else:\n                    s.append(')')\n        pairs_list.append(''.join(s))\n    return {'pairs_list': pairs_list}", "io_pairs": [{"input": {"pairs_list": ["))())((", ")", "()((", ")()))))(()(()((()", ")((())))))))(()()()"]}, "output": 0}, {"input": {"pairs_list": ["((())())(()))()((", "))())))()((()("]}, "output": 0}, {"input": {"pairs_list": ["()"]}, "output": 1}, {"input": {"pairs_list": ["())())())(((((", "))())())))()()())", "((()()))((((", "())(()()("]}, "output": 0}, {"input": {"pairs_list": ["())())()(()", ")()))(((()(()())(()", "))())"]}, "output": 0}, {"input": {"pairs_list": [")((((((())))(((()"]}, "output": 0}, {"input": {"pairs_list": ["))(()((()()))))(", "())(()()(((", "(()((())((())())))", ")(()()()", "(()", "(())())(()()())((", "()))))((()()()(", "())(((()((()((()"]}, "output": 1}, {"input": {"pairs_list": ["()(((((())(())((((", "()))))((", ")))((((", "()(()()(("]}, "output": 0}, {"input": {"pairs_list": ["()()((", "(((()))))(", "())()())()()))()(((", "(())()((((", "))()))())))))()()((", "()(()(()()("]}, "output": 0}, {"input": {"pairs_list": ["(()((()(())))(((()", "))))))()", "())))()((()((()("]}, "output": 0}], "error_log": []}
{"context": "A researcher is studying the growth of bacteria over time. They have collected data on the number of bacteria at specific time intervals. Using this data, they want to estimate the number of bacteria at a different time point. Given the recorded time intervals and the corresponding number of bacteria, what is the estimated number of bacteria at a randomly selected time point between 0.1 and 1.3 seconds?\n\nThe input and output requirements are as follows:\n\nInput:\n  `t_values` (list of float): A list of time values in seconds at which the number of bacteria was recorded.\n  `f_values` (list of float): A list of corresponding number of bacteria values for each time in `t_values`.\n  `target_t` (float): The time value in seconds at which the number of bacteria needs to be estimated.\n\nOutput:\n  `return` (float): The estimated number of bacteria at the given `target_t` time value, rounded to 10 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef u_cal(u, n):\n    temp = u\n    for i in range(1, n):\n        temp = temp * (u - i)\n    return temp\n\ndef fact(n):\n    f = 1\n    for i in range(2, n + 1):\n        f *= i\n    return f\n\n# main function\ndef main_solution(t_values, f_values, target_t):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    n = len(t_values)\n    y = [[0 for i in range(n)] for j in range(n)]\n    \n    # Initialize the first column of the difference table\n    for i in range(n):\n        y[i][0] = f_values[i]\n    \n    # Calculating the forward difference table\n    for i in range(1, n):\n        for j in range(n - i):\n            y[j][i] = y[j + 1][i - 1] - y[j][i - 1]\n    \n    # Value to interpolate at\n    value = target_t\n    \n    # initializing u and sum\n    sum = y[0][0]\n    u = (value - t_values[0]) / (t_values[1] - t_values[0])\n    for i in range(1, n):\n        sum = sum + (u_cal(u, i) * y[0][i]) / fact(i)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return round(sum, 10)", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(3, 10)  # Reasonable size for interpolation\n    t_start = random.uniform(0, 10)\n    t_step = random.uniform(0.5, 2)\n    t_values = [round(t_start + i * t_step, 2) for i in range(n)]\n    \n    # Generate f_values with some randomness but ensuring it's not too trivial\n    base = random.uniform(1, 100)\n    f_values = [round(base + i * random.uniform(-5, 5), 2) for i in range(n)]\n    \n    # Generate target_t within a reasonable range of t_values\n    min_t = min(t_values)\n    max_t = max(t_values)\n    target_t = round(random.uniform(min_t, max_t), 2)\n    \n    return {\n        't_values': t_values,\n        'f_values': f_values,\n        'target_t': target_t\n    }", "io_pairs": [{"input": {"t_values": [4.92, 5.67, 6.42, 7.16, 7.91], "f_values": [33.21, 34.66, 24.0, 22.54, 38.63], "target_t": 5.78}, "output": 33.2010179748}, {"input": {"t_values": [7.88, 9.82, 11.76, 13.7, 15.64, 17.59], "f_values": [45.19, 47.39, 48.62, 34.55, 57.78, 69.56], "target_t": 15.24}, "output": 49.4403653868}, {"input": {"t_values": [8.65, 9.44, 10.23, 11.03, 11.82, 12.62, 13.41], "f_values": [50.74, 54.58, 52.34, 47.27, 69.79, 62.47, 34.74], "target_t": 11.2}, "output": 50.8543673529}, {"input": {"t_values": [9.03, 10.62, 12.22, 13.82, 15.42], "f_values": [71.56, 72.31, 62.06, 60.57, 80.92], "target_t": 14.75}, "output": 69.5428022583}, {"input": {"t_values": [7.02, 8.18, 9.34, 10.5, 11.66], "f_values": [54.6, 57.07, 59.39, 40.59, 48.68], "target_t": 8.16}, "output": 56.8685100244}, {"input": {"t_values": [7.34, 8.51, 9.68, 10.85, 12.02, 13.19, 14.35], "f_values": [25.92, 25.41, 31.13, 11.34, 40.8, 33.98, 24.11], "target_t": 8.11}, "output": 7.1175462684}, {"input": {"t_values": [6.37, 8.24, 10.11, 11.98], "f_values": [17.17, 19.04, 13.24, 18.0], "target_t": 10.89}, "output": 12.8948966977}, {"input": {"t_values": [9.31, 9.83, 10.35, 10.87, 11.38], "f_values": [83.82, 79.39, 86.56, 80.56, 81.57], "target_t": 11.27}, "output": 78.0295213753}, {"input": {"t_values": [5.19, 5.91, 6.64], "f_values": [5.2, 7.48, 8.07], "target_t": 6.6}, "output": 8.0791579861}, {"input": {"t_values": [2.93, 3.7, 4.48], "f_values": [37.86, 38.48, 39.37], "target_t": 4.38}, "output": 39.2520391297}], "error_log": []}
{"context": "Given a chessboard of size `N` x `N`, how many distinct ways can you place `N` queens on the board such that no two queens threaten each other? Each queen must be placed in a unique row and column, and no two queens can be on the same diagonal. What are the positions of the queens in each valid configuration?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (list of lists): A list of all possible solutions where each solution is represented as a list of integers. Each integer in the list represents the column position of the queen in the corresponding row. The length of the outer list is the number of solutions, and the length of each inner list is `N`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_available(candidate, current_col):\n    current_row = len(candidate)\n    for queen_row in range(current_row):\n        if candidate[queen_row] == current_col or abs(candidate[queen_row] - current_col) == current_row - queen_row:\n            return False\n    return True\n\ndef DFS(N, current_row, current_candidate, final_result):\n    if current_row == N:\n        final_result.append(current_candidate[:])\n        return\n    \n    for candidate_col in range(N):\n        if is_available(current_candidate, candidate_col):\n            current_candidate.append(candidate_col)\n            DFS(N, current_row + 1, current_candidate, final_result)\n            current_candidate.pop()\n\n# main function\ndef main_solution(N):\n    final_result = []\n    DFS(N, 0, [], final_result)\n    return final_result", "input_generator": "import random\n\ndef input_generator():\n    N = random.choice([4, 5, 6, 7, 8])\n    return {'N': N}", "io_pairs": [{"input": {"N": 6}, "output": [[1, 3, 5, 0, 2, 4], [2, 5, 1, 4, 0, 3], [3, 0, 4, 1, 5, 2], [4, 2, 0, 5, 3, 1]]}, {"input": {"N": 4}, "output": [[1, 3, 0, 2], [2, 0, 3, 1]]}], "error_log": []}
{"context": "Given a message consisting of uppercase alphabetic characters, how can we encrypt it using a solitaire cipher to produce a new message composed solely of uppercase alphabetic characters?\n\nThe input and output requirements are as follows:\n\nInput:\n  `message` (str): The message to be encrypted. It should be a string containing only uppercase alphabetic characters (A-Z). Any non-alphabetic characters will be removed.\n\nOutput:\n  `return` (str): The encrypted message. It is a string containing only uppercase alphabetic characters (A-Z).", "reference_code": "# import necessary packages\nimport string\nimport random\nimport re\nimport copy\n\n# all class and function definitions in the code file, if any\ndef create_deck():\n    value = {}\n    deck = []\n    jokera = create_card(1,0,deck)\n    jokerb = create_card(2,0,deck)\n    for v in range(1,14):\n        for c in range(1,3):\n            deck.append((v, c))\n            value = define_cards(deck)\n    shuffle_deck(deck)\n    return deck, value\n\ndef create_card(v,c,deck):\n    deck.append((v,c))\n\ndef shuffle_deck(deck):\n    random.shuffle(deck)\n    for x in range(int(len(deck) / 2)):\n        deck.append(deck.pop(0))\n\ndef move_card(old, new, deck):\n    if deck[old] == (1,0):\n        if old == 27:\n             deck.insert(1,(deck.pop(old)))\n        else:\n            deck.insert(new, (deck.pop(old)))\n    elif deck[old] == (2,0):\n        if old == 27:\n            deck.insert(2, (deck.pop(old)))\n        elif old == 26:\n            deck.insert(1, (deck.pop(old)))\n        else:\n            deck.insert(new, (deck.pop(old)))\n    else:\n        deck.insert(new, (deck.pop(old)))\n\ndef define_cards(deck):\n    deck.sort(key=lambda tup: tup[1])\n    value = {}\n    for x in range(len(deck)):\n        if deck[x][1] == 0:\n            value[deck[x]] = 27\n        else:\n            value[deck[x]] = x + -1\n    return value\n\ndef solitaire_keystream(length, deck, value):\n    temp_deck = copy.deepcopy(deck)\n    key = \"\"\n\n    while (len(key) != length):\n        move_card(temp_deck.index((1,0)), temp_deck.index((1,0)) + 1, temp_deck)\n        move_card(temp_deck.index((2,0)), temp_deck.index((2,0)) + 2, temp_deck)\n        \n        joker1 = min(temp_deck.index((1,0)),temp_deck.index((2,0)))\n        joker2 = max(temp_deck.index((1,0)),temp_deck.index((2,0)))\n\n        A = temp_deck[:joker1]\n        B = temp_deck[joker1:joker2 + 1]\n        C = temp_deck[joker2+1:]\n        temp_deck = C + B + A\n        \n        for i in range(value[temp_deck[len(temp_deck) - 1]]):\n            temp_deck.insert(len(temp_deck) - 2, temp_deck.pop(0))\n            \n        if value[temp_deck[0]] == 27:\n            pass\n        else:\n            key += string.ascii_uppercase[value[temp_deck[0]] - 1]\n\n    return key\n\n# main function\ndef main_solution(message):\n    # Convert message to uppercase and remove non-alphabetic characters\n    message = re.sub('[^A-Z]', '', message.upper())\n    \n    # Create deck and value dictionary\n    deck, value = create_deck()\n    \n    # Generate keystream\n    keystream = solitaire_keystream(len(message), deck, value)\n    \n    # Encrypt the message\n    encrypted_message = \"\"\n    for i in range(len(message)):\n        msg_char_value = string.ascii_uppercase.index(message[i]) + 1\n        key_char_value = string.ascii_uppercase.index(keystream[i]) + 1\n        encrypted_char_value = (msg_char_value + key_char_value - 1) % 26 + 1\n        encrypted_message += string.ascii_uppercase[encrypted_char_value - 1]\n    \n    return encrypted_message", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random message length between 5 and 20 characters\n    length = random.randint(5, 20)\n    # Generate a random message consisting of uppercase letters and possibly some non-alphabetic characters\n    message = ''.join(random.choices(string.ascii_uppercase + string.digits + string.punctuation + ' ', k=length))\n    return {'message': message}", "io_pairs": [{"input": {"message": "TIY[}I>}}&8Y\"<"}, "output": "YODEZ"}, {"input": {"message": ")@0H~7+>.60H%,*<}]S"}, "output": "QXL"}, {"input": {"message": "$_D`0E):CU`?ZC~~~"}, "output": "HPKBLF"}, {"input": {"message": "~{L: ,F1}SDC} "}, "output": "OULKJ"}, {"input": {"message": "0]A%^LR[Q>-"}, "output": "CGPZ"}, {"input": {"message": "H}^*:6$H;/@8<0E"}, "output": "DWM"}, {"input": {"message": "P0[B_KD=A[K"}, "output": "RTSCDV"}, {"input": {"message": "|GD,@+AS]/GMSS"}, "output": "QACMCISJ"}, {"input": {"message": "4D0%2]^*<K){X\\/B}-0F"}, "output": "KVAHQ"}, {"input": {"message": "7HUFH"}, "output": "TRQA"}], "error_log": []}
{"context": "Given a sum `n`, find the product of the Pythagorean triplet (a, b, c) such that a + b + c = n and a\u00b2 + b\u00b2 = c\u00b2. What is the product of the triplet if it exists?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer representing the sum of the Pythagorean triplet (a + b + c).\n\nOutput:\n  `return` (int): The product of the Pythagorean triplet (a * b * c) if such a triplet exists, otherwise `None`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef isTriplet(a, b, c):\n    if pow(c, 2) == pow(a, 2) + pow(b, 2):\n        return True\n    return False\n\ndef specialPythagoreanTriplet(n):\n    for a in range(1, n):\n        for b in range(a, n):\n            c = n - b - a\n            if (isTriplet(a, b, c)):\n                return a*b*c\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = specialPythagoreanTriplet(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random even number between 12 and 1000 to ensure it's possible to form a triplet\n    n = random.randint(12, 1000) * 2\n    return {'n': n}", "io_pairs": [{"input": {"n": 1788}, "output": 198476940}, {"input": {"n": 200}, "output": 255000}, {"input": {"n": 1040}, "output": 34710000}, {"input": {"n": 1566}, "output": 57393900}, {"input": {"n": 770}, "output": 15015000}, {"input": {"n": 1932}, "output": 130680480}, {"input": {"n": 1978}, "output": 110253720}, {"input": {"n": 72}, "output": 12960}, {"input": {"n": 1968}, "output": 202576080}, {"input": {"n": 1956}, "output": 259844820}], "error_log": []}
{"context": "Given two integers `a` and `modulo`, what is the modular inverse of `a` under `modulo`? The modular inverse exists only if `a` and `modulo` are coprime. If they are not coprime, indicate the reason why the inverse cannot be found.\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): The integer for which the modular inverse is to be found.\n  `modulo` (int): The modulus under which the inverse is to be found.\n\nOutput:\n  `return` (int or str): The modular inverse of `a` under `modulo` if `a` and `modulo` are coprime. If they are not coprime, it returns a string indicating the error.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef pgcd(a, modulo):\n    c, d = max(a, modulo), min(a, modulo)  # d\u00e9termination du Dividende et du diviseur\n    while d > 0:\n        c, d = d, c % d\n    return c\n\ndef inverse_mod(a, modulo):\n    npgcd = pgcd(a, modulo)\n    if npgcd != 1:\n        raise ValueError(\"D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux.\")\n    k = int(modulo / a) + 1\n    mo = 1\n    while mo != 0:\n        k += 1\n        mo = (1 + modulo * k) % a\n    res = ((1 + modulo * k) // a) % modulo\n    return res\n\n# main function\ndef main_solution(a, modulo):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    try:\n        result = inverse_mod(a, modulo)\n    except ValueError as e:\n        result = str(e)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random modulo between 2 and 1000\n    modulo = random.randint(2, 1000)\n    \n    # Generate a list of potential 'a' values that are coprime with modulo\n    coprime_candidates = [i for i in range(1, modulo) if math.gcd(i, modulo) == 1]\n    \n    # Decide whether to generate a valid 'a' or an invalid one (not coprime)\n    if random.choice([True, False]) and coprime_candidates:\n        a = random.choice(coprime_candidates)\n    else:\n        # Generate an 'a' that is not coprime with modulo\n        factors = []\n        temp = modulo\n        i = 2\n        while i * i <= temp:\n            if temp % i == 0:\n                factors.append(i)\n                while temp % i == 0:\n                    temp //= i\n            i += 1\n        if temp > 1:\n            factors.append(temp)\n        if factors:\n            a = random.choice(factors) * random.randint(1, modulo // max(factors))\n        else:\n            a = random.randint(1, modulo - 1)\n    \n    return {'a': a, 'modulo': modulo}", "io_pairs": [{"input": {"a": 117, "modulo": 403}, "output": "D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux."}, {"input": {"a": 24, "modulo": 196}, "output": "D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux."}, {"input": {"a": 929, "modulo": 929}, "output": "D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux."}, {"input": {"a": 48, "modulo": 234}, "output": "D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux."}, {"input": {"a": 333, "modulo": 371}, "output": 205}, {"input": {"a": 331, "modulo": 331}, "output": "D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux."}, {"input": {"a": 53, "modulo": 109}, "output": 72}, {"input": {"a": 167, "modulo": 167}, "output": "D\u00e9sol\u00e9, votre nombre et le modulo ne sont pas premiers entre eux."}, {"input": {"a": 695, "modulo": 874}, "output": 83}, {"input": {"a": 496, "modulo": 905}, "output": 801}], "error_log": []}
{"context": "Given a maze represented by a grid of characters, where `X` represents walls, `_` represents empty spaces, `S` represents the starting point, and `G` represents the goal point, what is the path from the starting point `S` to the goal point `G`? The path should be represented as a series of coordinates, where each coordinate is a position in the maze grid.\n\nThe input and output requirements are as follows:\n\nInput:\n  `maze_str` (str): A string representing the maze. Each line of the maze is separated by a newline character (`\\n`). The maze consists of the following symbols:\n  - `X`: Walls\n  - `_`: Empty spaces\n  - `S`: Starting point\n  - `G`: Goal point\n\nOutput:\n  `return` (str): A string representing the path from the starting point `S` to the goal point `G`. Each coordinate in the path is separated by a semicolon (`;`). Each coordinate is represented as `row,column`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef printmaze(maze):\n    xmax, ymax = len(maze), len(maze[0])\n    print ('\\nMaze Graph') \n    print ('='*(2*ymax-1)) # upper boarder\n    \n    for lists in maze:\n        for i in lists:\n            print(i,end=' ')\n        print()\n        \n    print ('='*(2*ymax-1)) # lower boarder\n\ndef search(maze, x, y, xmax, ymax, path):\n    if maze[x][y] == 'G':\n        path.append([x,y]) # Adding final value to solution path list.\n        return True\n    elif maze[x][y] == 'X':\n        return False\n    elif maze[x][y] == '+':\n        return False\n\n    # else: spot is available to move into\n    maze[x][y] = '+'    # marking as visited.\n    path.append([x,y])  # adding position's coordinates to our solution path list.\n\n    # explore neighbors clockwise (starting north), only after checking said neighbor is within bounds.\n    if ((x > 0 and search(maze, x-1, y, xmax, ymax, path))         # check north \n        or (y < ymax-1 and search(maze, x, y+1, xmax, ymax, path)) # check east\n        or (x < xmax-1 and search(maze, x+1, y, xmax, ymax, path)) # check south\n        or (y > 0 and search(maze, x, y-1, xmax, ymax, path))):    # check west\n        return True\n    \n    maze[x][y] = ' '    # not part of solution path => unmarking.\n    path.pop()          # removing unmarked spot's coordinates from solution path list.\n    return False\n\n# main function\ndef main_solution(maze_str):\n    # Convert the input string to a list of lists\n    maze = [list(line) for line in maze_str.split('\\n') if line.strip()]\n    \n    # Find starting position (S) index\n    x1, y1 = None, None\n    for i, row in enumerate(maze):\n        if 'S' in row:\n            x1 = i\n            y1 = row.index('S')\n            break\n    \n    if x1 is None or y1 is None:\n        raise ValueError(\"Starting point 'S' not found in the maze.\")\n    \n    xmax, ymax = len(maze), len(maze[0])\n    path = []\n    \n    # Perform the search\n    search(maze, x1, y1, xmax, ymax, path)\n    \n    # Reset starting position back to 'S'\n    maze[x1][y1] = 'S'\n    \n    # Convert the path to a JSON serializable format\n    path_str = ';'.join([f\"{coord[0]},{coord[1]}\" for coord in path])\n    \n    return path_str", "input_generator": "import random\n\ndef input_generator():\n    # Define possible maze components\n    wall = 'X'\n    path = ' '\n    start = 'S'\n    goal = 'G'\n    \n    # Randomly choose maze dimensions (between 5x5 and 10x10)\n    rows = random.randint(5, 10)\n    cols = random.randint(5, 10)\n    \n    # Initialize maze with walls\n    maze = [[wall for _ in range(cols)] for _ in range(rows)]\n    \n    # Randomly place start and goal\n    start_pos = (random.randint(0, rows-1), (random.randint(0, cols-1))\n    goal_pos = (random.randint(0, rows-1), (random.randint(0, cols-1)))\n    while goal_pos == start_pos:\n        goal_pos = (random.randint(0, rows-1), (random.randint(0, cols-1)))\n    \n    maze[start_pos[0]][start_pos[1]] = start\n    maze[goal_pos[0]][goal_pos[1]] = goal\n    \n    # Create a path from start to goal\n    current_pos = start_pos\n    while current_pos != goal_pos:\n        x, y = current_pos\n        # Decide next move (randomly choose direction)\n        if random.random() < 0.5:\n            # Move horizontally\n            new_y = y + 1 if goal_pos[1] > y else y - 1\n            if 0 <= new_y < cols:\n                if (x, new_y) == goal_pos:\n                    current_pos = (x, new_y)\n                else:\n                    maze[x][new_y] = path\n                    current_pos = (x, new_y)\n        else:\n            # Move vertically\n            new_x = x + 1 if goal_pos[0] > x else x - 1\n            if 0 <= new_x < rows:\n                if (new_x, y) == goal_pos:\n                    current_pos = (new_x, y)\n                else:\n                    maze[new_x][y] = path\n                    current_pos = (new_x, y)\n    \n    # Convert maze to string representation\n    maze_str = '\\n'.join(''.join(row) for row in maze)\n    \n    return {'maze_str': maze_str}", "io_pairs": [], "error_log": ["STDERR:   File \"<string>\", line 59\n    start_pos = (random.randint(0, rows-1), (random.randint(0, cols-1))\n                ^\nSyntaxError: '(' was never closed\n"]}
{"context": "Given a large integer `n`, what is the difference between the results of two mathematical functions, `R_v3` and `B`, when applied to `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer representing the target value for the computation.\n\nOutput:\n  `return` (float): A floating-point number representing the difference between the results of the functions `R_v3` and `B` for the given input `n`.", "reference_code": "# import necessary packages\nfrom math import log\n\n# all class and function definitions in the code file, if any\ndef B(n):\n    def recur_B(n):\n        if n in result: return result[n]\n\n        temp_result = 1\n        index1 = (n + 1) // 2 - 1\n        index2 = n - (n + 1) // 2\n        temp_result += (index1 * recur_B(index1) + index2 * recur_B(index2)) / n\n\n        result[n] = temp_result\n        return temp_result\n\n    result = {0: 0, 1: 1}\n    return recur_B(n)\n\ndef R_v3(n):\n    running_sum = log(n) - 1.5 + 0.5772156649 + 1 / 2 / n\n    return 3 / n + 2 * (n + 1) * running_sum / n\n\n# main function\ndef main_solution(n):\n    # Convert JSON serializable input to original input variables\n    n = int(n)\n    \n    # Compute the results using the provided functions\n    r = R_v3(n)\n    b = B(n)\n    \n    # Convert the results to JSON serializable outputs\n    result = r - b\n    \n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 1000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 676}, "output": 2.70780608657798}, {"input": {"n": 603}, "output": 2.663008549287616}, {"input": {"n": 734}, "output": 2.7524750161637}, {"input": {"n": 36}, "output": 1.164503845170275}, {"input": {"n": 203}, "output": 2.0605761420523327}, {"input": {"n": 222}, "output": 2.1307964115537894}, {"input": {"n": 155}, "output": 1.9138475841323093}, {"input": {"n": 433}, "output": 2.48828141918749}, {"input": {"n": 397}, "output": 2.4223664170757955}, {"input": {"n": 394}, "output": 2.417056171795517}], "error_log": []}
{"context": "Given a square matrix represented by a list of lists of floats, what is the estimated supremum of its eigenvalues?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_data` (list of lists of floats): A 2D list representing a square matrix. Each sublist represents a row in the matrix, and each element in the sublist is a float.\n\nOutput:\n  `supremum_eigenvalue` (float): The estimated supremum of the eigenvalues of the given matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef ncr(n, r):\n    \"\"\"\n    Calculates nCr in efficient manner. \n    This function is not my original code, but copied from below url.\n    https://stackoverflow.com/questions/4941753/is-there-a-math-ncr-function-in-python\n\n    Parameters\n    ----------\n    n, r: int \n    \"\"\"\n    r = min(r, n-r)\n    numer = reduce(op.mul, range(n, n-r, -1), 1)\n    denom = reduce(op.mul, range(1, r+1), 1)\n    return numer / denom\n\ndef flatten(l):\n    \"\"\" \n    flatten a nested list.\n    https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-list-of-lists\n    \n    Parameters\n    ----------\n    l: array-like\n    \"\"\"\n    return [item for sublist in l for item in sublist]\n\ndef split_array(a, n):\n    \"\"\"\n    Split an array into n chunks. \n    https://stackoverflow.com/questions/2130016/splitting-a-list-into-n-parts-of-approximately-equal-length\n\n    Parameters\n    ----------\n    a: array-like\n    n: int \n        number of chunks\n    \"\"\"\n    k, m = divmod(len(a), n)\n    return (a[i * k + min(i, m):(i + 1) * k + min(i + 1, m)] for i in range(n))\n\ndef supremum_eigen(X):\n    \"\"\"\n    Estimates approximate supremum of eigen values of a square matrix\n    by Gershgorin circle theorem.\n    Ref(in JP): https://qiita.com/fujiisoup/items/e7f703fc57e2dfc441ad\n\n    Parameters\n    ----------\n    X: np.ndarray (d,d)\n    \"\"\"\n    return np.max(np.sum(np.abs(X), axis=0))\n\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\ndef softmax(x):\n    if x.ndim == 1:\n        x = np.array([x])\n\n    # Avoid overflow\n    x = x - np.array([x.max(axis=1)]).T\n\n    exp_x = np.exp(x)\n    sum_exp_x = np.sum(exp_x,axis=1)[np.newaxis].T\n    return exp_x / sum_exp_x\n\n# main function\ndef main_solution(matrix_data):\n    \"\"\"\n    This function calculates the supremum of the eigenvalues of a given square matrix.\n\n    Parameters\n    ----------\n    matrix_data: list of lists of floats\n        A 2D list representing a square matrix.\n\n    Returns\n    -------\n    supremum_eigenvalue: float\n        The estimated supremum of the eigenvalues of the given matrix.\n    \"\"\"\n    # Convert the input list of lists to a numpy array\n    X = np.array(matrix_data)\n    \n    # Calculate the supremum of the eigenvalues\n    supremum_eigenvalue = supremum_eigen(X)\n    \n    # Return the result as a float\n    return supremum_eigenvalue", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.randint(2, 10)  # Random matrix size between 2x2 and 10x10\n    matrix = np.random.uniform(-10, 10, (size, size)).tolist()  # Random values between -10 and 10\n    return {'matrix_data': matrix}", "io_pairs": [{"input": {"matrix_data": [[0.8536665864621629, -3.0281613566723546], [3.6972345405871074, 4.165858320255978]]}, "output": 7.194019676928333}, {"input": {"matrix_data": [[1.2266960413060328, 1.527313329711875], [1.9375536535894629, -5.32302409729438]]}, "output": 6.850337427006255}, {"input": {"matrix_data": [[-3.8167143681303877, -0.8090491139481806], [-9.175744573662685, 0.8657750221649678]]}, "output": 12.992458941793073}, {"input": {"matrix_data": [[-6.594097440349365, -2.1035257022045766], [-9.870236837487836, 0.6904168549962169]]}, "output": 16.4643342778372}, {"input": {"matrix_data": [[9.86159260218481, -6.599535198040261, 0.9091942067658483], [5.962077266497781, -7.4276122953968855, 7.748542464307864], [0.211681144118117, 6.3096003723877345, 0.8058007017479731]]}, "output": 20.336747865824883}, {"input": {"matrix_data": [[-7.553732379376232, -4.261669637804076], [-8.633148356447029, 9.270175789860755]]}, "output": 16.18688073582326}, {"input": {"matrix_data": [[-5.120773060816928, -2.628317768173929, 9.456501698782617], [4.343509427796654, -5.702363747560392, -1.8895939221897944], [-4.599703002322844, 6.05495490894295, -0.2706327077193844]]}, "output": 14.385636424677271}, {"input": {"matrix_data": [[6.330454726045808, 8.402606850051217], [-1.1369908332106622, -0.12484277087702367]]}, "output": 8.527449620928241}, {"input": {"matrix_data": [[5.688710345825662, -4.7170465597602345], [-0.023331974895324237, -9.575766136700835]]}, "output": 14.29281269646107}, {"input": {"matrix_data": [[2.3844685390533016, -6.253828192099422], [4.378244689667039, -4.350507486854309]]}, "output": 10.604335678953731}], "error_log": []}
{"context": "A manager of an industrial plant is considering purchasing either machine A or machine B. The number of repairs needed for each machine per day follows a Poisson distribution. Machine A has a mean number of repairs `lambda_a`, and machine B has a mean number of repairs `lambda_b`. The daily operating cost for machine A is calculated as 160 + 40 * (lambda_a + lambda_a\u00b2), and for machine B, it is 128 + 40 * (lambda_b + lambda_b\u00b2). What are the daily operating costs for both machines, rounded to three decimal places?\n\nThe input and output requirements are as follows:\n\nInput:\n  `lambda_a` (float): The mean number of repairs for machine A.\n  `lambda_b` (float): The mean number of repairs for machine B.\n\nOutput:\n  `return` (dict): A dictionary containing the daily costs for both machines.\n    - `cost_a` (float): The daily cost of operating machine A, rounded to 3 decimal places.\n    - `cost_b` (float): The daily cost of operating machine B, rounded to 3 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(lambda_a, lambda_b):\n    # Calculate the daily cost for machine A\n    cost_a = 160 + 40 * (lambda_a + lambda_a ** 2)\n    \n    # Calculate the daily cost for machine B\n    cost_b = 128 + 40 * (lambda_b + lambda_b ** 2)\n    \n    # Return the costs rounded to 3 decimal places\n    return {\"cost_a\": round(cost_a, 3), \"cost_b\": round(cost_b, 3)}", "input_generator": "import random\n\ndef input_generator():\n    lambda_a = round(random.uniform(0.1, 5.0), 2)\n    lambda_b = round(random.uniform(0.1, 5.0), 2)\n    return {\"lambda_a\": lambda_a, \"lambda_b\": lambda_b}", "io_pairs": [{"input": {"lambda_a": 2.09, "lambda_b": 0.55}, "output": {"cost_a": 418.324, "cost_b": 162.1}}, {"input": {"lambda_a": 4.41, "lambda_b": 3.44}, "output": {"cost_a": 1114.324, "cost_b": 738.944}}, {"input": {"lambda_a": 4.61, "lambda_b": 3.14}, "output": {"cost_a": 1194.484, "cost_b": 647.984}}, {"input": {"lambda_a": 3.31, "lambda_b": 4.67}, "output": {"cost_a": 730.644, "cost_b": 1187.156}}, {"input": {"lambda_a": 2.75, "lambda_b": 2.82}, "output": {"cost_a": 572.5, "cost_b": 558.896}}, {"input": {"lambda_a": 1.56, "lambda_b": 2.56}, "output": {"cost_a": 319.744, "cost_b": 492.544}}, {"input": {"lambda_a": 1.68, "lambda_b": 4.81}, "output": {"cost_a": 340.096, "cost_b": 1245.844}}, {"input": {"lambda_a": 3.01, "lambda_b": 4.93}, "output": {"cost_a": 642.804, "cost_b": 1297.396}}, {"input": {"lambda_a": 3.7, "lambda_b": 3.94}, "output": {"cost_a": 855.6, "cost_b": 906.544}}, {"input": {"lambda_a": 3.25, "lambda_b": 4.39}, "output": {"cost_a": 712.5, "cost_b": 1074.484}}], "error_log": []}
{"context": "Given two lines defined by their endpoints, what are the coordinates of the intersection point of these two lines? The lines are defined by their endpoints, where each endpoint is a pair of x and y coordinates.\n\nThe input and output requirements are as follows:\n\nInput:\n  `line1` (list of lists): A list containing two lists, each representing a point on the first line. Each point is represented by a list of two floats, [x, y].\n  `line2` (list of lists): A list containing two lists, each representing a point on the second line. Each point is represented by a list of two floats, [x, y].\n\nOutput:\n  `return` (dict): A dictionary containing the coordinates of the intersection point. The keys are \"x\" and \"y\", and the values are floats representing the x and y coordinates of the intersection point.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef line_from_points(p1, p2):\n    if p1 == p2:\n        raise ValueError(\"Points are Not Distinct...\")\n    else:\n        x1, y1 = p1[0], p1[1]\n        x2, y2 = p2[0], p2[1]\n    # line for two points\n    # ((y - y1) / (x - x1)) = ((y2-y1)/(x2-x1))\n    # check if line is vertical x2 == x1\n    if x2 == x1:\n        # ax + by + c = 0\n        # ax + by = -c\n        # line is vertical -> x = -c\n        a, b, c = 1, 0, -x1\n    else:\n        m = ((y2-y1)/(x2-x1))\n        a, b, c = (-m), 1, (m*x1-y1)\n    return a, b, c\n\ndef line_intersection(line1, line2):\n    a1, b1, c1 = line_from_points(line1[0], line1[1])\n    a2, b2, c2 = line_from_points(line2[0], line2[1])\n    a = np.array([[a1, b1], [a2, b2]])\n    b = np.array([-c1, -c2])\n    x, y = np.linalg.solve(a, b)\n    return x, y \n\n# main function\ndef main_solution(line1, line2):\n    # Convert input to appropriate format if necessary\n    line1 = tuple(map(tuple, line1))\n    line2 = tuple(map(tuple, line2))\n    \n    # Calculate the intersection point\n    intersection = line_intersection(line1, line2)\n    \n    # Convert output to JSON serializable format\n    return {\"x\": float(intersection[0]), \"y\": float(intersection[1])}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate two distinct points for line1\n    while True:\n        p1 = (random.uniform(-10, 10), random.uniform(-10, 10))\n        p2 = (random.uniform(-10, 10), random.uniform(-10, 10))\n        if p1 != p2:\n            line1 = (p1, p2)\n            break\n    \n    # Generate two distinct points for line2, ensuring they are not the same as line1's points\n    while True:\n        p3 = (random.uniform(-10, 10), random.uniform(-10, 10))\n        p4 = (random.uniform(-10, 10), random.uniform(-10, 10))\n        if p3 != p4 and (p3, p4) != (p1, p2) and (p3, p4) != (p2, p1):\n            line2 = (p3, p4)\n            break\n    \n    return {\"line1\": line1, \"line2\": line2}", "io_pairs": [{"input": {"line1": [[3.211662044252, -4.31044910357193], [-6.738874161286983, 1.5186617636973914]], "line2": [[6.81612402943356, 1.621028332247299], [-3.205823273432813, -7.017178298284918]]}, "output": {"x": 1.260557711897646, "y": -3.167475174129605}}, {"input": {"line1": [[-4.198152143646563, -8.7937698381894], [4.18915421505876, 2.0055645322354536]], "line2": [[6.604775292150677, 5.770384661377486], [-9.650082348943723, 4.092604966532923]]}, "output": {"x": 7.157403608135636, "y": 5.827425368089777}}, {"input": {"line1": [[-4.437591317149792, -5.534666812673457], [-2.5893808518112493, -3.1220805488907866]], "line2": [[3.517218297221895, 2.9309851321181064], [-3.251997378482912, -5.4682784813340195]]}, "output": {"x": -26.19554594683254, "y": -33.93670405466248}}, {"input": {"line1": [[5.961421447820028, 2.741868496311046], [-2.0944282091571527, 5.4615812350819954]], "line2": [[8.919506034100365, -5.4690784824367045], [-4.020770649750947, -0.4644425694476322]]}, "output": {"x": -137.8457768559527, "y": 51.29221213572918}}, {"input": {"line1": [[2.3655384676544067, -3.3844070551260153], [-1.5922167994657226, -6.274845149549815]], "line2": [[-1.3555549640244635, -5.735035995135307], [8.885064320062405, 0.5878719649132851]]}, "output": {"x": 1.895173117249094, "y": -3.7279254981190313}}, {"input": {"line1": [[-3.2665725161306858, -7.556503415344478], [8.397454713735947, 5.588428581174515]], "line2": [[-3.9342167863362327, -0.3812908929279608], [-7.341000356947227, -1.6071402677417694]]}, "output": {"x": 6.3998162240708725, "y": 3.3371630806072163}}, {"input": {"line1": [[4.976817033513711, -5.934824502093909], [-0.5235061221314901, -7.784175124703667]], "line2": [[-5.104242397530355, 3.3071697930564348], [4.200752492773891, 8.175724266102822]]}, "output": {"x": -72.65469854007517, "y": -32.03654390976294}}, {"input": {"line1": [[4.885589298733372, -5.947036103655541], [-5.5643640090846835, 2.8006778434309574]], "line2": [[-5.514076943658752, 3.659218566217886], [-7.561324488685404, -7.2716183896166475]]}, "output": {"x": -5.6598961529244916, "y": 2.8806483315705878}}, {"input": {"line1": [[-6.299690338118791, 6.4009939352668574], [6.140530588958974, 0.93753655139537]], "line2": [[-8.206683576972555, 9.64320706726452], [7.635295119768504, -2.7038810067887287]]}, "output": {"x": -1.1384609380629496, "y": 4.134301322580797}}, {"input": {"line1": [[-8.7973340171601, 6.959506668545863], [0.748027522195418, 9.82239429724451]], "line2": [[-2.388773858984832, 2.345311399996721], [7.973213676100066, -4.9202525688299215]]}, "output": {"x": -8.91787624677065, "y": 6.9233531026002515}}], "error_log": []}
{"context": "Given a set of `n` disks stacked on rod `a`, how many steps are required to move all the disks to rod `b` using rod `c` as an auxiliary rod, following the rules of the Tower of Hanoi puzzle?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of disks to be moved.\n  `a` (str): The source rod from which disks are to be moved.\n  `b` (str): The destination rod to which disks are to be moved.\n  `c` (str): The auxiliary rod used for moving disks.\n\nOutput:\n  `return` (int): The total number of steps required to move `n` disks from rod `a` to rod `b` using rod `c`.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ncount = 0\n\ndef mov(n, a, b, c):\n    global count\n    if n <= 0:\n        return\n    if n == 1:\n        count += 1 \n    else:\n        mov(n-1, a, c, b)\n        mov(1, a, b, c)\n        mov(n-1, c, b, a)\n\n# main function\ndef main_solution(n, a, b, c):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    global count\n    count = 0\n    mov(n, a, b, c)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)\n    a = random.choice(['A', 'B', 'C'])\n    b = random.choice(['A', 'B', 'C'])\n    while b == a:\n        b = random.choice(['A', 'B', 'C'])\n    c = random.choice(['A', 'B', 'C'])\n    while c == a or c == b:\n        c = random.choice(['A', 'B', 'C'])\n    return {'n': n, 'a': a, 'b': b, 'c': c}", "io_pairs": [{"input": {"n": 1, "a": "B", "b": "A", "c": "C"}, "output": 1}, {"input": {"n": 8, "a": "B", "b": "C", "c": "A"}, "output": 255}, {"input": {"n": 4, "a": "B", "b": "C", "c": "A"}, "output": 15}, {"input": {"n": 4, "a": "A", "b": "B", "c": "C"}, "output": 15}, {"input": {"n": 9, "a": "A", "b": "C", "c": "B"}, "output": 511}, {"input": {"n": 5, "a": "A", "b": "C", "c": "B"}, "output": 31}, {"input": {"n": 2, "a": "A", "b": "B", "c": "C"}, "output": 3}, {"input": {"n": 3, "a": "A", "b": "C", "c": "B"}, "output": 7}, {"input": {"n": 6, "a": "B", "b": "C", "c": "A"}, "output": 63}, {"input": {"n": 7, "a": "A", "b": "C", "c": "B"}, "output": 127}], "error_log": []}
{"context": "Given a cost function defined by constants `a` and `b`, and initial values for parameters `z`, how would the parameters `z` and the cost function value evolve after running a gradient descent algorithm for a specified number of iterations with a given precision level?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The constant value used in the cost function.\n  `b` (float): The constant value used in the cost function.\n  `initial_z` (list of floats): The initial values for the parameters z, should be a list of two floats.\n  `num_iterations` (int): The number of iterations to run the gradient descent algorithm.\n  `precision` (float): The precision level for convergence check.\n  `NT` (float): The constant value used in the learning rate calculation.\n  `E` (float): The small constant value added to the gradient sums for numerical stability.\n\nOutput:\n  `return` (dict): A dictionary containing the final values of the parameters `z` and the final cost function value.\n    - `final_z` (list of floats): The final values of the parameters z after the gradient descent algorithm.\n    - `final_cost` (float): The final cost function value after the gradient descent algorithm.", "reference_code": "# import necessary packages\nimport numpy as np\nimport math\n\n# all class and function definitions in the code file, if any\ndef cost_function(z, a, b):\n    A = (((a - z[0]) ** 2) + (b * (z[1] - (z[0] ** 2) ** 2)))\n    return A\n\ndef gradient_1(z, a, b):\n    d_f_1 = (2 * z[0] - 2 * a + (4 * b * ((z[0] ** 3) - z[1] * z[0])))\n    return d_f_1\n\ndef gradient_2(z, a, b):\n    d_f_2 = (2 * b * (z[1] - (z[0] ** 2)))\n    return d_f_2\n\ndef descent(d_F, z, alpha):\n    z = z - alpha * d_F\n    return z\n\n# main function\ndef main_solution(a, b, initial_z, num_iterations, precision, NT, E):\n    # Convert JSON serializable inputs to appropriate types\n    z = np.array(initial_z).reshape(2, 1)\n    F = np.zeros((num_iterations, 1))\n    gradient_list_1 = []\n    gradient_list_2 = []\n    P_1 = []\n    P_2 = []\n    alpha = np.zeros((2, 1))\n\n    for i in range(num_iterations):\n        P_1.append(z.item(0))\n        P_2.append(z.item(1))\n        F[i] = cost_function(z, a, b)\n        if i > 0 and abs(float(F[i] - F[i - 1])) <= float(precision):\n            break\n        d_f = np.zeros((2, 1))\n        d_f[0] = gradient_1(z, a, b)\n        d_f[1] = gradient_2(z, a, b)\n        gradient_list_1.append((d_f.item(0) ** 2))\n        gradient_list_2.append((d_f.item(1) ** 2))\n        G1 = sum(gradient_list_1)\n        G2 = sum(gradient_list_2)\n        alpha[0] = NT / (math.sqrt(E + G1))\n        alpha[1] = NT / (math.sqrt(E + G2))\n        z = descent(d_f, z, alpha)\n\n    # Convert output to JSON serializable format\n    final_z = z.flatten().tolist()\n    final_cost = F[i].item()\n    return {\"final_z\": final_z, \"final_cost\": final_cost}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    a = random.uniform(0.1, 10.0)\n    b = random.uniform(0.1, 10.0)\n    initial_z = [random.uniform(-5.0, 5.0), random.uniform(-5.0, 5.0)]\n    num_iterations = random.randint(100, 1000)\n    precision = random.uniform(1e-6, 1e-4)\n    NT = random.uniform(0.01, 0.1)\n    E = random.uniform(1e-8, 1e-6)\n    return {\n        \"a\": a,\n        \"b\": b,\n        \"initial_z\": initial_z,\n        \"num_iterations\": num_iterations,\n        \"precision\": precision,\n        \"NT\": NT,\n        \"E\": E\n    }", "io_pairs": [{"input": {"a": 5.275109147379733, "b": 7.330016798013033, "initial_z": [3.252690669429443, -2.812988605460589], "num_iterations": 868, "precision": 4.8282675283198164e-05, "NT": 0.057780261871801165, "E": 4.1957697143321264e-07}, "output": {"final_z": [1.3627558355561826, -0.46877370651846856], "final_cost": -13.457620489080364}}, {"input": {"a": 6.50111250684871, "b": 0.29608125223118315, "initial_z": [1.7947551982440721, -1.1087404533045833], "num_iterations": 760, "precision": 9.316314069264657e-05, "NT": 0.05298561113768062, "E": 4.1376853219471683e-07}, "output": {"final_z": [2.2080900680968774, 1.593633483017135], "final_cost": 11.868476016138906}}, {"input": {"a": 6.723488382420063, "b": 4.562079058533208, "initial_z": [0.11388201725170433, 1.821132390444527], "num_iterations": 115, "precision": 4.705810271608107e-05, "NT": 0.046777641620642976, "E": 4.136857405656181e-07}, "output": {"final_z": [1.0300768019593596, 1.1769741772794953], "final_cost": 32.74293054941215}}, {"input": {"a": 0.7434936674733466, "b": 6.303058048282204, "initial_z": [-1.2069754640511632, -0.8187080222927179], "num_iterations": 510, "precision": 8.096899199900474e-05, "NT": 0.03957962716747596, "E": 5.893601781022704e-07}, "output": {"final_z": [-0.38481134745345424, 0.08791554999375085], "final_cost": 1.6881540107863713}}, {"input": {"a": 7.078179609665753, "b": 7.899547419259613, "initial_z": [-2.4553673978407287, 4.346893229111558], "num_iterations": 216, "precision": 6.824731202354013e-05, "NT": 0.021684368267490907, "E": 5.57235015292299e-07}, "output": {"final_z": [-2.111240016301279, 4.587551236913297], "final_cost": -36.345997279154574}}, {"input": {"a": 9.26433582099348, "b": 4.727092045690109, "initial_z": [2.3853001979293875, -2.425741159239394], "num_iterations": 755, "precision": 2.1667255382589724e-05, "NT": 0.059285265738315406, "E": 6.002915307038766e-07}, "output": {"final_z": [0.955438490931561, -0.28677199035694784], "final_cost": 63.733462659772485}}, {"input": {"a": 0.7506280429070699, "b": 3.6179638258802393, "initial_z": [-3.5793100267590727, -4.352674035243864], "num_iterations": 437, "precision": 5.242133295460343e-05, "NT": 0.03761025127861768, "E": 4.296714685705799e-07}, "output": {"final_z": [-2.353155756946386, -3.020205617066139], "final_cost": -112.44194274857274}}, {"input": {"a": 6.2572831264508455, "b": 2.7737210867363715, "initial_z": [2.4422962296422863, -3.641438486699804], "num_iterations": 190, "precision": 4.9601153306877916e-05, "NT": 0.09990866648695597, "E": 3.1007069473765643e-07}, "output": {"final_z": [0.9674494863558155, -1.6480163990094792], "final_cost": 20.933512273125302}}, {"input": {"a": 8.543147308561723, "b": 4.653757759162262, "initial_z": [2.438573584233165, 4.572139800849973], "num_iterations": 233, "precision": 6.624910167789921e-05, "NT": 0.08134741730900877, "E": 5.768589034087467e-07}, "output": {"final_z": [2.5498150651598035, 6.263258199057031], "final_cost": -131.3880128189253}}, {"input": {"a": 5.752300731735439, "b": 2.7826193556592274, "initial_z": [-2.7675641131710194, 1.930110280083249], "num_iterations": 813, "precision": 7.440258560281995e-05, "NT": 0.09083928290645843, "E": 4.566456158951202e-08}, "output": {"final_z": [-1.2291438136582604, 2.0372941035994256], "final_cost": 48.058253084672764}}], "error_log": []}
{"context": "Given a digital circuit described by a series of operations, where each operation defines a gate and its inputs, how can we represent the circuit as a Boolean satisfiability (SAT) problem, and what is the maximum input vertex number plus one?\n\nThe input and output requirements are as follows:\n\nInput:\n  `operations` (list of strings): A list of strings where each string represents a line of operations in the circuit description. Each string should follow the format of the original code file, such as `\"INPUT(v)\"`, `\"OUTPUT(v)\"`, or `\"gate=operation(a,b)\"`.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `\"sat_result\"` (list of lists of integers): A list of clauses where each clause is a list of integers representing the SAT problem.\n    - `\"max_input_vertex\"` (integer): The maximum input vertex number plus one.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nvertexes_match = {}\nvertex_counter = 1\nsat = []\ninput_vertexes = []\n\ndef add_vertex(v, is_input=False):\n    global vertex_counter\n    global vertexes_match\n    if v in vertexes_match.keys():\n        return vertexes_match[v]\n    vertexes_match[v] = vertex_counter\n    if is_input:\n        input_vertexes.append(vertex_counter)\n    vertex_counter += 1\n    return vertexes_match[v]\n\ndef create_new_vertex():\n    global vertex_counter\n    vertex_counter += 1\n    return vertex_counter - 1\n\ndef sat_add_and(g, h1, h2):\n    sat.extend([[-g, h1], [-g, h2], [g, -h1, -h2]])\n\ndef sat_add_or(g, h1, h2):\n    sat.extend([[g, -h1], [g, -h2], [-g, h1, h2]])\n\ndef sat_add_not(g, h):\n    sat.extend([[g, h], [-g, -h]])\n\ndef sat_add_id(g, h):\n    sat.extend([[g, -h], [-g, h]])\n\ndef parse_operation(line):\n    gate, operation = line.replace(' ', '').split('=')\n    g = add_vertex(gate)\n    if operation.startswith('AND'):\n        a, b = operation[4:-1].split(',')\n        h1, h2 = add_vertex(a), add_vertex(b)\n        sat_add_and(g, h1, h2)\n    elif operation.startswith('OR'):\n        a, b = operation[3:-1].split(',')\n        h1, h2 = add_vertex(a), add_vertex(b)\n        sat_add_or(g, h1, h2)\n    elif operation.startswith('NOT'):\n        a = operation[4:-1]\n        h = add_vertex(a)\n        sat_add_not(g, h)\n    elif operation.startswith('NAND'):\n        a, b = operation[5:-1].split(',')\n        h1, h2 = add_vertex(a), add_vertex(b)\n        g1 = create_new_vertex()\n        sat_add_and(g1, h1, h2)\n        sat_add_not(g, g1)\n    elif operation.startswith('NOR'):\n        a, b = operation[4:-1].split(',')\n        h1, h2 = add_vertex(a), add_vertex(b)\n        g1 = create_new_vertex()\n        sat_add_or(g1, h1, h2)\n        sat_add_not(g, g1)\n    elif operation.startswith('NXOR'):\n        a, b = operation[5:-1].split(',')\n        h1, h2 = add_vertex(a), add_vertex(b)\n        g1 = create_new_vertex()\n        sat_add_and(g1, h1, h2)\n        g2 = create_new_vertex()\n        sat_add_not(g2, h1)\n        g3 = create_new_vertex()\n        sat_add_not(g3, h2)\n        g4 = create_new_vertex()\n        sat_add_and(g4, g2, g3)\n        sat_add_or(g, g1, g4)\n    elif operation.startswith('XOR'):\n        a, b = operation[4:-1].split(',')\n        h1, h2 = add_vertex(a), add_vertex(b)\n        g1 = create_new_vertex()\n        sat_add_not(g1, h1)\n        g2 = create_new_vertex()\n        sat_add_not(g2, h2)\n        g3 = create_new_vertex()\n        sat_add_and(g3, g1, h2)\n        g4 = create_new_vertex()\n        sat_add_and(g4, h1, g2)\n        sat_add_or(g, g3, g4)\n    elif operation.startswith('DFF') or operation.startswith('BUFF'):\n        a = operation[4:-1]\n        h = add_vertex(a)\n        sat_add_id(g, h)\n\ndef parse_line(line):\n    if line.isspace() or line == '':\n        return\n    if line.startswith('#'):\n        return\n    if line.startswith('INPUT('):\n        add_vertex(line[6:-1], is_input=True)\n        return\n    if line.startswith('OUTPUT('):\n        sat.append([add_vertex(line[7:-1])])\n        return\n    parse_operation(line)\n\n# main function\ndef main_solution(operations):\n    global vertex_counter\n    global vertexes_match\n    global sat\n    global input_vertexes\n    \n    vertex_counter = 1\n    vertexes_match = {}\n    sat = []\n    input_vertexes = []\n    \n    for line in operations:\n        parse_line(line)\n    \n    # Convert the final SAT result to a JSON serializable format\n    sat_result = [[int(x) for x in clause] for clause in sat]\n    \n    return {\n        \"sat_result\": sat_result,\n        \"max_input_vertex\": max(input_vertexes) + 1\n    }", "input_generator": "import random\n\ndef input_generator():\n    operations = []\n    num_gates = random.randint(5, 15)\n    input_vars = [f\"i_{i}\" for i in range(random.randint(2, 5))]\n    output_vars = [f\"o_{i}\" for i in range(random.randint(1, 3))]\n    gate_types = ['AND', 'OR', 'NOT', 'NAND', 'NOR', 'XOR', 'NXOR', 'BUFF']\n    \n    # Add INPUT declarations\n    for var in input_vars:\n        operations.append(f\"INPUT({var})\")\n    \n    # Generate gates\n    used_vars = input_vars.copy()\n    for _ in range(num_gates):\n        gate_name = f\"g_{random.randint(1, 100)}\"\n        gate_type = random.choice(gate_types)\n        \n        if gate_type == 'NOT':\n            a = random.choice(used_vars)\n            operations.append(f\"{gate_name} = {gate_type}({a})\")\n        elif gate_type in ['AND', 'OR', 'NAND', 'NOR', 'XOR', 'NXOR']:\n            a, b = random.sample(used_vars, 2)\n            operations.append(f\"{gate_name} = {gate_type}({a},{b})\")\n        elif gate_type == 'BUFF':\n            a = random.choice(used_vars)\n            operations.append(f\"{gate_name} = {gate_type}({a})\")\n        \n        used_vars.append(gate_name)\n    \n    # Add OUTPUT declarations\n    for var in output_vars:\n        operations.append(f\"OUTPUT({random.choice(used_vars)})\")\n    \n    return {\"operations\": operations}", "io_pairs": [], "error_log": []}
{"context": "Given a classic puzzle of moving disks from one pillar to another using an auxiliary pillar, how many steps are required to move `n` disks from the source pillar `plfrom` to the destination pillar `plto` using the auxiliary pillar `pltmp`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of disks to be moved.\n  `plfrom` (str): The name of the source pillar (e.g., 'A').\n  `pltmp` (str): The name of the auxiliary pillar (e.g., 'B').\n  `plto` (str): The name of the destination pillar (e.g., 'C').\n\nOutput:\n  `return` (int): The total number of steps required to move `n` disks from `plfrom` to `plto` using `pltmp` as the auxiliary pillar.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef hanoi(number, plfrom, pltmp, plto):\n    i = 0\n    if number > 0:\n        i = hanoi(number - 1, plfrom, plto, pltmp)\n        i += 1\n        i += hanoi(number - 1, pltmp, plfrom, plto)\n    return i\n\n# main function\ndef main_solution(n, plfrom, pltmp, plto):\n    # Convert JSON serializable inputs to the original input variables\n    number = int(n)\n    plfrom = str(plfrom)\n    pltmp = str(pltmp)\n    plto = str(plto)\n    \n    # Call the original function\n    steps = hanoi(number, plfrom, pltmp, plto)\n    \n    # Convert the output to JSON serializable\n    return steps", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Reasonable range for Hanoi problem\n    pegs = ['A', 'B', 'C']\n    random.shuffle(pegs)\n    plfrom, pltmp, plto = pegs\n    return {'n': n, 'plfrom': plfrom, 'pltmp': pltmp, 'plto': plto}", "io_pairs": [{"input": {"n": 6, "plfrom": "A", "pltmp": "B", "plto": "C"}, "output": 63}, {"input": {"n": 6, "plfrom": "B", "pltmp": "C", "plto": "A"}, "output": 63}, {"input": {"n": 9, "plfrom": "B", "pltmp": "A", "plto": "C"}, "output": 511}, {"input": {"n": 4, "plfrom": "B", "pltmp": "A", "plto": "C"}, "output": 15}, {"input": {"n": 1, "plfrom": "B", "pltmp": "C", "plto": "A"}, "output": 1}, {"input": {"n": 9, "plfrom": "A", "pltmp": "C", "plto": "B"}, "output": 511}, {"input": {"n": 10, "plfrom": "B", "pltmp": "C", "plto": "A"}, "output": 1023}, {"input": {"n": 2, "plfrom": "A", "pltmp": "C", "plto": "B"}, "output": 3}, {"input": {"n": 5, "plfrom": "B", "pltmp": "C", "plto": "A"}, "output": 31}, {"input": {"n": 8, "plfrom": "A", "pltmp": "C", "plto": "B"}, "output": 255}], "error_log": []}
{"context": "Given a square matrix of integers, how can we determine if the matrix is singular by calculating its determinant?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of integers): A square matrix represented as a list of lists of integers. Each inner list represents a row in the matrix.\n\nOutput:\n  `return` (integer): The determinant of the input matrix. If the determinant is zero, the matrix is singular.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef mat(arr, i, j):\n    return [row[: j] + row[j+1:] for row in (arr[: i] + arr[i+1:])]\n\ndef check_singular(arr):\n    data = len(arr)\n    if (data == 2):\n        res = arr[0][0]*arr[1][1] - arr[1][0]*arr[0][1]\n        return res\n\n    determinant = 0\n    for i in range(data):\n        val = (-1)**i\n        dt = check_singular(mat(arr, 0, i))\n        determinant += (val*arr[0][i]*dt)\n    return determinant\n\n# main function\ndef main_solution(matrix):\n    # Convert the input matrix to a list of lists if it's not already\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        raise ValueError(\"Input must be a list of lists representing a matrix\")\n    \n    # Check if the matrix is square\n    size = len(matrix)\n    if any(len(row) != size for row in matrix):\n        raise ValueError(\"Input matrix must be square\")\n    \n    # Calculate the determinant to check if the matrix is singular\n    determinant = check_singular(matrix)\n    \n    # Return the determinant as the result\n    return determinant", "input_generator": "import random\n\ndef input_generator():\n    size = random.randint(2, 5)\n    matrix = []\n    for _ in range(size):\n        row = [random.randint(-10, 10) for _ in range(size)]\n        matrix.append(row)\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[6, -2, 6], [3, -10, -10], [1, 7, -10]]}, "output": 1166}, {"input": {"matrix": [[9, -4, -5], [-3, 0, 9], [-9, -2, 1]]}, "output": 444}, {"input": {"matrix": [[-4, -4], [-3, -2]]}, "output": -4}, {"input": {"matrix": [[0, -6], [-7, -9]]}, "output": -42}, {"input": {"matrix": [[3, 7], [3, 0]]}, "output": -21}, {"input": {"matrix": [[-4, 6], [5, -6]]}, "output": -6}, {"input": {"matrix": [[5, 1, -7], [-3, 6, 2], [10, 5, -1]]}, "output": 462}, {"input": {"matrix": [[4, 6], [-6, 3]]}, "output": 48}, {"input": {"matrix": [[6, 3, 9], [5, -4, 5], [-9, -5, 3]]}, "output": -651}, {"input": {"matrix": [[-7, -5], [-4, 8]]}, "output": -76}], "error_log": []}
{"context": "Given a number, how many circular primes are there below this number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `limit` (int): The upper limit (exclusive) for checking circular primes. For example, if `limit` is 100, the function will check for circular primes below 100.\n\nOutput:\n  `return` (int): The count of circular primes below the given `limit`.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    else:\n        i = 3\n        while i <= math.sqrt(n):\n            if n % i == 0:\n                return False\n            i += 2\n        return True\n\ndef is_cyclic_prime(n):\n    str_n = str(n)\n    for index in range(1, len(str_n)):\n        rotated_num = int(str_n[index:] + str_n[:index])\n        if not is_prime(rotated_num):\n            return False\n    return True\n\n# main function\ndef main_solution(limit):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    count = 0\n    for num in range(2, limit):\n        if is_prime(num):\n            if is_cyclic_prime(num):\n                count += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a reasonable limit, ensuring it's not too large or too small\n    # Cyclic primes are rare, so the limit should be chosen to potentially include some\n    # Known cyclic primes under 100 are 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, 97\n    # So setting limits between 10 and 1000 is reasonable\n    limit = random.choice([50, 100, 200, 500, 1000])\n    return {'limit': limit}", "io_pairs": [{"input": {"limit": 500}, "output": 20}, {"input": {"limit": 100}, "output": 13}, {"input": {"limit": 1000}, "output": 25}, {"input": {"limit": 200}, "output": 17}, {"input": {"limit": 50}, "output": 9}], "error_log": []}
{"context": "Imagine you have a series of bulbs that are initially off. You perform a series of operations where you toggle the state of the bulbs in a specific pattern. After completing all the operations, how many bulbs remain on? Specifically, given the number of bulbs `n`, determine the count of bulbs that are still on after `n` rounds of toggling.\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of bulbs. It should be a positive integer.\n\nOutput:\n  `return` (int): The number of bulbs that are on after `n` rounds.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(n):\n    # Convert the input to an integer if it's not already\n    n = int(n)\n    \n    # Calculate the number of bulbs that are on after n rounds\n    # The number of bulbs that are on is equal to the number of perfect squares less than or equal to n\n    result = int(math.sqrt(n))\n    \n    # Return the result as an integer\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random integer n between 1 and 10000\n    n = random.randint(1, 10000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 9122}, "output": 95}, {"input": {"n": 7201}, "output": 84}, {"input": {"n": 6167}, "output": 78}, {"input": {"n": 7197}, "output": 84}, {"input": {"n": 9065}, "output": 95}, {"input": {"n": 7729}, "output": 87}, {"input": {"n": 9949}, "output": 99}, {"input": {"n": 8585}, "output": 92}, {"input": {"n": 4169}, "output": 64}, {"input": {"n": 4807}, "output": 69}], "error_log": []}
{"context": "In a stable marriage problem, there are two sets of parties, A and B, each with their own preferences for the other set. Given the preference lists of both sets, what are the stable matches where no two parties would prefer each other over their current partners?\n\nThe input and output requirements are as follows:\n\nInput:\n  `A_preferences` (list of lists): A list of preference lists for each proposing party (A). Each inner list contains integers representing the preferences of A for the accepting parties (B).\n  `B_preferences` (list of lists): A list of preference lists for each accepting party (B). Each inner list contains integers representing the preferences of B for the proposing parties (A).\n\nOutput:\n  `return` (list of tuples): A list of tuples representing the stable matches. Each tuple contains two integers, the first being the index of the proposing party (A) and the second being the index of the accepting party (B).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass preference_list:\n    def __init__(self, input_list):\n        self.list = input_list\n    \n    def prefers(self, c1, c2):\n        return self.list.index(c1) < self.list.index(c2)\n    \n    def get(self, index):\n        return self.list[index]\n\n    def get_index(self, c):\n        return self.list.index(c)\n\n# main function\ndef main_solution(A_preferences, B_preferences):\n    # Convert JSON serializable inputs to original input variables\n    A = [preference_list(pref) for pref in A_preferences]\n    B = [preference_list(pref) for pref in B_preferences]\n    n = len(A)\n    \n    # the algorithm\n    bookmark = [0 for _ in A]\n    matchA = {}\n    matchB = {}\n    matchA[0] = A[0].get(0)\n    matchB[matchA[0]] = 0\n    bookmark[0] += 1\n    i = 1\n    while i < n:\n        a = i\n        while True:\n            b = A[a].get(bookmark[a])  # b will be proposed to\n            bookmark[a] += 1\n            if b not in matchB:  # if b is not engaged...\n                matchA[a] = b\n                matchB[b] = a\n                break\n            else:\n                a2 = matchB[b]\n                # if a is better than current suitor\n                if B[b].get_index(a) < B[b].get_index(a2):\n                    matchA[a] = b\n                    matchB[b] = a\n                    matchA.pop(a2)\n                    a = a2\n        i += 1\n    out = [(a, matchA[a]) for a in matchA]\n    return out", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(3, 10)  # Reasonable size for stable matching problem\n    candidates = list(range(n))\n    \n    A_preferences = []\n    for _ in range(n):\n        shuffled = candidates.copy()\n        random.shuffle(shuffled)\n        A_preferences.append(shuffled)\n    \n    B_preferences = []\n    for _ in range(n):\n        shuffled = list(range(n))  # B's preferences are over A's indices (0..n-1)\n        random.shuffle(shuffled)\n        B_preferences.append(shuffled)\n    \n    return {'A_preferences': A_preferences, 'B_preferences': B_preferences}", "io_pairs": [], "error_log": []}
{"context": "Given a sequence of integers, what is the sum of the distances between consecutive integers in the sequence? For example, in the sequence [1, 7, 2, 11, 8, 34, 3], the distance between 1 and 2 is 2, between 2 and 3 is 4, and between 7 and 8 is 3. What is the total sum of these distances for a given sequence of integers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `integers` (list of int): A list of integers for which the consecutive distance rating needs to be calculated.\n\nOutput:\n  `return` (int): The consecutive distance rating of the input list of integers.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(integers):\n    # Convert the input list to a JSON serializable format\n    integers = list(integers)\n    \n    # Calculate the consecutive distance rating\n    count = 0\n    for i in integers:\n        if i + 1 in integers:\n            count += abs(integers.index(i) - integers.index(i + 1))\n    \n    # Return the result as a JSON serializable output\n    return count", "input_generator": "import random\n\ndef input_generator():\n    length = random.randint(5, 20)\n    integers = random.sample(range(1, 100), length)\n    return {'integers': integers}", "io_pairs": [{"input": {"integers": [56, 33, 24, 31, 75, 98, 97, 74, 81, 52]}, "output": 4}, {"input": {"integers": [21, 39, 81, 48, 32, 88, 7]}, "output": 0}, {"input": {"integers": [75, 38, 5, 78, 79, 88, 80, 48, 63, 91, 26, 18, 12, 50, 82, 97, 35]}, "output": 3}, {"input": {"integers": [51, 57, 58, 66, 75, 20]}, "output": 1}, {"input": {"integers": [66, 56, 23, 88, 53, 41, 62, 84, 57, 47]}, "output": 7}, {"input": {"integers": [1, 34, 76, 26, 64, 67, 72, 95, 79, 25, 90, 98, 70, 28, 46, 73]}, "output": 15}, {"input": {"integers": [26, 25, 71, 40, 84, 83, 32, 68]}, "output": 2}, {"input": {"integers": [99, 7, 19, 80, 61, 62, 13, 1, 98, 25, 51, 38, 28, 71, 65]}, "output": 9}, {"input": {"integers": [85, 51, 99, 29, 87, 47, 89, 81, 98, 25, 41, 38, 42, 96]}, "output": 8}, {"input": {"integers": [48, 53, 70, 71, 77, 3, 66, 94, 86, 90, 51, 54, 78]}, "output": 19}], "error_log": []}
{"context": "In a 25x25 grid, Picobot is a simple robot that navigates based on a set of rules. Given an initial position for Picobot and a number of steps it will take, what is the average fitness of the Picobot program over a specified number of trials? The fitness is defined as the fraction of cells in the grid that Picobot has visited.\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_row` (int): The initial row position of Picobot within the 25x25 grid.\n  `initial_col` (int): The initial column position of Picobot within the 25x25 grid.\n  `steps` (int): The number of steps Picobot will take during the simulation.\n  `trials` (int): The number of trials to run to evaluate the fitness of the Picobot program.\n\nOutput:\n  `return` (dict): A dictionary containing the key `fitness` with a float value representing the average fitness of the Picobot program over the specified number of trials.", "reference_code": "# import necessary packages\nimport random\nimport operator\n\n# Constants\nHEIGHT = 25\nWIDTH = 25\nNUMSTATES = 5\n\n# all class and function definitions in the code file, if any\nclass Program:\n    def __init__(self):\n        self.rules = {}\n\n    def randomize(self):\n        Moves = ('N', 'S', 'W', 'E')\n        surrounding = ('xxxx', 'Nxxx', 'NExx', 'NxWx', 'xxxS', 'xExS', 'xxWS', 'xExx', 'xxWx')\n        for state in range(5):\n            for pattern in surrounding:\n                movedir = random.choice(Moves)\n                while movedir in pattern:\n                    movedir = random.choice(Moves)\n                self.rules[(state, pattern)] = (movedir, random.randint(0, 4))\n\n    def getMove(self, state, surrounding):\n        return self.rules[(state, surrounding)]\n\nclass World:\n    def __init__(self, initial_row, initial_col, program):\n        self.prow = initial_row\n        self.pcol = initial_col\n        self.state = 0\n        self.prog = program\n        self.room = [ [' ']*WIDTH for row in range(HEIGHT) ]\n        for col in range(WIDTH):\n            self.room[0][col] = '-'\n        for col in range(WIDTH):\n            self.room[HEIGHT-1][col] = '-' \n        for row in range(HEIGHT):\n            self.room[row][0] = '|'\n        for row in range(HEIGHT-1):\n            self.room[row][WIDTH -1] = '|'\n        self.room[0][0] = '+'\n        self.room[0][WIDTH-1] = '+'\n        self.room[HEIGHT-1][0] = '+'\n        self.room[HEIGHT-1][WIDTH-1] = '+'\n        self.room[self.prow][self.pcol] = 'P'\n\n    def getCurrentSurroundings(self):\n        state = ''\n        if self.prow == 1:\n            state += 'N'\n        else:\n            state += 'x'\n        if self.pcol == WIDTH - 2:\n            state += 'E'\n        else:\n            state += 'x'\n        if self.pcol == 1:\n            state += 'W'\n        else:\n            state += 'x'\n        if self.prow == HEIGHT - 2:\n            state += 'S'\n        else:\n            state += 'x'\n        return state\n    \n    def step(self):\n        current_surrounding = self.getCurrentSurroundings()\n        NEW = self.prog.getMove(self.state,current_surrounding)\n        nextMove = NEW[0]\n        nextState = NEW[1]\n        self.room[self.prow][self.pcol] = 'o'\n        self.state = nextState\n        if nextMove == 'N':\n            self.prow -= 1\n        elif nextMove == 'S':\n            self.prow += 1\n        elif nextMove == 'W':\n            self.pcol -= 1\n        else:\n            self.pcol += 1\n        self.room[self.prow][self.pcol] = 'P'\n    \n    def run(self, steps):\n        for turn in range(steps):\n            self.step()\n    \n    def fractionVisitedCells(self):\n        cellsVisited = 0\n        cellsTotal = 23*23\n        for col in range(WIDTH):\n            for row in range(HEIGHT):\n                if self.room[row][col] == 'o' or self.room[row][col] == 'P':\n                    cellsVisited += 1\n        return cellsVisited/cellsTotal\n\ndef evaluateFitness(program, trials, steps):\n    totalFitness = 0\n    for x in range(trials):\n        row = random.randint(1,23)\n        col = random.randint(1,23)\n        picobot = World(row, col, program)\n        picobot.run(steps)\n        totalFitness += picobot.fractionVisitedCells()\n    return totalFitness/trials\n\n# main function\ndef main_solution(initial_row, initial_col, steps, trials):\n    # Convert JSON serializable inputs to original input variables\n    initial_row = int(initial_row)\n    initial_col = int(initial_col)\n    steps = int(steps)\n    trials = int(trials)\n\n    # Create a random program\n    program = Program()\n    program.randomize()\n\n    # Evaluate the fitness of the program\n    fitness = evaluateFitness(program, trials, steps)\n\n    # Return the fitness as a JSON serializable output\n    return {\"fitness\": fitness}", "input_generator": "import random\n\ndef input_generator():\n    initial_row = random.randint(1, 23)\n    initial_col = random.randint(1, 23)\n    steps = random.randint(50, 200)\n    trials = random.randint(5, 20)\n    return {\n        \"initial_row\": initial_row,\n        \"initial_col\": initial_col,\n        \"steps\": steps,\n        \"trials\": trials\n    }", "io_pairs": [{"input": {"initial_row": 20, "initial_col": 18, "steps": 152, "trials": 9}, "output": {"fitness": 0.06490233144297415}}, {"input": {"initial_row": 11, "initial_col": 13, "steps": 160, "trials": 16}, "output": {"fitness": 0.05718336483931949}}, {"input": {"initial_row": 5, "initial_col": 11, "steps": 53, "trials": 20}, "output": {"fitness": 0.06578449905482041}}, {"input": {"initial_row": 6, "initial_col": 18, "steps": 52, "trials": 17}, "output": {"fitness": 0.04714778160791727}}, {"input": {"initial_row": 17, "initial_col": 16, "steps": 132, "trials": 17}, "output": {"fitness": 0.026909818747915044}}, {"input": {"initial_row": 23, "initial_col": 6, "steps": 102, "trials": 16}, "output": {"fitness": 0.0392249527410208}}, {"input": {"initial_row": 10, "initial_col": 3, "steps": 166, "trials": 17}, "output": {"fitness": 0.04948293116868676}}, {"input": {"initial_row": 8, "initial_col": 12, "steps": 100, "trials": 20}, "output": {"fitness": 0.017958412098298675}}, {"input": {"initial_row": 15, "initial_col": 16, "steps": 98, "trials": 9}, "output": {"fitness": 0.05881117412308338}}, {"input": {"initial_row": 8, "initial_col": 9, "steps": 92, "trials": 13}, "output": {"fitness": 0.03155445688526974}}], "error_log": []}
{"context": "Given a Markov chain with a transition probability matrix that depends on a temperature parameter \\( T \\), what is the probability distribution of the states after the transition matrix is raised to a certain power? The transition matrix is defined such that the probabilities of moving between states depend on the temperature \\( T \\). The problem requires determining the probability distribution of the states after the matrix is raised to a specified power \\( \\text{power} \\).\n\nThe input and output requirements are as follows:\n\nInput:\n  `T` (float): The temperature parameter for the transition probability matrix.\n  `power` (int): The power to which the transition probability matrix should be raised.\n\nOutput:\n  `return` (list of float): A list representing the probability distribution of states after raising the transition probability matrix to the specified power. The list contains four float values corresponding to the probabilities of being in states 1, 2, 3, and 4 respectively.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef cost(x1, x2):\n    return 2 * np.power((x1 - x2), 2) + x1\n\ndef transProb(T):\n    p21 = 0.5 * np.exp(-1 / T)\n    p24 = 0.5 * np.exp(-2 / T)\n    p22 = 1 - p21 - p24\n    p31 = 0.5 * np.exp(-2 / T)\n    p34 = 0.5 * np.exp(-3 / T)\n    p33 = 1 - p31 - p34\n    P = np.matrix([[0, 0.5, 0.5, 0], [p21, p22, 0, p24], [p31, 0, p33, p34], [0, 0.5, 0.5, 0]])\n    return P\n\ndef matPower(matrix, power):\n    sol = matrix\n    for i in range(1, power):\n        sol = np.matmul(sol, matrix)\n    return sol\n\n# main function\ndef main_solution(T, power):\n    # Convert input to float for precision\n    T = float(T)\n    power = int(power)\n    \n    # Generate transition probability matrix\n    P = transProb(T)\n    \n    # Calculate the power of the matrix\n    P_power = matPower(P, power)\n    \n    # Extract the probability distribution from the resulting matrix\n    probability_distribution = P_power[0, :].tolist()[0]\n    \n    # Return the probability distribution as a list of floats\n    return probability_distribution", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    T = random.uniform(0.1, 10.0)\n    power = random.randint(1, 20)\n    return {'T': T, 'power': power}", "io_pairs": [{"input": {"T": 2.1678835888552563, "power": 10}, "output": [0.17460488536644783, 0.2771433389732478, 0.43816749697236446, 0.11008427868794006]}, {"input": {"T": 9.266538997728636, "power": 12}, "output": [0.2583700606706614, 0.23896213365687802, 0.27072803122159034, 0.2319397744508701]}, {"input": {"T": 3.2635516024557116, "power": 19}, "output": [0.2024116048579293, 0.2750000431266201, 0.3735969456663851, 0.14899140634906555]}, {"input": {"T": 6.153070542136675, "power": 10}, "output": [0.24024172157348855, 0.2535060000667578, 0.30204713237379405, 0.20420514598595974]}, {"input": {"T": 9.814264101841143, "power": 20}, "output": [0.24142662754101055, 0.25603687828442373, 0.28449767914288526, 0.21803881503168046]}, {"input": {"T": 0.5904912725702733, "power": 5}, "output": [0.04683394841253148, 0.39539942148343166, 0.5491550897768523, 0.008611540327184461]}, {"input": {"T": 6.292060813556366, "power": 7}, "output": [0.19116023572580995, 0.301877815321399, 0.34389162128722783, 0.1630703276655632]}, {"input": {"T": 1.2644355835893202, "power": 6}, "output": [0.12231832344757253, 0.29461136527735754, 0.5276048696630349, 0.055465441612034816]}, {"input": {"T": 7.725310633257184, "power": 19}, "output": [0.22938373929122957, 0.26642173545944836, 0.30266181831619704, 0.20153270693312506]}, {"input": {"T": 8.29640669576213, "power": 2}, "output": [0.4180587168551251, 0.0819412831448749, 0.129413167397244, 0.37058683260275604]}], "error_log": []}
{"context": "In a high-dimensional cellular automaton simulation, a set of initial active cells in a 2D grid evolves over a specified number of generations. Each cell can be in an active or inactive state, and the state of each cell in the next generation depends on the number of its active neighbors. Given the initial active cells, the number of dimensions, and the number of generations, how many active cells will there be after the specified number of generations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_cells` (list of tuples): A list of tuples representing the initial active cells in a 2D grid. Each tuple contains two integers representing the coordinates of an active cell.\n  `dimensions` (int): An integer representing the number of dimensions for the simulation (e.g., 3 for 3D, 4 for 4D).\n  `generations` (int): An integer representing the number of generations to simulate.\n\nOutput:\n  `return` (int): An integer representing the number of active cells after the specified number of generations.", "reference_code": "# import necessary packages\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\ndef get_neighbors(cell: tuple) -> set:\n    dims = len(cell)\n    deltas = product(*[[-1, 0, 1]] * dims)\n    res = {tuple(c + d for c, d in zip(cell, delta)) for delta in deltas}\n    res.remove(cell)\n    return res\n\ndef next_gen(cells: set) -> set:\n    nb = {}\n    for c in cells:\n        for n in get_neighbors(c):\n            try:\n                nb[n] += 1\n            except KeyError:\n                nb[n] = 1\n    new_cells = set()\n    for c in nb:\n        active_neighbors = nb[c]\n        if active_neighbors == 3 or (active_neighbors == 2 and c in cells):\n            new_cells.add(c)\n    return new_cells\n\ndef next_gens(cells: set, n: int) -> set:\n    for _ in range(n):\n        cells = next_gen(cells)\n    return cells\n\n# main function\ndef main_solution(initial_cells: list, dimensions: int, generations: int) -> int:\n    # Convert list to set for initial_cells\n    cells = {(x, y) + (0,) * (dimensions - 2) for x, y in initial_cells}\n    final_cells = next_gens(cells, generations)\n    return len(final_cells)", "input_generator": "import random\n\ndef input_generator():\n    dimensions = random.randint(2, 4)\n    generations = random.randint(1, 10)\n    num_cells = random.randint(1, 20)\n    initial_cells = []\n    for _ in range(num_cells):\n        x = random.randint(-10, 10)\n        y = random.randint(-10, 10)\n        initial_cells.append((x, y))\n    return {\n        'initial_cells': initial_cells,\n        'dimensions': dimensions,\n        'generations': generations\n    }", "io_pairs": [{"input": {"initial_cells": [[9, 4], [8, -10], [-5, 0], [-10, -4]], "dimensions": 4, "generations": 1}, "output": 0}, {"input": {"initial_cells": [[-6, -2], [-9, 2], [5, -4], [6, 9]], "dimensions": 3, "generations": 5}, "output": 0}, {"input": {"initial_cells": [[0, 8]], "dimensions": 3, "generations": 2}, "output": 0}, {"input": {"initial_cells": [[2, 9], [6, 0]], "dimensions": 3, "generations": 6}, "output": 0}, {"input": {"initial_cells": [[8, -5]], "dimensions": 3, "generations": 6}, "output": 0}, {"input": {"initial_cells": [[-8, 1], [-3, 5], [-6, 6], [-5, -7]], "dimensions": 2, "generations": 6}, "output": 0}, {"input": {"initial_cells": [[-10, 6], [8, -10], [6, -9], [-6, 10]], "dimensions": 4, "generations": 7}, "output": 0}, {"input": {"initial_cells": [[7, -6]], "dimensions": 2, "generations": 9}, "output": 0}, {"input": {"initial_cells": [[7, 5]], "dimensions": 3, "generations": 8}, "output": 0}, {"input": {"initial_cells": [[6, 2], [10, -2]], "dimensions": 2, "generations": 2}, "output": 0}], "error_log": []}
{"context": "In a scenario where missionaries and cannibals need to cross a river using a boat that can hold up to two people, how can we determine the sequence of moves required to safely transport all missionaries and cannibals from the left side of the river to the right side without ever allowing the cannibals to outnumber the missionaries on either side of the river? Given the initial number of missionaries and cannibals on the left side, what is the list of moves that ensures all reach the right side safely?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_missionaries` (int): The initial number of missionaries on the left side of the river.\n  `initial_cannibals` (int): The initial number of cannibals on the left side of the river.\n\nOutput:\n  `return` (list of tuples): A list of 2-tuples representing the moves required to get all missionaries and cannibals from the left side of the river to the right. Each tuple represents a move with the number of missionaries and cannibals moved in that step. If it is impossible to move the animals over according to the rules of the problem, an empty list is returned.", "reference_code": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass SemanticNetsAgent:\n    def __init__(self):\n        pass\n\n    def solve(self, initial_missionaries, initial_cannibals):\n        class States:\n            def __init__(self, left_missionaries, left_cannibals, right_missionaries, right_cannibals, boat_position):\n                self.left_missionaries = left_missionaries\n                self.left_cannibals = left_cannibals\n                self.right_missionaries = right_missionaries\n                self.right_cannibals = right_cannibals\n                self.boat_position = boat_position\n                self.parent = None\n\n            def __eq__(self, other):\n                return (self.left_missionaries == other.left_missionaries and self.left_cannibals == other.left_cannibals and\n                        self.right_missionaries == other.right_missionaries and self.right_cannibals == other.right_cannibals and\n                        self.boat_position == other.boat_position)\n\n            def goal_state(self):\n                if self.left_missionaries == 0 and self.left_cannibals == 0 and self.right_missionaries == initial_missionaries \\\n                        and self.right_cannibals == initial_cannibals and self.boat_position == \"right\":\n                    return True\n                else:\n                    return False\n\n            def valid_state(self):\n                if (self.left_missionaries != 0 and self.left_cannibals > self.left_missionaries) \\\n                        or (self.right_missionaries != 0 and self.right_cannibals > self.right_missionaries) \\\n                        or self.left_missionaries < 0 or self.left_cannibals < 0 or self.right_missionaries < 0 \\\n                        or self.right_cannibals < 0:\n                    return False\n                else:\n                    return True\n\n        def successors(curr_state):\n            successor = []\n            possible_moves = [(2, 0), (0, 2), (1, 1), (1, 0), (0, 1)]\n            if curr_state.boat_position == \"left\":\n                for move in possible_moves:\n                    new_state = States(curr_state.left_missionaries - move[0], curr_state.left_cannibals - move[1],\n                                       curr_state.right_missionaries + move[0], curr_state.right_cannibals + move[1], \"right\")\n                    if new_state.valid_state():\n                        successor.append(new_state)\n                        new_state.parent = curr_state\n            else:\n                for move in possible_moves:\n                    new_state = States(curr_state.left_missionaries + move[0], curr_state.left_cannibals + move[1],\n                                       curr_state.right_missionaries - move[0], curr_state.right_cannibals - move[1], \"left\")\n                    if new_state.valid_state():\n                        successor.append(new_state)\n                        new_state.parent = curr_state\n            return successor\n\n        def bfs():\n            initial_state = States(initial_missionaries, initial_cannibals, 0, 0, \"left\")\n            if initial_state.goal_state():\n                return initial_state\n            queue = deque([])\n            explored = []\n            queue.append(initial_state)\n            while queue:\n                node = queue.popleft()\n                if node.goal_state():\n                    return node\n                explored.append(node)\n                node_children = successors(node)\n                for child in node_children:\n                    if (child not in explored) and (child not in queue):\n                        queue.append(child)\n            return None\n\n        def find_moves(result):\n            path = []\n            final_path = []\n            result_parent = result.parent\n            while result_parent:\n                move = (abs(result.left_missionaries - result_parent.left_missionaries),\n                        abs(result.left_cannibals - result_parent.left_cannibals))\n                path.append(move)\n                result = result_parent\n                result_parent = result.parent\n            for i in range(len(path)):\n                final_result = path[len(path) - 1 - i]\n                final_path.append(final_result)\n            return final_path\n\n        solution = bfs()\n        if solution:\n            return find_moves(solution)\n        else:\n            return []\n\n# main function\ndef main_solution(initial_missionaries, initial_cannibals):\n    # Convert JSON serializable inputs to the original input variables\n    agent = SemanticNetsAgent()\n    result = agent.solve(initial_missionaries, initial_cannibals)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate initial_missionaries and initial_cannibals between 1 and 5\n    initial_missionaries = random.randint(1, 5)\n    initial_cannibals = random.randint(1, 5)\n    \n    # Ensure that initial_missionaries >= initial_cannibals to have a solvable problem\n    if initial_missionaries < initial_cannibals:\n        initial_missionaries, initial_cannibals = initial_cannibals, initial_missionaries\n    \n    return {\n        'initial_missionaries': initial_missionaries,\n        'initial_cannibals': initial_cannibals\n    }", "io_pairs": [{"input": {"initial_missionaries": 3, "initial_cannibals": 2}, "output": [[0, 2], [0, 1], [2, 0], [1, 0], [2, 0], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 4, "initial_cannibals": 3}, "output": [[0, 2], [0, 1], [2, 0], [1, 0], [1, 1], [0, 1], [2, 0], [0, 1], [0, 2], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 1, "initial_cannibals": 1}, "output": [[1, 1]]}, {"input": {"initial_missionaries": 2, "initial_cannibals": 1}, "output": [[2, 0], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 2, "initial_cannibals": 2}, "output": [[0, 2], [0, 1], [2, 0], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 5, "initial_cannibals": 5}, "output": []}, {"input": {"initial_missionaries": 4, "initial_cannibals": 1}, "output": [[2, 0], [1, 0], [2, 0], [1, 0], [2, 0], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 5, "initial_cannibals": 3}, "output": [[2, 0], [1, 0], [1, 1], [1, 0], [2, 0], [1, 0], [1, 1], [1, 0], [2, 0], [1, 0], [2, 0], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 3, "initial_cannibals": 1}, "output": [[2, 0], [1, 0], [2, 0], [1, 0], [1, 1]]}, {"input": {"initial_missionaries": 3, "initial_cannibals": 3}, "output": [[0, 2], [0, 1], [0, 2], [0, 1], [2, 0], [1, 1], [2, 0], [0, 1], [0, 2], [1, 0], [1, 1]]}], "error_log": []}
{"context": "Given a standard 8x8 chessboard, two queens are placed at random positions. Can the first queen attack the second queen?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_size` (int): The size of the chessboard (e.g., 8 for an 8x8 board).\n  `queen1_row` (int): The row index (0-based) where the first queen is placed.\n  `queen1_col` (int): The column index (0-based) where the first queen is placed.\n  `queen2_row` (int): The row index (0-based) where the second queen is placed.\n  `queen2_col` (int): The column index (0-based) where the second queen is placed.\n\nOutput:\n  `return` (bool): `True` if the two queens can attack each other, `False` otherwise.", "reference_code": "# import necessary packages\nfrom typing import List\nfrom random import randint\n\n# all class and function definitions in the code file, if any\ndef create_board(size: int) -> List[List[int]]:\n    board = []\n    for i in range(size):\n        row = []\n        for j in range(size):\n            row.append(0)\n        board.append(row)\n    return board\n\ndef add_random_queen(chess_board: List[List[int]]) -> List[List[int]]:\n    random_indexes = (randint(0, len(chess_board) - 1), randint(0, len(chess_board) - 1))\n    if chess_board[random_indexes[0]][random_indexes[1]] == 1:\n        return add_random_queen(chess_board)\n    chess_board[random_indexes[0]][random_indexes[1]] = 1\n    return chess_board\n\ndef number_of_queens(board: List[List[int]]) -> int:\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 1:\n                count += 1\n    return count\n\ndef isOutsideBorder(board: List[List[int]], row: int, col: int) -> bool:\n    if row < 0 or row >= len(board):\n        return True\n    if col < 0 or col >= len(board[0]):\n        return True\n    return False\n\ndef first_queen(board: List[List[int]]) -> List[int]:\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 1:\n                return [i, j]\n    return [-1, -1]\n\ndef queens(board: List[List[int]]) -> bool:\n    if len(board) != 8:\n        return False\n    for i in range(len(board)):\n        if len(board[i]) != 8:\n            return False\n    if number_of_queens(board) != 2:\n        return False\n    \n    first_queen_pos = first_queen(board)\n    first_queen_row = first_queen_pos[0]\n    first_queen_col = first_queen_pos[1]\n\n    for j in range(len(board[first_queen_row])):\n        if board[first_queen_row][j] == 1 and j != first_queen_col:\n            return True\n\n    for i in range(len(board)):\n        if board[i][first_queen_col] == 1 and i != first_queen_row:\n            return True\n\n    diagonal_map = [[-1, -1], [-1, +1], [+1, -1], [+1, +1]]\n    for i in range(len(diagonal_map)):\n        move_row = diagonal_map[i][0]\n        move_col = diagonal_map[i][1]\n        row = first_queen_row\n        col = first_queen_col\n        while True:\n            row = row + move_row\n            col = col + move_col\n            if isOutsideBorder(board, row, col):\n                break\n            if board[row][col] == 1:\n                return True\n\n    return False\n\n# main function\ndef main_solution(board_size: int, queen1_row: int, queen1_col: int, queen2_row: int, queen2_col: int) -> bool:\n    # Create the board\n    board = create_board(board_size)\n    \n    # Place the queens on the board\n    board[queen1_row][queen1_col] = 1\n    board[queen2_row][queen2_col] = 1\n    \n    # Check if the queens can attack each other\n    return queens(board)", "input_generator": "import random\nfrom typing import Dict\n\ndef input_generator() -> Dict:\n    board_size = 8\n    queen1_row = random.randint(0, board_size - 1)\n    queen1_col = random.randint(0, board_size - 1)\n    \n    queen2_row = random.randint(0, board_size - 1)\n    queen2_col = random.randint(0, board_size - 1)\n    while (queen2_row == queen1_row and queen2_col == queen1_col):\n        queen2_row = random.randint(0, board_size - 1)\n        queen2_col = random.randint(0, board_size - 1)\n    \n    return {\n        'board_size': board_size,\n        'queen1_row': queen1_row,\n        'queen1_col': queen1_col,\n        'queen2_row': queen2_row,\n        'queen2_col': queen2_col\n    }", "io_pairs": [{"input": {"board_size": 8, "queen1_row": 4, "queen1_col": 7, "queen2_row": 2, "queen2_col": 6}, "output": false}, {"input": {"board_size": 8, "queen1_row": 0, "queen1_col": 0, "queen2_row": 4, "queen2_col": 7}, "output": false}, {"input": {"board_size": 8, "queen1_row": 7, "queen1_col": 7, "queen2_row": 1, "queen2_col": 3}, "output": false}, {"input": {"board_size": 8, "queen1_row": 0, "queen1_col": 5, "queen2_row": 4, "queen2_col": 2}, "output": false}, {"input": {"board_size": 8, "queen1_row": 1, "queen1_col": 5, "queen2_row": 0, "queen2_col": 7}, "output": false}, {"input": {"board_size": 8, "queen1_row": 5, "queen1_col": 4, "queen2_row": 4, "queen2_col": 2}, "output": false}, {"input": {"board_size": 8, "queen1_row": 3, "queen1_col": 0, "queen2_row": 6, "queen2_col": 2}, "output": false}, {"input": {"board_size": 8, "queen1_row": 2, "queen1_col": 3, "queen2_row": 5, "queen2_col": 0}, "output": true}, {"input": {"board_size": 8, "queen1_row": 5, "queen1_col": 3, "queen2_row": 4, "queen2_col": 0}, "output": false}, {"input": {"board_size": 8, "queen1_row": 4, "queen1_col": 1, "queen2_row": 7, "queen2_col": 0}, "output": false}], "error_log": []}
{"context": "Given a positive integer `limit`, find all pairs of amicable numbers `(x, di)` such that both `x` and `di` are less than or equal to `limit`. Amicable numbers are pairs of numbers where the sum of the proper divisors of each number is equal to the other number. What are the pairs of amicable numbers within the given `limit`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `limit` (int): The upper limit for finding amicable numbers. Must be a positive integer.\n\nOutput:\n  `return` (list of tuples): A list of tuples where each tuple contains a pair of amicable numbers. Each tuple is of the form `(x, di)` where `x` and `di` are amicable numbers.", "reference_code": "# import necessary packages\nimport math\nimport collections\n\n# all class and function definitions in the code file, if any\ndef primeFactors2(n, arrayprimos): \n    resta = n\n    factores = []\n    multi = 1\n    i = 0\n    while n != 1 and arrayprimos[i] < math.sqrt(n): \n        while n % arrayprimos[i] == 0:\n            factores.append(arrayprimos[i])\n            n = n / arrayprimos[i]\n        i += 1\n    # Condition if n is a prime \n    # greater than 2\n    if n > 2: \n        factores.append(n)\n    \n    frec = collections.Counter(factores)\n    for valor in frec:\n        multi *= (pow(valor, frec[valor] + 1) - 1) / (valor - 1)\n    return int(multi - resta)\n\ndef primosff(num, pr):\n    div = 0\n    while pr[div] < num:\n        if num % pr[div] == 0:\n            return False\n        else:\n            if pr[div] > math.sqrt(num):\n                return True\n            else:\n                div += 1\n    return True\n\ndef generate_primes(limit):\n    prim = 3\n    arrayprimos = [2, 3]\n    while prim < math.sqrt(limit):\n        prim += 2\n        if primosff(prim, arrayprimos):\n            arrayprimos.append(prim)\n    return arrayprimos\n\n# main function\ndef main_solution(limit):\n    # Generate prime numbers up to the square root of the limit\n    arrayprimos = generate_primes(limit)\n    \n    # Find amicable numbers\n    amicable_numbers = []\n    for x in range(220, limit):\n        if x % 2 == 0 or x % 5 == 0:\n            di = primeFactors2(x, arrayprimos)\n            if di > x and di <= limit:\n                dj = primeFactors2(di, arrayprimos)\n                if dj == x:\n                    amicable_numbers.append((x, di))\n    \n    # Return the list of amicable numbers\n    return amicable_numbers", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random limit between 1000 and 10000 to keep it reasonable\n    limit = random.randint(1000, 10000)\n    return {'limit': limit}", "io_pairs": [{"input": {"limit": 7387}, "output": [[220, 284], [2620, 2924], [5020, 5564], [6232, 6368]]}, {"input": {"limit": 5655}, "output": [[220, 284], [2620, 2924], [5020, 5564]]}, {"input": {"limit": 5993}, "output": [[220, 284], [2620, 2924], [5020, 5564]]}, {"input": {"limit": 9850}, "output": [[220, 284], [2620, 2924], [5020, 5564], [6232, 6368]]}, {"input": {"limit": 8041}, "output": [[220, 284], [2620, 2924], [5020, 5564], [6232, 6368]]}, {"input": {"limit": 5277}, "output": [[220, 284], [2620, 2924]]}, {"input": {"limit": 7488}, "output": [[220, 284], [2620, 2924], [5020, 5564], [6232, 6368]]}, {"input": {"limit": 6274}, "output": [[220, 284], [2620, 2924], [5020, 5564]]}, {"input": {"limit": 9469}, "output": [[220, 284], [2620, 2924], [5020, 5564], [6232, 6368]]}, {"input": {"limit": 3179}, "output": [[220, 284], [2620, 2924]]}], "error_log": []}
{"context": "Given a starting point on the Earth's surface defined by its latitude and longitude, and a specified distance between points, how can we generate a grid of points around the starting point, where each point is a certain distance apart from its neighbors? Specifically, what are the coordinates of each point in the grid when the grid is of a given size?\n\nThe input and output requirements are as follows:\n\nInput:\n- `start_latitude` (float): The starting latitude in degrees.\n- `start_longitude` (float): The starting longitude in degrees.\n- `point_dist` (float): The distance between points in kilometers.\n- `square_size` (int): The size of the square grid.\n\nOutput:\n- `return` (dict): A dictionary where each key is a string representing the grid coordinates (e.g., \"0,0\") and each value is a list of two floats representing the latitude and longitude of that grid point.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(start_latitude, start_longitude, point_dist, square_size):\n    # Convert input variables to the required types\n    start_latitude = float(start_latitude)\n    start_longitude = float(start_longitude)\n    point_dist = float(point_dist)\n    square_size = int(square_size)\n    \n    # Function to calculate distance on unit sphere\n    def distance_on_unit_sphere(lat1, long1, lat2, long2):\n        degrees_to_radians = math.pi / 180.0\n        phi1 = (90.0 - lat1) * degrees_to_radians\n        phi2 = (90.0 - lat2) * degrees_to_radians\n        theta1 = long1 * degrees_to_radians\n        theta2 = long2 * degrees_to_radians\n        cos = (math.sin(phi1) * math.sin(phi2) * math.cos(theta1 - theta2) + \n               math.cos(phi1) * math.cos(phi2))\n        arc = math.acos(cos)\n        return arc * 6373  # in km\n    \n    # Calculate delta\n    delta = point_dist / distance_on_unit_sphere(start_latitude, start_longitude, start_latitude + 1, start_longitude)\n    \n    # Generate places dictionary\n    places = {}\n    for x in range(int(-math.floor(square_size / 2)), int(math.ceil(square_size / 2))):\n        for y in range(int(-math.floor(square_size / 2)), int(math.ceil(square_size / 2))):\n            curr = (start_latitude + (delta * x), start_longitude + (delta * y))\n            places[f\"{x},{y}\"] = curr\n    \n    # Convert places dictionary to a JSON serializable format\n    serializable_places = {key: list(value) for key, value in places.items()}\n    \n    return serializable_places", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random start latitude (-90 to 90)\n    start_latitude = random.uniform(-90, 90)\n    # Generate random start longitude (-180 to 180)\n    start_longitude = random.uniform(-180, 180)\n    # Generate random point distance (0.1 to 100 km)\n    point_dist = random.uniform(0.1, 100)\n    # Generate random square size (1 to 10)\n    square_size = random.randint(1, 10)\n    \n    return {\n        'start_latitude': start_latitude,\n        'start_longitude': start_longitude,\n        'point_dist': point_dist,\n        'square_size': square_size\n    }", "io_pairs": [{"input": {"start_latitude": -35.78364397343283, "start_longitude": -134.68250311922316, "point_dist": 65.49776299911362, "square_size": 1}, "output": {"0,0": [-35.78364397343283, -134.68250311922316]}}, {"input": {"start_latitude": -0.9606698415926616, "start_longitude": -147.3712718802198, "point_dist": 12.166259822691114, "square_size": 2}, "output": {"-1,-1": [-1.070049308138966, -147.4806513467661], "-1,0": [-1.070049308138966, -147.3712718802198], "0,-1": [-0.9606698415926616, -147.4806513467661], "0,0": [-0.9606698415926616, -147.3712718802198]}}, {"input": {"start_latitude": -77.80393102119433, "start_longitude": -166.60513010828146, "point_dist": 5.725551142909439, "square_size": 1}, "output": {"0,0": [-77.80393102119433, -166.60513010828146]}}, {"input": {"start_latitude": 84.12559459122417, "start_longitude": 163.61481110780477, "point_dist": 77.91890333323337, "square_size": 1}, "output": {"0,0": [84.12559459122417, 163.61481110780477]}}, {"input": {"start_latitude": -54.06820888882345, "start_longitude": -36.176516645524146, "point_dist": 50.669143636674235, "square_size": 1}, "output": {"0,0": [-54.06820888882345, -36.176516645524146]}}, {"input": {"start_latitude": 62.43147083264654, "start_longitude": 50.24820942189456, "point_dist": 79.55441197432027, "square_size": 2}, "output": {"-1,-1": [61.71624534264617, 49.53298393189419], "-1,0": [61.71624534264617, 50.24820942189456], "0,-1": [62.43147083264654, 49.53298393189419], "0,0": [62.43147083264654, 50.24820942189456]}}, {"input": {"start_latitude": -45.778776858631886, "start_longitude": -134.2482129919474, "point_dist": 86.21832665202903, "square_size": 1}, "output": {"0,0": [-45.778776858631886, -134.2482129919474]}}, {"input": {"start_latitude": 20.300718178671445, "start_longitude": -170.20849302814673, "point_dist": 32.617721055673464, "square_size": 1}, "output": {"0,0": [20.300718178671445, -170.20849302814673]}}, {"input": {"start_latitude": 83.64335436070058, "start_longitude": -21.990558937700712, "point_dist": 75.85579887959639, "square_size": 1}, "output": {"0,0": [83.64335436070058, -21.990558937700712]}}, {"input": {"start_latitude": 78.30517166962915, "start_longitude": 179.83872081954337, "point_dist": 3.644757646100292, "square_size": 2}, "output": {"-1,-1": [78.27240386318485, 179.80595301309907], "-1,0": [78.27240386318485, 179.83872081954337], "0,-1": [78.30517166962915, 179.80595301309907], "0,0": [78.30517166962915, 179.83872081954337]}}], "error_log": []}
{"context": "Given a graph represented by its adjacency matrix and a set number of colors, how can we determine all possible ways to color the vertices of the graph such that no two adjacent vertices share the same color?\n\nThe input and output requirements are as follows:\n\nInput:\n  `adjacency_matrix` (list of lists of integers): A 2D list representing the adjacency matrix of the graph. Each element is either 0 or 1, where 1 indicates an edge between two vertices and 0 indicates no edge.\n  `num_colors` (integer): The number of colors available for coloring the graph.\n\nOutput:\n  `return` (list of lists of integers): A list of all possible colorings of the graph. Each inner list represents a valid coloring of the graph, where each element corresponds to the color assigned to the respective vertex.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef safe(A, v, colour, c):\n    ans = True\n    for i in range(len(A)):\n        if A[v][i] == 1 and colour[i] == c:\n            ans = False\n    return ans\n\ndef solve(A, m, colour, v, all_sols):\n    if v == len(A[0]):\n        all_sols.append(list(colour))\n    else:\n        for c in range(1, m+1):\n            if safe(A, v, colour, c):\n                colour[v] = c\n                solve(A, m, colour, v+1, all_sols)\n\n# main function\ndef main_solution(adjacency_matrix, num_colors):\n    # Convert adjacency_matrix from list of lists to a JSON serializable format\n    adjacency_matrix = [[int(x) for x in row] for row in adjacency_matrix]\n    \n    all_sols = []\n    V = len(adjacency_matrix[0])\n    colour = [None for _ in range(V)]\n    solve(adjacency_matrix, num_colors, colour, 0, all_sols)\n    \n    # Convert all_sols to a JSON serializable format\n    return [sol for sol in all_sols]", "input_generator": "import random\n\ndef input_generator():\n    # Randomly decide the number of vertices (between 2 and 5 for reasonable size)\n    V = random.randint(2, 5)\n    \n    # Generate a random adjacency matrix for a simple undirected graph\n    adjacency_matrix = [[0 for _ in range(V)] for _ in range(V)]\n    for i in range(V):\n        for j in range(i+1, V):\n            adjacency_matrix[i][j] = random.choice([0, 1])\n            adjacency_matrix[j][i] = adjacency_matrix[i][j]\n    \n    # Randomly decide the number of colors (between 1 and V)\n    num_colors = random.randint(1, V)\n    \n    return {\n        'adjacency_matrix': adjacency_matrix,\n        'num_colors': num_colors\n    }", "io_pairs": [{"input": {"adjacency_matrix": [[0, 0, 0], [0, 0, 0], [0, 0, 0]], "num_colors": 1}, "output": [[1, 1, 1]]}, {"input": {"adjacency_matrix": [[0, 1], [1, 0]], "num_colors": 1}, "output": []}, {"input": {"adjacency_matrix": [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], "num_colors": 2}, "output": [[1, 2, 1, 2]]}, {"input": {"adjacency_matrix": [[0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0]], "num_colors": 2}, "output": [[1, 1, 1, 2], [1, 1, 2, 2], [1, 2, 1, 2], [1, 2, 2, 2]]}, {"input": {"adjacency_matrix": [[0, 1, 1], [1, 0, 1], [1, 1, 0]], "num_colors": 2}, "output": []}, {"input": {"adjacency_matrix": [[0, 1], [1, 0]], "num_colors": 2}, "output": [[1, 2]]}, {"input": {"adjacency_matrix": [[0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 1], [1, 0, 1, 0]], "num_colors": 2}, "output": [[1, 1, 1, 2], [1, 2, 1, 2]]}, {"input": {"adjacency_matrix": [[0, 0], [0, 0]], "num_colors": 2}, "output": [[1, 1], [1, 2], [2, 1], [2, 2]]}, {"input": {"adjacency_matrix": [[0, 1, 1, 0], [1, 0, 1, 0], [1, 1, 0, 1], [0, 0, 1, 0]], "num_colors": 2}, "output": []}, {"input": {"adjacency_matrix": [[0, 1, 1], [1, 0, 0], [1, 0, 0]], "num_colors": 1}, "output": []}], "error_log": []}
{"context": "Given a set of article titles and a search query, which articles are most relevant to the search query based on the frequency of the search terms in the articles?\n\nThe input and output requirements are as follows:\n\nInput:\n  `userstring` (str): A string representing the search query. Words should be separated by spaces.\n  `listofarticles` (str): A comma-separated string representing the titles of the articles. Each title should be a single word or phrase.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"closest_articles\"`, whose value is a list of strings representing the titles of the articles that best match the search query.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\ndef vector_distance(vector1, vector2):\n    if len(vector1) != len(vector2):\n        raise ValueError('These two vectors do not have the same length.')\n\n    d = 0\n    for i in range(len(vector1)):\n        d = (vector1[i] - vector2[i])**2 + d\n    d = math.sqrt(d)\n    return d\n\ndef normalize(vector1):\n    length = 0\n    for value in vector1:\n        length = length + value**2\n    length = math.sqrt(length)\n    if length > 0:\n        for i in range(len(vector1)):\n            vector1[i] = vector1[i]/length\n    return vector1      \n\ndef clean_word(word):\n    word = word.strip('.')\n    word = word.strip(',')\n    word = word.strip('!')\n    word = word.strip('?')\n    return word\n\n# main function\ndef main_solution(userstring, listofarticles):\n    # Convert listofarticles to a list of strings\n    listofarticles = listofarticles.split(',')\n    \n    # Break the string into a list of words\n    userstring = userstring.lower()\n    parsedstring = userstring.split()\n    \n    # Collect the unique words in parsedstring in a dictionary\n    masterword_dictionary = {}\n    for word in parsedstring:\n        masterword_dictionary[word] = 0\n    \n    # Make a list of only the unique words in the search string\n    masterword_list = list(masterword_dictionary.keys())\n    \n    # Initialize the word matrix\n    wordmatrix = []\n    \n    # Loop through list of article filenames, open the article file, read the content of the article\n    for article_title in listofarticles:\n        word_dictionary = {}\n        words = []\n        wordvec = []\n        \n        # Simulate reading the article content\n        article_words = article_title.lower().split()\n        \n        # Clean and collect words\n        for w in article_words:\n            w = clean_word(w)\n            words.append(w)\n        \n        # Count words that are in the search string\n        for w in words:\n            if w in masterword_dictionary.keys():\n                word_dictionary[w] = word_dictionary.get(w, 0) + 1\n        \n        # Update masterword_dictionary with article counts\n        for w in masterword_dictionary.keys():\n            if w in word_dictionary.keys():\n                masterword_dictionary[w] = masterword_dictionary.get(w, 0) + 1\n        \n        # Create word vector for the article\n        for word in masterword_list:\n            if word in word_dictionary.keys():\n                wordvec.append(word_dictionary[word])\n            else:\n                wordvec.append(0)\n        \n        # Normalize the word vector\n        wordvec = normalize(wordvec)\n        wordmatrix.append(wordvec)\n    \n    # Calculate Inverse Document Frequency (IDF)\n    numarticles = len(listofarticles)\n    InverseDocumentFreq = {}\n    for w in masterword_dictionary.keys():\n        if masterword_dictionary[w] > 0:\n            InverseDocumentFreq[w] = math.log(numarticles / masterword_dictionary[w])\n        else:\n            InverseDocumentFreq[w] = 1\n    \n    # Weight the word counts using IDF\n    for row in range(len(wordmatrix)):\n        for col in range(len(wordmatrix[row])):\n            word_col = masterword_list[col]\n            wordmatrix[row][col] = wordmatrix[row][col] * InverseDocumentFreq[word_col]\n        wordmatrix[row] = normalize(wordmatrix[row])\n    \n    # Create the masterword vector\n    masterword_vec = []\n    for word in masterword_list:\n        masterword_vec.append(masterword_dictionary[word] * InverseDocumentFreq[word])\n    masterword_vec = normalize(masterword_vec)\n    \n    # Calculate distances between masterword_vec and rows in wordmatrix\n    distance = []\n    for i in range(numarticles):\n        distance.append(vector_distance(masterword_vec, wordmatrix[i][:]))\n    \n    # Find the closest article(s)\n    closest_article_score = min(distance)\n    closest_articles = [listofarticles[index] for index, score in enumerate(distance) if score == closest_article_score]\n    \n    # Return the closest articles\n    return {\"closest_articles\": closest_articles}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random user string with some words\n    words = ['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew', 'kiwi', 'lemon']\n    userstring = ' '.join(random.choices(words, k=random.randint(3, 8)))\n    \n    # Generate a list of article titles (simulated filenames)\n    num_articles = random.randint(2, 5)\n    listofarticles = []\n    for _ in range(num_articles):\n        title_words = random.choices(words, k=random.randint(2, 6))\n        title = ' '.join(title_words)\n        # Randomly add some punctuation\n        if random.random() > 0.5:\n            title += random.choice(['.', '!', '?'])\n        listofarticles.append(title)\n    listofarticles = ','.join(listofarticles)\n    \n    return {\n        'userstring': userstring,\n        'listofarticles': listofarticles\n    }", "io_pairs": [{"input": {"userstring": "cherry banana date", "listofarticles": "kiwi grape kiwi lemon honeydew!,kiwi lemon lemon apple,cherry date kiwi."}, "output": {"closest_articles": ["cherry date kiwi."]}}, {"input": {"userstring": "banana lemon lemon grape", "listofarticles": "date banana!,honeydew elderberry elderberry,cherry apple kiwi,apple cherry elderberry!"}, "output": {"closest_articles": ["date banana!"]}}, {"input": {"userstring": "apple kiwi lemon cherry", "listofarticles": "apple fig elderberry grape fig fig,honeydew honeydew?,banana kiwi grape fig date elderberry!"}, "output": {"closest_articles": ["apple fig elderberry grape fig fig", "banana kiwi grape fig date elderberry!"]}}, {"input": {"userstring": "cherry date honeydew lemon fig fig", "listofarticles": "grape kiwi grape grape fig apple,date grape,elderberry date date!,honeydew fig cherry cherry date."}, "output": {"closest_articles": ["honeydew fig cherry cherry date."]}}, {"input": {"userstring": "date elderberry cherry elderberry apple", "listofarticles": "elderberry date!,banana cherry kiwi banana date."}, "output": {"closest_articles": ["elderberry date!", "banana cherry kiwi banana date."]}}, {"input": {"userstring": "cherry apple banana elderberry lemon grape apple grape", "listofarticles": "lemon grape lemon apple lemon.,kiwi fig fig date banana?,elderberry cherry kiwi date lemon fig!"}, "output": {"closest_articles": ["lemon grape lemon apple lemon."]}}, {"input": {"userstring": "grape honeydew lemon lemon cherry honeydew banana", "listofarticles": "kiwi apple date kiwi banana grape.,lemon apple date date!"}, "output": {"closest_articles": ["kiwi apple date kiwi banana grape."]}}, {"input": {"userstring": "banana fig apple", "listofarticles": "honeydew apple elderberry!,lemon cherry banana"}, "output": {"closest_articles": ["honeydew apple elderberry!", "lemon cherry banana"]}}, {"input": {"userstring": "honeydew fig date honeydew lemon fig", "listofarticles": "fig grape grape elderberry honeydew,grape elderberry"}, "output": {"closest_articles": ["fig grape grape elderberry honeydew"]}}, {"input": {"userstring": "cherry banana grape", "listofarticles": "honeydew grape honeydew kiwi elderberry?,apple lemon,fig cherry elderberry lemon grape"}, "output": {"closest_articles": ["fig cherry elderberry lemon grape"]}}], "error_log": []}
{"context": "Given a range of even numbers starting from a lower limit (which is at least 4) to an upper limit, what are the prime number pairs that sum up to each even number within this range, according to Goldbach's Conjecture?\n\nThe input and output requirements are as follows:\n\nInput:\n  `lower_limit` (int): The lower limit of the range of even numbers (greater than or equal to 4).\n  `upper_limit` (int): The upper limit of the range of even numbers (greater than `lower_limit`).\n\nOutput:\n  `return` (str): A string containing the Goldbach's Conjecture representations for each even number in the range, formatted as \"number = prime1 + prime2\".", "reference_code": "# import necessary packages\nimport random\n\n# determine if a number is prime\ndef is_prime(num):\n    if num == 1:\n        return False\n    for i in range(2, num // 2 + 1):\n        if num % i == 0:\n            return False\n    return True\n\n# find all prime summations in the given range\ndef find_goldmans(start, end):\n    results = []\n    for i in range(start, end + 1, 2):\n        results.append(str(i))\n        for j in range(2, i // 2 + 1):\n            if is_prime(j) and is_prime(i - j):\n                results.append(\"=\")\n                results.append(str(j))\n                results.append(\"+\")\n                results.append(str(i - j))\n        results = [' {0} '.format(elem) for elem in results]\n        results.append(\"\\n\")\n    return ''.join(results).strip()\n\n# main function\ndef main_solution(lower_limit, upper_limit):\n    # all input arguments of the main_solution function should be json serializable\n    # return, the returned value must be json serializable\n    return find_goldmans(lower_limit, upper_limit)", "input_generator": "import random\n\ndef input_generator():\n    lower_limit = random.randint(2, 100) * 2  # Ensure it's even\n    upper_limit = lower_limit + random.randint(2, 20) * 2  # Ensure it's even and larger than lower_limit\n    return {'lower_limit': lower_limit, 'upper_limit': upper_limit}", "io_pairs": [{"input": {"lower_limit": 4, "upper_limit": 8}, "output": "4      =      2      +      2     \n    6    =    3    +    3   \n  8  =  3  +  5"}, {"input": {"lower_limit": 6, "upper_limit": 10}, "output": "6      =      3      +      3     \n    8    =    3    +    5   \n  10  =  3  +  7  =  5  +  5"}], "error_log": []}
{"context": "Given a set of x-values and their corresponding function values, what is the approximated value of the function at a specific point `x` using the Newton Forward Difference Method?\n\nThe input and output requirements are as follows:\n\nInput:\n  `X` (list of floats): List of x-values used for interpolation.\n  `fX` (list of floats): List of corresponding function values at the x-values.\n  `x` (float): The point at which the function value is to be approximated.\n\nOutput:\n  `return` (float): The approximated value of the function at the point `x`, rounded to 10 decimal places.", "reference_code": "# import necessary packages\nimport numpy as np\nimport math\n\n# all class and function definitions in the code file, if any\ndef DiffArray(A):\n    ans = []\n    for i in range(1, len(A)):\n        ans.append(A[i]-A[i-1])\n    return ans\n\ndef NewtonForwardDiffMethod(X, fX, x):\n    A = fX\n    factorial = 1\n    ans = 0\n    for i in range(len(X)):\n        if i == 0:\n            ans += A[0]\n        else:\n            factorial *= i\n            cur = 1\n            for j in range(i):\n                cur *= (x - X[j])\n            cur /= pow(X[1] - X[0], i)\n            cur /= factorial\n            cur *= A[0]\n            ans += cur\n        A = DiffArray(A)\n    return ans\n\n# main function\ndef main_solution(X, fX, x):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert JSON serializable inputs to the original input variables if necessary\n    X = list(X)\n    fX = list(fX)\n    \n    # Call the core function to solve the problem\n    result = NewtonForwardDiffMethod(X, fX, x)\n    \n    # Convert the result to a JSON serializable output\n    return round(result, 10)", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    # Generate a random number of points (between 3 and 10)\n    n = random.randint(3, 10)\n    \n    # Generate random X values, sorted and with reasonable spacing\n    X = sorted([round(random.uniform(0, 10), 2) for _ in range(n)])\n    \n    # Generate corresponding fX values, ensuring some variability\n    fX = [round(random.uniform(-10, 10), 2) for _ in range(n)]\n    \n    # Generate a random x value within the range of X, or slightly outside\n    if random.random() < 0.8:\n        # Within range\n        x = round(random.uniform(min(X), max(X)), 2)\n    else:\n        # Outside range\n        x = round(random.uniform(min(X) - 2, max(X) + 2), 2)\n    \n    return {\n        'X': X,\n        'fX': fX,\n        'x': round(random.uniform(min(X), max(X)), 2)\n    }", "io_pairs": [{"input": {"X": [0.58, 2.36, 7.64, 8.37, 9.77], "fX": [4.05, -7.45, -5.62, 1.9, 4.36], "x": 4.73}, "output": 3.0452776673}, {"input": {"X": [0.61, 5.53, 6.87, 7.16, 9.75, 9.75], "fX": [-7.84, -5.45, -5.87, 6.23, -5.18, 6.8], "x": 1.39}, "output": -6.1897611704}, {"input": {"X": [2.19, 3.14, 4.71, 8.21], "fX": [3.31, -4.24, 4.8, -2.06], "x": 5.24}, "output": 16.4998559557}, {"input": {"X": [0.1, 0.31, 1.86, 2.47, 2.88, 4.33, 7.57], "fX": [7.39, 6.85, 0.49, 9.28, -6.26, 5.54, 3.4], "x": 4.5}, "output": 236376.7329148791}, {"input": {"X": [1.39, 4.55, 6.24, 9.39], "fX": [8.58, 2.19, 4.75, 2.91], "x": 8.86}, "output": 1.9549193798}, {"input": {"X": [1.55, 4.02, 5.4, 6.54, 6.55, 6.76], "fX": [8.38, -2.07, -5.96, -1.69, -1.64, 8.07], "x": 1.83}, "output": 7.2433238678}, {"input": {"X": [4.92, 6.42, 7.63, 8.78], "fX": [-6.02, -5.81, -1.7, -6.78], "x": 7.87}, "output": -2.5634478519}, {"input": {"X": [2.47, 4.24, 4.33, 4.4, 6.31, 6.43, 7.74, 9.88], "fX": [-6.79, 4.66, 8.77, -1.49, -4.43, 1.84, -6.12, -6.07], "x": 8.96}, "output": 17.3710794604}, {"input": {"X": [1.18, 7.66, 8.81], "fX": [-9.18, -4.76, -7.53], "x": 8.2}, "output": -4.7162152778}, {"input": {"X": [3.93, 4.35, 5.95, 6.09, 6.78, 8.81], "fX": [9.22, 9.63, -5.74, -1.42, -4.19, -0.06], "x": 8.21}, "output": 3091.1774299005}], "error_log": []}
{"context": "Given a sequence of elevation data, what are the indices of the peaks and valleys, and what is the highest elevation point in the data?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data` (str): A comma-separated string of integers representing the elevation data.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `peaks_valleys` (list of int): A list of indices where peaks and valleys are located.\n    - `highest_point` (int): The highest elevation point in the data.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef peaks(data):\n    peaks_list = []\n    for i in range(1, len(data) - 1):\n        if data[i] > data[i - 1] and data[i] > data[i + 1]:\n            peaks_list.append(i)\n    return peaks_list\n\ndef valley(data):\n    valley_list = []\n    for i in range(1, len(data) - 1):\n        if data[i] < data[i - 1] and data[i] < data[i + 1]:\n            valley_list.append(i)\n    return valley_list\n\ndef peaks_and_valleys(data):\n    peaks_list = peaks(data)\n    valley_list = valley(data)\n    peaks_valley = peaks_list + valley_list\n    peaks_valley.sort()\n    return peaks_valley\n\ndef find_highest_point(data):\n    highest = 0\n    for point in data:\n        if point > highest:\n            highest = point\n    return highest\n\n# main function\ndef main_solution(data):\n    # Convert input to list of integers\n    data = list(map(int, data.split(',')))\n    \n    # Find peaks and valleys\n    peaks_valleys = peaks_and_valleys(data)\n    \n    # Find the highest point\n    highest_point = find_highest_point(data)\n    \n    # Return the results as a dictionary\n    return {\n        \"peaks_valleys\": peaks_valleys,\n        \"highest_point\": highest_point\n    }", "input_generator": "import random\n\ndef input_generator():\n    length = random.randint(5, 20)\n    data = [random.randint(0, 100) for _ in range(length)]\n    # Ensure at least one peak or valley by modifying some elements\n    if length >= 3:\n        for i in range(1, length - 1):\n            if random.choice([True, False]):\n                data[i] = max(data[i-1], data[i+1]) + 1  # Ensure peak\n            else:\n                data[i] = min(data[i-1], data[i+1]) - 1  # Ensure valley\n    data_str = ','.join(map(str, data))\n    return {'data': data_str}", "io_pairs": [{"input": {"data": "75,80,40,39,36,9,23,74,57,58,57,58,36,88,66,67"}, "output": {"peaks_valleys": [1, 5, 7, 8, 9, 10, 11, 12, 13, 14], "highest_point": 88}}, {"input": {"data": "34,86,87,88,89,15,14,20"}, "output": {"peaks_valleys": [4, 6], "highest_point": 89}}, {"input": {"data": "82,83,84,85,1,88,74,75,76,82,83,84,69,70"}, "output": {"peaks_valleys": [3, 4, 5, 6, 11, 12], "highest_point": 88}}, {"input": {"data": "84,38,37,76,77,78,59,60"}, "output": {"peaks_valleys": [2, 5, 6], "highest_point": 84}}, {"input": {"data": "79,80,18,53,52,31,34,35,38,39,35"}, "output": {"peaks_valleys": [1, 2, 3, 5, 9], "highest_point": 80}}, {"input": {"data": "57,55,35,11,5,4,3,2,56,57,58,31,30,63"}, "output": {"peaks_valleys": [7, 10, 12], "highest_point": 63}}, {"input": {"data": "6,34,33,34,33,32,31,3,4,74,75,76,72,73,11,12"}, "output": {"peaks_valleys": [1, 2, 3, 7, 11, 12, 13, 14], "highest_point": 76}}, {"input": {"data": "36,96,43,8,7,6,50,49,50,9,56,55,54,85,24,23,22,91,92,42"}, "output": {"peaks_valleys": [1, 5, 6, 7, 8, 9, 10, 12, 13, 16, 18], "highest_point": 96}}, {"input": {"data": "98,80,75,53,52,53,54,14,13,12,11,10,21,86,87,88,30,31"}, "output": {"peaks_valleys": [4, 6, 11, 15, 16], "highest_point": 98}}, {"input": {"data": "40,46,61,93,56,57,56,6,5,59"}, "output": {"peaks_valleys": [3, 4, 5, 8], "highest_point": 93}}], "error_log": []}
{"context": "Given two wires that are laid out on a grid, each wire follows a specific path defined by a series of movements. Each movement is described by a direction (right, left, up, down) and a number of steps. The wires can intersect at certain points. What is the minimum Manhattan distance from the origin to any intersection point of the two wires?\n\nThe input and output requirements are as follows:\n\nInput:\n  `wire_1` (str): A string representing the path of the first wire. Each movement is separated by a comma. Each movement is in the format of a direction (R, L, U, D) followed by a number of steps.\n  `wire_2` (str): A string representing the path of the second wire. Each movement is separated by a comma. Each movement is in the format of a direction (R, L, U, D) followed by a number of steps.\n\nOutput:\n  `return` (int or None): The minimum Manhattan distance from the origin to any intersection point of the two wires. If no intersection points are found, it returns `None`.", "reference_code": "# import necessary packages\nfrom collections import namedtuple\nimport random\n\n# all class and function definitions in the code file, if any\nPoint = namedtuple('Point', 'x y')\n\nclass Line:\n    def __init__(self, start, end):\n        self.start = Point(*start)\n        self.end = Point(*end)\n        if self.start.x == self.end.x:\n            step = 1 if self.end.y > self.start.y else -1\n            self.points = [\n                Point(self.start.x, y) for y in\n                range(self.start.y, self.end.y + step, step)\n            ]\n        else:\n            step = 1 if self.end.x > self.start.x else -1\n            self.points = [\n                Point(x, self.start.y) for x in\n                range(self.start.x, self.end.x + step, step)\n            ]\n        self.steps = len(self.points)\n\n    def intersect(self, line):\n        p = set(self.points) & set(line.points)\n        if p:\n            return p.pop()\n        raise ValueError('Lines do not intersect.')\n\ndef manhattan(point):\n    return abs(point.x) + abs(point.y)\n\ndef collect_lines(wire):\n    pos = [0, 0]\n    lines = []\n    for item in wire:\n        start = pos[:]\n        direction = item[0]\n        steps = int(item[1:])\n        if direction == 'R':\n            pos[0] += steps\n        elif direction == 'L':\n            pos[0] -= steps\n        elif direction == 'U':\n            pos[1] += steps\n        elif direction == 'D':\n            pos[1] -= steps\n        else:\n            raise ValueError(f'Unknown direction: {direction}')\n        lines.append(Line(start, pos[:]))\n    return lines\n\n# main function\ndef main_solution(wire_1, wire_2):\n    # Convert JSON serializable inputs to original input variables\n    wire_1 = wire_1.split(',')\n    wire_2 = wire_2.split(',')\n    \n    # Collect lines for both wires\n    lines_1 = collect_lines(wire_1)\n    lines_2 = collect_lines(wire_2)\n    \n    # Find intersection points\n    points = []\n    for line in lines_1[1:]:\n        for l in lines_2[1:]:\n            try:\n                point = line.intersect(l)\n                points.append(point)\n            except ValueError:\n                pass\n    \n    # Calculate Manhattan distances and find the minimum\n    if points:\n        min_distance = min(map(manhattan, points))\n    else:\n        min_distance = None\n    \n    # Return the minimum distance as JSON serializable output\n    return min_distance", "input_generator": "import random\nimport string\n\ndef input_generator():\n    directions = ['R', 'L', 'U', 'D']\n    wire_length = random.randint(5, 20)\n    \n    def generate_wire():\n        wire = []\n        pos = [0, 0]\n        for _ in range(wire_length):\n            direction = random.choice(directions)\n            steps = random.randint(1, 10)\n            wire.append(f\"{direction}{steps}\")\n        return ','.join(wire)\n    \n    wire_1 = generate_wire()\n    wire_2 = generate_wire()\n    \n    return {'wire_1': wire_1, 'wire_2': wire_2}", "io_pairs": [{"input": {"wire_1": "D9,R9,R6,R10,L4,U1", "wire_2": "D3,D5,U3,D9,R3,L8"}, "output": 9}, {"input": {"wire_1": "D5,R8,R6,R5,R2,R4,U2,U6,L5,R9,U5,U3,U10,L10,D4,L1,U3,D9,L1,R8", "wire_2": "L6,R10,U5,U6,R4,D10,U2,R7,R10,D1,L9,R7,L7,L1,U3,D6,R3,R9,L3,U4"}, "output": 26}, {"input": {"wire_1": "D8,U3,U1,U5,U1,D3,D2,R1,L8,U5,U9,R10,U9,R2", "wire_2": "U5,U7,R7,R3,L4,U9,U8,L7,R1,R5,U2,D8,L9,L4"}, "output": 11}, {"input": {"wire_1": "D4,R10,D3,L5,L10,L8,L2,L3,U10,L7,D3,L1,U2,R3,R3,U2,U8,D6,D1,L9", "wire_2": "L8,L6,D4,R2,U3,D4,D2,L3,D9,D9,D8,D4,R5,R2,U4,L1,D9,R3,U8,U4"}, "output": 19}, {"input": {"wire_1": "U2,R2,U10,D1,U5,D2,D8", "wire_2": "U7,U4,R10,D3,U9,L3,D1"}, "output": 13}, {"input": {"wire_1": "D1,U1,D10,L9,U4,D3,R10,R1,U1,R8,L2,D2,U1,U9,U6,L7,L7,L5,U8", "wire_2": "U2,L9,L8,U7,R4,D7,R3,D4,U4,D3,R9,R8,U10,D6,R10,R6,R9,U6,L10"}, "output": 1}, {"input": {"wire_1": "R5,R1,L7,L8,U6,L6,U5,R9,D10,L5,D4", "wire_2": "R1,R8,R1,D5,R4,R2,L5,D5,L10,R5,U7"}, "output": 4}, {"input": {"wire_1": "R5,D8,R2,L9,U2", "wire_2": "D8,U10,L5,R4,L1"}, "output": 8}, {"input": {"wire_1": "R9,R2,R6,R4,R8,L2,R10,L2,D10,L7,L3,L2,L6,U8,R7,R1", "wire_2": "D1,R8,U9,U3,D7,R8,U7,D4,R2,D2,U1,D1,D10,U1,D3,U2"}, "output": 18}, {"input": {"wire_1": "D4,D8,L8,U10,D2,U5,D5,U3,R4,L10,R9,U4,U10,D2,U3,D10,L2,D9,D6", "wire_2": "D7,R4,U5,L3,U7,U8,U7,U1,R9,U9,L1,U10,D9,L9,D7,D3,L1,R1,R8"}, "output": 7}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, what is the optimal move for player 'O' given the current state of the board and the depth parameters for both players? The board is represented by a grid of size `n x n`, and the current state of the board is provided. The depth parameters `d1` and `d2` determine the depth of the search for player 'X' and player 'O', respectively. The goal is to find the best move for player 'O' based on the minimax algorithm, which evaluates the board state and returns the value and coordinates of the optimal move.\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the Tic-Tac-Toe board (n x n).\n  `d1` (int): Depth parameter for player 'X'.\n  `d2` (int): Depth parameter for player 'O'.\n  `current_state` (list of lists of str): The current state of the Tic-Tac-Toe board, where each element is either '.', 'X', or 'O'.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `value` (int): The value of the best move according to the minimax algorithm.\n    - `x` (int): The x-coordinate of the best move.\n    - `y` (int): The y-coordinate of the best move.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass TicTacToe:\n    def __init__(self, n, d1, d2):\n        self.n = n\n        self.d1 = d1\n        self.d2 = d2\n        self.current_state = [['.' for _ in range(n)] for _ in range(n)]\n\n    def is_end(self):\n        # Check if the game has ended (win, lose, or draw)\n        # This is a placeholder implementation\n        return None\n\n    def simpleHeuristic(self):\n        # Placeholder for simple heuristic\n        return 0\n\n    def sophisticatedHeuristic(self):\n        # Placeholder for sophisticated heuristic\n        return 0\n\n    def minimax(self, max=False):\n        value = 2\n        if max:\n            value = -2\n        x = None\n        y = None\n        result = self.is_end()\n        if result == 'X':\n            return (-1, x, y)\n        elif result == 'O':\n            return (1, x, y)\n        elif result == '.':\n            return (0, x, y)\n        if self.d1 == 0:\n            return (self.simpleHeuristic(), x, y)\n        else:\n            return (self.sophisticatedHeuristic(), x, y)\n        if self.d2 == 0:\n            return (self.simpleHeuristic(), x, y)\n        else:\n            return (self.sophisticatedHeuristic(), x, y)\n\n        for i in range(self.n):\n            for j in range(self.n):\n                if self.current_state[i][j] == '.':\n                    if max:\n                        self.current_state[i][j] = 'O'\n                        (v, _, _) = self.minimax(max=False)\n                        if v > value:\n                            value = v\n                            x = i\n                            y = j\n                    else:\n                        self.current_state[i][j] = 'X'\n                        (v, _, _) = self.minimax(max=False)\n                        if v < value:\n                            value = v\n                            x = i\n                            y = j\n                    self.current_state[i][j] = '.'\n        return (value, x, y)\n\n# main function\ndef main_solution(n, d1, d2, current_state):\n    # Convert JSON serializable inputs to the original input variables\n    game = TicTacToe(n, d1, d2)\n    game.current_state = current_state\n\n    # Call the minimax function\n    (value, x, y) = game.minimax(max=True)\n\n    # Convert the output to JSON serializable format\n    return {\"value\": value, \"x\": x, \"y\": y}", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(3, 5)  # Reasonable board size between 3x3 and 5x5\n    d1 = random.randint(0, 1)\n    d2 = random.randint(0, 1)\n    \n    # Generate a random current state with some moves already made\n    current_state = []\n    symbols = ['X', 'O', '.']\n    for _ in range(n):\n        row = []\n        for _ in range(n):\n            row.append(random.choice(symbols))\n        current_state.append(row)\n    \n    return {\n        'n': n,\n        'd1': d1,\n        'd2': d2,\n        'current_state': current_state\n    }", "io_pairs": [{"input": {"n": 3, "d1": 0, "d2": 0, "current_state": [["X", "X", "O"], ["O", "X", "."], ["O", ".", "."]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 1, "d2": 1, "current_state": [[".", "O", "X"], ["X", "X", "."], [".", ".", "X"]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 1, "d2": 1, "current_state": [["O", "O", "."], ["O", "X", "."], ["X", "O", "O"]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 0, "d2": 1, "current_state": [["X", ".", "."], [".", "X", "."], [".", "X", "."]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 0, "d2": 0, "current_state": [["O", "O", "X"], ["X", ".", "X"], ["O", "X", "X"]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 0, "d2": 0, "current_state": [["O", ".", "."], ["X", ".", "X"], [".", ".", "X"]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 0, "d2": 0, "current_state": [["O", ".", "."], ["O", ".", "O"], ["X", "O", "."]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 0, "d2": 0, "current_state": [["O", "O", "O"], ["X", ".", "O"], [".", ".", "."]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 0, "d2": 0, "current_state": [["O", "O", "X"], ["X", "O", "O"], ["O", "X", "X"]]}, "output": {"value": 0, "x": null, "y": null}}, {"input": {"n": 3, "d1": 1, "d2": 1, "current_state": [["X", "O", "X"], ["O", ".", "."], ["O", "O", "O"]]}, "output": {"value": 0, "x": null, "y": null}}], "error_log": []}
{"context": "Given a point in 3D space and a vector originating from this point, how would the vector be reflected when it encounters a surface with a given normal vector? Specifically, what are the coordinates of the reflected vector?\n\nThe input and output requirements are as follows:\n\nInput:\n  `point_coords` (list of float): A list containing the x, y, and z coordinates of a point in 3D space.\n  `vector_coords` (list of float): A list containing the x, y, and z coordinates of a vector in 3D space.\n  `normal_coords` (list of float): A list containing the x, y, and z coordinates of the normal vector in 3D space.\n\nOutput:\n  `return` (list of float): A list containing the x, y, and z coordinates of the reflected vector in 3D space.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Tuple(tuple):\n    def __new__(self, x, y, z, w):\n        return tuple.__new__(Tuple, (x, y, z, w))\n\n    @staticmethod\n    def Point(x, y, z):\n        return Tuple(x, y, z, 1.0)\n\n    @staticmethod\n    def Vector(x, y, z):\n        return Tuple(x, y, z, 0.0)\n\n    @staticmethod\n    def is_point(t):\n        return isinstance(t, Tuple) and len(t) == 4 and t[3] == 1.0\n\n    @staticmethod\n    def is_vector(t):\n        return isinstance(t, Tuple) and len(t) == 4 and t[3] == 0.0\n\n    def __add__(self, other):\n        return Tuple(self.x + other.x, self.y + other.y, self.z + other.z, self.w + other.w)\n\n    def __sub__(self, other):\n        return Tuple(self.x - other.x, self.y - other.y, self.z - other.z, self.w - other.w)\n\n    def __neg__(self):\n        return Tuple(-self.x, -self.y, -self.z, -self.w)\n\n    def __mul__(self, other):\n        return Tuple(self.x * other, self.y * other, self.z * other, self.w * other)\n\n    def __truediv__(self, other):\n        return Tuple(self.x / other, self.y / other, self.z / other, self.w / other)\n\n    def __div__(self, other):\n        return Tuple(self.x / other, self.y / other, self.z / other, self.w / other)\n\n    def mag(self):\n        return math.sqrt(sum(_ * _ for _ in self[:3]))\n\n    def norm(self):\n        return self / self.mag()\n\n    def dot(self, other):\n        return sum([a * b for a, b in zip(self, other)])\n\n    def cross(self, other):\n        assert self.w == 0 and other.w == 0\n        a, b = self, other\n        return Tuple(\n            a.y * b.z - a.z * b.y,\n            a.z * b.x - a.x * b.z,\n            a.x * b.y - a.y * b.x,\n            0.0,\n            )\n\n    @property\n    def x(self):\n        return self[0]\n\n    @property\n    def y(self):\n        return self[1]\n\n    @property\n    def z(self):\n        return self[2]\n\n    @property\n    def w(self):\n        return self[3]\n\n    def reflect(self, normal):\n        return self - normal * 2 * self.dot(normal)\n\n# create aliases so we don't need to prefix with Tuple everywhere\nPoint = Tuple.Point\nVector = Tuple.Vector\n\n# main function\ndef main_solution(point_coords, vector_coords, normal_coords):\n    # Convert JSON serializable inputs to original input variables\n    point = Point(*point_coords)\n    vector = Vector(*vector_coords)\n    normal = Vector(*normal_coords)\n    \n    # Perform the reflection operation\n    reflected_vector = vector.reflect(normal)\n    \n    # Convert the result to JSON serializable output\n    reflected_vector_coords = (reflected_vector.x, reflected_vector.y, reflected_vector.z)\n    \n    return reflected_vector_coords", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random point coordinates (x, y, z)\n    point_coords = (\n        random.uniform(-10.0, 10.0),\n        random.uniform(-10.0, 10.0),\n        random.uniform(-10.0, 10.0)\n    )\n    \n    # Generate random vector coordinates (x, y, z)\n    vector_coords = (\n        random.uniform(-5.0, 5.0),\n        random.uniform(-5.0, 5.0),\n        random.uniform(-5.0, 5.0)\n    )\n    \n    # Generate random normal vector coordinates (x, y, z) and normalize it\n    normal_x = random.uniform(-1.0, 1.0)\n    normal_y = random.uniform(-1.0, 1.0)\n    normal_z = random.uniform(-1.0, 1.0)\n    magnitude = math.sqrt(normal_x**2 + normal_y**2 + normal_z**2)\n    normal_coords = (\n        normal_x / magnitude,\n        normal_y / magnitude,\n        normal_z / magnitude\n    )\n    \n    return {\n        'point_coords': point_coords,\n        'vector_coords': vector_coords,\n        'normal_coords': normal_coords\n    }", "io_pairs": [{"input": {"point_coords": [-3.1893917993588854, 0.866227852023103, 6.202992069192717], "vector_coords": [-4.058828127059008, 0.8861127450719142, -2.2985044150871357], "normal_coords": [-0.05459189300754256, 0.31223642575313704, -0.9484345732051098]}, "output": [-3.7664080889007505, -0.7863734521096954, 2.7817604156072377]}, {"input": {"point_coords": [6.203530131554647, 7.536763772743946, -3.685245325168916], "vector_coords": [-2.469927108840262, -2.2808852535892843, 1.170874457900542], "normal_coords": [0.6387453009637698, -0.5088094694058781, -0.5771632042495536]}, "output": [-1.0737525548605875, -3.393045034548175, -0.09069345978235788]}, {"input": {"point_coords": [6.828838864668381, -5.945935705738652, 0.6028770307680009], "vector_coords": [2.973169101091244, 4.349160831548405, -4.466009321838477], "normal_coords": [-0.7485694100789659, -0.2376440701508348, 0.619006570414381]}, "output": [-6.045093363858641, 1.4861843740504779, 2.9913669005434818]}, {"input": {"point_coords": [0.0262013512203616, 5.780913060576459, 2.395378063434258], "vector_coords": [-4.354095376193376, -0.3332197294912138, -4.440243888050993], "normal_coords": [0.7509367864736485, 0.6288217317327827, 0.20168582602953133]}, "output": [2.216181661918392, 5.168618853315465, -2.675605671434693]}, {"input": {"point_coords": [-8.636043998931369, -8.589458277986664, -6.4695591706091555], "vector_coords": [-1.3457738881237304, -1.2888020058012706, 3.422600818912221], "normal_coords": [-0.7036626654626942, -0.33039981985397326, 0.6290427745983564]}, "output": [3.6161077702876314, 1.041014377163791, -1.0130982153450612]}, {"input": {"point_coords": [2.4035460718394965, -9.23952948598975, -4.865390568817358], "vector_coords": [1.36459420403048, -2.8997754114807717, -1.7643201812616995], "normal_coords": [-0.392050544080395, -0.07250030431645293, -0.9170823718512356]}, "output": [2.378649901245999, -2.7122502371071278, 0.6077530578484183]}, {"input": {"point_coords": [-8.644553735277116, 7.198478688854124, 2.399037632934462], "vector_coords": [1.9313976408550033, -3.0303853548833724, 3.9353245799893717], "normal_coords": [-0.8749607939601384, -0.4401678284384354, 0.20173222806591087]}, "output": [2.697623073041865, -2.644919186675431, 3.7586625344407762]}, {"input": {"point_coords": [6.439264841518039, 6.14178443937103, 5.764013471880203], "vector_coords": [2.6198521666784744, -0.6897378789447215, -2.9137743323093046], "normal_coords": [-0.045116924601320815, 0.9925341230411824, 0.1133158316979127]}, "output": [2.5176203903807215, 1.559274599881503, -2.6570086316437127]}, {"input": {"point_coords": [9.111963516015841, -5.558962200826246, 3.747589567411273], "vector_coords": [-3.474463887955431, 4.876464385186077, 2.709940417814332], "normal_coords": [0.18174468011588418, -0.6042305373301047, -0.7758056000103041]}, "output": [-1.4097131111009262, -1.9880307436730567, -6.103771291865318]}, {"input": {"point_coords": [3.0205856006673937, -7.242098170418984, -9.33718414300914], "vector_coords": [0.12868985352221785, -2.1358130126141592, 3.7983733458453948], "normal_coords": [-0.29379366318987776, -0.677996395938732, -0.673799800061979]}, "output": [-0.5464937807632336, -3.693954415910848, 2.2498763740348338]}], "error_log": []}
{"context": "In a drone network, each drone is connected to other drones through direct friendships. Given a list of these direct connections and the names of two drones, determine if there is any indirect connection between them through a series of mutual friends. For example, if drone A is friends with drone B, and drone B is friends with drone C, then drone A and drone C are indirectly connected. How can we determine if two given drones are connected through any series of mutual friends?\n\nThe input and output requirements are as follows:\n\nInput:\n  `network` (list of strings): A list of strings where each string represents a connection between two drones in the format \"drone1-drone2\".\n  `first` (string): The name of the first drone to check for a connection.\n  `second` (string): The name of the second drone to check for a connection.\n\nOutput:\n  `return` (boolean): `True` if there is a connection between the two drones through any depth of common friends, otherwise `False`.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(network, first, second):\n    # Convert the network tuple of strings into a dictionary for easier traversal\n    d = dict()\n    for connection in network:\n        tmp1, tmp2 = connection.split('-')\n        d.setdefault(tmp1, []).append(tmp2)\n        d.setdefault(tmp2, []).append(tmp1)\n    \n    # Initialize the BFS queue and visited list\n    future = [first]\n    visited = []\n    \n    # Perform BFS to check if there's a path from first to second\n    while len(future):\n        top = future.pop()\n        visited.append(top)\n        if top == second:\n            return True\n        for next in d.setdefault(top, []):\n            if next not in visited and next not in future:\n                future.append(next)\n    \n    return False", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random number of nodes (between 5 and 15)\n    num_nodes = random.randint(5, 15)\n    nodes = []\n    for _ in range(num_nodes):\n        # Generate random node names (e.g., 'A', 'B', ... or 'Node1', 'Node2', ...)\n        if random.choice([True, False]):\n            node = random.choice(string.ascii_uppercase)\n        else:\n            node = 'Node' + str(random.randint(1, 50))\n        nodes.append(node)\n    \n    # Ensure unique nodes\n    nodes = list(set(nodes))\n    num_nodes = len(nodes)\n    \n    # Generate random connections\n    network = []\n    max_connections = min(num_nodes * (num_nodes - 1) // 2, 20)  # Limit to 20 connections max\n    num_connections = random.randint(num_nodes - 1, max_connections)  # Ensure at least a spanning tree\n    \n    # First create a spanning tree to ensure connectivity\n    connected = [nodes[0]]\n    remaining = nodes[1:]\n    while remaining:\n        a = random.choice(connected)\n        b = random.choice(remaining)\n        network.append(f\"{a}-{b}\")\n        connected.append(b)\n        remaining.remove(b)\n    \n    # Add additional random connections\n    possible_connections = []\n    for i in range(num_nodes):\n        for j in range(i + 1, num_nodes):\n            a, b = nodes[i], nodes[j]\n            if f\"{a}-{b}\" not in network and f\"{b}-{a}\" not in network:\n                possible_connections.append((a, b))\n    \n    random.shuffle(possible_connections)\n    for _ in range(num_connections - (num_nodes - 1)):\n        if not possible_connections:\n            break\n        a, b = possible_connections.pop()\n        network.append(f\"{a}-{b}\")\n    \n    # Randomly choose first and second nodes\n    first, second = random.sample(nodes, 2)\n    \n    return {\n        'network': tuple(network),\n        'first': first,\n        'second': second\n    }", "io_pairs": [{"input": {"network": ["Node21-Node11", "Node11-Node28", "Node28-G", "Node11-Node40"], "first": "Node28", "second": "Node11"}, "output": true}, {"input": {"network": ["K-V", "V-L", "L-Y", "L-Node46", "V-C", "Y-Node17", "K-L"], "first": "C", "second": "Node46"}, "output": true}, {"input": {"network": ["Node43-Q", "Node43-Y", "Node43-I"], "first": "I", "second": "Q"}, "output": true}, {"input": {"network": ["Node13-Node28", "Node28-Node5", "Node5-Node20", "Node28-Node26", "Node26-Node5", "Node13-Node26", "Node13-Node5"], "first": "Node26", "second": "Node20"}, "output": true}, {"input": {"network": ["Node43-Node40", "Node40-Node13", "Node43-S", "Node40-I", "I-T", "Node43-Node23"], "first": "Node43", "second": "Node13"}, "output": true}, {"input": {"network": ["V-S", "V-Node48", "V-Node23", "Node48-C", "Node23-D", "D-Node48", "C-S"], "first": "V", "second": "D"}, "output": true}, {"input": {"network": ["J-W", "W-Node34", "Node34-Q"], "first": "Node34", "second": "J"}, "output": true}, {"input": {"network": ["Node8-Node35", "Node35-W", "Node35-O", "O-X", "Node8-X", "O-W", "X-W"], "first": "Node8", "second": "O"}, "output": true}, {"input": {"network": ["A-Node6", "A-Node1", "Node1-D", "Node1-Node6", "A-D"], "first": "D", "second": "Node6"}, "output": true}, {"input": {"network": ["Node24-Q", "Node24-R", "Q-S", "Node24-Z", "Z-Node32", "Node24-Node50"], "first": "Node32", "second": "Q"}, "output": true}], "error_log": []}
{"context": "Given a function \\( f(x, y) = x^2 y^2 + 2xy \\), what are the coordinates of the local minimum and the value of the function at this point when starting from a specific initial guess and using gradient descent with a given step size, precision, and maximum number of iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n- `initial_guess` (list of float): A list containing the initial guess for the x and y coordinates, e.g., `[1.0, 2.0]`.\n- `alpha` (float): The step size factor for gradient descent, e.g., `0.001`.\n- `precision` (float): The precision threshold for convergence, e.g., `0.0000001`.\n- `max_iters` (int): The maximum number of iterations allowed, e.g., `100000`.\n\nOutput:\n- `return` (dict): A dictionary containing the following keys:\n  - `local_minimum` (list of float): A list containing the x and y coordinates of the local minimum found by the gradient descent algorithm.\n  - `value_at_minimum` (float): The value of the function at the local minimum.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(initial_guess, alpha, precision, max_iters):\n    # Convert JSON serializable inputs to original input variables\n    cur_xy = np.array(initial_guess)\n    \n    # Define the function and its gradients\n    f = lambda x, y: x**2 * y**2 + 2 * x * y\n    grad_fx = lambda x, y: 2 * x * y**2 + 2 * y\n    grad_fy = lambda x, y: 2 * x**2 * y + 2 * x\n    \n    previous_step_size = 1\n    iters = 0\n    \n    # Gradient descent loop\n    while previous_step_size > precision and iters < max_iters:\n        prev_xy = cur_xy\n        cur_xy = cur_xy - alpha * np.array([grad_fx(cur_xy[0], cur_xy[1]), grad_fy(cur_xy[0], cur_xy[1])])\n        previous_step_size = np.linalg.norm(cur_xy - prev_xy)\n        iters += 1\n    \n    # Convert output to JSON serializable\n    local_minimum = cur_xy.tolist()\n    value_at_minimum = f(cur_xy[0], cur_xy[1])\n    \n    return {\"local_minimum\": local_minimum, \"value_at_minimum\": value_at_minimum}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    initial_guess = [random.uniform(-5.0, 5.0), random.uniform(-5.0, 5.0)]\n    alpha = random.uniform(0.001, 0.1)\n    precision = random.choice([1e-3, 1e-4, 1e-5, 1e-6])\n    max_iters = random.randint(100, 1000)\n    return {\n        \"initial_guess\": initial_guess,\n        \"alpha\": alpha,\n        \"precision\": precision,\n        \"max_iters\": max_iters\n    }", "io_pairs": [{"input": {"initial_guess": [2.267798567496965, -3.024361303903189], "alpha": 0.01626309289994174, "precision": 0.001, "max_iters": 602}, "output": {"local_minimum": [0.5052826733240716, -2.0016043843115736], "value_at_minimum": -0.9998705862999628}}, {"input": {"initial_guess": [3.3088962567874347, 4.378842158205812], "alpha": 0.036699713049372924, "precision": 1e-05, "max_iters": 880}, "output": {"local_minimum": [-1.6635856994606804, 0.6011450609571019], "value_at_minimum": -0.9999999968273019}}, {"input": {"initial_guess": [-2.855862092058419, 1.609241469876192], "alpha": 0.07830212046095499, "precision": 0.0001, "max_iters": 652}, "output": {"local_minimum": [-1.9860862274340487, 0.5034558904642681], "value_at_minimum": -0.9999999913156559}}, {"input": {"initial_guess": [-1.0558554683183319, -2.4027484834493773], "alpha": 0.08461616498286668, "precision": 1e-05, "max_iters": 534}, "output": {"local_minimum": [0.5519052181857919, -1.8118956371145951], "value_at_minimum": -0.9999999999714516}}, {"input": {"initial_guess": [-1.19985612391998, -1.5321104486087398], "alpha": 0.014542457596001486, "precision": 0.001, "max_iters": 251}, "output": {"local_minimum": [0.8010025413371951, -1.2210345128148192], "value_at_minimum": -0.9995182742264668}}, {"input": {"initial_guess": [3.4827804711564685, 3.6254301855706768], "alpha": 0.05590340883025722, "precision": 1e-06, "max_iters": 307}, "output": {"local_minimum": [-1.2334214640530676, 0.8107497796689724], "value_at_minimum": -0.9999999999854093}}, {"input": {"initial_guess": [-2.4647249116529824, 0.34400839270630623], "alpha": 0.00755698349707275, "precision": 1e-06, "max_iters": 860}, "output": {"local_minimum": [-2.4738126550965718, 0.404224726092863], "value_at_minimum": -0.9999999994356006}}, {"input": {"initial_guess": [1.4410464953937439, 1.17202532029029], "alpha": 0.06131937492215962, "precision": 1e-06, "max_iters": 683}, "output": {"local_minimum": [1.1326500422805483, -0.8828816665089864], "value_at_minimum": -0.9999999999836532}}, {"input": {"initial_guess": [4.08808698445301, 4.811213950779669], "alpha": 0.03321371656260804, "precision": 0.0001, "max_iters": 706}, "output": {"local_minimum": [-2.351886558650526, 0.42503421927576185], "value_at_minimum": -0.9999998647726475}}, {"input": {"initial_guess": [-2.9111397677136552, -4.594984611608101], "alpha": 0.01854106759008821, "precision": 0.0001, "max_iters": 502}, "output": {"local_minimum": [0.33262147610641685, -3.0051549272585367], "value_at_minimum": -0.9999998228161111}}], "error_log": []}
{"context": "Given two integers `m` and `n`, how does the performance of Ackermann's function vary between two different implementations (Count and Ternary) when evaluated using timeit?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The first parameter for Ackermann's function.\n  `n` (int): The second parameter for Ackermann's function.\n\nOutput:\n  `return` (str): A formatted string containing the results of timing the execution of Ackermann's function using two different implementations (Count and Ternary).", "reference_code": "# import necessary packages\nimport timeit\nimport sys\nimport json\n\n# all class and function definitions in the code file, if any\ndef ack_c(m, n):\n    global COUNT\n    COUNT += 1\n    return (n + 1) if m == 0 else (ack_c(m - 1, 1) if n == 0 else ack_c(m - 1, ack_c(m, n-1)))\n\ndef ack_t(m, n):\n    \"\"\" Ackermann's Function as a Ternary in the return \"\"\"\n    return (n + 1) if m == 0 else (ack_t(m - 1, 1) if n == 0 else ack_t(m - 1, ack_t(m, n-1)))\n\ndef t_comp(ret, cases, t='r'):\n    \"\"\" ret is a reference pointer to an empty list\n    cases is a list of dicts with the timeit args \"\"\"\n    for d in cases:\n        if 'num' not in d: d['num'] = 1\n        if t == 'r':\n            if 'rep' not in d: d['rep'] = 3\n            ret.append((\n                        d['tit'],\n                        timeit.repeat(d['stat'], d['sup'], repeat=d['rep'], number=d['num'])\n                      ))\n        else:\n            ret.append((\n                        d['tit'],\n                        timeit.timeit(d['stat'], d['sup'], number=d['num'])\n                       ))\n    return None\n\ndef t_rep(ret):\n    \"\"\" Takes a list of paired (title, results) tuples and\n    formats them into a single return string. \"\"\"\n    pr = ''\n    for c in ret:\n        pr += \"Case: {1}{0:^5}{2}\\n\".format('-', c[0], c[1])\n    return pr\n\n# main function\ndef main_solution(m, n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    global COUNT\n    COUNT = 1\n    sys.setrecursionlimit(3500)\n\n    sup = \"m ,n = {}, {}; from __main__ import ack_{{}}\".format(m, n)\n    case_c = dict(tit='Count', sup=sup.format('c'), stat=\"\"\"ack_c(m, n)\"\"\")\n    case_t = dict(tit='Ternary', sup=sup.format('t'), stat=\"\"\"ack_t(m, n)\"\"\")\n\n    run_set = (case_c, case_t)\n\n    ret_set = []\n    t_comp(ret_set, run_set, 't')\n    results = t_rep(ret_set)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return results", "input_generator": "import random\n\ndef input_generator():\n    m = random.choice([0, 1, 2, 3])  # Higher values can cause stack overflow\n    n = random.randint(0, 5)\n    return {'m': m, 'n': n}", "io_pairs": [{"input": {"m": 2, "n": 2}, "output": "Case: Count  -  8.200004231184721e-06\nCase: Ternary  -  5.89998671784997e-06\n"}, {"input": {"m": 1, "n": 5}, "output": "Case: Count  -  3.500026650726795e-06\nCase: Ternary  -  2.5999615900218487e-06\n"}, {"input": {"m": 0, "n": 0}, "output": "Case: Count  -  9.00006853044033e-07\nCase: Ternary  -  8.00006091594696e-07\n"}, {"input": {"m": 1, "n": 3}, "output": "Case: Count  -  2.7999631129205227e-06\nCase: Ternary  -  2.00001522898674e-06\n"}, {"input": {"m": 1, "n": 4}, "output": "Case: Count  -  3.100023604929447e-06\nCase: Ternary  -  2.0999577827751637e-06\n"}, {"input": {"m": 1, "n": 2}, "output": "Case: Count  -  2.2999593056738377e-06\nCase: Ternary  -  1.700012944638729e-06\n"}, {"input": {"m": 2, "n": 3}, "output": "Case: Count  -  1.0100018698722124e-05\nCase: Ternary  -  6.800051778554916e-06\n"}, {"input": {"m": 3, "n": 2}, "output": "Case: Count  -  9.200000204145908e-05\nCase: Ternary  -  6.19000056758523e-05\n"}, {"input": {"m": 0, "n": 3}, "output": "Case: Count  -  9.00006853044033e-07\nCase: Ternary  -  7.00005330145359e-07\n"}, {"input": {"m": 3, "n": 1}, "output": "Case: Count  -  1.8199963960796595e-05\nCase: Ternary  -  1.2800039257854223e-05\n"}], "error_log": []}
{"context": "Given a polynomial function and an interval, what is the arc length of the function over that interval?\n\nThe input and output requirements are as follows:\n\nInput:\n  `function_str` (str): A string representing a one-variable function in SymPy syntax.\n  `variable_str` (str): A string representing the variable used in the function.\n  `lower_limit` (float): The lower limit of the interval over which to calculate the arc length.\n  `upper_limit` (float): The upper limit of the interval over which to calculate the arc length.\n\nOutput:\n  `return` (float): The arc length of the function over the specified interval, returned as a float. If the input function is invalid, returns the string \"Invalid input function\".", "reference_code": "# import necessary packages\nimport sympy\n\n# main function\ndef main_solution(function_str, variable_str, lower_limit, upper_limit):\n    # Convert the input strings to sympy expressions and symbols\n    try:\n        function_expr = sympy.sympify(function_str)\n    except sympy.SympifyError:\n        return \"Invalid input function\"\n    \n    variable_sym = sympy.Symbol(variable_str)\n    \n    # Calculate the derivative of the function\n    derivative = sympy.Derivative(function_expr, variable_sym).doit()\n    \n    # Calculate the arc length of the function between the given limits\n    length = sympy.Integral(sympy.sqrt(1 + derivative ** 2), (variable_sym, lower_limit, upper_limit)).doit().evalf()\n    \n    # Return the length as a float\n    return float(length)", "input_generator": "import random\nimport sympy\nfrom sympy.abc import x, y, z\n\ndef input_generator():\n    # List of common functions and variables\n    functions = [\n        \"x**2\",\n        \"sin(x)\",\n        \"cos(x)\",\n        \"exp(x)\",\n        \"log(x)\",\n        \"sqrt(x)\",\n        \"x**3 - 2*x + 1\",\n        \"tan(x)\",\n        \"1/x\",\n        \"x + sin(x)\"\n    ]\n    variables = ['x', 'y', 'z']\n    \n    # Randomly select a function and variable\n    function_str = random.choice(functions)\n    variable_str = random.choice(variables)\n    \n    # Generate random limits, ensuring lower < upper\n    lower_limit = random.uniform(-10, 10)\n    upper_limit = lower_limit + random.uniform(0.1, 10)\n    \n    return {\n        'function_str': function_str,\n        'variable_str': variable_str,\n        'lower_limit': lower_limit,\n        'upper_limit': upper_limit\n    }", "io_pairs": [{"input": {"function_str": "cos(x)", "variable_str": "x", "lower_limit": 2.440423320754803, "upper_limit": 3.307160548642798}, "output": 0.9166202310498978}, {"input": {"function_str": "exp(x)", "variable_str": "z", "lower_limit": -8.024456000269616, "upper_limit": -1.125283845649288}, "output": 6.899172154620328}, {"input": {"function_str": "log(x)", "variable_str": "z", "lower_limit": -0.3958750507572155, "upper_limit": 6.797225571629205}, "output": 7.193100622386421}, {"input": {"function_str": "log(x)", "variable_str": "z", "lower_limit": 8.911494580961573, "upper_limit": 18.575734865137793}, "output": 9.66424028417622}, {"input": {"function_str": "exp(x)", "variable_str": "y", "lower_limit": -7.453285257231554, "upper_limit": -6.0161975729403}, "output": 1.4370876842912548}, {"input": {"function_str": "x + sin(x)", "variable_str": "y", "lower_limit": -2.6728314024840465, "upper_limit": 3.745855211619766}, "output": 6.418686614103812}, {"input": {"function_str": "cos(x)", "variable_str": "x", "lower_limit": -1.2331954249545003, "upper_limit": 2.2027819430142155}, "output": 4.212743037469294}, {"input": {"function_str": "sin(x)", "variable_str": "y", "lower_limit": -2.387660769041842, "upper_limit": 0.4735483971136687}, "output": 2.861209166155511}, {"input": {"function_str": "sqrt(x)", "variable_str": "z", "lower_limit": -7.040348258090203, "upper_limit": -6.072345423610376}, "output": 0.9680028344798268}, {"input": {"function_str": "log(x)", "variable_str": "y", "lower_limit": -7.37905414999438, "upper_limit": -3.8306487943379945}, "output": 3.548405355656385}], "error_log": []}
{"context": "In a game of Lingo, a hidden five-character word is chosen from a predefined list. Players attempt to guess the word by providing five-letter guesses. After each guess, they receive a clue indicating which characters are correct and in the right position, and which characters are present but in the wrong position. Given a list of possible words and a player's guess, what clue should be provided to guide the player towards the correct word?\n\nThe input and output requirements are as follows:\n\nInput:\n  `words` (list of strings): A list of five-letter words from which the hidden word is chosen.\n  `guess` (string): A five-letter string representing the user's guess.\n\nOutput:\n  `return` (string): A string representing the clue for the user's guess. Characters in the correct position are enclosed in square brackets `[ ]`, and characters present but in the wrong position are enclosed in parentheses `( )`.", "reference_code": "# import necessary packages\nfrom random import randrange\n\n# main function\ndef main_solution(words, guess):\n    # Choose a word from the list randomly\n    hidden = words[randrange(0, len(words))]\n\n    # Map to build clue\n    sym_map = {0: \"%s\", 1:\"(%s)\", 2: \"[%s]\"}\n    \n    # 0: letter not present in the hidden word\n    # 1: letter present but position is wrong\n    # 2: correct letter and position\n    cenc = [(int(guess[i] == hidden[i])) + int(guess[i] in hidden) for i in range(5)] \n    \n    # Enclose the letter with appropriate symbols using sym_map\n    clue = \"\".join([sym_map[cenc[i]] % guess[i] for i in range(5)])\n    \n    # Return the clue\n    return clue", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a list of 5-letter words\n    word_list = [\n        ''.join(random.choices(string.ascii_lowercase, k=5)) \n        for _ in range(random.randint(5, 10))\n    ]\n    # Select a random guess from the word list or generate a new 5-letter word\n    if random.random() > 0.5:\n        guess = random.choice(word_list)\n    else:\n        guess = ''.join(random.choices(string.ascii_lowercase, k=5))\n    return {'words': word_list, 'guess': guess}", "io_pairs": [{"input": {"words": ["qeatg", "uhbep", "uytif", "yekag", "posqn"], "guess": "qeatg"}, "output": "q(e)atg"}, {"input": {"words": ["dxlwx", "lkrif", "pguhh", "omkmo", "nknbt"], "guess": "omkmo"}, "output": "om(k)mo"}, {"input": {"words": ["bhfmo", "odicx", "gnlqc", "zlqaq", "jmamc", "olufa", "yjqfa"], "guess": "yjqfa"}, "output": "y(j)qf(a)"}, {"input": {"words": ["octig", "duoxk", "totbo", "yjfur", "sulbc", "gvjfc"], "guess": "gvjfc"}, "output": "gvjfc"}, {"input": {"words": ["uwazf", "rmanr", "cafai", "iccca", "zmqri", "jpakt", "utgpr"], "guess": "ztyum"}, "output": "ztyum"}, {"input": {"words": ["canlj", "axrwo", "qkblo", "leong", "fejqw", "flknb"], "guess": "axrwo"}, "output": "axr(w)o"}, {"input": {"words": ["fflxj", "djamh", "etbpk", "ljzji", "yfdwf"], "guess": "rarrl"}, "output": "rarrl"}, {"input": {"words": ["rrhtz", "qrzii", "wpoxg", "qtdoj", "qfciq"], "guess": "qfciq"}, "output": "[q]fc[i](q)"}, {"input": {"words": ["bwzjy", "nuipy", "ifior", "axbkm", "iisle", "ufogf", "esfth"], "guess": "gxpvv"}, "output": "g[x]pvv"}, {"input": {"words": ["epend", "ajrcu", "hlndd", "rlvwa", "dhsqi", "wfmkj", "wqadn", "wigoy", "hxmoi"], "guess": "wigoy"}, "output": "wigoy"}], "error_log": []}
{"context": "Given the continued fraction representation of the number e, what is the sum of the digits of the numerator after performing the continued fraction calculation for a specified number of iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `iterations` (int): The number of iterations to perform in the continued fraction calculation.\n\nOutput:\n  `return` (str): A string representing the sum of the digits of the numerator after performing the continued fraction calculation for the specified number of iterations.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef e_contfrac_term(i):\n    if i == 0:\n        return 2\n    elif i % 3 == 2:\n        return i // 3 * 2 + 2\n    else:\n        return 1\n\n# main function\ndef main_solution(iterations):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    numer = 1\n    denom = 0\n    for i in reversed(range(iterations)):\n        numer, denom = e_contfrac_term(i) * numer + denom, numer\n    result = sum(int(c) for c in str(numer))\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return str(result)", "input_generator": "import random\n\ndef input_generator():\n    iterations = random.randint(5, 20)\n    return {'iterations': iterations}", "io_pairs": [{"input": {"iterations": 17}, "output": "28"}, {"input": {"iterations": 11}, "output": "12"}, {"input": {"iterations": 15}, "output": "30"}, {"input": {"iterations": 6}, "output": "15"}, {"input": {"iterations": 16}, "output": "34"}, {"input": {"iterations": 5}, "output": "10"}, {"input": {"iterations": 9}, "output": "13"}, {"input": {"iterations": 7}, "output": "7"}, {"input": {"iterations": 13}, "output": "26"}, {"input": {"iterations": 8}, "output": "13"}], "error_log": []}
{"context": "Given two matrices, what is the result of their matrix multiplication?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_a` (list of lists of ints/floats): A 2D list representing the first matrix.\n  `matrix_b` (list of lists of ints/floats): A 2D list representing the second matrix. The dimensions of `matrix_b` should be compatible with `matrix_a` for matrix multiplication.\n\nOutput:\n  `return` (list of lists of ints/floats): A 2D list representing the result of the matrix multiplication of `matrix_a` and `matrix_b`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix_a, matrix_b):\n    # Convert JSON serializable inputs to numpy arrays\n    a = np.array(matrix_a)\n    b = np.array(matrix_b)\n    \n    # Perform matrix multiplication\n    result = np.dot(a, b)\n    \n    # Convert the result to a JSON serializable output\n    return result.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the dimensions of the matrices (m x n) and (n x p)\n    m = random.randint(1, 5)\n    n = random.randint(1, 5)\n    p = random.randint(1, 5)\n    \n    # Generate random matrices with integers between -10 and 10\n    matrix_a = [[random.randint(-10, 10) for _ in range(n)] for _ in range(m)]\n    matrix_b = [[random.randint(-10, 10) for _ in range(p)] for _ in range(n)]\n    \n    return {'matrix_a': matrix_a, 'matrix_b': matrix_b}", "io_pairs": [{"input": {"matrix_a": [[1], [2]], "matrix_b": [[4]]}, "output": [[4], [8]]}, {"input": {"matrix_a": [[10], [5]], "matrix_b": [[3, -9, 6, 8]]}, "output": [[30, -90, 60, 80], [15, -45, 30, 40]]}, {"input": {"matrix_a": [[-2, 9, 2]], "matrix_b": [[-1], [5], [-2]]}, "output": [[43]]}, {"input": {"matrix_a": [[-10], [-10]], "matrix_b": [[-3, -7, 0, 9]]}, "output": [[30, 70, 0, -90], [30, 70, 0, -90]]}, {"input": {"matrix_a": [[1]], "matrix_b": [[9, -1, 0]]}, "output": [[9, -1, 0]]}, {"input": {"matrix_a": [[-7, 2]], "matrix_b": [[5], [7]]}, "output": [[-21]]}, {"input": {"matrix_a": [[6], [8], [3]], "matrix_b": [[-9, -7]]}, "output": [[-54, -42], [-72, -56], [-27, -21]]}, {"input": {"matrix_a": [[3], [5]], "matrix_b": [[7, -3, 2, -1, 0]]}, "output": [[21, -9, 6, -3, 0], [35, -15, 10, -5, 0]]}, {"input": {"matrix_a": [[-1], [-9]], "matrix_b": [[-9, 4, 9]]}, "output": [[9, -4, -9], [81, -36, -81]]}, {"input": {"matrix_a": [[-9], [-8]], "matrix_b": [[5, -6, 10, -6, 2]]}, "output": [[-45, 54, -90, 54, -18], [-40, 48, -80, 48, -16]]}], "error_log": []}
{"context": "Given two functions \\( f(t) \\) and \\( g(t) \\), where \\( f(t) = 1.1(t - 2.5)^2 \\) and \\( g(t) = 5t + 2.5 \\), determine the roots of these functions within a specified interval and identify the points where the functions cross over each other. What are the roots of \\( f(t) \\) and \\( g(t) \\), and at which points do \\( f(t) \\) and \\( g(t) \\) intersect within the given tolerance?\n\nThe input and output requirements are as follows:\n\nInput:\n  `t0` (float): Initial guess for the root finding method.\n  `tmin` (float): Minimum value of the interval for generating t values.\n  `tmax` (float): Maximum value of the interval for generating t values.\n  `eps` (float): Tolerance for finding crossover points between f(t) and g(t).\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `tf_root` (float or None): The root of the function f(t) found using Newton's method. If no root is found, it will be `None`.\n    - `tg_root` (float or None): The root of the function g(t) found using Newton's method. If no root is found, it will be `None`.\n    - `crossover_points` (list of floats): A list of t values where f(t) and g(t) cross over within the tolerance `eps`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef f_t(t):\n    t0 = 2.5\n    c = 1.1\n    f = c*(t-t0)**2\n    return f\n\ndef dfdt(t):\n    t0 = 2.5\n    c = 1.1\n    df = 2*c*(t-t0)\n    return df\n\ndef g_t(t):\n    t0 = 2.5\n    A = 5\n    g = A*t + t0\n    return g\n\ndef dgdt(t):\n    A = 5\n    return A\n\ndef Newton(function, d_dt, t0):\n    \"\"\"\n    Implementation of Newton's Method\n    for solving f(x) = 0 when f'(x) is known\n    \"\"\"\n    t_next = 0\n    tn = float(t0)\n    abs_tn = abs(function(tn))\n    eps = 1e-5 # epsilon to set bounds\n    N = 20 # runs through 20 times\n    i = 0\n    while abs_tn > eps and i < N: # convergence criteria\n        t_next = tn - function(tn)/d_dt(tn)\n        tn = t_next\n        i += 1\n    if abs_tn < eps:\n        return t_next\n    else:\n        return np.nan\n\n# main function\ndef main_solution(t0, tmin, tmax, eps):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # Find roots using Newton's method\n    tf_root = Newton(f_t, dfdt, t0)\n    tg_root = Newton(g_t, dgdt, t0)\n    \n    # Generate t values for plotting\n    a_t = np.linspace(tmin, tmax, 1000)\n    \n    # Calculate function values\n    a_ft = f_t(a_t)\n    a_gt = g_t(a_t)\n    \n    # Find crossover points\n    sel = abs(a_ft - a_gt) < eps\n    crossover_points = a_t[sel].tolist()\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\n        \"tf_root\": tf_root.item() if not np.isnan(tf_root) else None,\n        \"tg_root\": tg_root.item() if not np.isnan(tg_root) else None,\n        \"crossover_points\": crossover_points\n    }", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    t0 = random.uniform(0.0, 5.0)\n    tmin = random.uniform(-10.0, 0.0)\n    tmax = random.uniform(5.0, 15.0)\n    eps = random.choice([1e-3, 1e-4, 1e-5, 1e-6])\n    return {\n        \"t0\": t0,\n        \"tmin\": tmin,\n        \"tmax\": tmax,\n        \"eps\": eps\n    }", "io_pairs": [{"input": {"t0": 2.494952004771222, "tmin": -3.730504838918451, "tmax": 9.611312954195284, "eps": 0.0001}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 4.892618539150787, "tmin": -3.1375460911466666, "tmax": 10.994313590445993, "eps": 0.001}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 3.139290064873763, "tmin": -6.928826111256278, "tmax": 14.590137854209505, "eps": 1e-06}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 1.881458332716619, "tmin": -6.396343081644773, "tmax": 9.25617686170649, "eps": 1e-05}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 4.33494612669756, "tmin": -4.889067090647778, "tmax": 9.56111334682861, "eps": 0.001}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 1.293426912080589, "tmin": -4.910559710321733, "tmax": 9.60657707642763, "eps": 0.001}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 2.3082901983655475, "tmin": -3.0157520542863185, "tmax": 11.372174571645562, "eps": 0.0001}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 3.0646332812976818, "tmin": -6.478654392973309, "tmax": 5.992462353094144, "eps": 0.0001}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 2.933675294985445, "tmin": -5.865327797453319, "tmax": 12.333018075897815, "eps": 1e-05}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}, {"input": {"t0": 4.196550982068297, "tmin": -2.2016936548908017, "tmax": 12.846960230562287, "eps": 1e-06}, "output": {"tf_root": null, "tg_root": null, "crossover_points": []}}], "error_log": []}
{"context": "Given a continued fraction represented as a list of integers, how can we convert it to a fraction, optionally limiting the denominator to a specified maximum value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `cfrac` (list of int): The continued fraction represented as a list of integers.\n  `limit_denom` (int, optional): The maximum allowed denominator. If None, no limit is applied.\n\nOutput:\n  `return` (dict): A dictionary containing the numerator and denominator of the resulting fraction.\n    - `numerator` (int): The numerator of the resulting fraction.\n    - `denominator` (int): The denominator of the resulting fraction.", "reference_code": "# import necessary packages\nfrom fractions import Fraction\nfrom math import floor\n\n# main function\ndef main_solution(cfrac, limit_denom=None):\n    \"\"\"\n    Convert a continued fraction to a Fraction, optionally limiting the denominator.\n    \n    Parameters:\n    cfrac (list of int): The continued fraction represented as a list of integers.\n    limit_denom (int, optional): The maximum allowed denominator. If None, no limit is applied.\n    \n    Returns:\n    dict: A dictionary containing the numerator and denominator of the resulting fraction.\n    \"\"\"\n    # Convert JSON serializable inputs to the original input variables\n    cfrac = list(cfrac)\n    if limit_denom is not None:\n        limit_denom = int(limit_denom)\n    \n    # Function to convert continued fraction to a Fraction\n    def cfrac_to_fraction(cfrac, limit_denom=None):\n        terms = cfrac[:]\n        assert limit_denom is None or limit_denom >= 1\n        ans = Fraction(terms.pop(0))\n        if terms:\n            ans = ans + (Fraction(1) / cfrac_to_fraction(terms))\n        if (\n            (limit_denom is not None)\n            and (ans.denominator > limit_denom)\n            and (len(cfrac) > 1)\n        ):\n            return cfrac_to_fraction(cfrac[:-1], limit_denom)\n        return ans\n    \n    # Convert the continued fraction to a Fraction\n    frac = cfrac_to_fraction(cfrac, limit_denom)\n    \n    # Convert the Fraction to JSON serializable output\n    return {\"numerator\": frac.numerator, \"denominator\": frac.denominator}", "input_generator": "import random\nfrom fractions import Fraction\n\ndef input_generator():\n    # Generate a random continued fraction with length between 1 and 5\n    length = random.randint(1, 5)\n    cfrac = [random.randint(1, 10) for _ in range(length)]\n    \n    # Randomly decide whether to include limit_denom\n    if random.choice([True, False]):\n        # Generate a reasonable limit_denom, ensuring it's at least 1\n        limit_denom = random.randint(1, 100)\n    else:\n        limit_denom = None\n    \n    return {\"cfrac\": cfrac, \"limit_denom\": limit_denom}", "io_pairs": [{"input": {"cfrac": [2], "limit_denom": null}, "output": {"numerator": 2, "denominator": 1}}, {"input": {"cfrac": [4, 7, 9, 8], "limit_denom": 72}, "output": {"numerator": 265, "denominator": 64}}, {"input": {"cfrac": [5, 9, 10, 1, 4], "limit_denom": 82}, "output": {"numerator": 46, "denominator": 9}}, {"input": {"cfrac": [8, 7, 5], "limit_denom": 18}, "output": {"numerator": 57, "denominator": 7}}, {"input": {"cfrac": [4, 8], "limit_denom": 5}, "output": {"numerator": 4, "denominator": 1}}, {"input": {"cfrac": [1, 10, 1, 5], "limit_denom": 37}, "output": {"numerator": 12, "denominator": 11}}, {"input": {"cfrac": [7, 10, 5, 1], "limit_denom": 65}, "output": {"numerator": 433, "denominator": 61}}, {"input": {"cfrac": [6, 5], "limit_denom": 99}, "output": {"numerator": 31, "denominator": 5}}, {"input": {"cfrac": [5], "limit_denom": 62}, "output": {"numerator": 5, "denominator": 1}}, {"input": {"cfrac": [10, 7], "limit_denom": null}, "output": {"numerator": 71, "denominator": 7}}], "error_log": []}
{"context": "Given an 8x8 chessboard and 8 queens, where each queen is initially placed in a different column but may have conflicting rows, how many distinct ways can the queens be rearranged such that no two queens threaten each other?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_queen_positions` (list of integers): A list of 8 integers representing the initial positions of the queens on an 8x8 chessboard. Each integer should be between 0 and 7, inclusive.\n\nOutput:\n  `return` (integer): The number of distinct solutions to the 8-queens problem starting from the given initial queen positions.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef update(queen, row):\n    for i in range(8):\n        queen[row] = i\n        if find_elements(queen, row):\n            if row == 7:\n                globals()[\"solutions\"] += 1\n            else:\n                update(queen, row + 1)\n            \ndef find_elements(queen, row):\n    c = 0\n    result = True\n    for i in range(row):\n        c += 1\n        current = queen[row]\n        other = queen[row - i - 1]\n        if (current == other) or (current - c == other) or (current + c == other):\n            result = False\n            break\n    return result\n\n# main function\ndef main_solution(initial_queen_positions):\n    # Convert the input list to a list of integers\n    queen = list(initial_queen_positions)\n    \n    # Initialize the solution counter\n    globals()[\"solutions\"] = 0\n    \n    # Start the recursive update process\n    for i in range(8):\n        queen[0] = i\n        update(queen, 1)\n    \n    # Return the number of solutions found\n    return globals()[\"solutions\"]", "input_generator": "import random\n\ndef input_generator():\n    # Generate a list of 8 integers, each between 0 and 7, representing initial queen positions\n    # The first few positions might be fixed or random, but the rest can be arbitrary since they'll be updated\n    initial_queen_positions = [random.randint(0, 7) for _ in range(8)]\n    return {\"initial_queen_positions\": initial_queen_positions}", "io_pairs": [{"input": {"initial_queen_positions": [3, 4, 1, 7, 4, 2, 7, 5]}, "output": 92}, {"input": {"initial_queen_positions": [2, 2, 3, 7, 0, 4, 2, 6]}, "output": 92}, {"input": {"initial_queen_positions": [0, 7, 0, 3, 7, 7, 7, 0]}, "output": 92}, {"input": {"initial_queen_positions": [1, 3, 1, 1, 1, 1, 7, 1]}, "output": 92}, {"input": {"initial_queen_positions": [2, 7, 7, 0, 4, 1, 5, 3]}, "output": 92}, {"input": {"initial_queen_positions": [1, 2, 3, 6, 4, 2, 3, 7]}, "output": 92}, {"input": {"initial_queen_positions": [4, 3, 7, 4, 0, 3, 0, 6]}, "output": 92}, {"input": {"initial_queen_positions": [7, 1, 1, 3, 2, 5, 0, 3]}, "output": 92}, {"input": {"initial_queen_positions": [4, 5, 6, 4, 1, 7, 0, 2]}, "output": 92}, {"input": {"initial_queen_positions": [2, 3, 3, 5, 7, 3, 2, 7]}, "output": 92}], "error_log": []}
{"context": "Given two sets of 2D points, what is the modified Hausdorff distance between them? The modified Hausdorff distance is a measure of similarity between two sets of points, considering the maximum of the directed distances from each point in one set to the nearest point in the other set.\n\nThe input and output requirements are as follows:\n\nInput:\n  `points_set_A` (List of tuples): Each tuple represents a 2D point in set A. Example: `[(1, 2), (3, 4)]`.\n  `points_set_B` (List of tuples): Each tuple represents a 2D point in set B. Example: `[(5, 6), (7, 8)]`.\n\nOutput:\n  `return` (Float): The modified Hausdorff distance between the two sets of 2D points.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef modified_hausdorff_distance(A, B):\n    \"\"\"\n    Calculate modified hausdorff distance for 2D points sets\n\n    A modified Hausdorff distance for object matching\n    doi: 10.1109/ICPR.1994.576361\n\n    :param A: 2D points set\n    :param B: 2D points set\n    :return: MDH - undirected distance\n    \"\"\"\n    return np.max([directed_distance(A, B), directed_distance(B, A)])\n\ndef directed_distance(A, B):\n    \"\"\"\n    Calculate directed distance between two sets of 2D points\n    :param A: 2D points set\n    :param B: 2D points set\n    :return: directed sitance\n    \"\"\"\n    Na = len(A)\n    sum = 0\n    for a in A:\n        sum += distance_between_point_and_set(a, B)\n    return sum/Na\n\ndef distance_between_point_and_set(a, B):\n    \"\"\"\n    Calculate distance between point and a set\n\n    :param a: is a 2D point\n    :param B: is set of 2D points\n    :return: distance between point and set\n    \"\"\"\n    distances = [euclid_distance(a, b) for b in B]\n    return np.min(distances)\n\ndef euclid_distance(a, b):\n    \"\"\"\n    Calculate euclid distance between two 2D points\n\n    :param a: 2D point\n    :param b: 2D point\n    :return: euclid distance\n    \"\"\"\n    dist = np.linalg.norm(a - b)\n    return dist\n\n# main function\ndef main_solution(points_set_A, points_set_B):\n    \"\"\"\n    Calculate the modified Hausdorff distance between two sets of 2D points.\n\n    :param points_set_A: List of tuples, where each tuple represents a 2D point in set A.\n    :param points_set_B: List of tuples, where each tuple represents a 2D point in set B.\n    :return: Float, the modified Hausdorff distance between the two sets.\n    \"\"\"\n    # Convert input lists to numpy arrays\n    A = np.array(points_set_A)\n    B = np.array(points_set_B)\n    \n    # Calculate the modified Hausdorff distance\n    mdh_distance = modified_hausdorff_distance(A, B)\n    \n    # Return the result as a float\n    return float(mdh_distance)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly decide the number of points in each set (between 1 and 20)\n    n_A = random.randint(1, 20)\n    n_B = random.randint(1, 20)\n    \n    # Generate random points in the range [0, 100) for both sets\n    points_set_A = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(n_A)]\n    points_set_B = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(n_B)]\n    \n    return {\n        'points_set_A': points_set_A,\n        'points_set_B': points_set_B\n    }", "io_pairs": [{"input": {"points_set_A": [[75.077755617849, 78.10726355906327], [47.23264961836134, 31.63360086366359], [69.59614460564667, 94.10831175520099], [87.6981829626213, 93.85384284532793]], "points_set_B": [[37.42926188977267, 0.4508724008638332]]}, "output": 81.02182421091915}, {"input": {"points_set_A": [[11.785662084039906, 81.74938346467908], [39.03077712560733, 22.41207222566558]], "points_set_B": [[46.01447926373099, 18.616728278292204]]}, "output": 39.88151500274127}, {"input": {"points_set_A": [[93.92859553054281, 6.459013826010763]], "points_set_B": [[71.62370160366297, 27.308684771389025], [7.214354518876798, 68.7216209307171], [31.770397043974707, 44.88711788057982]]}, "output": 70.12067112884891}, {"input": {"points_set_A": [[76.25809944645398, 99.98762087779323], [65.52770377545036, 7.878597677707511]], "points_set_B": [[47.87526480857529, 4.694199665231613], [66.76165396912981, 2.1101164484877533]]}, "output": 52.11804976900295}, {"input": {"points_set_A": [[4.973402674250971, 92.01597308375477], [54.13791792694671, 67.29395971941123]], "points_set_B": [[82.85676573866594, 53.59355601639271]]}, "output": 59.332326081720204}, {"input": {"points_set_A": [[74.00949991069325, 4.239767428813845], [18.879181106694396, 61.66980589856682]], "points_set_B": [[28.418249245570383, 4.111495689254774], [88.65467308014918, 90.7457863575514]]}, "output": 60.59132350124881}, {"input": {"points_set_A": [[65.19031939710226, 83.57853424475093]], "points_set_B": [[93.97632730549778, 47.996956856791265], [7.899598242182648, 12.873499763596497], [15.331455187062959, 44.87936141575436]]}, "output": 66.6284304779811}, {"input": {"points_set_A": [[96.25179563258705, 82.6580776231457], [70.44253825135937, 43.210339745671654], [64.35095213745174, 88.03974852690375], [7.204711389545193, 73.69548525110883]], "points_set_B": [[92.66586981612195, 33.6509683411677]]}, "output": 57.25646662561133}, {"input": {"points_set_A": [[48.53852695438064, 16.222891390758665], [75.28667494767436, 77.73690162334643], [9.103397181481366, 35.42438912492477]], "points_set_B": [[31.724472495816325, 93.14360796383009], [13.572260616923714, 3.044274743041653]]}, "output": 39.44672341199579}, {"input": {"points_set_A": [[58.285373678870954, 65.48747227867328], [25.05754173310436, 30.936920417770807], [76.32469942308802, 23.27113702781345]], "points_set_B": [[43.023937371395235, 28.824177623188973]]}, "output": 30.52120091422384}], "error_log": []}
{"context": "Given a range of numbers defined by a minimum and maximum value, and a specific number of digits, how many numbers within this range meet the criteria for either part 'a' or part 'b' of the problem? Part 'a' requires that at least two adjacent digits are the same, while part 'b' requires that at least one digit appears exactly twice consecutively.\n\nThe input and output requirements are as follows:\n\nInput:\n  `part` (str): A string indicating the part of the problem to solve, either 'a' or 'b'.\n  `digits` (int): An integer representing the number of digits in the range.\n  `minimum` (str): A string representing the minimum value of the range.\n  `maximum` (str): A string representing the maximum value of the range.\n\nOutput:\n  `return` (int): An integer representing the count of valid numbers within the specified range based on the problem part.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ncache = {}\ndef cases(part, digits, last_digit, last_digit_count, double, minimum, maximum):\n    state = (digits, last_digit, last_digit_count, double, minimum, maximum)\n    if state in cache:\n        return cache[state]\n    count = 0\n    minimum_first_digit = int(minimum[0])\n    maximum_first_digit = int(maximum[0])\n\n    min_digit = max(minimum_first_digit, last_digit)\n    max_digit = min(maximum_first_digit, 9)\n\n    for d in range(min_digit, max_digit + 1):\n        if part == 'a':\n           new_double = double or (d == last_digit)\n           new_last_digit_count = 0\n        else:\n           new_double = double or (d != last_digit and last_digit_count == 2)\n           if d == last_digit:\n               new_last_digit_count = last_digit_count + 1\n           else:\n               new_last_digit_count = 1     \n\n        new_minimum = \"0\"*(digits-1)\n        new_maximum = \"9\"*(digits-1)\n        if d == min_digit:\n            new_minimum = minimum[1:]\n        if d == max_digit:\n            new_maximum = maximum[1:]\n\n        if digits == 1:\n            if new_double or (d == last_digit and last_digit_count == 1):\n                count += 1\n        else:\n            count += cases(part, digits-1, d, new_last_digit_count, new_double, new_minimum, new_maximum)\n    cache[state] = count\n    return count\n\n# main function\ndef main_solution(part, digits, minimum, maximum):\n    # Convert JSON serializable inputs to original input variables\n    last_digit = -1\n    last_digit_count = 0\n    double = False\n    \n    # Call the original function with converted inputs\n    result = cases(part, digits, last_digit, last_digit_count, double, minimum, maximum)\n    \n    # Return the result, which is already JSON serializable\n    return result", "input_generator": "import random\n\ndef input_generator():\n    part = random.choice(['a', 'b'])\n    digits = random.randint(4, 6)\n    min_num = random.randint(1000, 5000)\n    max_num = random.randint(min_num + 1000, min_num + 5000)\n    minimum = str(min_num).zfill(digits)\n    maximum = str(max_num).zfill(digits)\n    return {\n        'part': part,\n        'digits': digits,\n        'minimum': minimum,\n        'maximum': maximum\n    }", "io_pairs": [{"input": {"part": "a", "digits": 6, "minimum": "002757", "maximum": "007466"}, "output": 205}, {"input": {"part": "b", "digits": 4, "minimum": "4725", "maximum": "6701"}, "output": 34}, {"input": {"part": "a", "digits": 6, "minimum": "002971", "maximum": "004815"}, "output": 137}, {"input": {"part": "a", "digits": 5, "minimum": "03396", "maximum": "06694"}, "output": 123}, {"input": {"part": "a", "digits": 4, "minimum": "2301", "maximum": "3586"}, "output": 95}, {"input": {"part": "b", "digits": 5, "minimum": "02288", "maximum": "06313"}, "output": 153}, {"input": {"part": "a", "digits": 5, "minimum": "03826", "maximum": "05768"}, "output": 72}, {"input": {"part": "a", "digits": 4, "minimum": "2228", "maximum": "5541"}, "output": 189}, {"input": {"part": "a", "digits": 6, "minimum": "001713", "maximum": "004993"}, "output": 269}, {"input": {"part": "b", "digits": 6, "minimum": "001416", "maximum": "003673"}, "output": 242}], "error_log": []}
{"context": "In a game of polyominoes, two players, Richard and Gabriel, take turns placing polyominoes on a grid. Given the size of the polyomino `X`, and the dimensions of the grid `R` (rows) and `C` (columns), determine who will win the game if both players play optimally. The winner is determined based on specific rules related to the size of the polyomino and the grid dimensions. Who will win the game, Richard or Gabriel?\n\nThe input and output requirements are as follows:\n\nInput:\n  `X` (int): The size of the polyomino (number of squares in the shape).\n  `R` (int): The number of rows in the grid.\n  `C` (int): The number of columns in the grid.\n\nOutput:\n  `return` (str): The name of the winner (\"RICHARD\" or \"GABRIEL\") based on the given conditions.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef getDimList(X):\n    return [(w, X-w+1) for w in range(1, (X+1)//2+1)]\n\ndef WorstBlockWillCutBoardInHalf(X, R, C):\n    a = min(R, C)\n    b = max(R, C)\n    dims = getDimList(X)\n    if a >= 2 and any([a == min(d) for d in dims]):\n        return True\n    else:\n        return False\n\ndef worstBlockWillFit(X, R, C):\n    a = min(R, C)\n    b = max(R, C)\n    if all([x <= a and y <= b for (x, y) in getDimList(X)]):\n        return True\n    else:\n        return False\n\n# main function\ndef main_solution(X, R, C):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if X >= 7:\n        return \"RICHARD\"\n\n    if R * C % X != 0:\n        return \"RICHARD\"\n\n    if X in [1, 2]:\n        return \"GABRIEL\"\n\n    if X == 3:\n        if min(R, C) == 1:\n            return \"RICHARD\"\n        else:\n            return \"GABRIEL\"\n\n    if worstBlockWillFit(X, R, C):\n        if WorstBlockWillCutBoardInHalf(X, R, C):\n            return \"RICHARD\"\n        else:\n            return \"GABRIEL\"\n    else:\n        return \"RICHARD\"", "input_generator": "import random\n\ndef input_generator():\n    X = random.randint(1, 10)\n    R = random.randint(1, 20)\n    C = random.randint(1, 20)\n    return {'X': X, 'R': R, 'C': C}", "io_pairs": [{"input": {"X": 9, "R": 7, "C": 18}, "output": "RICHARD"}, {"input": {"X": 1, "R": 16, "C": 7}, "output": "GABRIEL"}, {"input": {"X": 4, "R": 11, "C": 17}, "output": "RICHARD"}, {"input": {"X": 8, "R": 19, "C": 16}, "output": "RICHARD"}, {"input": {"X": 1, "R": 3, "C": 4}, "output": "GABRIEL"}, {"input": {"X": 9, "R": 10, "C": 8}, "output": "RICHARD"}, {"input": {"X": 1, "R": 15, "C": 9}, "output": "GABRIEL"}, {"input": {"X": 10, "R": 8, "C": 3}, "output": "RICHARD"}, {"input": {"X": 6, "R": 5, "C": 6}, "output": "GABRIEL"}, {"input": {"X": 10, "R": 12, "C": 10}, "output": "RICHARD"}], "error_log": []}
{"context": "Given two normal distributions P and Q, where P has a mean of `mean_p` and a standard deviation of `std_p`, and Q has a mean of `mean_q` and a standard deviation of `std_q`, what is the Kullback-Leibler divergence between these two distributions over a range of x values from `x_range[0]` to `x_range[1]` with a step size of `x_range[2]`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `mean_p` (float): Mean of the first normal distribution P.\n  `std_p` (float): Standard deviation of the first normal distribution P.\n  `mean_q` (float): Mean of the second normal distribution Q.\n  `std_q` (float): Standard deviation of the second normal distribution Q.\n  `x_range` (list of floats): A list containing the start, end, and step size for the range of x values.\n\nOutput:\n  `return` (dict): A dictionary containing the key `kl_divergence` with the value being the calculated KL-divergence between the two distributions as a float.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy.stats import norm\n\n# main function\ndef main_solution(mean_p, std_p, mean_q, std_q, x_range):\n  # Convert JSON serializable inputs to numpy arrays\n  x = np.arange(x_range[0], x_range[1], x_range[2])\n  p = norm.pdf(x, mean_p, std_p)\n  q = norm.pdf(x, mean_q, std_q)\n  \n  # Calculate KL-divergence\n  kl_div = np.sum(np.where(p != 0, p * np.log(p / q), 0))\n  \n  # Return the result as a JSON serializable output\n  return {\"kl_divergence\": float(kl_div)}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    mean_p = random.uniform(-10, 10)\n    std_p = random.uniform(0.1, 5)\n    mean_q = random.uniform(-10, 10)\n    std_q = random.uniform(0.1, 5)\n    start = random.uniform(-20, 0)\n    end = random.uniform(0, 20)\n    step = random.uniform(0.1, 1.0)\n    x_range = [start, end, step]\n    return {\n        \"mean_p\": mean_p,\n        \"std_p\": std_p,\n        \"mean_q\": mean_q,\n        \"std_q\": std_q,\n        \"x_range\": x_range\n    }", "io_pairs": [{"input": {"mean_p": -3.1052667443544664, "std_p": 2.4856498420989843, "mean_q": -2.9176962582095367, "std_q": 2.2566396134771423, "x_range": [-15.83583196485783, 3.2528220567735167, 0.1623104396399367]}, "output": {"kl_divergence": 0.0651664093271481}}, {"input": {"mean_p": 5.361008423231333, "std_p": 1.0616446850248173, "mean_q": -2.209479133056065, "std_q": 1.0612158592887362, "x_range": [-13.217184926391951, 10.504222918913195, 0.5532796045844929]}, "output": {"kl_divergence": 45.990087844605235}}, {"input": {"mean_p": -2.2777711997279386, "std_p": 4.278875051260172, "mean_q": -2.750359908133719, "std_q": 1.8074758127750181, "x_range": [-3.8708937228088836, 15.282905578527803, 0.2586997061492607]}, "output": {"kl_divergence": 3.2999657932976802}}, {"input": {"mean_p": 2.5017484133523666, "std_p": 4.357415501430439, "mean_q": -2.5874982416068315, "std_q": 0.407008155363053, "x_range": [-13.436255044128472, 2.1305555890804695, 0.5558351979040739]}, "output": {"kl_divergence": 21.884122904287356}}, {"input": {"mean_p": -2.6505290117132363, "std_p": 4.986728476554983, "mean_q": -1.0300246429373985, "std_q": 0.3731260778724693, "x_range": [-9.612065346688912, 8.400087039399647, 0.6481461264914966]}, "output": {"kl_divergence": 87.27356757494309}}, {"input": {"mean_p": 3.179328727758099, "std_p": 0.7643132637286185, "mean_q": -2.9121836848028266, "std_q": 1.605073865456296, "x_range": [-8.474543021540683, 3.4554757138215386, 0.4653363310031732]}, "output": {"kl_divergence": 8.503492887133056}}, {"input": {"mean_p": -6.97119582354931, "std_p": 2.0951100704522148, "mean_q": -4.907545120854159, "std_q": 3.9818462850446874, "x_range": [-17.97708469756715, 6.331169475941259, 0.4918567168397675]}, "output": {"kl_divergence": 0.8434653342453577}}, {"input": {"mean_p": -9.6934462461052, "std_p": 1.3973255007875813, "mean_q": 7.653552431221058, "std_q": 0.8718682329366663, "x_range": [-2.207142146319878, 10.262624214213282, 0.1028004246696577]}, "output": {"kl_divergence": 2.2877862080440408e-05}}, {"input": {"mean_p": -9.609847539958736, "std_p": 0.6401743315058772, "mean_q": -1.859926143423614, "std_q": 0.39552660628973046, "x_range": [-19.07859364623175, 11.280840088681783, 0.5346349518572904]}, "output": {"kl_divergence": Infinity}}, {"input": {"mean_p": -6.828726575723712, "std_p": 0.3017212474402402, "mean_q": 0.8311410692917462, "std_q": 2.059254619854719, "x_range": [-3.4256027446828554, 19.07409652310392, 0.8075006658499299]}, "output": {"kl_divergence": -1.8683802769208896e-26}}], "error_log": []}
{"context": "Given a set of elements, how can we determine the representative elements of the disjoint sets formed by grouping these elements based on certain union operations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `elements` (list of integers): A list of integers representing the elements to be grouped into disjoint sets.\n\nOutput:\n  `return` (dictionary): A dictionary where the keys are the elements from the input list and the values are the representative elements of the disjoint sets they belong to.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, data):\n        self.parent = self\n        self.rank = 0\n        self.data = data\n\ndef make_set(x):\n    \"\"\"\n    \u521b\u5efa\u96c6\u5408\n    :param x:\n    :return:\n    \"\"\"\n    node = Node(data=x)\n    return node\n\ndef find_set(node):\n    if node != node.parent:\n        node.parent = find_set(node.parent) # \u8def\u5f84\u538b\u7f29\n    return node\n\ndef _link(node1, node2):\n    if not node1 or not node2:\n        return node1 if node1 else node2\n\n    if node1.rank >= node2.rank:\n        node2.parent = node1\n        if node1.rank == node2.rank:\n            node1.rank += 1\n        return node1\n    else:\n        node1.parent = node2\n        return node2\n\ndef union_set(node1, node2):\n    _link(find_set(node1), find_set(node2))\n\n# main function\ndef main_solution(elements):\n    # elements: list of integers representing the elements to be grouped into disjoint sets\n    nodes = {elem: make_set(elem) for elem in elements}\n    \n    # Randomly union some sets\n    for _ in range(len(elements) // 2):\n        elem1, elem2 = random.sample(elements, 2)\n        union_set(nodes[elem1], nodes[elem2])\n    \n    # Find the representative of each element\n    representatives = {elem: find_set(nodes[elem]).data for elem in elements}\n    \n    # Return the representatives as a dictionary\n    return representatives", "input_generator": "import random\n\ndef input_generator():\n    num_elements = random.randint(5, 20)\n    elements = random.sample(range(1, 100), num_elements)\n    return {'elements': elements}", "io_pairs": [{"input": {"elements": [95, 8, 32, 7, 53, 55, 46, 68, 81]}, "output": {"95": 95, "8": 8, "32": 32, "7": 7, "53": 53, "55": 55, "46": 46, "68": 68, "81": 81}}, {"input": {"elements": [12, 2, 40, 53, 19, 33]}, "output": {"12": 12, "2": 2, "40": 40, "53": 53, "19": 19, "33": 33}}, {"input": {"elements": [1, 82, 4, 27, 43, 89, 74, 5, 13, 48, 95]}, "output": {"1": 1, "82": 82, "4": 4, "27": 27, "43": 43, "89": 89, "74": 74, "5": 5, "13": 13, "48": 48, "95": 95}}, {"input": {"elements": [69, 32, 16, 63, 92, 77, 59, 91, 46, 55, 93, 71]}, "output": {"69": 69, "32": 32, "16": 16, "63": 63, "92": 92, "77": 77, "59": 59, "91": 91, "46": 46, "55": 55, "93": 93, "71": 71}}, {"input": {"elements": [39, 28, 76, 80, 22, 93, 20, 49, 72]}, "output": {"39": 39, "28": 28, "76": 76, "80": 80, "22": 22, "93": 93, "20": 20, "49": 49, "72": 72}}, {"input": {"elements": [84, 95, 51, 29, 77, 66, 88, 59, 48, 18]}, "output": {"84": 84, "95": 95, "51": 51, "29": 29, "77": 77, "66": 66, "88": 88, "59": 59, "48": 48, "18": 18}}, {"input": {"elements": [2, 63, 23, 50, 95]}, "output": {"2": 2, "63": 63, "23": 23, "50": 50, "95": 95}}, {"input": {"elements": [56, 24, 17, 98, 30, 27, 26]}, "output": {"56": 56, "24": 24, "17": 17, "98": 98, "30": 30, "27": 27, "26": 26}}, {"input": {"elements": [11, 82, 49, 83, 10, 25, 17, 7, 43, 50, 45]}, "output": {"11": 11, "82": 82, "49": 49, "83": 83, "10": 10, "25": 25, "17": 17, "7": 7, "43": 43, "50": 50, "45": 45}}, {"input": {"elements": [22, 85, 2, 28, 76, 92, 12]}, "output": {"22": 22, "85": 85, "2": 2, "28": 28, "76": 76, "92": 92, "12": 12}}], "error_log": []}
{"context": "Given the amount of nitrogen fertilizer applied and whether irrigation is used, what is the projected gross profit for a crop in a year?\n\nThe input and output requirements are as follows:\n\nInput:\n  `NFert` (float): The amount of nitrogen fertilizer in kg/ha.\n  `irrigation` (bool): A boolean indicating whether irrigation is applied (True) or not (False).\n\nOutput:\n  `return` (dict): A dictionary containing the key `profit` with the value being the gross profit in dollars.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass hectareCrop(object):\n    '''Used to project yearly yield for a crop based on fertilizer and rainfall \n    inputs.\n    '''\n    def __init__(self, NFert, irrigation):\n        self.NFert = NFert\n        self.irrigation = irrigation\n        \n    def rainfall(self):\n        '''returns an annual rainfall amount based on normal probability distribution.\n        Average rainfall during growth period is 50 cm and a standard deviation of 20 cm \n        return self.rainAmt\n        '''\n        mu, sigma = 50, 20\n        rainAmt = random.gauss(mu, sigma)\n        self.rainAmt = rainAmt\n        return self.rainAmt\n        \n    def Nloss(self):\n        '''Loss of N based on amount of rainfall that occurred.  For every cm of rain,\n        3.0% loss of N occurs.\n        Runs self.rainfall() to get self.rainAmt, returns an int of NAmt remaining based\n        on yearly rainfall.  Int returned is not a object variable and does not replace\n        self.NAmt\n        '''\n        self.rainfall()\n        NAmt = self.NFert - 0.0003 * self.rainAmt * self.NFert\n        self.NAmt = int(NAmt)\n        return self.NAmt\n        \n    def cropYield(self):\n        '''Predicts the yearly yield of a crop based on rainfall and fertilizer\n        inputs.\n        Average yield is 100 bushels per acre based on average rainfall and 200 kg/ha\n        per year N fertility.  A very basic model was used to predict yield where\n        yield = rainAmt + (0.25 * N amt in kg/ha).  Need to use NAmt after rainfall\n        for calcualtion.  \n        RETURN: self.yearYield wich is the yield in bushels per acre\n        '''\n        yearYield = self.rainfall() + (0.25 * self.Nloss())\n        self.yearYield = yearYield\n        return self.yearYield\n        \n    def profit(self):\n        '''Assume $7 dollar per bushel yield.  However, a loss of $10 for each cm below \n        50 cm.  If irrigation is True, rainfall is supplemented up to 50 cm if it is \n        below.  If rainfall is 50 cm or greater, no additional irrigation takes\n        place.\n        RETURN grossProfit, not an object attribute\n        '''\n        self.cropYield()\n        if self.rainAmt < 50:\n            if self.irrigation:\n                self.rainAmt = 50\n            grossProfit = self.yearYield * 7 - (50 - self.rainAmt) * 10\n        else:\n            grossProfit = self.yearYield * 7               \n        return grossProfit\n\n# main function\ndef main_solution(NFert, irrigation):\n    # Convert JSON serializable inputs to original input variables\n    NFert = float(NFert)\n    irrigation = bool(irrigation)\n    \n    # Create an instance of hectareCrop\n    crop = hectareCrop(NFert, irrigation)\n    \n    # Calculate the profit\n    profit = crop.profit()\n    \n    # Convert the output to JSON serializable\n    return {\"profit\": profit}", "input_generator": "import random\n\ndef input_generator():\n    NFert = random.uniform(100, 300)  # Reasonable range for fertilizer amount in kg/ha\n    irrigation = random.choice([True, False])\n    return {\"NFert\": NFert, \"irrigation\": irrigation}", "io_pairs": [{"input": {"NFert": 224.32381086839177, "irrigation": true}, "output": {"profit": 676.3078494388257}}, {"input": {"NFert": 158.85502063715273, "irrigation": false}, "output": {"profit": 584.2336377568777}}, {"input": {"NFert": 271.7626265448557, "irrigation": false}, "output": {"profit": 644.6012504608138}}, {"input": {"NFert": 138.4804173268949, "irrigation": false}, "output": {"profit": 325.10664399834593}}, {"input": {"NFert": 118.30242982707495, "irrigation": false}, "output": {"profit": 517.0006125682505}}, {"input": {"NFert": 156.9529334284395, "irrigation": true}, "output": {"profit": 524.1684135047587}}, {"input": {"NFert": 109.71684017454785, "irrigation": true}, "output": {"profit": 500.60263478478623}}, {"input": {"NFert": 238.15377388402143, "irrigation": false}, "output": {"profit": 727.1924891283702}}, {"input": {"NFert": 160.88079108268317, "irrigation": false}, "output": {"profit": 591.5355183293697}}, {"input": {"NFert": 168.332152310044, "irrigation": true}, "output": {"profit": 790.735093319445}}], "error_log": []}
{"context": "In the game of Ultimate Tic Tac Toe, players make moves on a grid of 9 individual Tic Tac Toe boards. Each move sends the opponent to a specific board based on the square chosen. Given a sequence of moves, determine the status of the game after these moves. What is the status of the game after the given moves?\n\nThe input and output requirements are as follows:\n\nInput:\n  `moves` (list of tuples): A list of moves, where each move is a tuple `(board_number, square)`. `board_number` is an integer between 1 and 9 representing the board number, and `square` is an integer between 1 and 9 representing the square on the board.\n\nOutput:\n  `return` (string): A string indicating the status of the game after the moves. Possible outputs are:\n  - \"Invalid move\" if a move is made on a filled square.\n  - \"Player X wins board Y\" if a player wins a board.\n  - \"Board Y is a draw\" if a board ends in a draw.\n  - \"Game in progress\" if the game is still ongoing after the moves.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass MultiBoard:\n    def __init__(self):\n        self.multiBoard = [SingleBoard(i) for i in range(1, 10)]\n\n    def getBoard(self, board):\n        return self.multiBoard[board - 1]\n\nclass SingleBoard:\n    def __init__(self, n):\n        self.singleBoard = [\"-\" for _ in range(1, 10)]\n        self.playerIcons = {0: \"-\", 1: \"X\", 2: \"O\"}\n        self.boardNumber = n\n\n    def changeSquare(self, player, square):\n        self.singleBoard[square - 1] = self.playerIcons[player]\n\n    def getSquare(self, square):\n        return self.singleBoard[square - 1]\n\n    def getNumber(self):\n        return self.boardNumber\n\n    def countSquaresFilled(self):\n        return 9 - self.singleBoard.count(\"-\")\n\n    def getEmptySquare(self):\n        for i, j in enumerate(self.singleBoard):\n            if j == \"-\":\n                return i + 1\n\nclass Game:\n    def __init__(self):\n        self.multiBoard = MultiBoard()\n        self.currentPlayer = 1\n        self.board = None\n        self.playerIcons = {0: \"-\", 1: \"X\", 2: \"O\"}\n        self.wins = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0}\n        self.draws = []\n\n    def detectBoardWin(self):\n        if self.wins[self.board.getNumber()]:\n            return False\n        rows = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]\n        for row in rows:\n            for square in row:\n                if self.board.getSquare(square + 1) != self.playerIcons[self.currentPlayer]:\n                    break\n            else:\n                return True\n        return False\n\n    def detectBoardDraw(self):\n        if self.board.countSquaresFilled() == 9:\n            if not self.detectBoardWin():\n                return True\n        elif self.board.countSquaresFilled() == 8:\n            emptysquare = self.board.getEmptySquare()\n            self.board.changeSquare(1, emptysquare)\n            if self.detectBoardWin():\n                self.board.changeSquare(0, emptysquare)\n                return False\n            self.board.changeSquare(2, emptysquare)\n            if self.detectBoardWin():\n                self.board.changeSquare(0, emptysquare)\n                return False\n            self.board.changeSquare(0, emptysquare)\n            return True\n        return False\n\n    def detectDrawnGame(self):\n        emptyBoards = [i for i in range(1, 10) if i not in self.draws and not self.wins[i]]\n        for empty in emptyBoards:\n            self.wins[empty] = 1\n        if self.detectPlayerWin(1):\n            for empty in emptyBoards:\n                self.wins[empty] = 0\n            return False\n        for empty in emptyBoards:\n            self.wins[empty] = 2\n        if self.detectPlayerWin(2):\n            for empty in emptyBoards:\n                self.wins[empty] = 0\n            return False\n        for empty in emptyBoards:\n            self.wins[empty] = 0\n        return True\n\n    def detectPlayerWin(self, player):\n        currentPlayerWins = [k for k, v in self.wins.items() if v == player]\n        rows = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]\n        for row in rows:\n            for square in row:\n                if square + 1 not in currentPlayerWins:\n                    break\n            else:\n                return True\n        return False\n\n    def getBoardWinRow(self):\n        currentPlayerWins = [k for k, v in self.wins.items() if v == self.currentPlayer]\n        rows = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]\n        for row in rows:\n            for square in row:\n                if square + 1 not in currentPlayerWins:\n                    break\n            else:\n                return tuple([i + 1 for i in row])\n        return None\n\n    def countWins(self, player):\n        return list(self.wins.values()).count(player)\n\n    def checkBoardFilled(self, board):\n        board = self.multiBoard.getBoard(board)\n        return not any(board.getSquare(square) == \"-\" for square in range(1, 10))\n\n    def checkSquareFilled(self, square):\n        return self.board.getSquare(square) != \"-\"\n\n    def makeMove(self, square):\n        self.board.changeSquare(self.currentPlayer, square)\n\n# main function\ndef main_solution(moves):\n    game = Game()\n    game.board = game.multiBoard.getBoard(1)  # Start with board 1\n    for move in moves:\n        board_number, square = move\n        game.board = game.multiBoard.getBoard(board_number)\n        if game.checkSquareFilled(square):\n            return \"Invalid move\"\n        game.makeMove(square)\n        if game.detectBoardWin():\n            return f\"Player {game.currentPlayer} wins board {game.board.getNumber()}\"\n        if game.detectBoardDraw():\n            return f\"Board {game.board.getNumber()} is a draw\"\n        game.currentPlayer = 3 - game.currentPlayer  # Switch player\n        game.board = game.multiBoard.getBoard(square)  # Next board is determined by the square chosen\n    return \"Game in progress\"", "input_generator": "import random\n\ndef input_generator():\n    num_moves = random.randint(1, 20)\n    moves = []\n    current_board = 1\n    for _ in range(num_moves):\n        square = random.randint(1, 9)\n        moves.append((current_board, square))\n        current_board = square\n    return {'moves': moves}", "io_pairs": [{"input": {"moves": [[1, 4], [4, 7], [7, 1], [1, 7], [7, 4], [4, 5], [5, 4]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 1], [1, 9], [9, 9], [9, 7], [7, 6], [6, 8], [8, 3]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 7]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 7], [7, 4], [4, 9]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 3], [3, 6]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 4], [4, 6]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 8]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 7], [7, 5], [5, 7], [7, 8], [8, 1], [1, 2], [2, 5], [5, 4]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 9]]}, "output": "Game in progress"}, {"input": {"moves": [[1, 8], [8, 3]]}, "output": "Game in progress"}], "error_log": []}
{"context": "Given the 3D coordinates of a Carbon (C), Nitrogen (N), and Calcium (Ca) atom, what are the bond lengths between N and C, N and Ca, and the bond angle formed by the C-N-Ca atoms?\n\nThe input and output requirements are as follows:\n\nInput:\n  `C` (list of float): Coordinates of Carbon atom in 3D space.\n  `N` (list of float): Coordinates of Nitrogen atom in 3D space.\n  `Ca` (list of float): Coordinates of Calcium atom in 3D space.\n\nOutput:\n  `return` (dict): A dictionary containing the bond lengths and angle.\n                   Keys: 'N-C bond length', 'N-Ca bond length', 'C-N-Ca bond angle'\n                   Values: Bond lengths are in Angstroms (float), and the angle is in degrees (float).", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Triad:\n    \"\"\"\n    Calculate angles and distances among a triad of points.\n    \"\"\"\n    def __init__(self, p, q, r):\n        self.p = p\n        self.q = q\n        self.r = r\n\n    def d2(self, a, b):\n        return float(sum((ia - ib) * (ia - ib) for ia, ib in zip(a, b)))\n\n    def dot(self, a, b):\n        return float(sum(ia * ib for ia, ib in zip(a, b)))\n\n    def ndot(self, a, b, c):\n        return float(sum((ia - ib) * (ic - ib) for ia, ib, ic in zip(a, b, c)))\n\n    def dPQ(self):\n        return math.sqrt(self.d2(self.p, self.q))\n\n    def dQR(self):\n        return math.sqrt(self.d2(self.q, self.r))\n\n    def angleQ(self):\n        return math.acos(self.ndot(self.p, self.q, self.r) / math.sqrt(self.d2(self.p, self.q) * self.d2(self.r, self.q)))\n\n# main function\ndef main_solution(C, N, Ca):\n    \"\"\"\n    Calculates the N-C bond length, N-Ca bond length, and C-N-Ca bond angle given the 3D coordinates of C, N, and Ca.\n    \n    Input:\n        C (list of float): Coordinates of Carbon atom in 3D space.\n        N (list of float): Coordinates of Nitrogen atom in 3D space.\n        Ca (list of float): Coordinates of Calcium atom in 3D space.\n    \n    Output:\n        dict: A dictionary containing the bond lengths and angle.\n              Keys: 'N-C bond length', 'N-Ca bond length', 'C-N-Ca bond angle'\n    \"\"\"\n    triadPoints = Triad(p=C, q=N, r=Ca)\n    nToC = triadPoints.dPQ()\n    nToCa = triadPoints.dQR()\n    bondAngle = math.degrees(triadPoints.angleQ())\n    \n    return {\n        'N-C bond length': round(nToC, 2),\n        'N-Ca bond length': round(nToCa, 2),\n        'C-N-Ca bond angle': round(bondAngle, 1)\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random coordinates for C, N, Ca in 3D space\n    # Coordinates are in a reasonable range (e.g., -10.0 to 10.0)\n    C = [round(random.uniform(-10.0, 10.0), round(random.uniform(-10.0, 10.0), 2), round(random.uniform(-10.0, 10.0), 2)]\n    N = [round(random.uniform(-10.0, 10.0), round(random.uniform(-10.0, 10.0), 2), round(random.uniform(-10.0, 10.0), 2)]\n    Ca = [round(random.uniform(-10.0, 10.0), round(random.uniform(-10.0, 10.0), 2), round(random.uniform(-10.0, 10.0), 2)]\n    \n    return {\n        'C': C,\n        'N': N,\n        'Ca': Ca\n    }", "io_pairs": [], "error_log": ["STDERR:   File \"<string>\", line 48\n    C = [round(random.uniform(-10.0, 10.0), round(random.uniform(-10.0, 10.0), 2), round(random.uniform(-10.0, 10.0), 2)]\n                                                                                                                        ^\nSyntaxError: closing parenthesis ']' does not match opening parenthesis '('\n"]}
{"context": "Given the mathematical background of Bessel functions, which are solutions to certain differential equations, how would you determine the value of the Bessel function of a specified order `m` at a given point `x`? Specifically, what is the value of the Bessel function for order `m` at `x`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The order of the Bessel function.\n  `x` (float): The value at which the Bessel function is evaluated.\n\nOutput:\n  `return` (float): The value of the Bessel function of order `m` at `x`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef integrand(theta, m, x):\n    return np.cos(m * theta - x * np.sin(theta))\n\ndef trapezium(a, b, m, x):\n    area = 0\n    h = (b - a) / 10000\n    for n in range(0, 10000):\n        area += h * ((integrand(h * n, m, x) + integrand(h * (n + 1), m, x)) / 2)\n    return area\n\ndef J(m, x):\n    return 1 / np.pi * trapezium(0, np.pi, m, x)\n\n# main function\ndef main_solution(m, x):\n    # Convert input to appropriate types if necessary\n    m = int(m)\n    x = float(x)\n    \n    # Calculate the Bessel function value\n    result = J(m, x)\n    \n    # Convert output to JSON serializable format\n    return float(result)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    m = random.randint(0, 10)\n    x = random.uniform(0.1, 10.0)\n    return {'m': m, 'x': x}", "io_pairs": [{"input": {"m": 3, "x": 7.50972347917303}, "output": -0.2592852108648439}, {"input": {"m": 9, "x": 0.7608805728861169}, "output": 4.534460200251755e-10}, {"input": {"m": 7, "x": 9.6385163893057}, "output": 0.27013455713657764}, {"input": {"m": 1, "x": 4.2463678262943}, "output": -0.15434365204448625}, {"input": {"m": 2, "x": 6.982535134938354}, "output": -0.30279896157685715}, {"input": {"m": 10, "x": 7.574642811444821}, "output": 0.04182547923663073}, {"input": {"m": 6, "x": 6.171332072759764}, "output": 0.2654057283322244}, {"input": {"m": 3, "x": 9.84368610295091}, "output": 0.020509536944434418}, {"input": {"m": 1, "x": 5.719451857942465}, "output": -0.32182057010509546}, {"input": {"m": 4, "x": 7.814842717606119}, "output": -0.059521649107047866}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = x \\cdot e^x - x^2 - 5x - 3 \\), we want to find an approximate root using an iterative method. The method involves an initial guess `xi`, a tolerance level `tol`, a maximum number of iterations `iter_max`, and a type of error calculation `error_type`. What is the estimated root, the number of iterations performed, and the final error value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `xi` (float): Initial guess for the root.\n  `tol` (float): Tolerance level for the error.\n  `iter_max` (int): Maximum number of iterations allowed.\n  `error_type` (int): Type of error calculation. If `1`, relative error is used; otherwise, absolute error is used.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `root` (float): The estimated root of the function.\n    - `iterations` (int): The number of iterations performed.\n    - `error` (float): The final error value.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef f(x): \n    return x * math.exp(x) - math.pow(x, 2) - 5 * x - 3 \n\ndef g(x): \n    return (x * math.exp(x) - math.pow(x, 2) - 3) / 5\n\n# main function\ndef main_solution(xi, tol, iter_max, error_type):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    x, fx, e = xi, f(xi), tol + 1\n    n = 0\n\n    while e > tol and fx != 0 and n < iter_max - 1:\n        x = g(xi)\n        fx = f(x)\n        e = (x - xi) \n        if error_type == 1:\n            e /= x\n        e = abs(e) \n        xi = x\n        n += 1\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"root\": x, \"iterations\": n, \"error\": e}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    xi = random.uniform(-5.0, 5.0)\n    tol = 10 ** random.uniform(-6, -2)\n    iter_max = random.randint(10, 100)\n    error_type = random.choice([0, 1])\n    return {\"xi\": xi, \"tol\": tol, \"iter_max\": iter_max, \"error_type\": error_type}", "io_pairs": [{"input": {"xi": 1.4798207454948242, "tol": 1.345240999079067e-05, "iter_max": 93, "error_type": 1}, "output": {"root": -0.7998336149915364, "iterations": 12, "error": 1.0321218812110263e-05}}, {"input": {"xi": -0.6388174360505205, "tol": 6.004312589666757e-06, "iter_max": 76, "error_type": 0}, "output": {"root": -0.7998350052433627, "iterations": 10, "error": 5.531398085789618e-06}}, {"input": {"xi": -3.1684258897699147, "tol": 0.003784351222553721, "iter_max": 89, "error_type": 1}, "output": {"root": -0.8003916093660924, "iterations": 10, "error": 0.001354117599205517}}, {"input": {"xi": -0.08614255391077297, "tol": 6.0993728866898276e-06, "iter_max": 11, "error_type": 0}, "output": {"root": -0.7998284808814623, "iterations": 10, "error": 1.8314422122411855e-05}}, {"input": {"xi": -2.8934107068651493, "tol": 0.000569171535037368, "iter_max": 89, "error_type": 1}, "output": {"root": -0.7999417411534782, "iterations": 11, "error": 0.0002544534448196457}}, {"input": {"xi": -3.853894033716606, "tol": 2.352237810801523e-05, "iter_max": 99, "error_type": 0}, "output": {"root": -0.7998454758256544, "iterations": 16, "error": 1.4982686298070647e-05}}, {"input": {"xi": -0.6935589318962272, "tol": 4.56710003700892e-06, "iter_max": 55, "error_type": 0}, "output": {"root": -0.7998359005566898, "iterations": 10, "error": 3.7772575428585142e-06}}, {"input": {"xi": -3.65087514401373, "tol": 3.04621243026585e-06, "iter_max": 41, "error_type": 0}, "output": {"root": -0.7998389185605934, "iterations": 17, "error": 2.1357148446421448e-06}}, {"input": {"xi": -0.4614699699974789, "tol": 0.0004651858229290568, "iter_max": 27, "error_type": 0}, "output": {"root": -0.7996993753387776, "iterations": 7, "error": 0.00027133407936974496}}, {"input": {"xi": 2.0017590042383873, "tol": 0.0007789795966768268, "iter_max": 58, "error_type": 1}, "output": {"root": -0.799716665394975, "iterations": 10, "error": 0.0002969075192937509}}], "error_log": []}
{"context": "Given a range of integers from `low_lim` to `up_lim`, what is the maximum number of pairs of prime numbers that can sum up to any even number within this range, according to Goldbach's Conjecture?\n\nThe input and output requirements are as follows:\n\nInput:\n  `low_lim` (int): The lower limit of the range (inclusive) for which to check Goldbach's Conjecture. Must be at least 4.\n  `up_lim` (int): The upper limit of the range (inclusive) for which to check Goldbach's Conjecture. Must be greater than `low_lim`.\n\nOutput:\n  `return` (int): The maximum number of pairs of prime numbers that add up to any even number in the given range.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    limit = int(n ** 0.5) + 1\n    div = 2\n    while div < limit:\n        if n % div == 0:\n            return False\n        div += 1\n    return True\n\ndef peel_factors(listo):\n    a = str(listo.pop(0)) + ' + ' + str(listo.pop(0))\n    while len(listo) > 0:\n        a += ' = ' + str(listo.pop(0)) + ' + ' + str(listo.pop(0))\n    return a\n\n# main function\ndef main_solution(low_lim, up_lim):\n    # Ensure the inputs are valid\n    if up_lim < low_lim or low_lim < 4:\n        raise ValueError(\"Upper limit must be greater than lower limit and lower limit must be at least 4.\")\n\n    # Create Range of values\n    a = list(range(low_lim, up_lim + 1))\n\n    max_pairs = 0\n\n    # For each even number in the range, find the pairs of primes that sum to it\n    for i in a:\n        if i % 2 == 0:\n            pairs = 0\n            factors = []\n            peel = 1\n            while peel <= (i // 2):\n                num_sum1 = i - peel\n                num_sum2 = peel\n                peel += 1\n                if is_prime(num_sum1) and is_prime(num_sum2) and num_sum1 != 1 and num_sum2 != 1:\n                    factors.append(num_sum2)\n                    factors.append(num_sum1)\n            pairs = len(factors)\n            if pairs > max_pairs:\n                max_pairs = pairs\n\n    # Return the maximum number of pairs of primes that add up to any even number in the given range\n    return max_pairs // 2", "input_generator": "import random\n\ndef input_generator():\n    low_lim = random.randint(4, 100)\n    up_lim = random.randint(low_lim + 1, low_lim + 100)\n    return {'low_lim': low_lim, 'up_lim': up_lim}", "io_pairs": [{"input": {"low_lim": 37, "up_lim": 84}, "output": 8}, {"input": {"low_lim": 99, "up_lim": 113}, "output": 8}, {"input": {"low_lim": 44, "up_lim": 82}, "output": 7}, {"input": {"low_lim": 44, "up_lim": 141}, "output": 12}, {"input": {"low_lim": 60, "up_lim": 116}, "output": 10}, {"input": {"low_lim": 65, "up_lim": 99}, "output": 9}, {"input": {"low_lim": 97, "up_lim": 165}, "output": 12}, {"input": {"low_lim": 100, "up_lim": 146}, "output": 12}, {"input": {"low_lim": 73, "up_lim": 160}, "output": 12}, {"input": {"low_lim": 75, "up_lim": 170}, "output": 13}], "error_log": []}
{"context": "Given a list of integers, is it possible to partition the list into two groups such that the sum of one group minus the sum of the other group equals 0 or a multiple of 360?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num` (int): The number of integers in the list.\n  `lists` (list of int): The list of integers.\n\nOutput:\n  `return` (bool): True if it is possible to partition the list into two groups such that the sum of one group minus the sum of the other group equals 0 or a multiple of 360, False otherwise.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(num, lists):\n    \"\"\"\n    Determines if it is possible to partition the given list of integers into two groups such that the sum of one group minus the sum of the other group equals 0 or a multiple of 360.\n\n    Args:\n        num (int): The number of integers in the list.\n        lists (list of int): The list of integers.\n\n    Returns:\n        bool: True if such a partition exists, False otherwise.\n    \"\"\"\n    def add(k, lists, count):\n        if k == len(lists):\n            return count == 0 or count % 360 == 0\n        else:\n            count = count + lists[k]\n            A = add(k + 1, lists, count)\n            count = count - 2 * lists[k]\n            B = add(k + 1, lists, count)\n            return A or B\n\n    return add(0, lists, 0)", "input_generator": "import random\n\ndef input_generator():\n    num = random.randint(1, 10)\n    lists = [random.randint(-100, 100) for _ in range(num)]\n    return {'num': num, 'lists': lists}", "io_pairs": [{"input": {"num": 1, "lists": [72]}, "output": false}, {"input": {"num": 10, "lists": [-35, -47, 79, 99, -41, 50, -89, 11, 20, 89]}, "output": true}, {"input": {"num": 9, "lists": [12, -64, 98, 25, -88, -4, 89, -63, 95]}, "output": true}, {"input": {"num": 6, "lists": [42, -1, -80, 31, 66, -88]}, "output": true}, {"input": {"num": 6, "lists": [-63, 79, -6, 65, -71, -26]}, "output": false}, {"input": {"num": 7, "lists": [29, 84, -49, -1, -22, -11, 32]}, "output": true}, {"input": {"num": 6, "lists": [-33, 2, -87, 92, 7, 46]}, "output": false}, {"input": {"num": 5, "lists": [-95, 37, -60, 79, 41]}, "output": false}, {"input": {"num": 5, "lists": [54, 54, -6, 23, -62]}, "output": false}, {"input": {"num": 1, "lists": [-15]}, "output": false}], "error_log": []}
{"context": "Given a sequence of integers, determine whether this sequence can represent the post-order traversal of a Binary Search Tree (BST). What is the result indicating whether the sequence is a valid post-order traversal of a BST?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sequence` (list of integers): A list of integers representing the sequence to be verified as the post-order traversal of a Binary Search Tree (BST).\n\nOutput:\n  `return` (string): A string indicating whether the input sequence is a valid post-order traversal of a BST. The possible values are \"Yes\" or \"No\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, sequence):\n        if not sequence:\n            return False\n        length = len(sequence)\n        root = sequence[-1]\n        index = 0\n        for i in range(length-1):\n            index = i\n            if sequence[i] > root:\n                break\n        for j in range(index+1, length-1):\n            if sequence[j] < root:\n                return False\n\n        left = True\n        if index > 0:\n            left = self.VerifySquenceOfBST(sequence[:index])\n\n        right = True\n        if index < length-1:\n            right = self.VerifySquenceOfBST(sequence[index:length-1])\n\n        return left and right\n\n# main function\ndef main_solution(sequence):\n    # Convert the input list to a JSON serializable format\n    sequence_list = list(sequence)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the VerifySquenceOfBST method\n    result = solution.VerifySquenceOfBST(sequence_list)\n    \n    # Convert the result to a JSON serializable format\n    return \"Yes\" if result else \"No\"", "input_generator": "import random\n\ndef input_generator():\n    def generate_sequence(length):\n        if random.random() < 0.5:\n            # Generate a valid BST postorder sequence\n            def build_valid_sequence(start, end):\n                if start > end:\n                    return []\n                root = random.randint(start, end)\n                left = build_valid_sequence(start, root - 1)\n                right = build_valid_sequence(root + 1, end)\n                return left + right + [root]\n            sequence = build_valid_sequence(1, length)\n        else:\n            # Generate a random sequence (may or may not be valid)\n            sequence = [random.randint(1, 100) for _ in range(length)]\n            # Occasionally make it obviously invalid\n            if random.random() < 0.3:\n                sequence.sort()  # sorted sequences are invalid for BST postorder\n        return sequence\n\n    length = random.randint(0, 20)\n    sequence = generate_sequence(length)\n    return {'sequence': sequence}", "io_pairs": [{"input": {"sequence": [1, 3, 4, 2, 5, 6, 9, 8, 7]}, "output": "Yes"}, {"input": {"sequence": [54, 79, 86, 88, 99]}, "output": "Yes"}, {"input": {"sequence": []}, "output": "No"}, {"input": {"sequence": [15, 29, 31, 46, 58, 75, 92, 99]}, "output": "Yes"}, {"input": {"sequence": [2, 1, 6, 8, 7, 5, 4, 10, 9, 12, 13, 11, 15, 14, 3]}, "output": "Yes"}, {"input": {"sequence": [84]}, "output": "Yes"}, {"input": {"sequence": [30, 57, 48, 95]}, "output": "Yes"}, {"input": {"sequence": [1, 5, 8, 7, 6, 4, 3, 2, 10, 12, 14, 16, 15, 17, 13, 11, 9]}, "output": "Yes"}, {"input": {"sequence": [1, 4, 3, 5, 7, 6, 2, 8]}, "output": "Yes"}, {"input": {"sequence": [9, 85, 46, 8, 18, 33, 22, 37, 53, 6, 73, 94]}, "output": "No"}], "error_log": []}
{"context": "Given a requirement to generate a sequence of independent standard Gaussian random variables, how many pairs of such variables can be generated using the Box-Muller method for a specified number of pairs?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_pairs` (int): The number of pairs of independent standard Gaussian random variables to generate.\n\nOutput:\n  `return` (list of float): A list containing the generated independent standard Gaussian random variables. Each pair of variables is generated using the Box-Muller method.", "reference_code": "# import necessary packages\nimport random\nimport numpy as np\n\n# main function\ndef main_solution(num_pairs):\n    # Convert the input to an integer\n    num_pairs = int(num_pairs)\n    \n    # Function to generate two independent standard Gaussian random variables using Box-Muller method\n    def box_muller():\n        u0 = random.random()\n        u1 = random.random()\n        z0 = np.sqrt(-2 * np.log(u0)) * np.cos(2 * np.pi * u1)\n        z1 = np.sqrt(-2 * np.log(u0)) * np.sin(2 * np.pi * u1)\n        return [z0, z1]\n    \n    # Generate the sequence of random variables\n    result = []\n    for _ in range(num_pairs):\n        result.extend(box_muller())\n    \n    # Return the result as a list of floats\n    return result", "input_generator": "import random\n\ndef input_generator():\n    return {'num_pairs': random.randint(1, 100)}", "io_pairs": [{"input": {"num_pairs": 4}, "output": [0.9590718139377354, 0.497666400190813, 1.4805527447277, -0.3892393306039855, -0.16589706826574505, 1.2703281860500233, -0.1674854157663331, -0.08315505388947543]}, {"input": {"num_pairs": 2}, "output": [0.8279787878795354, -0.17218089853083313, -0.2397131090553526, -0.8263631944880695]}, {"input": {"num_pairs": 8}, "output": [-1.2546138038816672, -1.5633543978189492, -1.0367685340644055, 1.041231859745943, 1.330010724090539, -0.7156770689506775, -0.02296960481331714, 0.8446165779926158, 0.6439508272716921, -0.6877267679168616, -0.3547393477373297, -1.2265442707029466, -0.47321493620080285, 0.5075705936457354, -0.36278380672507576, 0.4248551569309738]}, {"input": {"num_pairs": 7}, "output": [0.19982955493942128, -0.9341464009287237, -0.41596893063247975, 0.7599648224010516, -0.4640534611072595, -0.2610657630067721, -0.23193887320139908, 0.41233879787347594, -1.167173178302667, 1.0692616314037284, 0.02470215263199659, -1.7805149355957481, -0.773886007429506, -1.6381271157041637]}, {"input": {"num_pairs": 3}, "output": [-0.9907413348051333, -1.5042102363447243, 0.658064764348731, -0.21865604636663002, -0.5267950840045558, 0.3328832271930936]}, {"input": {"num_pairs": 5}, "output": [-0.5060280059971918, 0.24084205490417818, 0.2966804030922683, -1.6466102050980758, -0.5944013205812693, -0.28979260683395147, 0.26021064843764813, -0.6761062735865226, 1.7573340668254518, 0.31282927111243597]}, {"input": {"num_pairs": 6}, "output": [-0.20654638273815623, -1.320115953913682, 0.3060068226826752, -2.2577183046490306, -0.2938271254974449, 0.37898622807677784, -0.030442323238881117, -1.0483549473216875, -0.8961942285171605, -2.211595211431899, 0.8408664086959434, 0.21618152616699637]}, {"input": {"num_pairs": 1}, "output": [1.5453659223320773, 0.023023156195361986]}, {"input": {"num_pairs": 9}, "output": [-3.0463138422337295, 1.1941793145916448, -1.5473072631061349, -0.12131046375952875, -0.1415543853336639, 0.11830785655421493, -0.0144946808186035, -0.13114211376815632, -0.8377907714057217, 0.9909442255440816, 2.082261254296539, 0.07310088915463621, 1.3241112087172666, 1.1821064595135489, -0.37261775068902103, -0.03332781234751718, -1.6242061978287812, 0.12501793072431708]}], "error_log": []}
{"context": "Given a function that computes the sum of squares of two variables, how would the values of these variables change after applying the gradient descent algorithm with a specified learning rate and number of steps?\n\nThe input and output requirements are as follows:\n\nInput:\n  `init_x` (list of float): A list containing the initial values for the variables x0 and x1.\n  `lr` (float): The learning rate used in the gradient descent algorithm.\n  `step_num` (int): The number of steps to perform in the gradient descent algorithm.\n\nOutput:\n  `return` (list of float): A list containing the final values of x0 and x1 after performing the gradient descent algorithm.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef numerical_diff(f, x):\n    h = 1e-4\n    return (f(x+h)-f(x-h))/(2*h)\n\ndef function_2(x):\n    return x[0]**2 + x[1]**2\n\ndef numerical_grad(f, x):\n    h = 1e-4\n    grad = np.zeros_like(x)\n\n    for idx in range(x.size):\n        tmp = x[idx]\n\n        x[idx] = tmp + h\n        fxh1 = f(x)\n\n        x[idx] = tmp - h\n        fxh2 = f(x)\n\n        grad[idx] = (fxh1 - fxh2) / (2 * h)\n        x[idx] = tmp\n\n    return grad\n\ndef grad_descent(f, init_x, lr=0.01, step_num=100):\n    x = init_x\n\n    for i in range(step_num):\n        grad = numerical_grad(f, x)\n        x -= lr * grad\n\n    return x\n\n# main function\ndef main_solution(init_x, lr, step_num):\n    # Convert JSON serializable inputs to the original input variables\n    init_x = np.array(init_x)\n\n    # Call the grad_descent function\n    result = grad_descent(function_2, init_x, lr, step_num)\n\n    # Convert the result to JSON serializable output\n    return result.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    init_x = [random.uniform(-10, 10), random.uniform(-10, 10)]\n    lr = random.choice([0.001, 0.01, 0.1, 0.2])\n    step_num = random.randint(50, 200)\n    return {'init_x': init_x, 'lr': lr, 'step_num': step_num}", "io_pairs": [{"input": {"init_x": [5.17358511532594, -9.152129807240525], "lr": 0.01, "step_num": 171}, "output": [0.16347469730024167, -0.2891885639343407]}, {"input": {"init_x": [-7.852445318166783, 3.296611206322172], "lr": 0.01, "step_num": 151}, "output": [-0.371657028581682, 0.15602894075486368]}, {"input": {"init_x": [8.537359904621475, -0.8788985414331698], "lr": 0.2, "step_num": 102}, "output": [5.4263048183478615e-21, -2.660212849970537e-21]}, {"input": {"init_x": [-8.467445591165854, 9.775578993617831], "lr": 0.01, "step_num": 57}, "output": [-2.6769405670974162, 3.0905003986339246]}, {"input": {"init_x": [-7.76105885796426, 4.9773514070895], "lr": 0.01, "step_num": 176}, "output": [-0.2216717239975428, 0.1421633423406608]}, {"input": {"init_x": [3.8600703997618204, -8.556963404170174], "lr": 0.01, "step_num": 74}, "output": [0.8656151057029806, -1.918886448822425]}, {"input": {"init_x": [2.3986387097496475, 9.941391673466068], "lr": 0.2, "step_num": 133}, "output": [2.9513804255892027e-21, 2.660212849970537e-21]}, {"input": {"init_x": [-1.4415719230085138, -0.6945826655620557], "lr": 0.1, "step_num": 149}, "output": [-5.238950699240536e-15, -2.5242472867133992e-15]}, {"input": {"init_x": [5.371020164170442, -5.467715236897936], "lr": 0.1, "step_num": 181}, "output": [1.546614663748368e-17, -1.5743602867268668e-17]}, {"input": {"init_x": [-4.768792130542272, 6.694807878272119], "lr": 0.001, "step_num": 82}, "output": [-4.04680965721907, 5.681231731930655]}], "error_log": []}
{"context": "Given a set of 4 unique digits, what is the length of the longest sequence of consecutive integers starting from 1 that can be formed using these digits with the operators +, -, *, /, where each digit must be used exactly once?\n\nThe input and output requirements are as follows:\n\nInput:\n  `digits_str` (str): A string of exactly 4 unique digits (0-9) without any separators.\n\nOutput:\n  `return` (dict): A dictionary with the following keys:\n    - `longest_sequence` (int): The length of the longest sequence of consecutive integers starting from 1 that can be formed using the digits.\n    - `digits` (str): The input string of digits used to find the longest sequence.", "reference_code": "# import necessary packages\nimport itertools\nimport random\n\n# Performs the specified operation on a and b\ndef calc(a, b, op):\n    if op == 0:\n        return a + b\n    if op == 1:\n        return a - b\n    if op == 2:\n        return a * b\n    if op == 3:\n        if b != 0:\n            return float(a) / b\n        else:\n            return a + 0.123456\n\n# main function\ndef main_solution(digits_str):\n    digits = [int(d) for d in digits_str]\n    solutions = set()\n    \n    # Loop over all digit orders\n    for a, b, c, d in itertools.permutations(digits):\n        # Loop over all combinations of operations\n        for operations in itertools.product(range(4), repeat=3):\n            # The two options are:\n            # (((a ~ b) ~ c) ~ d)\n            # ((a ~ b) ~ (c ~ d))\n            answers = []\n            a_op_b = calc(a, b, operations[0])\n            answers.append(calc(calc(a_op_b, c, operations[1]), d, operations[2]))\n            answers.append(calc(a_op_b, calc(c, d, operations[1]), operations[2]))\n            for answer in answers:\n                if float(answer).is_integer() and answer > 0:\n                    solutions.add(int(answer))\n    \n    # Check if longest sequence has been improved on\n    longest_sequence = 0\n    for index, item in enumerate(sorted(list(solutions))):\n        if index != item - 1:\n            longest_sequence = index\n            break\n    \n    return {\"longest_sequence\": longest_sequence, \"digits\": digits_str}", "input_generator": "import random\n\ndef input_generator():\n    digits = random.sample(range(1, 10), 4)\n    digits_str = ''.join(map(str, digits))\n    return {\"digits_str\": digits_str}", "io_pairs": [{"input": {"digits_str": "7928"}, "output": {"longest_sequence": 22, "digits": "7928"}}, {"input": {"digits_str": "6137"}, "output": {"longest_sequence": 28, "digits": "6137"}}, {"input": {"digits_str": "9231"}, "output": {"longest_sequence": 30, "digits": "9231"}}, {"input": {"digits_str": "7243"}, "output": {"longest_sequence": 35, "digits": "7243"}}, {"input": {"digits_str": "9713"}, "output": {"longest_sequence": 15, "digits": "9713"}}, {"input": {"digits_str": "8319"}, "output": {"longest_sequence": 7, "digits": "8319"}}, {"input": {"digits_str": "2164"}, "output": {"longest_sequence": 28, "digits": "2164"}}, {"input": {"digits_str": "2718"}, "output": {"longest_sequence": 18, "digits": "2718"}}, {"input": {"digits_str": "2197"}, "output": {"longest_sequence": 28, "digits": "2197"}}, {"input": {"digits_str": "7195"}, "output": {"longest_sequence": 12, "digits": "7195"}}], "error_log": []}
{"context": "Given two integers `x` and `m`, what is the multiplicative inverse of `x` modulo `m`? The multiplicative inverse is an integer `a` such that `a * x` is congruent to 1 modulo `m`. If no such integer exists, the result should be `None`.\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (int): The integer for which the multiplicative inverse is to be found.\n  `m` (int): The modulus under which the multiplicative inverse is to be found.\n\nOutput:\n  `return` (int or None): The multiplicative inverse of `x` modulo `m` if it exists, otherwise `None`.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef multInv(x, m):\n    \"\"\" Find the multiplicative inverse of X mod M.\n        The multiplicative inverse is A such that A * X = 1 mod M. \"\"\"\n    d, a, b = extendedEuclid(x, m)\n    if d != 1:\n        raise ValueError(\"No multiplicative inverse exists\")\n    return a % m\n\ndef switched(x, y):\n    \"\"\"Returns Y, X.\"\"\"\n    return (y, x)\n\ndef extendedEuclid(x, y):\n    \"\"\"Returns d, a, b such that d is the gcd of X and Y and aX + bY = d. \"\"\"\n    swapped = False\n    if x < y:\n        swapped = True\n        x, y = switched(x, y)\n    eqs = {x: (1, 0),\n           y: (0, 1)}\n    while (x != 0):\n        if (x < y) and (x != 1):\n            x, y = switched(x, y)\n        if (x == 1 or y == 0):\n            if swapped:\n                return (x, eqs[x][1], eqs[x][0])\n            return (x, eqs[x][0], eqs[x][1])\n        scaleBy = (x // y)\n        eqs[x % y] = (eqs[x][0] - scaleBy * eqs[y][0], eqs[x][1] - scaleBy * eqs[y][1])\n        x = x % y\n    if swapped:\n        return (y, eqs[y][1], eqs[y][0])\n    return (y, eqs[y][0], eqs[y][1])\n\n# main function\ndef main_solution(x, m):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    try:\n        result = multInv(x, m)\n    except ValueError:\n        result = None\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate random x and m, ensuring they are coprime for some cases to allow inverse\n    if random.random() < 0.5:\n        # Generate coprime x and m\n        m = random.randint(2, 1000)\n        x = random.randint(1, m - 1)\n        while True:\n            d, a, b = extendedEuclid(x, m)\n            if d == 1:\n                break\n            x = random.randint(1, m - 1)\n    else:\n        # Generate non-coprime x and m\n        m = random.randint(2, 1000)\n        d = random.randint(2, min(m, 100))\n        x = random.randint(1, (m // d)) * d\n    \n    return {'x': x, 'm': m}", "io_pairs": [{"input": {"x": 750, "m": 931}, "output": 36}, {"input": {"x": 99, "m": 416}, "output": 395}, {"input": {"x": 83, "m": 90}, "output": 77}, {"input": {"x": 49, "m": 290}, "output": 219}, {"input": {"x": 197, "m": 663}, "output": 488}, {"input": {"x": 257, "m": 804}, "output": 341}, {"input": {"x": 400, "m": 961}, "output": 382}, {"input": {"x": 385, "m": 941}, "output": 22}, {"input": {"x": 538, "m": 937}, "output": 573}, {"input": {"x": 139, "m": 510}, "output": 499}], "error_log": []}
{"context": "Given a deck of cards and a series of shuffle instructions, what card will be at a specific position in the deck after all the instructions have been applied?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number_of_cards` (int): The total number of cards in the deck.\n  `instructions` (list of str): A list of instructions to shuffle the deck. Each instruction is a string describing the shuffle operation.\n  `card_position` (int): The position in the deck for which the card needs to be found.\n\nOutput:\n  `return` (int): The card at the specified position in the deck after applying all the shuffle instructions.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\ndef compute_inverse(n, a):\n    (r, u, r2, u2) = (a, 1, n, 0)\n    while r2 != 0:\n        q = r // r2\n        (r, u, r2, u2) = (r2, u2, r - q * r2, u - q * u2)\n    return u + n * math.ceil(-u / n)\n\ndef compute_power(root, exponent, n):\n    binary_exponent = [int(x) for x in str(bin(exponent))[2:]]\n    power = 1\n    r = root\n    for i, coefficient in enumerate(binary_exponent[::-1]):\n        power *= r ** coefficient\n        power = power % n\n        r = (r ** 2) % n\n    return power\n\nclass Deck(object):\n    def __init__(self, number_of_cards):\n        self.number_of_cards = number_of_cards\n        self.shuffle = (1, 0)\n\n    def get_card_position(self, x):\n        a, b = self.shuffle\n        return (a * x + b) % self.number_of_cards\n\n    def apply_shuffle(self, shuffle):\n        a1, b1 = self.shuffle\n        a2, b2 = shuffle\n        a = a1 * a2 % self.number_of_cards\n        b = (a1 * b2 + b1) % self.number_of_cards\n        self.shuffle = (a, b)\n\n    def deal(self):\n        shuffle = (-1, self.number_of_cards - 1)\n        self.apply_shuffle(shuffle)\n\n    def cut(self, n):\n        shuffle = (1, n)\n        self.apply_shuffle(shuffle)\n\n    def deal_with_increment(self, increment):\n        shuffle = (compute_inverse(self.number_of_cards, increment), 0)\n        self.apply_shuffle(shuffle)\n\n    def apply_instructions(self, instructions):\n        for instruction in instructions:\n            words = instruction.split(\" \")\n            if \" \".join(words[:-1]) == \"deal with increment\":\n                self.deal_with_increment(int(words[-1]))\n            elif instruction == \"deal into new stack\":\n                self.deal()\n            else:\n                self.cut(int(words[-1]))\n\n    def get_position_of_card(self, card):\n        a, b = self.shuffle\n        return compute_inverse(self.number_of_cards, a) * (card - b) % self.number_of_cards\n\n    def get_card_at_position(self, position):\n        a, b = self.shuffle\n        return (a * position + b) % self.number_of_cards\n\n    def apply_shuffle_repeatedly(self, n):\n        a, b = self.shuffle\n        if a == 1:\n            self.shuffle = (1, (b * n) % self.number_of_cards)\n        else:\n            power = compute_power(a, n, self.number_of_cards)\n            b = (compute_inverse(self.number_of_cards, a - 1) * (power - 1) * b) % self.number_of_cards\n            a = power % self.number_of_cards\n            self.shuffle = a, b\n\n# main function\ndef main_solution(number_of_cards, instructions, card_position):\n    # Convert JSON serializable inputs to original input variables\n    deck = Deck(number_of_cards)\n    deck.apply_instructions(instructions)\n    \n    # Get the card at the specified position\n    card = deck.get_card_at_position(card_position)\n    \n    # Convert the output to JSON serializable\n    return card", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a reasonable number of cards, e.g., between 10 and 1000\n    number_of_cards = random.randint(10, 1000)\n    \n    # Generate a list of instructions\n    instructions = []\n    num_instructions = random.randint(1, 10)\n    for _ in range(num_instructions):\n        instruction_type = random.randint(0, 2)\n        if instruction_type == 0:\n            instructions.append(\"deal into new stack\")\n        elif instruction_type == 1:\n            n = random.randint(-number_of_cards + 1, number_of_cards - 1)\n            instructions.append(f\"cut {n}\")\n        else:\n            increment = random.randint(1, number_of_cards - 1)\n            while math.gcd(increment, number_of_cards) != 1:\n                increment = random.randint(1, number_of_cards - 1)\n            instructions.append(f\"deal with increment {increment}\")\n    \n    # Generate a random card position within the deck\n    card_position = random.randint(0, number_of_cards - 1)\n    \n    return {\n        \"number_of_cards\": number_of_cards,\n        \"instructions\": instructions,\n        \"card_position\": card_position\n    }", "io_pairs": [{"input": {"number_of_cards": 590, "instructions": ["cut 569", "cut -571", "deal into new stack"], "card_position": 275}, "output": 312}, {"input": {"number_of_cards": 941, "instructions": ["deal with increment 78", "deal with increment 902", "deal into new stack", "deal into new stack", "deal with increment 335", "deal with increment 362", "cut -569"], "card_position": 294}, "output": 519}, {"input": {"number_of_cards": 105, "instructions": ["deal into new stack"], "card_position": 16}, "output": 88}, {"input": {"number_of_cards": 797, "instructions": ["cut -25", "deal with increment 291", "deal with increment 484", "deal into new stack", "cut 13", "deal into new stack"], "card_position": 250}, "output": 314}, {"input": {"number_of_cards": 338, "instructions": ["deal with increment 315"], "card_position": 333}, "output": 59}, {"input": {"number_of_cards": 738, "instructions": ["deal with increment 289", "deal into new stack", "cut -573", "deal into new stack", "cut -506", "deal with increment 521"], "card_position": 365}, "output": 512}, {"input": {"number_of_cards": 926, "instructions": ["deal into new stack", "deal with increment 649", "cut -683"], "card_position": 491}, "output": 239}, {"input": {"number_of_cards": 192, "instructions": ["cut -18", "deal into new stack", "cut 102"], "card_position": 63}, "output": 8}, {"input": {"number_of_cards": 655, "instructions": ["deal with increment 116", "cut -583", "cut -11", "cut 629", "deal into new stack"], "card_position": 143}, "output": 16}, {"input": {"number_of_cards": 63, "instructions": ["cut 30", "deal into new stack", "deal into new stack", "deal with increment 20", "deal into new stack", "deal with increment 20"], "card_position": 54}, "output": 61}], "error_log": []}
{"context": "Given a mathematical function and its derivative, how can we approximate the solution to the equation f(x) = 0 using the Newton-Raphson method, starting from a given initial guess and with specified stopping criteria and maximum iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `f_expr` (str): A string representing the mathematical function for which we are searching for a solution f(x)=0. The function should be in a format that can be evaluated using `eval`.\n  `Df_expr` (str): A string representing the derivative of the function `f_expr`. The derivative should be in a format that can be evaluated using `eval`.\n  `x0` (float): The initial guess for the solution f(x)=0.\n  `epsilon` (float): The stopping criteria for the Newton-Raphson method, where the method stops if abs(f(x)) < epsilon.\n  `max_iter` (int): The maximum number of iterations allowed for the Newton-Raphson method.\n\nOutput:\n  `return` (float or None): The approximate solution of f(x)=0 obtained by the Newton-Raphson method. If no solution is found within the maximum iterations or if the derivative is zero, it returns None.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef newton(f, Df, x0, epsilon, max_iter):\n    '''Approximate solution of f(x)=0 by Newton's method.\n\n    Parameters\n    ----------\n    f : function\n        Function for which we are searching for a solution f(x)=0.\n    Df : function\n        Derivative of f(x)\n    x0 : number\n        Initial guess for a solution f(x)=0.\n    epsilon : number\n        Stopping criteria is abs(f(x)) < epsilon.\n    max_iter : integer\n        Maximum number of iterations of Newton's method.\n\n    Returns\n    -------\n    xn : number\n        Implement Newton's method: compute the linear approximation\n        of f(x) at xn and find x intercept by the formula\n            x = xn - f(xn)/Df(xn)\n        Continue until abs(f(xn)) < epsilon and return xn.\n        If Df(xn) == 0, return None. If the number of iterations\n        exceeds max_iter, then return None.\n    '''\n\n    xn = x0\n    for n in range(0, max_iter):\n        fxn = f(xn)\n        if abs(fxn) < epsilon:\n            return xn\n        Dfxn = Df(xn)\n        if Dfxn == 0:\n            return None\n        xn = xn - fxn / Dfxn\n    return None\n\n# main function\ndef main_solution(f_expr, Df_expr, x0, epsilon, max_iter):\n    # Convert string expressions to lambda functions\n    f = eval(f_expr)\n    Df = eval(Df_expr)\n    \n    # Call the newton function with the converted inputs\n    result = newton(f, Df, x0, epsilon, max_iter)\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Randomly choose a type of function: linear, quadratic, cubic, or trigonometric\n    function_type = random.choice(['linear', 'quadratic', 'cubic', 'trigonometric'])\n    \n    if function_type == 'linear':\n        a = random.uniform(-10, 10)\n        b = random.uniform(-10, 10)\n        f_expr = f\"lambda x: {a} * x + {b}\"\n        Df_expr = f\"lambda x: {a}\"\n    elif function_type == 'quadratic':\n        a = random.uniform(-5, 5)\n        b = random.uniform(-5, 5)\n        c = random.uniform(-5, 5)\n        f_expr = f\"lambda x: {a} * x**2 + {b} * x + {c}\"\n        Df_expr = f\"lambda x: 2 * {a} * x + {b}\"\n    elif function_type == 'cubic':\n        a = random.uniform(-3, 3)\n        b = random.uniform(-3, 3)\n        c = random.uniform(-3, 3)\n        d = random.uniform(-3, 3)\n        f_expr = f\"lambda x: {a} * x**3 + {b} * x**2 + {c} * x + {d}\"\n        Df_expr = f\"lambda x: 3 * {a} * x**2 + 2 * {b} * x + {c}\"\n    else:  # trigonometric\n        a = random.uniform(0.1, 2)\n        b = random.uniform(0.1, 2)\n        f_expr = f\"lambda x: {a} * math.sin({b} * x)\"\n        Df_expr = f\"lambda x: {a * b} * math.cos({b} * x)\"\n    \n    x0 = random.uniform(-10, 10)\n    epsilon = 10 ** random.uniform(-6, -3)\n    max_iter = random.randint(10, 100)\n    \n    return {\n        'f_expr': f_expr,\n        'Df_expr': Df_expr,\n        'x0': x0,\n        'epsilon': epsilon,\n        'max_iter': max_iter\n    }", "io_pairs": [{"input": {"f_expr": "lambda x: 0.5723544567143518 * math.sin(1.6505054360872413 * x)", "Df_expr": "lambda x: 0.9446741421757974 * math.cos(1.6505054360872413 * x)", "x0": -6.922496474184843, "epsilon": 0.0008681173480416739, "max_iter": 16}, "output": -7.613322027851617}, {"input": {"f_expr": "lambda x: 1.6667260714623802 * math.sin(1.393282008909106 * x)", "Df_expr": "lambda x: 2.322219449148287 * math.cos(1.393282008909106 * x)", "x0": 2.9182707155210785, "epsilon": 0.0002991292192740366, "max_iter": 81}, "output": 2.254811733743955}, {"input": {"f_expr": "lambda x: 1.2736049328941492 * x**2 + 4.129766878394758 * x + -0.10809235853236032", "Df_expr": "lambda x: 2 * 1.2736049328941492 * x + 4.129766878394758", "x0": 7.628441303942317, "epsilon": 5.539161760569802e-06, "max_iter": 12}, "output": 0.025966030138029474}, {"input": {"f_expr": "lambda x: 0.15078751496678716 * math.sin(1.330500964172631 * x)", "Df_expr": "lambda x: 0.20062293404850537 * math.cos(1.330500964172631 * x)", "x0": 1.1951862135259148, "epsilon": 1.4210293677600021e-05, "max_iter": 48}, "output": 40.140575932110224}, {"input": {"f_expr": "lambda x: -5.723054328710515 * x + 7.3120628620329455", "Df_expr": "lambda x: -5.723054328710515", "x0": 6.594341817461416, "epsilon": 3.0303883917366317e-06, "max_iter": 27}, "output": 1.2776504366472539}, {"input": {"f_expr": "lambda x: 2.5763555129024525 * x**2 + -4.742060648235375 * x + -1.2591739367670742", "Df_expr": "lambda x: 2 * 2.5763555129024525 * x + -4.742060648235375", "x0": -7.170585305543165, "epsilon": 7.519694548540579e-05, "max_iter": 62}, "output": -0.23542166207839083}, {"input": {"f_expr": "lambda x: 1.5941593868705313 * math.sin(1.6398106849166385 * x)", "Df_expr": "lambda x: 2.6141195960504544 * math.cos(1.6398106849166385 * x)", "x0": -7.541016060041978, "epsilon": 1.4140049480983662e-06, "max_iter": 71}, "output": -7.663305723734371}, {"input": {"f_expr": "lambda x: 0.7908690395824287 * x**2 + 4.57335601766858 * x + -4.233366588163468", "Df_expr": "lambda x: 2 * 0.7908690395824287 * x + 4.57335601766858", "x0": 1.2274248738479052, "epsilon": 0.00035104881603045915, "max_iter": 92}, "output": 0.8117768438366657}, {"input": {"f_expr": "lambda x: 0.9580089551448712 * x**2 + -1.1523691617501242 * x + -3.985467408657175", "Df_expr": "lambda x: 2 * 0.9580089551448712 * x + -1.1523691617501242", "x0": -3.0585369727133216, "epsilon": 0.00022425757938832085, "max_iter": 29}, "output": -1.5250331026202155}, {"input": {"f_expr": "lambda x: 1.999361138816723 * math.sin(1.6859634417561755 * x)", "Df_expr": "lambda x: 3.3708497869129888 * math.cos(1.6859634417561755 * x)", "x0": 1.198891359594402, "epsilon": 1.354349881359645e-05, "max_iter": 36}, "output": 1.863381242903683}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = 3x - \\cos(x) - 1 \\), and an initial interval \\([a, b]\\), what are the midpoints \\( c \\) calculated during each iteration of the bisection method when performing \\( n \\) iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The initial lower bound of the interval.\n  `b` (float): The initial upper bound of the interval.\n  `n` (int): The number of iterations to perform.\n\nOutput:\n  `return` (list of floats): A list of midpoints `c` calculated during each iteration.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(a, b, n):\n    # Convert inputs to numpy arrays if necessary\n    a = np.float64(a)\n    b = np.float64(b)\n    n = int(n)\n    \n    # Function definition\n    def f(x):\n        return 3 * x - np.cos(x) - 1.0\n    \n    c = np.zeros(n)\n    \n    for i in range(n):\n        c[i] = (a + b) / 2.0\n        if np.sign(f(c[i])) == np.sign(f(a)):\n            a = c[i]\n        else:\n            b = c[i]\n    \n    # Convert output to JSON serializable format\n    return c.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    a = random.uniform(-10.0, 10.0)\n    b = random.uniform(a + 0.1, a + 20.0)  # Ensure b > a with some margin\n    n = random.randint(5, 20)\n    return {'a': a, 'b': b, 'n': n}", "io_pairs": [{"input": {"a": -8.43291480140422, "b": -4.417076396321306, "n": 5}, "output": [-6.424995598862763, -5.421035997592035, -4.919056196956671, -4.6680662966389885, -4.542571346480147]}, {"input": {"a": 1.932388582429855, "b": 17.168583747697124, "n": 12}, "output": [9.55048616506349, 13.359534956380307, 15.264059352038714, 16.21632154986792, 16.69245264878252, 16.930518198239824, 17.049550972968476, 17.1090673603328, 17.138825554014964, 17.153704650856042, 17.161144199276585, 17.164863973486852]}, {"input": {"a": -8.72591879528694, "b": -6.9977306510557025, "n": 8}, "output": [-7.861824723171321, -7.429777687113512, -7.213754169084607, -7.105742410070155, -7.051736530562929, -7.024733590809316, -7.011232120932509, -7.004481385994106]}, {"input": {"a": 8.966182326623311, "b": 28.383560629005615, "n": 16}, "output": [18.674871477814463, 23.52921605341004, 25.956388341207827, 27.16997448510672, 27.776767557056168, 28.08016409303089, 28.23186236101825, 28.307711495011933, 28.345636062008772, 28.364598345507193, 28.374079487256402, 28.37882005813101, 28.381190343568313, 28.382375486286964, 28.382968057646288, 28.38326434332595]}, {"input": {"a": -5.524781025500218, "b": 11.798917871316187, "n": 5}, "output": [3.1370684229079844, -1.1938563012961168, 0.9716060608059338, -0.11112512024509147, 0.4302404702804212]}, {"input": {"a": -4.615804444365694, "b": 10.57560276106976, "n": 17}, "output": [2.979899158352033, -0.8179526430068307, 1.0809732576726012, 0.13151030733288527, 0.6062417825027433, 0.8436075200876723, 0.7249246512952078, 0.6655832168989755, 0.6359124997008594, 0.6210771411018013, 0.6136594618022724, 0.6099506221525078, 0.6080962023276255, 0.6071689924151844, 0.6067053874589639, 0.6069371899370741, 0.6070530911761293]}, {"input": {"a": -5.7806874582898615, "b": 2.6645153675101163, "n": 9}, "output": [-1.5580860453898726, 0.5532146610601218, 1.608865014285119, 1.0810398376726205, 0.8171272493663712, 0.6851709552132466, 0.6191928081366842, 0.586203734598403, 0.6026982713675436]}, {"input": {"a": -0.8818643484415727, "b": 8.607249295548092, "n": 10}, "output": [3.8626924735532597, 1.4904140625558435, 0.3042748570571354, 0.8973444598064895, 0.6008096584318124, 0.7490770591191509, 0.6749433587754816, 0.6378765086036471, 0.6193430835177298, 0.6100763709747712]}, {"input": {"a": -0.025375617091826896, "b": 8.136935387270267, "n": 9}, "output": [4.05577988508922, 2.0152021339986965, 0.9949132584534348, 0.48476882068080396, 0.7398410395671193, 0.6123049301239616, 0.5485368754023827, 0.5804209027631722, 0.5963629164435669]}, {"input": {"a": 5.459537003489688, "b": 17.436002152479052, "n": 14}, "output": [11.44776957798437, 14.441885865231711, 15.938944008855382, 16.687473080667218, 17.061737616573133, 17.248869884526094, 17.342436018502575, 17.389219085490815, 17.412610618984935, 17.424306385731995, 17.430154269105522, 17.43307821079229, 17.43454018163567, 17.43527116705736]}], "error_log": []}
{"context": "In the context of Conway's Game of Life, given a game board with live and dead cells, what will be the state of the board after one iteration of the game rules? The rules are as follows:\n1. Any live cell with fewer than two live neighbors dies.\n2. Any live cell with more than three live neighbors dies.\n3. Any dead cell with exactly three live neighbors becomes a live cell.\n\nThe input variable names are `board`.\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (List[List[int]]): A 2D list representing the game board where each element is either 0 (dead cell) or 1 (live cell). The size of the board should be reasonable, typically less than 10x10 for simplicity.\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the updated game board after applying the rules of Conway's Game of Life. Each element is either 0 (dead cell) or 1 (live cell).", "reference_code": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\ndef count(board: List[List[int]], row: int, col: int) -> int:\n    count = 0\n    directions = ((-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1))\n\n    for i, j in directions:\n        newRow, newCol = row + i, col + j\n        if 0 <= newRow < len(board) and 0 <= newCol < len(board[0]) and (board[newRow][newCol] == 1 or board[newRow][newCol] == \"#\"):\n            count += 1\n    return count\n\n# main function\ndef main_solution(board: List[List[int]]) -> List[List[int]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    rows, cols = len(board), len(board[0])\n\n    for row in range(rows):\n        for col in range(cols):\n            neighbors = count(board, row, col)\n            if board[row][col] == 1 and (neighbors < 2 or neighbors > 3):\n                board[row][col] = '#'\n            elif board[row][col] == 0 and neighbors == 3:\n                board[row][col] = '*'\n\n    conversion_map = {'#': 0, '*': 1}\n    for row in range(rows):\n        for col in range(cols):\n            if board[row][col] in conversion_map:\n                board[row][col] = conversion_map[board[row][col]]\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return board", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(5, 15)\n    cols = random.randint(5, 15)\n    board = [[random.choice([0, 1]) for _ in range(cols)] for _ in range(rows)]\n    return {'board': board}", "io_pairs": [], "error_log": []}
{"context": "Imagine you are developing a ride-sharing app that needs to find the optimal pickup location for a passenger and a driver. Given the coordinates of the passenger's origin and the driver's destination, where should the passenger and driver meet to minimize the total travel time?\n\nThe input and output requirements are as follows:\n\nInput:\n  `origin` (list of float): A list containing the coordinates [x, y] of the starting point.\n  `destination` (list of float): A list containing the coordinates [x, y] of the ending point.\n\nOutput:\n  `return` (dict): A dictionary containing the key \"pickupLocation\" with a value of a list of floats representing the coordinates [x, y] of the optimal pickup location.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef timeOfPassenger(coordinates):\n    # Simulate time calculation for a passenger\n    return sum(coordinates) * random.uniform(0.8, 1.2)\n\ndef timeOfDriver(coordinates):\n    # Simulate time calculation for a driver\n    return sum(coordinates) * random.uniform(0.8, 1.2)\n\ndef getMidPoint(origin, destination):\n    # Calculate the midpoint between two coordinates\n    return [(origin[0] + destination[0]) / 2, (origin[1] + destination[1]) / 2]\n\ndef BinarySearch(origin, destination):\n    midpointOfOriginalRoute = getMidPoint(origin, destination)\n    \n    if abs(timeOfPassenger(midpointOfOriginalRoute) - timeOfDriver(midpointOfOriginalRoute)) < 0.1:\n        return midpointOfOriginalRoute\n    \n    if timeOfPassenger(midpointOfOriginalRoute) < timeOfDriver(midpointOfOriginalRoute):\n        return BinarySearch(midpointOfOriginalRoute, destination)\n    else:\n        return BinarySearch(origin, midpointOfOriginalRoute)\n\n# main function\ndef main_solution(origin, destination):\n    # Convert input to JSON serializable format if necessary\n    origin = list(origin)\n    destination = list(destination)\n    \n    # Call the main logic function\n    pickupLocation = BinarySearch(origin, destination)\n    \n    # Convert output to JSON serializable format\n    return {\"pickupLocation\": pickupLocation}", "input_generator": "import random\n\ndef input_generator():\n    origin = [random.uniform(-100, 100), random.uniform(-100, 100)]\n    destination = [random.uniform(-100, 100), random.uniform(-100, 100)]\n    return {\"origin\": origin, \"destination\": destination}", "io_pairs": [{"input": {"origin": [-49.284454606391016, 65.59169752598677], "destination": [-68.72603825002774, -12.58001928115604]}, "output": {"pickupLocation": [-66.6969278335392, -4.421268031481808]}}, {"input": {"origin": [-59.83046867119073, 33.23067246059594], "destination": [-63.25300177330744, -23.325397533615046]}, "output": {"pickupLocation": [-62.21889052454405, -6.237098773058955]}}, {"input": {"origin": [-32.68001436334612, 65.05725564135903], "destination": [-78.64532823800074, 27.38696987597615]}, "output": {"pickupLocation": [-77.28277481909339, 28.50363312341547]}}, {"input": {"origin": [-81.35095851962035, -53.152350176009456], "destination": [92.78810904327847, 68.21013338205944]}, "output": {"pickupLocation": [87.7057802160478, 64.66811344728117]}}, {"input": {"origin": [-12.197383117022383, -6.205846397503009], "destination": [5.735307605775915, -32.95393509488191]}, "output": {"pickupLocation": [2.128255313895575, -27.573718811073512]}}, {"input": {"origin": [-1.5178945578774972, 27.41421431882189], "destination": [-97.28891043537995, -92.89732905950608]}, "output": {"pickupLocation": [-36.19591353539953, -16.149759042650054]}}, {"input": {"origin": [83.36007333933898, 35.03943582583523], "destination": [-85.18371558790858, -69.4344815542712]}, "output": {"pickupLocation": [-59.51809164128096, -53.52533240807345]}}, {"input": {"origin": [91.45130611843456, 32.83068418211593], "destination": [92.68772924948411, -53.4519176328494]}, "output": {"pickupLocation": [92.0880386524087, -11.603084737175191]}}, {"input": {"origin": [62.979248521114556, -30.917104421145908], "destination": [55.10393653892547, -47.50772330571389]}, "output": {"pickupLocation": [58.623982091558545, -40.09217781975326]}}, {"input": {"origin": [97.36446079607998, -67.49818813154741], "destination": [-59.071518827332326, 18.876435436906732]}, "output": {"pickupLocation": [30.145875801645005, -30.384092066977274]}}], "error_log": []}
{"context": "Given a base number, an exponent, and a modulus value, what is the result of raising the base to the exponent and then taking the modulus of the result with the given modulus value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `base` (int): The base number for the exponentiation.\n  `exp` (int): The exponent to which the base is raised.\n  `modN` (int): The modulus value for the operation.\n\nOutput:\n  `return` (int): The result of the exponentiation operation modulo `modN`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef squareAndMultiply(base, exp, modN):\n    expBin = str(bin(exp)[2:])\n    z = 1\n    for i in range(len(expBin) - 1, -1, -1):\n        z = z * z % modN\n        if expBin[len(expBin) - 1 - i] == '1':\n            z = z * base % modN\n    return z\n\n# main function\ndef main_solution(base, exp, modN):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = squareAndMultiply(base, exp, modN)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    base = random.randint(1, 1000)\n    exp = random.randint(1, 1000)\n    modN = random.randint(2, 1000)\n    return {'base': base, 'exp': exp, 'modN': modN}", "io_pairs": [{"input": {"base": 260, "exp": 656, "modN": 415}, "output": 250}, {"input": {"base": 821, "exp": 570, "modN": 669}, "output": 355}, {"input": {"base": 649, "exp": 348, "modN": 283}, "output": 216}, {"input": {"base": 327, "exp": 835, "modN": 149}, "output": 16}, {"input": {"base": 924, "exp": 266, "modN": 601}, "output": 222}, {"input": {"base": 878, "exp": 988, "modN": 478}, "output": 226}, {"input": {"base": 167, "exp": 522, "modN": 536}, "output": 265}, {"input": {"base": 325, "exp": 216, "modN": 249}, "output": 64}, {"input": {"base": 530, "exp": 75, "modN": 52}, "output": 12}, {"input": {"base": 859, "exp": 189, "modN": 836}, "output": 419}], "error_log": []}
{"context": "Given a string of digits, what is the first prime number that can be formed by permuting these digits?\n\nThe input and output requirements are as follows:\n\nInput:\n  `digits` (str): A string of digits from which permutations will be generated to check for prime numbers. The string should contain only numeric characters.\n\nOutput:\n  `return` (str or None): A string representing the first prime number found by permuting the input digits. If no prime number is found, the function returns `None`.", "reference_code": "# import necessary packages\nimport itertools\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    if n % 2 == 0 and n > 2: \n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(digits):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert the input string to a list of characters\n    digit_list = list(digits)\n    \n    # Generate all permutations of the digit list\n    permutations = itertools.permutations(digit_list)\n    \n    # Check each permutation to see if it forms a prime number\n    for perm in permutations:\n        num_str = \"\".join(perm)\n        num = int(num_str)\n        if is_prime(num):\n            return num_str\n    \n    # If no prime number is found, return None\n    return None", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random length between 2 and 5 to avoid trivial or too large inputs\n    length = random.randint(2, 5)\n    \n    # Generate a string of digits, ensuring at least one odd digit (since primes > 2 are odd)\n    digits = []\n    for _ in range(length - 1):\n        digits.append(random.choice(string.digits))\n    # Ensure at least one odd digit\n    digits.append(random.choice('13579'))\n    random.shuffle(digits)\n    \n    # Join the digits into a string\n    digits_str = ''.join(digits)\n    \n    return {'digits': digits_str}", "io_pairs": [{"input": {"digits": "3137"}, "output": "3137"}, {"input": {"digits": "24035"}, "output": "20543"}, {"input": {"digits": "76951"}, "output": "76519"}, {"input": {"digits": "25292"}, "output": "25229"}, {"input": {"digits": "1903"}, "output": "1093"}, {"input": {"digits": "17374"}, "output": "13477"}, {"input": {"digits": "9161"}, "output": "9161"}, {"input": {"digits": "635"}, "output": "653"}, {"input": {"digits": "14"}, "output": "41"}, {"input": {"digits": "66641"}, "output": "64661"}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, given the current state of the board and the player whose turn it is, what is the optimal move for the player to make? The board is represented as a 3x3 grid, where each cell can be 'X', 'O', or ' '. The player can be either 'X' or 'O'. The optimal move is the one that maximizes the player's chances of winning or minimizes the opponent's chances of winning.\n\nThe input and output requirements are as follows:\n\nInput:\n  `state` (list of lists of strings): A 3x3 grid representing the Tic-Tac-Toe board. Each cell can be 'X', 'O', or ' '.\n  `player` (string): The current player, either 'X' or 'O'.\n\nOutput:\n  `return` (integer): The index of the best move for the current player. The index is a number between 1 and 9, representing the position on the board from top-left to bottom-right.", "reference_code": "# import necessary packages\nimport copy\nfrom math import inf as infinity\n\n# all class and function definitions in the code file, if any\ndef check_current_state(state):\n    '''\n    Check if the game is over\n    '''\n    # Check for winning rows\n    for row in range(3):\n        if (state[row][0] == state[row][1] == state[row][2]) and (state[row][0] is not ' '):\n            return state[row][0], \"Done\"\n    # Check for winning columns\n    for col in range(3):\n        if (state[0][col] == state[1][col] == state[2][col]) and (state[0][col] is not ' '):\n            return state[0][col], \"Done\"\n    # Check for winning diagonals\n    if (state[0][0] == state[1][1] == state[2][2]) and (state[0][0] is not ' '):\n        return state[0][0], \"Done\"\n    if (state[0][2] == state[1][1] == state[2][0]) and (state[0][2] is not ' '):\n        return state[0][2], \"Done\"\n    # Check for draw\n    draw_flag = 0\n    for i in range(3):\n        for j in range(3):\n            if state[i][j] is ' ':\n                draw_flag = 1\n    if draw_flag is 0:\n        return None, \"Draw\"\n    return None, \"Not Done\"\n\ndef play_move(state, player, block_num):\n    '''\n    Play a move on the board\n    '''\n    if state[int((block_num-1)/3)][(block_num-1)%3] is ' ':\n        state[int((block_num-1)/3)][(block_num-1)%3] = player\n    else:\n        return \"Invalid\"\n\ndef copy_game_state(state):\n    '''\n    Copy the game state\n    '''\n    new_state = [row[:] for row in state]\n    return new_state\n\n# main function\ndef main_solution(state, player):\n    '''\n    Main function to get the best move using the minimax algorithm\n    '''\n    # Convert state to a list of lists if it's not already\n    if not isinstance(state, list):\n        state = [list(row) for row in state]\n    \n    # Get the best move using the minimax algorithm\n    best_move = getBestMove(state, player)\n    \n    # Return the best move as an integer\n    return best_move\n\ndef getBestMove(state, player):\n    '''\n    Minimax Algorithm\n    '''\n    winner_loser , done = check_current_state(state)\n    if done == \"Done\" and winner_loser == 'O': # If AI won\n        return 1\n    elif done == \"Done\" and winner_loser == 'X': # If Human won\n        return -1\n    elif done == \"Draw\":    # Draw condition\n        return 0\n\n    moves = []\n    empty_cells = []\n    for i in range(3):\n        for j in range(3):\n            if state[i][j] is ' ':\n                empty_cells.append( i *3 + ( j +1))\n\n    for empty_cell in empty_cells:\n        move = {}\n        move['index'] = empty_cell\n        new_state = copy_game_state(state)\n        play_move(new_state, player, empty_cell)\n\n        if player == 'O':    # If AI\n            result = getBestMove(new_state, 'X')    # make more depth tree for human\n            move['score'] = result\n        else:\n            result = getBestMove(new_state, 'O')    # make more depth tree for AI\n            move['score'] = result\n\n        moves.append(move)\n\n    # Find best move\n    best_move = None\n    if player == 'O':   # If AI player\n        best = -infinity\n        for move in moves:\n            if move['score'] > best:\n                best = move['score']\n                best_move = move['index']\n    else:\n        best = infinity\n        for move in moves:\n            if move['score'] < best:\n                best = move['score']\n                best_move = move['index']\n\n    return best_move", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random Tic-Tac-Toe board state\n    state = [[' ' for _ in range(3)] for _ in range(3)]\n    players = ['X', 'O']\n    current_player = random.choice(players)\n    \n    # Randomly fill some cells\n    empty_cells = [(i, j) for i in range(3) for j in range(3)]\n    num_moves = random.randint(0, 8)  # Up to 8 moves to leave at least one empty cell\n    \n    for _ in range(num_moves):\n        if not empty_cells:\n            break\n        i, j = random.choice(empty_cells)\n        state[i][j] = current_player\n        current_player = 'O' if current_player == 'X' else 'X'\n        empty_cells.remove((i, j))\n    \n    # Ensure the game is not already over\n    winner, done = check_current_state(state)\n    if done == \"Done\" or done == \"Draw\":\n        # Reset to a nearly empty board if the game is already over\n        state = [[' ' for _ in range(3)] for _ in range(3)]\n        state[0][0] = 'X' if random.random() > 0.5 else 'O'\n    \n    # Randomly choose the player ('X' or 'O')\n    player = random.choice(['X', 'O'])\n    \n    return {'state': state, 'player': player}", "io_pairs": [{"input": {"state": [[" ", "O", " "], [" ", " ", " "], ["X", " ", " "]], "player": "O"}, "output": 4}, {"input": {"state": [[" ", " ", "O"], [" ", "X", "X"], [" ", " ", "O"]], "player": "X"}, "output": 4}, {"input": {"state": [[" ", "O", " "], [" ", " ", "O"], ["X", "X", " "]], "player": "X"}, "output": 9}, {"input": {"state": [[" ", " ", " "], [" ", " ", " "], [" ", " ", "X"]], "player": "O"}, "output": 1}, {"input": {"state": [["X", " ", " "], [" ", " ", " "], [" ", " ", " "]], "player": "X"}, "output": 3}, {"input": {"state": [[" ", "X", " "], ["X", "O", "O"], ["X", " ", " "]], "player": "O"}, "output": 1}, {"input": {"state": [[" ", " ", " "], [" ", "O", "X"], [" ", " ", " "]], "player": "X"}, "output": 2}, {"input": {"state": [["O", " ", " "], [" ", " ", "X"], [" ", " ", " "]], "player": "X"}, "output": 3}, {"input": {"state": [[" ", " ", " "], [" ", " ", "X"], [" ", " ", " "]], "player": "X"}, "output": 3}, {"input": {"state": [[" ", "X", "X"], [" ", "O", "X"], ["O", "O", " "]], "player": "X"}, "output": 1}], "error_log": []}
{"context": "Given the parameters of a fluid flow system, including the friction factor, pipe length, flow rate, head loss, and kinematic viscosity, what are the calculated values for the pipe diameter, Reynolds number, and friction coefficient?\n\nThe input and output requirements are as follows:\n\nInput:\n  `f` (float): The friction factor.\n  `L` (float): The length of the pipe.\n  `Q` (float): The flow rate.\n  `dH` (float): The head loss.\n  `v` (float): The kinematic viscosity.\n\nOutput:\n  `return` (dict): A dictionary containing the calculated values:\n    - `D` (float): The diameter of the pipe, rounded to 4 decimal places.\n    - `Rey` (float): The Reynolds number, rounded to 4 decimal places.\n    - `k` (float): The friction coefficient, rounded to 4 decimal places.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(f, L, Q, dH, v):\n    # Convert inputs to appropriate types\n    f = float(f)\n    L = float(L)\n    Q = float(Q)\n    dH = float(dH)\n    v = float(v)\n    \n    g = 9.81\n    e = 0.000002\n    \n    D = ((8 * f * L * (Q ** 2)) / ((math.pi ** 2) * g * dH)) ** 0.2\n    Rey = (4 * Q) / (math.pi * D * v)\n    k = (0.25 / ((math.log10((e / (3.7 * D)) + (5.74 / (Rey ** 0.9)))) ** 2))\n    \n    # Return JSON serializable outputs\n    return {\n        \"D\": round(D, 4),\n        \"Rey\": round(Rey, 4),\n        \"k\": round(k, 4)\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    f = random.uniform(0.001, 0.1)\n    L = random.uniform(10, 1000)\n    Q = random.uniform(0.1, 10)\n    dH = random.uniform(1, 100)\n    v = random.uniform(1e-6, 1e-4)\n    \n    return {\n        \"f\": f,\n        \"L\": L,\n        \"Q\": Q,\n        \"dH\": dH,\n        \"v\": v\n    }", "io_pairs": [{"input": {"f": 0.0208255586134106, "L": 934.2516745393272, "Q": 8.121469108763952, "dH": 34.588892453143714, "v": 9.528894714074436e-05}, "output": {"D": 1.2511, "Rey": 86735.9868, "k": 0.0184}}, {"input": {"f": 0.02102193255697462, "L": 813.3632570454615, "Q": 5.118953627238242, "dH": 28.94326758165448, "v": 2.869115524362145e-05}, "output": {"D": 1.0505, "Rey": 216254.2383, "k": 0.0153}}, {"input": {"f": 0.07300366546059114, "L": 867.0657736550049, "Q": 1.149970342184216, "dH": 27.490285821171728, "v": 4.579835628486924e-05}, "output": {"D": 0.7588, "Rey": 42131.2625, "k": 0.0216}}, {"input": {"f": 0.01980896671455908, "L": 183.31036648205315, "Q": 3.6784048052674065, "dH": 40.94939954510076, "v": 3.786495587208413e-05}, "output": {"D": 0.6299, "Rey": 196373.9462, "k": 0.0156}}, {"input": {"f": 0.002686320812719306, "L": 434.4191339260495, "Q": 1.3240959713761034, "dH": 32.99294106095077, "v": 2.138038855443553e-05}, "output": {"D": 0.3483, "Rey": 226408.5371, "k": 0.0152}}, {"input": {"f": 0.03253067272570069, "L": 792.329555749041, "Q": 9.264382390272353, "dH": 1.7238225194191639, "v": 6.543980520053244e-05}, "output": {"D": 2.5415, "Rey": 70923.8801, "k": 0.0192}}, {"input": {"f": 0.08067321851910077, "L": 369.5276088428934, "Q": 3.067517136023264, "dH": 27.942681864549748, "v": 8.796184445407487e-05}, "output": {"D": 0.9633, "Rey": 46093.7567, "k": 0.0212}}, {"input": {"f": 0.061863840391756, "L": 707.826458966665, "Q": 2.8534081909812166, "dH": 78.21668910640004, "v": 9.399532149844444e-05}, "output": {"D": 0.8226, "Rey": 46987.8018, "k": 0.0211}}, {"input": {"f": 0.037574597925311426, "L": 133.547305759762, "Q": 1.5160952358078077, "dH": 55.67649148989374, "v": 4.4784606551345924e-05}, "output": {"D": 0.4433, "Rey": 97234.7442, "k": 0.018}}, {"input": {"f": 0.07336240791455491, "L": 665.5627805704243, "Q": 1.0037755222509954, "dH": 10.244049135617235, "v": 7.003145153157216e-05}, "output": {"D": 0.8312, "Rey": 21955.1553, "k": 0.0252}}], "error_log": []}
{"context": "Given a 3x3 matrix with integer elements, what is the inverse of this matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_elements` (list of lists of floats): A 2D list representing the elements of a square matrix. Each sublist represents a row in the matrix.\n\nOutput:\n  `return` (list of lists of floats): A 2D list representing the elements of the inverse of the input matrix. Each sublist represents a row in the inverse matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix_elements):\n    # Convert the JSON serializable input to a numpy array\n    A = np.array(matrix_elements)\n    \n    # Calculate the inverse of the matrix\n    inverse_matrix = np.linalg.inv(A)\n    \n    # Convert the inverse matrix to a JSON serializable output\n    inverse_matrix_list = inverse_matrix.tolist()\n    \n    return inverse_matrix_list", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.choice([2, 3, 4])\n    while True:\n        matrix = np.random.rand(size, size) * 10 - 5  # Values between -5 and 5\n        if np.linalg.det(matrix) != 0:  # Ensure matrix is invertible\n            break\n    return {'matrix_elements': matrix.tolist()}", "io_pairs": [{"input": {"matrix_elements": [[4.625106595798931, 1.1305480072431653], [0.05313057086926598, -1.7044779333449176]]}, "output": [[0.2145762919878885, 0.14232440007743102], [0.006688594005998085, -0.5822534888601757]]}, {"input": {"matrix_elements": [[-1.9030740741016094, 4.348341980456695], [-2.766067134453624, 4.762609683446419]]}, "output": [[1.6067062657912192, -1.4669495865021311], [0.9331559149121272, -0.6420179780324168]]}, {"input": {"matrix_elements": [[1.5764626995228062, -4.859725697608692], [-2.3973781427119634, 2.771755482791005]]}, "output": [[-0.38068172886620993, -0.6674502104775736], [-0.32926355220723774, -0.21651640978919823]]}, {"input": {"matrix_elements": [[-4.235834806004577, -2.1759608415074227], [1.4877246049541712, 1.1092604470863403]]}, "output": [[-0.7590325573941299, -1.488942589323485], [1.0180038552376525, 2.8984505252538493]]}, {"input": {"matrix_elements": [[-2.7637474750119875, 1.1941891178805548], [0.18632668756148263, -3.149123414573097]]}, "output": [[-0.3713206847292455, -0.14080969926284495], [-0.02197022602813458, -0.32588008462643675]]}, {"input": {"matrix_elements": [[2.6517343785590066, 4.974687744023809, 3.6854884782428528], [-0.2897970691514695, 0.5447027428228317, -4.7445549819720725], [-2.6418725686229116, 2.829428766225133, 2.6081127809415907]]}, "output": [[0.13775763044581918, -0.02363283436032576, -0.23765515292507158], [0.12333051686138763, 0.15453152171627071, 0.10683974418532559], [0.005744840844984045, -0.1915833062508595, 0.026781788591234947]]}, {"input": {"matrix_elements": [[2.796844307525558, -1.1552917290018616], [2.381994371675863, 2.0787527259537804]]}, "output": [[0.24267920480349, 0.13487187514406393], [-0.2780804531233793, 0.3265111545184144]]}, {"input": {"matrix_elements": [[0.6429098153934607, -1.5399440042901205], [-3.9147403412910107, -1.6888871743495324]]}, "output": [[0.23739386815009994, -0.21645807337827927], [-0.5502649120301627, -0.09036888328949642]]}, {"input": {"matrix_elements": [[-3.688261896811844, -1.9325709677066651], [-3.996719237296862, 2.271944846195919]]}, "output": [[-0.14108416886865544, -0.12000958967604963], [-0.2481899209567207, 0.22903520970277866]]}, {"input": {"matrix_elements": [[4.83990107435903, -2.5715422907527374], [-0.7210176701705056, 4.869643006397119]]}, "output": [[0.22425804447807246, 0.11842532289518777], [0.03320449004868742, 0.22288836142140905]]}], "error_log": []}
{"context": "Given a set of data points, each with the same number of dimensions, what are the mean and covariance matrix of the data set?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data_points` (list of lists): A list of lists where each inner list represents a data point with the same number of dimensions. Each inner list should contain numerical values.\n\nOutput:\n  `mean` (list): A list representing the mean of the data set. The length of the list is equal to the number of dimensions in each data point.\n  `cov` (list of lists): A list of lists representing the covariance matrix of the data set. The size of the matrix is (number of dimensions) x (number of dimensions).", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(data_points):\n    \"\"\"\n    Calculate the mean and covariance of a data set.\n\n    Args:\n        data_points (list of lists): A list of lists where each inner list represents a data point with the same number of dimensions.\n\n    Returns:\n        mean (list): A list representing the mean of the data set.\n        cov (list of lists): A list of lists representing the covariance matrix of the data set.\n    \"\"\"\n    # Convert the input list of lists to a numpy array\n    X = np.array(data_points)\n    \n    # Calculate the mean and covariance using the provided function\n    mean, cov = mean_cov(X)\n    \n    # Convert the numpy arrays to lists for JSON serialization\n    mean_list = mean.tolist()[0]\n    cov_list = cov.tolist()\n    \n    return mean_list, cov_list\n\ndef mean_cov(X):\n    \"\"\"\n    X is a numpy.ndarray of shape (n, d) containing the data set:\n    n is the number of data points\n    d is the number of dimensions in each data point\n    Returns: mean, cov:\n        mean numpy.ndarray of shape (1, d) containing the mean of the data set\n        cov numpy.ndarray of shape (d, d) containing the covariance matrix\n            of the data set\n    \"\"\"\n    if not isinstance(X, np.ndarray) or len(X.shape) != 2:\n        raise TypeError(\"X must be a 2D numpy.ndarray\")\n    if X.shape[0] < 2:\n        raise ValueError(\"X must contain multiple data points\")\n    d = X.shape[1]\n    mean = np.mean(X, axis=0)\n    a = X - mean\n    c = np.matmul(a.T, a)\n    cov = c/(X.shape[0] - 1)\n    return mean.reshape((1, d)), cov", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the number of data points (between 2 and 100)\n    n = random.randint(2, 100)\n    # Randomly choose the number of dimensions (between 1 and 10)\n    d = random.randint(1, 10)\n    # Generate random data points\n    data_points = [[random.uniform(-10, 10) for _ in range(d)] for _ in range(n)]\n    return {'data_points': data_points}", "io_pairs": [{"input": {"data_points": [[-2.218801226974099, -0.6616968438857924], [-4.411197769552018, -7.545466291608404], [-7.40481303439646, 6.900000884410662], [7.407985863835272, 1.1209548528953643]]}, "output": [[-1.6567065417718263, -0.0465518495470425], [[41.037516339291706, -2.7816573172726007], [-2.7816573172726007, 35.409929319773234]]]}, {"input": {"data_points": [[-5.814795322440796, 1.054679705921167, -8.933951922659295], [1.749209345872071, 6.742828245637934, -6.888307273472519]]}, "output": [[-2.0327929882843625, 3.8987539757795506, -7.911129598065907], [[28.607083311129422, 21.512591054237323, 7.736632838079007], [21.512591054237323, 16.177516904940997, 5.817965312025591], [7.736632838079007, 5.817965312025591, 2.092331015373245]]]}, {"input": {"data_points": [[2.9049416850879677, -2.0141633709961093, 0.7731272145243491], [-1.0498711584800482, 1.2035341589236754, -5.92726462174787], [0.4675001184740939, 6.113667226442384, 9.067216475133073]]}, "output": [[0.7741902150273378, 1.767679338123317, 1.304359689303184], [[3.9806802684055125, -4.181001463326814, 4.839105449875533], [-4.181001463326814, 16.754102392574993, 19.913002612212182], [4.839105449875533, 19.913002612212182, 56.42027179787471]]]}, {"input": {"data_points": [[1.4757212241385016, 3.927324740907853], [-0.1212659704331287, -6.538394171143683], [2.303970038768803, -4.301234481755378]]}, "output": [[1.219475097491392, -2.304101303997069], [[1.5196889831486629, 2.553994149880985], [2.553994149880985, 30.374223783795543]]]}, {"input": {"data_points": [[-7.1307049995632354], [6.210230562326924], [-9.295739950377905], [-8.366846110182195], [-4.267751704717899]]}, "output": [[-4.570162440502862], [[39.902648358696354]]]}, {"input": {"data_points": [[2.9013054645169944], [-8.872028369197231], [-2.092051418845438], [-7.927836884144092]]}, "output": [[-3.9976528019174418], [[30.144275294750624]]]}, {"input": {"data_points": [[-5.6514236187625055, 7.0126462746696845], [-0.28655872024534546, -0.8045626771308783], [-1.6352796345263307, 4.833306172839848]]}, "output": [[-2.5244206578447272, 3.6804632567928848], [[7.788372664346149, -9.71578752989772], [-9.71578752989772, 16.273974040837462]]]}, {"input": {"data_points": [[2.395888779768857, -7.936163316901512, -7.020583074430595], [0.41289742963275344, -4.024094492846945, 1.1764377771314223]]}, "output": [[1.4043931047008051, -5.9801289048742285, -2.9220726486495865], [[1.966127347357303, -3.8787993196186616, -8.127310722766378], [-3.8787993196186616, 7.652141242069839, 16.033654861760493], [-8.127310722766378, 16.033654861760493, 33.59557542047125]]]}, {"input": {"data_points": [[3.181453672676737], [-3.6251139777903107], [-6.266105252190317], [3.7354372212641103]]}, "output": [[-0.7435820840099452], [[24.756335942083037]]]}, {"input": {"data_points": [[8.526492280940342, 4.813365095809294, -7.592075282051061], [-8.256682213208212, 6.584118777292623, 8.69402765173323], [7.022706859271814, 9.167974151732658, 9.615086878456594], [4.744296936603172, 8.869071064642707, 1.1800211979431285]]}, "output": [[3.0092034659017792, 7.358632272369321, 2.974265111520473], [[58.826471614662864, 1.521719542300497, -33.06532092065503], [1.521719542300497, 4.211133178584037, 10.58984914350885], [-33.06532092065503, 10.58984914350885, 63.894352596954825]]]}], "error_log": []}
{"context": "In a festive logistics operation, Santa's elves need to calculate the total weighted reindeer weariness for a set of trips. Each trip consists of multiple stops, and each stop has a specific weight. The weariness is calculated based on the distance traveled and the weight carried at each stop. Given the details of all trips, including the latitude, longitude, and weight of each stop, what is the total weighted reindeer weariness?\n\nThe input and output requirements are as follows:\n\nInput:\n  `all_trips_data` (list of dictionaries): Each dictionary represents a trip with keys `'TripId'` (str), `'Latitude'` (float), `'Longitude'` (float), and `'Weight'` (float).\n\nOutput:\n  `return` (float): The total weighted reindeer weariness, which is the sum of the weighted distances for all trips.", "reference_code": "# import necessary packages\nimport pandas as pd\nimport numpy as np\nfrom math import radians, cos, sin, asin, sqrt\n\n# all class and function definitions in the code file, if any\ndef haversine(lat1, lon1, lat2, lon2):\n    \"\"\" Calculate the great-circle distance between two points on the Earth surface.\n    Takes 4 numbers, containing the latitude and longitude of each point in decimal degrees.\n\n    The default returned unit is kilometers.\n    \"\"\"\n    avg_earth_radius = 6371.0\n    lat1, lon1, lat2, lon2 = map(radians, (lat1, lon1, lat2, lon2))\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    d = sin(dlat * 0.5) ** 2 + cos(lat1) * cos(lat2) * sin(dlon * 0.5) ** 2\n    c = 2.0 * avg_earth_radius\n    return c  * asin(sqrt(d))\n\ndef weighted_trip_length(stops_latitude, stops_longitude, weights):\n    north_pole = (90,0)\n    sleigh_weight = 10\n    dist = 0.0\n    prev_lat, prev_lon = north_pole\n    prev_weight = np.sum(weights) + sleigh_weight\n    for lat, lon, weight in zip(stops_latitude, stops_longitude, weights):\n        dist += haversine(lat, lon, prev_lat, prev_lon) * prev_weight\n        prev_lat, prev_lon = lat, lon\n        prev_weight -= weight\n    dist += haversine(north_pole[0], north_pole[1], prev_lat, prev_lon) * sleigh_weight\n    return dist\n\ndef weighted_reindeer_weariness(all_trips, weight_limit = 1000):\n    uniq_trips = all_trips['TripId'].unique()\n    \n    if any(all_trips.groupby('TripId')['Weight'].sum() > weight_limit):\n        raise Exception(\"One of the sleighs over weight limit!\")\n \n    dist = 0.0\n    for t in uniq_trips:\n        this_trip = all_trips[all_trips['TripId']==t]\n        dist += weighted_trip_length(this_trip['Latitude'], this_trip['Longitude'], this_trip['Weight'])\n    \n    return dist    \n\n# main function\ndef main_solution(all_trips_data):\n    # Convert input data to DataFrame\n    all_trips = pd.DataFrame(all_trips_data)\n    \n    # Calculate weighted reindeer weariness\n    weariness = weighted_reindeer_weariness(all_trips)\n    \n    # Return the result as a float\n    return weariness", "input_generator": "import numpy as np\nimport pandas as pd\nimport random\n\ndef input_generator():\n    num_trips = random.randint(1, 5)\n    trip_ids = []\n    latitudes = []\n    longitudes = []\n    weights = []\n    \n    for trip_id in range(num_trips):\n        num_stops = random.randint(1, 10)\n        trip_ids.extend([trip_id] * num_stops)\n        # Generate random latitudes (-90 to 90) and longitudes (-180 to 180)\n        trip_lats = [random.uniform(-90, 90) for _ in range(num_stops)]\n        trip_lons = [random.uniform(-180, 180) for _ in range(num_stops)]\n        trip_weights = [random.uniform(1, 100) for _ in range(num_stops)]\n        \n        latitudes.extend(trip_lats)\n        longitudes.extend(trip_lons)\n        weights.extend(trip_weights)\n    \n    all_trips_data = {\n        'TripId': trip_ids,\n        'Latitude': latitudes,\n        'Longitude': longitudes,\n        'Weight': weights\n    }\n    \n    return {'all_trips_data': all_trips_data}", "io_pairs": [], "error_log": []}
{"context": "Given a mathematical function that calculates a specific value based on an integer input, what is the result of the function when applied to a randomly chosen integer between 2 and 10?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer representing the input value for the function.\n\nOutput:\n  `return` (float): A floating-point number representing the result of the calculation.", "reference_code": "# import necessary packages\nfrom math import pi, atan, sqrt, log, factorial\n\n# main function\ndef main_solution(n):\n    # Convert the input to the required format for the original function\n    n = int(n)\n    \n    # Calculate the result using the original function logic\n    result = (-1) * (1 * n * (pi * n - atan(sqrt(sqrt(5) - 1))) - log(factorial(n))) / log(n)\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\nfrom math import factorial\n\ndef input_generator():\n    n = random.randint(1, 20)  # Reasonable range to avoid factorial becoming too large\n    return {'n': n}", "io_pairs": [{"input": {"n": 6}, "output": -56.641746476112694}, {"input": {"n": 3}, "output": -21.816363518581}, {"input": {"n": 13}, "output": -193.95287965710807}, {"input": {"n": 2}, "output": -14.710666769527684}, {"input": {"n": 20}, "output": -399.74726485522126}, {"input": {"n": 12}, "output": -169.96321782439395}, {"input": {"n": 5}, "output": -43.22062284210694}, {"input": {"n": 7}, "output": -71.71189116741844}, {"input": {"n": 15}, "output": -246.07550798543315}, {"input": {"n": 16}, "output": -274.17096636390755}], "error_log": []}
{"context": "Given a list of words, each composed of alphabetic characters and having no more than 10 unique characters, determine the highest square number that can be formed by mapping the letters of these words to digits in such a way that the anagram property between the words and the numbers is preserved. What is the largest square number that can be derived from these mappings?\n\nThe input and output requirements are as follows:\n\nInput:\n  `words` (list of strings): A list of words where each word is a string. The words should be composed of alphabetic characters and should not exceed 10 unique characters.\n\nOutput:\n  `return` (int): The highest square number found that can be formed by mapping letters to digits in a way that preserves the anagram property between words and numbers.", "reference_code": "# import necessary packages\nfrom collections import defaultdict\nfrom itertools import groupby\nfrom math import floor, ceil, sqrt\nimport random\n\n# all class and function definitions in the code file, if any\nclass Word:\n    def __init__(self, word):\n        self._raw = word\n        self._value = word.upper()\n\n    @property\n    def raw(self):\n        return self._raw\n\n    @property\n    def value(self):\n        return self._value\n\n    @property\n    def letters(self):\n        return set(self.value)\n\n    @property\n    def occurences(self):\n        word = self.value\n        return { c: word.count(c) for c in word }\n\n    @property\n    def sorted_characters(self):\n        return ''.join(sorted(self.value))\n\n    @property\n    def sorted_letter_counts(self):\n        return [ n for n in sorted(self.occurences.values()) ]\n\n    def count(self, char):\n        return self.occurences.get(char.upper(), 0)\n\n    def is_anagram_of(self, other):\n        return self.occurences == other.occurences\n\n    def __len__(self):\n        return len(self._value)\n\n    def __repr__(self):\n        return '{}({!r})'.format(self.__class__.__name__, self.raw)\n\n    def __str__(self):\n        return self.raw\n\ndef group_anagrams(words):\n    key = lambda w: w.sorted_characters\n    words = sorted(words, key=key)\n    anagrams = groupby(words, key)\n    return [ list(g) for _, g in anagrams ]\n\n# main function\ndef main_solution(words):\n    words = [Word(word) for word in words if len(word) <= 10]\n    anagrams = group_anagrams(words)\n    anagrams = [g for g in anagrams if len(g) > 1]\n\n    square_anagrams_for_digits = {}\n\n    for digits in range(1, 10 + 1):\n        lo = ceil(sqrt(10 ** (digits - 1)))\n        hi = floor(sqrt(10 ** digits - 1))\n\n        squares = []\n\n        for base in range(lo, hi + 1):\n            square = base ** 2\n            square = Word(str(square))\n            squares.append(square)\n\n        square_anagrams = [g for g in group_anagrams(squares) if len(g) > 1]\n        square_anagrams_for_digits[digits] = square_anagrams\n\n    compatibles = defaultdict(list)\n\n    for group in anagrams:\n        for word in group:\n            for numbers in square_anagrams_for_digits[len(word)]:\n                for number in numbers:\n                    char_map, digit_map = {}, {}\n                    compatible = True\n                    for char, digit in zip(word.value, number.value):\n                        if char_map.get(char, digit) != digit or \\\n                                digit_map.get(digit, char) != char:\n                            compatible = False\n                            break\n                        char_map[char] = digit\n                        digit_map[digit] = char\n                    if not compatible:\n                        continue\n                    items = sorted(char_map.items())\n                    chars = ''.join(str(k) for k, _ in items)\n                    numbers = ''.join(str(v) for _, v in items)\n                    compatibles[chars + numbers].append((word, number))\n\n    compatibles = {k: v for k, v in compatibles.items() if len(v) > 1}\n\n    highest = 0\n\n    for pairs in compatibles.values():\n        for word, number in pairs:\n            number = int(number.value)\n            highest = max(highest, number)\n\n    return highest", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a list of words with some anagrams and some non-anagrams\n    words = []\n    \n    # Common words that can form anagrams\n    base_words = [\n        'listen', 'silent', 'enlist', 'triangle', 'integral', 'altering',\n        'evil', 'vile', 'live', 'leap', 'peal', 'pale', 'plea',\n        'earth', 'heart', 'hater', 'rat', 'tar', 'art'\n    ]\n    \n    # Add some random words\n    for _ in range(random.randint(5, 15)):\n        length = random.randint(3, 10)\n        word = ''.join(random.choices(string.ascii_lowercase, k=length))\n        words.append(word)\n    \n    # Add some anagram groups from base_words\n    num_anagram_groups = random.randint(1, 3)\n    for _ in range(num_anagram_groups):\n        group_size = random.randint(2, 4)\n        group = random.sample(base_words, group_size)\n        words.extend(group)\n    \n    # Shuffle the words to mix anagrams and non-anagrams\n    random.shuffle(words)\n    \n    return {'words': words}", "io_pairs": [{"input": {"words": ["silent", "dzctq", "omsuxul", "dhoscqy", "yxxhjppmq", "rcmezi", "tizmr", "peal", "jwcfjtj", "pzcyxlp"]}, "output": 0}, {"input": {"words": ["pri", "efdpd", "enlist", "silent", "silent", "tsc", "lbphs", "peal", "evil", "ecas"]}, "output": 863041}, {"input": {"words": ["tsqpij", "hnqhkl", "tar", "ansftynbci", "katv", "bvsov", "xqckxifn", "rat", "heart", "vile"]}, "output": 961}, {"input": {"words": ["dkqpgnost", "listen", "heart", "nvmclj", "leap", "yhirwry", "hishisyic", "fdrfuqlfho"]}, "output": 0}, {"input": {"words": ["bpbtdtko", "heart", "tod", "silent", "heart", "vile", "ljmp", "qxgrxfzf", "wojksnt", "pbpzb"]}, "output": 96721}, {"input": {"words": ["lygiqsy", "integral", "sdzdy", "kgurhgladg", "rat", "wdondazxn", "ppx", "qgdy", "frpkc", "jkdvk"]}, "output": 0}, {"input": {"words": ["triangle", "gikfi", "altering", "ugkagxn", "cfraqo", "tar", "ialewqbdih", "gcbytrxaol", "yjgit"]}, "output": 0}, {"input": {"words": ["hater", "ijtbeu", "pale", "silent", "listen", "integral", "vfaypz", "pale", "gnoahafy", "integral", "piv", "mrqnsqtl"]}, "output": 98327056}, {"input": {"words": ["art", "frsaiqo", "rout", "txtrol", "silent", "earth", "zeq", "qqkveguq", "dyngxffw"]}, "output": 0}, {"input": {"words": ["evil", "jxtzxf", "hcpm", "qlwznx", "tar", "exwqup", "plea", "ikaqq", "wuhowifhba", "pbloxhcf"]}, "output": 0}], "error_log": []}
{"context": "Given a neural network with a specific architecture, how would the network respond to a particular input vector? Specifically, what would be the output of the network for a given set of input values?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sizes` (list of int): A list representing the number of neurons in each layer of the neural network.\n  `input_data` (list of float): A list of input values to the neural network. The length of this list should match the number of neurons in the input layer.\n\nOutput:\n  `return` (list of float): A list representing the output values from the neural network. The length of this list corresponds to the number of neurons in the output layer.", "reference_code": "# import necessary packages\nimport random\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef sigmoid(z):\n    \"\"\"The sigmoid function.\"\"\"\n    return 1.0 / (1.0 + np.exp(-z))\n\nsigmoid_vec = np.vectorize(sigmoid)\n\ndef sigmoid_prime(z):\n    \"\"\"Derivative of the sigmoid function.\"\"\"\n    return sigmoid(z) * (1 - sigmoid(z))\n\nsigmoid_prime_vec = np.vectorize(sigmoid_prime)\n\ndef init_network(sizes):\n    num_layers = len(sizes)\n    biases = [np.random.randn(y, 1) for y in sizes[1:]]\n    weights = [np.random.randn(y, x) for x, y in zip(sizes[:-1], sizes[1:])]\n    return weights, biases, num_layers\n\ndef feedforward(weights, biases, X):\n    \"\"\"\n    Return the output of the network if ``a`` is input.\n    \"\"\"\n    a = X\n    for b, w in zip(biases, weights):\n        a = sigmoid_vec(np.dot(w, a) + b)\n    return a\n\ndef backprop(weights, biases, X, z, num_layers=3):\n    \"\"\"\n    Return a tuple ``(nabla_b, nabla_w)`` representing the\n    gradient for the cost function C_x.  ``nabla_b`` and\n    ``nabla_w`` are layer-by-layer lists of numpy arrays, similar\n    to ``biases`` and ``weights``.\n    \"\"\"\n    nabla_b = [np.zeros(b.shape) for b in biases]\n    nabla_w = [np.zeros(w.shape) for w in weights]\n    # feedforward\n    activation = X\n    activations = [X] # list to store all the activations, layer by layer\n    zs = [] # list to store all the z vectors, layer by layer\n    for b, w in zip(biases, weights):\n        z = np.dot(w, activation) + b\n        zs.append(z)\n        activation = sigmoid_vec(z)\n        activations.append(activation)\n    # backward pass\n    delta = (activations[-1] - z) * sigmoid_prime_vec(zs[-1])\n    nabla_b[-1] = delta\n    nabla_w[-1] = np.dot(delta, activations[-2].transpose())\n    # Note that the variable l in the loop below is used a little\n    # differently to the notation in Chapter 2 of the book.  Here,\n    # l = 1 means the last layer of neurons, l = 2 is the\n    # second-last layer, and so on.  It's a renumbering of the\n    # scheme in the book, used here to take advantage of the fact\n    # that Python can use negative indices in lists.\n    for l in range(2, num_layers):\n        z = zs[-l]\n        spv = sigmoid_prime_vec(z)\n        delta = np.dot(weights[-l+1].transpose(), delta) * spv\n        nabla_b[-l] = delta\n        nabla_w[-l] = np.dot(delta, activations[-l-1].transpose())\n    return (nabla_b, nabla_w)\n\n# main function\ndef main_solution(sizes, input_data):\n    # Convert input_data to a numpy array\n    input_data = np.array(input_data).reshape(-1, 1)\n    \n    # Initialize the network\n    weights, biases, num_layers = init_network(sizes)\n    \n    # Feedforward to get the output\n    output = feedforward(weights, biases, input_data)\n    \n    # Convert the output to a list for JSON serialization\n    output = output.flatten().tolist()\n    \n    return output", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    # Randomly choose the number of layers (between 2 and 5)\n    num_layers = random.randint(2, 5)\n    \n    # Generate random layer sizes (between 1 and 10 neurons per layer)\n    sizes = [random.randint(1, 10) for _ in range(num_layers)]\n    \n    # Generate random input data matching the input layer size\n    input_size = sizes[0]\n    input_data = [random.uniform(-1.0, 1.0) for _ in range(input_size)]\n    \n    return {\n        'sizes': sizes,\n        'input_data': input_data\n    }", "io_pairs": [{"input": {"sizes": [10, 4], "input_data": [0.24422437298101474, 0.715524172388232, -0.6210732613353858, -0.9172841645491858, -0.5819594667762003, -0.16598794709072817, 0.6390133992315279, -0.07297138314571328, -0.7639251252845314, -0.269913986407611]}, "output": [0.03666162406791732, 0.0676196008219756, 0.3002670984052063, 0.25940004899895514]}, {"input": {"sizes": [8, 6, 10, 4, 4], "input_data": [0.9176263704576291, -0.29295022888172517, -0.9697590747919667, -0.5059694542292519, 0.2234656651341611, 0.27141463774817254, -0.9251468513161591, 0.23752452987232453]}, "output": [0.4132268046858961, 0.8605834931326756, 0.3272326320724333, 0.03036679739383547]}, {"input": {"sizes": [1, 3, 4, 4], "input_data": [-0.38420858351404696]}, "output": [0.5692789209076922, 0.14797171919561447, 0.6034848315128751, 0.15143509178231654]}, {"input": {"sizes": [2, 3], "input_data": [-0.15359044665382782, 0.7947654306121255]}, "output": [0.9048665192146785, 0.636457973394164, 0.1971770795275625]}, {"input": {"sizes": [7, 10, 10, 10, 9], "input_data": [-0.578212524663569, -0.8498499852356454, 0.5317856388389384, -0.7765054100747453, -0.41167938963845696, 0.5508265929800138, 0.21072941019980918]}, "output": [0.9763806639149162, 0.06385326708757241, 0.3641105769896496, 0.9025166687343802, 0.11510625278205251, 0.2622833373261822, 0.7565889812019966, 0.8669159673120286, 0.11933439623944989]}, {"input": {"sizes": [2, 9, 10, 4, 7], "input_data": [0.27559928171476167, 0.894320219375728]}, "output": [0.7918552723833637, 0.5778832691308539, 0.6054153349293862, 0.7899090578348905, 0.30635577396917496, 0.09343503629463902, 0.30819443616853814]}, {"input": {"sizes": [8, 6], "input_data": [-0.09670232987854566, -0.7341161240033531, -0.11007571737225375, 0.4904548105083346, 0.45221044169569535, 0.48512005468006336, 0.908010880634528, 0.7103150108009377]}, "output": [0.9702009028429545, 0.4108637730146186, 0.9450597130896077, 0.29351875182987563, 0.349165473555921, 0.398577944329915]}, {"input": {"sizes": [1, 3, 1, 6, 10], "input_data": [0.1997880708065689]}, "output": [0.24263376922126698, 0.2841513716128686, 0.8564859865198771, 0.4396105441068212, 0.9046170779910638, 0.9398174409311035, 0.47429290676395547, 0.7289807135544938, 0.23991881443570887, 0.9330484151418554]}, {"input": {"sizes": [3, 10], "input_data": [-0.7421975065864534, -0.8142228683953545, -0.4849400348719968]}, "output": [0.5208424611825756, 0.3405366101001066, 0.025706553706569362, 0.6434953352586107, 0.6297119607617677, 0.22836014328067986, 0.6489954213221737, 0.16249571856087158, 0.7020431581605083, 0.028937745559954056]}, {"input": {"sizes": [6, 6], "input_data": [0.7211527818018848, 0.8654680664875474, -0.2516602580701621, -0.30718653928382733, -0.26736696945822835, 0.702500412910328]}, "output": [0.02633614740855577, 0.43564483948437227, 0.543117558363237, 0.8857133401873369, 0.7535740648586139, 0.34369221102531883]}], "error_log": []}
{"context": "Given a partially filled Tic Tac Toe board, what is the optimal move for the current player to maximize their chances of winning or forcing a draw?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists of strings/None): A 3x3 grid representing the Tic Tac Toe board. Each cell can be `\"X\"`, `\"O\"`, or `None` (representing an empty cell).\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"optimal_action\"` whose value is a tuple `(i, j)` representing the optimal move for the current player on the board. If the game is over, the value will be `None`.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    x_count = sum(row.count(X) for row in board)\n    o_count = sum(row.count(O) for row in board)\n    return X if x_count == o_count else O\n\n# Function to get all possible actions\ndef actions(board):\n    possible_actions = []\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == EMPTY:\n                possible_actions.append((i, j))\n    return possible_actions\n\n# Function to get the result of an action\ndef result(board, action):\n    new_board = [row[:] for row in board]\n    new_board[action[0]][action[1]] = player(board)\n    return new_board\n\n# Function to determine the winner\ndef winner(board):\n    lines = [\n        [(0, 0), (0, 1), (0, 2)],\n        [(1, 0), (1, 1), (1, 2)],\n        [(2, 0), (2, 1), (2, 2)],\n        [(0, 0), (1, 0), (2, 0)],\n        [(0, 1), (1, 1), (2, 1)],\n        [(0, 2), (1, 2), (2, 2)],\n        [(0, 0), (1, 1), (2, 2)],\n        [(2, 0), (1, 1), (0, 2)],\n    ]\n    for line in lines:\n        if board[line[0][0]][line[0][1]] == board[line[1][0]][line[1][1]] == board[line[2][0]][line[2][1]] != EMPTY:\n            return board[line[0][0]][line[0][1]]\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or not any(EMPTY in row for row in board)\n\n# Function to get the utility of the board\ndef utility(board):\n    win = winner(board)\n    if win == X:\n        return 1\n    elif win == O:\n        return -1\n    else:\n        return 0\n\n# Minimax functions\ndef max_value(board):\n    if terminal(board):\n        return utility(board)\n    v = -math.inf\n    for action in actions(board):\n        v = max(v, min_value(result(board, action)))\n    return v\n\ndef min_value(board):\n    if terminal(board):\n        return utility(board)\n    v = math.inf\n    for action in actions(board):\n        v = min(v, max_value(result(board, action)))\n    return v\n\n# Function to get the optimal action using minimax\ndef minimax(board):\n    if terminal(board):\n        return None\n    if player(board) == X:\n        best_score = -math.inf\n        best_action = None\n        for action in actions(board):\n            score = min_value(result(board, action))\n            if score > best_score:\n                best_score = score\n                best_action = action\n        return best_action\n    else:\n        best_score = math.inf\n        best_action = None\n        for action in actions(board):\n            score = max_value(result(board, action))\n            if score < best_score:\n                best_score = score\n                best_action = action\n        return best_action\n\n# Main function\ndef main_solution(board):\n    \"\"\"\n    Returns the optimal action for the current player on the board.\n    \"\"\"\n    action = minimax(board)\n    return {\"optimal_action\": action}", "input_generator": "import random\n\ndef input_generator():\n    board = [[None, None, None], [None, None, None], [None, None, None]]\n    symbols = ['X', 'O']\n    current_symbol = random.choice(symbols)\n    \n    # Randomly fill the board with some moves\n    moves = random.randint(0, 8)\n    for _ in range(moves):\n        empty_positions = [(i, j) for i in range(3) for j in range(3) if board[i][j] is None]\n        if not empty_positions:\n            break\n        pos = random.choice(empty_positions)\n        board[pos[0]][pos[1]] = current_symbol\n        current_symbol = 'O' if current_symbol == 'X' else 'X'\n    \n    return {\"board\": board}", "io_pairs": [{"input": {"board": [["O", "X", null], ["O", null, "O"], ["X", null, "X"]]}, "output": {"optimal_action": [1, 1]}}, {"input": {"board": [[null, null, null], [null, null, null], [null, null, null]]}, "output": {"optimal_action": [0, 0]}}, {"input": {"board": [["X", "O", "X"], ["O", "X", "O"], [null, "X", "O"]]}, "output": {"optimal_action": [2, 0]}}, {"input": {"board": [["O", "X", "O"], ["X", "O", "O"], [null, "X", "X"]]}, "output": {"optimal_action": [2, 0]}}, {"input": {"board": [[null, null, "O"], ["X", "O", null], ["X", null, null]]}, "output": {"optimal_action": [0, 0]}}, {"input": {"board": [["X", "O", null], ["O", "X", "O"], [null, "O", "X"]]}, "output": {"optimal_action": null}}, {"input": {"board": [[null, null, "X"], [null, "X", "X"], ["O", "O", "O"]]}, "output": {"optimal_action": null}}, {"input": {"board": [[null, null, "X"], [null, null, null], [null, null, null]]}, "output": {"optimal_action": [1, 1]}}, {"input": {"board": [[null, null, "X"], ["O", null, null], ["O", "X", null]]}, "output": {"optimal_action": [0, 0]}}, {"input": {"board": [[null, null, null], [null, null, null], ["O", null, "X"]]}, "output": {"optimal_action": [0, 0]}}], "error_log": []}
{"context": "In a game of Connect Four, the AI is about to make its move. Given the current state of the board, what will be the updated board state and the result of the game after the AI's move?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_state` (list of strings): A list of 7 strings, each string representing a column of the Connect Four board. Each string has 6 characters, representing the cells in that column. The characters can be `'_'` (empty), `'X'`, or `'O'`.\n\nOutput:\n  `return` (dictionary): A dictionary with two keys:\n  - `board_state` (list of strings): The updated board state after the AI's move.\n  - `result` (string): A string indicating the result of the game after the AI's move. Possible values are `'I won, yay!'`, `'You won, well done!'`, or `'It\\'s a draw.'`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef transform(x):\n    if x == 'X':\n        return -1.01\n    else:\n        return 1\n\ndef endtext(x):\n    if x > 90000:\n        return 'I won, yay!'\n    if x < -90000:\n        return 'You won, well done!'\n    else:\n        return 'It\\'s a draw.'\n\ndef setup():\n    board = []\n    for i in range(7):\n        board.append(['_', '_', '_', '_', '_', '_'])\n    return board\n\ndef move(column, player, board):\n    done = False\n    for i in range(6):\n        if board[column-1][i] == '_' and done == False:\n            board[column-1][i] = player\n            done = True\n    return board\n\ndef evaluate(board):\n    w = 0\n    # check for winners vertically:\n    for c in range(7):\n        for r in range(3):\n            if board[c][r]==board[c][r+1]==board[c][r+2]==board[c][r+3]!='_':\n                w += transform(board[c][r])*100000\n    # horizontally:\n    for c in range(4):\n        for r in range(6):\n            if board[c][r]==board[c+1][r]==board[c+2][r]==board[c+3][r]!='_':\n                w += transform(board[c][r])*100000\n    # / diagonally:\n    for c in range(4):\n        for r in range(3):\n            if board[c][r]==board[c+1][r+1]==board[c+2][r+2]==board[c+3][r+3]!='_':\n                w += transform(board[c][r])*100000\n    # \\ diagonally:\n    for c in range(3,7):\n        for r in range(3):\n            if board[c][r]==board[c-1][r+1]==board[c-2][r+2]==board[c-3][r+3]!='_':\n                w += transform(board[c][r])*100000\n    return w\n\ndef get_move_o(board):\n    copy = [row[:] for row in board]\n    pos_moves = {}\n    for a in range(1,8):\n        if copy[a-1][5] == '_':\n            move(a, 'O', copy)\n            if evaluate(copy) > 90000:\n                pos_moves[evaluate(copy)] = a\n            else:\n                listb = []\n                for b in range(1,8):\n                    if copy[b-1][5] == '_':\n                        move(b, 'X', copy)\n                        if evaluate(copy) > 90000:\n                            listb.append(evaluate(copy))\n                        else:\n                            listc = []\n                            for c in range(1,8):\n                                if board[c-1][5] == '_':\n                                    move(c, 'O', copy)\n                                    if evaluate(copy) > 90000:\n                                        listc.append(evaluate(copy))\n                                    else:\n                                        listd = []\n                                        for d in range(1,8):\n                                            if board[d-1][5] == '_':\n                                                move(d, 'X', copy)\n                                                listd.append(evaluate(copy))\n                                                move(d, '_', copy)\n                                        if listd != []:\n                                            listc.append(evaluate(copy))\n                                    move(c, '_', copy)\n                            if listc != []:\n                                listb.append(max(listc))\n                        move(b, '_', copy)\n                if listb != []:\n                    pos_moves[min(listb)] = a\n            move(a, '_', board)\n    if pos_moves == {}:\n        return None\n    else:\n        return pos_moves[max(pos_moves)]\n\n# main function\ndef main_solution(board_state):\n    board = [list(row) for row in board_state]\n    move_o = get_move_o(board)\n    if move_o is not None:\n        board = move(move_o, 'O', board)\n    evaluation = evaluate(board)\n    result = endtext(evaluation)\n    return {\"board_state\": [''.join(row) for row in board], \"result\": result}", "input_generator": "import random\n\ndef input_generator():\n    board = []\n    for _ in range(7):\n        row = []\n        for _ in range(6):\n            cell = random.choice(['_', 'X', 'O'])\n            row.append(cell)\n        board.append(''.join(row))\n    \n    return {\"board_state\": board}", "io_pairs": [{"input": {"board_state": ["XXO_XX", "_XOXXX", "XOXO_O", "OXOOOO", "X_O_XX", "_XO_X_", "_OXX__"]}, "output": {"board_state": ["XXO_XX", "_XOXXX", "XOXO_O", "OXOOOO", "X_O_XX", "OXO_X_", "_OXX__"], "result": "You won, well done!"}}, {"input": {"board_state": ["_XOXXX", "X_XO_O", "X___X_", "XXXO_O", "XOX_OO", "X__XX_", "OO__O_"]}, "output": {"board_state": ["_XOXXX", "X_XO_O", "XO__X_", "XXXO_O", "XOX_OO", "X__XX_", "OO__O_"], "result": "You won, well done!"}}, {"input": {"board_state": ["X___XO", "OOXXXX", "____XO", "XX_XOO", "OXX__X", "X_XXOO", "X_OOO_"]}, "output": {"board_state": ["X___XO", "OOXXXX", "____XO", "XX_XOO", "OXX__X", "X_XXOO", "XOOOO_"], "result": "You won, well done!"}}, {"input": {"board_state": ["_OXXXO", "XOX__O", "_OOOOX", "OXOXXX", "OXOXXX", "___X_X", "O__OOO"]}, "output": {"board_state": ["_OXXXO", "XOX__O", "_OOOOX", "OXOXXX", "OXOXXX", "___X_X", "O__OOO"], "result": "It's a draw."}}, {"input": {"board_state": ["OOX_O_", "OXOOO_", "_O_XXO", "XOXOXO", "___OX_", "_O__OX", "XO_X_X"]}, "output": {"board_state": ["OOXOO_", "OXOOO_", "_O_XXO", "XOXOXO", "___OX_", "_O__OX", "XO_X_X"], "result": "It's a draw."}}, {"input": {"board_state": ["_XOO_X", "XOOOOX", "OOXOOX", "OOXOO_", "XXXXXX", "XXXXXO", "OXO_O_"]}, "output": {"board_state": ["_XOO_X", "XOOOOX", "OOXOOX", "OOXOOO", "XXXXXX", "XXXXXO", "OXO_O_"], "result": "You won, well done!"}}, {"input": {"board_state": ["XO_OO_", "___OXO", "O_X_OX", "O_____", "_O_OX_", "OX_XO_", "O__OO_"]}, "output": {"board_state": ["XO_OO_", "___OXO", "O_X_OX", "O_____", "_O_OX_", "OX_XO_", "OO_OO_"], "result": "It's a draw."}}, {"input": {"board_state": ["_OXOOO", "_X___O", "O_O_OX", "OOXOXX", "OXXOOO", "X_XXOX", "__X_OO"]}, "output": {"board_state": ["_OXOOO", "_X___O", "O_O_OX", "OOXOXX", "OXXOOO", "X_XXOX", "__X_OO"], "result": "You won, well done!"}}, {"input": {"board_state": ["XOX_O_", "XXO_OO", "OOX_XX", "XO_X__", "XOXXXX", "XX_O__", "X__XOO"]}, "output": {"board_state": ["XOXOO_", "XXO_OO", "OOX_XX", "XO_X__", "XOXXXX", "XX_O__", "X__XOO"], "result": "You won, well done!"}}, {"input": {"board_state": ["X_X_XX", "_XXOOO", "XOO_XO", "_OOXOX", "_OO__X", "OXOOXO", "OX__OO"]}, "output": {"board_state": ["X_X_XX", "_XXOOO", "XOO_XO", "_OOXOX", "_OO__X", "OXOOXO", "OX__OO"], "result": "I won, yay!"}}], "error_log": []}
{"context": "Given a mathematical algorithm to approximate the value of Pi, how would the calculated value of Pi change after a certain number of iterations? Specifically, what is the value of Pi after `n` iterations using Bellard's Big Pi algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of iterations to perform in the Bellard's Big Pi calculation.\n\nOutput:\n  `return` (str): A string representation of the calculated value of Pi after `n` iterations.", "reference_code": "# import necessary packages\nfrom decimal import Decimal\n\n# all class and function definitions in the code file, if any\nclass Value:\n    def bellardBig(self, n):\n        pi = Decimal(0)\n        k = 0\n        while k < n:\n            pi += (Decimal(-1)**k/(1024**k))*( Decimal(256)/(10*k+1) + Decimal(1)/(10*k+9) - Decimal(64)/(10*k+3) - Decimal(32)/(4*k+1) - Decimal(4)/(10*k+5) - Decimal(4)/(10*k+7) -Decimal(1)/(4*k+3))\n            k += 1\n        pi = pi * 1/(2**6)\n        return pi\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    instan = Value()\n    pi_value = instan.bellardBig(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return str(pi_value)", "input_generator": "import random\nfrom decimal import Decimal\n\ndef input_generator():\n    n = random.randint(1, 10)\n    return {'n': n}", "io_pairs": [{"input": {"n": 3}, "output": "3.141592653642050769944283786"}, {"input": {"n": 9}, "output": "3.141592653589793238462643383"}, {"input": {"n": 4}, "output": "3.141592653589755368080512995"}, {"input": {"n": 1}, "output": "3.141765873015873015873015873"}, {"input": {"n": 7}, "output": "3.141592653589793238462663227"}, {"input": {"n": 10}, "output": "3.141592653589793238462643383"}, {"input": {"n": 6}, "output": "3.141592653589793238438850569"}, {"input": {"n": 8}, "output": "3.141592653589793238462643366"}, {"input": {"n": 2}, "output": "3.141592571868390306374052505"}, {"input": {"n": 5}, "output": "3.141592653589793267843375631"}], "error_log": []}
{"context": "Given a 2D grid of cells represented by a matrix, where each cell can either be empty (0) or occupied (1), how would you ensure that every row and column that contains at least one occupied cell is entirely filled with occupied cells? The matrix should be mutated in place without creating a new copy. What would be the resulting matrix after applying this transformation?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of integers): A 2D matrix where each element is either 0 or 1. The matrix represents a grid of cells.\n\nOutput:\n  `return` (list of lists of integers): A 2D matrix where every row and column that originally contained at least one 1 is now filled entirely with 1s. The matrix is mutated in place.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef ones_infection(arr):\n    rows = []\n    cols = []\n    \n    for x in range(len(arr)): \n        for y in range(len(arr[x])): \n            if arr[x][y]:\n                rows.append(x)\n                cols.append(y)\n    \n    for x in rows:\n        arr[x] = [1] * len(arr[x])\n    \n    for x in cols:\n        for y in range(len(arr)):\n            arr[y][x] = 1\n        \n    return arr\n\n# main function\ndef main_solution(matrix):\n    # Convert the input matrix to a list of lists if it's not already\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        raise ValueError(\"Input must be a list of lists representing a matrix\")\n    \n    # Call the ones_infection function to mutate the matrix\n    result_matrix = ones_infection(matrix)\n    \n    # Convert the result matrix to a JSON serializable format\n    return result_matrix", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(2, 10)\n    cols = random.randint(2, 10)\n    matrix = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n    # Randomly place some 1s in the matrix\n    num_ones = random.randint(1, rows * cols // 2)\n    for _ in range(num_ones):\n        x = random.randint(0, rows - 1)\n        y = random.randint(0, cols - 1)\n        matrix[x][y] = 1\n    \n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[1, 1, 1, 1], [1, 1, 1, 1]]}, "output": [[1, 1, 1, 1], [1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]]}, "output": [[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]}, "output": [[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]}, "output": [[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]]}, "output": [[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1], [1, 1], [1, 1], [1, 1], [1, 1]]}, "output": [[1, 1], [1, 1], [1, 1], [1, 1], [1, 1]]}, {"input": {"matrix": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]}, "output": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1], [1, 1, 1], [1, 1, 1]]}, "output": [[1, 1, 1], [1, 1, 1], [1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1, 1], [0, 0, 1, 1], [1, 1, 1, 1]]}, "output": [[1, 1, 1, 1], [0, 0, 1, 1], [1, 1, 1, 1]]}, {"input": {"matrix": [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]}, "output": [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]}], "error_log": []}
{"context": "Given a double pendulum system with two masses connected by rigid rods, what are the final positions of the pendulums after a certain period of time, given their initial angles and angular velocities?\n\nThe input and output requirements are as follows:\n\nInput:\n  `th1` (float): Initial angle of the first pendulum in degrees.\n  `th2` (float): Initial angle of the second pendulum in degrees.\n  `w1` (float): Initial angular velocity of the first pendulum in degrees per second.\n  `w2` (float): Initial angular velocity of the second pendulum in degrees per second.\n  `t_end` (float): End time for the simulation in seconds.\n  `dt` (float): Time step for the simulation in seconds.\n\nOutput:\n  `return` (dict): A dictionary containing the final positions of the pendulums.\n    - `x1_final` (float): Final x-coordinate of the first pendulum.\n    - `y1_final` (float): Final y-coordinate of the first pendulum.\n    - `x2_final` (float): Final x-coordinate of the second pendulum.\n    - `y2_final` (float): Final y-coordinate of the second pendulum.", "reference_code": "# import necessary packages\nimport numpy as np\nimport scipy.integrate as integrate\n\n# Constants\nG = 9.8  # acceleration due to gravity, in m/s^2\nL1 = 1.0  # length of pendulum 1 in m\nL2 = 1.0  # length of pendulum 2 in m\nM1 = 1.0  # mass of pendulum 1 in kg\nM2 = 1.0  # mass of pendulum 2 in kg\n\ndef derivs(state, t):\n    dydx = np.zeros_like(state)\n    dydx[0] = state[1]\n\n    delta = state[2] - state[0]\n    den1 = (M1 + M2) * L1 - M2 * L1 * np.cos(delta) * np.cos(delta)\n    dydx[1] = ((M2 * L1 * state[1] * state[1] * np.sin(delta) * np.cos(delta)\n                + M2 * G * np.sin(state[2]) * np.cos(delta)\n                + M2 * L2 * state[3] * state[3] * np.sin(delta)\n                - (M1 + M2) * G * np.sin(state[0]))\n               / den1)\n\n    dydx[2] = state[3]\n\n    den2 = (L2 / L1) * den1\n    dydx[3] = ((- M2 * L2 * state[3] * state[3] * np.sin(delta) * np.cos(delta)\n                + (M1 + M2) * G * np.sin(state[0]) * np.cos(delta)\n                - (M1 + M2) * L1 * state[1] * state[1] * np.sin(delta)\n                - (M1 + M2) * G * np.sin(state[2]))\n               / den2)\n\n    return dydx\n\n# main function\ndef main_solution(th1, th2, w1, w2, t_end, dt):\n    # Convert angles and angular velocities to radians\n    state = np.radians([th1, w1, th2, w2])\n    \n    # Create time array\n    t = np.arange(0, t_end, dt)\n    \n    # Integrate the ODE\n    y = integrate.odeint(derivs, state, t)\n    \n    # Extract the final positions of the pendulums\n    x1_final = L1 * np.sin(y[-1, 0])\n    y1_final = -L1 * np.cos(y[-1, 0])\n    x2_final = L2 * np.sin(y[-1, 2]) + x1_final\n    y2_final = -L2 * np.cos(y[-1, 2]) + y1_final\n    \n    # Return the final positions as a dictionary\n    return {\n        \"x1_final\": x1_final,\n        \"y1_final\": y1_final,\n        \"x2_final\": x2_final,\n        \"y2_final\": y2_final\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate random initial angles between -90 and 90 degrees\n    th1 = random.uniform(-90, 90)\n    th2 = random.uniform(-90, 90)\n    # Generate random initial angular velocities between -10 and 10 rad/s\n    w1 = random.uniform(-10, 10)\n    w2 = random.uniform(-10, 10)\n    # Generate random end time between 1 and 10 seconds\n    t_end = random.uniform(1, 10)\n    # Generate random time step between 0.01 and 0.1 seconds\n    dt = random.uniform(0.01, 0.1)\n    \n    return {\n        \"th1\": th1,\n        \"th2\": th2,\n        \"w1\": w1,\n        \"w2\": w2,\n        \"t_end\": t_end,\n        \"dt\": dt\n    }", "io_pairs": [{"input": {"th1": 52.23735417965656, "th2": -15.98434326479709, "w1": 0.07037187056217142, "w2": 5.756574821046739, "t_end": 5.723921371423828, "dt": 0.03846091840977276}, "output": {"x1_final": -0.00823361513500529, "y1_final": -0.9999661032164083, "x2_final": 0.3799387636002608, "y2_final": -1.9215528893559477}}, {"input": {"th1": 49.23663014949844, "th2": 29.651993466293078, "w1": 0.23209656066869755, "w2": 2.58912783950346, "t_end": 3.029343781310267, "dt": 0.08309449216262321}, "output": {"x1_final": 0.3131240778396865, "y1_final": -0.9497122258226678, "x2_final": 1.1573479918391667, "y2_final": -1.4857028815540883}}, {"input": {"th1": 48.00139598903567, "th2": 79.908332381458, "w1": -0.20156662107109824, "w2": 1.6086519701743747, "t_end": 2.5586593307932004, "dt": 0.040951136730492194}, "output": {"x1_final": 0.6766470857366729, "y1_final": -0.7363074910416623, "x2_final": 1.544248479261444, "y2_final": -1.2335678071275886}}, {"input": {"th1": -70.83018038414255, "th2": 57.630538904496404, "w1": -6.239916828643654, "w2": 8.075424623806878, "t_end": 4.8212235842647395, "dt": 0.029746213319817305}, "output": {"x1_final": 0.7232996518505627, "y1_final": -0.6905342957687581, "x2_final": -0.27215763929184866, "y2_final": -0.785743441922962}}, {"input": {"th1": -59.68751049486535, "th2": -21.69520776753025, "w1": -9.493302050772153, "w2": -1.496575980799804, "t_end": 4.305494220126228, "dt": 0.045884468169250084}, "output": {"x1_final": 0.7530222263530544, "y1_final": -0.6579950809985508, "x2_final": 1.3399118575415305, "y2_final": -1.467662025367317}}, {"input": {"th1": 81.7425427043897, "th2": -55.37392302291008, "w1": -9.241935277921725, "w2": 3.1675191943073138, "t_end": 7.475079783970463, "dt": 0.022024481249133122}, "output": {"x1_final": -0.1276598488148068, "y1_final": -0.9918180090120267, "x2_final": 0.8391077397439541, "y2_final": -1.2474748683220764}}, {"input": {"th1": -87.51399012883192, "th2": 60.14426580454216, "w1": 8.808411657062955, "w2": 8.915257416930547, "t_end": 7.715203568517301, "dt": 0.025705529391943413}, "output": {"x1_final": 0.6368657189457055, "y1_final": -0.7709747440946231, "x2_final": 1.4710785427385518, "y2_final": -1.322417365424862}}, {"input": {"th1": 20.97230524621672, "th2": 63.40310494456992, "w1": -1.0796057511916963, "w2": -9.885191970907128, "t_end": 6.601168531047019, "dt": 0.06121074813977278}, "output": {"x1_final": -0.43870491066281736, "y1_final": -0.8986311820543117, "x2_final": -1.1953592129075656, "y2_final": -1.5524463446916683}}, {"input": {"th1": 75.88745880235786, "th2": 51.977037436905505, "w1": -7.267291081652482, "w2": -7.592371099086446, "t_end": 6.948498978561275, "dt": 0.08809541580188254}, "output": {"x1_final": -0.8204109536155038, "y1_final": -0.571774314907289, "x2_final": -1.78900522520644, "y2_final": -0.8204209256648538}}, {"input": {"th1": -80.70328338231019, "th2": 3.563204159698145, "w1": 4.696430357903576, "w2": 1.325770082778721, "t_end": 4.34897762972558, "dt": 0.0930627350032114}, "output": {"x1_final": 0.8840933905309344, "y1_final": -0.46731025755863387, "x2_final": 1.2125394912654266, "y2_final": -1.411832972432293}}], "error_log": []}
{"context": "In a baseball game, a player tries to guess a 3-digit number. After each guess, the player is given feedback in the form of strikes and balls. A strike indicates that one of the guessed digits is correct and in the correct position, while a ball indicates that one of the guessed digits is correct but in the wrong position. Given a set of guesses and their corresponding strikes and balls, how many possible 3-digit numbers could be the correct answer?\n\nThe input and output requirements are as follows:\n\nInput:\n  `baseballs` (list of lists): A list of lists where each inner list contains three elements:\n    - The first element is a 3-digit number (int) representing the guess.\n    - The second element is an integer representing the number of strikes.\n    - The third element is an integer representing the number of balls.\n\nOutput:\n  `return` (int): The number of possible 3-digit numbers that could be the correct answer based on the given baseballs data.", "reference_code": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(baseballs):\n    # Convert the input list of tuples to a list of lists for JSON serialization\n    baseballs = [list(baseball) for baseball in baseballs]\n    \n    def strikes(answer, standard):\n        strike_point = 0\n        for i in range(3):\n            if answer[i] == str(standard[i]):\n                strike_point += 1\n        return strike_point\n\n    def balls(answer, standard):\n        ball_point = 0\n        for i in range(3):\n            for j in range(3):\n                if answer[i] == str(standard[j]) and i != j:\n                    ball_point += 1\n                    break\n        return ball_point\n\n    def is_possible(baseballs, permutaion):\n        for baseball in baseballs:\n            if baseball[1] == strikes(str(baseball[0]), permutaion) and \\\n                    baseball[2] == balls(str(baseball[0]), permutaion):\n                continue\n            else:\n                return 0\n        return 1\n\n    answer = 0\n    for permutaion in permutations([1, 2, 3, 4, 5, 6, 7, 8, 9], 3):\n        answer += is_possible(baseballs, permutaion)\n    \n    # Return the final output as an integer\n    return answer", "input_generator": "import random\nfrom itertools import permutations\n\ndef input_generator():\n    # Generate a random number of baseballs (1 to 5)\n    num_baseballs = random.randint(1, 5)\n    baseballs = []\n    \n    # Generate all possible permutations of 3 distinct digits from 1-9\n    all_possible = list(permutations(range(1, 10), 3))\n    \n    # Randomly select one permutation as the 'answer'\n    answer = random.choice(all_possible)\n    \n    for _ in range(num_baseballs):\n        # Randomly select a permutation for the baseball\n        baseball_num = random.choice(all_possible)\n        \n        # Calculate strikes and balls against the answer\n        strike = 0\n        ball = 0\n        for i in range(3):\n            if baseball_num[i] == answer[i]:\n                strike += 1\n            elif baseball_num[i] in answer:\n                ball += 1\n        \n        baseballs.append((baseball_num, strike, ball))\n    \n    return {'baseballs': baseballs}", "io_pairs": [{"input": {"baseballs": [[[2, 9, 8], 1, 1], [[5, 4, 8], 1, 0]]}, "output": 0}, {"input": {"baseballs": [[[7, 1, 8], 0, 0], [[9, 3, 6], 2, 0]]}, "output": 0}, {"input": {"baseballs": [[[2, 4, 6], 0, 1]]}, "output": 112}, {"input": {"baseballs": [[[6, 2, 9], 0, 1], [[1, 7, 8], 0, 1]]}, "output": 14}, {"input": {"baseballs": [[[4, 2, 3], 0, 1], [[8, 4, 1], 0, 0], [[2, 5, 7], 1, 1]]}, "output": 0}, {"input": {"baseballs": [[[9, 5, 1], 0, 1], [[9, 1, 2], 0, 1]]}, "output": 112}, {"input": {"baseballs": [[[1, 5, 3], 0, 0], [[4, 2, 6], 0, 1], [[4, 1, 5], 0, 0]]}, "output": 0}, {"input": {"baseballs": [[[5, 9, 4], 0, 0], [[2, 7, 3], 0, 1]]}, "output": 84}, {"input": {"baseballs": [[[9, 6, 2], 0, 2], [[8, 5, 2], 0, 0]]}, "output": 0}, {"input": {"baseballs": [[[3, 2, 9], 0, 1]]}, "output": 112}], "error_log": []}
{"context": "Imagine you have two blocks on a frictionless ramp. The first block slides down the ramp from a certain height and collides inelastically with the second block, which is initially at rest. How does the final speed of the combined blocks after the collision depend on the masses of the blocks and the height of the ramp? Specifically, what is the final speed of the blocks when the first block has a mass of `m_1`, the second block has a mass of `m_2`, and the ramp height is `h`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m_1` (float): Mass of the first block in kilograms.\n  `m_2` (float): Mass of the second block in kilograms.\n  `h` (float): Height of the ramp in meters.\n\nOutput:\n  `return` (dict): A dictionary containing the final speed of the blocks after the collision. The key is `\"final_speed\"` and the value is a float representing the final speed in meters per second.", "reference_code": "# import necessary packages\nfrom math import sqrt\n\n# all class and function definitions in the code file, if any\ndef solver(m_1, m_2, h):\n    # Calculate the speed of block m_1 at the bottom of the ramp using energy conservation\n    v_1 = sqrt(2 * 9.81 * h)\n    \n    # Calculate the final speed of the blocks after the inelastic collision using momentum conservation\n    v_f = (m_1 * v_1) / (m_1 + m_2)\n    \n    return v_f\n\n# main function\ndef main_solution(m_1, m_2, h):\n    # Convert JSON serializable inputs to the original input variables\n    m_1 = float(m_1)\n    m_2 = float(m_2)\n    h = float(h)\n    \n    # Call the solver function to get the final speed\n    final_speed = solver(m_1, m_2, h)\n    \n    # Convert the output to JSON serializable format\n    return {\"final_speed\": final_speed}", "input_generator": "import random\n\ndef input_generator():\n    m_1 = random.uniform(0.1, 10.0)\n    m_2 = random.uniform(0.1, 10.0)\n    h = random.uniform(0.1, 5.0)\n    return {\"m_1\": m_1, \"m_2\": m_2, \"h\": h}", "io_pairs": [{"input": {"m_1": 4.309035896059211, "m_2": 3.662799775050591, "h": 2.10539723115011}, "output": {"final_speed": 3.474067876755978}}, {"input": {"m_1": 6.076023706752046, "m_2": 6.758380433872941, "h": 1.945644779995271}, "output": {"final_speed": 2.9249943208834246}}, {"input": {"m_1": 7.217317469048883, "m_2": 5.88842307461768, "h": 2.3525321392928276}, "output": {"final_speed": 3.741377475829448}}, {"input": {"m_1": 5.340045633237882, "m_2": 9.331524103075935, "h": 2.6135170546255164}, "output": {"final_speed": 2.606336924502455}}, {"input": {"m_1": 0.11088218341490791, "m_2": 7.830747916714129, "h": 1.9895144440053538}, "output": {"final_speed": 0.08723186626933561}}, {"input": {"m_1": 4.139053747708395, "m_2": 7.063720476989181, "h": 1.4245298400980297}, "output": {"final_speed": 1.9532631620617507}}, {"input": {"m_1": 8.024715191121683, "m_2": 4.030302587515487, "h": 4.874543418752027}, "output": {"final_speed": 6.509958881613957}}, {"input": {"m_1": 3.679299055039359, "m_2": 7.366893160078797, "h": 4.3084407638922}, "output": {"final_speed": 3.062400996710866}}, {"input": {"m_1": 4.160956447337507, "m_2": 9.214438085475518, "h": 4.028566087561011}, "output": {"final_speed": 2.765739782323195}}, {"input": {"m_1": 5.0744783824413515, "m_2": 8.247939276438924, "h": 2.0772619362992812}, "output": {"final_speed": 2.4316636074689586}}], "error_log": []}
{"context": "Alice wants to send a secret message to Bob using the RSA encryption algorithm. She has chosen two prime numbers `p1` and `p2` to generate the public and private keys. What will be the encrypted message (`ciphertext`) and the decrypted message (`plaintext`) when Alice uses the RSA algorithm to encrypt her message?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p1` (int): A prime number used in the RSA key generation.\n  `p2` (int): Another prime number used in the RSA key generation.\n  `message` (str): The message to be encrypted using the RSA algorithm.\n\nOutput:\n  `return` (dict): A dictionary containing the encrypted message (`ciphertext`) and the decrypted message (`plaintext`). Both values are strings.", "reference_code": "# import necessary packages\nfrom sympy import isprime, gcd\nimport random\n\n# main function\ndef main_solution(p1, p2, message):\n    # Convert input variables if necessary\n    p1 = int(p1)\n    p2 = int(p2)\n    message = str(message)\n\n    # RSA_Keygen\n    def RSA_Keygen(p1, p2):\n        if not(isprime(p1) and isprime(p2)):\n            return -1, -1\n        n = p1 * p2\n        phin = (p1-1)*(p2-1)\n        f = 0\n        while f == 0:\n            m = random.randint(2, phin)\n            if gcd(phin, m) == 1:\n                f = e = m\n        i = 2\n        e1 = phin + 1\n        while e1 % e != 0:\n            e1 = (phin * i) + 1\n            i += 1\n        d = int(e1 / e)\n        publicKey = [e, n]\n        privateKey = [d, n]\n        return publicKey, privateKey\n\n    # RSA_Encryption\n    def RSA_Encryption(message, ku):\n        ciphertext = (message ** ku[0]) % ku[1]\n        return ciphertext\n\n    # RSA_Decryption\n    def RSA_Decryption(ciphertext, kr):\n        plaintext = (ciphertext ** kr[0]) % kr[1]\n        return plaintext\n\n    # Generate keys\n    ku, kr = RSA_Keygen(p1, p2)\n\n    # Encrypt message\n    ciphertext = ''.join(chr(RSA_Encryption(ord(e), ku)) for e in message)\n\n    # Decrypt message\n    plaintext = ''.join(chr(RSA_Decryption(ord(f), kr)) for f in ciphertext)\n\n    # Return results\n    return {\"ciphertext\": ciphertext, \"plaintext\": plaintext}", "input_generator": "import random\nfrom sympy import randprime\n\ndef input_generator():\n    # Generate two distinct small prime numbers\n    p1 = randprime(10, 100)\n    p2 = randprime(10, 100)\n    while p2 == p1:\n        p2 = randprime(10, 100)\n    \n    # Generate a random message of reasonable length (1-10 characters)\n    message_length = random.randint(1, 10)\n    message = ''.join(random.choice('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') for _ in range(message_length))\n    \n    return {\"p1\": p1, \"p2\": p2, \"message\": message}", "io_pairs": [{"input": {"p1": 97, "p2": 79, "message": "oA"}, "output": {"ciphertext": "\u1db4\u05ce", "plaintext": "oA"}}, {"input": {"p1": 47, "p2": 67, "message": "S8Z"}, "output": {"ciphertext": "\u0bea\u0589\u0609", "plaintext": "S8Z"}}, {"input": {"p1": 67, "p2": 83, "message": "x712mDUmla"}, "output": {"ciphertext": "\u0dfa\u0e94\u10c6\u0919\u142a\u12d9\u14ea\u142a\u06d9\u0b5f", "plaintext": "x712mDUmla"}}, {"input": {"p1": 59, "p2": 23, "message": "QM3zr"}, "output": {"ciphertext": "N\r\u052e\u04a8\u0369", "plaintext": "QM3zr"}}, {"input": {"p1": 97, "p2": 37, "message": "VqUoS"}, "output": {"ciphertext": "\u0ade\u0554\u0471\u0c49\u0ad4", "plaintext": "VqUoS"}}, {"input": {"p1": 97, "p2": 53, "message": "rI"}, "output": {"ciphertext": "\u10b3\u0fee", "plaintext": "rI"}}, {"input": {"p1": 37, "p2": 59, "message": "hoyIKq"}, "output": {"ciphertext": "\u0435\u050f\u043b\u00dd\u0535\u0344", "plaintext": "hoyIKq"}}, {"input": {"p1": 59, "p2": 19, "message": "O"}, "output": {"ciphertext": "\u007f", "plaintext": "O"}}, {"input": {"p1": 19, "p2": 83, "message": "U6u"}, "output": {"ciphertext": "\u029d\u0569\u049c", "plaintext": "U6u"}}, {"input": {"p1": 23, "p2": 61, "message": "xfMs"}, "output": {"ciphertext": "\u01c9\u0504\u024f\u023f", "plaintext": "xfMs"}}], "error_log": []}
{"context": "\u5c0f\u8d5b\u6700\u8fd1\u4e70\u4e86\u4e00\u652f\u80a1\u7968\uff0c\u4ed6\u77e5\u9053\u4ece\u4ed6\u4e70\u80a1\u7968\u7684\u90a3\u5929\u5f00\u59cb\uff0c\u80a1\u7968\u4f1a\u6709\u4ee5\u4e0b\u53d8\u5316\uff1a\u7b2c\u4e00\u5929\u4e0d\u53d8\uff0c\u4ee5\u540e\u6da8\u4e00\u5929\uff0c\u8dcc\u4e00\u5929\uff0c\u6da8\u4e24\u5929\uff0c\u8dcc\u4e00\u5929\uff0c\u6da8\u4e09\u5929\uff0c\u8dcc\u4e00\u5929...\u4f9d\u6b64\u7c7b\u63a8\u3002\u5047\u8bbe\u6bcf\u6b21\u6da8\u548c\u8dcc\u7686\u4e3a1\uff0c\u80a1\u7968\u521d\u59cb\u5355\u4ef7\u4e5f\u4e3a1\u3002\u8bf7\u95ee\uff0c\u4e70\u80a1\u7968\u7684\u7b2cn\u5929\u6bcf\u80a1\u80a1\u7968\u503c\u591a\u5c11\u94b1\uff1f\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The day number to calculate the stock price. It should be a positive integer greater than 0.\n\nOutput:\n  `return` (int): The stock price on the nth day. It will be a positive integer representing the value of the stock.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(n):\n    # n (int): The day number to calculate the stock price.\n    \n    # Initialize the stock price and other variables\n    price = 1\n    day = 0\n    up = 1\n    \n    # Loop to calculate the stock price on the nth day\n    for _ in range(1, n):\n        if day < up:\n            day += 1\n            price += 1\n        elif day == up:\n            up += 1\n            day = 0\n            price -= 1\n    \n    # Return the stock price on the nth day\n    return price", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 1000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 914}, "output": 832}, {"input": {"n": 292}, "output": 248}, {"input": {"n": 632}, "output": 564}, {"input": {"n": 772}, "output": 698}, {"input": {"n": 423}, "output": 369}, {"input": {"n": 563}, "output": 499}, {"input": {"n": 247}, "output": 207}, {"input": {"n": 343}, "output": 295}, {"input": {"n": 812}, "output": 736}, {"input": {"n": 533}, "output": 471}], "error_log": []}
{"context": "Given a string of digits, how many unique prime numbers can be formed by permuting the digits in the string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numbers` (str): A string of digits from which permutations will be generated. Each character in the string represents a digit.\n\nOutput:\n  `return` (int): The number of unique prime numbers that can be formed by permuting the digits in the input string.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef definePrime(num):\n    if num == 1 or num == 0:\n        return False\n\n    for i in range(2, num):\n        if num % i == 0:\n            return False\n    return True\n\ndef permu(level, numbers, visited, nums, permus):\n    if level == len(numbers):\n        permus.add(int(nums))\n        return\n\n    if nums != \"\":\n        permus.add(int(nums))\n\n    for i in range(len(numbers)):\n        if not visited[i]:\n            visited[i] = True\n            permu(level + 1, numbers, visited, nums + numbers[i], permus)\n            visited[i] = False\n\n# main function\ndef main_solution(numbers):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    permus = set()\n    visited = [False] * len(numbers)\n    permu(0, numbers, visited, \"\", permus)\n    \n    answer = 0\n    for prime in permus:\n        if definePrime(prime):\n            answer += 1\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return answer", "input_generator": "import random\n\ndef input_generator():\n    digits = random.randint(1, 5)\n    numbers = ''.join(random.sample('0123456789', digits))\n    return {'numbers': numbers}", "io_pairs": [{"input": {"numbers": "607"}, "output": 3}, {"input": {"numbers": "67"}, "output": 2}, {"input": {"numbers": "21"}, "output": 1}, {"input": {"numbers": "371"}, "output": 11}, {"input": {"numbers": "04"}, "output": 0}, {"input": {"numbers": "61740"}, "output": 22}, {"input": {"numbers": "314"}, "output": 6}, {"input": {"numbers": "398"}, "output": 6}, {"input": {"numbers": "09451"}, "output": 31}, {"input": {"numbers": "8"}, "output": 0}], "error_log": []}
{"context": "Given a grid of `m` rows and `n` columns, a robot starts at the top-left corner of the grid (coordinate [0,0]). The robot can move to adjacent cells (left, right, up, down) but cannot move outside the grid or to a cell where the sum of the digits of the row and column indices exceeds `k`. How many cells can the robot reach?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The number of rows in the grid.\n  `n` (int): The number of columns in the grid.\n  `k` (int): The maximum sum of the digits of the row and column indices that the robot can move to.\n\nOutput:\n  `return` (int): The number of cells the robot can reach.", "reference_code": "# import necessary packages\nfrom queue import Queue\n\n# all class and function definitions in the code file, if any\ndef digitsum(n):\n    ans = 0\n    while n:\n        ans += n % 10\n        n //= 10\n    return ans\n\n# main function\ndef main_solution(m, n, k):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # BFS implementation\n    q = Queue()\n    q.put((0, 0))\n    s = set()\n    while not q.empty():\n        x, y = q.get()\n        if (x, y) not in s and 0 <= x < m and 0 <= y < n and digitsum(x) + digitsum(y) <= k:\n            s.add((x, y))\n            for nx, ny in [(x + 1, y), (x, y + 1)]:\n                q.put((nx, ny))\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return len(s)", "input_generator": "import random\n\ndef input_generator():\n    m = random.randint(1, 100)\n    n = random.randint(1, 100)\n    k = random.randint(1, 50)\n    return {'m': m, 'n': n, 'k': k}", "io_pairs": [{"input": {"m": 54, "n": 17, "k": 40}, "output": 918}, {"input": {"m": 61, "n": 28, "k": 34}, "output": 1708}, {"input": {"m": 76, "n": 72, "k": 8}, "output": 45}, {"input": {"m": 88, "n": 24, "k": 46}, "output": 2112}, {"input": {"m": 90, "n": 66, "k": 21}, "output": 5145}, {"input": {"m": 6, "n": 58, "k": 33}, "output": 348}, {"input": {"m": 17, "n": 53, "k": 50}, "output": 901}, {"input": {"m": 57, "n": 57, "k": 17}, "output": 2615}, {"input": {"m": 64, "n": 31, "k": 21}, "output": 1950}, {"input": {"m": 90, "n": 52, "k": 4}, "output": 15}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = \\frac{\\sin(x)}{x} \\) for \\( x \\neq 0 \\) and \\( f(0) = 1 \\), how would you approximate the integral of this function over a specified interval using three different numerical integration methods: the composite trapezoidal formula, the compound Simpson's formula, and the half-trapezoidal method? What are the results of these approximations for a given interval and parameters?\n\nThe input and output requirements are as follows:\n\nInput:\n  `lower_limit` (float): The lower limit of the integration interval.\n  `upper_limit` (float): The upper limit of the integration interval.\n  `divide` (int): The number of divisions for the composite trapezoidal and Simpson's rule.\n  `deviation` (float): The acceptable deviation for the half-trapezoidal method.\n\nOutput:\n  `return` (dict): A dictionary containing the results of the integration methods.\n    - `trapezoidal_result` (float): The result of the composite trapezoidal formula.\n    - `simpson_result` (float): The result of the compound Simpson's formula.\n    - `half_trapezoidal_result` (float): The result of the half-trapezoidal method.", "reference_code": "# import necessary packages\nfrom math import sin\n\n# all class and function definitions in the code file, if any\ndef f(x):\n    if x == 0:\n        return 1\n    return sin(x) / x\n\ndef composite_trapezoidal_formula(function, lower_limit, upper_limit, divide):\n    tmp = 0\n    step = (upper_limit - lower_limit) / divide\n    for i in range(divide):\n        tmp = tmp + function(lower_limit + i * step) + function(lower_limit + (i + 1) * step)\n    return step / 2 * tmp\n\ndef compound_Simpson_formula(function, lower_limit, upper_limit, divide):\n    tmp = 0\n    step = (upper_limit - lower_limit) / divide\n    for i in range(divide):\n        tmp = tmp + function(lower_limit + i * step) + function(lower_limit + (i + 1) * step) + 4 * function(((lower_limit + i * step) + (lower_limit + (i + 1) * step)) / 2)\n    return step / 6 * tmp\n\ndef half_trapezoidal(function, lower_limit, upper_limit, deviation):\n    T_n = 1 / 2 * (function(lower_limit) + function(upper_limit))\n    length = (upper_limit - lower_limit)\n    divide = 1\n    step = length / divide\n    k = 0\n    while True:\n        tmp = 0\n        for i in range(divide):\n            tmp = tmp + function(((lower_limit + i * step) + (lower_limit + (i + 1) * step)) / 2)\n        T_2n = 1 / 2 * T_n + step / 2 * tmp\n        if abs(T_2n - T_n) < deviation:\n            return T_2n\n        T_n = T_2n\n        k = k + 1\n        divide = 2 ** k\n        step = length / divide\n\n# main function\ndef main_solution(lower_limit, upper_limit, divide, deviation):\n    # Convert JSON serializable inputs to original input variables\n    lower_limit = float(lower_limit)\n    upper_limit = float(upper_limit)\n    divide = int(divide)\n    deviation = float(deviation)\n    \n    # Calculate results using the original functions\n    trapezoidal_result = composite_trapezoidal_formula(f, lower_limit, upper_limit, divide)\n    simpson_result = compound_Simpson_formula(f, lower_limit, upper_limit, divide)\n    half_trapezoidal_result = half_trapezoidal(f, lower_limit, upper_limit, deviation)\n    \n    # Convert results to JSON serializable outputs\n    return {\n        \"trapezoidal_result\": trapezoidal_result,\n        \"simpson_result\": simpson_result,\n        \"half_trapezoidal_result\": half_trapezoidal_result\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random lower and upper limits, ensuring lower < upper\n    lower_limit = random.uniform(-10.0, 10.0)\n    upper_limit = random.uniform(lower_limit + 0.1, lower_limit + 20.0)\n    \n    # Generate a random divide value, ensuring it's a positive integer\n    divide = random.randint(1, 100)\n    \n    # Generate a small positive deviation\n    deviation = random.uniform(1e-6, 1e-3)\n    \n    return {\n        \"lower_limit\": lower_limit,\n        \"upper_limit\": upper_limit,\n        \"divide\": divide,\n        \"deviation\": deviation\n    }", "io_pairs": [{"input": {"lower_limit": -2.270915341066779, "upper_limit": 13.754785385146162, "divide": 92, "deviation": 0.0006024324342853953}, "output": {"trapezoidal_result": 3.25073663228838, "simpson_result": 3.2517731716283818, "half_trapezoidal_result": 3.2514022669343374}}, {"input": {"lower_limit": 6.9634191053563015, "upper_limit": 17.322569079431453, "divide": 23, "deviation": 0.00023903349908435638}, "output": {"trapezoidal_result": 0.11875187336853422, "simpson_result": 0.12032434013346859, "half_trapezoidal_result": 0.12017364073475037}}, {"input": {"lower_limit": 5.718907911440127, "upper_limit": 17.129289958319646, "divide": 35, "deviation": 0.0007818098675849988}, "output": {"trapezoidal_result": 0.13683494514398778, "simpson_result": 0.13833878832105326, "half_trapezoidal_result": 0.13910518809879477}}, {"input": {"lower_limit": -7.112999743807418, "upper_limit": 2.3280987120410312, "divide": 37, "deviation": 0.0009579475976803222}, "output": {"trapezoidal_result": 3.1950288959620323, "simpson_result": 3.1969229157377095, "half_trapezoidal_result": 3.1960650087310682}}, {"input": {"lower_limit": 0.8154437524555931, "upper_limit": 18.644941769654075, "divide": 53, "deviation": 0.0004264385936156238}, "output": {"trapezoidal_result": 0.736135927543711, "simpson_result": 0.7332336631562817, "half_trapezoidal_result": 0.7330081086398876}}, {"input": {"lower_limit": -2.79957039855889, "upper_limit": 2.166222898728559, "divide": 11, "deviation": 0.0007008758350065709}, "output": {"trapezoidal_result": 3.4931504111990197, "simpson_result": 3.507014784562685, "half_trapezoidal_result": 3.506522472514978}}, {"input": {"lower_limit": -2.118981361374712, "upper_limit": 17.681192678537794, "divide": 47, "deviation": 0.000811217437777185}, "output": {"trapezoidal_result": 3.202007871660296, "simpson_result": 3.2080964631573106, "half_trapezoidal_result": 3.207288517105132}}, {"input": {"lower_limit": -4.331107583636136, "upper_limit": 2.077389457365258, "divide": 74, "deviation": 0.0005175399421992506}, "output": {"trapezoidal_result": 3.3296697009395793, "simpson_result": 3.329965092311836, "half_trapezoidal_result": 3.3296918930547728}}, {"input": {"lower_limit": 3.9384993345567487, "upper_limit": 14.890035336281661, "divide": 94, "deviation": 0.0008220702793861057}, "output": {"trapezoidal_result": -0.15640513630993938, "simpson_result": -0.15649802860166212, "half_trapezoidal_result": -0.15585300750004139}}, {"input": {"lower_limit": 0.34337652574017064, "upper_limit": 11.39268645031173, "divide": 91, "deviation": 0.0004741243065668985}, "output": {"trapezoidal_result": 1.2032017043240328, "simpson_result": 1.2030122499312101, "half_trapezoidal_result": 1.2027363998202785}}], "error_log": []}
{"context": "Given a graph with a certain number of vertices and edges, determine if an Eulerian Circuit exists. If it does, provide the sequence of vertices that form the Eulerian Circuit. What is the Eulerian Circuit for the given graph?\n\nThe input and output requirements are as follows:\n\nInput:\n  `vertices` (int): The number of vertices in the graph.\n  `edges` (list of lists): A list of edges where each edge is represented as a list of two integers, representing the vertices connected by the edge.\n\nOutput:\n  `return` (str): A JSON serialized string representing the Eulerian Circuit if it exists, otherwise an empty list.", "reference_code": "# import necessary packages\nfrom collections import defaultdict\nimport json\n\n# all class and function definitions in the code file, if any\nclass Graph:\n\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        \n    def remEdge(self, u, v):\n        for i in self.graph:\n            if i == u:\n                self.graph[i].remove(v)\n        for i in self.graph:\n            if i == v:\n                self.graph[i].remove(u)\n\n    def DFS(self, v, visited):\n        visited[v] = True\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFS(i, visited)\n\n    def isConnected(self):\n        visited = defaultdict(bool)\n        for i in self.graph:\n            visited[i] = False\n        counter = 0\n        for i in self.graph:\n            counter += 1\n            if len(self.graph[i]) > 1:\n                break\n        if counter == self.V - 1:\n            return True\n        self.DFS(i, visited)\n        for i in self.graph:\n            if visited[i] == False and len(self.graph[i]) > 0:\n                return False\n        return True\n\n    def isEulerianCircuitExists(self):\n        if self.isConnected() == False:\n            return False\n        else:\n            odd = 0\n            for i in self.graph:\n                if len(self.graph[i]) % 2 != 0:\n                    odd += 1\n            if odd == 0:\n                return True\n            else: return False\n            \n    def EulerianCircuitfromHeirholzer(self):\n        stack = []\n        circuit = []\n        start_vertex = list(self.graph.keys())[0]\n        stack.append(start_vertex)\n        while stack:\n            v = stack[-1]\n            if len(self.graph[v])==0:\n                circuit.append(stack.pop())\n            else:\n                next_vertex = self.graph[v][0]\n                self.remEdge(v,next_vertex)\n                stack.append(next_vertex)\n        return circuit\n\n# main function\ndef main_solution(vertices, edges):\n    # Convert JSON serializable inputs to original input variables\n    graph = Graph(vertices)\n    for edge in edges:\n        graph.addEdge(edge[0], edge[1])\n    \n    # Check if Eulerian Circuit exists\n    if graph.isEulerianCircuitExists():\n        circuit = graph.EulerianCircuitfromHeirholzer()\n        # Convert the output to JSON serializable format\n        return json.dumps(circuit)\n    else:\n        return json.dumps([])", "input_generator": "import random\nimport json\n\ndef input_generator():\n    vertices = random.randint(3, 10)\n    edges = []\n    max_edges = min(vertices * (vertices - 1) // 2, 15)  # Limit edges to avoid too dense graphs\n    \n    # Ensure the graph is connected and has even degree for all vertices (Eulerian circuit exists)\n    # First, create a cycle to ensure connectivity\n    for i in range(vertices):\n        edges.append((i, (i + 1) % vertices))\n    \n    # Add some random edges to ensure all vertices have even degree\n    remaining_edges = max_edges - vertices\n    possible_edges = []\n    for u in range(vertices):\n        for v in range(u + 1, vertices):\n            if (u, v) not in edges and (v, u) not in edges:\n                possible_edges.append((u, v))\n    \n    # Randomly select edges to add, ensuring degrees remain even\n    random.shuffle(possible_edges)\n    added = 0\n    for edge in possible_edges:\n        if added >= remaining_edges:\n            break\n        edges.append(edge)\n        added += 1\n    \n    return {'vertices': vertices, 'edges': edges}", "io_pairs": [{"input": {"vertices": 4, "edges": [[0, 1], [1, 2], [2, 3], [3, 0], [0, 2], [1, 3]]}, "output": "[]"}, {"input": {"vertices": 3, "edges": [[0, 1], [1, 2], [2, 0]]}, "output": "[0, 2, 1, 0]"}, {"input": {"vertices": 4, "edges": [[0, 1], [1, 2], [2, 3], [3, 0], [1, 3], [0, 2]]}, "output": "[]"}], "error_log": []}
{"context": "Given a set of known data points, how can we approximate the value of a function f(x) at a specific point x using Lagrange interpolation? Specifically, what is the interpolated value of f(x) at the desired x-value based on the provided x and f(x) values?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_data_points` (int): The number of known data points.\n  `x_values` (list of float): A list of x-values corresponding to the known data points.\n  `fx_values` (list of float): A list of f(x) values corresponding to the known data points.\n  `x_desired` (float): The x-value for which the function f(x) needs to be calculated.\n\nOutput:\n  `return` (float): The interpolated value of f(x) at the desired x-value.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(num_data_points, x_values, fx_values, x_desired):\n    # Convert JSON serializable inputs to numpy array\n    matriz = np.zeros((2, num_data_points))\n    for i in range(num_data_points):\n        matriz[0, i] = x_values[i]\n        matriz[1, i] = fx_values[i]\n    \n    # Lagrange interpolation function\n    def lagrange(x):\n        L0 = ((np.poly1d([1, 0]) - float(matriz[0, 1])) / (float(matriz[0, 0]) - float(matriz[0, 1])))\n        L1 = ((np.poly1d([1, 0]) - float(matriz[0, 0])) / (float(matriz[0, 1]) - float(matriz[0, 0])))\n        px = (float(matriz[1, 0]) * L0) + (float(matriz[1, 1]) * L1)\n        return px\n    \n    # Calculate the solution\n    sol = lagrange(x_desired)\n    result = sol(x_desired)\n    \n    # Return the result as a JSON serializable output\n    return float(result)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    num_data_points = 2\n    x_values = sorted([round(random.uniform(-10, 10), 2) for _ in range(num_data_points)])\n    fx_values = [round(random.uniform(-10, 10), 2) for _ in range(num_data_points)]\n    x_desired = round(random.uniform(min(x_values), max(x_values)), 2)\n    \n    return {\n        'num_data_points': num_data_points,\n        'x_values': x_values,\n        'fx_values': fx_values,\n        'x_desired': x_desired\n    }", "io_pairs": [{"input": {"num_data_points": 2, "x_values": [-7.75, 0.4], "fx_values": [-1.64, -5.58], "x_desired": -0.12}, "output": -5.328613496932515}, {"input": {"num_data_points": 2, "x_values": [-6.97, -0.25], "fx_values": [1.79, -5.21], "x_desired": -2.94}, "output": -2.407916666666666}, {"input": {"num_data_points": 2, "x_values": [-9.38, 7.95], "fx_values": [9.91, -1.32], "x_desired": 3.76}, "output": 1.3951586843623769}, {"input": {"num_data_points": 2, "x_values": [0.91, 8.55], "fx_values": [6.52, -8.57], "x_desired": 7.76}, "output": -7.009646596858637}, {"input": {"num_data_points": 2, "x_values": [-6.57, 2.4], "fx_values": [2.36, 2.27], "x_desired": -1.59}, "output": 2.3100334448160535}, {"input": {"num_data_points": 2, "x_values": [-8.51, 3.72], "fx_values": [-6.36, -9.62], "x_desired": -2.84}, "output": -7.871381847914963}, {"input": {"num_data_points": 2, "x_values": [1.45, 5.76], "fx_values": [3.76, 6.87], "x_desired": 3.04}, "output": 4.907308584686776}, {"input": {"num_data_points": 2, "x_values": [-2.09, 5.1], "fx_values": [8.49, 5.19], "x_desired": 3.65}, "output": 5.855507649513213}, {"input": {"num_data_points": 2, "x_values": [4.12, 8.54], "fx_values": [-5.17, -0.19], "x_desired": 6.46}, "output": -2.5335294117647065}, {"input": {"num_data_points": 2, "x_values": [-7.71, -1.69], "fx_values": [4.65, 8.66], "x_desired": -2.21}, "output": 8.313621262458472}], "error_log": []}
{"context": "Given a stochastic differential equation (SDE) with coefficients `a` and `b`, and a time interval up to `y`, what are the strong and weak convergence errors when solving the SDE using the Euler-Maruyama method with `nsteps` discretization steps?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The coefficient for the deterministic part of the SDE.\n  `b` (float): The coefficient for the stochastic part of the SDE.\n  `y` (int): The time up to which the solution is computed.\n  `nsteps` (int): The number of steps in the discretization of the time interval.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `error_strong` (float): The average absolute difference between the numerical and analytic solutions (strong convergence error).\n    - `error_weak` (float): The absolute difference between the average values of the numerical and analytic solutions (weak convergence error).", "reference_code": "# import necessary packages\nimport numpy as np\nfrom math import exp, log, sqrt\n\n# function implementing Euler-Maruyama method\n# probe_fnctn is the the expression for dy/dx\ndef euler_maruyama_method(a, b, rwalk, h):\n    output_list = list()\n    \n    # setting initial values for X(t) and t\n    y = 1.0\n    t = 0\n    w_prev = 0\n    \n    for W_n in rwalk:\n        output_list.append(y)\n        y += a*h + b*(W_n - w_prev)\n        w_prev = W_n\n        t += h\n    output_list.append(y)\n    return output_list\n\n# main function\ndef main_solution(a, b, y, nsteps):\n    # all input arguments of the main_solution function should be json serializable\n    h = 1.0 / (float(nsteps))\n    \n    # creation of 'x' axis (with re-scaling)\n    t = np.arange(1, nsteps * y + 1, int(nsteps / nsteps))\n    steps = np.random.randint(0, 2, size=nsteps * y)\n    steps = np.where(steps > 0, 1, -1)\n    steps = steps * (1 / sqrt(nsteps))\n    rwalk = steps.cumsum()\n\n    buff_list1 = euler_maruyama_method(a, b, rwalk, h)\n    \n    # adjusting output to analytic solution X(t)\n    buff_list2 = [1]\n    for indx, z in enumerate(rwalk):\n        buff_list2.append(exp(t[indx] / nsteps + z))\n    \n    # STRONG convergence\n    error_strong = sum(abs(elem1 - elem2) for elem1, elem2 in zip(buff_list1, buff_list2)) / len(buff_list1)\n    \n    # WEAK convergence\n    error_weak_1 = sum(buff_list1) / len(buff_list1)\n    error_weak_2 = sum(buff_list2) / len(buff_list2)\n    error_weak = abs(error_weak_1 - error_weak_2)\n    \n    # return, the returned value must be json serializable\n    return {\n        \"error_strong\": error_strong,\n        \"error_weak\": error_weak\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    a = random.uniform(0.1, 2.0)\n    b = random.uniform(0.1, 2.0)\n    y = random.randint(1, 10)\n    nsteps = random.randint(100, 1000)\n    return {\n        \"a\": a,\n        \"b\": b,\n        \"y\": y,\n        \"nsteps\": nsteps\n    }", "io_pairs": [{"input": {"a": 0.6230158356724722, "b": 0.9096547581703438, "y": 9, "nsteps": 703}, "output": {"error_strong": 41.40742783018995, "error_weak": 41.40742573267821}}, {"input": {"a": 1.9794561149053025, "b": 1.74454210155597, "y": 7, "nsteps": 855}, "output": {"error_strong": 498.8184743009776, "error_weak": 498.81415726754113}}, {"input": {"a": 0.9112574947547921, "b": 1.842488386210186, "y": 4, "nsteps": 819}, "output": {"error_strong": 26.91464122206988, "error_weak": 26.90195682354812}}, {"input": {"a": 1.9572085625880629, "b": 0.634245929672705, "y": 3, "nsteps": 632}, "output": {"error_strong": 2.6091972794333165, "error_weak": 1.2187457380091158}}, {"input": {"a": 0.5316529680717602, "b": 1.4893806085188712, "y": 4, "nsteps": 582}, "output": {"error_strong": 8.245262721540222, "error_weak": 8.245262721540207}}, {"input": {"a": 0.9509408357969423, "b": 1.5842508611041894, "y": 9, "nsteps": 307}, "output": {"error_strong": 46.374656520370415, "error_weak": 46.374389857536976}}, {"input": {"a": 1.6239429519809445, "b": 1.0543306241774162, "y": 6, "nsteps": 218}, "output": {"error_strong": 1.2310167454413459, "error_weak": 1.191520134260851}}, {"input": {"a": 0.8779325450229136, "b": 0.6527872630225915, "y": 3, "nsteps": 452}, "output": {"error_strong": 26.943478285284954, "error_weak": 26.940351501687697}}, {"input": {"a": 1.4271093795416059, "b": 1.8074487252307683, "y": 3, "nsteps": 394}, "output": {"error_strong": 1.6308199735004418, "error_weak": 1.623371078553989}}, {"input": {"a": 1.8415929727237563, "b": 0.6703810216027086, "y": 8, "nsteps": 793}, "output": {"error_strong": 25.781095382469708, "error_weak": 25.326703786736587}}], "error_log": []}
{"context": "Given a set of vectors in 3-dimensional space, we need to determine the effect of rotating one of the vectors after orthogonalizing the set using the Gram-Schmidt process. Specifically, what is the resulting vector when the first vector in the orthogonal basis is rotated by a given angle?\n\nThe input and output requirements are as follows:\n\nInput:\n- `vectors` (list of lists of floats): A list of vectors, where each vector is represented as a list of its components.\n- `angle` (float): The angle in radians by which to rotate the first vector in the orthogonal basis.\n\nOutput:\n- `return` (list of lists of floats): A list containing the rotated vector as a list of its components.", "reference_code": "# import necessary packages\nfrom math import sqrt, sin, cos\nimport random\n\n# all class and function definitions in the code file, if any\nclass Vector:\n    def __init__(self, *comps):\n        self.components = tuple(comps)\n    \n    def __len__(self):\n        return len(self.components)\n    \n    def __eq__(self, other):\n        selfDim = len(self.components)\n        if selfDim != len(other.components):\n            return False\n        \n        for i in range(selfDim):\n            if self.components[i] != other.components[i]:\n                return False\n        return True\n    \n    def __neq__(self, other):\n        return not self.__eq__(other)\n    \n    def iszero(self, zeroVal=0):\n        return all(c == zeroVal for c in self.components)\n    \n    def __abs__(self):\n        total = None\n        for c in self.components:\n            if total is None:\n                total = c * c\n            else:\n                total += c * c\n        \n        if total is None:\n            return 0\n        else:\n            return sqrt(total)\n    \n    def __getitem__(self, key):\n        return self.components[key]\n    \n    def __add__(self, other):\n        if not isinstance(other, Vector):\n            raise TypeError(\"Vectors can only be added to other Vectors\")\n        \n        selfDim, otherDim = len(self), len(other)\n        if selfDim != otherDim:\n            raise ValueError(f\"Vector dimensions do not match: {selfDim} and {otherDim}\")\n        \n        return Vector(*(self.components[i] + other.components[i] for i in range(selfDim)))\n    \n    def __sub__(self, other):\n        if not isinstance(other, Vector):\n            raise TypeError(\"Vectors can only be added to other Vectors\")\n        \n        selfDim, otherDim = len(self), len(other)\n        if selfDim != otherDim:\n            raise ValueError(f\"Vector dimensions do not match: {selfDim} and {otherDim}\")\n        \n        return Vector(*(self.components[i] - other.components[i] for i in range(selfDim)))\n    \n    def __mul__(self, other):\n        selfDim = len(self)\n        if isinstance(other, Vector):\n            otherDim = len(other)\n            if selfDim != otherDim:\n                raise ValueError(f\"Vector dimensions do not match: {selfDim} and {otherDim}\")\n            \n            dot = None\n            for i in range(selfDim):\n                prod = self.components[i] * other.components[i]\n                \n                if dot is None:\n                    dot = prod\n                else:\n                    dot += prod\n            return dot\n        else:\n            return Vector(*(other * self.components[i] for i in range(selfDim)))\n    \n    def __rmul__(self, other):\n        return self.__mul__(other)\n    \n    def __div__(self, other):\n        return self.__truediv__(other)\n    \n    def __truediv__(self, other):\n        selfDim = len(self)\n        return Vector(*(self.components[i] / other for i in range(selfDim)))\n    \n    def __floordiv__(self, other):\n        selfDim = len(self)\n        return Vector(*(self.components[i] // other for i in range(selfDim)))\n    \n    def __repr__(self):\n        return 'Vector(' + ', '.join(map(str, self.components)) + ')'\n    \n    def rotate(self, rotand, angle):\n        \"\"\"\n        Rotate the `rotand` about the rotator defined by `self`\n        by an angle of `angle` counterclockwise.\n        Note: Uses Rodriguez Rotation Formula\n        \n        Args:\n            rotand (Vector) -- Vector to rotate around self\n            angle (float) -- angle by which to rotate in radians\n        \n        Returns:\n            Vector -- rotated vector\n        \"\"\"\n        \n        c, s = cos(angle), sin(angle)\n        selfMag = abs(self)\n        \n        total = rotand * c\n        total += cross(self, rotand) * (s / selfMag)\n        total += self * (self * rotand) * ((1 - c) / (selfMag * selfMag))\n        return total\n\ndef gramschmidt(*vectors):\n    basis, first = [], True\n    for v in vectors:\n        if first:\n            basis.append(v)\n        else:\n            for b in basis:\n                v -= (v * b) / (b * b) * b\n            \n            if not v.iszero():\n                basis.append(v)\n    \n    return basis\n\ndef zero(dims=3, zeroVal=0):\n    return Vector(*(zeroVal for i in range(dims)))\n\ndef cross(vec1, vec2):\n    if not isinstance(vec1, Vector) or not isinstance(vec2, Vector):\n        raise TypeError(\"Cross Product only defined between Vectors\")\n    \n    dim1, dim2 = len(vec1), len(vec2)\n    if dim1 != dim2:\n        raise ValueError(f\"Vector dimensions do not match: {dim1} and {dim2}\")\n    \n    if dim1 == 2:\n        return vec1.components[0] * vec2.components[1] - vec1.components[1] * vec2.components[0]\n    elif dim1 == 3:\n        x = vec1.components[1] * vec2.components[2] - vec1.components[2] * vec2.components[1]\n        y = vec1.components[2] * vec2.components[0] - vec1.components[0] * vec2.components[2]\n        z = vec1.components[0] * vec2.components[1] - vec1.components[1] * vec2.components[0]\n        return Vector(x, y, z)\n    else:\n        raise ValueError(f\"Cross Product not defined on Vectors of dimension {dim1}\")\n\n# main function\ndef main_solution(vectors, angle):\n    # Convert JSON serializable inputs to original input variables\n    vectors = [Vector(*v) for v in vectors]\n    \n    # Apply Gram-Schmidt process to orthogonalize the vectors\n    orthogonal_basis = gramschmidt(*vectors)\n    \n    # Rotate the first vector in the orthogonal basis by the given angle\n    rotated_vector = orthogonal_basis[0].rotate(orthogonal_basis[0], angle)\n    \n    # Convert the result to JSON serializable output\n    return [list(rotated_vector.components)]", "input_generator": "import random\nimport math\nfrom math import pi\n\ndef input_generator():\n    # Randomly choose the number of vectors (between 2 and 4)\n    num_vectors = random.randint(2, 4)\n    # Randomly choose the dimension of vectors (2 or 3)\n    dim = random.choice([2, 3])\n    \n    vectors = []\n    for _ in range(num_vectors):\n        # Generate random components for each vector\n        components = [round(random.uniform(-10, 10), 2) for _ in range(dim)]\n        vectors.append(components)\n    \n    # Generate a random angle between 0 and 2*pi\n    angle = round(random.uniform(0, 2 * pi), 2)\n    \n    return {\n        'vectors': vectors,\n        'angle': angle\n    }", "io_pairs": [{"input": {"vectors": [[1.31, -0.79, -7.3], [4.22, -7.1, -4.52]], "angle": 2.43}, "output": [[1.31, -0.7900000000000001, -7.3]]}, {"input": {"vectors": [[-1.95, 5.68, 4.3], [-6.21, 3.34, 4.24]], "angle": 6.23}, "output": [[-1.95, 5.68, 4.3]]}, {"input": {"vectors": [[7.28, -2.09, -4.22], [-8.09, 3.03, -8.9]], "angle": 4.53}, "output": [[7.28, -2.09, -4.22]]}, {"input": {"vectors": [[-5.76, -7.31, 4.86], [2.5, -9.32, -9.67]], "angle": 4.14}, "output": [[-5.759999999999998, -7.309999999999998, 4.859999999999998]]}, {"input": {"vectors": [[8.08, -0.41, -9.2], [-1.57, -1.6, 2.46]], "angle": 1.44}, "output": [[8.08, -0.41, -9.2]]}, {"input": {"vectors": [[9.7, -2.39, -0.44], [4.51, 2.82, -6.3], [-4.6, -6.05, 2.07]], "angle": 2.31}, "output": [[9.700000000000005, -2.3900000000000006, -0.44000000000000017]]}, {"input": {"vectors": [[-4.37, 8.69, 5.53], [-8.28, 0.56, -7.25], [-3.37, 6.98, 2.18]], "angle": 2.48}, "output": [[-4.369999999999999, 8.689999999999998, 5.53]]}, {"input": {"vectors": [[-0.35, 5.96, -3.46], [-4.08, -5.49, -4.09]], "angle": 2.78}, "output": [[-0.35, 5.960000000000002, -3.460000000000001]]}, {"input": {"vectors": [[-1.86, -0.8, -0.34], [9.32, 7.35, 3.41]], "angle": 2.03}, "output": [[-1.8599999999999994, -0.7999999999999998, -0.33999999999999997]]}, {"input": {"vectors": [[1.63, -8.01, 9.27], [1.29, -2.34, 4.38]], "angle": 0.38}, "output": [[1.63, -8.01, 9.27]]}], "error_log": []}
{"context": "Given a mathematical function `x^3 - 4x - yi`, where `yi` is a constant, and an interval `[a, b]`, what are the successive approximations of the root of the function using the False Position method, given tolerances `e1` and `e2` for the interval size and function value, respectively?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The initial lower bound of the interval.\n  `b` (float): The initial upper bound of the interval.\n  `e1` (float): The tolerance for the interval size.\n  `e2` (float): The tolerance for the function value.\n  `yi` (float): The constant term in the function `x^3 - 4x - yi`.\n\nOutput:\n  `return` (list of floats): A list of approximations of the root of the function `x^3 - 4x - yi` obtained using the False Position method.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef testFuncion(x, yi):\n    return x**3 - (4*x) - yi\n\n# main function\ndef main_solution(a, b, e1, e2, yi):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    salida = []\n    while True:\n        c = b - ((testFuncion(b, yi) * (b - a)) / (testFuncion(b, yi) - testFuncion(a, yi)))\n        salida.append(c)\n        if abs(testFuncion(c, yi)) < (e2 / 100):\n            break\n        if abs(b - a) < (e1 / 100):\n            break\n        if (testFuncion(c, yi) * testFuncion(a, yi)) < 0:\n            b = c\n        else:\n            a = c\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return salida", "input_generator": "import random\n\ndef input_generator():\n    a = random.uniform(-10.0, 10.0)\n    b = random.uniform(a + 0.1, a + 10.0)  # Ensure b > a\n    e1 = random.uniform(0.001, 0.1)\n    e2 = random.uniform(0.001, 0.1)\n    yi = random.uniform(-100.0, 100.0)\n    return {'a': a, 'b': b, 'e1': e1, 'e2': e2, 'yi': yi}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a binary tree represented by a string in level order traversal format, where nodes are separated by spaces and \"N\" denotes a NULL child, what is the inorder traversal of the mirrored binary tree?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_string` (str): A string representing the binary tree in level order traversal format. Nodes are separated by spaces, and \"N\" denotes a NULL child.\n\nOutput:\n  `return` (list of int): A list of integers representing the inorder traversal of the mirrored binary tree.", "reference_code": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, val):\n        self.right = None\n        self.data = val\n        self.left = None\n\ndef buildTree(s):\n    if(len(s)==0 or s[0]==\"N\"):           \n        return None\n        \n    ip=list(map(str,s.split()))\n    \n    root=Node(int(ip[0]))                     \n    size=0\n    q=deque()\n    \n    q.append(root)                            \n    size=size+1 \n    \n    i=1                                       \n    while(size>0 and i<len(ip)):\n        currNode=q[0]\n        q.popleft()\n        size=size-1\n        \n        currVal=ip[i]\n        \n        if(currVal!=\"N\"):\n            currNode.left=Node(int(currVal))\n            q.append(currNode.left)\n            size=size+1\n        i=i+1\n        if(i>=len(ip)):\n            break\n        currVal=ip[i]\n        \n        if(currVal!=\"N\"):\n            currNode.right=Node(int(currVal))\n            q.append(currNode.right)\n            size=size+1\n        i=i+1\n    return root\n\ndef mirror(root):\n    if root == None:\n        return \n    \n    temp = root.left\n    root.left = root.right\n    root.right = temp\n    \n    mirror(root.left)\n    mirror(root.right)\n\ndef inorderTraversalUtil(root):\n    if root is None:\n        return []\n    return inorderTraversalUtil(root.left) + [root.data] + inorderTraversalUtil(root.right)\n\n# main function\ndef main_solution(tree_string):\n    # Convert the input string to a binary tree\n    root = buildTree(tree_string)\n    \n    # Mirror the binary tree\n    mirror(root)\n    \n    # Get the inorder traversal of the mirrored tree\n    inorder_result = inorderTraversalUtil(root)\n    \n    # Convert the result to a JSON serializable format\n    return inorder_result", "input_generator": "import random\nfrom random import randint\n\ndef input_generator():\n    # Generate a random binary tree string\n    levels = randint(1, 5)  # Limit tree depth to keep it reasonable\n    nodes = []\n    if levels == 0:\n        return {'tree_string': ''}\n    \n    nodes.append(str(randint(1, 100)))  # Root node\n    \n    for i in range(1, 2**levels - 1):\n        if random.random() < 0.7:  # 70% chance to add a node\n            nodes.append(str(randint(1, 100)))\n        else:\n            nodes.append(\"N\")\n    \n    tree_string = ' '.join(nodes)\n    return {'tree_string': tree_string}", "io_pairs": [{"input": {"tree_string": "78 N 12 89 44 19 N"}, "output": [44, 12, 89, 19, 78]}, {"input": {"tree_string": "21 N 93"}, "output": [93, 21]}, {"input": {"tree_string": "21 81 N N N 17 N N 77 98 12 81 13 N N N 3 23 65 57 83 N 48 N N 62 94 N 38 77 90"}, "output": [21, 81]}, {"input": {"tree_string": "34 77 49"}, "output": [49, 34, 77]}, {"input": {"tree_string": "19"}, "output": [19]}, {"input": {"tree_string": "44 29 96 98 45 57 N"}, "output": [96, 57, 44, 45, 29, 98]}, {"input": {"tree_string": "49 86 32 N 40 30 33 57 13 N 35 34 24 N 66"}, "output": [24, 33, 34, 32, 35, 30, 49, 13, 40, 66, 57, 86]}, {"input": {"tree_string": "18 N 1 N N 69 N"}, "output": [1, 18]}, {"input": {"tree_string": "5 8 74 79 N N 86"}, "output": [86, 74, 5, 8, 79]}, {"input": {"tree_string": "78 78 15 82 50 N 5"}, "output": [5, 15, 78, 50, 78, 82]}], "error_log": []}
{"context": "Given a chessboard of size `n` x `n`, how many distinct ways can you place `n` queens on the board such that no two queens threaten each other?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (int): The number of distinct solutions to the N-Queens problem for the given board size `n`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_valid(board):\n    \"\"\"\n    Check if the current queen is attacked by previous queens\n    \"\"\"\n    N = len(board)\n    curr_queen_row, curr_queen_col = N-1, board[N-1]\n    for row, col in enumerate(board[:-1]):\n        diff = abs(curr_queen_col-col)\n        if diff==0 or diff==curr_queen_row-row:\n            return False\n    return True\n\ndef n_queens(n, board: list = []):\n    if n == len(board):\n        return 1\n    count = 0\n    for col in range(n):\n        board.append(col)\n        if is_valid(board):\n            count += n_queens(n, board)\n        board.pop()\n    return count\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return n_queens(n)", "input_generator": "import random\n\ndef input_generator():\n    n = random.choice([4, 5, 6, 7, 8])\n    return {'n': n}", "io_pairs": [{"input": {"n": 7}, "output": 40}, {"input": {"n": 5}, "output": 10}, {"input": {"n": 6}, "output": 4}, {"input": {"n": 4}, "output": 2}, {"input": {"n": 8}, "output": 92}], "error_log": []}
{"context": "In a forest fire simulation, a forest is represented as a grid where each cell can either be empty, contain a tree, or be on fire. Given a specific forest density and size, how many trees on average will burn if a fire starts in a random location within the forest, and what is the variance in the number of trees burned across multiple simulations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `density` (float): The density of the forest, representing the probability of a cell being a tree.\n  `forest_size` (int): The size of the forest, which is a square grid of size `forest_size x forest_size`.\n  `num_simulations` (int): The number of simulations to run to calculate the average number of trees burned.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `variance` (float): The variance of the number of trees burned across all simulations.\n    - `average_burned` (float): The average number of trees burned across all simulations.", "reference_code": "# import necessary packages\nimport numpy as np\nimport random\nimport math\n\n# all class and function definitions in the code file, if any\ndef init(d, x):\n    foret = np.zeros([x, x])\n    for i in range(1, x - 1):\n        for j in range(1, x - 1):\n            if random.random() < d:\n                foret[i, j] = 1\n            if foret[i, j] == 1:\n                continue\n    n = random.randint(1, x - 2)\n    m = random.randint(1, x - 2)\n    foret[n, m] = 2\n    return foret\n\ndef iteration(foret):\n    foret2 = np.copy(foret)\n    for k in range(1, foret2.shape[0] - 1):\n        for l in range(1, foret2.shape[1] - 1):\n            if (foret[k, l] == 1) and ((foret[k + 1, l] == 2) or (foret[k - 1, l] == 2) or (foret[k, l - 1] == 2) or (foret[k, l + 1] == 2)):\n                foret2[k, l] = 2\n            if foret[k, l] == 2:\n                foret2[k, l] = 3\n    return foret2\n\ndef comptage(foret):\n    nb_brules = 0\n    while 2 in foret:\n        foret = iteration(foret)\n    for i in range(1, foret.shape[0] - 1):\n        for j in range(1, foret.shape[1] - 1):\n            if foret[i, j] == 3:\n                nb_brules += 1\n    return nb_brules\n\ndef repetition(d, size, n):\n    i = 0\n    resultats_vecteurs = np.zeros([n])\n    while i < n:\n        foret = init(d, size)\n        resultats_vecteurs[i] = comptage(foret)\n        i += 1\n    m = np.average(resultats_vecteurs)\n    v = np.var(resultats_vecteurs)\n    ec = math.sqrt(v)\n    return (v, m)\n\n# main function\ndef main_solution(density, forest_size, num_simulations):\n    # Convert JSON serializable inputs to original input variables\n    density = float(density)\n    forest_size = int(forest_size)\n    num_simulations = int(num_simulations)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    variance, average_burned = repetition(density, forest_size, num_simulations)\n    \n    # Convert the output to JSON serializable\n    return {\"variance\": variance, \"average_burned\": average_burned}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    density = random.uniform(0.1, 0.5)\n    forest_size = random.randint(10, 20)\n    num_simulations = random.randint(5, 15)\n    return {\n        \"density\": density,\n        \"forest_size\": forest_size,\n        \"num_simulations\": num_simulations\n    }", "io_pairs": [{"input": {"density": 0.12330828724489772, "forest_size": 13, "num_simulations": 5}, "output": {"variance": 0.6400000000000002, "average_burned": 1.4}}, {"input": {"density": 0.1602443293975977, "forest_size": 20, "num_simulations": 10}, "output": {"variance": 4.61, "average_burned": 2.3}}, {"input": {"density": 0.18007836812886496, "forest_size": 16, "num_simulations": 6}, "output": {"variance": 1.9166666666666667, "average_burned": 2.5}}, {"input": {"density": 0.12106067348579695, "forest_size": 10, "num_simulations": 5}, "output": {"variance": 3.3600000000000003, "average_burned": 3.2}}, {"input": {"density": 0.11720528613505238, "forest_size": 16, "num_simulations": 15}, "output": {"variance": 1.8933333333333335, "average_burned": 1.8}}, {"input": {"density": 0.3316712582174087, "forest_size": 15, "num_simulations": 10}, "output": {"variance": 21.009999999999998, "average_burned": 4.3}}, {"input": {"density": 0.28782001270107, "forest_size": 11, "num_simulations": 5}, "output": {"variance": 4.4, "average_burned": 3.0}}, {"input": {"density": 0.1909634769713403, "forest_size": 12, "num_simulations": 7}, "output": {"variance": 1.2653061224489797, "average_burned": 1.8571428571428572}}, {"input": {"density": 0.11187122418519597, "forest_size": 20, "num_simulations": 11}, "output": {"variance": 0.9256198347107436, "average_burned": 1.7272727272727273}}, {"input": {"density": 0.1992424426011911, "forest_size": 16, "num_simulations": 13}, "output": {"variance": 1.36094674556213, "average_burned": 1.8461538461538463}}], "error_log": []}
{"context": "Given a set of data points with their abscissas (x-values) and ordinates (y-values), what are the best fit slope and y-intercept of a straight line that fits these data points, along with their respective errors and the residual variance?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (list of float): List of abscissas (x-values) of the data points.\n  `y` (list of float): List of ordinates (y-values) of the data points.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `slope` (float): The best fit slope of the line.\n    - `intercept` (float): The best fit y-intercept of the line.\n    - `slope_error` (float): The standard error for the slope.\n    - `intercept_error` (float): The standard error for the intercept.\n    - `residual_variance` (float): The residual variance of the fit.", "reference_code": "# import necessary packages\nimport numpy as np\nimport math\n\n# main function\ndef main_solution(x, y):\n    # Convert input lists to numpy arrays\n    x = np.array(x)\n    y = np.array(y)\n    \n    n = len(x)\n    \n    sumx2 = np.sum(x**2)\n    xsum = np.sum(x)\n    yxsum = np.sum(y * x)\n    ysum = np.sum(y)\n    \n    ata = np.array([[sumx2, xsum], [xsum, n]])\n    aty = np.array([yxsum, ysum])\n    \n    det = np.linalg.det(ata)\n    atainv = np.linalg.inv(ata)\n    \n    slope = np.dot(atainv[0], aty)\n    cept = np.dot(atainv[1], aty)\n    \n    s2 = np.sum((y - cept - slope * x)**2) / (n - 2)\n    \n    errs = math.sqrt(n * s2 / det)\n    errc = math.sqrt(s2 * sumx2 / det)\n    \n    # Return JSON serializable output\n    return {\n        \"slope\": slope,\n        \"intercept\": cept,\n        \"slope_error\": errs,\n        \"intercept_error\": errc,\n        \"residual_variance\": s2\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    n = random.randint(5, 20)  # Generate between 5 and 20 points\n    slope = random.uniform(-10, 10)\n    intercept = random.uniform(-5, 5)\n    noise_scale = random.uniform(0.1, 2.0)\n    \n    x = np.linspace(0, 10, n)\n    y = intercept + slope * x + np.random.normal(0, noise_scale, n)\n    \n    return {\n        \"x\": x.tolist(),\n        \"y\": y.tolist()\n    }", "io_pairs": [{"input": {"x": [0.0, 2.0, 4.0, 6.0, 8.0, 10.0], "y": [-4.441539597272053, 2.5648325286294655, 10.592624175874736, 18.002413928334278, 26.919338860143785, 33.987979626263446]}, "output": {"slope": 3.894584355209714, "intercept": -4.868646855719625, "slope_error": 0.05902817531289139, "intercept_error": 0.3574333517756089, "residual_variance": 0.24390278365386106}}, {"input": {"x": [0.0, 2.5, 5.0, 7.5, 10.0], "y": [2.8941721800680194, 21.14083583081811, 40.42744591454828, 59.68362016123863, 78.56930556674642]}, "output": {"slope": 7.595722044151092, "intercept": 2.564465709928413, "slope_error": 0.041165217862529066, "intercept_error": 0.25208444728424956, "residual_variance": 0.10591094760434257}}, {"input": {"x": [0.0, 2.5, 5.0, 7.5, 10.0], "y": [4.46732360075134, -18.808512974101685, -39.717641337859654, -64.35776332902444, -85.39127138695873]}, "output": {"slope": -9.01065761321372, "intercept": 4.291714980629962, "slope_error": 0.12161113504783531, "intercept_error": 0.7447130697697312, "residual_variance": 0.9243292604764269}}, {"input": {"x": [0.0, 2.0, 4.0, 6.0, 8.0, 10.0], "y": [3.377299510426709, -2.834436721256941, -4.435760632146807, -9.04147601921192, -11.894988359292304, -16.151058666494574]}, "output": {"slope": -1.8489880169396793, "intercept": 2.4148699367024236, "slope_error": 0.11951944228485657, "intercept_error": 0.7237261635105614, "residual_variance": 0.999942795885822}}, {"input": {"x": [0.0, 2.0, 4.0, 6.0, 8.0, 10.0], "y": [1.2346600061704218, 12.16137816126364, 21.329544010807446, 31.19431632619848, 42.00964342526162, 51.53657529197176]}, "output": {"slope": 5.013130636234168, "intercept": 1.5120330224414005, "slope_error": 0.054873831915765565, "intercept_error": 0.3322775532609077, "residual_variance": 0.21077962003837858}}, {"input": {"x": [0.0, 2.0, 4.0, 6.0, 8.0, 10.0], "y": [4.371763087261195, 3.2023427369106163, 9.641225541330403, 11.995530762649585, 14.569455406900873, 19.277811341537436]}, "output": {"slope": 1.5855126357524458, "intercept": 2.5821249673361315, "slope_error": 0.2020037910469277, "intercept_error": 1.2231936989845327, "residual_variance": 2.8563872118131606}}, {"input": {"x": [0.0, 2.5, 5.0, 7.5, 10.0], "y": [4.661019706694897, 0.7593377276995402, -3.0899907122854775, -7.147120740562929, -10.99536688070074]}, "output": {"slope": -1.56876926572215, "intercept": 4.681422148779808, "slope_error": 0.0072008448631277954, "intercept_error": 0.04409598907901118, "residual_variance": 0.0032407604214271207}}, {"input": {"x": [0.0, 2.0, 4.0, 6.0, 8.0, 10.0], "y": [3.179966810492551, -8.402627123982061, -18.91763186883893, -29.692627887137125, -41.112872166997704, -53.03274138847105]}, "output": {"slope": -5.570989602030902, "intercept": 3.1918590726654514, "slope_error": 0.05550736821238564, "intercept_error": 0.33611380604649843, "residual_variance": 0.21567475481057535}}, {"input": {"x": [0.0, 1.4285714285714286, 2.857142857142857, 4.285714285714286, 5.714285714285714, 7.142857142857143, 8.571428571428571, 10.0], "y": [-1.391786947068162, -8.479519387580488, -16.339134462410247, -17.158463984040175, -23.119801133290633, -31.17489489676528, -39.9348473970155, -40.671386013423195]}, "output": {"slope": -4.022520433033133, "intercept": -2.17112711253354, "slope_error": 0.24607353848819707, "intercept_error": 1.4705706660062057, "residual_variance": 5.190187400923041}}, {"input": {"x": [0.0, 1.25, 2.5, 3.75, 5.0, 6.25, 7.5, 8.75, 10.0], "y": [-1.23988718044032, 4.031450423531899, 9.183851459841271, 14.054238503461539, 20.441674419164165, 27.394101801381627, 29.399172983700996, 34.087693350008294, 42.425564765900006]}, "output": {"slope": 4.2480139054723995, "intercept": -1.2647516910787147, "slope_error": 0.13103138371242867, "intercept_error": 0.7797927072293706, "residual_variance": 1.60961470477441}}], "error_log": []}
{"context": "Given a polynomial defined by its coefficients, what are the values of the polynomial at specified x values?\n\nThe input and output requirements are as follows:\n\nInput:\n  `coefficients` (list of int): The coefficients of the polynomial in descending order of powers.\n  `x_values` (list of float): The x values at which the polynomial is to be evaluated.\n\nOutput:\n  `return` (dict): A dictionary with keys as the x values and values as the corresponding polynomial values.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\nclass Polynomial:\n    \"\"\" Class for work with polynomials.\n        Coefficients are saved as a list attribute (coeffs). \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\" Saves coefficients of polynomial set as arguments to a self.coeffs list \"\"\"\n        self.coeffs = []\n        if args:\n            for elem in args:\n                if isinstance(elem, list):\n                    self.coeffs = elem\n                    break\n                else:\n                    self.coeffs.append(elem)\n        if kwargs:\n            iterator = 0\n            for key, val in sorted(kwargs.items()):\n                key = int(key[1:])\n                while key != iterator:\n                    self.coeffs.append(0)\n                    iterator = iterator + 1\n                self.coeffs.append(val)\n                iterator = iterator + 1\n        for elem in self.coeffs:\n            if (self.coeffs[-1] == 0) and (len(self.coeffs) != 1):\n                self.coeffs.pop()\n            else:\n                break\n\n    def __str__(self):\n        \"\"\" Conversion polynomial to a string \"\"\"\n        if all(i == 0 for i in self.coeffs):\n            return \"0\"\n        string = \"\"\n        cnt = 0\n        for elem in self.coeffs:\n            if elem == 0:\n                cnt = cnt + 1\n                continue\n            elif (elem == 1 or elem == -1) and cnt != 0:\n                coeff = \"\"\n            else:\n                coeff = str(abs(elem))\n            if cnt == len(self.coeffs) - 1:\n                if elem < 0:\n                    sign = \"- \"\n                else:\n                    sign = \"\"\n            elif elem < 0:\n                sign = \" - \"\n            else:\n                sign = \" + \"\n            if cnt == 0:\n                power = \"\"\n            elif cnt == 1:\n                power = \"x\"\n            else:\n                power = \"x^\" + str(cnt)\n            string = sign + coeff + power + string\n            cnt = cnt + 1\n        return string\n\n    def __eq__(self, other):\n        \"\"\" Compare two polynomials \"\"\"\n        return self.coeffs == other.coeffs\n\n    def __add__(self, other):\n        \"\"\" Returns sum of polynomials \"\"\"\n        A = self.coeffs\n        B = other.coeffs\n        result = list()\n        if len(A) > len(B):\n            for i, b in enumerate(B):\n                result.append(A[i] + b)\n            i += 1\n            while i < len(A):\n                result.append(A[i])\n                i += 1\n        else:\n            for i, a in enumerate(A):\n                result.append(B[i] + a)\n            i += 1\n            while i < len(B):\n                result.append(B[i])\n                i += 1\n        return str(Polynomial(result))\n\n    def __pow__(self, exp):\n        \"\"\" Returns polynomial power to the exp \"\"\"\n        power = int(exp)\n        result = []\n        for k in range(0, power + 1):\n            nCr = math.factorial(power) // math.factorial(k) // math.factorial(power - k)\n            result.append(nCr * ((self.coeffs[1]) ** (power - k)) * (self.coeffs[0] ** k))\n        return Polynomial(result[::-1])\n\n    def derivative(self):\n        \"\"\" Returns derived polynomial \"\"\"\n        derivated = []\n        idx = 1;\n        for elem in self.coeffs[1:]:\n            derivated.append(elem * idx)\n            idx += 1\n        return Polynomial(derivated)\n\n    def at_value(self, *x):\n        \"\"\" Returns value of polynomial at x,\n            when there are 2 values, it returns their difference \"\"\"\n        x = list(x)\n        if len(x) == 1:\n            idx = 0\n            result = 0\n            for elem in self.coeffs:\n                result += (x[0] ** idx) * elem\n                idx += 1\n            return result\n        elif len(x) == 2:\n            if x[0] > x[1]:\n                return self.at_value(x[0]) - self.at_value(x[1])\n            else:\n                return self.at_value(x[1]) - self.at_value(x[0])\n\n# main function\ndef main_solution(coefficients, x_values):\n    \"\"\"\n    Computes the value of a polynomial at given x values.\n\n    Parameters:\n    coefficients (list of int): The coefficients of the polynomial in descending order of powers.\n    x_values (list of float): The x values at which the polynomial is to be evaluated.\n\n    Returns:\n    dict: A dictionary with keys as the x values and values as the corresponding polynomial values.\n    \"\"\"\n    polynomial = Polynomial(coefficients)\n    result = {}\n    for x in x_values:\n        result[x] = polynomial.at_value(x)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate random coefficients (between -10 and 10, with length between 1 and 5)\n    num_coeffs = random.randint(1, 5)\n    coefficients = [random.randint(-10, 10) for _ in range(num_coeffs)]\n    \n    # Generate random x_values (between -10.0 and 10.0, with length between 1 and 5)\n    num_x_values = random.randint(1, 5)\n    x_values = [round(random.uniform(-10.0, 10.0), 2) for _ in range(num_x_values)]\n    \n    return {\n        'coefficients': coefficients,\n        'x_values': x_values\n    }", "io_pairs": [{"input": {"coefficients": [9, 10, -3, 2, -4], "x_values": [-7.23, -8.52, 4.37]}, "output": {"-7.23": -11905.809131640004, "-8.52": -22608.376304639998, "4.37": -1296.4501524400002}}, {"input": {"coefficients": [2], "x_values": [3.28, 1.8]}, "output": {"3.28": 2.0, "1.8": 2.0}}, {"input": {"coefficients": [8], "x_values": [-0.4, 3.51, 7.39]}, "output": {"-0.4": 8.0, "3.51": 8.0, "7.39": 8.0}}, {"input": {"coefficients": [5], "x_values": [6.77, -8.91, -4.75, -5.11, 9.98]}, "output": {"6.77": 5.0, "-8.91": 5.0, "-4.75": 5.0, "-5.11": 5.0, "9.98": 5.0}}, {"input": {"coefficients": [-3, -8, -10, -1], "x_values": [9.2, -4.92, -0.98, 7.23]}, "output": {"9.2": -1701.6879999999996, "-4.92": -86.60851200000002, "-0.98": -3.8228079999999993, "7.23": -961.5020670000001}}, {"input": {"coefficients": [0], "x_values": [2.55, 2.22, 4.35, -7.61, -3.15]}, "output": {"2.55": 0.0, "2.22": 0.0, "4.35": 0.0, "-7.61": 0.0, "-3.15": 0.0}}, {"input": {"coefficients": [3, -4, -10], "x_values": [7.08, 3.15, -8.27, 2.94, -6.72]}, "output": {"7.08": -526.5840000000001, "3.15": -108.82499999999999, "-8.27": -647.8489999999999, "2.94": -95.196, "-6.72": -421.70399999999995}}, {"input": {"coefficients": [-2, 1], "x_values": [6.49, -0.34, -1.78]}, "output": {"6.49": 4.49, "-0.34": -2.34, "-1.78": -3.7800000000000002}}, {"input": {"coefficients": [9, 4, -9, -7, 1], "x_values": [8.05, 4.28, 7.65, -2.46, 0.21]}, "output": {"8.05": 5.720631250001134, "4.28": -352.00108544, "7.65": -196.09936874999994, "-2.46": 85.52601456, "0.21": 9.38021781}}, {"input": {"coefficients": [8], "x_values": [4.57, -2.11, 2.2, -1.9, 8.56]}, "output": {"4.57": 8.0, "-2.11": 8.0, "2.2": 8.0, "-1.9": 8.0, "8.56": 8.0}}], "error_log": []}
{"context": "A gambler is playing a game where he bets on the outcome of a coin flip. The gambler starts with a certain amount of money and can bet any amount up to the lesser of his current money or the amount needed to reach 100 if the coin lands heads. The coin has a fixed probability of landing heads. Given the gambler's initial amount of money and the probability of the coin landing heads, what is the optimal betting amount and the expected value of the gambler's state after following the optimal policy?\n\nThe input and output requirements are as follows:\n\nInput:\n- `initial_state` (int): The initial amount of money the gambler has, ranging from 1 to 99.\n- `p_h` (float): The probability of the coin landing heads, ranging from 0.0 to 1.0.\n\nOutput:\n- `return` (dict): A dictionary containing:\n  - `optimal_action` (int): The optimal betting amount for the gambler given the initial state.\n  - `expected_value` (float): The expected value of the gambler's state after following the optimal policy.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# States represent how much money our gambler has, with range [0, 100] inclusive\nNUM_STATES, NUM_ACTIONS = 101, 50\n\n# Reward of +1 at 100 and 0 otherwise\ndef reward(state):\n    return int(state == 100)\n\n# Gambler can bet at most up to his money, or the amount of money that gets him to 100 if heads\ndef get_actions(state):\n    return list(range(0, min(state, 100 - state)))\n\ndef get_states():\n    return list(range(1, 100))\n\n# Probability of Heads\np_h = 0.4\n\n# Calculate probability and new state, reward transitions\n# There are 50 actions to take (actions in [1,50] inclusive)\n# Returns list of (next_state, reward, probability)\ndef transitions(state, action):\n    return [\n        (state + action + 1, reward(state + action + 1), p_h),\n        (state - action - 1, reward(state - action - 1), 1 - p_h),\n    ]\n\n# Set up training parameters\nDELTA_LIM = 0.0000000001\nDISCOUNT = 1\n\n## Policy Evaluation\n\ndef policy_evaluation(V_s, policy):\n    delta = DELTA_LIM + 1\n    \n    while delta > DELTA_LIM:\n        delta = 0\n        for state in get_states():\n            old_state = V_s[state]\n            \n            expected_reward = 0\n            for action in get_actions(state):\n                action_reward = 0\n                for next_state, reward, prob in transitions(state, action):\n                    action_reward += prob * (reward + DISCOUNT * V_s[next_state])\n                expected_reward += action_reward * policy[state, action]\n\n            V_s[state] = expected_reward\n            delta = max(delta, abs(old_state - V_s[state]))\n        \n    return V_s\n\n## Policy Improvement\n\ndef policy_improvement(V_s, policy):\n    stable = True\n\n    for state in get_states():\n        old_action = np.argmax(policy[state])\n        rewards = np.zeros(NUM_ACTIONS)\n\n        for action in get_actions(state):\n            for next_state, reward, prob in transitions(state, action):\n                rewards[action] += prob * (reward + DISCOUNT * V_s[next_state])\n\n        policy[state] = np.eye(NUM_ACTIONS)[np.argmax(rewards)]  \n        stable &= (old_action == np.argmax(policy[state]))\n    \n    return policy, stable\n\n## Policy Iteration\n\ndef policy_iteration():\n    V_s = np.random.random(NUM_STATES)\n    V_s[-1] = 0\n\n    policy = np.zeros((NUM_STATES, NUM_ACTIONS))\n    policy[:, 0] = 1\n\n    stable = False\n    while not stable:\n        V_s = policy_evaluation(V_s, policy)\n        policy, stable = policy_improvement(V_s, policy)\n    return V_s, policy\n\n## Value Iteration\n\ndef value_iteration(V_s):\n    delta = DELTA_LIM + 1\n    policy = np.zeros((NUM_STATES, NUM_ACTIONS))\n    policy[:, 0] = 1\n    \n    while delta > DELTA_LIM:\n        delta = 0\n        for state in get_states():\n            v = V_s[state]\n            rewards = np.zeros(NUM_ACTIONS)\n\n            for action in get_actions(state):\n                for next_state, reward, prob in transitions(state, action):\n                    rewards[action] += prob * (reward + DISCOUNT * V_s[next_state])\n            \n            V_s[state] = rewards.max()\n            policy[state] = np.eye(NUM_ACTIONS)[np.argmax(rewards)]\n            delta = max(delta, abs(v - V_s[state]))\n        \n    return policy, V_s\n\n# main function\ndef main_solution(initial_state, p_h):\n    # Convert JSON serializable input to the required format\n    V_s = np.random.random(NUM_STATES)\n    V_s[-1] = 0\n\n    # Run the value iteration algorithm\n    policy, V_s = value_iteration(V_s)\n\n    # Convert the output to JSON serializable format\n    optimal_action = np.argmax(policy[initial_state])\n    expected_value = V_s[initial_state]\n\n    return {\"optimal_action\": int(optimal_action), \"expected_value\": float(expected_value)}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    initial_state = random.randint(1, 99)\n    p_h = round(random.uniform(0.1, 0.9), 2)\n    return {\"initial_state\": initial_state, \"p_h\": p_h}", "io_pairs": [{"input": {"initial_state": 97, "p_h": 0.16}, "output": {"optimal_action": 2, "expected_value": 0.9993791318413601}}, {"input": {"initial_state": 40, "p_h": 0.5}, "output": {"optimal_action": 9, "expected_value": 0.5155214077349533}}, {"input": {"initial_state": 42, "p_h": 0.73}, "output": {"optimal_action": 7, "expected_value": 0.6998894174551361}}, {"input": {"initial_state": 91, "p_h": 0.51}, "output": {"optimal_action": 8, "expected_value": 0.9643165256622949}}, {"input": {"initial_state": 45, "p_h": 0.78}, "output": {"optimal_action": 4, "expected_value": 0.7118685541828284}}, {"input": {"initial_state": 90, "p_h": 0.44}, "output": {"optimal_action": 9, "expected_value": 0.9336945678501269}}, {"input": {"initial_state": 93, "p_h": 0.55}, "output": {"optimal_action": 6, "expected_value": 0.9128586431236383}}, {"input": {"initial_state": 39, "p_h": 0.66}, "output": {"optimal_action": 10, "expected_value": 0.44588704530142265}}, {"input": {"initial_state": 81, "p_h": 0.55}, "output": {"optimal_action": 18, "expected_value": 0.7887497480343052}}, {"input": {"initial_state": 21, "p_h": 0.8}, "output": {"optimal_action": 20, "expected_value": 0.7009625552101663}}], "error_log": []}
{"context": "Given a sphere in a 3D space and a ray originating from a specific point and traveling in a certain direction, what is the distance from the ray's origin to the point where it intersects the sphere, and what is the normal vector at that intersection point?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sphere_pos` (list of float): The position of the sphere in 3D space, represented as a list of three floats [x, y, z].\n  `sphere_radius` (float): The radius of the sphere.\n  `ray_orig` (list of float): The origin of the ray in 3D space, represented as a list of three floats [x, y, z].\n  `ray_dir` (list of float): The direction of the ray in 3D space, represented as a list of three floats [x, y, z].\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `intersection_distance` (float): The distance from the ray origin to the intersection point with the sphere. If no intersection occurs, this value is 0.0.\n    - `normal_at_intersection` (list of float or None): The normal vector at the intersection point, represented as a list of three floats [x, y, z]. If no intersection occurs, this value is None.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\nclass Ray:\n    def __init__(self, orig, dir):\n        self.orig = np.array(orig)\n        self.dir = np.array(dir)\n\nclass Sphere:\n    def __init__(self, pos, radius=1.0):\n        self.pos = np.array(pos)\n        self.radius = radius\n\n    def intersect(self, ray):\n        omc = ray.orig - self.pos\n        dir_omc = np.dot(ray.dir, omc)\n        omc_omc = np.dot(omc, omc)\n        dis = dir_omc**2 - omc_omc + self.radius**2\n        if dis < 0: return 0.0\n        t = -dir_omc - np.sqrt(dis)\n        if t > 0.0: return t\n        t = -dir_omc + np.sqrt(dis)\n        return t if t > 0.0 else 0.0\n\n    def normal(self, point):\n        return normalize(point - self.pos)\n\ndef normalize(vec):\n    return vec / np.linalg.norm(vec, ord=2)\n\n# main function\ndef main_solution(sphere_pos, sphere_radius, ray_orig, ray_dir):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    sphere = Sphere(sphere_pos, sphere_radius)\n    ray = Ray(ray_orig, ray_dir)\n    \n    # Calculate the intersection distance\n    intersection_distance = sphere.intersect(ray)\n    \n    # Calculate the normal at the intersection point\n    if intersection_distance > 0.0:\n        intersection_point = ray.orig + intersection_distance * ray.dir\n        normal_at_intersection = sphere.normal(intersection_point)\n    else:\n        normal_at_intersection = None\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\n        \"intersection_distance\": intersection_distance,\n        \"normal_at_intersection\": normal_at_intersection.tolist() if normal_at_intersection is not None else None\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate random sphere position and radius\n    sphere_pos = [random.uniform(-5, 5) for _ in range(3)]\n    sphere_radius = random.uniform(0.5, 3.0)\n    \n    # Generate random ray origin and direction\n    ray_orig = [random.uniform(-5, 5) for _ in range(3)]\n    ray_dir = normalize(np.array([random.uniform(-1, 1) for _ in range(3)]))\n    \n    return {\n        \"sphere_pos\": sphere_pos,\n        \"sphere_radius\": sphere_radius,\n        \"ray_orig\": ray_orig,\n        \"ray_dir\": ray_dir.tolist()\n    }\n\ndef normalize(vec):\n    return vec / np.linalg.norm(vec, ord=2)", "io_pairs": [{"input": {"sphere_pos": [-2.8715927875014247, 3.2557144661766717, 0.29006045763312205], "sphere_radius": 1.6598070614569504, "ray_orig": [-1.5618905957653317, -3.531055036264866, 2.781703643138802], "ray_dir": [-0.12201978933083676, -0.8810652305269805, 0.45698493472771806]}, "output": {"intersection_distance": 0.0, "normal_at_intersection": null}}, {"input": {"sphere_pos": [-1.9402310375166767, 4.324912033665102, 1.2630577216612728], "sphere_radius": 0.56817166067832, "ray_orig": [1.0789979695199197, -1.5077716880484404, -2.8564372733542376], "ray_dir": [-0.7549886446554303, -0.6241100859389196, 0.20119330771839988]}, "output": {"intersection_distance": 0.0, "normal_at_intersection": null}}, {"input": {"sphere_pos": [-4.871892674102028, 2.5732009896224657, 4.6504780851918675], "sphere_radius": 2.4967064261414302, "ray_orig": [1.5114435386306209, -0.7233025098113206, 1.1198127331843413], "ray_dir": [0.22828135375576786, -0.8235502667364053, 0.5192808312328017]}, "output": {"intersection_distance": 0.0, "normal_at_intersection": null}}, {"input": {"sphere_pos": [-0.5351578135654549, 3.5160352397896055, -2.9314714740049475], "sphere_radius": 0.5975498541942954, "ray_orig": [3.6839146394267424, -4.888733343447262, -4.817176193689444], "ray_dir": [0.8152485312432679, -0.4735855338848571, -0.33329652623555733]}, "output": {"intersection_distance": 0.0, "normal_at_intersection": null}}, {"input": {"sphere_pos": [-2.9676644580369804, -2.4823895361167536, -4.191456726945212], "sphere_radius": 1.9482698908210563, "ray_orig": [1.8783402073900621, 3.387559920915585, -3.7909255534511943], "ray_dir": [0.7568773839265422, 0.03857205862281585, -0.6524176744954964]}, "output": {"intersection_distance": 0.0, "normal_at_intersection": null}}, {"input": {"sphere_pos": [4.40302160603094, 1.8987035664433103, -3.2043739078258113], "sphere_radius": 1.8257008274030715, "ray_orig": [0.6895089198787456, 0.7465699653474802, -4.682877647904898], "ray_dir": [-0.763681377442626, -0.5042927098578237, 0.4030876040410897]}, "output": {"intersection_distance": 0.0, "normal_at_intersection": null}}, {"input": {"sphere_pos": [-0.12353304253406083, -1.9311587255056128, 3.8941721987954185], "sphere_radius": 1.9256696621580887, "ray_orig": [-3.635002438653175, -2.571080759833344, -2.6018124664438225], "ray_dir": [0.3297744906226625, -0.8693051066847529, 0.3681812282373638]}, "output": {"intersection_distance": 0.0, "normal_at_intersection": null}}, {"input": {"sphere_pos": [-2.1315875128179718, 2.0413541084999673, 3.636008856874577], "sphere_radius": 2.7528009912553504, "ray_orig": [-2.8060052037226413, 0.3702568942033082, 4.773282348543864], "ray_dir": [-0.6732437884935247, -0.6542292565023994, 0.34456767287603146]}, "output": {"intersection_distance": 0.6680244461609726, "normal_at_intersection": [-0.4083698761426718, -0.7658157482981043, 0.4967497195951233]}}, {"input": {"sphere_pos": [2.768750836387232, 2.6882767036206925, 2.620299835115336], "sphere_radius": 0.8372635563198961, "ray_orig": [2.7378715578514434, 0.6920010981610645, 3.0549096037995653], "ray_dir": [0.8903389763936879, -0.41386992348005186, 0.1897582502892986]}, "output": {"intersection_distance": 0.0, "normal_at_intersection": null}}, {"input": {"sphere_pos": [2.244675685142166, -3.4932907269715, 1.7807343019783755], "sphere_radius": 2.1248023447019153, "ray_orig": [4.564842721536042, -0.5309558389135951, -3.4741026099571695], "ray_dir": [-0.6109661621856181, 0.7786929991744959, 0.1426799274628556]}, "output": {"intersection_distance": 0.0, "normal_at_intersection": null}}], "error_log": []}
{"context": "Given a number, determine if it is a happy number. A happy number is defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. What is the result of checking if the given number is a happy number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number` (int): The number to be checked if it is a happy number.\n\nOutput:\n  `return` (bool): `True` if the number is a happy number, `False` otherwise.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef happyNumber(y, visitedNumbers):\n    if y == 1:  # if 1 then it terminates and is a happy number\n        return True\n    y = str(y)  # This splits the number\n    total = 0\n    for i in range(len(y)):\n        total += int(y[i])**2  # adds the square\n    if total in visitedNumbers:  # if seen before then it will just loop\n        return False\n    visitedNumbers.append(total)\n    return happyNumber(total, visitedNumbers)\n\n# main function\ndef main_solution(number):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    visitedNumbers = []\n    is_happy = happyNumber(number, visitedNumbers)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return is_happy", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random number between 1 and 1000 with some bias towards smaller numbers\n    number = random.choices(\n        range(1, 1001),\n        weights=[1/(i+1) for i in range(1000)],\n        k=1\n    )[0]\n    return {'number': number}", "io_pairs": [{"input": {"number": 39}, "output": false}, {"input": {"number": 1}, "output": true}, {"input": {"number": 48}, "output": false}, {"input": {"number": 2}, "output": false}, {"input": {"number": 842}, "output": false}, {"input": {"number": 4}, "output": false}, {"input": {"number": 22}, "output": false}, {"input": {"number": 10}, "output": true}, {"input": {"number": 3}, "output": false}, {"input": {"number": 45}, "output": false}], "error_log": []}
{"context": "In a game of Battleship, a player has placed their ships on a 10x10 grid. You are given a list of coordinates representing guesses made by the opponent. For each guess, determine whether it results in a hit, miss, or sinking of a ship. What is the status of each guess and the length of the ship if it is sunk?\n\nThe input and output requirements are as follows:\n\nInput:\n  `guesses` (List[Tuple[int, int]]): A list of tuples where each tuple represents a guess in the format (row, col). Both row and col are integers between 0 and 9.\n\nOutput:\n  `return` (List[Tuple[int, Optional[int]]]): A list of tuples where each tuple represents the result of a guess. The first element of the tuple is the status (0 for miss, 1 for hit, 2 for sunk), and the second element is the length of the ship if the ship is sunk (None otherwise).", "reference_code": "# import necessary packages\nimport random\nfrom typing import List, Tuple, Optional\n\n# all class and function definitions in the code file, if any\nclass Ship:\n    def __init__(self, length: int, row: int, col: int, orient: int):\n        self.length = length\n        self.row = row\n        self.col = col\n        self.orient = orient\n        self.hits = 0\n        self.sunk = False\n\n    def hit(self):\n        self.hits += 1\n        if self.hits == self.length:\n            self.sunk = True\n\nclass Human:\n    def __init__(self):\n        self._my_ships: List[Ship] = []\n        self._my_misses: List[Tuple[int, int]] = []\n        self._my_hits: List[Tuple[int, int]] = []\n        self._sunk_ships: List[Ship] = []\n        self._their_misses: List[Tuple[int, int]] = []\n        self._their_hits: List[Tuple[int, int]] = []\n        self._board_matrix: List[List[Optional[Ship]]] = [[None] * 10 for _ in range(10)]\n        self.complete: bool = False\n\n    def initialize(self):\n        for ship_length in [5, 4, 3, 3, 2]:\n            validPlac = False\n            while not validPlac:\n                orient = random.randint(0, 1)\n                if orient == 1:\n                    row = random.randint(0, 10 - ship_length)\n                    col = random.randint(0, 9)\n                else:\n                    row = random.randint(0, 9)\n                    col = random.randint(0, 10 - ship_length)\n\n                my_ship = Ship(ship_length, row, col, orient)\n\n                conflict = ['No']\n                if orient == 1:\n                    for n in range(ship_length):\n                        if self._board_matrix[row + n][col] is None:\n                            conflict.append('No')\n                        else:\n                            conflict.append('Yes')\n                else:\n                    for n in range(ship_length):\n                        if self._board_matrix[row][col + n] is None:\n                            conflict.append('No')\n                        else:\n                            conflict.append('Yes')\n\n                if 'Yes' not in conflict:\n                    for n in range(ship_length):\n                        if orient == 1:\n                            self._board_matrix[row + n][col] = my_ship\n                        else:\n                            self._board_matrix[row][col + n] = my_ship\n\n                    self._my_ships.append(my_ship)\n                    validPlac = True\n\n    def guess(self, row: int, col: int) -> Tuple[int, Optional[Ship]]:\n        my_ship: Ship = self._board_matrix[row][col]\n\n        if my_ship is not None and (row, col) not in self._their_hits:\n            self._their_hits.append((row, col))\n            my_ship.hit()\n            if my_ship.sunk:\n                return (2, my_ship)\n            else:\n                return (1, None)\n        else:\n            self._their_misses.append((row, col))\n            return (0, None)\n\n# main function\ndef main_solution(guesses: List[Tuple[int, int]]) -> List[Tuple[int, Optional[int]]]:\n    human = Human()\n    human.initialize()\n\n    results = []\n    for guess in guesses:\n        result = human.guess(*guess)\n        results.append((result[0], result[1].length if result[1] else None))\n\n    return results", "input_generator": "import random\nfrom typing import List, Tuple\n\ndef input_generator() -> dict:\n    num_guesses = random.randint(5, 20)\n    guesses = []\n    for _ in range(num_guesses):\n        row = random.randint(0, 9)\n        col = random.randint(0, 9)\n        guesses.append((row, col))\n    return {'guesses': guesses}", "io_pairs": [{"input": {"guesses": [[0, 5], [4, 6], [0, 5], [3, 3], [8, 2], [6, 1]]}, "output": [[0, null], [0, null], [0, null], [0, null], [1, null], [0, null]]}, {"input": {"guesses": [[3, 5], [8, 5], [0, 5], [7, 7], [1, 6]]}, "output": [[0, null], [0, null], [1, null], [0, null], [1, null]]}, {"input": {"guesses": [[9, 2], [3, 7], [2, 0], [7, 0], [9, 9]]}, "output": [[0, null], [0, null], [0, null], [0, null], [0, null]]}, {"input": {"guesses": [[0, 0], [4, 0], [0, 8], [4, 8], [7, 7], [9, 9], [7, 7]]}, "output": [[0, null], [0, null], [0, null], [0, null], [0, null], [0, null], [0, null]]}, {"input": {"guesses": [[8, 2], [5, 0], [4, 8], [7, 4], [8, 3], [5, 3], [0, 7]]}, "output": [[0, null], [0, null], [0, null], [0, null], [0, null], [0, null], [1, null]]}, {"input": {"guesses": [[7, 4], [1, 9], [2, 6], [7, 3], [2, 7]]}, "output": [[0, null], [0, null], [1, null], [0, null], [0, null]]}, {"input": {"guesses": [[0, 3], [2, 4], [2, 7], [7, 7], [5, 2], [3, 6]]}, "output": [[0, null], [0, null], [0, null], [0, null], [0, null], [0, null]]}, {"input": {"guesses": [[6, 8], [2, 2], [7, 6], [1, 0], [1, 7]]}, "output": [[0, null], [0, null], [1, null], [0, null], [0, null]]}, {"input": {"guesses": [[0, 3], [1, 3], [3, 2], [9, 3], [5, 9], [5, 0], [3, 1], [1, 9]]}, "output": [[1, null], [0, null], [0, null], [0, null], [0, null], [1, null], [0, null], [0, null]]}, {"input": {"guesses": [[5, 9], [6, 0], [6, 9], [9, 2], [2, 3]]}, "output": [[0, null], [0, null], [1, null], [0, null], [1, null]]}], "error_log": []}
{"context": "Given a message, how can we ensure that the message remains confidential during transmission by using RSA encryption and decryption, and what will be the decrypted message after the process?\n\nThe input and output requirements are as follows:\n\nInput:\n  `message` (str): The message to be encrypted and decrypted using RSA. The message should be a string that can be encoded using UTF-8.\n\nOutput:\n  `return` (str): The decrypted message, which should be the same as the input message if the RSA encryption and decryption process is successful.", "reference_code": "# import necessary packages\nfrom Crypto.Util import number\n\n# main function\ndef main_solution(message):\n    # Generate RSA keys\n    n_length = 1024\n    p1 = number.getPrime(n_length)\n    p2 = number.getPrime(n_length)\n    n = p1 * p2\n    e = 65537\n    phi = (p1 - 1) * (p2 - 1)\n    d = pow(e, -1, phi)\n    \n    # Convert message to integer\n    m_int = int.from_bytes(message.encode(), byteorder='big')\n    \n    # Ensure message is less than n\n    if m_int >= n:\n        raise ValueError(\"Message too long for the generated RSA key\")\n    \n    # Encrypt the message\n    C = pow(m_int, e, n)\n    \n    # Decrypt the message\n    D = pow(C, d, n)\n    m_decrypted = D.to_bytes((D.bit_length() + 7) // 8, byteorder='big').decode()\n    \n    return m_decrypted", "input_generator": "import random\nimport string\n\ndef input_generator():\n    message_length = random.randint(1, 50)\n    message = ''.join(random.choice(string.ascii_letters + string.digits + ' ') for _ in range(message_length))\n    return {'message': message}", "io_pairs": [{"input": {"message": "yOcayK1Pif XTL6hP7T5NN1PVugIvKY1DHfLF5JN9aX1"}, "output": "yOcayK1Pif XTL6hP7T5NN1PVugIvKY1DHfLF5JN9aX1"}, {"input": {"message": "wpCVaMHcLGfsPEbDyF1gd2mrhEdyhyrGkTCmipyqBy"}, "output": "wpCVaMHcLGfsPEbDyF1gd2mrhEdyhyrGkTCmipyqBy"}, {"input": {"message": "00GK1xkjL"}, "output": "00GK1xkjL"}, {"input": {"message": "epqr6TZIG9irXJndUbGnHNq9Xn3 bgyH"}, "output": "epqr6TZIG9irXJndUbGnHNq9Xn3 bgyH"}, {"input": {"message": " lqFxLlM7tXmcP2vQHcRcMhKBIC7c7vLxCM3E3 8"}, "output": " lqFxLlM7tXmcP2vQHcRcMhKBIC7c7vLxCM3E3 8"}, {"input": {"message": "KyCcFgHVefOUT"}, "output": "KyCcFgHVefOUT"}, {"input": {"message": "SuxUSjn5Pd0EUTCLNt3Vt6"}, "output": "SuxUSjn5Pd0EUTCLNt3Vt6"}, {"input": {"message": "eSxzowGYj8H5hfvzGLv"}, "output": "eSxzowGYj8H5hfvzGLv"}, {"input": {"message": "ZIEx QMCU6VLqgaFbPSCZQWjHJ9DgysIw3O0W2WL"}, "output": "ZIEx QMCU6VLqgaFbPSCZQWjHJ9DgysIw3O0W2WL"}, {"input": {"message": "BQWyn"}, "output": "BQWyn"}], "error_log": []}
{"context": "Given a sequence of integers, how can we transform this sequence into a balanced binary tree where the number of entries in its left branch differs from the number of entries in its right branch by at most 1, and both branches are also balanced trees?\n\nThe input and output requirements are as follows:\n\nInput:\n  `elements` (list): A list of integers representing the elements of the linked list.\n\nOutput:\n  `return` (str): A string representation of the balanced binary tree.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Link:\n    empty = ()\n\n    def __init__(self, first, rest=empty):\n        assert rest is Link.empty or isinstance(rest, Link)\n        self.first = first\n        self.rest = rest\n\n    def __len__(self):\n        return 1 + len(self.rest)\n\n    def __repr__(self):\n        if self.rest is not Link.empty:\n            rest_str = ', ' + repr(self.rest)\n        else:\n            rest_str = ''\n        return 'Link({0}{1})'.format(repr(self.first), rest_str)\n\nclass BinaryTree:\n    empty = ()\n\n    def __init__(self, entry, left=empty, right=empty):\n        self.entry = entry\n        self.left = left\n        self.right = right\n\n    def __repr__(self):\n        if self.left == self.empty and self.right == self.empty:\n            return 'BinaryTree({})'.format(repr(self.entry))\n        left = 'BinaryTree.empty' if self.left == self.empty else self.left\n        right = 'BinaryTree.empty' if self.right == self.empty else self.right\n        return 'BinaryTree({}, {}, {})'.format(repr(self.entry),\n                                               repr(left), repr(right))\n\ndef partial_tree(s, n):\n    if n == 0:\n        return BinaryTree.empty, s\n    left_size = (n-1)//2\n    right_size = n - left_size - 1\n    left, rest = partial_tree(s, left_size)\n    entry, rest = rest.first, rest.rest\n    right, rest = partial_tree(rest, right_size)\n    return BinaryTree(entry, left, right), rest\n\ndef ordered_sequence_to_tree(s):\n    return partial_tree(s, len(s))[0]\n\n# main function\ndef main_solution(elements):\n    \"\"\"\n    Converts a linked list of elements into a balanced binary tree.\n\n    Args:\n    elements (list): A list of integers representing the elements of the linked list.\n\n    Returns:\n    str: A string representation of the balanced binary tree.\n    \"\"\"\n    # Convert the list of elements to a linked list\n    linked_list = Link(elements[0])\n    current = linked_list\n    for element in elements[1:]:\n        current.rest = Link(element)\n        current = current.rest\n\n    # Convert the linked list to a balanced binary tree\n    balanced_tree = ordered_sequence_to_tree(linked_list)\n\n    # Return the string representation of the balanced binary tree\n    return repr(balanced_tree)", "input_generator": "import random\nfrom random import randint, sample\n\ndef input_generator():\n    # Generate a random length between 1 and 20\n    length = randint(1, 20)\n    # Generate a list of unique elements in sorted order\n    elements = sorted(sample(range(1, 100), length))\n    return {'elements': elements}", "io_pairs": [{"input": {"elements": [31, 67, 81]}, "output": "BinaryTree(67, BinaryTree(31), BinaryTree(81))"}, {"input": {"elements": [14, 45, 76]}, "output": "BinaryTree(45, BinaryTree(14), BinaryTree(76))"}, {"input": {"elements": [37]}, "output": "BinaryTree(37)"}, {"input": {"elements": [22, 56]}, "output": "BinaryTree(22, 'BinaryTree.empty', BinaryTree(56))"}, {"input": {"elements": [22, 72]}, "output": "BinaryTree(22, 'BinaryTree.empty', BinaryTree(72))"}, {"input": {"elements": [7, 12, 41]}, "output": "BinaryTree(12, BinaryTree(7), BinaryTree(41))"}, {"input": {"elements": [10, 44, 75, 93]}, "output": "BinaryTree(44, BinaryTree(10), BinaryTree(75, 'BinaryTree.empty', BinaryTree(93)))"}, {"input": {"elements": [12, 34]}, "output": "BinaryTree(12, 'BinaryTree.empty', BinaryTree(34))"}, {"input": {"elements": [3, 47, 70]}, "output": "BinaryTree(47, BinaryTree(3), BinaryTree(70))"}, {"input": {"elements": [29, 34]}, "output": "BinaryTree(29, 'BinaryTree.empty', BinaryTree(34))"}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, given the current state of the board and which player is currently making the move, what is the best move and its corresponding score according to the minimax algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_state` (list of int): A list of 9 integers representing the current state of the Tic-Tac-Toe board. Each integer can be -1 (O), 0 (empty), or 1 (X).\n  `max_player` (bool): A boolean indicating whether the current player is the maximizing player (True) or the minimizing player (False).\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `score` (int): The score of the best move determined by the minimax algorithm.\n    - `move` (int): The index of the best move on the board (0-8).", "reference_code": "# import necessary packages\nfrom copy import deepcopy\nfrom random import randint\n\n# all class and function definitions in the code file, if any\nclass Board(object):\n    def __init__(self):\n        self.board = [0 for _ in range(9)]\n\n    def winner(self):\n        def winning_line(a, b, c):\n            if (\n                self.board[a] != 0 and\n                self.board[a] == self.board[b] == self.board[c]\n            ):\n                return self.board[a]\n\n        lines = [\n            [0, 1, 2], [3, 4, 5], [6, 7, 8],\n            [0, 3, 6], [1, 4, 7], [2, 5, 8],\n            [0, 4, 8], [2, 4, 6]]\n\n        for a, b, c in lines:\n            res = winning_line(a, b, c)\n            if res:\n                return res\n\n    def valid_moves(self):\n        return [i for i in range(9) if self.board[i] == 0]\n\n    def is_full(self):\n        return len(self.valid_moves()) == 0\n\n    def apply(self, i, player):\n        self.board[i] = player\n\n    def __str__(self):\n        def x(i):\n            r = { -1 : 'O', 0 : '.', 1: 'X'}\n            return r[self.board[i]]\n\n        return '%s %s %s\\n%s %s %s\\n%s %s %s' % (\n            x(0), x(1), x(2), x(3), x(4), x(5), x(6), x(7), x(8))\n\n\ndef minimax(board, max_player):\n    winner = board.winner()\n    if winner:\n        return winner, None\n\n    best_move, best_score = None, 0\n    player = 1 if max_player else -1\n\n    for move in board.valid_moves():\n        new_board = deepcopy(board)\n        new_board.apply(move, player)\n        score, _ = minimax(new_board, not max_player)\n        # if the move is a winning move, pick it, and return\n        if score == player:\n            return player, move\n        if best_move is None:\n            best_score = score\n            best_move = move\n        else:\n            if (\n                (max_player and score > best_score) or\n                (not max_player and score < best_score)\n            ):\n                best_score = score\n                best_move = move\n\n    return best_score, best_move\n\n# main function\ndef main_solution(board_state, max_player):\n    # Convert JSON serializable input to original input variables\n    board = Board()\n    board.board = board_state\n\n    # Apply the minimax algorithm to determine the best move\n    score, move = minimax(board, max_player)\n\n    # Convert the output to JSON serializable format\n    return {\"score\": score, \"move\": move}", "input_generator": "import random\nfrom random import randint\n\ndef input_generator():\n    board_state = [0] * 9\n    max_player = random.choice([True, False])\n    \n    # Randomly fill some positions with -1 or 1, ensuring no winner\n    for i in range(random.randint(0, 5)):\n        move = random.choice([idx for idx, val in enumerate(board_state) if val == 0])\n        board_state[move] = random.choice([-1, 1])\n    \n    # Ensure no winner\n    def has_winner(board):\n        lines = [\n            [0, 1, 2], [3, 4, 5], [6, 7, 8],\n            [0, 3, 6], [1, 4, 7], [2, 5, 8],\n            [0, 4, 8], [2, 4, 6]\n        ]\n        for a, b, c in lines:\n            if board[a] != 0 and board[a] == board[b] == board[c]:\n                return True\n        return False\n    \n    while has_winner(board_state):\n        board_state = [0] * 9\n        for i in range(random.randint(0, 5)):\n            move = random.choice([idx for idx, val in enumerate(board_state) if val == 0])\n            board_state[move] = random.choice([-1, 1])\n    \n    return {\"board_state\": board_state, \"max_player\": max_player}", "io_pairs": [{"input": {"board_state": [0, 1, 0, 0, 0, 0, 0, 0, 0], "max_player": true}, "output": {"score": 1, "move": 0}}, {"input": {"board_state": [0, 0, 0, 0, 0, 0, 0, 0, -1], "max_player": true}, "output": {"score": 0, "move": 4}}, {"input": {"board_state": [0, 0, 0, 0, 0, 0, 0, 1, 0], "max_player": true}, "output": {"score": 1, "move": 0}}, {"input": {"board_state": [0, 0, 0, 0, 0, 0, 0, 0, 0], "max_player": false}, "output": {"score": 0, "move": 0}}, {"input": {"board_state": [0, 0, 0, 0, 1, -1, -1, -1, 0], "max_player": true}, "output": {"score": 0, "move": 8}}, {"input": {"board_state": [-1, 0, 1, -1, 0, 0, 0, 1, 0], "max_player": true}, "output": {"score": 1, "move": 6}}, {"input": {"board_state": [0, 0, 1, -1, 0, -1, 0, -1, 0], "max_player": true}, "output": {"score": -1, "move": 0}}, {"input": {"board_state": [0, -1, 1, 0, 0, 0, 0, 0, 0], "max_player": false}, "output": {"score": 0, "move": 4}}, {"input": {"board_state": [0, 0, 0, 0, 0, -1, 0, 0, 0], "max_player": true}, "output": {"score": 0, "move": 2}}, {"input": {"board_state": [0, 1, 0, 0, 0, 0, 0, 0, 0], "max_player": false}, "output": {"score": 0, "move": 0}}], "error_log": []}
{"context": "Given a mathematical function that approximates the hyperbolic sine function using a series expansion, what is the result of this approximation when evaluated at a specific value of `x`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): The input argument for which the function `mans_sinuss` will be evaluated. It represents the value of the argument in the hyperbolic sine function.\n\nOutput:\n  `return` (float): The result of the function `mans_sinuss` evaluated at the input `x`. It represents the approximation of the hyperbolic sine function using a series expansion.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom math import sinh\n\n# all class and function definitions in the code file, if any\ndef mans_sinuss(x):\n    k = 0\n    a = x / 1\n    S = a\n    while k < 500:\n        k = k + 1\n        R = x * x / ((2 * k) * (2 * k + 1))\n        a = a * R\n        S = S + a\n    return S\n\n# main function\ndef main_solution(x):\n    # Convert input to float if necessary\n    x = float(x)\n    \n    # Calculate the result using the mans_sinuss function\n    result = mans_sinuss(x)\n    \n    # Return the result as a float\n    return float(result)", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    x = random.uniform(-10, 10)\n    return {'x': x}", "io_pairs": [{"input": {"x": -5.67541681039857}, "output": -145.80321500016845}, {"input": {"x": 2.8871940661480426}, "output": 8.943579978547884}, {"input": {"x": -0.6075972721188023}, "output": -0.6456783440844495}, {"input": {"x": -0.11612357340094093}, "output": -0.11638473104135698}, {"input": {"x": -7.419960040552667}, "output": -834.4831081238085}, {"input": {"x": -0.17282635454223794}, "output": -0.17368799727745804}, {"input": {"x": 9.204030736567628}, "output": 4968.551092387963}, {"input": {"x": -4.228533204344204}, "output": -34.300969085346765}, {"input": {"x": -6.847555135810572}, "output": -470.78750132777594}, {"input": {"x": -4.7484542045264995}, "output": -57.698543903156526}], "error_log": []}
{"context": "Given a list of characters, how can we generate all possible distinct permutations of the list?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_list` (list of str): A list of characters or strings for which distinct permutations need to be generated.\n\nOutput:\n  `return` (list of lists of str): A list containing all distinct permutations of the input list. Each permutation is represented as a list of strings.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef A_n_k(a, n, k, depth, used, curr, ans):\n    \"\"\"\n    depth: start from 0, or the depth of the search\n    used: track what items are in partial solution from the set n\n    curr: the current partial solution\n    ans: collect all the valid solutions\n    \"\"\"\n    if depth == k:\n        ans.append(curr[::])\n        return  \n\n    for i in range(n):\n        if not used[i]:\n            curr.append(a[i])\n            used[i] = True \n            A_n_k(a, n, k, depth+1, used, curr, ans)\n            curr.pop()\n            used[i] = False\n\n    return \n\ndef should_swap(ls, start, end):\n    for i in range(start, end):\n        if ls[i] == ls[end]:\n            return False\n    return True\n\ndef distinct_permutation(ls, start, end):\n    \"\"\"\n    prints all the permutations of a list \n    Input: a list, start and end indices\n    Output: print all permutations\n    \"\"\"\n    if (start >= end):\n        return [ls[:]]\n    permutations = []\n    for i in range(start, end):\n        check = should_swap(ls, start, i)\n        if check:\n            ls[start], ls[i] = ls[i], ls[start] #swapping\n            permutations.extend(distinct_permutation(ls, start+1, end))\n            ls[start], ls[i] = ls[i], ls[start] #backtracking\n    return permutations\n\n# main function\ndef main_solution(input_list):\n    # Convert input_list to a list if it's not already\n    input_list = list(input_list)\n    \n    # Generate all distinct permutations of the input list\n    permutations = distinct_permutation(input_list, 0, len(input_list))\n    \n    # Return the list of permutations\n    return permutations", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Randomly decide the length of the list (between 3 and 6 for reasonable size)\n    length = random.randint(3, 6)\n    \n    # Randomly decide whether to use letters or digits\n    if random.choice([True, False]):\n        # Generate a list of random letters (may include duplicates)\n        chars = random.choices(string.ascii_lowercase, k=length)\n    else:\n        # Generate a list of random digits (may include duplicates)\n        chars = random.choices(string.digits, k=length)\n    \n    # Randomly shuffle the list to ensure randomness\n    random.shuffle(chars)\n    \n    return {'input_list': chars}", "io_pairs": [{"input": {"input_list": ["5", "1", "8"]}, "output": [["5", "1", "8"], ["5", "8", "1"], ["1", "5", "8"], ["1", "8", "5"], ["8", "1", "5"], ["8", "5", "1"]]}, {"input": {"input_list": ["s", "m", "x"]}, "output": [["s", "m", "x"], ["s", "x", "m"], ["m", "s", "x"], ["m", "x", "s"], ["x", "m", "s"], ["x", "s", "m"]]}, {"input": {"input_list": ["0", "2", "8"]}, "output": [["0", "2", "8"], ["0", "8", "2"], ["2", "0", "8"], ["2", "8", "0"], ["8", "2", "0"], ["8", "0", "2"]]}, {"input": {"input_list": ["a", "p", "q"]}, "output": [["a", "p", "q"], ["a", "q", "p"], ["p", "a", "q"], ["p", "q", "a"], ["q", "p", "a"], ["q", "a", "p"]]}, {"input": {"input_list": ["r", "x", "d"]}, "output": [["r", "x", "d"], ["r", "d", "x"], ["x", "r", "d"], ["x", "d", "r"], ["d", "x", "r"], ["d", "r", "x"]]}, {"input": {"input_list": ["0", "0", "0", "6"]}, "output": [["0", "0", "0", "6"], ["0", "0", "6", "0"], ["0", "6", "0", "0"], ["6", "0", "0", "0"]]}, {"input": {"input_list": ["1", "6", "2"]}, "output": [["1", "6", "2"], ["1", "2", "6"], ["6", "1", "2"], ["6", "2", "1"], ["2", "6", "1"], ["2", "1", "6"]]}, {"input": {"input_list": ["3", "5", "7"]}, "output": [["3", "5", "7"], ["3", "7", "5"], ["5", "3", "7"], ["5", "7", "3"], ["7", "5", "3"], ["7", "3", "5"]]}, {"input": {"input_list": ["2", "1", "5"]}, "output": [["2", "1", "5"], ["2", "5", "1"], ["1", "2", "5"], ["1", "5", "2"], ["5", "1", "2"], ["5", "2", "1"]]}, {"input": {"input_list": ["4", "4", "4"]}, "output": [["4", "4", "4"]]}], "error_log": []}
{"context": "Given a mathematical expression involving numbers and the basic arithmetic operators (addition, subtraction, multiplication, and division), how can we determine the result of the expression using a recursive descent parser?\n\nThe input and output requirements are as follows:\n\nInput:\n  `expression` (str): A string representing a mathematical expression to be evaluated. The expression should only contain numbers, parentheses, and the operators '+', '-', '*', '/'.\n\nOutput:\n  `return` (int): The result of the evaluated mathematical expression.", "reference_code": "# import necessary packages\nimport re\nimport collections\n\n# Tokenizer \u5206\u8bcd\u5668\nNUM = \"(?P<NUM>\\d+)\"\nPLUS = \"(?P<PLUS>\\+)\"\nMINUS = \"(?P<MINUS>\\-)\"\nTIMES = \"(?P<TIMES>\\*)\"\nDIVIDE = \"(?P<DIVIDE>/)\"\nLPAREN = \"(?P<LPAREN>\\()\"\nRPAREN = \"(?P<RPAREN>\\))\"\nWS = \"?<WS>\\s+\"\n\nmaster_pat = re.compile('|'.join([NUM, PLUS, MINUS, TIMES, DIVIDE, LPAREN, RPAREN]))\nToken = collections.namedtuple(\"Token\", ['type', 'value'])\n\ndef generate_tokens(text):\n    scanner = master_pat.scanner(text)\n    for m in iter(scanner.match, None):\n        tok = Token(m.lastgroup, m.group())\n        if tok.type != 'WS':\n            yield tok\n\n# parser \u8bed\u6cd5\u5206\u6790\u5668\nclass ExpressionEvaluator:\n    def parse(self, text):\n        self.tokens = generate_tokens(text)\n        self.tok = None  # Last symbol consumed\n        self.nexttok = None  # Next symbol tokenized\n        self._advance()  # Load first lookahead token\n        return self.expr()\n\n    def _advance(self):\n        'Advance one token ahead'\n        self.tok, self.nexttok = self.nexttok, next(self.tokens, None)\n\n    def _accept(self, toktype):\n        'Test and consume the next token if it matches toktype'\n        if self.nexttok and self.nexttok.type == toktype:\n            self._advance()\n            return True\n        else:\n            return False\n\n    def _except(self, toktype):\n        'Consume next token if it matches toktype or raise SyntaxError'\n        if not self._accept(toktype):\n            raise SyntaxError('Expected ' + toktype)\n\n    def expr(self):\n        \"expr ::= term {('+'|'-') term}*\"\n        exprval = self.term()\n        while self._accept('PLUS') or self._accept('MINUS'):\n            op = self.tok.type\n            right = self.term()\n            if op == 'PLUS':\n                exprval += right\n            elif op == 'MINUS':\n                exprval -= right\n        return exprval\n\n    def term(self):\n        \"term ::= factor { ('*'|'/') factor }*\"\n        termval = self.factor()\n        while self._accept('TIMES') or self._accept('DIVIDE'):\n            op = self.tok.type\n            right = self.factor()\n            if op == 'TIMES':\n                termval *= right\n            elif op == 'DIVIDE':\n                termval /= right\n        return termval\n\n    def factor(self):\n        \"factor ::= NUM | ( expr )\"\n        if self._accept('NUM'):\n            return int(self.tok.value)\n        elif self._accept('LPAREN'):\n            exprval = self.expr()\n            self._except('RPAREN')\n            return exprval\n        else:\n            raise SyntaxError('Expected NUMBER OR LPAREN')\n\n# main function\ndef main_solution(expression):\n    \"\"\"\n    Evaluates a mathematical expression using a recursive descent parser.\n\n    Parameters:\n    expression (str): A string representing a mathematical expression to be evaluated.\n\n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    evaluator = ExpressionEvaluator()\n    return evaluator.parse(expression)", "input_generator": "import random\nimport string\n\ndef input_generator():\n    operators = ['+', '-', '*', '/']\n    depth = random.randint(1, 3)\n    \n    def generate_expression(d):\n        if d == 0:\n            return str(random.randint(1, 100))\n        else:\n            left = generate_expression(d - 1)\n            right = generate_expression(d - 1)\n            op = random.choice(operators)\n            if random.random() < 0.3:\n                return f\"({left} {op} {right})\"\n            else:\n                return f\"{left} {op} {right}\"\n    \n    expression = generate_expression(depth)\n    # Occasionally add some spaces\n    if random.random() < 0.5:\n        expression = ' '.join(expression)\n    return {'expression': expression}", "io_pairs": [{"input": {"expression": "41 * 65 + (22 + 3)"}, "output": 41}, {"input": {"expression": "51 - 15 * (92 - 98) / 36 * 80 / 6 - 69"}, "output": 51}, {"input": {"expression": "34 * 91"}, "output": 34}, {"input": {"expression": "9 6   *   1 0   /   3 9   -   3 4"}, "output": 9}, {"input": {"expression": "6 1   *   2 5   -   ( 4 6   *   2 )"}, "output": 6}, {"input": {"expression": "5 4   -   4 8   -   2 3   +   7 5   -   1 3   *   8 0   -   9 2   -   3 1"}, "output": 5}, {"input": {"expression": "2 2   +   5 8"}, "output": 2}, {"input": {"expression": "4 6   +   3 9   /   8 8   +   9 9"}, "output": 4}, {"input": {"expression": "17 * 68"}, "output": 17}, {"input": {"expression": "7 2   *   2 5"}, "output": 7}], "error_log": []}
{"context": "In a memory system, data is stored in a spiral pattern starting from address 1. Each square in this spiral grid stores a value that is the sum of the values in all its adjacent squares, including diagonals. Given an address in this spiral grid, what is the storage value at that address?\n\nThe input and output requirements are as follows:\n\nInput:\n  `addr` (int): The address in the spiral memory grid for which the storage value is to be calculated. The address should be a positive integer.\n\nOutput:\n  `return` (int): The storage value at the given address in the spiral memory grid. This value is the sum of the values in all adjacent squares, including diagonals.", "reference_code": "# import necessary packages\nimport math\nfrom itertools import count, islice\n\n# all class and function definitions in the code file, if any\ndef nth(iterable, n, default=None):\n    \"Returns the nth item or a default value\"\n    return next(islice(iterable, n, None), default)\n\ndef to_coord(addr):\n    dist = math.ceil((math.sqrt(addr) - 1)/2)\n    width = 1 + 2 * dist\n    \n    if dist == 0:\n        return (0, 0)\n\n    start = (width - 2) ** 2 + 1\n    center = start + (width - 3)//2\n    from_start = addr - start\n    from_center = addr - center\n    side = width - 1\n\n    if from_start < side:\n        offset = from_center\n        return (dist, offset)\n    elif addr - start < 2 * side:\n        offset = -(from_center - side)\n        return (offset, dist)\n    elif addr - start < 3 * side:\n        offset = -(from_center - 2 * side)\n        return (-dist, offset)\n    else:\n        offset = from_center - 3 * side\n        return (offset, -dist)\n\ndef storage():\n    grid = {\n        (0, 0): 1\n    }\n\n    yield 1\n\n    for addr in count(start=2):\n        x, y = to_coord(addr)\n        adjacent = [\n            (x+1, y+0),\n            (x+1, y+1),\n            (x+0, y+1),\n            (x-1, y+1),\n            (x-1, y+0),\n            (x-1, y-1),\n            (x+0, y-1),\n            (x+1, y-1)\n        ]\n        value = sum(grid.get(coord, 0) for coord in adjacent)\n        grid[(x, y)] = value\n        yield value\n\ndef storage_at(addr):\n    return nth(storage(), addr - 1)\n\n# main function\ndef main_solution(addr):\n    # Convert the address to its corresponding storage value\n    result = storage_at(addr)\n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    return {'addr': random.randint(1, 1000)}", "io_pairs": [{"input": {"addr": 803}, "output": 149605114515696220510855361}, {"input": {"addr": 73}, "output": 1026827}, {"input": {"addr": 384}, "output": 113371754444310536}, {"input": {"addr": 701}, "output": 1221149518740623087232032}, {"input": {"addr": 815}, "output": 370924707201790028511955456}, {"input": {"addr": 311}, "output": 1070338187352412}, {"input": {"addr": 249}, "output": 12145001538651}, {"input": {"addr": 923}, "output": 23979515056398896930163383404}, {"input": {"addr": 822}, "output": 428393358207183646612082414}, {"input": {"addr": 3}, "output": 2}], "error_log": []}
{"context": "Given a 3D box with a specified edge length, containing a certain number of hard spheres with a given radius, what is the average distance between these particles when considering a certain number of configurations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `M` (int): Number of configurations to generate.\n  `L` (float): Edge length of the box.\n  `R` (float): Radius of the spheres.\n  `N` (int): Dimension of the space (3 for 3D).\n  `n` (int): Number of particles to be placed in the box.\n\nOutput:\n  `return` (dict): A dictionary containing the key `average_distance` with the average distance between particles as its value.", "reference_code": "# import necessary packages\nimport numpy as np\nimport random as rnd\n\n# all class and function definitions in the code file, if any\nclass ConfigError(Exception):\n    def __init__(self):\n        pass\n    def __str__(self):\n        return 'Could not find a configuration'\n\ndef genConfiguration(L, R, N, n):\n    \"\"\"\n    Generates a particular configuration\n    \"\"\"\n    list_of_points = []\n    rnd.seed()\n    cnt = 0\n    while True:\n        cnt += 1\n        if cnt > n * 100:\n            raise ConfigError()\n        if len(list_of_points) >= n:\n            break\n        point = np.array([rnd.uniform(0+R, L-R) for _ in range(N)], dtype=float)\n        if volumeCondition(point, list_of_points, R):\n            list_of_points.append(point)\n    return list_of_points\n\ndef volumeCondition(pnt1, list_of_points, radius):\n    \"\"\"\n    Checks whether the sphere at pnt1 with radius overlaps with any\n    of the points in list_of_points\n    \"\"\"\n    for pnt2 in list_of_points:\n        if (np.sqrt(((pnt1 - pnt2) ** 2).sum()) < radius):\n            return False\n    return True\n\ndef dkmean(config):\n    \"\"\"\n    Calculates the d_mean of a given configuration\n    d_mean = 2*1 / (n(n-1)) * SUM_(i<j) d_ij\n    with d_ij = dist(pi, pj)\n    \"\"\"\n    sum = 0\n    n = len(config)\n    for j, pj in enumerate(config):\n        for i, pi in enumerate(config[0:j]):\n            sum += np.sqrt(((pi - pj) ** 2).sum())\n    return sum * (2 * 1 / float((n * (n - 1))))\n\ndef dmean(M, L, R, N, n):\n    \"\"\"\n    Creates M configurations k, gets the d^k_mean for each\n    and returns the total d_mean, with\n    d_mean = 1 / m * SUM_{k=1}^{M} d^k_mean\n    \"\"\"\n    dmean = 0\n    for _ in range(M):\n        try:\n            config = genConfiguration(L, R, N, n)\n        except ConfigError:\n            return 0\n        else:\n            dmean += dkmean(config)\n    return dmean / float(M)\n\n# main function\ndef main_solution(M, L, R, N, n):\n    \"\"\"\n    Calculates the average distance between particles in a 3D box for a given number of configurations.\n    \"\"\"\n    # Convert inputs to appropriate types if necessary\n    M = int(M)\n    L = float(L)\n    R = float(R)\n    N = int(N)\n    n = int(n)\n    \n    # Calculate the average distance\n    avg_distance = dmean(M, L, R, N, n)\n    \n    # Return the result as a JSON serializable output\n    return {\"average_distance\": avg_distance}", "input_generator": "import numpy as np\nimport random as rnd\n\ndef input_generator():\n    M = rnd.randint(1, 10)\n    L = rnd.uniform(5.0, 20.0)\n    R = rnd.uniform(0.1, 1.0)\n    N = rnd.choice([2, 3])\n    n = rnd.randint(2, 10)\n    return {\n        'M': M,\n        'L': L,\n        'R': R,\n        'N': N,\n        'n': n\n    }", "io_pairs": [{"input": {"M": 10, "L": 13.716173784362924, "R": 0.11334149026249447, "N": 2, "n": 8}, "output": {"average_distance": 6.261572844931242}}, {"input": {"M": 1, "L": 10.928365597914176, "R": 0.6518971604763639, "N": 2, "n": 10}, "output": {"average_distance": 5.670462541120827}}, {"input": {"M": 4, "L": 15.333645388030014, "R": 0.8728106350953793, "N": 3, "n": 7}, "output": {"average_distance": 9.361875306416223}}, {"input": {"M": 7, "L": 9.517493305889392, "R": 0.4016921351962929, "N": 3, "n": 3}, "output": {"average_distance": 5.781428467506659}}, {"input": {"M": 6, "L": 8.177768369948243, "R": 0.8482745789535925, "N": 2, "n": 8}, "output": {"average_distance": 3.407876650876179}}, {"input": {"M": 6, "L": 15.478307810268303, "R": 0.8202845765969087, "N": 2, "n": 9}, "output": {"average_distance": 6.802175861398328}}, {"input": {"M": 5, "L": 18.749996296745522, "R": 0.8751510636430264, "N": 3, "n": 4}, "output": {"average_distance": 12.363589489193519}}, {"input": {"M": 9, "L": 11.665234801725813, "R": 0.5700280659965004, "N": 3, "n": 7}, "output": {"average_distance": 6.72503419698168}}, {"input": {"M": 10, "L": 8.616140319231091, "R": 0.31386632799739606, "N": 2, "n": 3}, "output": {"average_distance": 4.296439426703567}}, {"input": {"M": 7, "L": 17.63494964781272, "R": 0.3346523024938186, "N": 3, "n": 10}, "output": {"average_distance": 11.111947071552944}}], "error_log": []}
{"context": "In the field of bioinformatics, simulating molecular evolution helps us understand how genetic sequences change over time. Given a population of DNA sequences, how would the sequences evolve over a specified number of generations, and what would be the final state of the population? Specifically, what is the original sequence and the evolved sequences after the simulation?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The number of sequences in the population.\n  `L` (int): The length of each DNA sequence.\n  `G` (int): The number of generations to simulate.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `original_sequence` (str): The original DNA sequence.\n    - `population` (str): A comma-separated string of the evolved DNA sequences in the population.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef generateRandomDNASeq(length):\n    nucleotides = ['A', 'G', 'C', 'T']\n    sequence = ''\n    for i in range(length):\n        sequence += random.choice(nucleotides)\n    return sequence\n\ndef kimura2Parameter(sequence, a, b):\n    mutationMatrix = {'A':[1-a-(2*b), b, a, a],\n                      'C':[b, 1-a-(2*b), b, a],\n                      'G':[a, b, 1-a-(2*b), b],\n                      'T':[a, a, b, 1-a-(2*b)]}\n    matNucleoOrder = ['A', 'C', 'G', 'T']\n\n    for i in range(len(sequence)):\n        noMutation = True\n        probsCount = 0\n        randomNum = 0\n        while noMutation and probsCount < 3:\n            randomNum = random.random()\n            if randomNum <= mutationMatrix[sequence[i]][probsCount]:\n                noMutation = False\n            probsCount += 1\n\n        if not(noMutation):\n            sequence = sequence[:i] + matNucleoOrder[probsCount-1]+ sequence[i+1:]\n            \n    return sequence\n\n# main function\ndef main_solution(N, L, G):\n    originalSeq = generateRandomDNASeq(L)\n    population = []\n    for i in range(N):\n        population.append(originalSeq)\n\n    for i in range(G):\n        for j in range(len(population)):\n            newJ = kimura2Parameter(population[j], 0.3, 0.1)\n            population[j] = newJ\n\n    # Convert the population list to a JSON serializable format\n    population_str = ','.join(population)\n    return {\"original_sequence\": originalSeq, \"population\": population_str}", "input_generator": "import random\n\ndef input_generator():\n    N = random.randint(1, 100)  # Population size between 1 and 100\n    L = random.randint(10, 100)  # Sequence length between 10 and 100\n    G = random.randint(1, 50)    # Generations between 1 and 50\n    return {\"N\": N, \"L\": L, \"G\": G}", "io_pairs": [{"input": {"N": 1, "L": 18, "G": 45}, "output": {"original_sequence": "CGAGAGACACCGTACCTT", "population": "AGAAAACCGACAGCCACC"}}, {"input": {"N": 7, "L": 10, "G": 13}, "output": {"original_sequence": "ATCGCGCGGC", "population": "CGCCAACAGC,GGAAAACAGA,AACAACCAGG,GGAACAAAAG,ACACAGAGAC,AACACGCCAA,ACGAAAAAAA"}}, {"input": {"N": 1, "L": 22, "G": 12}, "output": {"original_sequence": "CGTCAATGGGAACGGTGTGCTG", "population": "CAAGGCGAAGAAAGAAAAAAAC"}}, {"input": {"N": 2, "L": 35, "G": 25}, "output": {"original_sequence": "TAGCTTACTTTACACAGAACCAAAATCAGTGACAT", "population": "AAACCAACAGAAACCGCACACGAAGGAGCGAAAAC,AACCCACGACAGCAAGGCCCCCACAACACGCCCCG"}}, {"input": {"N": 1, "L": 18, "G": 7}, "output": {"original_sequence": "CAGGAGCGCGGGCCTTTA", "population": "AGAGCGCAGCAAACCACG"}}, {"input": {"N": 1, "L": 82, "G": 36}, "output": {"original_sequence": "AATAGGGAGAGCAGGGTAGGTGTTTTCCACTAGTGCTATCTATACCTGTTGCGTAGCAGACGCCACGACCCGCTAGATGCGT", "population": "CCGAAGGGGAAAGGGCCAAGGACCCCCAAGAAAAAGCCCAACGACAACAAGGAGCACAGAAACACCCCAAGGCGAAACAAAC"}}, {"input": {"N": 1, "L": 38, "G": 19}, "output": {"original_sequence": "GGGTTACAAACAATCGAGCCCCTCCAGTGAATGTGCCG", "population": "AGCCAAGGGCCAAACAAACGGGAAACCCGCAGAAAAGA"}}, {"input": {"N": 1, "L": 37, "G": 41}, "output": {"original_sequence": "TTTCCCCGATTAACCCTCTACGCCGGTGTTTCCTTAG", "population": "CAACACCCGAACGGAGGACAAGCACAAAGAAAAAAAA"}}, {"input": {"N": 2, "L": 32, "G": 15}, "output": {"original_sequence": "ATCGACGGTGGCTCGTCGGCGGGGAGATGACC", "population": "AGCAAGAGCGCCAAAACCGGCCAGGCAGAAGA,AAGCAGACGAGCACAAACACAACAACCCCCCG"}}, {"input": {"N": 1, "L": 80, "G": 10}, "output": {"original_sequence": "ACGGTTGTGCGTTCCGCACGCCTTCTCCGCCCTATCCTAGGGCCATTAGGATGAAGGCACGTTCCAAGAAATTAACTCCA", "population": "GAACCGAAGCGAAAAACGGACACAACGAGAACACGAAACAACCGGGAAGACCCGACACCAAACGACCGGACGCAAAAACC"}}], "error_log": []}
{"context": "A monkey eats peaches in a peculiar way: each day, it eats half of the remaining peaches plus one more. On the last day, only one peach is left. How many peaches were there on the first day if the monkey followed this pattern for a given number of days?\n\nThe input and output requirements are as follows:\n\nInput:\n  `days` (int): The number of days to calculate backwards from the last day. For example, if the last day is day 10 and you want to calculate the number of peaches on day 1, `days` should be 10.\n\nOutput:\n  `return` (int): The number of peaches on the first day.", "reference_code": "# import necessary packages\n\n# main function\ndef main_solution(days):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    n = 1\n    for i in range(days - 1, 0, -1):\n        n = (n + 1) * 2\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return n", "input_generator": "import random\n\ndef input_generator():\n    days = random.randint(1, 20)\n    return {'days': days}", "io_pairs": [{"input": {"days": 12}, "output": 6142}, {"input": {"days": 15}, "output": 49150}, {"input": {"days": 20}, "output": 1572862}, {"input": {"days": 5}, "output": 46}, {"input": {"days": 19}, "output": 786430}, {"input": {"days": 16}, "output": 98302}, {"input": {"days": 10}, "output": 1534}, {"input": {"days": 6}, "output": 94}, {"input": {"days": 11}, "output": 3070}, {"input": {"days": 13}, "output": 12286}], "error_log": []}
{"context": "In a fantasy world, a player named `player_name` is exploring a world of size `world_size`. The player can either attack a target or grab an item. What will be the outcome of the player's action `action` on the target `target`?\n\nThe input and output requirements are as follows:\n\nInput:\n- `player_name` (str): The name of the player.\n- `world_size` (tuple): A tuple representing the size of the world in the format (width, height).\n- `action` (str): The action the player wants to perform, either \"attack\" or \"grab\".\n- `target` (str): The target of the action, which can be an item modifier for \"grab\" or a target name for \"attack\".\n\nOutput:\n- `return` (dict): A dictionary containing the result of the action. The key is \"result\" and the value is a string describing the outcome of the action.", "reference_code": "# import necessary packages\nimport random\nimport math\n\n# all class and function definitions in the code file, if any\nclass World:\n    size = (20, 20)\n\n    def __init__(self, world_size):\n        self.map = self.create_world(world_size)\n\n    def create_world(self, world_size):\n        world_map = {}\n        for i in range(world_size[0]):\n            for j in range(world_size[1]):\n                env_type = random.choice(['village', 'desert', 'forest'])\n                world_map[(i, j)] = Environment(env_type)\n        return world_map\n\nclass Environment:\n    def __init__(self, env_type):\n        self.name = env_type\n        self.contents = []\n\nclass Player:\n    def __init__(self, name):\n        self.name = name\n        self.hp = 10\n        self.strength = 1\n        self.speed = 1\n        self.defense = 1\n        self.inventory_dict = {}\n\n    def attack(self, opponent):\n        p_hit = 0.8 * self.speed / (opponent.speed + self.speed)\n        hploss_give = math.ceil(random.uniform(0.5, 1) * self.strength / opponent.defense)\n        hit = random.choices(population=[True, False], weights=[p_hit, 1.0 - p_hit])[0]\n        if hit:\n            opponent.hp -= hploss_give\n            return f\"You hit {opponent.name} and they lost {hploss_give} hp.\"\n        else:\n            return f\"You missed {opponent.name}.\"\n\n    def grab(self, item):\n        if item.name in self.inventory_dict:\n            self.inventory_dict[item.name] += 1\n        else:\n            self.inventory_dict[item.name] = 1\n        return f\"You place the {item.name} in your inventory.\"\n\nclass Item:\n    def __init__(self, args):\n        self.base = args[1]\n        self.modifier = args[0]\n        self.name = self.modifier + ' ' + self.base\n\n# main function\ndef main_solution(player_name, world_size, action, target):\n    # Initialize the world and player\n    world = World(world_size)\n    player = Player(player_name)\n\n    # Perform the action\n    if action == \"attack\":\n        environment = world.map[(0, 0)]\n        target_object = environment.contents[0] if environment.contents else None\n        if target_object:\n            result = player.attack(target_object)\n        else:\n            result = \"There is no target to attack.\"\n    elif action == \"grab\":\n        environment = world.map[(0, 0)]\n        target_object = Item((target, \"Potion\"))\n        environment.contents.append(target_object)\n        result = player.grab(target_object)\n    else:\n        result = \"Invalid action.\"\n\n    # Return the result\n    return {\"result\": result}", "input_generator": "import random\n\ndef input_generator():\n    player_names = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Eve\", \"Frank\", \"Grace\", \"Hank\"]\n    actions = [\"attack\", \"grab\"]\n    modifiers = [\"red\", \"blue\", \"green\", \"yellow\", \"healing\", \"poisonous\", \"magic\", \"rare\"]\n    \n    player_name = random.choice(player_names)\n    world_size = (random.randint(5, 20), random.randint(5, 20))\n    action = random.choice(actions)\n    target = random.choice(modifiers) if action == \"grab\" else None\n    \n    return {\n        \"player_name\": player_name,\n        \"world_size\": world_size,\n        \"action\": action,\n        \"target\": target\n    }", "io_pairs": [{"input": {"player_name": "Hank", "world_size": [14, 15], "action": "grab", "target": "healing"}, "output": {"result": "You place the healing Potion in your inventory."}}, {"input": {"player_name": "Frank", "world_size": [18, 6], "action": "grab", "target": "blue"}, "output": {"result": "You place the blue Potion in your inventory."}}, {"input": {"player_name": "Hank", "world_size": [19, 14], "action": "grab", "target": "yellow"}, "output": {"result": "You place the yellow Potion in your inventory."}}, {"input": {"player_name": "Eve", "world_size": [13, 15], "action": "grab", "target": "poisonous"}, "output": {"result": "You place the poisonous Potion in your inventory."}}, {"input": {"player_name": "Frank", "world_size": [18, 20], "action": "attack", "target": null}, "output": {"result": "There is no target to attack."}}, {"input": {"player_name": "Hank", "world_size": [9, 16], "action": "grab", "target": "healing"}, "output": {"result": "You place the healing Potion in your inventory."}}, {"input": {"player_name": "Frank", "world_size": [18, 13], "action": "attack", "target": null}, "output": {"result": "There is no target to attack."}}, {"input": {"player_name": "Grace", "world_size": [20, 8], "action": "attack", "target": null}, "output": {"result": "There is no target to attack."}}, {"input": {"player_name": "Hank", "world_size": [5, 6], "action": "attack", "target": null}, "output": {"result": "There is no target to attack."}}, {"input": {"player_name": "Alice", "world_size": [16, 11], "action": "grab", "target": "poisonous"}, "output": {"result": "You place the poisonous Potion in your inventory."}}], "error_log": []}
{"context": "In a farm, there are a certain number of chickens and rabbits. You know the total number of heads and legs among them. How many chickens and how many rabbits are there on the farm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `heads` (int): The total number of heads (chickens and rabbits combined).\n  `legs` (int): The total number of legs (chickens and rabbits combined).\n\nOutput:\n  `return` (dict): A dictionary containing the number of chickens and rabbits. The keys are:\n    - `\"chickens\"` (int): The number of chickens.\n    - `\"rabbits\"` (int): The number of rabbits.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef puzzle(h, l):\n    for r in range(h + 1):\n        c = h - r\n        if 2 * c + 4 * r == l:\n            return {\"chickens\": c, \"rabbits\": r}\n    return {\"chickens\": 0, \"rabbits\": 0}\n\n# main function\ndef main_solution(heads, legs):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = puzzle(heads, legs)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    heads = random.randint(1, 100)\n    # Ensure legs is at least 2*heads (all chickens) and at most 4*heads (all rabbits)\n    legs = random.randint(2 * heads, 4 * heads)\n    return {\"heads\": heads, \"legs\": legs}", "io_pairs": [{"input": {"heads": 60, "legs": 221}, "output": {"chickens": 0, "rabbits": 0}}, {"input": {"heads": 74, "legs": 276}, "output": {"chickens": 10, "rabbits": 64}}, {"input": {"heads": 18, "legs": 67}, "output": {"chickens": 0, "rabbits": 0}}, {"input": {"heads": 89, "legs": 278}, "output": {"chickens": 39, "rabbits": 50}}, {"input": {"heads": 24, "legs": 48}, "output": {"chickens": 24, "rabbits": 0}}, {"input": {"heads": 79, "legs": 161}, "output": {"chickens": 0, "rabbits": 0}}, {"input": {"heads": 23, "legs": 85}, "output": {"chickens": 0, "rabbits": 0}}, {"input": {"heads": 84, "legs": 199}, "output": {"chickens": 0, "rabbits": 0}}, {"input": {"heads": 45, "legs": 140}, "output": {"chickens": 20, "rabbits": 25}}, {"input": {"heads": 48, "legs": 177}, "output": {"chickens": 0, "rabbits": 0}}], "error_log": []}
{"context": "In a hypothetical universe, a cluster of celestial bodies is formed within a spherical region. Each celestial body starts at a random position within this sphere and moves according to a simplified gravitational model. Given the number of celestial bodies, the number of time steps to simulate, and the radius of the initial spherical region, what are the final positions of all the celestial bodies after the simulation?\n\nThe input and output requirements are as follows:\n\nInput:\n- `N` (int): The number of celestial bodies in the cluster.\n- `n_steps` (int): The number of time steps to simulate the system.\n- `radius` (float): The radius of the sphere within which the initial positions of the celestial bodies are randomly picked.\n\nOutput:\n- `return` (list of lists): A list containing the final positions of all celestial bodies. Each inner list represents the 3D coordinates (x, y, z) of a celestial body.", "reference_code": "# import necessary packages\nimport random\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass CelestialBody:\n    def __init__(self, radius, M, n):\n        self.R = radius\n        self.M = M\n        self.n = n\n        self.r = np.zeros((n, 3))\n        self.v = np.zeros((n, 3))\n        self.a = np.zeros((n, 3))\n\n    def set_initial_conditions(self, r0, v0, a0):\n        self.r[0] = r0\n        self.v[0] = v0\n        self.a[0] = a0\n\n    def step(self, dt, i, cb_list):\n        # Simplified step function for demonstration purposes\n        self.r[i+1] = self.r[i] + self.v[i] * dt\n        self.v[i+1] = self.v[i] + self.a[i] * dt\n\nclass Cluster:\n    point_of_origin = [0, 0, 0]\n\n    def __init__(self, N, n_steps):\n        self.N = N\n        self.n_steps = n_steps\n        self.cb_list = [CelestialBody(radius=random.randint(30, 500), M=float(random.randint(9, 11)), n=n_steps) for i in range(N)]\n\n    def initialize(self, radius=20):\n        for body in self.cb_list:\n            body.set_initial_conditions(r0=Cluster.pick_point_in_sphere(radius), v0=[0, 0, 0], a0=[0, 0, 0])\n\n    @staticmethod\n    def pick_point_in_sphere(R):\n        while True:\n            x = random.random()*R\n            y = random.random()*R\n            z = random.random()*R\n            if np.sqrt(x**2 + y**2 + z**2) < R:\n                return np.array([x, y, z])\n\n# main function\ndef main_solution(N, n_steps, radius):\n    # Convert JSON serializable inputs to original input variables\n    cluster = Cluster(N, n_steps)\n    cluster.initialize(radius)\n\n    # Simulate the system for n_steps\n    for i in range(n_steps - 1):\n        for body in cluster.cb_list:\n            body.step(1, i, cluster.cb_list)\n\n    # Collect the final positions of all celestial bodies\n    final_positions = [body.r[-1].tolist() for body in cluster.cb_list]\n\n    # Return the final positions as JSON serializable output\n    return final_positions", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    N = random.randint(1, 10)  # Number of celestial bodies\n    n_steps = random.randint(5, 20)  # Number of simulation steps\n    radius = random.uniform(10.0, 50.0)  # Initialization radius\n    return {'N': N, 'n_steps': n_steps, 'radius': radius}", "io_pairs": [{"input": {"N": 2, "n_steps": 15, "radius": 48.57287422389842}, "output": [[23.326665619458225, 4.48533829472553, 5.2768777606437585], [8.231534148610113, 29.579422947351716, 19.477127696700904]]}, {"input": {"N": 3, "n_steps": 10, "radius": 13.488980648229262}, "output": [[1.986876439032246, 12.171328107866879, 2.463124721451245], [3.185399360311547, 7.622956030249159, 5.855454775478933], [3.9482238641521468, 12.748350681898554, 0.7105227795573336]]}, {"input": {"N": 2, "n_steps": 18, "radius": 42.663540098245306}, "output": [[1.8616178767309985, 15.148359077128559, 1.9643133543855424], [13.618331646316365, 19.68292880649537, 14.537247981506873]]}, {"input": {"N": 2, "n_steps": 11, "radius": 41.53331144989699}, "output": [[19.07287008136793, 19.80744008670361, 25.456657156454188], [9.237650137260923, 31.21570930400593, 17.99266083240286]]}, {"input": {"N": 1, "n_steps": 6, "radius": 13.54332979615258}, "output": [[4.79231296243175, 1.6560367588743061, 12.377778186814558]]}, {"input": {"N": 1, "n_steps": 10, "radius": 11.258936873046451}, "output": [[9.764459624429968, 5.355404815916667, 1.032659297450649]]}, {"input": {"N": 3, "n_steps": 10, "radius": 36.02209333388312}, "output": [[16.327006546864915, 11.84868281165018, 16.691902812510996], [16.295831539151823, 11.71902130568962, 29.264812584763234], [21.115404708638042, 23.904634861569274, 13.103478419828882]]}, {"input": {"N": 4, "n_steps": 8, "radius": 19.70760719791688}, "output": [[17.0875001832176, 0.20755709909789033, 3.8342546443163594], [2.0504997283165807, 11.903999178137516, 9.267430411912436], [14.125953945483065, 12.372070037498897, 4.94116920791552], [9.634875467349767, 8.360007015308812, 8.711583220133283]]}, {"input": {"N": 5, "n_steps": 14, "radius": 36.310463988144726}, "output": [[16.46199714987827, 2.8300102193221632, 15.028871609521207], [1.2201201039701395, 1.6320163579178437, 34.16269942083122], [2.5948562769014685, 25.836101751296873, 4.729940441951561], [27.329630188386446, 16.22960624840561, 14.722943297138746], [10.91184799728232, 7.382934418511388, 21.22508473962589]]}, {"input": {"N": 2, "n_steps": 15, "radius": 38.357466020157105}, "output": [[27.034662469179214, 16.312956161341457, 9.44983987000508], [10.07397104650219, 10.903791902992113, 25.410404091884928]]}], "error_log": []}
{"context": "Given a cellular automaton known as the Game of Life, which simulates the life cycle of cells on a grid, how would the state of the board evolve after one iteration, considering the rules that govern the birth, death, and survival of cells based on their neighbors?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists of integers): A 2D array representing the state of the board. Each element in the array is either `0` (dead cell) or `1` (live cell).\n\nOutput:\n  `return` (list of lists of integers): A 2D array representing the next state of the board after applying the rules of the Game of Life. Each element in the array is either `0` (dead cell) or `1` (live cell).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def gameOfLife(self, board):\n        if not board:\n            return []\n\n        self.board = board\n        self.num_rows, self.num_cols = len(self.board), len(self.board[0])\n        self.directions = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]]\n\n        for row in range(self.num_rows):\n            for col in range(self.num_cols):\n                ones_count = self.count_ones(row, col)\n                if self.board[row][col] == 1:\n                    if ones_count < 2:\n                        board[row][col] = 3\n                    elif ones_count > 3:\n                        board[row][col] = 3\n                else:\n                    if ones_count == 3:\n                        board[row][col] = 2\n\n        for row in range(self.num_rows):\n            for col in range(self.num_cols):\n                if self.board[row][col] == 2:\n                    self.board[row][col] = 1\n                elif self.board[row][col] == 3:\n                    self.board[row][col] = 0\n\n    def count_ones(self, row, col):\n        ones_count = 0\n        for item in self.directions:\n            neighbour_row = row + item[0]\n            neighbour_col = col + item[1]\n            if -1 < neighbour_row < self.num_rows and -1 < neighbour_col < self.num_cols:\n                if self.board[neighbour_row][neighbour_col] % 2 == 1:\n                    ones_count += 1\n        return ones_count\n\n# main function\ndef main_solution(board):\n    # Convert the input board to a list of lists if it's not already\n    if not isinstance(board, list) or not all(isinstance(row, list) for row in board):\n        raise ValueError(\"Input board must be a list of lists.\")\n\n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Apply the game of life rules to the board\n    solution.gameOfLife(board)\n    \n    # Return the updated board\n    return board", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(3, 10)\n    cols = random.randint(3, 10)\n    board = [[random.randint(0, 1) for _ in range(cols)] for _ in range(rows)]\n    return {'board': board}", "io_pairs": [{"input": {"board": [[0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0]]}, "output": [[0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0]]}, {"input": {"board": [[0, 1, 0], [1, 0, 1], [0, 0, 1], [0, 1, 1], [0, 0, 0]]}, "output": [[0, 1, 0], [1, 0, 1], [0, 0, 1], [0, 1, 1], [0, 0, 0]]}, {"input": {"board": [[0, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0]]}, "output": [[0, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0]]}, {"input": {"board": [[0, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0]]}, "output": [[0, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0]]}, {"input": {"board": [[1, 1, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0]]}, "output": [[1, 1, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0]]}, {"input": {"board": [[1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 1]]}, "output": [[1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 1]]}, {"input": {"board": [[0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0]]}, "output": [[0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0]]}, {"input": {"board": [[1, 0, 0, 1, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 0, 1, 1]]}, "output": [[1, 0, 0, 1, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 0, 1, 1]]}, {"input": {"board": [[0, 1, 0], [1, 1, 1], [0, 0, 0]]}, "output": [[0, 1, 0], [1, 1, 1], [0, 0, 0]]}, {"input": {"board": [[1, 0, 0, 0, 0], [0, 0, 0, 0, 1], [1, 0, 0, 0, 1]]}, "output": [[1, 0, 0, 0, 0], [0, 0, 0, 0, 1], [1, 0, 0, 0, 1]]}], "error_log": []}
{"context": "Given four numbers, can you determine the sequence of arithmetic operations that results in the number 24? The operations allowed are addition, subtraction, multiplication, and division. If no such sequence exists, indicate that no solution can be found.\n\nThe input and output requirements are as follows:\n\nInput:\n  `numbers` (list of int): A list of four integers representing the numbers to be used in the arithmetic operations.\n\nOutput:\n  `return` (str): A string representing the arithmetic operation that results in the number 24. If no such operation exists, the string \"No solution found\" is returned.", "reference_code": "# import necessary packages\nfrom itertools import permutations \nfrom math import sqrt\n\n# Function to perform arithmetic operations on two tuples\ndef oprNum(a, b, op):\n    if op == \"+\":\n        rval = a[1] + b[1]\n        rstr = \"(\" + a[0] + \"+\" + b[0] + \")\"\n    elif op == '-':\n        rval = a[1] - b[1]\n        rstr = \"(\" + a[0] + \"-\" + b[0] + \")\"\n    elif op == \"*\":\n        rval = a[1] * b[1]\n        rstr = \"(\" + a[0] + \"*\" + b[0] + \")\"\n    elif op == \"/\":\n        if b[1] == 0:\n            rval = -sqrt(3) #this value will be no use\n            rstr = \"(\" + a[0] + \"/\" + b[0] + \")\"\n        else:\n            rval = a[1] / b[1]\n            rstr = \"(\" + a[0] + \"/\" + b[0] + \")\"\n    return (rstr, rval)\n\n# Main function\ndef main_solution(numbers):\n    # Convert input list of numbers to list of tuples (str, int)\n    curList = [[(str(num), num) for num in numbers]]\n    opList = ['+', '-', '*', '/']\n    \n    for _ in range(3):\n        newList = []\n        for clist in curList:\n            perm = permutations(clist, 2)\n            for p in list(perm):\n                for op in opList:\n                    cclist = clist.copy()\n                    t = oprNum(p[0], p[1], op) \n                    cclist.remove(p[0])\n                    cclist.remove(p[1])\n                    newList.append([t, *cclist])\n        curList = newList.copy()\n    \n    # Find and return the operation string that results in 24\n    for item in curList:\n        if item[0][1] == 24:\n            return item[0][0]\n    \n    return \"No solution found\"", "input_generator": "import random\n\ndef input_generator():\n    # Generate a list of 4 numbers, which could potentially form 24 with some operations\n    # Common combinations that can form 24:\n    combinations = [\n        [1, 3, 4, 6],  # 6 / (1 - 3/4) = 24\n        [3, 3, 8, 8],  # 8 / (3 - 8/3) = 24\n        [4, 4, 4, 4],  # (4*4) + (4+4) = 24\n        [2, 3, 5, 7],  # (7 - (5 - 2)) * 3 = 24\n        [1, 5, 5, 5],  # (5 - 1/5) * 5 = 24\n        [6, 6, 6, 6],  # (6*6) - (6+6) = 24\n        [2, 2, 2, 6],  # (2 + 2 + 2) * 6 = 24\n        [1, 1, 1, 1],  # No solution\n        [1, 2, 3, 4],  # 1*2*3*4 = 24\n        [5, 5, 5, 1],  # 5*(5 - 1/5) = 24\n    ]\n    \n    # Randomly choose between a combination that can form 24 or a random one\n    if random.random() < 0.7:\n        numbers = random.choice(combinations)\n    else:\n        numbers = [random.randint(1, 10) for _ in range(4)]\n    \n    return {'numbers': numbers}", "io_pairs": [{"input": {"numbers": [1, 3, 4, 6]}, "output": "(6/(1-(3/4)))"}, {"input": {"numbers": [6, 6, 6, 6]}, "output": "(((6+6)+6)+6)"}, {"input": {"numbers": [5, 5, 5, 1]}, "output": "((5-(1/5))*5)"}, {"input": {"numbers": [1, 5, 5, 5]}, "output": "((5-(1/5))*5)"}, {"input": {"numbers": [4, 5, 5, 9]}, "output": "(((4*5)-5)+9)"}, {"input": {"numbers": [10, 8, 5, 8]}, "output": "((5-(10-8))*8)"}, {"input": {"numbers": [10, 6, 5, 7]}, "output": "No solution found"}, {"input": {"numbers": [3, 10, 2, 9]}, "output": "(((3+10)+2)+9)"}, {"input": {"numbers": [8, 8, 10, 3]}, "output": "(((8*10)-8)/3)"}, {"input": {"numbers": [1, 2, 3, 4]}, "output": "(((1+2)+3)*4)"}], "error_log": []}
{"context": "Given a specific encryption key and a piece of plaintext data, what is the resulting ciphertext when the data is encrypted using the RC4 algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `key` (str): A hexadecimal string representing the encryption key.\n  `plaintext` (str): A hexadecimal string representing the plaintext data to be encrypted.\n\nOutput:\n  `return` (str): A hexadecimal string representing the encrypted ciphertext.", "reference_code": "# import necessary packages\nimport codecs\n\nMOD = 256\n\ndef KSA(key):\n    ''' Key Scheduling Algorithm (from wikipedia):\n        for i from 0 to 255\n            S[i] := i\n        endfor\n        j := 0\n        for i from 0 to 255\n            j := (j + S[i] + key[i mod keylength]) mod 256\n            swap values of S[i] and S[j]\n        endfor\n    '''\n    key_length = len(key)\n    # create the array \"S\"\n    S = list(range(MOD))  # [0,1,2, ... , 255]\n    j = 0\n    for i in range(MOD):\n        j = (j + S[i] + key[i % key_length]) % MOD\n        S[i], S[j] = S[j], S[i]  # swap values\n    return S\n\n\ndef PRGA(S):\n    ''' Psudo Random Generation Algorithm (from wikipedia):\n        i := 0\n        j := 0\n        while GeneratingOutput:\n            i := (i + 1) mod 256\n            j := (j + S[i]) mod 256\n            swap values of S[i] and S[j]\n            K := S[(S[i] + S[j]) mod 256]\n            output K\n        endwhile\n    '''\n    i = 0\n    j = 0\n    while True:\n        i = (i + 1) % MOD\n        j = (j + S[i]) % MOD\n        S[i], S[j] = S[j], S[i]  # swap values\n        K = S[(S[i] + S[j]) % MOD]\n        yield K\n\n\ndef encrypt(key, in_data):\n    '''\n    Function to encrypt/decrypt data.\n\n    args\n        key: Encryption key as a byte string.\n        in_data: input data as a byte string.\n\n    return\n        out_data: output data as a byte string.\n    '''\n    keystream = PRGA(KSA(key))\n    out_data = b\"\"\n    for c in in_data:\n        out_data += (c^next(keystream)).to_bytes(1, 'little')\n    return out_data\n\n# main function\ndef main_solution(key, plaintext):\n    # Convert JSON serializable inputs to byte strings\n    key = codecs.decode(key, 'hex')\n    plaintext = codecs.decode(plaintext, 'hex')\n    \n    # Encrypt the plaintext\n    ciphertext = encrypt(key, plaintext)\n    \n    # Convert the ciphertext to a JSON serializable output\n    ciphertext_hex = codecs.encode(ciphertext, 'hex').decode('utf-8')\n    \n    return ciphertext_hex", "input_generator": "import random\nimport string\nimport codecs\n\ndef input_generator():\n    # Generate a random key (hex string)\n    key_length = random.randint(1, 32)  # Reasonable key length\n    key_bytes = bytes([random.randint(0, 255) for _ in range(key_length)])\n    key_hex = codecs.encode(key_bytes, 'hex').decode('utf-8')\n    \n    # Generate random plaintext (hex string)\n    plaintext_length = random.randint(1, 64)  # Reasonable plaintext length\n    plaintext_bytes = bytes([random.randint(0, 255) for _ in range(plaintext_length)])\n    plaintext_hex = codecs.encode(plaintext_bytes, 'hex').decode('utf-8')\n    \n    return {'key': key_hex, 'plaintext': plaintext_hex}", "io_pairs": [{"input": {"key": "671c03e027e3b72948ab20", "plaintext": "d4ddf661fb7e0364048c88ee852881"}, "output": "8129c154d2a0a6ce0edefd605379ff"}, {"input": {"key": "fac771150999c691344e", "plaintext": "d5de9b148916b7dea398619b2115adb3413cabbf47c53820a3ac48aedfecc7f3e6"}, "output": "b1a7d3d409e7d9109ac9f8f1ae8a3640b84cf1673148e4180ed10a9ab6de72a24d"}, {"input": {"key": "e2b8cef7a01d72bedf51fc5eda83fc67d871d3d97d02", "plaintext": "d8044253f6769208cb3899e021e65470205e2a5806284585"}, "output": "63b7dc5e0a2f39de96548c3a6c21681adcae82bb8095b929"}, {"input": {"key": "f0cef12720ca1f9d3ddeba2548dcc06949f46281734bca", "plaintext": "370144d15709c60fa9aaff80da3c384fd5fcce8ce07d0c2f3007df6af281"}, "output": "0920806db2cac47f8d22f2b09971816a6230d50a22640799f9a336b32038"}, {"input": {"key": "ba73142298656553860021dc3d7a4c7b7f0170a94c5c4b", "plaintext": "11f45d673f6e51084b92226499b811ff68de"}, "output": "ea5adedc12caf4e7f554b0cfd11dc9f3c4f5"}, {"input": {"key": "d80d5bfb6591cddbabe13a983f2332304dea5a72", "plaintext": "dc67007aa4ed86873c936b8e88c6dabe372a38c8ba62a7ab"}, "output": "c00ea6006a6ba800b4095a2d1340b42e30202e4e911ca40c"}, {"input": {"key": "03a945a18865a0efdf6a7ef8f98f", "plaintext": "532529818fa09e04c2b3b44c9e538359c336cf7a560a7b24edc92447b29c71dd28"}, "output": "93ba2e97e71725e43cd014263518f22d684aa49d158717717ab59c848ed8322e0f"}, {"input": {"key": "58846e3d8c06291ac0864430553f", "plaintext": "27d1bbf24db73db88f950eaba2fc9cb6b4d94e5b52af"}, "output": "0cd871ed9130bf2acac1f178537f4a26f3a83793a69c"}, {"input": {"key": "8931f9af74e460a74fd93dd6c88004897b615697936c10d0f00c59", "plaintext": "bc3fc5b298d1651ad9ec3807edb9eb98b6b3ef"}, "output": "5f10a8e9e46903744140c87924d31242ed3032"}, {"input": {"key": "a968120f143391", "plaintext": "e2cd8a350a4c749e0a452b6437a1279e62a375ebe75891158d53df"}, "output": "4d69372818671f025a6285941e4c0facc152d816a9c67b78541be4"}], "error_log": []}
{"context": "Given a chessboard of size `n x n`, where `n` is an integer, and a maximum number of iterations `max_iterations`, how many steps does it take for a stochastic hill climbing algorithm to either find a solution where no queens can attack each other or determine that no solution exists within the given iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the board (n x n).\n  `max_iterations` (int): The maximum number of iterations for the stochastic hill climbing algorithm.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `steps` (int): The number of steps taken to reach the solution or fail.\n    - `success` (bool): A boolean indicating whether the solution was found (`True`) or not (`False`).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef generate_random_board(n):\n    '''Generates a random board for initialization, queens have been calculated row-wise'''\n    generated_board = []\n    for i in range(n):\n        j = random.randint(0, n-1)\n        row = [0]*n\n        row[j] = 1\n        generated_board.extend(row)\n    return generated_board\n\ndef determine_h_cost(board, n):\n    ''' Function to determine heuristic - total collisions on the board '''\n    collisions, _ = find_collisions(board, n)\n    # return half the collisions, since each colliding position is counted twice from the helper function\n    return int(collisions/2)\n\ndef find_collisions(board, n):\n    ''' Helper function for calculating queen position collisions '''\n    collisions = 0\n    max_index = len(board)\n    for i in range(max_index):\n        if board[i] == 1:\n            for x in range(1, n):\n                if (i - n*x >= 0):\n                    north = i - n*x\n                    if (board[north] == 1):\n                        collisions += 1\n                    if (int((north - x)/n) == int(north/n)) and (north - x) >= 0:\n                        northwest = north - x\n                        if (board[northwest] == 1):\n                            collisions += 1\n                    if (int((north + x)/n) == int(north/n)):\n                        northeast = north + x\n                        if (board[northeast] == 1):\n                            collisions += 1\n                if (i + n*x < max_index):\n                    south = i + n*x\n                    if (board[south] == 1):\n                        collisions += 1\n                    if (int((south - x)/n) == int(south/n)):\n                        southwest = south - x\n                        if (board[southwest] == 1):\n                            collisions += 1\n                    if (int((south + x)/n) == int(south/n)) and ((south + x) < max_index):\n                        southeast = south + x\n                        if (board[southeast] == 1):\n                            collisions += 1\n                if (int((i - x)/n) == int(i/n)) and (i - x >= 0):\n                    west = i - x\n                    if (board[west] == 1):\n                        collisions += 1\n                if (int((i + x)/n) == int(i/n)) and (i + x < max_index):\n                    east = i + x\n                    if (board[east] == 1):\n                        collisions += 1\n    return [collisions, []]\n\ndef find_child(board, n):\n    ''' Function to find the successor from all the children by comparing the heuristic values of moving the queens row-wise '''\n    child = []\n    current_h_cost = determine_h_cost(board, n)\n    same_cost_children = []\n\n    for row in range(n):\n        for col in range(n):\n            temp_board = []\n            temp_board.extend(board[:row*n])\n            new_row = [0]*n\n            new_row[col] = 1\n            temp_board.extend(new_row)\n            temp_board.extend(board[(row+1)*n:])\n            temp_h_cost = determine_h_cost(temp_board, n)\n            if (temp_board != board):\n                if (temp_h_cost != current_h_cost):\n                    child = temp_board.copy()\n                    current_h_cost = (temp_h_cost)\n                elif (temp_h_cost == current_h_cost):\n                    same_cost_children.append(temp_board)\n                    x = random.randint(0, len(same_cost_children)-1)\n                    child = same_cost_children[x]\n    return child\n\ndef stochastic_hill_climbing(board, n, max_iterations=10):\n    ''' Steepest Hill climbing algorithm, returns the current steps and whether the run succeeded or not '''\n    steps = 0\n    success = False\n    current_board = board.copy()\n\n    for i in range(max_iterations):\n        next_node = find_child(current_board, n).copy()\n        steps += 1\n        if (len(next_node) != 0) and (determine_h_cost(next_node, n) == 0):\n            success = True\n            break\n        if (len(next_node) == 0):\n            break\n        current_board = next_node.copy()\n    return steps, success\n\n# main function\ndef main_solution(n, max_iterations):\n    # Convert input to appropriate types if necessary\n    n = int(n)\n    max_iterations = int(max_iterations)\n    \n    # Generate a random board and run the stochastic hill climbing algorithm\n    board = generate_random_board(n)\n    steps, success = stochastic_hill_climbing(board, n, max_iterations)\n    \n    # Return the result as a dictionary\n    return {\n        \"steps\": steps,\n        \"success\": success\n    }", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(4, 10)  # Reasonable board size between 4x4 and 10x10\n    max_iterations = random.randint(5, 20)  # Reasonable iterations between 5 and 20\n    return {\n        \"n\": n,\n        \"max_iterations\": max_iterations\n    }", "io_pairs": [{"input": {"n": 6, "max_iterations": 19}, "output": {"steps": 19, "success": false}}, {"input": {"n": 8, "max_iterations": 17}, "output": {"steps": 17, "success": false}}, {"input": {"n": 4, "max_iterations": 16}, "output": {"steps": 16, "success": false}}, {"input": {"n": 8, "max_iterations": 20}, "output": {"steps": 20, "success": false}}, {"input": {"n": 6, "max_iterations": 12}, "output": {"steps": 12, "success": false}}, {"input": {"n": 8, "max_iterations": 10}, "output": {"steps": 10, "success": false}}, {"input": {"n": 9, "max_iterations": 13}, "output": {"steps": 13, "success": false}}, {"input": {"n": 9, "max_iterations": 17}, "output": {"steps": 17, "success": false}}, {"input": {"n": 5, "max_iterations": 16}, "output": {"steps": 16, "success": false}}, {"input": {"n": 4, "max_iterations": 17}, "output": {"steps": 17, "success": false}}], "error_log": []}
{"context": "Given a range of possible values for the multiplicand (m) and the multiplier (n), what is the sum of all unique products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital?\n\nThe input and output requirements are as follows:\n\nInput:\n  `min_m` (int): The minimum value for the multiplicand (m).\n  `max_m` (int): The maximum value for the multiplicand (m).\n  `min_n` (int): The minimum value for the multiplier (n).\n  `max_n` (int): The maximum value for the multiplier (n).\n\nOutput:\n  `return` (int): The sum of all unique products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef has_zero(num):\n    for d in str(num):\n        if d == '0':\n            return True\n    return False\n\ndef is_pandigital(m, n, product):\n    digit = set(['1','2','3','4','5','6','7','8','9'])\n    test = set(str(m) + str(n) + str(product))\n    return sorted(digit) == sorted(test)\n\ndef has_length_9(m, n, product):\n    length = len(str(m)) + len(str(n)) + len(str(product))\n    return 9 == length\n\n# main function\ndef main_solution(min_m, max_m, min_n, max_n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    pandigital = []\n    for m in range(min_m, max_m + 1):\n        if has_zero(m):\n            continue\n        for n in range(min_n, max_n + 1):\n            if has_zero(n):\n                continue\n            product = m * n\n            if has_length_9(m, n, product) and is_pandigital(m, n, product):\n                pandigital.append(product)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sum(set(pandigital))", "input_generator": "import random\n\ndef input_generator():\n    # Generate reasonable ranges for m and n\n    # The product of m and n, combined with m and n, should form a 9-digit pandigital number\n    # So possible ranges are limited to ensure the total digits are 9\n    \n    # Randomly choose between different possible digit splits:\n    # e.g., m is 2 digits, n is 3 digits, product is 4 digits (2+3+4=9)\n    # or m is 1 digit, n is 4 digits, product is 4 digits (1+4+4=9)\n    split_options = [\n        (2, 3),  # m: 2 digits, n: 3 digits\n        (1, 4),   # m: 1 digit, n: 4 digits\n        (3, 2),   # m: 3 digits, n: 2 digits\n        (4, 1)    # m: 4 digits, n: 1 digit\n    ]\n    m_digits, n_digits = random.choice(split_options)\n    \n    # Generate min and max for m and n based on digit counts\n    min_m = 10 ** (m_digits - 1)\n    max_m = (10 ** m_digits) - 1\n    min_n = 10 ** (n_digits - 1)\n    max_n = (10 ** n_digits) - 1\n    \n    # Ensure no zeros in the ranges by adjusting if necessary\n    # For example, if min_m is 100, max_m is 999 (3 digits), but we can skip zeros in the main_solution\n    return {\n        'min_m': min_m,\n        'max_m': max_m,\n        'min_n': min_n,\n        'max_n': max_n\n    }", "io_pairs": [{"input": {"min_m": 1, "max_m": 9, "min_n": 1000, "max_n": 9999}, "output": 14804}, {"input": {"min_m": 1000, "max_m": 9999, "min_n": 1, "max_n": 9}, "output": 14804}, {"input": {"min_m": 10, "max_m": 99, "min_n": 100, "max_n": 999}, "output": 30424}, {"input": {"min_m": 100, "max_m": 999, "min_n": 10, "max_n": 99}, "output": 30424}], "error_log": []}
{"context": "Given a list of random positive integers, what are the fractions no greater than 1 that can be built from the list, sorted from smallest to largest, and which fraction(s) are closest to 1/2?\n\nThe input and output requirements are as follows:\n\nInput:\n- `arg_for_seed` (int): A seed value for the random number generator.\n- `length` (int): The length of the list `L` to be generated.\n- `max_value` (int): The maximum value for the integers in the list `L`.\n\nOutput:\n- `return` (dict): A dictionary containing the following keys:\n  - `fractions` (list of str): A list of strings representing fractions in the form 'a/b' or '0' or '1', sorted from smallest to largest.\n  - `spot_on` (str or None): A string '1/2' if '1/2' is in the `fractions` list, otherwise `None`.\n  - `closest_1` (str or None): The fraction closest to '1/2' if it is unique, otherwise `None`.\n  - `closest_2` (str or None): The second fraction closest to '1/2' if there are two equally close fractions, otherwise `None`.", "reference_code": "# import necessary packages\nimport random\nfrom math import gcd\nfrom fractions import Fraction\n\n# main function\ndef main_solution(arg_for_seed, length, max_value):\n    # Convert inputs to the required types\n    arg_for_seed = int(arg_for_seed)\n    length = int(length)\n    max_value = int(max_value)\n    \n    # Seed the random number generator\n    random.seed(arg_for_seed)\n    \n    # Generate the list L of random positive integers\n    L = [random.randint(0, max_value) for _ in range(length)]\n    \n    # Ensure at least one strictly positive number is in L\n    if not any(e > 0 for e in L):\n        L[0] = random.randint(1, max_value)\n    \n    fractions = []\n    num = []\n    spot_on, closest_1, closest_2 = [None] * 3\n    \n    # Generate fractions from the list L\n    L.sort()\n    for i in range(len(L)):\n        for j in range(i + 1, len(L)):\n            a = L[i]\n            b = L[j]\n            if b != 0:\n                c = gcd(a, b)\n                fraction = Fraction(a, b)\n                if fraction not in num:\n                    if fraction == 0:\n                        fractions.append('0')\n                        num.append(0)\n                    elif fraction == 1:\n                        fractions.append('1')\n                        num.append(1)\n                    else:\n                        fractions.append(f\"{a // c}/{b // c}\")\n                        num.append(fraction)\n    \n    # Ensure '1' is in fractions\n    if '1' not in fractions:\n        fractions.append('1')\n    \n    # Sort fractions by their value\n    fractions.sort(key=lambda x: Fraction(x))\n    \n    # Check for the closest fraction to 1/2\n    if '1/2' in fractions:\n        spot_on = '1/2'\n    else:\n        dis = 1\n        for x in fractions:\n            if abs(Fraction(0.5) - Fraction(x)) < dis:\n                dis = abs(Fraction(0.5) - Fraction(x))\n                closest_1 = x\n                closest_2 = None\n            elif abs(Fraction(0.5) - Fraction(x)) == dis:\n                closest_2 = x\n    \n    # Prepare the output\n    result = {\n        'fractions': fractions,\n        'spot_on': spot_on,\n        'closest_1': closest_1,\n        'closest_2': closest_2\n    }\n    \n    return result", "input_generator": "import random\n\ndef input_generator():\n    arg_for_seed = random.randint(0, 1000)\n    length = random.randint(5, 20)\n    max_value = random.randint(10, 100)\n    return {\n        'arg_for_seed': arg_for_seed,\n        'length': length,\n        'max_value': max_value\n    }", "io_pairs": [{"input": {"arg_for_seed": 612, "length": 5, "max_value": 64}, "output": {"fractions": ["4/15", "3/7", "4/9", "3/5", "28/45", "27/28", "1"], "spot_on": null, "closest_1": "4/9", "closest_2": null}}, {"input": {"arg_for_seed": 987, "length": 8, "max_value": 11}, "output": {"fractions": ["0", "2/5", "1/2", "4/5", "1"], "spot_on": "1/2", "closest_1": null, "closest_2": null}}, {"input": {"arg_for_seed": 580, "length": 5, "max_value": 58}, "output": {"fractions": ["5/53", "5/33", "5/18", "18/53", "6/11", "33/53", "1"], "spot_on": null, "closest_1": "6/11", "closest_2": null}}, {"input": {"arg_for_seed": 375, "length": 5, "max_value": 23}, "output": {"fractions": ["7/22", "1/2", "7/13", "13/22", "7/11", "11/13", "1"], "spot_on": "1/2", "closest_1": null, "closest_2": null}}, {"input": {"arg_for_seed": 281, "length": 6, "max_value": 30}, "output": {"fractions": ["0", "3/14", "1/3", "3/8", "4/7", "9/14", "8/9", "1"], "spot_on": null, "closest_1": "4/7", "closest_2": null}}, {"input": {"arg_for_seed": 157, "length": 6, "max_value": 20}, "output": {"fractions": ["0", "5/19", "1/3", "7/19", "7/15", "5/7", "15/19", "1"], "spot_on": null, "closest_1": "7/15", "closest_2": null}}, {"input": {"arg_for_seed": 51, "length": 5, "max_value": 12}, "output": {"fractions": ["1/4", "3/8", "2/3", "1"], "spot_on": null, "closest_1": "3/8", "closest_2": null}}, {"input": {"arg_for_seed": 377, "length": 6, "max_value": 20}, "output": {"fractions": ["0", "1/8", "3/16", "2/7", "3/7", "7/16", "2/3", "1"], "spot_on": null, "closest_1": "7/16", "closest_2": null}}, {"input": {"arg_for_seed": 485, "length": 5, "max_value": 17}, "output": {"fractions": ["4/15", "1/3", "2/5", "1/2", "2/3", "4/5", "1"], "spot_on": "1/2", "closest_1": null, "closest_2": null}}, {"input": {"arg_for_seed": 146, "length": 5, "max_value": 98}, "output": {"fractions": ["17/98", "17/79", "17/42", "3/7", "42/79", "79/98", "1"], "spot_on": null, "closest_1": "42/79", "closest_2": null}}], "error_log": []}
{"context": "Given a mathematical function that involves exponential and polynomial terms, how can we find the root of this function using a numerical method, starting from a given initial guess? Specifically, what is the root of the function when using the Eiler method with an initial guess of `initial_x`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_x` (float): The initial guess for the starting point of the Eiler method. This value is used to determine the starting point for the numerical method.\n\nOutput:\n  `return` (float): The root of the function `func` found using the Eiler method, represented as a float.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# Constants\nA = 9\nB = 5\nC = 2001 + 5 * 3\nh = 0.00001\n\n# Function definitions\ny = lambda x: np.exp(C / x)\ndy = lambda x: (y(x + h) - y(x - h)) / (2 * h)\n\ndef func(x):\n    try:\n        if x < 0:\n            x = -x\n            return -sum([x ** (i / A) for i in range(A + 1)]) - (x * B) ** (1 / 5) + y(x)\n        if x > 0:\n            return sum([x ** (i / A) for i in range(A + 1)]) + (x * B) ** (1 / 5) + y(x)\n    except ZeroDivisionError:\n        return 0\n\ndef start_x():\n    x = 9\n    while abs(dy(x)) > 10**-4: x += 1\n    return x\n\ndef Eiler(x0):\n    eps = 10 ** -5\n    h = 0.01\n    if func(x0) > func(x0 - h * func(x0)):\n        while abs(func(x0)) > eps:\n            x1 = x0 - h * func(x0)\n            x0 = x1\n    else:\n        while abs(func(x0)) > eps:\n            x1 = x0 + h * func(x0)\n            x0 = x1\n    return x0\n\n# main function\ndef main_solution(initial_x):\n    # Convert input to float if necessary\n    initial_x = float(initial_x)\n    \n    # Find the starting point\n    start = start_x()\n    \n    # Apply the Eiler method\n    result = Eiler(start)\n    \n    # Return the result as a float\n    return float(result)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random initial_x within a reasonable range\n    initial_x = random.uniform(-10.0, 10.0)\n    \n    return {'initial_x': initial_x}", "io_pairs": [{"input": {"initial_x": -4.754127307451812}, "output": -310.4028432379205}, {"input": {"initial_x": 9.295316490498937}, "output": -310.4028432379205}, {"input": {"initial_x": 0.090312346619152}, "output": -310.4028432379205}, {"input": {"initial_x": 6.64055488313387}, "output": -310.4028432379205}, {"input": {"initial_x": 0.36174323469131764}, "output": -310.4028432379205}, {"input": {"initial_x": -3.361949773791002}, "output": -310.4028432379205}, {"input": {"initial_x": -5.365266981282726}, "output": -310.4028432379205}, {"input": {"initial_x": 7.472834355068002}, "output": -310.4028432379205}, {"input": {"initial_x": 1.767102809689277}, "output": -310.4028432379205}, {"input": {"initial_x": -1.3677792933174988}, "output": -310.4028432379205}], "error_log": []}
{"context": "Given a system of linear equations represented by a coefficient matrix `matrix_a` and a constant vector `vector_b`, what is the solution vector that satisfies the system of equations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_a` (list of lists of floats): A square matrix representing the coefficients of the linear equations.\n  `vector_b` (list of floats): A vector representing the constants of the linear equations.\n\nOutput:\n  `return` (list of floats): A vector representing the solution to the system of linear equations.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Equation:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\nclass Position:\n    def __init__(self, column, row):\n        self.column = column\n        self.row = row\n\ndef SelectPivotElement(a, used_rows, used_columns):\n    pivot_element = Position(0, 0)\n    while used_rows[pivot_element.row]:\n        pivot_element.row += 1\n    while used_columns[pivot_element.column]:\n        pivot_element.column += 1\n    return pivot_element\n\ndef SwapLines(a, b, used_rows, pivot_element):\n    pe = pivot_element\n    if a[pe.row][pe.column] == 0:\n        for i in range(pe.row + 1, len(a)):\n            if a[i][pe.column] != 0:\n                pivot_element.row = i\n                break\n    a[pivot_element.column], a[pivot_element.row] = a[pivot_element.row], a[pivot_element.column]\n    b[pivot_element.column], b[pivot_element.row] = b[pivot_element.row], b[pivot_element.column]\n    used_rows[pivot_element.column], used_rows[pivot_element.row] = used_rows[pivot_element.row], used_rows[pivot_element.column]\n    pivot_element.row = pivot_element.column\n    return (a, b)\n\ndef scale(a, b, pivot_element):\n    pe = pivot_element\n    peval = a[pe.row][pe.column]\n    if peval == 1:\n        return (a, b)\n    for i in range(len(a[pe.row])):\n        a[pe.row][i] /= peval\n    b[pe.row] /= peval\n    return (a, b)\n\ndef zero(a, b, pivot_element):\n    pe = pivot_element\n    peval = a[pe.row][pe.column]\n    if peval != 1:\n        return (a, b)\n    for i in range(pe.row + 1, len(a)):\n        val = a[i][pe.column]\n        x = 0 - val\n        for j in range(pe.column, len(a)):\n            a[i][j] += a[pe.row][j] * x\n        b[i] += b[pe.row] * x\n    return (a, b)\n\ndef ProcessPivotElement(a, b, pivot_element):\n    (a, b) = scale(a, b, pivot_element)\n    (a, b) = zero(a, b, pivot_element)\n\ndef MarkPivotElementUsed(pivot_element, used_rows, used_columns):\n    used_rows[pivot_element.row] = True\n    used_columns[pivot_element.column] = True\n\ndef SolveEquation(equation):\n    a = equation.a\n    b = equation.b\n    size = len(a)\n    used_columns = [False] * size\n    used_rows = [False] * size\n    for step in range(size):\n        pivot_element = SelectPivotElement(a, used_rows, used_columns)\n        (a, b) = SwapLines(a, b, used_rows, pivot_element)\n        ProcessPivotElement(a, b, pivot_element)\n        MarkPivotElementUsed(pivot_element, used_rows, used_columns)\n    for i in reversed(range(size - 1)):\n        leftsum = 0\n        for j in range(i + 1, len(a)):\n            leftsum += a[i][j] * b[j]\n        b[i] -= leftsum\n    return b\n\n# main function\ndef main_solution(matrix_a, vector_b):\n    # Convert JSON serializable inputs to original input variables\n    equation = Equation(matrix_a, vector_b)\n    # Solve the equation\n    solution = SolveEquation(equation)\n    # Convert the solution to JSON serializable output\n    return solution", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    size = random.randint(2, 5)\n    matrix_a = np.random.randint(-10, 10, size=(size, size)).tolist()\n    vector_b = np.random.randint(-10, 10, size=size).tolist()\n    return {'matrix_a': matrix_a, 'vector_b': vector_b}", "io_pairs": [{"input": {"matrix_a": [[1.0, -0.5], [0.0, 1.0]], "vector_b": [-0.47619047619047616, -0.9523809523809523]}, "output": [-0.47619047619047616, -0.9523809523809523]}, {"input": {"matrix_a": [[1, -4, -2], [-0.0, 1.0, -1.0], [0.0, 0.0, 1.0]], "vector_b": [0.9212121212121218, 0.37575757575757596, -4.290909090909091]}, "output": [0.9212121212121218, 0.37575757575757596, -4.290909090909091]}, {"input": {"matrix_a": [[1.0, -0.25], [0.0, 1.0]], "vector_b": [-0.875, 0.5]}, "output": [-0.875, 0.5]}, {"input": {"matrix_a": [[1.0, -1.25], [-0.0, 1.0]], "vector_b": [0.5405405405405403, 2.4324324324324325]}, "output": [0.5405405405405403, 2.4324324324324325]}, {"input": {"matrix_a": [[1.0, 3.5], [-0.0, 1.0]], "vector_b": [-0.0, -0.0]}, "output": [-0.0, -0.0]}, {"input": {"matrix_a": [[1.0, -0.5], [-0.0, 1.0]], "vector_b": [-0.6666666666666666, -1.6666666666666665]}, "output": [-0.6666666666666666, -1.6666666666666665]}, {"input": {"matrix_a": [[1.0, -1.0], [0.0, 1.0]], "vector_b": [2.5, 1.0]}, "output": [2.5, 1.0]}, {"input": {"matrix_a": [[1.0, 8.0], [0.0, 1.0]], "vector_b": [2.3793103448275863, 0.8275862068965517]}, "output": [2.3793103448275863, 0.8275862068965517]}, {"input": {"matrix_a": [[1.0, 6.0], [0.0, 1.0]], "vector_b": [-5.307692307692307, 1.3846153846153846]}, "output": [-5.307692307692307, 1.3846153846153846]}, {"input": {"matrix_a": [[1.0, 1.4285714285714286], [0.0, 1.0]], "vector_b": [-0.38095238095238093, 1.1666666666666667]}, "output": [-0.38095238095238093, 1.1666666666666667]}], "error_log": []}
{"context": "Given a message represented by a single uppercase letter, a prime number `p`, a generator `g`, and a private key `d`, how can we generate a digital signature using the ElGamal signature scheme? Specifically, what are the values of the public key component `e`, the random number `r`, the multiplicative inverse of `r` modulo \\( p-1 \\), the message identifier `rho`, and the signature element `s`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p` (int): A prime number used in the ElGamal signature scheme.\n  `g` (int): A generator in the ElGamal signature scheme.\n  `m` (str): A single uppercase letter representing the message to be signed.\n  `d` (int): The private key used in the ElGamal signature scheme.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `p` (int): The prime number used.\n    - `g` (int): The generator used.\n    - `m` (str): The message letter.\n    - `d` (int): The private key used.\n    - `e` (int): The public key component calculated as \\( g^d \\mod p \\).\n    - `r` (int): A random number used in the signature process.\n    - `mir` (int): The multiplicative inverse of `r` modulo \\( p-1 \\).\n    - `rho` (int): The message identifier calculated as \\( g^r \\mod p \\).\n    - `s` (int): The signature element calculated as \\( (m - d \\cdot \\rho) \\cdot mir \\mod (p-1) \\).", "reference_code": "# import necessary packages\nimport sys\nimport platform\nfrom random import randint\n\n# all class and function definitions in the code file, if any\ndef is_prime(num, test_count):\n    if num == 1:\n        return False\n    if test_count >= num:\n        test_count = num - 1\n    for x in range(test_count):\n        val = randint(1, num - 1)\n        if pow(val, num-1, num) != 1:\n            return False\n    return True\n\ndef generate_big_prime(n):\n    found_prime = False\n    while not found_prime:\n        p = randint(2**(n-1), 2**n)\n        if is_prime(p, 1000):\n            return p\n\ndef ggT(k, n):\n    while k > 0 and n > 0:\n        if k >= n:\n            k = k - n\n        else:\n            n = n - k\n    return k+n\n\ndef ExtGCD(x, y):\n    m,n=x,y\n    b,d=0,1\n    p,t=1,0\n    \n    while (m!=0):\n        q = n//m  # yes, //\n        n,m=m,n-q*m\n        d,b=b,d-q*b\n        t,p=p,t-q*p\n    \n    return d\n\n# main function\ndef main_solution(p, g, m, d):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    alphabet = {0:'A', 1:'B', 2:'C', 3:'D', 4:'E', 5:'F', 6:'G', 7:'H', 8:'I', 9:'J', 10:'K', 11:'L', 12:'M', 13:'N', 14:'O', 15:'P', 16:'Q', 17:'R', 18:'S', 19:'T', 20:'U', 21:'V', 22:'W', 23:'X', 24:'Y', 25:'Z'}\n    \n    key = int(list(alphabet.keys())[list(alphabet.values()).index(m)])\n    \n    e = g**d % p\n    \n    ggTCheck = 0\n    \n    while ggTCheck != 1:\n        r = randint(1, p-1)\n        ggTCheck = ggT(r, p-1)\n        \n    mir = ExtGCD(p-1, r)\n    if mir < 0:\n        mir = (p-1) + mir\n    \n    rho = g**r % p\n    \n    s = ((key - (d * rho)) * mir) % (p-1)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"p\": p, \"g\": g, \"m\": m, \"d\": d, \"e\": e, \"r\": r, \"mir\": mir, \"rho\": rho, \"s\": s}", "input_generator": "import random\nfrom random import randint\n\ndef input_generator():\n    alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n    \n    # Generate a random prime p between 2^5 and 2^8 to keep it reasonable\n    p = randint(2**5, 2**8)\n    while not is_prime(p, 100):\n        p = randint(2**5, 2**8)\n    \n    # Generate a random generator g (1 < g < p)\n    g = randint(2, p-1)\n    \n    # Randomly select a message m from the alphabet\n    m = random.choice(alphabet)\n    \n    # Generate a random private key d (1 < d < p-1)\n    d = randint(2, p-2)\n    \n    return {\"p\": p, \"g\": g, \"m\": m, \"d\": d}", "io_pairs": [{"input": {"p": 41, "g": 25, "m": "E", "d": 39}, "output": {"p": 41, "g": 25, "m": "E", "d": 39, "e": 23, "r": 29, "mir": 29, "rho": 23, "s": 23}}, {"input": {"p": 43, "g": 23, "m": "T", "d": 33}, "output": {"p": 43, "g": 23, "m": "T", "d": 33, "e": 16, "r": 1, "mir": 1, "rho": 23, "s": 16}}, {"input": {"p": 43, "g": 6, "m": "Q", "d": 4}, "output": {"p": 43, "g": 6, "m": "Q", "d": 4, "e": 6, "r": 13, "mir": 13, "rho": 6, "s": 22}}, {"input": {"p": 73, "g": 55, "m": "T", "d": 53}, "output": {"p": 73, "g": 55, "m": "T", "d": 53, "e": 4, "r": 53, "mir": 53, "rho": 4, "s": 67}}, {"input": {"p": 67, "g": 29, "m": "E", "d": 13}, "output": {"p": 67, "g": 29, "m": "E", "d": 13, "e": 29, "r": 19, "mir": 7, "rho": 29, "s": 29}}, {"input": {"p": 73, "g": 8, "m": "S", "d": 64}, "output": {"p": 73, "g": 8, "m": "S", "d": 64, "e": 8, "r": 35, "mir": 35, "rho": 64, "s": 46}}, {"input": {"p": 251, "g": 149, "m": "N", "d": 241}, "output": {"p": 251, "g": 149, "m": "N", "d": 241, "e": 149, "r": 1, "mir": 1, "rho": 149, "s": 104}}], "error_log": []}
{"context": "Given a string of characters, what are all the possible unique permutations of the string, sorted in dictionary order?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string of characters for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string, sorted in dictionary order.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all permutations of the characters\n    permutations = list(itertools.permutations(char_list))\n    \n    # Convert each permutation tuple to a string\n    result = [''.join(perm) for perm in permutations]\n    \n    # Sort the result list to ensure dictionary order\n    result.sort()\n    \n    # Return the sorted list of permutations\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    input_string = ''.join(random.sample(string.ascii_lowercase, length))\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "lc"}, "output": ["cl", "lc"]}, {"input": {"input_string": "ig"}, "output": ["gi", "ig"]}, {"input": {"input_string": "xuz"}, "output": ["uxz", "uzx", "xuz", "xzu", "zux", "zxu"]}, {"input": {"input_string": "grd"}, "output": ["dgr", "drg", "gdr", "grd", "rdg", "rgd"]}, {"input": {"input_string": "jq"}, "output": ["jq", "qj"]}, {"input": {"input_string": "o"}, "output": ["o"]}, {"input": {"input_string": "vo"}, "output": ["ov", "vo"]}, {"input": {"input_string": "hwd"}, "output": ["dhw", "dwh", "hdw", "hwd", "wdh", "whd"]}, {"input": {"input_string": "ny"}, "output": ["ny", "yn"]}, {"input": {"input_string": "zdf"}, "output": ["dfz", "dzf", "fdz", "fzd", "zdf", "zfd"]}], "error_log": []}
{"context": "Given a starting index for generating triangle numbers, what is the first triangle number that is both pentagonal and hexagonal, starting from that index?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start_index` (int): The starting index for generating triangle numbers. It should be an integer greater than or equal to 286.\n\nOutput:\n  `return` (str): The first triangle number starting from the given index that is both pentagonal and hexagonal, returned as a string.", "reference_code": "# import necessary packages\nimport time\nfrom math import sqrt\n\n# Function to check if a number is both pentagonal and hexagonal\ndef is_pent_hex(P):\n    return (1 + sqrt(1 + 24 * P)) % 6 == 0 and (1 + sqrt(1 + 8 * P)) % 4 == 0\n\n# main function\ndef main_solution(start_index):\n    # Convert the input to an integer if it's not already\n    start_index = int(start_index)\n    \n    flag = True\n    i = start_index\n    while flag:\n        # Find the triangle number\n        T = i * (i + 1) // 2\n        # Check if it is both pentagonal and hexagonal\n        if is_pent_hex(T):\n            # Return the triangle number as a string (JSON serializable)\n            return str(T)\n        i += 1", "input_generator": "import random\n\ndef input_generator():\n    return {'start_index': random.randint(1, 10000)}", "io_pairs": [{"input": {"start_index": 7347}, "output": "1533776805"}, {"input": {"start_index": 1278}, "output": "1533776805"}, {"input": {"start_index": 5548}, "output": "1533776805"}, {"input": {"start_index": 411}, "output": "1533776805"}, {"input": {"start_index": 6968}, "output": "1533776805"}, {"input": {"start_index": 7529}, "output": "1533776805"}, {"input": {"start_index": 6930}, "output": "1533776805"}, {"input": {"start_index": 8550}, "output": "1533776805"}, {"input": {"start_index": 668}, "output": "1533776805"}, {"input": {"start_index": 1120}, "output": "1533776805"}], "error_log": []}
{"context": "Given a set of train routes between various cities, each route specifying the departure and arrival times and the price, what is the cheapest route from a specified starting city to a specified destination city, starting at a given time?\n\nThe input and output requirements are as follows:\n\nInput:\n  `city_data` (list of strings): Each string represents a train route in the format \"start_city end_city price departure_time arrival_time\".\n  `start_city` (int): The starting city number.\n  `end_city` (int): The destination city number.\n  `start_time` (string): The starting time in \"HH:MM\" format.\n\nOutput:\n  `return` (int): The cheapest price of the route from `start_city` to `end_city` starting at `start_time`. If no route is found, returns -1.", "reference_code": "# import necessary packages\nimport random\nimport copy\n\n# all class and function definitions in the code file, if any\nclass train:\n    def __init__(self, x, y, price, xtime, ytime):\n        self.x = x\n        self.y = y\n        self.price = price\n        self.xtime = xtime\n        self.ytime = ytime\n\nclass city:\n    def __init__(self, num):\n        self.num = num\n        self.next = []\n        self.trains = []\n\n    def addTrain(self, c):\n        self.trains.append(c)\n        if c.y not in self.next:\n            self.next.append(c.y)\n\n    def getCityTrain(self, c, time):\n        result = []\n        if c in self.next:\n            for i in self.trains:\n                if i.y == c and timebigger(i.xtime, time):\n                    result.append(i)\n        return result\n\nclass path:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.citylist = []\n        self.trainlist = []\n\nclass cityGraph:\n    def __init__(self):\n        self.citys = []\n        self.cityids = []\n        self.d = {}\n        self.ids = {}\n        self.addCity(1)\n\n    def addCity(self, num):\n        startCity = city(num)\n        self.citys.append(startCity)\n        self.cityids.append(startCity.num)\n        self.ids[str(num)] = startCity\n        return startCity\n\n    def getCity(self, num):\n        if num not in self.cityids:\n            ct = self.addCity(num)\n            return ct\n        else:\n            return self.ids[str(num)]\n\n    def cityFromLine(self, line):\n        spl = line.split(\" \")\n        startCity = self.getCity(int(spl[0]))\n        endCity = self.getCity(int(spl[1]))\n        newtrain = train(startCity, endCity, int(spl[2]), spl[3], spl[4])\n        startCity.addTrain(newtrain)\n\n    def searchPath(self, start, end, time):\n        result = path(start, end)\n        key = \"_\".join([str(start.num), str(end.num), time])\n        if key in self.d.keys():\n            return self.d[key]\n        if len(start.next) == 0:\n            return result\n        ncity = []\n        ntrain = []\n        if end in start.next:\n            xtrain = start.getCityTrain(end, time)\n            for x in xtrain:\n                ncity.append([end])\n                ntrain.append([x])\n        for ct in start.next:\n            if ct != end:\n                xtrain = start.getCityTrain(ct, time)\n                for z in xtrain:\n                    nkey = str(ct.num) + '_' + str(end.num) + '_' + z.ytime\n                    if nkey in self.d.keys():\n                        answer = self.d[nkey]\n                    else:\n                        answer = self.searchPath(ct, end, z.ytime)\n                    if answer.citylist.__len__() >= 1:\n                        for i in range(answer.citylist.__len__()):\n                            shx = copy.copy(answer.citylist[i])\n                            shx.insert(0, ct)\n                            shy = copy.copy(answer.trainlist[i])\n                            shy.insert(0, z)\n                            ncity.append(shx)\n                            ntrain.append(shy)\n        result.trainlist = ntrain\n        result.citylist = ncity\n        self.d[key] = result\n        return result\n\n    def choosePath(self, primaryResult, start, end):\n        starttime = \"00:00\"\n        ntrain = primaryResult.trainlist\n        ncity = primaryResult.citylist\n        result = path(start, end)\n        for i in range(len(ntrain)):\n            if timebigger(ntrain[i][0].xtime, starttime):\n                starttime = ntrain[i][0].xtime\n            elif ntrain[i][0].xtime == starttime:\n                starttime = ntrain[i][0].xtime\n        cityresult = []\n        trainresult = []\n        while ntrain:\n            tr = ntrain.pop()\n            ct = ncity.pop()\n            if tr[0].xtime != starttime:\n                cityresult.append(ct)\n                trainresult.append(tr)\n        result.trainlist = trainresult\n        result.citylist = cityresult\n        dtrain = []\n        dcity = []\n        l = len(result.trainlist)\n        for i in range(l):\n            flag = True\n            for t in result.trainlist[i]:\n                if self.checkPath(t.x, end, t.xtime):\n                    flag = False\n            if flag:\n                dtrain.append(result.trainlist[i])\n                dcity.append(result.citylist[i])\n        result.trainlist = dtrain\n        result.citylist = dcity\n        return result\n\n    def checkPath(self, start, end, time):\n        key = str(start.num) + '_' + str(end.num) + '_' + time\n        if key in self.d.keys():\n            answer = self.d[key]\n        else:\n            answer = self.searchPath(start, end, time)\n        for t in answer.trainlist:\n            if timebigger(t[0].xtime, time):\n                return False\n        return True\n\n    def findCheapest(self, r):\n        min_price = []\n        l = len(r.citylist)\n        for i in range(l):\n            for t in r.trainlist:\n                tot = 0\n                for ft in t:\n                    tot += ft.price\n                min_price.append(tot)\n        return min(min_price)\n\ndef timebigger(left, right):\n    lspl = left.split(\":\")\n    rspl = right.split(\":\")\n    lmins = int(lspl[0]) * 60 + int(lspl[1])\n    rmins = int(rspl[0]) * 60 + int(rspl[1])\n    return lmins > rmins\n\n# main function\ndef main_solution(city_data, start_city, end_city, start_time):\n    graph = cityGraph()\n    for line in city_data:\n        graph.cityFromLine(line)\n    city1 = graph.getCity(start_city)\n    city3 = graph.getCity(end_city)\n    answer = graph.searchPath(city1, city3, start_time)\n    result = graph.choosePath(answer, city1, city3)\n    if len(result.citylist) >= 1:\n        return graph.findCheapest(result)\n    else:\n        return -1", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate random number of cities (between 2 and 10)\n    num_cities = random.randint(2, 10)\n    cities = list(range(1, num_cities + 1))\n    \n    # Generate random train connections\n    city_data = []\n    for _ in range(random.randint(num_cities, num_cities * 3)):\n        x = random.choice(cities)\n        y = random.choice([c for c in cities if c != x])\n        price = random.randint(10, 500)\n        \n        # Generate random times in HH:MM format\n        hour1 = random.randint(0, 23)\n        minute1 = random.randint(0, 59)\n        xtime = f\"{hour1:02d}:{minute1:02d}\"\n        \n        hour2 = random.randint(hour1, 23)\n        if hour2 == hour1:\n            minute2 = random.randint(minute1, 59)\n        else:\n            minute2 = random.randint(0, 59)\n        ytime = f\"{hour2:02d}:{minute2:02d}\"\n        \n        line = f\"{x} {y} {price} {xtime} {ytime}\"\n        city_data.append(line)\n    \n    # Choose random start and end cities\n    start_city, end_city = random.sample(cities, 2)\n    \n    # Generate random start time\n    start_hour = random.randint(0, 23)\n    start_minute = random.randint(0, 59)\n    start_time = f\"{start_hour:02d}:{start_minute:02d}\"\n    \n    return {\n        'city_data': city_data,\n        'start_city': start_city,\n        'end_city': end_city,\n        'start_time': start_time\n    }", "io_pairs": [{"input": {"city_data": ["2 1 377 23:09 23:21", "1 3 191 01:15 23:50", "1 4 343 23:42 23:43", "3 2 390 09:38 12:04"], "start_city": 2, "end_city": 1, "start_time": "10:26"}, "output": -1}, {"input": {"city_data": ["1 2 191 20:51 23:00", "2 1 423 19:09 20:59", "1 2 271 13:16 22:05", "4 1 193 20:51 22:45"], "start_city": 3, "end_city": 1, "start_time": "04:24"}, "output": -1}, {"input": {"city_data": ["1 2 192 03:05 20:51", "1 2 400 23:14 23:44"], "start_city": 2, "end_city": 1, "start_time": "01:56"}, "output": -1}, {"input": {"city_data": ["2 4 257 14:49 22:01", "3 1 436 08:33 21:21", "3 1 266 20:47 20:57", "3 4 26 21:48 22:17"], "start_city": 4, "end_city": 2, "start_time": "12:54"}, "output": -1}, {"input": {"city_data": ["2 1 265 21:06 22:33", "1 2 104 18:00 20:49", "2 1 327 06:21 23:26", "1 2 500 06:56 17:36"], "start_city": 1, "end_city": 2, "start_time": "06:22"}, "output": 500}, {"input": {"city_data": ["2 1 186 01:55 06:13", "2 1 256 09:46 12:48", "1 2 313 18:26 21:37", "2 1 70 09:16 12:36"], "start_city": 1, "end_city": 2, "start_time": "13:58"}, "output": -1}, {"input": {"city_data": ["2 1 157 02:51 14:13", "1 2 40 03:41 05:33", "1 2 39 02:04 20:35", "1 2 33 00:11 08:37"], "start_city": 2, "end_city": 1, "start_time": "04:21"}, "output": -1}, {"input": {"city_data": ["1 2 186 16:17 17:01", "1 2 113 05:50 17:26", "2 1 310 04:04 22:55"], "start_city": 1, "end_city": 2, "start_time": "08:37"}, "output": -1}, {"input": {"city_data": ["1 3 350 16:02 17:47", "1 3 306 08:56 21:42", "3 2 138 02:54 18:46", "3 1 325 04:54 17:24"], "start_city": 3, "end_city": 1, "start_time": "19:52"}, "output": -1}, {"input": {"city_data": ["1 2 16 12:01 20:52", "1 2 400 19:05 22:31", "1 2 155 04:35 17:12", "2 1 500 00:48 04:47"], "start_city": 1, "end_city": 2, "start_time": "19:46"}, "output": -1}], "error_log": []}
{"context": "Given a collection of `n` objects, how many ways can you select and arrange `k` objects from this collection, considering that the result should be modulo 1,000,000?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): A positive integer representing the total number of objects in the collection.\n  `k` (int): A positive integer representing the number of objects to be taken from the collection for partial permutations.\n\nOutput:\n  `return` (int): The total number of partial permutations P(n, k) modulo 1,000,000.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(n, k):\n    # Calculate the factorial of n\n    n_factorial = math.factorial(n)\n    \n    # Calculate the factorial of (n-k)\n    n_minus_k_factorial = math.factorial(n - k)\n    \n    # Calculate the number of partial permutations P(n, k)\n    partial_permutations = n_factorial // n_minus_k_factorial\n    \n    # Return the result modulo 1,000,000\n    return partial_permutations % 1000000", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(1, 100)\n    max_k = min(n, 10)  # Ensure k is not too large to avoid very big numbers\n    k = random.randint(1, max_k)\n    return {'n': n, 'k': k}", "io_pairs": [{"input": {"n": 89, "k": 6}, "output": 31360}, {"input": {"n": 9, "k": 3}, "output": 504}, {"input": {"n": 30, "k": 8}, "output": 936000}, {"input": {"n": 7, "k": 4}, "output": 840}, {"input": {"n": 5, "k": 3}, "output": 60}, {"input": {"n": 86, "k": 4}, "output": 965320}, {"input": {"n": 2, "k": 1}, "output": 2}, {"input": {"n": 43, "k": 6}, "output": 446880}, {"input": {"n": 80, "k": 1}, "output": 80}, {"input": {"n": 32, "k": 9}, "output": 544000}], "error_log": []}
{"context": "In a game of Minesweeper, a player clicks on a cell in a grid to reveal what is underneath. The grid contains mines ('M') and empty cells ('E'). If a player clicks on a mine, the game ends. If a player clicks on an empty cell, the game reveals either a blank cell ('B') or a number indicating the count of adjacent mines. Given a Minesweeper board and the position of a click, what will be the state of the board after the click is processed?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of strings): A 2D board where each cell is either 'M' (mine), 'E' (empty), 'B' (blank), or a digit representing the number of adjacent mines.\n  `click` (list of integers): A list containing two integers representing the row and column indices of the cell that was clicked.\n\nOutput:\n  `return` (list of strings): The updated 2D board after processing the click.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def updateBoard(self, board, click):\n        ROW = len(board)\n        COLUMN = len(board[0])\n        self.ROW = ROW\n        self.COLUMN = COLUMN\n        self.board = board\n        index = 0\n        while index < ROW:\n            board[index] = list(board[index])\n            index += 1\n        \n        if board[click[0]][click[1]] == 'M':\n            board[click[0]][click[1]] = 'X'\n        else:\n            self.dfs(click[0], click[1])\n    \n        index = 0\n        while index < ROW:\n            board[index] = \"\".join(board[index])\n            index += 1\n        return board\n    \n    def dfs(self, x, y):\n        if x < 0 or y < 0 or x == self.ROW or y == self.COLUMN or self.board[x][y] != 'E':\n            return \n        neighbourCount = 0\n        for i in range(-1, 2):\n            newX = x + i\n            if newX < 0 or newX == self.ROW:\n                continue\n            \n            for j in range(-1, 2):\n                newY = y + j\n                if newY < 0 or newY == self.COLUMN:\n                    continue\n                \n                if self.board[newX][newY] == 'M':\n                    neighbourCount += 1\n        if neighbourCount == 0:\n            self.board[x][y] = 'B'\n            for i in range(-1, 2):\n                for j in range(-1, 2):\n                    self.dfs(x + i, y + j)\n        else:\n            self.board[x][y] = str(neighbourCount)\n\n# main function\ndef main_solution(board, click):\n    # Convert the board from a list of strings to a list of lists\n    board = [list(row) for row in board]\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the updateBoard method\n    updated_board = solution.updateBoard(board, click)\n    \n    # Convert the board back to a list of strings\n    updated_board = [''.join(row) for row in updated_board]\n    \n    # Return the updated board\n    return updated_board", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(5, 10)\n    cols = random.randint(5, 10)\n    board = []\n    for _ in range(rows):\n        row = []\n        for _ in range(cols):\n            if random.random() < 0.15:\n                row.append('M')\n            else:\n                row.append('E')\n        board.append(''.join(row))\n    click = (random.randint(0, rows-1), random.randint(0, cols-1))\n    return {'board': board, 'click': click}", "io_pairs": [{"input": {"board": ["EEEEEEME", "MMMEEEEE", "EMEEEEME", "EEEEEEEM", "EEMEMEEE"], "click": [2, 6]}, "output": ["EEEEEEME", "MMMEEEEE", "EMEEEEXE", "EEEEEEEM", "EEMEMEEE"]}, {"input": {"board": ["EEEMME", "EMEEEE", "EEEEEE", "EEEEEM", "EMEEEE"], "click": [3, 5]}, "output": ["EEEMME", "EMEEEE", "EEEEEE", "EEEEEX", "EMEEEE"]}, {"input": {"board": ["EEEMEM", "EEEEEM", "EMMMEE", "EEEEEE", "EEEMEE", "EEEEEE"], "click": [5, 1]}, "output": ["EEEMEM", "EEEEEM", "EMMMEE", "124EEE", "BB1MEE", "BB1EEE"]}, {"input": {"board": ["MEEEEEEE", "EEMEEEME", "EEEEEEME", "EEEEEEEE", "EEEEEEEE", "EEEEEEME", "MEEEEEEE", "MMEEMEME"], "click": [1, 1]}, "output": ["MEEEEEEE", "E2MEEEME", "EEEEEEME", "EEEEEEEE", "EEEEEEEE", "EEEEEEME", "MEEEEEEE", "MMEEMEME"]}, {"input": {"board": ["MEEEEEE", "EEEEEEE", "EMEMEEM", "EEEMEME", "EEEEEME", "EMEEEEE", "MMEEEEE"], "click": [1, 4]}, "output": ["MEEEEEE", "EEEE1EE", "EMEMEEM", "EEEMEME", "EEEEEME", "EMEEEEE", "MMEEEEE"]}, {"input": {"board": ["EEEEEEEE", "EEEEEEME", "EEEEEEEE", "EMMEEEEM", "EEEEEEEE", "EMEEEEME"], "click": [2, 5]}, "output": ["EEEEEEEE", "EEEEEEME", "EEEEE1EE", "EMMEEEEM", "EEEEEEEE", "EMEEEEME"]}, {"input": {"board": ["EMEEEEMEE", "EEEEEEEEE", "MEEEEMEEE", "EEEEEEEEE", "EEEEEEEEE", "EMMEEEMEM", "EEEEEEMEE"], "click": [5, 5]}, "output": ["EMEEEEMEE", "EEEEEEEEE", "MEEEEMEEE", "EEEEEEEEE", "EEEEEEEEE", "EMMEE2MEM", "EEEEEEMEE"]}, {"input": {"board": ["EEEMEEM", "EMEEEEE", "EEEEEEE", "EEEMEEE", "MEEEEEE", "EEEEEEE", "EEEEEEM"], "click": [3, 4]}, "output": ["EEEMEEM", "EMEEEEE", "EEEEEEE", "EEEM1EE", "MEEEEEE", "EEEEEEE", "EEEEEEM"]}, {"input": {"board": ["EEMMM", "EEEEE", "EEEEE", "MEEEE", "EEMEE"], "click": [4, 0]}, "output": ["EEMMM", "EEEEE", "EEEEE", "MEEEE", "1EMEE"]}, {"input": {"board": ["EEEEEEEM", "EEEEEMEE", "EMEEEEEE", "EMEEEEEE", "EEEEMEEE"], "click": [1, 1]}, "output": ["EEEEEEEM", "E1EEEMEE", "EMEEEEEE", "EMEEEEEE", "EEEEMEEE"]}], "error_log": []}
{"context": "Given two prime numbers `p` and `q`, and a single character `plaintext`, what is the encrypted ciphertext and the decrypted character after applying the RSA encryption and decryption algorithms?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p` (int): A prime number used in the RSA key generation.\n  `q` (int): Another prime number used in the RSA key generation.\n  `plaintext` (str): A single character string to be encrypted using RSA.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `ciphertext` (int): The encrypted version of the plaintext character.\n    - `decrypted_text` (str): The decrypted version of the ciphertext, which should match the original plaintext character.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef get_d(e, z):\n    a = e\n    b = z\n    x = 0\n    y = 1\n    q = 0\n    d = 0\n\n    while True:\n        if a == 1:\n            return y\n        if a == 0:\n            return -1\n        q = b // a\n        b = b - a * q\n        x = x + q * y\n        if b == 1:\n            d = z - x\n            break\n        if b == 0:\n            return -1\n        q = a // b\n        a = a - b * q\n        y = y + q * x\n    while d < 0:\n        d += z\n    return d\n\ndef is_prime(num):\n    if num > 1:\n        for i in range(2, num // 2):\n            if (num % i) == 0:\n                return False\n        return True\n    else:\n        return False\n\ndef generate_keypair(p, q):\n    if not (is_prime(p) and is_prime(q)):\n        raise ValueError('Both numbers must be prime.')\n    elif p == q:\n        raise ValueError('p and q cannot be equal')\n    n = p * q\n    z = (p - 1) * (q - 1)\n    e = random.randrange(1, z)\n\n    while gcd(e, z) != 1:\n        e = random.randrange(1, z)\n\n    d = get_d(e, z)\n    return ((e, n), (d, n))\n\ndef encryptRSA(pk, plaintext):\n    AsciiVal = ord(plaintext)\n    cipher = pow(AsciiVal, pk[0], pk[1])\n    return cipher\n\ndef decryptRSA(pk, ciphertext):\n    AsciiVal = pow(ciphertext, pk[0], pk[1])\n    plain = chr(AsciiVal)\n    return plain\n\n# main function\ndef main_solution(p, q, plaintext):\n    # all input arguments of the main_solution function should be json serializable\n    # convert JSON serializable inputs to original input variables if necessary\n    p = int(p)\n    q = int(q)\n    plaintext = str(plaintext)\n\n    # generate RSA keypair\n    public_key, private_key = generate_keypair(p, q)\n\n    # encrypt the plaintext\n    ciphertext = encryptRSA(public_key, plaintext)\n\n    # decrypt the ciphertext\n    decrypted_text = decryptRSA(private_key, ciphertext)\n\n    # return the final output, which must be json serializable\n    return {\"ciphertext\": ciphertext, \"decrypted_text\": decrypted_text}", "input_generator": "import random\n\ndef input_generator():\n    # List of small primes for p and q\n    small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    \n    # Randomly select two distinct primes\n    p, q = random.sample(small_primes, 2)\n    \n    # Generate a random plaintext character (printable ASCII)\n    plaintext = chr(random.randint(32, 126))\n    \n    return {\"p\": p, \"q\": q, \"plaintext\": plaintext}", "io_pairs": [{"input": {"p": 3, "q": 17, "plaintext": "j"}, "output": {"ciphertext": 4, "decrypted_text": "\u0004"}}, {"input": {"p": 67, "q": 79, "plaintext": "b"}, "output": {"ciphertext": 1234, "decrypted_text": "b"}}, {"input": {"p": 5, "q": 47, "plaintext": ";"}, "output": {"ciphertext": 54, "decrypted_text": ";"}}, {"input": {"p": 79, "q": 83, "plaintext": "Q"}, "output": {"ciphertext": 1769, "decrypted_text": "Q"}}, {"input": {"p": 73, "q": 37, "plaintext": "."}, "output": {"ciphertext": 2236, "decrypted_text": "."}}, {"input": {"p": 29, "q": 17, "plaintext": "Y"}, "output": {"ciphertext": 293, "decrypted_text": "Y"}}, {"input": {"p": 61, "q": 23, "plaintext": "d"}, "output": {"ciphertext": 351, "decrypted_text": "d"}}, {"input": {"p": 67, "q": 2, "plaintext": "/"}, "output": {"ciphertext": 21, "decrypted_text": "/"}}, {"input": {"p": 11, "q": 73, "plaintext": "2"}, "output": {"ciphertext": 244, "decrypted_text": "2"}}, {"input": {"p": 47, "q": 61, "plaintext": "N"}, "output": {"ciphertext": 2579, "decrypted_text": "N"}}], "error_log": []}
{"context": "In a game, two players take turns choosing numbers. The first player wins if they can choose a pair of numbers (a, b) such that a is not equal to b and the first player can always force a win regardless of the second player's moves. Given the ranges for the numbers a and b, what is the count of such winning pairs for the first player?\n\nThe input and output requirements are as follows:\n\nInput:\n  `A1` (int): The start of the range for the first number.\n  `A2` (int): The end of the range for the first number.\n  `B1` (int): The start of the range for the second number.\n  `B2` (int): The end of the range for the second number.\n\nOutput:\n  `return` (int): The count of pairs (a, b) within the specified ranges where the first player wins the game.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef check_win(a, b):\n    if a == b:\n        return False\n    # Make sure b > a\n    if a > b:\n        a, b = b, a\n    alpha = b % a\n    if alpha == 0:\n        result = True\n    elif a % alpha == 0:\n        if b/a == 1:\n            result = False\n        else:\n            result = True\n    else:\n        if b/a > 1 and check_win(a, alpha):\n            result = True\n        else:\n            result = not check_win(a, alpha)\n    return result\n\n# main function\ndef main_solution(A1, A2, B1, B2):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    win_count = 0\n    for a in range(A1, A2 + 1):\n        for b in range(B1, B2 + 1):\n            if check_win(a, b):\n                win_count += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return win_count", "input_generator": "import random\n\ndef input_generator():\n    A1 = random.randint(1, 50)\n    A2 = random.randint(A1 + 1, 100)\n    B1 = random.randint(1, 50)\n    B2 = random.randint(B1 + 1, 100)\n    return {'A1': A1, 'A2': A2, 'B1': B1, 'B2': B2}", "io_pairs": [{"input": {"A1": 46, "A2": 56, "B1": 16, "B2": 71}, "output": 605}, {"input": {"A1": 17, "A2": 42, "B1": 24, "B2": 93}, "output": 1801}, {"input": {"A1": 3, "A2": 53, "B1": 39, "B2": 94}, "output": 2841}, {"input": {"A1": 22, "A2": 27, "B1": 29, "B2": 91}, "output": 378}, {"input": {"A1": 49, "A2": 60, "B1": 1, "B2": 54}, "output": 642}, {"input": {"A1": 34, "A2": 47, "B1": 4, "B2": 73}, "output": 966}, {"input": {"A1": 36, "A2": 64, "B1": 15, "B2": 33}, "output": 551}, {"input": {"A1": 39, "A2": 99, "B1": 45, "B2": 59}, "output": 900}, {"input": {"A1": 16, "A2": 59, "B1": 16, "B2": 43}, "output": 1204}, {"input": {"A1": 13, "A2": 81, "B1": 43, "B2": 54}, "output": 816}], "error_log": []}
{"context": "Given a text file containing sentences, how would the weather forecast look over a specified number of days, and what sentence can be generated using a Markov chain based on the text file?\n\nThe input and output requirements are as follows:\n\nInput:\n  `days` (int): The number of days to forecast the weather.\n  `filename` (str): The path to the text file to generate the Markov chain sentence.\n\nOutput:\n  `result` (dict): A dictionary containing the weather forecast and the generated sentence.\n    - `weather_forecast` (list of int): A list of integers representing the weather state for each day.\n    - `generated_sentence` (str): A string representing a sentence generated by the Markov chain.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom random import random\nimport scipy.sparse as sp\nfrom scipy import linalg as la\n\n# all class and function definitions in the code file, if any\ndef random_markov(n):\n    \"\"\"Create and return a transition matrix for a random Markov chain with\n    'n' states. This should be stored as an nxn NumPy array.\n    \"\"\"\n    #create nxn random matrix, Normalize columns\n    A = np.random.rand(n,n)\n    for i in range(n):\n        total = sum(A[:,i])\n        A[:,i] = A[:,i]/float(total)\n    return A\n\ndef forecast(days):\n    \"\"\"Forecast tomorrow's weather given that today is hot.\"\"\"\n    transition = np.array([[0.7, 0.6], [0.3, 0.4]])\n    # Sample from a binomial distribution to choose a new state.\n    predictions = []\n    current = 0\n    for i in range(days):\n        if current == 1:\n            prob = transition[1, 1]\n        elif current == 0:\n            prob = transition[1, 0]\n        predictions.append(np.random.binomial(1, prob))\n        current = predictions[i]\n    return predictions\n\ndef four_state_forecast(days):\n    \"\"\"Run a simulation for the weather over the specified number of days,\n    with mild as the starting state, using the four-state Markov chain.\n    Return a list containing the day-by-day results, not including the\n    starting day.\n    \"\"\"\n    transition = np.array([[0.5, 0.3, 0.1, 0], [0.3, 0.3, 0.3, 0.3], [0.2, 0.3, 0.4, 0.5], [0, 0.1, 0.2, 0.2]])\n    current = 1\n    predictions = []\n    for i in range(days):\n        prob = transition[:,current]\n        new = np.random.multinomial(1, prob)\n        j = np.where(new == 1)#Finds the index where there is a 1 which corresponds to the current state\n        current = int(j[0])\n        predictions.append(current)\n    return predictions\n\ndef steady_state(A, tol=1e-12, N=40):\n    \"\"\"Compute the steady state of the transition matrix A.\n\n    Inputs:\n        A ((n,n) ndarray): A column-stochastic transition matrix.\n        tol (float): The convergence tolerance.\n        N (int): The maximum number of iterations to compute.\n\n    Raises:\n        ValueError: if the iteration does not converge within N steps.\n\n    Returns:\n        x ((n,) ndarray): The steady state distribution vector of A.\n    \"\"\"\n    n = np.shape(A)[0]\n    i = 0\n    e = 1\n    xprev = np.random.rand(n,1)\n    total = sum(xprev[:,0])\n    xprev = xprev/float(total)#generate random state distribution vector\n    xi = np.dot(A,xprev)\n    while i <= N and e >= tol:\n        i += 1\n        if i > N:\n            raise ValueError(\"Does Not Converge\")\n            break\n        xi = np.dot(A, xprev)\n        e = la.norm(xprev-xi, ord=np.inf)#calculate norm\n        xprev = xi\n    return xi\n\nclass SentenceGenerator(object):\n    \"\"\"Markov chain creator for simulating bad English.\n\n    Attributes:\n        (what attributes do you need to keep track of?)\n\n    Example:\n        >>> yoda = SentenceGenerator(\"Yoda.txt\")\n        >>> print yoda.babble()\n        The dark side of loss is a path as one with you.\n    \"\"\"\n\n    def __init__(self, filename):\n        \"\"\"Read the specified file and build a transition matrix from its\n        contents. You may assume that the file has one complete sentence\n        written on each line. Use sparse matrices to ensure the proccess\n        will work for larger training sets.\n        \"\"\"\n        self.filename = filename\n        wordcount = set()\n        lines = []\n        states = [\"$tart\"]\n        with open(filename, 'r') as myfile:\n            for line in myfile:\n                lines.append(line)\n                for word in line.split():\n                    if word not in wordcount:\n                        states.append(word)\n                    wordcount.add(word)#WORDS SEPARATED: does not keep duplicates\n        states.append(\"$top\")\n        matrix = np.zeros((len(wordcount)+2,len(wordcount)+2))#Want a matrix the size of unique words +2\n        matrix[len(wordcount)+1,len(wordcount)+1] = 1#Stop state transitions to self...index of last entry is 1 less than size\n\n        for line in lines:#Each line is a sentence\n            words = line.split()#Separate the words\n            for i in range(len(words)):#For each word update the transition matrix\n                if i == 0:#if it is the 1st word of the sentence\n                    matrix[states.index(words[i]),0] += 1#Add 1 to start state\n                elif i == len(words)-1:#if it is the last word in the sentence\n                    matrix[states.index(words[i]),states.index(words[i-1])] += 1#Add 1 to prev word transition\n                    matrix[len(wordcount)+1, states.index(words[i])] += 1#Add 1 to stop state\n                else:\n                    matrix[states.index(words[i]),states.index(words[i-1])] += 1#Add 1 to prev word transition\n        '''Normalize columns'''\n        for i in range(len(wordcount)+2):\n            total = sum(matrix[:,i])\n            if total != 0:\n                matrix[:,i] = matrix[:,i]/float(total)\n\n        self.states = states#Save the states of the transition matrix\n        self.transition = matrix\n\n    def babble(self):\n        \"\"\"Begin at the start sate and use the strategy from\n        four_state_forecast() to transition through the Markov chain.\n        Keep track of the path through the chain and the corresponding words.\n        When the stop state is reached, stop transitioning and terminate the\n        sentence. Return the resulting sentence as a single string.\n        \"\"\"\n        current = 0\n        predictions = []\n        my_string = \"\"\n\n        while current != np.shape(self.transition)[0]-1:#Transition through Markov chain until stop state\n            prob = self.transition[:,current]#Probability is assigned the Start state transition\n            new = np.random.multinomial(1, prob)#Takes 1 draw from multinomial with Probability of current transition state\n            j = np.where(new == 1)#Finds the index where there is a 1 which corresponds to the current state\n            current = int(j[0])\n            predictions.append(current)#List of state at each point\n\n        for i in predictions:#for each state\n            if i < np.shape(self.transition)[0]-1:\n                my_string += self.states[i] + \" \"\n        return my_string\n\n# main function\ndef main_solution(days, filename):\n    \"\"\"\n    Simulate the weather forecast for a given number of days and generate a sentence based on a Markov chain from a given text file.\n\n    Inputs:\n        days (int): The number of days to forecast the weather.\n        filename (str): The path to the text file to generate the Markov chain sentence.\n\n    Returns:\n        result (dict): A dictionary containing the weather forecast and the generated sentence.\n    \"\"\"\n    # Weather forecast\n    weather_forecast = four_state_forecast(days)\n    \n    # Sentence generation\n    sentence_generator = SentenceGenerator(filename)\n    generated_sentence = sentence_generator.babble()\n    \n    # Return the result as a dictionary\n    return {\n        \"weather_forecast\": weather_forecast,\n        \"generated_sentence\": generated_sentence\n    }", "input_generator": "import numpy as np\nimport random\nimport os\n\ndef input_generator():\n    # Generate a random number of days between 1 and 30\n    days = random.randint(1, 30)\n    \n    # Create a temporary text file with some sample sentences\n    filename = \"temp_text_file.txt\"\n    sample_sentences = [\n        \"The quick brown fox jumps over the lazy dog.\",\n        \"A journey of a thousand miles begins with a single step.\",\n        \"To be or not to be, that is the question.\",\n        \"All that glitters is not gold.\",\n        \"The early bird catches the worm.\"\n    ]\n    \n    with open(filename, 'w') as f:\n        for sentence in sample_sentences:\n            f.write(sentence + \"\\n\")\n    \n    return {\n        \"days\": days,\n        \"filename\": filename\n    }", "io_pairs": [], "error_log": []}
{"context": "Given two sets of dice, each with six faces numbered from 0 to 9, determine if it is possible to display all the square numbers from 1 to 81 using the faces of these dice. Note that the number 9 can be represented by either 6 or 9 on the dice. What is the result of checking if the two sets of dice faces can display all the required square numbers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n_set` (list of int): A list of 6 unique integers between 0 and 9 representing the first set of dice faces.\n  `m_set` (list of int): A list of 6 unique integers between 0 and 9 representing the second set of dice faces.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the two sets of dice faces can display all the square numbers from 1 to 81.", "reference_code": "# import necessary packages\nfrom itertools import combinations\n\n# main function\ndef main_solution(n_set, m_set):\n    # Convert input lists to sets\n    n_set = set(n_set)\n    m_set = set(m_set)\n    \n    # Replace 9 with 6 if present\n    if 9 in n_set:\n        n_set.remove(9)\n        n_set.add(6)\n    if 9 in m_set:\n        m_set.remove(9)\n        m_set.add(6)\n    \n    # Define the squares to check\n    squares = [(0,1), (0,4), (0,6), (1,6), (2,5), (3,6), (6,4), (8,1)]\n    \n    # Check if the sets are valid\n    for n, m in squares:\n        forward = (n in n_set) and (m in m_set)\n        backward = (m in n_set) and (n in m_set)\n        if not (forward or backward):\n            return False\n    \n    return True", "input_generator": "import random\n\ndef input_generator():\n    # Define possible digits (0-8, with 9 replaced by 6)\n    digits = [0, 1, 2, 3, 4, 5, 6, 7, 8]\n    \n    # Randomly choose sizes for n_set and m_set (between 6 and 9 elements)\n    n_size = random.randint(6, 9)\n    m_size = random.randint(6, 9)\n    \n    # Generate n_set and m_set with random digits, ensuring they can cover squares\n    n_set = random.sample(digits, n_size)\n    m_set = random.sample(digits, m_size)\n    \n    # Randomly decide to include 9 (which will be replaced by 6)\n    if random.choice([True, False]):\n        if 6 not in n_set:\n            n_set[random.randint(0, len(n_set)-1)] = 9\n    if random.choice([True, False]):\n        if 6 not in m_set:\n            m_set[random.randint(0, len(m_set)-1)] = 9\n    \n    return {'n_set': n_set, 'm_set': m_set}", "io_pairs": [{"input": {"n_set": [0, 7, 4, 3, 2, 8, 1, 6], "m_set": [5, 2, 6, 3, 7, 1, 0, 8]}, "output": true}, {"input": {"n_set": [4, 5, 3, 6, 0, 7, 2], "m_set": [8, 6, 5, 7, 1, 4]}, "output": false}, {"input": {"n_set": [8, 7, 9, 3, 1, 5, 0, 2], "m_set": [4, 2, 6, 5, 3, 0, 7]}, "output": false}, {"input": {"n_set": [0, 1, 7, 3, 2, 5, 4, 6], "m_set": [5, 4, 1, 3, 6, 7]}, "output": false}, {"input": {"n_set": [3, 5, 4, 8, 6, 1], "m_set": [5, 6, 0, 7, 2, 1, 8]}, "output": true}, {"input": {"n_set": [8, 7, 4, 3, 2, 1, 5, 6, 0], "m_set": [7, 4, 0, 2, 3, 5, 6, 1, 8]}, "output": true}, {"input": {"n_set": [8, 4, 3, 5, 2, 0, 7, 6, 1], "m_set": [4, 8, 0, 7, 2, 6, 3, 5, 1]}, "output": true}, {"input": {"n_set": [4, 1, 3, 5, 0, 6], "m_set": [7, 1, 8, 4, 2, 0, 9]}, "output": true}, {"input": {"n_set": [4, 5, 6, 0, 8, 7, 1], "m_set": [2, 7, 4, 8, 3, 6, 5, 0]}, "output": true}, {"input": {"n_set": [6, 7, 1, 2, 3, 4], "m_set": [5, 7, 2, 9, 3, 8]}, "output": false}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, a computer player uses a Q-learning algorithm to decide its next move. Given the current state of the board, the exploration rate (epsilon), and whether the player is maximizing or minimizing the Q-values, which cell will the computer player choose to mark next?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_state` (str): A string representing the current state of the Tic-Tac-Toe board. Each character in the string corresponds to a cell on the board, where ' ' represents an empty cell, 'X' represents a cell marked by Player X, and 'O' represents a cell marked by Player O. The string length is always 9.\n  `epsilon` (float): A float value between 0 and 1 representing the exploration rate in the Q-learning algorithm. It determines the probability of the player making a random move instead of a greedy move.\n  `is_maximising` (bool): A boolean value indicating whether the player is maximizing (True) or minimizing (False) the Q-values.\n\nOutput:\n  `return` (int): An integer representing the cell index (0-8) where the player will place their next move on the Tic-Tac-Toe board.", "reference_code": "# import necessary packages\nimport random\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass QLearning:\n    def __init__(self, epsilon):\n        self.epsilon = epsilon\n        self.qvalues = {}\n\n    def get_or_create_qvalues(self, board, player):\n        board_str = str(board)\n        if board_str not in self.qvalues:\n            self.qvalues[board_str] = {i: 0 for i in range(9)}\n        return self.qvalues[board_str]\n\n    def update_qvalues(self, action, player, state, reward, board):\n        pass  # Placeholder for actual Q-learning update logic\n\n    def get_state(self, board, player):\n        return str(board)\n\nclass Board:\n    def __init__(self):\n        self.board = [' ' for _ in range(9)]\n        self.is_game_over = False\n        self.winner = None\n\n    def mark(self, cell, symbol):\n        if self.board[cell] == ' ':\n            self.board[cell] = symbol\n            self._check_game_over()\n            return True\n        return False\n\n    def _check_game_over(self):\n        win_conditions = [(0, 1, 2), (3, 4, 5), (6, 7, 8), (0, 3, 6), (1, 4, 7), (2, 5, 8), (0, 4, 8), (2, 4, 6)]\n        for condition in win_conditions:\n            if self.board[condition[0]] == self.board[condition[1]] == self.board[condition[2]] != ' ':\n                self.is_game_over = True\n                self.winner = self.board[condition[0]]\n                return\n        if ' ' not in self.board:\n            self.is_game_over = True\n\n    def __str__(self):\n        return ''.join(self.board)\n\nclass ComputerPlayer:\n    def __init__(self, name, symbol, is_maximising, qlearning):\n        self.name = name\n        self.symbol = symbol\n        self.is_maximising = is_maximising\n        self.qlearning = qlearning\n\n    def get_next_move(self, board):\n        qvalues = self.qlearning.get_or_create_qvalues(board, self)\n        return self._pick_move(qvalues)\n\n    def _pick_move(self, qvalues):\n        unif = random.random()\n        if unif < self.qlearning.epsilon:\n            cell = self._greedy_pick_cell(qvalues)\n        else:\n            cell = self._random_pick_cell(qvalues)\n        return cell\n\n    def _greedy_pick_cell(self, qvalues):\n        if self.is_maximising:\n            return int(max(qvalues, key=qvalues.get))\n        else:\n            return int(min(qvalues, key=qvalues.get))\n\n    def _random_pick_cell(self, qvalues):\n        if not self.is_maximising:\n            self._change_to_negative_values(qvalues)\n        return self._pick_weighted_random_move(qvalues)\n\n    def _change_to_negative_values(self, qvalues):\n        for i, v in qvalues.items():\n            qvalues[i] = -v\n\n    def _pick_weighted_random_move(self, qvalues):\n        probabilities = [0] * 9\n        min_val = min(qvalues.values())\n        if min_val <= 0:\n            constant = abs(min_val) + 0.1\n        else:\n            constant = 0\n        for x in qvalues.keys():\n            probabilities[int(x)] = qvalues[x] + constant\n        probabilities = np.cumsum(probabilities)\n        rand = random.uniform(0, probabilities[8])\n        cell = next(i for i, v in enumerate(probabilities) if v >= rand)\n        return cell\n\n    def make_move(self, board, cell):\n        state = self.qlearning.get_state(board, self)\n        is_valid_move = board.mark(cell, self.symbol)\n        if not is_valid_move:\n            return False\n        reward = self._get_reward(board)\n        self.qlearning.update_qvalues(str(cell), self, state, reward, board)\n        return is_valid_move\n\n    def _get_reward(self, board):\n        reward = 0\n        if board.is_game_over and board.winner is not None:\n            if self.is_maximising:\n                reward = 1\n            else:\n                reward = -1\n        return reward\n\n# main function\ndef main_solution(board_state, epsilon, is_maximising):\n    # Convert JSON serializable inputs to original input variables\n    board = Board()\n    board.board = list(board_state)\n    qlearning = QLearning(epsilon)\n    player = ComputerPlayer(\"Computer\", \"X\", is_maximising, qlearning)\n    \n    # Get the next move\n    next_move = player.get_next_move(board)\n    \n    # Return the next move as a JSON serializable output\n    return next_move", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random board state with ' ', 'X', or 'O'\n    symbols = [' ', 'X', 'O']\n    board_state = [random.choice(symbols) for _ in range(9)]\n    \n    # Ensure the board is not already full or in a terminal state\n    if ' ' not in board_state:\n        # Randomly pick an empty cell to replace\n        empty_indices = [i for i, cell in enumerate(board_state) if cell == ' ']\n        if not empty_indices:  # all cells are filled (shouldn't happen here but just in case)\n            board_state[random.randint(0, 8)] = ' '\n    \n    # Random epsilon between 0.1 and 0.9\n    epsilon = random.uniform(0.1, 0.9)\n    \n    # Random boolean for is_maximising\n    is_maximising = random.choice([True, False])\n    \n    return {\n        'board_state': ''.join(board_state),\n        'epsilon': epsilon,\n        'is_maximising': is_maximising\n    }", "io_pairs": [{"input": {"board_state": " OOXO  OO", "epsilon": 0.657811892015368, "is_maximising": true}, "output": 0}, {"input": {"board_state": "X  OXXXO ", "epsilon": 0.15786159087983204, "is_maximising": false}, "output": 6}, {"input": {"board_state": "  XO     ", "epsilon": 0.5127637400831628, "is_maximising": false}, "output": 4}, {"input": {"board_state": "O  OO XXX", "epsilon": 0.18329683221677184, "is_maximising": true}, "output": 4}, {"input": {"board_state": "O  OOXO X", "epsilon": 0.4643669600195125, "is_maximising": false}, "output": 6}, {"input": {"board_state": " OXO OOO ", "epsilon": 0.3292229662261411, "is_maximising": true}, "output": 0}, {"input": {"board_state": " XX OXOO ", "epsilon": 0.6429954093415617, "is_maximising": false}, "output": 0}, {"input": {"board_state": " XXXOOOXO", "epsilon": 0.3070535629162938, "is_maximising": true}, "output": 0}, {"input": {"board_state": "OX  XOOOO", "epsilon": 0.7149303976102925, "is_maximising": true}, "output": 0}, {"input": {"board_state": "XXXX OOOX", "epsilon": 0.12095331716786317, "is_maximising": false}, "output": 7}], "error_log": []}
{"context": "Given a positive integer `n`, what are the primitive roots modulo `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): A positive integer for which we want to find the primitive roots.\n\nOutput:\n  `return` (list of int): A list of integers representing the primitive roots of the given integer `n`.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef PrimativeRoots(n):\n    Set = [i for i in range(1, n)]\n    Roots = []\n    for i in range(1, n):\n        Pos = []\n        for j in range(1, n):\n            Pos.append(i ** j % n)\n        if sorted(Pos) == Set:\n            Roots.append(i)\n    return Roots\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    roots = PrimativeRoots(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return roots", "input_generator": "import random\n\ndef input_generator():\n    # List of primes known to have primitive roots (since primitive roots exist for n = 2, 4, p^k, or 2*p^k where p is an odd prime)\n    primes_with_roots = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    n = random.choice(primes_with_roots)\n    return {'n': n}", "io_pairs": [{"input": {"n": 11}, "output": [2, 6, 7, 8]}, {"input": {"n": 5}, "output": [2, 3]}, {"input": {"n": 43}, "output": [3, 5, 12, 18, 19, 20, 26, 28, 29, 30, 33, 34]}, {"input": {"n": 17}, "output": [3, 5, 6, 7, 10, 11, 12, 14]}, {"input": {"n": 19}, "output": [2, 3, 10, 13, 14, 15]}, {"input": {"n": 31}, "output": [3, 11, 12, 13, 17, 21, 22, 24]}, {"input": {"n": 29}, "output": [2, 3, 8, 10, 11, 14, 15, 18, 19, 21, 26, 27]}, {"input": {"n": 3}, "output": [2]}, {"input": {"n": 7}, "output": [3, 5]}, {"input": {"n": 13}, "output": [2, 6, 7, 11]}], "error_log": []}
{"context": "In a grid-based environment, a robot needs to navigate from a starting position to an ending position while avoiding obstacles. Given the dimensions of the grid, the coordinates of the starting and ending positions, and the locations of the obstacles, what is the shortest path the robot can take to reach the destination?\n\nThe input and output requirements are as follows:\n\nInput:\n  `grid_width` (int): The width of the grid.\n  `grid_height` (int): The height of the grid.\n  `start_x` (int): The x-coordinate of the starting position.\n  `start_y` (int): The y-coordinate of the starting position.\n  `end_x` (int): The x-coordinate of the ending position.\n  `end_y` (int): The y-coordinate of the ending position.\n  `obstacles` (list of tuples): A list of tuples where each tuple contains the x and y coordinates of an obstacle.\n\nOutput:\n  `return` (list of tuples): A list of tuples where each tuple contains the x and y coordinates of the path from the start to the end position, avoiding obstacles.", "reference_code": "# import necessary packages\nimport math\nimport copy\nimport random\n\n# position of the best path search\nclass Position:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def getX(self):\n        return self.x\n    \n    def getY(self):\n        return self.y   \n    \nclass PathData:    \n    def __init__(self):\n        # list of paths that can be continued, containing: a path and Fscore\n        self.openList = []\n        # List of coordinates already visited \n        self.closedList = []\n    \n    # function to put a path as openPath in the open list\n    def putInOpenList(self, path, F):\n        openPath = [path, F]\n        self.openList.append(openPath)\n    \n    # function to put an element in the closed list\n    def putInClosedList(self, pos):\n        self.closedList.append(pos)\n    \n    # function to check if a position is in the closed list\n    def inClosedList(self, position):\n        for element in self.closedList:\n            if element.getX() == position.getX() and element.getY() == position.getY():\n                return True\n        return False \n    \n    # function to delete element from the open list\n    def deleteFromOpenList(self, path):\n        counter = 0\n        for element in self.openList:\n            if path is element[0]:\n                del self.openList[counter]\n            counter += 1\n            \n    def getLowestFScore(self, endPos):\n        lowestFscore = 10000\n        H = 10000\n        bestPath = self.openList[0]\n        for possiblePath in self.openList:\n            if possiblePath[1] < lowestFscore:\n                lowestFscore = possiblePath[1]\n                H = calcDistance(possiblePath[0][-1], endPos)\n                bestPath = possiblePath[0]\n            elif possiblePath[1] == lowestFscore and calcDistance(possiblePath[0][-1], endPos) < H:\n                lowestFscore = possiblePath[1]\n                H = len(possiblePath[0])\n                bestPath = possiblePath[0]\n        return bestPath\n\nclass Grid:\n    # dus dit is voor het maken van het grid van 17 bij 12\n    def __init__(self, width, height):\n        self.grid = [[0 for x in range(height)] for x in range(width)]\n        self.width = width\n        self.height = height\n    \n    def setPointToValue(self, position, value):\n        self.grid[position.getX()][position.getY()] = value\n\n    def setStartEnd(self, startPos, endPos):\n        self.start = startPos\n        self.end = endPos\n        self.grid[startPos.getX()][startPos.getY()] = 1\n        self.grid[endPos.getX()][endPos.getY()] = 2\n        \n    def getStart(self):\n        return self.start\n    \n    def getEnd(self):\n        return self.end\n    \n    # find all possible next paths in the grid\n    def getPossibleNextPaths(self, currentPath, pathData):\n        nextPaths = []\n        x = currentPath[-1].getX()\n        y = currentPath[-1].getY()\n        \n        possiblePath = copy.copy(currentPath)\n        \n        rightx = x + 1\n        if rightx <= self.width-1 and (self.grid[rightx][y] == 0 or self.grid[rightx][y] == 2) and not pathData.inClosedList(Position(rightx, y)):\n            possiblePath.append(Position(rightx, y))\n            nextPaths.append(possiblePath)\n\n        possiblePath = copy.copy(currentPath)\n        leftx = x - 1\n        if leftx >= 0 and (self.grid[leftx][y] == 0 or self.grid[leftx][y] == 2) and not pathData.inClosedList(Position(leftx, y)):\n            possiblePath.append(Position(leftx, y))\n            nextPaths.append(possiblePath)\n\n        possiblePath = copy.copy(currentPath)\n        upy = y + 1\n        if upy <= self.height-1 and (self.grid[x][upy] == 0 or self.grid[x][upy] == 2) and not pathData.inClosedList(Position(x, upy)):\n            possiblePath.append(Position(x, upy))\n            nextPaths.append(possiblePath)\n            \n        possiblePath = copy.copy(currentPath)\n        downy = y - 1\n        if downy >= 0 and (self.grid[x][downy] == 0 or self.grid[x][downy] == 2) and not pathData.inClosedList(Position(x, downy)):\n            possiblePath.append(Position(x, downy))\n            nextPaths.append(possiblePath)\n            \n        return nextPaths\n        \n    def drawPath(self, path):\n        for i in range(self.width):\n            for j in range(self.height):\n                if self.grid[i][j] == 1:\n                    self.grid[i][j] = 0\n        for step in path:\n            self.grid[step.getX()][step.getY()] = 1\n\n# function to calculate manhattan distance\ndef calcDistance(pos1, pos2):\n    distance = abs(pos1.getX() - pos2.getX()) + abs(pos1.getY() - pos2.getY())\n    return distance\n\n# main function\ndef main_solution(grid_width, grid_height, start_x, start_y, end_x, end_y, obstacles):\n    # Convert JSON serializable inputs to original input variables\n    start = Position(start_x, start_y)\n    end = Position(end_x, end_y)\n    grid = Grid(grid_width, grid_height)\n    \n    # Set start and end positions\n    grid.setStartEnd(start, end)\n    \n    # Set obstacles\n    for obstacle in obstacles:\n        grid.setPointToValue(Position(obstacle[0], obstacle[1]), 3)\n    \n    # Find the path\n    pathData = PathData()\n    currentPath = [grid.getStart()]\n    endPos = grid.getEnd()\n    \n    while not(currentPath[-1].getX() == endPos.getX() and currentPath[-1].getY() == endPos.getY()):\n        pathData.deleteFromOpenList(currentPath)    \n        pathData.putInClosedList(currentPath[-1])\n        continuationList = grid.getPossibleNextPaths(currentPath, pathData)\n\n        for possiblePath in continuationList:\n            G = len(possiblePath) - 1\n            H = calcDistance(possiblePath[-1], endPos)\n            F = G + H\n            pathData.putInOpenList(possiblePath, F)\n            \n        currentPath = pathData.getLowestFScore(endPos)\n        grid.setPointToValue(currentPath[-1], 1)\n    \n    # Convert the result to JSON serializable output\n    path_coords = [(pos.getX(), pos.getY()) for pos in currentPath]\n    return path_coords", "input_generator": "import random\n\ndef input_generator():\n    grid_width = random.randint(5, 20)\n    grid_height = random.randint(5, 20)\n    \n    start_x = random.randint(0, grid_width - 1)\n    start_y = random.randint(0, grid_height - 1)\n    \n    end_x = random.randint(0, grid_width - 1)\n    end_y = random.randint(0, grid_height - 1)\n    while (end_x == start_x and end_y == start_y):\n        end_x = random.randint(0, grid_width - 1)\n        end_y = random.randint(0, grid_height - 1)\n    \n    num_obstacles = random.randint(1, min(grid_width, grid_height))\n    obstacles = []\n    for _ in range(num_obstacles):\n        obs_x = random.randint(0, grid_width - 1)\n        obs_y = random.randint(0, grid_height - 1)\n        while (obs_x == start_x and obs_y == start_y) or (obs_x == end_x and obs_y == end_y) or ((obs_x, obs_y) in obstacles):\n            obs_x = random.randint(0, grid_width - 1)\n            obs_y = random.randint(0, grid_height - 1)\n        obstacles.append((obs_x, obs_y))\n    \n    return {\n        'grid_width': grid_width,\n        'grid_height': grid_height,\n        'start_x': start_x,\n        'start_y': start_y,\n        'end_x': end_x,\n        'end_y': end_y,\n        'obstacles': obstacles\n    }", "io_pairs": [{"input": {"grid_width": 13, "grid_height": 12, "start_x": 8, "start_y": 11, "end_x": 12, "end_y": 8, "obstacles": [[11, 3]]}, "output": [[8, 11], [9, 11], [10, 11], [11, 11], [11, 10], [11, 9], [11, 8], [12, 8]]}, {"input": {"grid_width": 5, "grid_height": 8, "start_x": 2, "start_y": 6, "end_x": 2, "end_y": 7, "obstacles": [[2, 2]]}, "output": [[2, 6], [2, 7]]}, {"input": {"grid_width": 9, "grid_height": 9, "start_x": 0, "start_y": 0, "end_x": 2, "end_y": 5, "obstacles": [[8, 5]]}, "output": [[0, 0], [1, 0], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [2, 5]]}, {"input": {"grid_width": 10, "grid_height": 6, "start_x": 1, "start_y": 4, "end_x": 4, "end_y": 1, "obstacles": [[1, 3]]}, "output": [[1, 4], [2, 4], [3, 4], [3, 3], [3, 2], [3, 1], [4, 1]]}, {"input": {"grid_width": 7, "grid_height": 11, "start_x": 4, "start_y": 4, "end_x": 2, "end_y": 8, "obstacles": [[2, 7]]}, "output": [[4, 4], [3, 4], [3, 5], [3, 6], [3, 7], [3, 8], [2, 8]]}, {"input": {"grid_width": 8, "grid_height": 6, "start_x": 4, "start_y": 5, "end_x": 4, "end_y": 0, "obstacles": [[6, 4]]}, "output": [[4, 5], [4, 4], [4, 3], [4, 2], [4, 1], [4, 0]]}, {"input": {"grid_width": 6, "grid_height": 8, "start_x": 4, "start_y": 1, "end_x": 4, "end_y": 2, "obstacles": [[1, 2]]}, "output": [[4, 1], [4, 2]]}, {"input": {"grid_width": 9, "grid_height": 9, "start_x": 1, "start_y": 6, "end_x": 3, "end_y": 3, "obstacles": [[1, 5]]}, "output": [[1, 6], [2, 6], [3, 6], [3, 5], [3, 4], [3, 3]]}, {"input": {"grid_width": 5, "grid_height": 11, "start_x": 2, "start_y": 2, "end_x": 0, "end_y": 0, "obstacles": [[4, 4]]}, "output": [[2, 2], [1, 2], [1, 1], [1, 0], [0, 0]]}, {"input": {"grid_width": 20, "grid_height": 5, "start_x": 5, "start_y": 0, "end_x": 0, "end_y": 4, "obstacles": [[19, 0]]}, "output": [[5, 0], [4, 0], [3, 0], [2, 0], [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [0, 4]]}], "error_log": []}
{"context": "Given a set of data points, how can we estimate the value of a function at a specific point using Newton's divided differences method? Specifically, what is the value of the interpolation polynomial at a given x value when the x and y coordinates of the data points are provided?\n\nThe input and output requirements are as follows:\n\nInput:\n  `xdata` (list of floats): List of x coordinates of interpolation values.\n  `ydata` (list of floats): List of y coordinates of interpolation values.\n  `x` (float): The x value at which to evaluate the interpolation polynomial.\n\nOutput:\n  `return` (float): The value of the Newton polynomial evaluated at the given x value.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef N_divided_differences(xdata, ydata):\n    ''' \n    Input: \n    xdata: x coordinates of interpolation values.\n    ydata: y coordinates of interpolation values.\n\n    Output: \n    top_row: Top row of f, which is a table of Newton's divided differences (nxn matrix), with x-values in first column.  \n    ''' \n    n = len(xdata)\n    m = len(ydata)\n    assert(n == m)\n    f = np.zeros((n, n+1)) #Make table for the differences. \n\n    f[:,1] = ydata\n    f[:,0] = xdata #Add x-values to first column for calculation purposes. Follow same pattern as by hand. \n\n    for col in range(2,n+1):\n        for row in range(n+1-col):\n            f[row,col] = (f[row+1,col-1]-f[row,col-1])/(f[row+col-1, 0]-f[row, 0])\n\n    return f[0,1:] #No need to return the entire matrix, only returning top row. \n\ndef newton_polynomial(xdata, ydata, x):\n    ''' \n    Input: \n    ydata: y coordinates of interpolation values.\n    xdata: x coordinates of interpolation values.\n    x: x value to evaluate the interpolation polynomial in.  \n\n    Output: \n    y: Newton polynomial in the given x value.  \n    ''' \n    top_row = N_divided_differences(xdata, ydata)\n    n = len(ydata)\n    pol = top_row[0]\n    \n    factor = 1\n    for i in range(n-1):\n        factor *= (x-xdata[i])\n        pol += top_row[i+1]*factor\n    return pol\n\n# main function\ndef main_solution(xdata, ydata, x):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # convert JSON serializable inputs to numpy arrays\n  xdata = np.array(xdata)\n  ydata = np.array(ydata)\n  \n  # call the newton_polynomial function\n  result = newton_polynomial(xdata, ydata, x)\n  \n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return float(result)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    n = random.randint(2, 10)  # Reasonable number of points\n    xdata = sorted([random.uniform(-10, 10) for _ in range(n)])\n    ydata = [random.uniform(-10, 10) for _ in range(n)]\n    x = random.uniform(min(xdata), max(xdata))  # x within interpolation range\n    return {'xdata': xdata, 'ydata': ydata, 'x': x}", "io_pairs": [{"input": {"xdata": [-8.126034612013846, 9.93131420307272], "ydata": [-3.0234303927739115, 1.1154797588002463], "x": -3.532699405001946}, "output": -1.9705957871755038}, {"input": {"xdata": [-0.8406481084152304, 9.660673962728815], "ydata": [8.050434223701522, -2.2795961238191964], "x": 2.296716528059973}, "output": 4.964244533825987}, {"input": {"xdata": [-7.184295162762324, 1.1609259468022834, 4.901899703738904, 6.547709218352331, 8.231135178823003], "ydata": [4.230135755127648, 8.659191084662325, -3.7382594556107236, -5.73035124242995, 4.063566457178183], "x": 5.121188184475206}, "output": -4.379399040681721}, {"input": {"xdata": [-2.479773083799106, 4.97339426894821], "ydata": [3.9928897555213343, -6.978394736349413], "x": 1.8577793105412672}, "output": -2.3921166537553527}, {"input": {"xdata": [-9.200646174366838, -0.2862550691863408, 2.691072153408463, 4.565961972154895, 6.739319652407566, 7.03398422768781, 7.377557655173614], "ydata": [-5.842960829221067, 5.1663269663382465, 8.187241878697037, 7.849500219081335, -4.330071630860228, 6.171824440340895, -9.929978940476428], "x": 5.617513891682929}, "output": -50.09047439830778}, {"input": {"xdata": [-4.554198951913362, 0.5526956588504088], "ydata": [2.527790217185535, -4.226335583466194], "x": -3.6909761025049064}, "output": 1.3861344433199003}, {"input": {"xdata": [-9.075181900148714, -7.124875096552059], "ydata": [6.163939354371728, -7.011372518764542], "x": -7.464403060910595}, "output": -4.7176888727734525}, {"input": {"xdata": [-9.106792936541046, -5.909419909799749, 0.9364409968156231, 1.5033432301028284, 2.484324637463324, 3.42588457210109, 9.49591993653394], "ydata": [6.397464672862409, 5.720519295478512, 3.840898029544137, 7.494976791594727, -2.5594909881703227, -0.6394787604506931, -0.00586790483576749], "x": 4.573084166438287}, "output": 73.56572904800001}, {"input": {"xdata": [-8.798821703674083, -7.694907432825557, -4.132080533859412], "ydata": [-3.9073947381562846, -1.9800827846168811, -5.6927376768812525], "x": -6.398664912501065}, "output": -1.5756298520272691}, {"input": {"xdata": [1.161503545610163, 7.640211083888584], "ydata": [0.8669038146670012, 7.607011621400524], "x": 6.217497070638174}, "output": 6.126894519215911}], "error_log": []}
{"context": "Given a base number `x`, an exponent `n`, and a modulus `p`, determine the primitive roots modulo `p` for the given exponent `n`. What are the primitive roots modulo `p` for the given `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (int): The base number for the power operation.\n  `n` (int): The exponent for the power operation.\n  `p` (int): The modulus for the power operation.\n\nOutput:\n  `return` (list of int): A list of integers representing the primitive roots modulo `p` for the given `n`.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(x, n, p):\n    # Function to calculate (x^y)%p\n    def power(x, y, p):\n        res = 1\n        x = x % p\n        while y > 0:\n            if (y & 1) == 1:\n                res = (res * x) % p\n            y = y >> 1\n            x = (x * x) % p\n        return res\n\n    # List to store primitive roots\n    primitive_roots = []\n\n    for i in range(p):\n        if power(i, n, p) == 1:\n            flag = True\n            for j in range(1, n - 1):\n                if power(i, j, p) == 1:\n                    flag = False\n                    break\n            if flag:\n                primitive_roots.append(i)\n\n    # Return the list of primitive roots\n    return primitive_roots", "input_generator": "import random\nimport sympy\n\ndef input_generator():\n    p = sympy.randprime(5, 100)\n    n = random.randint(2, p-1)\n    while (p-1) % n != 0:\n        p = sympy.randprime(5, 100)\n        n = random.randint(2, p-1)\n    x = random.randint(1, p-1)\n    return {'x': x, 'n': n, 'p': p}", "io_pairs": [{"input": {"x": 76, "n": 4, "p": 89}, "output": [34, 55]}, {"input": {"x": 3, "n": 20, "p": 61}, "output": [8, 23, 24, 28, 33, 37, 38, 53]}, {"input": {"x": 4, "n": 2, "p": 5}, "output": [1, 4]}, {"input": {"x": 1, "n": 10, "p": 31}, "output": [15, 23, 27, 29]}, {"input": {"x": 3, "n": 3, "p": 7}, "output": [2, 4]}, {"input": {"x": 6, "n": 2, "p": 23}, "output": [1, 22]}, {"input": {"x": 30, "n": 10, "p": 41}, "output": [4, 23, 25, 31]}, {"input": {"x": 9, "n": 10, "p": 11}, "output": [2, 6, 7, 8]}, {"input": {"x": 10, "n": 2, "p": 11}, "output": [1, 10]}, {"input": {"x": 6, "n": 2, "p": 59}, "output": [1, 58]}], "error_log": []}
{"context": "Given a number, determine whether it is a Fibonacci number. What is the result of checking if the number `n` is a Fibonacci number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer number to check if it is a Fibonacci number.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input number `n` is a Fibonacci number (`True` if it is, `False` otherwise).", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef isPerfectSquare(x):\n    s = int(math.sqrt(x))\n    return s * s == x\n\ndef isFibonacci(n):\n    return isPerfectSquare(5 * n * n + 4) or isPerfectSquare(5 * n * n - 4)\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = isFibonacci(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a mix of Fibonacci and non-Fibonacci numbers\n    if random.random() < 0.5:\n        # Generate a Fibonacci number\n        fibs = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]\n        n = random.choice(fibs)\n    else:\n        # Generate a non-Fibonacci number\n        while True:\n            n = random.randint(0, 1000)\n            s = int(math.sqrt(5 * n * n + 4))\n            t = int(math.sqrt(5 * n * n - 4))\n            if not (s * s == 5 * n * n + 4 or t * t == 5 * n * n - 4):\n                break\n    return {'n': n}", "io_pairs": [{"input": {"n": 5}, "output": true}, {"input": {"n": 0}, "output": true}, {"input": {"n": 22}, "output": false}, {"input": {"n": 1}, "output": true}, {"input": {"n": 144}, "output": true}, {"input": {"n": 656}, "output": false}, {"input": {"n": 2584}, "output": true}, {"input": {"n": 748}, "output": false}, {"input": {"n": 539}, "output": false}, {"input": {"n": 16}, "output": false}], "error_log": []}
{"context": "Given a set of integers from 1 to `n`, find a sequence where each element is unique and the absolute difference between any two consecutive elements is at least `m`. What is the sequence that satisfies these conditions?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of elements in the solution.\n  `m` (int): The minimum difference required between consecutive elements in the solution.\n\nOutput:\n  `return` (list or None): A list of integers representing the solution if found, otherwise None.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef consistent(x, m):\n    for i in range(len(x)-1):\n        if x[i] == x[-1]:\n            return False\n    for i in range(len(x)-1):\n        if abs(x[i]-x[i+1]) < m:\n            return False\n    return True\n\ndef solution(x, n):\n    return len(x) == n\n\ndef solutionFound(x):\n    return x\n\ndef backtracking(n, m):\n    x = [0]\n    possible = False\n    while len(x) > 0:\n        ok = False\n        while not ok and x[-1] < n:\n            x[-1] += 1\n            ok = consistent(x, m)\n        if ok:\n            if solution(x, n):\n                return solutionFound(x)\n            else:\n                x.append(0)\n        else:\n            x = x[:-1]\n    return None\n\n# main function\ndef main_solution(n, m):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = backtracking(n, m)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(2, 10)\n    m = random.randint(1, n // 2)\n    return {'n': n, 'm': m}", "io_pairs": [{"input": {"n": 8, "m": 4}, "output": [4, 8, 3, 7, 2, 6, 1, 5]}, {"input": {"n": 10, "m": 2}, "output": [1, 3, 5, 2, 4, 6, 8, 10, 7, 9]}, {"input": {"n": 5, "m": 2}, "output": [1, 3, 5, 2, 4]}, {"input": {"n": 9, "m": 1}, "output": [1, 2, 3, 4, 5, 6, 7, 8, 9]}, {"input": {"n": 3, "m": 1}, "output": [1, 2, 3]}, {"input": {"n": 9, "m": 2}, "output": [1, 3, 5, 2, 4, 7, 9, 6, 8]}, {"input": {"n": 4, "m": 1}, "output": [1, 2, 3, 4]}, {"input": {"n": 9, "m": 3}, "output": [1, 4, 7, 2, 5, 8, 3, 6, 9]}, {"input": {"n": 8, "m": 3}, "output": [1, 4, 7, 2, 5, 8, 3, 6]}, {"input": {"n": 8, "m": 2}, "output": [1, 3, 5, 2, 6, 8, 4, 7]}], "error_log": []}
{"context": "Given a graph represented by its adjacency list, and a constraint on the maximum number of colors that can be used to color the graph, determine if the graph can be colored such that no two adjacent vertices share the same color. If it is possible, provide the color assignment for each vertex. What is the result and the color assignment for the given graph and color constraint?\n\nThe input and output requirements are as follows:\n\nInput:\n  `graph` (list of lists): A 2D list representing the adjacency list of the graph. Each sublist contains the indices of the nodes connected to the node at the corresponding index.\n  `d` (int): The maximum number of colors allowed for coloring the graph.\n  `V` (int): The number of vertices in the graph.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `result` (bool): A boolean indicating whether the graph can be colored with at most `d` colors.\n    - `color_assignment` (list of int): A list representing the color assignment for each vertex if the graph can be colored, otherwise an empty list.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef graphColoring(graph, color, src, d, V):\n    if src == V:\n        return True\n    for c in range(1, d+1):\n        if isValidColor(graph, color, c, src):\n            color[src] = c\n            if graphColoring(graph, color, src+1, d, V):\n                return True\n            color[src] = 0\n    return max(color)\n\ndef isValidColor(graph, color, c, src):\n    for u in graph[src]:\n        if color[u] == c:\n            return False\n    return True\n\n# main function\ndef main_solution(graph, d, V):\n    # Convert JSON serializable inputs to original input variables\n    color = [0 for _ in range(V+1)]\n    \n    # Call the original function\n    result = graphColoring(graph, color, 0, d, V)\n    \n    # Convert the output to JSON serializable format\n    color_result = color[:V]  # Remove the last element which is not used\n    return {\"result\": result, \"color_assignment\": color_result}", "input_generator": "import random\n\ndef input_generator():\n    V = random.randint(3, 10)  # Number of vertices\n    d = random.randint(2, 5)   # Number of colors\n    \n    # Generate a random graph (adjacency list)\n    graph = [[] for _ in range(V)]\n    for i in range(V):\n        for j in range(i+1, V):\n            if random.random() < 0.3:  # 30% chance of having an edge\n                graph[i].append(j)\n                graph[j].append(i)\n    \n    return {\"graph\": graph, \"d\": d, \"V\": V}", "io_pairs": [{"input": {"graph": [[], [], []], "d": 5, "V": 3}, "output": {"result": true, "color_assignment": [1, 1, 1]}}, {"input": {"graph": [[], [], []], "d": 3, "V": 3}, "output": {"result": true, "color_assignment": [1, 1, 1]}}, {"input": {"graph": [[2], [], [0]], "d": 4, "V": 3}, "output": {"result": true, "color_assignment": [1, 1, 2]}}, {"input": {"graph": [[2, 3], [3], [0, 3], [0, 1, 2]], "d": 3, "V": 4}, "output": {"result": true, "color_assignment": [1, 1, 2, 3]}}, {"input": {"graph": [[1, 2], [0], [0]], "d": 4, "V": 3}, "output": {"result": true, "color_assignment": [1, 2, 2]}}, {"input": {"graph": [[1], [0, 3], [3], [1, 2]], "d": 5, "V": 4}, "output": {"result": true, "color_assignment": [1, 2, 1, 3]}}, {"input": {"graph": [[1], [0], []], "d": 5, "V": 3}, "output": {"result": true, "color_assignment": [1, 2, 1]}}, {"input": {"graph": [[], [], [3], [2], []], "d": 4, "V": 5}, "output": {"result": true, "color_assignment": [1, 1, 1, 2, 1]}}, {"input": {"graph": [[1, 2], [0], [0]], "d": 5, "V": 3}, "output": {"result": true, "color_assignment": [1, 2, 2]}}, {"input": {"graph": [[], [4], [], [4], [1, 3]], "d": 2, "V": 5}, "output": {"result": true, "color_assignment": [1, 1, 1, 1, 2]}}], "error_log": []}
{"context": "Given a maximum number, what are all the prime numbers that are less than or equal to that number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `aMaximum` (int): The maximum number up to which to find prime numbers.\n\nOutput:\n  `return` (list of int): A list of prime numbers not greater than `aMaximum`.", "reference_code": "# import necessary packages\nfrom math import sqrt, trunc\n\n# all class and function definitions in the code file, if any\nclass PrimeFinder:\n    pass  # Placeholder for the base class, not used directly in main_solution\n\nclass Sundaram(PrimeFinder):\n    def primesNotGreaterThan(self, aMaximum):\n        n = int(trunc((aMaximum - 1) / 2))\n        isPrime = [True for _ in range(n + 1)]\n\n        maxJ = maxI = trunc((n - 1) / (1 + 2))\n        for i in range(1, maxI + 1):\n            for j in range(1, maxJ + 1):\n                k = i + j + 2 * i * j\n                if k <= n:\n                    isPrime[k] = False\n                else:\n                    break  # Inner loop\n\n        retval = [2]\n        for i in range(1, n + 1):\n            if isPrime[i]:\n                retval.append(2 * i + 1)\n\n        return retval\n\n# main function\ndef main_solution(aMaximum):\n    # Input argument is already JSON serializable (integer)\n    sundaram = Sundaram()\n    primes = sundaram.primesNotGreaterThan(aMaximum)\n    # Convert the list of primes to a JSON serializable format (list of integers)\n    return primes", "input_generator": "import random\n\ndef input_generator():\n    return {'aMaximum': random.randint(10, 1000)}", "io_pairs": [{"input": {"aMaximum": 64}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]}, {"input": {"aMaximum": 21}, "output": [2, 3, 5, 7, 11, 13, 17, 19]}, {"input": {"aMaximum": 35}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]}, {"input": {"aMaximum": 10}, "output": [2, 3, 5, 7]}, {"input": {"aMaximum": 33}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]}, {"input": {"aMaximum": 54}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]}, {"input": {"aMaximum": 19}, "output": [2, 3, 5, 7, 11, 13, 17, 19]}, {"input": {"aMaximum": 15}, "output": [2, 3, 5, 7, 11, 13]}, {"input": {"aMaximum": 57}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]}, {"input": {"aMaximum": 58}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]}], "error_log": []}
{"context": "Given a mathematical expression involving the variable 'x', what is the derivative of this expression with respect to 'x'?\n\nThe input and output requirements are as follows:\n\nInput:\n  `expression_str` (str): A string representing a mathematical expression in terms of the variable 'x'. The expression should be in a format that can be parsed by SymPy's `sympify` function.\n\nOutput:\n  `return` (str): A string representing the derivative of the input expression with respect to 'x'. The derivative is also in a format that can be parsed by SymPy's `sympify` function.", "reference_code": "# import necessary packages\nimport sympy\n\n# main function\ndef main_solution(expression_str):\n    # Convert the input string to a SymPy expression\n    x = sympy.symbols('x')\n    exp = sympy.sympify(expression_str)\n    \n    # Compute the derivative of the expression\n    dif = sympy.diff(exp, x)\n    \n    # Convert the derivative to a string for JSON serialization\n    derivative_str = str(dif)\n    \n    return derivative_str", "input_generator": "import random\nimport sympy\n\ndef input_generator():\n    x = sympy.symbols('x')\n    operations = ['+', '-', '*', '/', '**']\n    terms = [\n        'x',\n        'x**2',\n        'x**3',\n        'sin(x)',\n        'cos(x)',\n        'exp(x)',\n        'log(x)',\n        'sqrt(x)',\n        '1',\n        '2',\n        '3',\n        '5',\n        '10'\n    ]\n    \n    # Randomly choose the number of terms (1 to 4)\n    num_terms = random.randint(1, 4)\n    selected_terms = random.sample(terms, num_terms)\n    \n    # Build the expression string\n    if num_terms == 1:\n        expression_str = selected_terms[0]\n    else:\n        expression_str = selected_terms[0]\n        for term in selected_terms[1:]:\n            op = random.choice(operations)\n            expression_str += f'{op}{term}'\n    \n    # Randomly add parentheses for complexity\n    if random.choice([True, False]) and num_terms > 1:\n        expression_str = f'({expression_str})'\n        # Optionally add another operation\n        if random.choice([True, False]):\n            op = random.choice(operations)\n            extra_term = random.choice(terms)\n            expression_str += f'{op}{extra_term}'\n    \n    return {'expression_str': expression_str}", "io_pairs": [{"input": {"expression_str": "1"}, "output": "0"}, {"input": {"expression_str": "(sin(x)**10**1+cos(x))"}, "output": "10*sin(x)**9*cos(x) - sin(x)"}, {"input": {"expression_str": "sqrt(x)"}, "output": "1/(2*sqrt(x))"}, {"input": {"expression_str": "(exp(x)*5+x**2)"}, "output": "2*x + 5*exp(x)"}, {"input": {"expression_str": "cos(x)*1*x*10"}, "output": "-10*x*sin(x) + 10*cos(x)"}, {"input": {"expression_str": "exp(x)**2"}, "output": "2*exp(2*x)"}, {"input": {"expression_str": "log(x)"}, "output": "1/x"}, {"input": {"expression_str": "(x**3**2+10)+1"}, "output": "9*x**8"}, {"input": {"expression_str": "exp(x)**3*log(x)*x"}, "output": "3*x*exp(3*x)*log(x) + exp(3*x)*log(x) + exp(3*x)"}, {"input": {"expression_str": "(cos(x)-sqrt(x)**x)"}, "output": "-x**(x/2)*(log(x)/2 + 1/2) - sin(x)"}], "error_log": []}
{"context": "Given two mathematical expressions, what is the expanded product of these expressions?\n\nThe input and output requirements are as follows:\n\nInput:\n  `expr1` (str): A string representing the first mathematical expression.\n  `expr2` (str): A string representing the second mathematical expression.\n\nOutput:\n  `return` (str): A string representing the expanded product of the two input expressions. If the input is invalid, it returns \"Invalid Input\".", "reference_code": "# import necessary packages\nfrom sympy import expand, sympify\nfrom sympy.core.sympify import SympifyError\n\n# main function\ndef main_solution(expr1, expr2):\n    # Convert JSON serializable inputs to sympy expressions\n    try:\n        expr1 = sympify(expr1)\n        expr2 = sympify(expr2)\n    except SympifyError:\n        return \"Invalid Input\"\n    \n    # Calculate the product of the two expressions\n    prod = expand(expr1 * expr2)\n    \n    # Convert the result to a string for JSON serialization\n    return str(prod)", "input_generator": "import random\nfrom sympy import symbols\n\ndef input_generator():\n    # Define possible variables and constants\n    vars = ['x', 'y', 'z', 'a', 'b', 'c']\n    coeffs = list(range(-10, 11))\n    coeffs.remove(0)\n    \n    # Randomly choose number of terms (1 to 3) and variables (1 to 2)\n    num_terms1 = random.randint(1, 3)\n    num_vars1 = random.randint(1, 2)\n    num_terms2 = random.randint(1, 3)\n    num_vars2 = random.randint(1, 2)\n    \n    # Generate first expression\n    terms1 = []\n    for _ in range(num_terms1):\n        coeff = random.choice(coeffs)\n        vars_used = random.sample(vars[:num_vars1], min(num_vars1, len(vars[:num_vars1])))\n        term_parts = [str(coeff)] + vars_used\n        term = '*'.join(term_parts)\n        terms1.append(term)\n    expr1 = '+'.join(terms1)\n    \n    # Generate second expression\n    terms2 = []\n    for _ in range(num_terms2):\n        coeff = random.choice(coeffs)\n        vars_used = random.sample(vars[:num_vars2], min(num_vars2, len(vars[:num_vars2])))\n        term_parts = [str(coeff)] + vars_used\n        term = '*'.join(term_parts)\n        terms2.append(term)\n    expr2 = '+'.join(terms2)\n    \n    return {'expr1': expr1, 'expr2': expr2}", "io_pairs": [{"input": {"expr1": "7*x*y", "expr2": "-5*x*y"}, "output": "-35*x**2*y**2"}, {"input": {"expr1": "-4*x+-5*x+-7*x", "expr2": "-6*x*y+7*y*x"}, "output": "-16*x**2*y"}, {"input": {"expr1": "4*y*x+10*y*x", "expr2": "10*x+9*x"}, "output": "266*x**2*y"}, {"input": {"expr1": "2*x+3*x", "expr2": "5*x+-10*x"}, "output": "-25*x**2"}, {"input": {"expr1": "-8*x*y+-9*y*x+-7*y*x", "expr2": "3*y*x+-6*y*x"}, "output": "72*x**2*y**2"}, {"input": {"expr1": "-3*x*y+7*y*x", "expr2": "-1*x+-8*x"}, "output": "-36*x**2*y"}, {"input": {"expr1": "-9*x", "expr2": "-6*x+10*x"}, "output": "-36*x**2"}, {"input": {"expr1": "-1*y*x+-2*x*y", "expr2": "-7*x"}, "output": "21*x**2*y"}, {"input": {"expr1": "-5*y*x+7*y*x+8*y*x", "expr2": "-1*y*x+-2*x*y+-1*y*x"}, "output": "-40*x**2*y**2"}, {"input": {"expr1": "-7*x+-10*x", "expr2": "6*x*y+-4*y*x"}, "output": "-34*x**2*y"}], "error_log": []}
{"context": "Given a mathematical function and a specific operation, what is the result of performing the operation on the function at a specified point? The operation can be either finding the derivative at a point, calculating the definite integral over a given interval, or determining the gradient at a point in 3D space.\n\nThe input and output requirements are as follows:\n\nInput:\n  `function_str` (str): A string representation of the mathematical function to be evaluated. For example, \"x**2 + 3*x + 2\".\n  `operation` (str): The type of operation to perform. It can be one of the following: \"derivative\", \"integral\", \"gradient\".\n  `point` (float or list): Depending on the operation, this can be a single float (for derivative) or a list of floats (for integral and gradient). For \"derivative\", it is a single float representing the point at which the derivative is to be calculated. For \"integral\", it is a list of two floats representing the lower and upper bounds of the integral. For \"gradient\", it is a list of three floats representing the point in 3D space.\n\nOutput:\n  `return` (float or list): The result of the operation. For \"derivative\" and \"integral\", it is a float. For \"gradient\", it is a list of three floats representing the gradient vector.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef derivative(f, x):\n    return (f(x - x / 10000) + f(x + x / 10000)) / (2 * x / 10000)\n\ndef integral(f, a, b):\n    summation = 0\n    for i in range(10000):\n        summation += (b - a) / 10000 * f(a + i * (b - a) / 10000)\n    return summation\n\ndef grad(f, v):\n    return [\n        derivative(lambda x: f(x, v[1], v[2]), v[0]),\n        derivative(lambda y: f(v[0], y, v[2]), v[1]),\n        derivative(lambda z: f(v[0], v[1], z), v[2])\n    ]\n\n# main function\ndef main_solution(function_str, operation, point):\n    # Convert the function_str to a callable function\n    f = eval(f\"lambda x: {function_str}\")\n    \n    if operation == \"derivative\":\n        result = derivative(f, point)\n    elif operation == \"integral\":\n        result = integral(f, point[0], point[1])\n    elif operation == \"gradient\":\n        result = grad(lambda x, y, z: eval(function_str), point)\n    else:\n        raise ValueError(\"Invalid operation\")\n    \n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    operations = [\"derivative\", \"integral\", \"gradient\"]\n    operation = random.choice(operations)\n    \n    if operation == \"derivative\":\n        function_str = random.choice([\n            \"math.sin(x)\", \"math.cos(x)\", \"x**2\", \"math.exp(x)\", \"math.log(abs(x) + 1)\"\n        ])\n        point = random.uniform(-10, 10)\n        return {\n            \"function_str\": function_str,\n            \"operation\": operation,\n            \"point\": point\n        }\n    elif operation == \"integral\":\n        function_str = random.choice([\n            \"math.sin(x)\", \"math.cos(x)\", \"x**2\", \"math.exp(x)\", \"math.log(abs(x) + 1)\"\n        ])\n        a = random.uniform(-5, 5)\n        b = random.uniform(a, a + 10)\n        return {\n            \"function_str\": function_str,\n            \"operation\": operation,\n            \"point\": [a, b]\n        }\n    else:  # gradient\n        function_str = random.choice([\n            \"x**2 + y**2 + z**2\", \"math.sin(x) + math.cos(y) + z\", \"x*y*z\", \"x + y + z\"\n        ])\n        point = [random.uniform(-5, 5) for _ in range(3)]\n        return {\n            \"function_str\": function_str,\n            \"operation\": operation,\n            \"point\": point\n        }", "io_pairs": [{"input": {"function_str": "x**2 + y**2 + z**2", "operation": "gradient", "point": [-4.304139245214848, -2.5189247815233506, -1.2525737426521086]}, "output": [-61428.16567238866, -104963.58579398626, -211081.68559929144]}, {"input": {"function_str": "x + y + z", "operation": "gradient", "point": [-1.2052600450861073, 4.2396632725239485, 0.15684666903922562]}, "output": [-26477.68761179729, 7527.130555765241, 203463.03278388208]}, {"input": {"function_str": "math.cos(x)", "operation": "integral", "point": [-1.5453842779684734, 4.314767282302202]}, "output": 0.07781349189970943}, {"input": {"function_str": "math.cos(x)", "operation": "derivative", "point": 7.156055077661563}, "output": 898.0231074977795}, {"input": {"function_str": "x + y + z", "operation": "gradient", "point": [1.2102617913797857, -1.758267095696755, -1.564881282100623]}, "output": [-17458.095442381513, 12016.869289021819, 13501.896984679583]}, {"input": {"function_str": "x**2", "operation": "derivative", "point": -2.4035436388406612}, "output": -24035.436628760977}, {"input": {"function_str": "math.cos(x)", "operation": "derivative", "point": -7.995790063351292}, "output": 176.7599885491245}, {"input": {"function_str": "x**2", "operation": "integral", "point": [0.973154969926485, 4.142848431650843]}, "output": 23.39173010661001}, {"input": {"function_str": "math.cos(x)", "operation": "derivative", "point": -4.3249016311827}, "output": 873.6920300677924}, {"input": {"function_str": "x*y*z", "operation": "gradient", "point": [-3.6044955367869838, 0.6341292329286059, -4.7317784977191355]}, "output": [-30005.590691467067, 170556.74476093243, -22857.159898373135]}], "error_log": []}
{"context": "Given a grid with a specified number of rows and columns, how can we generate a random maze that represents a solvable path from the top-left corner to the bottom-right corner? The maze should be represented in a string format where 'X' denotes walls and spaces denote open paths. What is the string representation of the generated maze for the given grid dimensions?\n\nThe input and output requirements are as follows:\n\nInput:\n  `rows` (int): The number of rows in the maze grid. Must be an odd integer >= 3.\n  `cols` (int): The number of columns in the maze grid. Must be an odd integer >= 3.\n\nOutput:\n  `return` (str): A string representation of the generated maze. The maze is represented as a grid of characters, where 'X' denotes walls and spaces denote open paths. The maze includes a top wall and side walls, with paths represented by spaces.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass DisjointSets:\n    \n    def __init__(self, n):\n        self.s = [-1] * n\n        \n    def __repr__(self):\n        return repr(self.s)\n        \n    def __len__(self):\n        return len(self.s)\n        \n    def count(self):\n        return sum([1 if x < 0 else 0 for x in self.s])\n        \n    def find(self, x):\n        if self.s[x] < 0: return x\n        else:\n            self.s[x] = self.find(self.s[x])\n            return self.s[x]\n    \n    def union(self, x, y):\n        r_x = self.find(x)\n        r_y = self.find(y)\n        \n        if r_x == r_y: return -1\n        \n        if self.s[r_x] < self.s[r_y]:\n            larger = r_x\n            smaller = r_y\n        else:\n            larger = r_y\n            smaller = r_x\n        \n        self.s[larger] += self.s[smaller]\n        self.s[smaller] = larger\n        \n        return -self.s[larger]\n        \nclass Maze:\n\n    ch = 'X'\n\n    def __init__(self, rows, cols):\n        self.rows = rows\n        self.cols = cols        \n        self.generate()\n\n    def generate(self):\n    \n        rows = self.rows\n        cols = self.cols\n    \n        total = rows * cols\n    \n        d = DisjointSets(total)\n        right = [True] * total\n        bot = [True] * total\n    \n        right[-1] = False\n        \n        walls = total*2-rows-cols\n        per_row = (cols-1)*2 + 1\n        last_row = cols-1\n        \n        choices = list(range(walls))\n        random.shuffle(choices)\n    \n        while d.count() > 1:\n            x = choices.pop()\n            \n            if x >= walls-last_row:\n                row = rows-1\n                col = x - (walls-last_row)\n                cell = row*cols + col\n                if d.union(cell, cell+1) != -1:\n                    right[cell] = False\n            else:\n                row = x // per_row\n                col = (x % per_row) // 2\n                dir = (x % per_row) % 2\n                cell = row*cols + col\n                if col == cols-1 or dir == 0:\n                    if d.union(cell, cell+cols) != -1:\n                        bot[cell] = False\n                else:\n                    if d.union(cell, cell+1) != -1:\n                        right[cell] = False\n    \n        self.right = right\n        self.bot = bot\n\n    def __repr__(self):\n        \n        s = ''\n        \n        # top wall\n        s += Maze.ch * (self.cols * 2 + 1) + '\\n'\n        \n        for row in range(self.rows):\n            s += (' ' if row == 0 else Maze.ch)\n            for col in range(self.cols):\n                s += ' '\n                s += (Maze.ch if self.right[row*self.cols + col] else ' ')\n            s += '\\n' + Maze.ch\n            for col in range(self.cols):\n                s += ((Maze.ch * 2) if self.bot[row*self.cols + col] else (' ' + Maze.ch))\n            s += '\\n'\n        \n        return s\n        \n# main function\ndef main_solution(rows, cols):\n    # Convert input to the required format for the Maze class\n    maze_rows = rows // 2\n    maze_cols = cols // 2\n    \n    # Generate the maze\n    maze = Maze(maze_rows, maze_cols)\n    \n    # Convert the maze representation to a JSON serializable format\n    maze_repr = repr(maze)\n    \n    # Return the maze representation\n    return maze_repr", "input_generator": "import random\n\ndef input_generator():\n    rows = random.choice([4, 6, 8, 10, 12, 14, 16, 18, 20])\n    cols = random.choice([4, 6, 8, 10, 12, 14, 16, 18, 20])\n    return {'rows': rows, 'cols': cols}", "io_pairs": [{"input": {"rows": 12, "cols": 4}, "output": "XXXXX\n    X\nX X X\nX X X\nX XXX\nX   X\nXXX X\nX   X\nXXX X\nX   X\nX XXX\nX    \nXXXXX\n"}, {"input": {"rows": 4, "cols": 12}, "output": "XXXXXXXXXXXXX\n    X X     X\nX XXX XXX XXX\nX            \nXXXXXXXXXXXXX\n"}, {"input": {"rows": 6, "cols": 4}, "output": "XXXXX\n    X\nXXX X\nX   X\nX XXX\nX    \nXXXXX\n"}, {"input": {"rows": 10, "cols": 6}, "output": "XXXXXXX\n  X X X\nX X X X\nX X   X\nX X XXX\nX     X\nXXX XXX\nX   X X\nX XXX X\nX      \nXXXXXXX\n"}, {"input": {"rows": 4, "cols": 16}, "output": "XXXXXXXXXXXXXXXXX\n  X   X         X\nX XXX X XXXXX X X\nX           X X  \nXXXXXXXXXXXXXXXXX\n"}, {"input": {"rows": 8, "cols": 6}, "output": "XXXXXXX\n      X\nX XXXXX\nX X   X\nX XXX X\nX     X\nXXXXX X\nX      \nXXXXXXX\n"}, {"input": {"rows": 4, "cols": 6}, "output": "XXXXXXX\n      X\nXXXXX X\nX      \nXXXXXXX\n"}, {"input": {"rows": 4, "cols": 4}, "output": "XXXXX\n  X X\nX X X\nX    \nXXXXX\n"}, {"input": {"rows": 6, "cols": 10}, "output": "XXXXXXXXXXX\n    X   X X\nXXX X X X X\nX   X X   X\nXXX X X X X\nX     X X  \nXXXXXXXXXXX\n"}, {"input": {"rows": 8, "cols": 4}, "output": "XXXXX\n  X X\nX X X\nX   X\nX XXX\nX X X\nX X X\nX    \nXXXXX\n"}], "error_log": []}
{"context": "In a historical reenactment of the Josephus problem, a group of soldiers forms a circle. Starting from a designated soldier, every k-th soldier is eliminated until only one remains. Given the number of soldiers `n` and the spacing `k`, in what order do the soldiers get eliminated?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of soldiers in the circle, must be at least 2.\n  `k` (int): The spacing between victims, must be between 1 and `n`.\n\nOutput:\n  `return` (list of int): A list representing the order in which soldiers die, starting from the first soldier killed to the last remaining soldier.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\nclass Soldier:\n    def __init__(self, number):\n        self.number = number\n        self.next = None\n        self.prev = None\n\n    def kill(self):\n        # Splice myself out of the circle.\n        self.prev.next = self.next\n        self.next.prev = self.prev\n        return self.number\n\nclass Army:\n    def __init__(self, n):\n        self.remaining = n\n        self.victim = Soldier(1)\n        self.victim.next = self.victim\n        self.victim.prev = self.victim\n        for i in range(2, n+1):\n            new = Soldier(i)\n            new.next = self.victim.next\n            new.prev = self.victim\n            self.victim.next.prev = new\n            self.victim.next = new\n            self.victim = new\n\n    def advance(self, k):\n        for i in range(k):\n            self.victim = self.victim.next\n\n    def kill_all(self, skip):\n        death_order = []\n        while self.remaining > 1:\n            self.advance(skip)\n            previous = self.victim.prev\n            death_order.append(self.victim.kill())\n            self.victim = previous\n            self.remaining -= 1\n        death_order.append(self.victim.kill())\n        return death_order\n\n# main function\ndef main_solution(n, k):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    army = Army(n)\n    death_order = army.kill_all(k)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return death_order", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(5, 100)\n    k = random.randint(1, n - 1)\n    return {'n': n, 'k': k}", "io_pairs": [{"input": {"n": 17, "k": 11}, "output": [11, 5, 17, 13, 9, 7, 6, 8, 12, 16, 4, 2, 3, 15, 10, 14, 1]}, {"input": {"n": 11, "k": 2}, "output": [2, 4, 6, 8, 10, 1, 5, 9, 3, 11, 7]}, {"input": {"n": 16, "k": 3}, "output": [3, 6, 9, 12, 15, 2, 7, 11, 16, 5, 13, 4, 14, 10, 1, 8]}, {"input": {"n": 9, "k": 5}, "output": [5, 1, 7, 4, 3, 6, 9, 2, 8]}, {"input": {"n": 14, "k": 10}, "output": [10, 6, 3, 1, 14, 2, 5, 9, 4, 13, 8, 11, 7, 12]}, {"input": {"n": 13, "k": 10}, "output": [10, 7, 5, 4, 6, 9, 13, 8, 3, 12, 1, 11, 2]}, {"input": {"n": 5, "k": 1}, "output": [1, 2, 3, 4, 5]}, {"input": {"n": 9, "k": 1}, "output": [1, 2, 3, 4, 5, 6, 7, 8, 9]}, {"input": {"n": 9, "k": 3}, "output": [3, 6, 9, 4, 8, 5, 2, 7, 1]}, {"input": {"n": 9, "k": 4}, "output": [4, 8, 3, 9, 6, 5, 7, 2, 1]}], "error_log": []}
{"context": "Given a function \\( f(x) = e^{-x} + x^2 \\), we want to approximate it using a cubic spline interpolation. How does the interpolated value of the cubic spline at \\( x = 0.5 \\) change as the number of nodes used for interpolation varies?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of nodes to use for the cubic spline interpolation.\n\nOutput:\n  `return` (dict): A dictionary containing the key `\"spline_value\"` with the value being a float representing the interpolated value of the cubic spline at `x = 0.5`.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\n# main function\ndef main_solution(n):\n    # Convert the input to the required format\n    n = int(n)\n    \n    # Generate nodes and values\n    nodes = np.linspace(0.0, 1.0, n)\n    values = np.exp(-nodes) + nodes**2\n    \n    # Create the cubic spline\n    cs = CubicSpline(nodes, values, bc_type='natural')\n    \n    # Evaluate the spline at a specific point (e.g., 0.5)\n    spline_value = cs(0.5)\n    \n    # Return the result as a JSON serializable output\n    return {\"spline_value\": float(spline_value)}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    n = random.randint(2, 20)\n    return {\"n\": n}", "io_pairs": [{"input": {"n": 8}, "output": {"spline_value": 0.8564336133817924}}, {"input": {"n": 17}, "output": {"spline_value": 0.8565306597126334}}, {"input": {"n": 10}, "output": {"spline_value": 0.8565460453616552}}, {"input": {"n": 3}, "output": {"spline_value": 0.8565306597126334}}, {"input": {"n": 9}, "output": {"spline_value": 0.8565306597126334}}, {"input": {"n": 14}, "output": {"spline_value": 0.8565311422625717}}, {"input": {"n": 18}, "output": {"spline_value": 0.85653066339697}}, {"input": {"n": 7}, "output": {"spline_value": 0.8565306597126334}}, {"input": {"n": 20}, "output": {"spline_value": 0.8565306427573542}}, {"input": {"n": 13}, "output": {"spline_value": 0.8565306597126334}}], "error_log": []}
{"context": "In the game of Mastermind, a player tries to guess a secret 6-digit code with all distinct digits. After each guess, the player is told how many digits in the guess correctly match their location in the secret code. Given a sequence of guesses and their corresponding scores, what are the possible secret codes that could have produced these results?\n\nThe input and output requirements are as follows:\n\nInput:\n  `guesses_and_scores` (dict): A dictionary where each key is a 6-digit number (int) representing a guess, and each value is an integer representing the number of digits that correctly matched their location in the secret code.\n\nOutput:\n  `return` (dict): A dictionary with a single key \"possible_codes\" whose value is a list of integers representing all possible 6-digit secret codes that could have produced the given guesses and scores.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef count_matching(a, b):\n    a, b = str(a), str(b)\n    return sum([1 for i in range(min(len(a), len(b))) if a[i] == b[i]])\n\n# main function\ndef main_solution(guesses_and_scores):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = []\n\n    for possible in range(100_000, 999_999):\n        if len(set(str(possible))) != 6:\n            continue\n\n        all_match = True\n\n        for sample, sample_matches in guesses_and_scores.items():\n            if count_matching(possible, sample) != sample_matches:\n                all_match = False\n                break\n\n        if all_match:\n            result.append(possible)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"possible_codes\": result}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random 6-digit number with all unique digits as the secret code\n    digits = random.sample(range(10), 6)\n    secret_code = int(''.join(map(str, digits)))\n    \n    # Generate 1 to 5 random guesses and their matching scores\n    num_guesses = random.randint(1, 5)\n    guesses_and_scores = {}\n    \n    for _ in range(num_guesses):\n        # Generate a random 6-digit guess (may or may not have unique digits)\n        guess = random.randint(100000, 999999)\n        # Calculate the matching score with the secret code\n        matches = sum(1 for a, b in zip(str(secret_code), str(guess)) if a == b)\n        guesses_and_scores[guess] = matches\n    \n    return {\"guesses_and_scores\": guesses_and_scores}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a certain amount of cents and a set of coin denominations, how many unique ways can you represent the total amount of cents using the available coin sizes?\n\nThe input and output requirements are as follows:\n\nInput:\n  `cents` (int): The total amount of cents to be represented using the given coin sizes.\n  `sizes` (list of int): A list of integers representing the denominations of the coins available, sorted in descending order.\n\nOutput:\n  `return` (int): The number of unique ways to represent the total amount of cents using the given coin sizes.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# main function\ndef main_solution(cents, sizes):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = 0\n\n  def combinations(remaining, j):\n      nonlocal result\n      current_value = sizes[j]\n      if remaining == 0 or j == 0:\n          result += 1\n          return\n      for i in range(int(remaining / current_value) + 1):\n          combinations(remaining - i * current_value, j - 1)\n\n  combinations(cents, len(sizes) - 1)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "input_generator": "import random\n\ndef input_generator():\n    cents = random.randint(1, 100)\n    num_sizes = random.randint(1, 5)\n    sizes = sorted(random.sample(range(1, 101), num_sizes), reverse=True)\n    return {'cents': cents, 'sizes': sizes}", "io_pairs": [{"input": {"cents": 21, "sizes": [74, 24]}, "output": 1}, {"input": {"cents": 71, "sizes": [68, 37, 25, 21]}, "output": 12}, {"input": {"cents": 64, "sizes": [53]}, "output": 1}, {"input": {"cents": 3, "sizes": [62, 38, 36, 28, 3]}, "output": 2}, {"input": {"cents": 37, "sizes": [10]}, "output": 1}, {"input": {"cents": 69, "sizes": [71, 27]}, "output": 3}, {"input": {"cents": 89, "sizes": [38, 31, 16, 11, 4]}, "output": 382}, {"input": {"cents": 97, "sizes": [98, 74, 35, 16, 15]}, "output": 47}, {"input": {"cents": 71, "sizes": [74, 67, 38]}, "output": 3}, {"input": {"cents": 81, "sizes": [29, 19]}, "output": 5}], "error_log": []}
{"context": "In a game of chess, a board is set up with a variety of pieces placed at random positions. Each piece has the ability to attack other pieces based on its movement rules. Given the size of the board and the positions and types of the pieces, what is the total number of friendly pieces that can be attacked (friendly fire) and the total number of enemy pieces that can be attacked (kills)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_size` (int): The size of the board (e.g., 8 for an 8x8 board).\n  `pieces` (list of dict): A list of dictionaries representing the pieces on the board. Each dictionary contains:\n    - `type` (str): The type of the piece (\"Queen\", \"Rook\", \"Bishop\", \"Knight\").\n    - `color` (bool): The color of the piece (True for white, False for black).\n    - `x` (int): The x-coordinate of the piece on the board.\n    - `y` (int): The y-coordinate of the piece on the board.\n\nOutput:\n  `return` (dict): A dictionary containing the total friendly fire and kills.\n    - `friendly_fire` (int): The total number of friendly pieces that can be attacked by other pieces on the board.\n    - `kills` (int): The total number of enemy pieces that can be attacked by other pieces on the board.", "reference_code": "# import necessary packages\nfrom random import randint, getrandbits\nimport pickle\n\n# all class and function definitions in the code file, if any\nclass Board:\n    def __init__(self, size):\n        self.__size = size\n        self.__pieces = []\n\n    @property\n    def size(self):\n        return self.__size\n\n    @property\n    def pieces(self):\n        return self.__pieces\n\n    def add_piece(self, piece):\n        self.pieces.append(piece)\n\n    def is_placement_valid(self, x, y):\n        if x < 0 or x >= self.size or y < 0 or y >= self.size:\n            return False\n        for placed_piece in self.pieces:\n            if placed_piece.x == x and placed_piece.y == y:\n                return False\n        return True\n\n    def conflict_resolve(self):\n        for i in range(len(self.pieces)):\n            for j in range(i + 1, len(self.pieces)):\n                while (self.pieces[i].x == self.pieces[j].x and self.pieces[i].y == self.pieces[j].y):\n                    self.pieces[i].random_move()\n\n    def count_total_targets(self):\n        ff_tot = 0  # ff = friendly fire\n        kill_tot = 0\n        for piece in self.pieces:\n            ff, kill = piece.count_targets()\n            ff_tot += ff\n            kill_tot += kill\n        return ff_tot, kill_tot\n\nclass Piece:\n    def __init__(self, board, color, x, y):\n        self._board = board\n        self._color = color  # True = white\n        self._x = x\n        self._y = y\n\n    @property\n    def board(self):\n        return self._board\n\n    @board.setter\n    def board(self, new_board):\n        self._board = new_board\n\n    @property\n    def color(self):\n        return self._color\n\n    @property\n    def x(self):\n        return self._x\n\n    @x.setter\n    def x(self, new_x):\n        self._x = new_x\n\n    @property\n    def y(self):\n        return self._y\n\n    @y.setter\n    def y(self, new_y):\n        self._y = new_y\n\n    def move(self, x, y):\n        if self.board.is_placement_valid(x, y):\n            self.x = x\n            self.y = y\n        else:\n            raise ValueError(\"Piece's position isn't valid\")\n\n    def random_move(self):\n        while (True):\n            try:\n                self.move(randint(0, self.board.size - 1),\n                          randint(0, self.board.size - 1))\n                break\n            except:\n                pass\n\ndef count_hv_targets(board, piece):\n    ff = 0\n    kill = 0\n    s_check = True  # Whether we should continue checking south\n    n_check = True\n    w_check = True\n    e_check = True\n    for target in board.pieces:\n        for i in range(1, board.size):\n            if piece.x - i >= 0 and s_check:\n                if target.x == piece.x - i and target.y == piece.y:\n                    if target.color == piece.color:\n                        ff += 1\n                    else:\n                        kill += 1\n                    s_check = False\n                    continue\n            if piece.x + i < board.size and n_check:\n                if target.x == piece.x + i and target.y == piece.y:\n                    if target.color == piece.color:\n                        ff += 1\n                    else:\n                        kill += 1\n                    n_check = False\n                    continue\n            if piece.y - i >= 0 and w_check:\n                if target.x == piece.x and target.y == piece.y - i:\n                    if target.color == piece.color:\n                        ff += 1\n                    else:\n                        kill += 1\n                    w_check = False\n                    continue\n            if piece.y + i < board.size and e_check:\n                if target.x == piece.x and target.y == piece.y + i:\n                    if target.color == piece.color:\n                        ff += 1\n                    else:\n                        kill += 1\n                    e_check = False\n    return ff, kill\n\ndef count_diag_targets(board, piece):\n    ff = 0\n    kill = 0\n    sw_check = True  # Whether we should continue checking southwest\n    nw_check = True\n    se_check = True\n    ne_check = True\n    for target in board.pieces:\n        for i in range(1, board.size):\n            if piece.x - i >= 0:\n                if piece.y - i >= 0 and sw_check:\n                    if target.x == piece.x - i and target.y == piece.y - i:\n                        if target.color == piece.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        sw_check = False\n                        continue\n                if piece.y + i < board.size and nw_check:\n                    if target.x == piece.x - i and target.y == piece.y + i:\n                        if target.color == piece.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        nw_check = False\n                        continue\n            if piece.x + i < board.size:\n                if piece.y - i >= 0 and se_check:\n                    if target.x == piece.x + i and target.y == piece.y - i:\n                        if target.color == piece.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        se_check = False\n                        continue\n                if piece.y + i < board.size and ne_check:\n                    if target.x == piece.x + i and target.y == piece.y + i:\n                        if target.color == piece.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        ne_check = False\n    return ff, kill\n\nclass Queen(Piece):\n    def __init__(self, board, color, x, y):\n        Piece.__init__(self, board, color, x, y)\n\n    def count_targets(self):\n        ff_hv, kill_hv = count_hv_targets(self.board, self)\n        ff_diag, kill_diag = count_diag_targets(self.board, self)\n        return ff_hv + ff_diag, kill_hv + kill_diag\n\nclass Rook(Piece):\n    def __init__(self, board, color, x, y):\n        Piece.__init__(self, board, color, x, y)\n\n    def count_targets(self):\n        return count_hv_targets(self.board, self)\n\nclass Bishop(Piece):\n    def __init__(self, board, color, x, y):\n        Piece.__init__(self, board, color, x, y)\n\n    def count_targets(self):\n        return count_diag_targets(self.board, self)\n\nclass Knight(Piece):\n    def __init__(self, board, color, x, y):\n        Piece.__init__(self, board, color, x, y)\n\n    def count_targets(self):\n        ff = 0\n        kill = 0\n        for target in self.board.pieces:\n            if target == self:\n                continue\n            if self.x - 2 >= 0:\n                if self.y - 1 >= 0:\n                    if target.x == self.x - 2 and target.y == self.y - 1:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n                if self.y + 1 < self.board.size:\n                    if target.x == self.x - 2 and target.y == self.y + 1:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n            if self.x - 1 >= 0:\n                if self.y - 2 >= 0:\n                    if target.x == self.x - 1 and target.y == self.y - 2:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n                if self.y + 2 < self.board.size:\n                    if target.x == self.x - 1 and target.y == self.y + 2:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n            if self.x + 1 < self.board.size:\n                if self.y - 2 >= 0:\n                    if target.x == self.x + 1 and target.y == self.y - 2:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n                if self.y + 2 < self.board.size:\n                    if target.x == self.x + 1 and target.y == self.y + 2:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n            if self.x + 2 < self.board.size:\n                if self.y - 1 >= 0:\n                    if target.x == self.x + 2 and target.y == self.y - 1:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n                if self.y + 1 < self.board.size:\n                    if target.x == self.x + 2 and target.y == self.y + 1:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n        return ff, kill\n\n# main function\ndef main_solution(board_size, pieces):\n    # Convert JSON serializable inputs to original input variables\n    board = Board(board_size)\n    for piece in pieces:\n        piece_class = None\n        if piece[\"type\"] == \"Queen\":\n            piece_class = Queen\n        elif piece[\"type\"] == \"Rook\":\n            piece_class = Rook\n        elif piece[\"type\"] == \"Bishop\":\n            piece_class = Bishop\n        elif piece[\"type\"] == \"Knight\":\n            piece_class = Knight\n        board.add_piece(piece_class(board, piece[\"color\"], piece[\"x\"], piece[\"y\"]))\n\n    # Resolve conflicts and count targets\n    board.conflict_resolve()\n    ff_tot, kill_tot = board.count_total_targets()\n\n    # Convert outputs to JSON serializable format\n    return {\"friendly_fire\": ff_tot, \"kills\": kill_tot}", "input_generator": "import random\nfrom random import randint, choice\n\ndef input_generator():\n    board_size = random.randint(4, 10)\n    num_pieces = random.randint(2, min(10, board_size * board_size // 2))\n    piece_types = [\"Queen\", \"Rook\", \"Bishop\", \"Knight\"]\n    pieces = []\n    \n    for _ in range(num_pieces):\n        piece_type = choice(piece_types)\n        color = random.choice([True, False])\n        x = randint(0, board_size - 1)\n        y = randint(0, board_size - 1)\n        pieces.append({\n            \"type\": piece_type,\n            \"color\": color,\n            \"x\": x,\n            \"y\": y\n        })\n    \n    return {\n        \"board_size\": board_size,\n        \"pieces\": pieces\n    }", "io_pairs": [], "error_log": []}
{"context": "In a game of Pig, two players take turns rolling a die. Each player has a strategy to decide when to hold based on the number of pending points. Given two strategies with different hold thresholds, which strategy will win the game?\n\nThe input and output requirements are as follows:\n\nInput:\n  `strategy1_hold_threshold` (int): The threshold for the first player's strategy to hold. If the pending points are greater than or equal to this threshold, the player will hold.\n  `strategy2_hold_threshold` (int): The threshold for the second player's strategy to hold. If the pending points are greater than or equal to this threshold, the player will hold.\n\nOutput:\n  `return` (str): The name of the winning strategy. It will be in the format \"hold_at(X)\" where X is the hold threshold of the winning strategy.", "reference_code": "# import necessary packages\nimport random\nfrom functools import lru_cache\n\n# all class and function definitions in the code file, if any\npossible_moves = ['roll', 'hold']\nother = {1: 0, 0: 1}\ngoal = 50\n\ndef hold(state):\n    \"\"\"Apply the hold action to a state to yield a new state:\n    Reap the 'pending' points and it becomes the other player's turn.\"\"\"\n    (p, me, you, pending) = state\n    return (other[p], you, me + pending, 0)\n\ndef roll(state, d):\n    \"\"\"Apply the roll action to a state (and a die roll d) to yield a new state:\n    If d is 1, get 1 point (losing any accumulated 'pending' points),\n    and it is the other player's turn. If d > 1, add d to 'pending' points.\"\"\"\n    (p, me, you, pending) = state\n    if d == 1:\n        return (other[p], you, me + 1, 0)  # pig out; other player's turn\n    else:\n        return (p, me, you, pending + d)  # accumulate die roll in pending\n\ndef hold_at(x):\n    \"\"\"Return a strategy that holds if and only if \n    pending >= x or player reaches goal.\"\"\"\n    def strategy(state):\n        (p, me, you, pending) = state\n        return 'hold' if (pending >= x or me + pending >= goal) else 'roll'\n    strategy.__name__ = 'hold_at(%d)' % x\n    return strategy\n\ndef dierolls():\n    \"Generate die rolls.\"\n    while True:\n        yield random.randint(1, 6)\n\n@lru_cache(maxsize=None)\ndef Pwin3(me, you, pending):\n    \"The probability of winning for player with score me to you, and pending.\"\n    if me + pending >= goal:\n        return 1\n    elif you >= goal:\n        return 0\n    else:\n        Proll = (1 - Pwin3(you, me + 1, 0) +\n                 sum(Pwin3(me, you, pending + d) for d in (2, 3, 4, 5, 6))) / 6.\n        return (Proll if not pending else\n                max(Proll, 1 - Pwin3(you, me + pending, 0)))\n\ndef max_wins2(state):\n    \"The optimal pig strategy chooses an action with the highest win probability.\"\n    def Q_pig(state, action, Pwin):\n        if action == 'hold':\n            return 1 - Pwin(hold(state))\n        if action == 'roll':\n            return (1 - Pwin(roll(state, 1))\n                    + sum(Pwin(roll(state, d)) for d in (2, 3, 4, 5, 6))) / 6.\n        raise ValueError\n\n    def best_action(state, actions, Q, U):\n        def EU(action): return Q(state, action, U)\n        return max(actions(state), key=EU)\n\n    def pig_actions(state):\n        _, _, _, pending = state\n        return ['roll', 'hold'] if pending else ['roll']\n\n    return best_action(state, pig_actions, Q_pig, Pwin3)\n\n# main function\ndef main_solution(strategy1_hold_threshold, strategy2_hold_threshold):\n    \"\"\"Simulate a game of Pig between two strategies and return the winning strategy's name.\"\"\"\n    strategy1 = hold_at(strategy1_hold_threshold)\n    strategy2 = hold_at(strategy2_hold_threshold)\n    \n    def play_pig(A, B, rolls=dierolls()):\n        strategies = [A, B]\n        state = (0, 0, 0, 0)\n        while True:\n            (p, me, you, pending) = state\n            if me >= goal:\n                return strategies[p].__name__\n            elif you >= goal:\n                return strategies[other[p]].__name__\n            else:\n                action = strategies[p](state)\n                if action == 'hold':\n                    state = hold(state)\n                elif action == 'roll':\n                    state = roll(state, next(rolls))\n                else:\n                    return strategies[other[p]].__name__\n    \n    winner = play_pig(strategy1, strategy2)\n    return winner", "input_generator": "import random\n\ndef input_generator():\n    strategy1_hold_threshold = random.randint(1, 20)\n    strategy2_hold_threshold = random.randint(1, 20)\n    return {\n        'strategy1_hold_threshold': strategy1_hold_threshold,\n        'strategy2_hold_threshold': strategy2_hold_threshold\n    }", "io_pairs": [{"input": {"strategy1_hold_threshold": 9, "strategy2_hold_threshold": 18}, "output": "hold_at(18)"}, {"input": {"strategy1_hold_threshold": 16, "strategy2_hold_threshold": 7}, "output": "hold_at(16)"}, {"input": {"strategy1_hold_threshold": 1, "strategy2_hold_threshold": 1}, "output": "hold_at(1)"}, {"input": {"strategy1_hold_threshold": 3, "strategy2_hold_threshold": 3}, "output": "hold_at(3)"}, {"input": {"strategy1_hold_threshold": 3, "strategy2_hold_threshold": 6}, "output": "hold_at(6)"}, {"input": {"strategy1_hold_threshold": 7, "strategy2_hold_threshold": 3}, "output": "hold_at(7)"}, {"input": {"strategy1_hold_threshold": 1, "strategy2_hold_threshold": 2}, "output": "hold_at(1)"}, {"input": {"strategy1_hold_threshold": 2, "strategy2_hold_threshold": 13}, "output": "hold_at(13)"}, {"input": {"strategy1_hold_threshold": 11, "strategy2_hold_threshold": 10}, "output": "hold_at(11)"}, {"input": {"strategy1_hold_threshold": 4, "strategy2_hold_threshold": 10}, "output": "hold_at(10)"}], "error_log": []}
{"context": "Given a number `n_factorial`, what is the factorial of `n_factorial`? Additionally, for a Hanoi Tower problem with `n_hanoi` disks and towers labeled `a`, `b`, and `c`, what are the steps required to move all disks from tower `a` to tower `c`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n_factorial` (int): The number for which the factorial is to be calculated.\n  `n_hanoi` (int): The number of disks in the Hanoi Tower problem.\n  `a` (str): The label of the first tower in the Hanoi Tower problem.\n  `b` (str): The label of the second tower in the Hanoi Tower problem.\n  `c` (str): The label of the third tower in the Hanoi Tower problem.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `factorial_result` (int): The result of the factorial calculation.\n    - `hanoi_steps` (list of str): A list of strings representing the steps to solve the Hanoi Tower problem. Each string is in the format \"source --> destination\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef fact_iter(num, product):\n    if num == 1:\n        return product\n    return fact_iter(num - 1, num * product)\n\ndef hanoi_steps(n, a, b, c):\n    steps = []\n    def hanoi(n, a, b, c):\n        if n == 1:\n            steps.append(f\"{a} --> {c}\")\n        else:\n            hanoi(n - 1, a, c, b)\n            steps.append(f\"{a} --> {c}\")\n            hanoi(n - 1, b, a, c)\n    hanoi(n, a, b, c)\n    return steps\n\n# main function\ndef main_solution(n_factorial, n_hanoi, a, b, c):\n    # Calculate factorial\n    factorial_result = fact_iter(n_factorial, 1)\n    \n    # Calculate Hanoi Tower steps\n    hanoi_result = hanoi_steps(n_hanoi, a, b, c)\n    \n    # Return results\n    return {\n        \"factorial_result\": factorial_result,\n        \"hanoi_steps\": hanoi_result\n    }", "input_generator": "import random\n\ndef input_generator():\n    n_factorial = random.randint(1, 10)\n    n_hanoi = random.randint(1, 5)\n    pegs = ['A', 'B', 'C']\n    a, b, c = pegs\n    return {\n        \"n_factorial\": n_factorial,\n        \"n_hanoi\": n_hanoi,\n        \"a\": a,\n        \"b\": b,\n        \"c\": c\n    }", "io_pairs": [{"input": {"n_factorial": 6, "n_hanoi": 2, "a": "A", "b": "B", "c": "C"}, "output": {"factorial_result": 720, "hanoi_steps": ["A --> B", "A --> C", "B --> C"]}}, {"input": {"n_factorial": 10, "n_hanoi": 2, "a": "A", "b": "B", "c": "C"}, "output": {"factorial_result": 3628800, "hanoi_steps": ["A --> B", "A --> C", "B --> C"]}}, {"input": {"n_factorial": 4, "n_hanoi": 2, "a": "A", "b": "B", "c": "C"}, "output": {"factorial_result": 24, "hanoi_steps": ["A --> B", "A --> C", "B --> C"]}}, {"input": {"n_factorial": 8, "n_hanoi": 1, "a": "A", "b": "B", "c": "C"}, "output": {"factorial_result": 40320, "hanoi_steps": ["A --> C"]}}, {"input": {"n_factorial": 3, "n_hanoi": 1, "a": "A", "b": "B", "c": "C"}, "output": {"factorial_result": 6, "hanoi_steps": ["A --> C"]}}, {"input": {"n_factorial": 4, "n_hanoi": 3, "a": "A", "b": "B", "c": "C"}, "output": {"factorial_result": 24, "hanoi_steps": ["A --> C", "A --> B", "C --> B", "A --> C", "B --> A", "B --> C", "A --> C"]}}, {"input": {"n_factorial": 3, "n_hanoi": 2, "a": "A", "b": "B", "c": "C"}, "output": {"factorial_result": 6, "hanoi_steps": ["A --> B", "A --> C", "B --> C"]}}, {"input": {"n_factorial": 1, "n_hanoi": 1, "a": "A", "b": "B", "c": "C"}, "output": {"factorial_result": 1, "hanoi_steps": ["A --> C"]}}, {"input": {"n_factorial": 9, "n_hanoi": 2, "a": "A", "b": "B", "c": "C"}, "output": {"factorial_result": 362880, "hanoi_steps": ["A --> B", "A --> C", "B --> C"]}}, {"input": {"n_factorial": 5, "n_hanoi": 1, "a": "A", "b": "B", "c": "C"}, "output": {"factorial_result": 120, "hanoi_steps": ["A --> C"]}}], "error_log": []}
{"context": "Given a system of two simultaneous congruences, where the first congruence is \\( x \\equiv b \\pmod{m} \\) and the second congruence is \\( x \\equiv c \\pmod{n} \\), what is the smallest positive integer solution \\( x \\) that satisfies both congruences?\n\nThe input and output requirements are as follows:\n\nInput:\n  `b` (int): The first remainder in the first congruence equation.\n  `m` (int): The first modulus in the first congruence equation.\n  `c` (int): The second remainder in the second congruence equation.\n  `n` (int): The second modulus in the second congruence equation.\nOutput:\n  `return` (int): The solution to the system of simultaneous congruences, which is a positive integer.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef linear_eq(a, b):\n    if b == 0:\n        return (a, 1, 0)\n    if a == 0:\n        return (b, 0, 1)\n\n    x = 1\n    g = a\n    v = 0\n    w = b\n\n    while w != 0:\n        q = g // w\n        t = g - q * w\n\n        s = x - q * v\n        x = v\n        g = w\n\n        v = s\n        w = t\n\n    y = (g - a * x) // b\n\n    while x <= 0:\n        x = x + b\n        y = y - a\n\n    return (g, x, y)\n\ndef solve_sim_congruence(b, m, c, n):\n    g, x, y = linear_eq(m, n)\n\n    y_1 = int((c - b) * x)\n\n    x_0 = y_1 * m + b\n\n    while x_0 < 0:\n        x_0 = x_0 + m * n\n\n    return x_0\n\n# main function\ndef main_solution(b, m, c, n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = solve_sim_congruence(b, m, c, n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate random values for b and c within a reasonable range\n    b = random.randint(-100, 100)\n    c = random.randint(-100, 100)\n    \n    # Generate random values for m and n, ensuring they are positive and not too large\n    m = random.randint(1, 100)\n    n = random.randint(1, 100)\n    \n    return {'b': b, 'm': m, 'c': c, 'n': n}", "io_pairs": [{"input": {"b": 13, "m": 23, "c": 48, "n": 44}, "output": 18528}, {"input": {"b": -45, "m": 83, "c": 80, "n": 68}, "output": 612080}, {"input": {"b": -57, "m": 30, "c": 8, "n": 11}, "output": 13593}, {"input": {"b": -93, "m": 32, "c": 57, "n": 77}, "output": 311907}, {"input": {"b": -3, "m": 59, "c": 57, "n": 42}, "output": 17697}, {"input": {"b": -27, "m": 68, "c": -49, "n": 72}, "output": 1469}, {"input": {"b": 1, "m": 95, "c": -59, "n": 73}, "output": 5416}, {"input": {"b": 96, "m": 22, "c": -42, "n": 37}, "output": 624}, {"input": {"b": -40, "m": 68, "c": 85, "n": 24}, "output": 195460}, {"input": {"b": -50, "m": 70, "c": 61, "n": 44}, "output": 302980}], "error_log": []}
{"context": "Given a list of integers, we need to construct a Binary Search Tree (BST) and perform two operations:\n1. Determine if a specific integer is present in the BST.\n2. Find the maximum value stored in the BST.\n\nWhat is the result of checking if a specific integer is present in the BST and finding the maximum value in the BST?\n\nThe input and output requirements are as follows:\n\nInput:\n- `values` (list of integers): A list of integers representing the values to be inserted into the Binary Search Tree (BST).\n- `target` (integer): An integer value to be searched in the BST.\n\nOutput:\n- `return` (dictionary): A dictionary containing the following keys:\n  - `contains_target` (boolean): `True` if the target value is found in the BST, `False` otherwise.\n  - `max_value` (integer): The maximum value found in the BST.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Queue:\n    def __init__(self):\n        self.size = 0\n        self.storage = []\n\n    def __len__(self):\n        return len(self.storage)\n\n    def enqueue(self, value):\n        self.storage.append(value)\n        self.size += 1\n\n    def dequeue(self, index=0):\n        if len(self.storage) == 0:\n            return None\n        self.size -= 1\n        return self.storage.pop(index)\n\nclass Stack:\n    def __init__(self):\n        self.size = 0\n        self.storage = []\n\n    def __len__(self):\n        return len(self.storage)\n\n    def push(self, value):\n        self.storage.append(value)\n        self.size += 1\n\n    def pop(self):\n        if len(self.storage) == 0:\n            return None\n        self.size -= 1\n        return self.storage.pop()\n\nclass BSTNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n    def insert(self, value):\n        cur_node = self\n        new_node = BSTNode(value)\n        while True:\n            if new_node.value >= cur_node.value:\n                if cur_node.right is None:\n                    cur_node.right = new_node\n                    break\n                cur_node = cur_node.right\n            elif new_node.value < cur_node.value:\n                if cur_node.left is None:\n                    cur_node.left = new_node\n                    break\n                cur_node = cur_node.left\n\n    def contains(self, target):\n        cur_node = self\n        while True:\n            if target == cur_node.value:\n                return True\n            elif target > cur_node.value:\n                if cur_node.right is None:\n                    return False\n                cur_node = cur_node.right\n            elif target < cur_node.value:\n                if cur_node.left is None:\n                    return False\n                cur_node = cur_node.left\n            else:\n                return False\n\n    def get_max(self):\n        cur_node = self\n        while cur_node.right is not None:\n            cur_node = cur_node.right\n        return cur_node.value\n\n    def for_each(self, fn):\n        fn(self.value)\n        if self.left:\n            self.left.for_each(fn)\n        if self.right:\n            self.right.for_each(fn)\n\n    def in_order_print(self):\n        if self.left:\n            self.left.in_order_print()\n        print(self.value)\n        if self.right:\n            self.right.in_order_print()\n\n    def bft_print(self):\n        q = Queue()\n        q.enqueue(self)\n        while q.size != 0:\n            for i, node in enumerate(q.storage):\n                print(node.value)\n                if node.left is not None:\n                    q.enqueue(node.left)\n                if node.right is not None:\n                    q.enqueue(node.right)\n                q.dequeue(i)\n\n    def dft_print(self):\n        s = Stack()\n        s.push(self)\n        while s.__len__() != 0:\n            for node in s.storage:\n                if node.left is None:\n                    if node.right is not None:\n                        s.push(node.right)\n                if node.left is not None:\n                    s.push(node.left)\n                    if node.right is not None:\n                        s.push(node.right)\n                print(node.value)\n            s.pop()\n            return\n\n# main function\ndef main_solution(values, target):\n    # values: list of integers to be inserted into the BST\n    # target: integer to be searched in the BST\n    \n    # Create the BST and insert values\n    root = BSTNode(values[0])\n    for value in values[1:]:\n        root.insert(value)\n    \n    # Check if the target is in the BST\n    contains_target = root.contains(target)\n    \n    # Get the maximum value in the BST\n    max_value = root.get_max()\n    \n    # Return the results\n    return {\n        \"contains_target\": contains_target,\n        \"max_value\": max_value\n    }", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random list of integers for BST values\n    num_values = random.randint(5, 20)\n    values = [random.randint(1, 100) for _ in range(num_values)]\n    \n    # Randomly decide whether the target is in the list or not (50% chance)\n    if random.choice([True, False]):\n        target = random.choice(values)\n    else:\n        target = random.randint(1, 100)\n    \n    return {\n        \"values\": values,\n        \"target\": target\n    }", "io_pairs": [{"input": {"values": [50, 16, 49, 48, 32, 49, 59, 66], "target": 39}, "output": {"contains_target": false, "max_value": 66}}, {"input": {"values": [11, 3, 18, 54, 39, 22, 92, 81, 44, 55, 22, 70, 73, 20, 8, 94], "target": 75}, "output": {"contains_target": false, "max_value": 94}}, {"input": {"values": [72, 100, 16, 8, 70, 64, 27], "target": 8}, "output": {"contains_target": true, "max_value": 100}}, {"input": {"values": [96, 84, 61, 48, 1], "target": 1}, "output": {"contains_target": true, "max_value": 96}}, {"input": {"values": [16, 28, 42, 87, 2, 99, 69, 88, 28, 81, 76], "target": 57}, "output": {"contains_target": false, "max_value": 99}}, {"input": {"values": [84, 89, 15, 28, 31, 55, 23], "target": 23}, "output": {"contains_target": true, "max_value": 89}}, {"input": {"values": [19, 53, 81, 72, 96, 96, 76, 62, 15, 91, 89, 18], "target": 85}, "output": {"contains_target": false, "max_value": 96}}, {"input": {"values": [16, 44, 83, 96, 85, 30, 97, 95, 92, 2, 59, 45, 13, 26, 7, 83], "target": 58}, "output": {"contains_target": false, "max_value": 97}}, {"input": {"values": [90, 3, 16, 65, 22, 18, 79, 96, 16, 36, 34, 72, 89, 27, 38], "target": 53}, "output": {"contains_target": false, "max_value": 96}}, {"input": {"values": [50, 6, 10, 72, 56, 50, 97, 87], "target": 12}, "output": {"contains_target": false, "max_value": 97}}], "error_log": []}
{"context": "Given a series of log returns from a financial instrument, how can we estimate the parameters of a GARCH(1,1) model to understand the volatility dynamics of the returns? Specifically, what are the values of the parameters 'omega', 'gamma', and 'beta' that best fit the provided log returns data?\n\nThe input and output requirements are as follows:\n\nInput:\n  `returns` (list of float): A list of log returns. Each element in the list represents a single log return value.\n\nOutput:\n  `return` (dict): A dictionary containing the estimated parameters of the GARCH model. The keys are 'omega', 'gamma', and 'beta', each corresponding to a float value representing the estimated parameter.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# all class and function definitions in the code file, if any\nclass Garch:\n    \"\"\"Class implements Garch(1,1) model\"\"\"\n    def __init__(self, order: tuple = (1, 1), mean: str = 'const'):\n        \"\"\"Constructor to specify order of Garch and specify mean equation\"\"\"\n        self.mean = mean\n        self.order = order\n\n    def _loglikelihood(self, vol, a):\n        \"\"\"Returns the loglikelihood function of Garch(1,1) model\"\"\"\n        return 0.5 * (np.log(vol) + a @ a / vol).sum()\n\n    def _simulate_vol(self, r: np.ndarray, theta: np.ndarray = None) -> np.ndarray:\n        \"\"\"Simulates the garch(1,1) volatility model\"\"\"\n        n = r.shape[0]\n        vol = np.zeros(n)\n        vol[0] = r.var(ddof=1)\n        omega, gamma, beta = theta\n        for idx in range(1, n):\n            vol[idx] = omega + gamma * r[idx-1] + beta * vol[idx-1]\n        return vol\n\n    def _constraint(self, params):\n        \"\"\"Specify constraint for variance process\"\"\"\n        return 1 - (params[1] + params[2])\n\n    def _objective_func(self, guess: np.ndarray, r: np.ndarray) -> np.float64:\n        \"\"\"Objective function to be minimized\"\"\"\n        vol = self._simulate_vol(r=r, theta=guess)\n        f = self._loglikelihood(vol, a=r)\n        return f\n\n    def fit(self, r: np.ndarray) -> 'Garch':\n        \"\"\"Fits training data via quasi maximum likelihood\"\"\"\n        if self.mean:\n            a_t = r - r.mean()\n        else:\n            a_t = r\n        guess_params = np.array([0.1, 0.2, 0.3])\n        cons = {'type': 'ineq', 'fun': self._constraint}\n        self.theta = minimize(self._objective_func,\n                              guess_params,\n                              method='BFGS',\n                              options={'disp': True},\n                              args=(a_t),\n                              constraints=cons)['x']\n        return self\n\n# main function\ndef main_solution(returns: list) -> dict:\n    \"\"\"\n    Fits a GARCH(1,1) model to the provided returns data and returns the estimated parameters.\n\n    Args:\n        returns (list of float): A list of log returns.\n\n    Returns:\n        dict: A dictionary containing the estimated parameters of the GARCH model.\n              The keys are 'omega', 'gamma', and 'beta'.\n    \"\"\"\n    # Convert list to numpy array\n    returns_array = np.array(returns)\n    \n    # Initialize Garch model\n    garch_model = Garch()\n    \n    # Fit the model\n    garch_model.fit(returns_array)\n    \n    # Extract the estimated parameters\n    omega, gamma, beta = garch_model.theta\n    \n    # Return the parameters as a dictionary\n    return {\n        'omega': float(omega),\n        'gamma': float(gamma),\n        'beta': float(beta)\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate random length between 100 and 1000\n    n = random.randint(100, 1000)\n    \n    # Generate random returns with some volatility\n    returns = np.random.normal(0, 0.02, n).tolist()\n    \n    return {'returns': returns}", "io_pairs": [], "error_log": []}
{"context": "Given a range of numbers up to a certain limit, how many of these numbers have square roots whose continued fractions exhibit an odd period?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The upper limit for the numbers whose square roots' continued fractions are to be checked. It should be a positive integer.\n\nOutput:\n  `return` (int): The count of numbers up to `n` whose square roots' continued fractions have an odd period.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    Calculates the number of continued fractions for square roots of numbers up to n that have an odd period.\n    \n    Args:\n    n (int): The upper limit for the numbers whose square roots' continued fractions are to be checked.\n    \n    Returns:\n    int: The count of numbers up to n whose square roots' continued fractions have an odd period.\n    \"\"\"\n    def calc_period(n):\n        lim = int(math.sqrt(n))\n        loops = 0\n        d = 1\n        m = 0\n        a = lim\n        while a != 2 * lim:\n            try:\n                m = d * a - m\n                d = (n - m * m) // d\n                a = (lim + m) // d\n                loops += 1\n            except ZeroDivisionError:  # Catches perfect squares\n                return 0\n        return loops\n\n    total = 0\n    for i in range(1, n + 1):\n        if calc_period(i) % 2 == 1:\n            total += 1\n    return total", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(10, 1000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 436}, "output": 74}, {"input": {"n": 874}, "output": 134}, {"input": {"n": 575}, "output": 93}, {"input": {"n": 379}, "output": 66}, {"input": {"n": 964}, "output": 146}, {"input": {"n": 330}, "output": 57}, {"input": {"n": 98}, "output": 20}, {"input": {"n": 287}, "output": 50}, {"input": {"n": 538}, "output": 88}, {"input": {"n": 661}, "output": 106}], "error_log": []}
{"context": "Given the coordinates of two points on the Earth's surface, what is the distance between these two points in kilometers? The coordinates are provided in degrees for latitude and longitude.\n\nThe input and output requirements are as follows:\n\nInput:\n  `lat1` (float): Latitude of the first point in degrees.\n  `long1` (float): Longitude of the first point in degrees.\n  `lat2` (float): Latitude of the second point in degrees.\n  `long2` (float): Longitude of the second point in degrees.\n\nOutput:\n  `return` (float): The distance between the two points in kilometers.", "reference_code": "# import necessary packages\nfrom math import sin, cos, sqrt, atan2, radians\n\n# main function\ndef main_solution(lat1, long1, lat2, long2):\n    # Convert latitude and longitude from degrees to radians\n    lat1 = radians(lat1)\n    long1 = radians(long1)\n    lat2 = radians(lat2)\n    long2 = radians(long2)\n\n    # Calculate differences\n    dlong = long2 - long1\n    dlat = lat2 - lat1\n\n    # Haversine formula\n    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlong / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n\n    # Approximate radius of earth in km\n    R = 6373.0\n    distance = R * c\n\n    # Return the distance in kilometers\n    return distance", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random latitudes and longitudes within valid ranges\n    lat1 = random.uniform(-90, 90)\n    long1 = random.uniform(-180, 180)\n    lat2 = random.uniform(-90, 90)\n    long2 = random.uniform(-180, 180)\n    \n    return {\n        'lat1': lat1,\n        'long1': long1,\n        'lat2': lat2,\n        'long2': long2\n    }", "io_pairs": [{"input": {"lat1": -17.126558478365354, "long1": -46.77451681052298, "lat2": -24.924031662614638, "long2": -86.91146061772439}, "output": 4240.675842782109}, {"input": {"lat1": 40.33943308859568, "long1": -137.1080872253392, "lat2": -47.303547787859955, "long2": 100.85404939643416}, "output": 15414.799649044804}, {"input": {"lat1": -60.70990406135737, "long1": 55.01688753694853, "lat2": -29.89706484292497, "long2": -160.11209010136318}, "output": 9450.13138736265}, {"input": {"lat1": -74.26117197040867, "long1": -120.6829311069909, "lat2": 70.07249908099081, "long2": -137.78079767453238}, "output": 16099.091294756125}, {"input": {"lat1": 8.08812265988783, "long1": -4.38990639231335, "lat2": -67.10359388643245, "long2": -17.054949832695115}, "output": 8425.26640907115}, {"input": {"lat1": 58.70315203942994, "long1": -72.39314093296814, "lat2": 42.804919055390144, "long2": 112.76054552911864}, "output": 8720.62191357949}, {"input": {"lat1": 70.76365850738509, "long1": 62.44451829308048, "lat2": -12.413399642499954, "long2": -34.98740621586046}, "output": 11585.375716762837}, {"input": {"lat1": 30.70034505453752, "long1": 15.94077652175065, "lat2": -35.00711387139717, "long2": 117.36598745932173}, "output": 12860.399136930679}, {"input": {"lat1": 15.562457226467941, "long1": -44.545392186507684, "lat2": -38.25929747210373, "long2": -0.6576276616795838}, "output": 7533.209362297833}, {"input": {"lat1": 68.84399076841203, "long1": -5.199585909228233, "lat2": 5.883176000112471, "long2": -176.01164493582763}, "output": 11679.069964463344}], "error_log": []}
{"context": "Given a partially filled Tic Tac Toe board, determine the optimal next move for the current player or the outcome of the game if it has ended. What is the result of the game or the best move for the current player?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists of strings/None): A 3x3 grid representing the Tic Tac Toe board. Each cell can be `\"X\"`, `\"O\"`, or `None` (empty).\n\nOutput:\n  `return` (int/tuple): If the game is over, returns an integer representing the utility of the board (`1` if X wins, `-1` if O wins, `0` if it's a draw). If the game is still ongoing, returns a tuple representing the optimal next move for the current player (e.g., `(0, 1)`).", "reference_code": "# import necessary packages\nimport copy\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    CntX = sum(row.count(X) for row in board)\n    CntO = sum(row.count(O) for row in board)\n    return X if CntX == CntO else O\n\n# Function to get all possible actions\ndef actions(board):\n    return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}\n\n# Function to get the result of an action\ndef result(board, action):\n    new_board = copy.deepcopy(board)\n    new_board[action[0]][action[1]] = player(board)\n    return new_board\n\n# Function to determine the winner\ndef winner(board):\n    lines = [\n        [(0, 0), (0, 1), (0, 2)],\n        [(1, 0), (1, 1), (1, 2)],\n        [(2, 0), (2, 1), (2, 2)],\n        [(0, 0), (1, 0), (2, 0)],\n        [(0, 1), (1, 1), (2, 1)],\n        [(0, 2), (1, 2), (2, 2)],\n        [(0, 0), (1, 1), (2, 2)],\n        [(0, 2), (1, 1), (2, 0)],\n    ]\n    for line in lines:\n        if board[line[0][0]][line[0][1]] == board[line[1][0]][line[1][1]] == board[line[2][0]][line[2][1]] != EMPTY:\n            return board[line[0][0]][line[0][1]]\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or all(all(cell is not EMPTY for cell in row) for row in board)\n\n# Function to get the utility of the board\ndef utility(board):\n    win = winner(board)\n    if win == X:\n        return 1\n    elif win == O:\n        return -1\n    else:\n        return 0\n\n# Main function to solve the problem\ndef main_solution(board):\n    if terminal(board):\n        return utility(board)\n    else:\n        return minimax(board)\n\n# Function to determine the optimal action using minimax algorithm\ndef minimax(board):\n    if terminal(board):\n        return None\n    if player(board) == X:\n        return max_value(board, float(\"-inf\"), float(\"inf\"))[1]\n    else:\n        return min_value(board, float(\"-inf\"), float(\"inf\"))[1]\n\n# Helper function for maximizing player\ndef max_value(board, alpha, beta):\n    if terminal(board):\n        return [utility(board), None]\n    v = float(\"-inf\")\n    move = None\n    for action in actions(board):\n        test = min_value(result(board, action), alpha, beta)[0]\n        if test > v:\n            v = test\n            move = action\n        alpha = max(alpha, v)\n        if alpha >= beta:\n            break\n    return [v, move]\n\n# Helper function for minimizing player\ndef min_value(board, alpha, beta):\n    if terminal(board):\n        return [utility(board), None]\n    v = float(\"inf\")\n    move = None\n    for action in actions(board):\n        test = max_value(result(board, action), alpha, beta)[0]\n        if test < v:\n            v = test\n            move = action\n        beta = min(beta, v)\n        if alpha >= beta:\n            break\n    return [v, move]", "input_generator": "import random\n\ndef input_generator():\n    board = [[None for _ in range(3)] for _ in range(3)]\n    symbols = ['X', 'O', None]\n    for i in range(3):\n        for j in range(3):\n            board[i][j] = random.choice(symbols)\n    \n    # Ensure the board is not terminal (optional, but adds variety)\n    while terminal(board):\n        board = [[None for _ in range(3)] for _ in range(3)]\n        for i in range(3):\n            for j in range(3):\n                board[i][j] = random.choice(symbols)\n    \n    return {'board': board}\n\ndef terminal(board):\n    # Check rows\n    for row in board:\n        if row[0] == row[1] == row[2] and row[0] is not None:\n            return True\n    # Check columns\n    for col in range(3):\n        if board[0][col] == board[1][col] == board[2][col] and board[0][col] is not None:\n            return True\n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] is not None:\n        return True\n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] is not None:\n        return True\n    # Check if board is full\n    if all(cell is not None for row in board for cell in row):\n        return True\n    return False", "io_pairs": [{"input": {"board": [[null, null, "O"], ["X", null, "X"], ["X", "X", null]]}, "output": [0, 1]}, {"input": {"board": [["X", null, "O"], [null, "O", null], [null, "X", "X"]]}, "output": [2, 0]}, {"input": {"board": [[null, null, "O"], [null, "O", "X"], ["X", null, "X"]]}, "output": [2, 1]}, {"input": {"board": [["X", null, null], [null, "X", "X"], [null, "X", null]]}, "output": [0, 1]}, {"input": {"board": [["X", null, null], ["O", "O", null], ["X", "O", "X"]]}, "output": [0, 1]}, {"input": {"board": [[null, "X", "O"], [null, "X", "O"], ["O", null, null]]}, "output": [1, 0]}, {"input": {"board": [[null, null, "O"], ["X", null, "X"], ["X", null, "X"]]}, "output": [0, 1]}, {"input": {"board": [[null, null, "O"], [null, "O", "X"], ["X", null, "O"]]}, "output": [0, 1]}, {"input": {"board": [["O", "O", null], ["O", null, "O"], ["X", null, null]]}, "output": [1, 1]}, {"input": {"board": [["O", "X", null], ["X", "O", "X"], ["X", "O", null]]}, "output": [2, 2]}], "error_log": []}
{"context": "Given a range of integers, what is the largest 1 to 9 pandigital 9-digit number that can be formed by concatenating the products of an integer within that range with (1, 2, ..., n) where n > 1?\n\nThe input and output requirements are as follows:\n\nInput:\n  `max_value` (int): The maximum value for the integer to be multiplied. It should be a positive integer.\n\nOutput:\n  `return` (int): The largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1, 2, ..., n) where n > 1.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef isPandigital(n):\n    pans = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    while n > 0:\n        r = n % 10\n\n        if r == 0:\n            return False\n\n        if pans[r] > 0:\n            return False\n\n        pans[r] = 1\n        n //= 10\n    return True\n\ndef Solve_Naive(max_value):\n    s = 0\n    for i in range(1, max_value + 1):\n        si = 0\n        ss = \"\"\n        for n in range(1, 50):\n            ss += str(n * i)\n            if len(ss) == 9:\n                si = int(ss)\n                if isPandigital(si):\n                    if si > s:\n                        s = si\n    return s\n\n# main function\ndef main_solution(max_value):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = Solve_Naive(max_value)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    max_value = random.choice([100, 200, 300, 400, 500, 1000, 2000, 5000])\n    return {'max_value': max_value}", "io_pairs": [{"input": {"max_value": 2000}, "output": 918273645}, {"input": {"max_value": 300}, "output": 918273645}, {"input": {"max_value": 1000}, "output": 918273645}, {"input": {"max_value": 400}, "output": 918273645}, {"input": {"max_value": 200}, "output": 918273645}, {"input": {"max_value": 500}, "output": 918273645}, {"input": {"max_value": 5000}, "output": 918273645}, {"input": {"max_value": 100}, "output": 918273645}], "error_log": []}
{"context": "In a game, a player traverses a digraph with a certain number of circles (vertices) and arrows (edges). The digraph must be strongly connected, meaning every circle must have at least one in arrow and one out arrow. The player starts at one circle and randomly moves to another circle until all circles have been visited at least once. Given the number of circles, the number of arrows, and the list of arrows, what is the average number of checks per game, the maximum number of checks in any single game, and the minimum number of checks in any single game?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): Number of circles (vertices) in the digraph.\n  `K` (int): Number of arrows (edges) in the digraph.\n  `edges` (list of tuples): List of tuples representing the edges (u, v) where u -> v. Each tuple contains two integers representing the source and destination vertices.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `average_checks_per_game` (float): The average number of checks per game.\n    - `maximum_checks_in_a_single_game` (int): The maximum number of checks in any single game.\n    - `minimum_checks_in_a_single_game` (int): The minimum number of checks in any single game.\n    - `error` (str): An error message if the digraph is not strongly connected or if all circles do not have both an in and an out arrow.", "reference_code": "# import necessary packages\nimport random\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices  # No. of vertices\n        self.graph = defaultdict(list)  # default dictionary to store graph\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def DFSUtil(self, v, visited):\n        visited[v] = True\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFSUtil(i, visited)\n\n    def getTranspose(self):\n        g = Graph(self.V)\n        for i in self.graph:\n            for j in self.graph[i]:\n                g.addEdge(j, i)\n        return g\n\n    def isSC(self):\n        visited = [False] * (self.V)\n        self.DFSUtil(0, visited)\n        if any(i == False for i in visited):\n            return False\n        gr = self.getTranspose()\n        visited = [False] * (self.V)\n        gr.DFSUtil(0, visited)\n        if any(i == False for i in visited):\n            return False\n        return True\n\n# main function\ndef main_solution(N, K, edges):\n    # N: number of circles (vertices)\n    # K: number of arrows (edges)\n    # edges: list of tuples representing the edges (u, v) where u -> v\n\n    # Create the graph\n    g1 = Graph(N)\n    matrix = [[0 for _ in range(N)] for _ in range(N)]\n\n    for u, v in edges:\n        g1.addEdge(u, v)\n        matrix[u][v] = 1\n\n    # Check for strong connection\n    if not g1.isSC():\n        return {\"error\": \"Digraph is not strongly connected\"}\n\n    # Check for in and out arrows\n    strongList = [[0 for _ in range(2)] for _ in range(N)]\n    for a in range(N):\n        for x in range(N):\n            if matrix[a][x] > 0:\n                strongList[a][1] = 1\n            if matrix[x][a] > 0:\n                strongList[a][0] = 1\n\n    count = sum(sum(row) for row in strongList)\n    if count != N * 2:\n        return {\"error\": \"All circles do not have both an in and an out arrow\"}\n\n    # Simulate the game\n    checksTotal = [0] * 10\n    for mate in range(1, 11):\n        currentCircle = 0\n        checkList = [0] * N\n        checkList[0] = 1\n        checkMarkTotal = 0\n        checkMarkTally = [0] * N\n        checkMarkTally[0] = 1\n        total = 0\n        iterations = 0\n        while True:\n            roll = random.randint(0, N - 1)\n            if matrix[currentCircle][roll]:\n                currentCircle = roll\n                checkMarkTotal += 1\n                checkMarkTally[currentCircle] += 1\n                checkList[currentCircle] = 1\n            iterations += 1\n            if sum(checkList) == N:\n                break\n            if iterations > 1000000:\n                return {\"error\": f\"Number of checks for game {mate} exceeded 1,000,000\"}\n        checksTotal[mate - 1] = checkMarkTotal\n\n    # Calculate results\n    sum_checks = sum(checksTotal)\n    max_checks = max(checksTotal)\n    min_checks = min(checksTotal)\n    avg_checks = sum_checks / 10\n\n    return {\n        \"average_checks_per_game\": avg_checks,\n        \"maximum_checks_in_a_single_game\": max_checks,\n        \"minimum_checks_in_a_single_game\": min_checks\n    }", "input_generator": "import random\nfrom collections import defaultdict\n\ndef input_generator():\n    # Generate a random number of vertices (circles) between 3 and 10\n    N = random.randint(3, 10)\n    \n    # Generate a strongly connected graph\n    # Start with a cycle to ensure strong connectivity\n    edges = []\n    for i in range(N):\n        edges.append((i, (i + 1) % N))\n    \n    # Add additional edges to ensure each vertex has both in and out arrows\n    # and to add some randomness\n    K = N  # initial edges from the cycle\n    max_extra_edges = min(20, N * (N - 1))  # limit to avoid too many edges\n    extra_edges = random.randint(0, max_extra_edges - N)\n    \n    possible_edges = []\n    for u in range(N):\n        for v in range(N):\n            if u != v and (u, v) not in edges:\n                possible_edges.append((u, v))\n    \n    random.shuffle(possible_edges)\n    edges.extend(possible_edges[:extra_edges])\n    K += extra_edges\n    \n    return {\n        \"N\": N,\n        \"K\": K,\n        \"edges\": edges\n    }", "io_pairs": [{"input": {"N": 4, "K": 5, "edges": [[0, 1], [1, 2], [2, 3], [3, 0], [2, 0]]}, "output": {"average_checks_per_game": 6.3, "maximum_checks_in_a_single_game": 12, "minimum_checks_in_a_single_game": 3}}, {"input": {"N": 3, "K": 6, "edges": [[0, 1], [1, 2], [2, 0], [0, 2], [1, 0], [2, 1]]}, "output": {"average_checks_per_game": 3.1, "maximum_checks_in_a_single_game": 4, "minimum_checks_in_a_single_game": 2}}, {"input": {"N": 3, "K": 4, "edges": [[0, 1], [1, 2], [2, 0], [2, 1]]}, "output": {"average_checks_per_game": 2.0, "maximum_checks_in_a_single_game": 2, "minimum_checks_in_a_single_game": 2}}, {"input": {"N": 3, "K": 3, "edges": [[0, 1], [1, 2], [2, 0]]}, "output": {"average_checks_per_game": 2.0, "maximum_checks_in_a_single_game": 2, "minimum_checks_in_a_single_game": 2}}, {"input": {"N": 4, "K": 4, "edges": [[0, 1], [1, 2], [2, 3], [3, 0]]}, "output": {"average_checks_per_game": 3.0, "maximum_checks_in_a_single_game": 3, "minimum_checks_in_a_single_game": 3}}, {"input": {"N": 3, "K": 5, "edges": [[0, 1], [1, 2], [2, 0], [2, 1], [1, 0]]}, "output": {"average_checks_per_game": 4.0, "maximum_checks_in_a_single_game": 8, "minimum_checks_in_a_single_game": 2}}, {"input": {"N": 3, "K": 5, "edges": [[0, 1], [1, 2], [2, 0], [1, 0], [2, 1]]}, "output": {"average_checks_per_game": 4.4, "maximum_checks_in_a_single_game": 10, "minimum_checks_in_a_single_game": 2}}, {"input": {"N": 3, "K": 4, "edges": [[0, 1], [1, 2], [2, 0], [1, 0]]}, "output": {"average_checks_per_game": 3.8, "maximum_checks_in_a_single_game": 8, "minimum_checks_in_a_single_game": 2}}, {"input": {"N": 5, "K": 5, "edges": [[0, 1], [1, 2], [2, 3], [3, 4], [4, 0]]}, "output": {"average_checks_per_game": 4.0, "maximum_checks_in_a_single_game": 4, "minimum_checks_in_a_single_game": 4}}, {"input": {"N": 3, "K": 4, "edges": [[0, 1], [1, 2], [2, 0], [0, 2]]}, "output": {"average_checks_per_game": 2.9, "maximum_checks_in_a_single_game": 7, "minimum_checks_in_a_single_game": 2}}], "error_log": []}
{"context": "In a game of Mastermind, a player tries to guess a secret code consisting of 4 colored pegs, each peg being one of six possible colors (A, B, C, D, E, F). After each guess, the player receives feedback indicating how many pegs are correct and in the right position, and how many pegs are correct but in the wrong position. Given a guess and the secret code, what feedback should the player receive?\n\nThe input and output requirements are as follows:\n\nInput:\n  `guess` (list of str): A list of 4 characters representing the guess, where each character is one of 'A', 'B', 'C', 'D', 'E', 'F'.\n  `secret_code` (list of str): A list of 4 characters representing the secret code, where each character is one of 'A', 'B', 'C', 'D', 'E', 'F'.\n\nOutput:\n  `return` (list of int): A list of two integers where the first integer represents the number of characters that are correct and in the right position, and the second integer represents the number of characters that are correct but in the wrong position.", "reference_code": "# import necessary packages\nimport random\nimport itertools\n\n# all class and function definitions in the code file, if any\nkleuren = ('A', 'B', 'C', 'D', 'E', 'F')\n\ndef antwoord_genereren():\n    \"\"\"return een lijst met 4 willekeurige elementen uit kleuren\"\"\"\n    return [random.choice(kleuren) for _ in range(4)]\n\ndef feedback(vraag, antwoord):\n    \"\"\"return feedback over de gestelde vraag.\\n\n        Vergelijk de gestelde vraag met de geheime correcte combinatie(antwoord),\\n\n        return een lijst van 2 lang waarbij het eerste teken staat voor hoeveel tekens er op de goede plek staan\\n\n        en het tweede teken staat voor hoeveel tekens er in het antwoord staan maar niet op de juiste plek\"\"\"\n    index = 0\n    feedback = [0, 0]\n    for i in vraag:\n        if i in antwoord:\n            feedback[1] += 1\n            if i == antwoord[index]:\n                feedback[0] += 1\n                feedback[1] -= 1\n        index += 1\n    return feedback\n\n# main function\ndef main_solution(guess, secret_code):\n    \"\"\"\n    This function takes a guess and a secret code, both as lists of 4 characters from the set ('A', 'B', 'C', 'D', 'E', 'F').\n    It returns feedback on the guess, indicating how many characters are correct and in the right position,\n    and how many characters are correct but in the wrong position.\n    \"\"\"\n    # Convert input to lists if they are not already\n    guess = list(guess)\n    secret_code = list(secret_code)\n    \n    # Get feedback\n    result = feedback(guess, secret_code)\n    \n    # Return the result as a list of two integers\n    return result", "input_generator": "import random\n\ndef input_generator():\n    kleuren = ('A', 'B', 'C', 'D', 'E', 'F')\n    secret_code = [random.choice(kleuren) for _ in range(4)]\n    guess = [random.choice(kleuren) for _ in range(4)]\n    return {'guess': guess, 'secret_code': secret_code}", "io_pairs": [{"input": {"guess": ["E", "E", "E", "B"], "secret_code": ["B", "F", "C", "F"]}, "output": [0, 1]}, {"input": {"guess": ["A", "D", "B", "B"], "secret_code": ["D", "B", "C", "D"]}, "output": [0, 3]}, {"input": {"guess": ["C", "D", "C", "F"], "secret_code": ["B", "B", "D", "E"]}, "output": [0, 1]}, {"input": {"guess": ["A", "F", "B", "C"], "secret_code": ["C", "F", "D", "B"]}, "output": [1, 2]}, {"input": {"guess": ["E", "E", "C", "E"], "secret_code": ["D", "A", "A", "C"]}, "output": [0, 1]}, {"input": {"guess": ["F", "E", "D", "C"], "secret_code": ["D", "C", "C", "B"]}, "output": [0, 2]}, {"input": {"guess": ["E", "A", "E", "D"], "secret_code": ["F", "E", "B", "F"]}, "output": [0, 2]}, {"input": {"guess": ["B", "A", "D", "F"], "secret_code": ["D", "F", "E", "B"]}, "output": [0, 3]}, {"input": {"guess": ["E", "C", "A", "F"], "secret_code": ["D", "A", "D", "E"]}, "output": [0, 2]}, {"input": {"guess": ["A", "D", "E", "F"], "secret_code": ["B", "A", "D", "A"]}, "output": [0, 2]}], "error_log": []}
{"context": "Given a string that may represent a numeric value, determine whether the string is a valid numeric representation. The string may contain digits, signs, decimal points, and scientific notation (e.g., 'e' or 'E'). What is the result of checking if the string represents a valid numeric value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string that may represent a numeric value. The string may contain leading or trailing spaces, and may include digits, signs, decimal points, and scientific notation (e.g., 'e' or 'E').\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input string represents a valid numeric value. `True` if the string is a valid numeric representation, `False` otherwise.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef isNumeric(s):\n    s = s.strip()\n    part = 'num'\n    hasDigit = False\n    for i in range(len(s)):\n        if s[i].isdigit():\n            hasDigit = True\n        elif s[i] == '.':\n            if part != 'num':\n                return False\n            part = 'frac'\n        elif s[i].lower() == 'e':\n            if part == 'e' or not hasDigit:\n                return False\n            part = 'e'\n            hasDigit = False\n        elif s[i] == '+' or s[i] == '-':\n            if i != 0 and s[i-1].lower() != 'e':\n                return False\n        else:\n            return False\n    return hasDigit\n\n# main function\ndef main_solution(input_string):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = isNumeric(input_string)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    choices = [\n        \"123\",\n        \"-123\",\n        \"123.45\",\n        \"123e10\",\n        \"123e-10\",\n        \"-123.456e-789\",\n        \"abc\",\n        \"123a\",\n        \"12.34.56\",\n        \"1e1e1\",\n        \"++123\",\n        \"--123\",\n        \"e123\",\n        \".\",\n        \"\",\n        \"   123   \",\n        \"   -123.456e+789   \",\n        \"123E10\",\n        \"123E-10\",\n        \"0\",\n        \"0000\",\n        \"-0\",\n        \"0.0\",\n        \"0e0\",\n        \"0.0e0\",\n        \"0.0e-0\",\n        \"0.0e+0\",\n        \"1.2e3\",\n        \"-1.2e3\",\n        \"1.2e-3\",\n        \"-1.2e-3\",\n        \"1.2e+3\",\n        \"-1.2e+3\"\n    ]\n    \n    # Randomly choose between predefined cases and a randomly generated string\n    if random.random() < 0.7:\n        s = random.choice(choices)\n    else:\n        length = random.randint(1, 10)\n        chars = string.digits + string.ascii_letters + '+-.eE'\n        s = ''.join(random.choices(chars, k=length))\n    \n    return {'input_string': s}", "io_pairs": [{"input": {"input_string": "CTN"}, "output": false}, {"input": {"input_string": "-0"}, "output": true}, {"input": {"input_string": "++123"}, "output": false}, {"input": {"input_string": "-1.2e3"}, "output": true}, {"input": {"input_string": "-123.456e-789"}, "output": true}, {"input": {"input_string": "-LA4w"}, "output": false}, {"input": {"input_string": "0.0e+0"}, "output": true}, {"input": {"input_string": "GN4zRPp7Jd"}, "output": false}, {"input": {"input_string": "123.45"}, "output": true}, {"input": {"input_string": "12.34.56"}, "output": false}], "error_log": []}
{"context": "Given four cards, each containing a number from 1 to 9, can you determine if it is possible to use the operations addition, subtraction, multiplication, and division (with real division, not integer division) along with parentheses to combine these numbers to get exactly 24? For example, with the numbers [4, 1, 8, 7], it is possible to achieve 24 by calculating (8-4) * (7-1). What is the result for a given set of four numbers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `nums` (list of int): A list of 4 integers, each ranging from 1 to 9.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the numbers in `nums` can be combined using the operations +, -, *, /, and parentheses to equal 24.", "reference_code": "# import necessary packages\nfrom operator import add, sub, mul, truediv\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def judgePoint24(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 1:\n            return abs(nums[0]-24) < 1e-6\n        ops = [add, sub, mul, truediv]\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i == j:\n                    continue\n                next_nums = [nums[k] for k in range(len(nums)) if i != k != j]\n                for op in ops:\n                    if ((op is add or op is mul) and j > i) or (op == truediv and nums[j] == 0):\n                        continue\n                    next_nums.append(op(nums[i], nums[j]))\n                    if self.judgePoint24(next_nums):\n                        return True\n                    next_nums.pop()\n        return False\n\n# main function\ndef main_solution(nums):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # convert input to the required format for the original function\n    nums = list(nums)\n    \n    # call the original function\n    result = Solution().judgePoint24(nums)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    nums = [random.randint(1, 13) for _ in range(4)]\n    return {'nums': nums}", "io_pairs": [{"input": {"nums": [3, 9, 2, 4]}, "output": true}, {"input": {"nums": [7, 9, 1, 5]}, "output": true}, {"input": {"nums": [6, 10, 13, 5]}, "output": true}, {"input": {"nums": [12, 9, 4, 11]}, "output": true}, {"input": {"nums": [7, 9, 2, 2]}, "output": false}, {"input": {"nums": [10, 12, 10, 9]}, "output": false}, {"input": {"nums": [13, 8, 5, 9]}, "output": true}, {"input": {"nums": [11, 12, 1, 13]}, "output": true}, {"input": {"nums": [9, 7, 11, 10]}, "output": true}, {"input": {"nums": [1, 10, 1, 3]}, "output": true}], "error_log": []}
{"context": "Given a dataset of voting records for several senators, which senator has a voting pattern most similar to a specified senator?\n\nThe input and output requirements are as follows:\n\nInput:\n  `voting_data` (list of strings): A list of strings where each string represents a voting record of a senator. Each string is formatted as \"SenatorName Party State Vote1 Vote2 ...\".\n  `senator_name` (string): The last name of the senator for whom we want to find the most similar senator.\n\nOutput:\n  `return` (string): The last name of the senator whose political mindset is most like the input senator.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef create_voting_dict(voting_data):\n    \"\"\"\n    Input: A list of strings representing voting records.\n    Output: A dictionary that maps the last name of a senator to a list of numbers representing the senator's voting record.\n    \"\"\"\n    votDict = dict()\n    for recStr in voting_data:\n        recList = recStr.split()\n        votDict[recList[0]] = [int(x) for x in recList[3:]]\n    return votDict\n\ndef policy_compare(sen_a, sen_b, voting_dict):\n    \"\"\"\n    Input: Last names of sen_a and sen_b, and a voting dictionary mapping senator names to lists representing their voting records.\n    Output: The dot-product (as a number) representing the degree of similarity between two senators' voting policies.\n    \"\"\"\n    senARecList = voting_dict[sen_a]\n    senBRecList = voting_dict[sen_b]\n    agreement = sum([a * b for (a, b) in zip(senARecList, senBRecList)])\n    return agreement\n\ndef most_similar(sen, voting_dict):\n    \"\"\"\n    Input: The last name of a senator, and a dictionary mapping senator names to lists representing their voting records.\n    Output: The last name of the senator whose political mindset is most like the input senator (excluding the input senator himself/herself).\n    \"\"\"\n    highScore = 0\n    senHighScore = \"\"\n    senPool = list(voting_dict.keys())\n    senPool.remove(sen)\n\n    for testSen in senPool:\n        testComp = policy_compare(sen, testSen, voting_dict)\n        if testComp > highScore:\n            highScore = testComp\n            senHighScore = testSen\n\n    return senHighScore\n\n# main function\ndef main_solution(voting_data, senator_name):\n    \"\"\"\n    Input: \n        voting_data (list of strings): A list of strings where each string represents a voting record of a senator.\n        senator_name (string): The last name of the senator for whom we want to find the most similar senator.\n    Output: \n        return (string): The last name of the senator whose political mindset is most like the input senator.\n    \"\"\"\n    voting_dict = create_voting_dict(voting_data)\n    most_similar_senator = most_similar(senator_name, voting_dict)\n    return most_similar_senator", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random number of senators (between 5 and 20)\n    num_senators = random.randint(5, 20)\n    senators = []\n    # Generate random last names for senators\n    for _ in range(num_senators):\n        last_name = ''.join(random.choices(string.ascii_uppercase, k=random.randint(3, 6)))\n        senators.append(last_name)\n    \n    # Generate random voting records for each senator (each record has 5 to 15 votes, -1 or 1)\n    voting_data = []\n    for senator in senators:\n        votes = [str(random.choice([-1, 1])) for _ in range(random.randint(5, 15))]\n        record = f\"{senator} {' '.join(['party'] + votes)}\"  # party is a placeholder\n        voting_data.append(record)\n    \n    # Randomly select a senator to find the most similar\n    senator_name = random.choice(senators)\n    \n    return {\n        \"voting_data\": voting_data,\n        \"senator_name\": senator_name\n    }", "io_pairs": [{"input": {"voting_data": ["MZPA party 1 -1 1 -1 -1 1 1 -1 -1 1", "PQEFN party -1 -1 -1 -1 -1 -1 1 1 -1 -1 -1", "KDCJ party 1 -1 1 1 1 1 -1 -1", "WIUR party -1 -1 1 1 1 -1 1 -1 -1 1", "HJQGE party 1 1 1 1 -1 -1"], "senator_name": "HJQGE"}, "output": "WIUR"}, {"input": {"voting_data": ["DNH party 1 -1 1 1 1 -1 1 -1 -1 1 -1 -1 1", "EBMMS party -1 1 -1 1 1 1 1 1 1", "IBPTJT party 1 -1 -1 1 1 1 1", "QOTYQZ party 1 -1 1 -1 -1 1 -1 -1 1 1 -1 -1 -1", "TQKQOX party -1 -1 1 1 -1 1 -1"], "senator_name": "DNH"}, "output": "IBPTJT"}, {"input": {"voting_data": ["ZRCND party 1 -1 1 -1 -1 -1 -1 1 1 -1 1 1 -1 -1 1", "SREKS party 1 -1 1 1 1 1 1 1 1 -1 -1", "ENI party -1 -1 -1 1 -1 -1 -1 -1", "QORZ party -1 1 -1 1 -1 1 -1", "VRXC party -1 -1 -1 1 1", "AUZM party 1 -1 1 1 1 1 1"], "senator_name": "ENI"}, "output": "QORZ"}, {"input": {"voting_data": ["MGSDUU party -1 1 1 1 1 1", "CVDL party 1 -1 1 1 -1 -1 -1 1 -1 -1 -1 -1 1 1 -1", "SPRU party 1 -1 -1 1 1 -1 -1", "XCMX party 1 -1 1 -1 1 -1", "PQT party -1 -1 1 -1 -1 1 -1"], "senator_name": "CVDL"}, "output": "SPRU"}, {"input": {"voting_data": ["ZQR party 1 -1 1 1 -1 -1 1 1 1 1 1 1 1", "SOJGW party 1 -1 -1 -1 -1 -1 1", "LQTWED party -1 1 -1 -1 -1 1 1 1 -1 -1 -1 -1", "SOPIO party 1 1 -1 -1 1 -1", "RACW party 1 -1 1 1 -1 -1 1 1 1 -1 -1 -1 1"], "senator_name": "ZQR"}, "output": "RACW"}, {"input": {"voting_data": ["LDOMN party -1 1 -1 -1 1 1 1 -1 1 1", "XFMPNV party 1 1 1 -1 -1 1", "KFQXN party -1 1 -1 -1 1 1 -1", "FHGUH party 1 -1 1 -1 1 1 -1", "ANAYTW party 1 1 -1 1 1 1 1 1 1 -1 1 1 1 1 -1"], "senator_name": "ANAYTW"}, "output": "LDOMN"}, {"input": {"voting_data": ["NDYJI party -1 -1 1 -1 1", "SJVGXE party 1 -1 -1 -1 1 1 -1", "XUBVCP party -1 -1 -1 1 -1", "PQJHYH party 1 -1 1 1 1 1 1 1 1 -1 -1 1 -1 -1 1", "NVSPJB party 1 -1 1 -1 1 -1 -1 1 -1 1 1"], "senator_name": "XUBVCP"}, "output": ""}, {"input": {"voting_data": ["TCQEFZ party -1 1 1 1 -1 1 -1", "YJRK party 1 -1 1 -1 -1 -1", "HWOH party -1 -1 -1 1 1 1 -1 1 1 -1 1", "PHY party 1 -1 1 -1 1", "KZYJ party -1 -1 -1 1 -1 1 1 -1 -1 1 1 -1 1 1", "EPQLCS party 1 -1 1 1 1 -1 1 -1 1 -1 -1 -1 -1 -1"], "senator_name": "YJRK"}, "output": "PHY"}, {"input": {"voting_data": ["IBCOK party -1 1 1 -1 1", "ZZJNQ party 1 -1 1 1 1 -1 -1 1 -1 1 1", "GGR party -1 1 1 -1 -1 -1 -1 -1", "XBILC party 1 1 1 1 1 -1 1", "JZGQQJ party -1 1 1 1 1 1 -1 -1 1 1 1 -1 1 -1 1", "GSW party 1 -1 1 1 -1 -1 -1 1 1 1 -1 1 -1"], "senator_name": "IBCOK"}, "output": "GGR"}, {"input": {"voting_data": ["KDVN party -1 1 1 1 -1 -1 1 -1 -1 -1 1 1 1 -1 -1", "FDM party 1 -1 1 1 1 1 1 -1 1 -1 1 1 1 1 1", "NBXM party 1 1 1 -1 1 1 -1 1 1 -1 1 -1 1", "FNGHLO party 1 -1 -1 1 -1 1 -1 -1 -1 1 -1 -1", "IXOQQK party 1 -1 1 1 1 -1 1 1 -1 -1"], "senator_name": "FDM"}, "output": "IXOQQK"}], "error_log": []}
{"context": "Given a loan with a specific notional amount, annual interest rate, and term in years, what are the interest due, principal due, and remaining balance at a particular month `t` within the loan term?\n\nThe input and output requirements are as follows:\n\nInput:\n  `notional` (float): The initial amount of the loan.\n  `rate` (float): The annual interest rate of the loan.\n  `term` (int): The term of the loan in years.\n  `t` (int): The specific period (in months) for which the interest, principal, and balance are to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `interest_due` (float): The interest due at time `t`.\n    - `principal_due` (float): The principal due at time `t`.\n    - `balance_due` (float): The remaining balance of the loan at time `t`.", "reference_code": "# import necessary packages\nimport random\n\n# loan class\n# This class object takes on the arguments asset, face, rate, term\nclass Loan(object):\n\n    # Initialization function with asset, face, rate, term\n    # Also included in this function is ability to set the arguments to 0 if they don't already exists\n    def __init__(self, notional, rate, term):\n        # Main attributes\n        self._notional = notional\n        self._rate = rate\n        self._term = term\n\n    # Decorator to create a property function to define the argument notional\n    @property\n    def notional(self):\n        return self._notional\n\n    # Decorator to set notional value\n    @notional.setter\n    def notional(self, inotional):\n        self._notional = inotional  # Set instance variable notional from input\n\n    # Decorator to create a property function to define the argument rate\n    @property\n    def rate(self):\n        return self._rate\n\n    # Decorator to set interest rate\n    @rate.setter\n    def rate(self, irate):\n        self._rate = irate  # Set instance variable rate from input\n\n    # Decorator to create a property function to define the argument term\n    @property\n    def term(self):\n        return self._term\n\n    # Decorator to set loan term\n    @term.setter\n    def term(self, iterm):\n        self._term = iterm  # Set instance variable term from input\n\n    # Instance method to calculate monthly payments\n    def monthlyPayment(self, period=None):\n        try:\n            return ((self._rate/12) * self._notional * (1 + (self._rate/12))**(self._term*12)) \\\n                   / (((1 + (self._rate/12))**(self._term*12)) - 1)\n        except ZeroDivisionError:\n            return None\n\n    # Instance method to calculate interest due at time t\n    def interestDue(self, t):\n        return (self._rate/12) * self.balance(t-1)\n\n    # Instance method to calculate principal due at time t\n    def principalDue(self, t):\n        return self.monthlyPayment() - self.interestDue(t)\n\n    # Instance method to calculate remaining loan balance due at time t\n    def balance(self, t):\n        return self._notional * ((1+self._rate/12)**t) - \\\n               (self.monthlyPayment() * (((1 + (self._rate/12))**t - 1)/(self._rate/12)))\n\n# main function\ndef main_solution(notional, rate, term, t):\n    loan = Loan(notional, rate, term)\n    interest_due = loan.interestDue(t)\n    principal_due = loan.principalDue(t)\n    balance_due = loan.balance(t)\n    return {\n        \"interest_due\": interest_due,\n        \"principal_due\": principal_due,\n        \"balance_due\": balance_due\n    }", "input_generator": "import random\n\ndef input_generator():\n    notional = round(random.uniform(10000, 1000000), 2)  # Loan amount between 10k and 1M\n    rate = round(random.uniform(0.01, 0.10), 4)  # Interest rate between 1% and 10%\n    term = random.randint(1, 30)  # Loan term between 1 and 30 years\n    t = random.randint(1, term * 12)  # Time period between 1 and total months in term\n    return {\n        \"notional\": notional,\n        \"rate\": rate,\n        \"term\": term,\n        \"t\": t\n    }", "io_pairs": [{"input": {"notional": 612650.27, "rate": 0.0154, "term": 15, "t": 101}, "output": {"interest_due": 371.91653722934313, "principal_due": 3442.1087420097465, "balance_due": 286362.9852029332}}, {"input": {"notional": 868779.56, "rate": 0.0959, "term": 28, "t": 280}, "output": {"interest_due": 2719.8659989730413, "principal_due": 4737.217629537859, "balance_due": 335600.5507508209}}, {"input": {"notional": 868355.74, "rate": 0.0536, "term": 16, "t": 30}, "output": {"interest_due": 3483.1389602631657, "principal_due": 3262.2281173548095, "balance_due": 776545.0017923092}}, {"input": {"notional": 99516.64, "rate": 0.0351, "term": 7, "t": 31}, "output": {"interest_due": 195.2199856968952, "principal_due": 1142.7221454327312, "balance_due": 65599.15330649726}}, {"input": {"notional": 346819.57, "rate": 0.037, "term": 20, "t": 33}, "output": {"interest_due": 968.1197242665311, "principal_due": 1079.1197190760126, "balance_due": 312905.65571871784}}, {"input": {"notional": 755666.88, "rate": 0.0567, "term": 15, "t": 124}, "output": {"interest_due": 1470.933062409672, "principal_due": 4771.87631315142, "balance_due": 306536.70832381607}}, {"input": {"notional": 75735.84, "rate": 0.0289, "term": 17, "t": 201}, "output": {"interest_due": 4.503682361558235, "principal_due": 465.8247842705379, "balance_due": 1404.2163347155874}}, {"input": {"notional": 366816.71, "rate": 0.0374, "term": 30, "t": 122}, "output": {"interest_due": 890.193048570855, "principal_due": 806.5115434315811, "balance_due": 284816.92650069296}}, {"input": {"notional": 172849.45, "rate": 0.0471, "term": 17, "t": 28}, "output": {"interest_due": 616.5774785163483, "principal_due": 616.3087648440071, "balance_due": 156473.49467881158}}, {"input": {"notional": 775725.14, "rate": 0.029, "term": 24, "t": 154}, "output": {"interest_due": 1040.5650919206344, "principal_due": 2701.2477495917456, "balance_due": 427877.4109761879}}], "error_log": []}
{"context": "In a series of binomial experiments, where each experiment consists of a fixed number of trials, we are interested in understanding the distribution of the number of successes. Given a probability of success for each trial and the number of trials in each experiment, what is the distribution of the number of successes across a specified number of such experiments?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p` (float): The probability of success in a single Bernoulli trial. It should be between 0 and 1.\n  `n` (int): The number of trials in each binomial experiment. It should be a positive integer.\n  `num_points` (int): The number of binomial experiments to simulate. It should be a positive integer.\n\nOutput:\n  `return` (dict): A dictionary where the keys are strings representing the number of successes (as integers) and the values are the counts of those successes in the simulated experiments.", "reference_code": "# import necessary packages\nimport random\nimport math\nfrom collections import Counter\n\n# all class and function definitions in the code file, if any\ndef random_kid():\n    return random.choice([\"boy\", \"girl\"])\n\ndef uniform_pdf(x):\n    return 1 if x >= 0 and x < 1 else 0\n\ndef uniform_cdf(x):\n    if x < 0: return 0\n    elif x < 1: return x\n    else: return 1\n\ndef normal_pdf(x, mu=0, sigma=1):\n    sqrt_two_pi = math.sqrt(2 * math.pi)\n    return math.exp(-(x - mu) ** 2 / (2 * sigma ** 2)) / (sigma * sqrt_two_pi)\n\ndef bernoulli_trial(p):\n    return 1 if random.random() < p else 0\n\ndef binomial(n, p):\n    return sum(bernoulli_trial(p) for _ in range(n))\n\n# main function\ndef main_solution(p, n, num_points):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    data = [binomial(n, p) for _ in range(num_points)]\n    histogram = Counter(data)\n    \n    # Convert histogram to a JSON serializable format\n    histogram_serializable = {str(k): v for k, v in histogram.items()}\n    \n    return histogram_serializable", "input_generator": "import random\n\ndef input_generator():\n    p = round(random.uniform(0.1, 0.9), 2)  # Probability between 0.1 and 0.9\n    n = random.randint(1, 20)                # Number of trials between 1 and 20\n    num_points = random.randint(100, 1000)   # Number of data points between 100 and 1000\n    return {\"p\": p, \"n\": n, \"num_points\": num_points}", "io_pairs": [{"input": {"p": 0.81, "n": 15, "num_points": 371}, "output": {"13": 77, "12": 95, "14": 66, "9": 15, "15": 18, "10": 36, "11": 61, "8": 3}}, {"input": {"p": 0.21, "n": 12, "num_points": 149}, "output": {"3": 39, "4": 22, "0": 7, "1": 23, "2": 47, "5": 9, "6": 2}}, {"input": {"p": 0.67, "n": 5, "num_points": 933}, "output": {"2": 165, "4": 295, "3": 312, "5": 124, "1": 36, "0": 1}}, {"input": {"p": 0.83, "n": 13, "num_points": 175}, "output": {"11": 45, "10": 41, "12": 38, "8": 11, "13": 19, "9": 17, "7": 4}}, {"input": {"p": 0.21, "n": 5, "num_points": 698}, "output": {"0": 208, "1": 296, "2": 146, "3": 43, "4": 5}}, {"input": {"p": 0.72, "n": 13, "num_points": 183}, "output": {"11": 35, "10": 56, "8": 23, "9": 35, "7": 14, "6": 8, "12": 11, "5": 1}}, {"input": {"p": 0.39, "n": 2, "num_points": 768}, "output": {"0": 289, "1": 365, "2": 114}}, {"input": {"p": 0.55, "n": 5, "num_points": 757}, "output": {"5": 43, "4": 151, "2": 218, "3": 238, "1": 98, "0": 9}}, {"input": {"p": 0.33, "n": 4, "num_points": 682}, "output": {"2": 211, "0": 151, "1": 260, "3": 57, "4": 3}}, {"input": {"p": 0.24, "n": 8, "num_points": 401}, "output": {"6": 1, "2": 120, "1": 118, "0": 53, "4": 31, "3": 72, "5": 6}}], "error_log": []}
{"context": "Given a set of step dependencies where each step must be completed before another can begin, what is the correct order in which all steps should be completed?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data` (list of strings): A list of strings where each string represents a step dependency in the format \"Step X must be finished before step Y can begin.\"\n\nOutput:\n  `return` (string): A string representing the order in which the steps should be completed, based on the dependencies provided in the input.", "reference_code": "# import necessary packages\nimport re\nimport string\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\ndef parse_data(data):\n    steps = {}\n    for line in data:\n        values = re.match(\"Step ([A-Z]) must be finished before step ([A-Z]) can begin.\", line)\n        if values.group(1) not in steps:\n            steps[values.group(1)] = []\n        steps[values.group(1)].append(values.group(2))\n        steps[values.group(1)].sort()\n    return steps\n\ndef find_starting_step(steps):\n    second_steps = [item for i in steps for item in steps[i]]\n    queue = deque()\n    for c in string.ascii_uppercase:\n        if c not in second_steps:\n            queue.append(c)\n    return queue\n\n# main function\ndef main_solution(data):\n    # Convert the input data to the required format\n    steps = parse_data(data)\n    queue = find_starting_step(steps)\n    result = \"\"\n    \n    while len(queue) > 0:\n        curr = queue.popleft()\n        while curr in [item for i in steps for item in steps[i]]:\n            queue.append(curr)\n            curr = queue.popleft()\n\n        if curr in steps:\n            for x in steps[curr]:\n                if x not in queue:\n                    queue.append(x)\n            del steps[curr]\n        queue = deque(sorted(queue))\n        result += curr\n    \n    # Return the result as a string\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    num_steps = random.randint(5, 10)\n    steps = random.sample(string.ascii_uppercase, num_steps)\n    dependencies = []\n    \n    for i in range(num_steps - 1):\n        for j in range(i + 1, min(i + 1 + random.randint(1, 3), num_steps):\n            if j < num_steps:\n                dependencies.append(f\"Step {steps[i]} must be finished before step {steps[j]} can begin.\")\n    \n    random.shuffle(dependencies)\n    return {'data': dependencies[:random.randint(5, len(dependencies))]}", "io_pairs": [], "error_log": ["STDERR:   File \"<string>\", line 51\n    for j in range(i + 1, min(i + 1 + random.randint(1, 3), num_steps):\n                                                                      ^\nSyntaxError: invalid syntax\n"]}
{"context": "In a secure system, passwords must adhere to specific rules to ensure they are strong and easy to remember. Given a current password, what is the next valid password that meets the following criteria: it must contain at least three consecutive increasing characters, at least two different non-overlapping pairs of characters, and must not contain the characters 'i', 'l', or 'o'?\n\nThe input and output requirements are as follows:\n\nInput:\n  `password` (str): A string representing the current password. The password should only contain lowercase letters from 'a' to 'z'.\n\nOutput:\n  `return` (str): A string representing the next valid password that meets the following criteria:\n    - It contains at least three consecutive increasing characters (e.g., 'abc', 'xyz').\n    - It contains at least two different non-overlapping pairs of characters (e.g., 'aa', 'bb').\n    - It does not contain the characters corresponding to the indices 8 ('i'), 11 ('l'), and 14 ('o').", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nalfabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nillegal = [8, 11, 14]\n\ndef convertPasswordToPassList(password):\n    l = []\n    for c in password:\n        if (c not in alfabet):\n            raise ValueError(\"Invalid character in password\")\n        l.append(alfabet.index(c))\n    return l\n\ndef convertPassListToPassword(l):\n    s = \"\"\n    for i in l:\n        s += alfabet[i]\n    return s\n\ndef incrementPassList(passList):\n    index = -1\n    for i in range(-len(passList), 0):\n        if passList[i] in illegal:\n            index = i\n            for j in range(i+1, 0):\n                passList[j] = 0\n    while (abs(index) <= len(passList)):\n        passList[index] += 1\n        if (passList[index] >= len(alfabet)):\n            passList[index] = 0\n            index -= 1\n        else:\n            index = len(alfabet)\n\ndef containsThreeConsecutiveIncreasingCharacters(passList):\n    for i in range(len(passList)-2):\n        if (passList[i] == passList[i+1] - 1 and passList[i] == passList[i+2] - 2):\n            return True\n    return False\n\ndef containsIllegalCharacter(passList):\n    return [c for c in passList if c in illegal]\n\ndef containsTwoDifferentPairs(passList):\n    foundOnePair = False\n    foundLastITeration = False\n    foundPairCaracter = \"\"\n    for i in range(len(passList)-1):\n        if (foundLastITeration):\n            foundLastITeration = False\n            continue\n        if (passList[i] == passList[i+1]):\n            if (foundOnePair and foundPairCaracter != passList[i]):\n                return True\n            else:\n                foundPairCaracter = passList[i]\n                foundLastITeration = True\n                foundOnePair = True\n    return False\n\ndef findNextLegalPasword(password):\n    passList = convertPasswordToPassList(password)\n    incrementPassList(passList)\n\n    while (not passListIsLegal(passList)):\n        incrementPassList(passList)\n    \n    return convertPassListToPassword(passList)\n\n\ndef passListIsLegal(passList):\n    return (containsThreeConsecutiveIncreasingCharacters(passList)\n        and containsTwoDifferentPairs(passList)\n        and not containsIllegalCharacter(passList))\n\n# main function\ndef main_solution(password):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    next_password = findNextLegalPasword(password)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return next_password", "input_generator": "import random\n\ndef input_generator():\n    alfabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n    illegal_chars = ['i', 'l', 'o']\n    length = random.randint(5, 10)\n    password = []\n    \n    for _ in range(length):\n        char = random.choice(alfabet)\n        while char in illegal_chars:\n            char = random.choice(alfabet)\n        password.append(char)\n    \n    return {'password': ''.join(password)}", "io_pairs": [{"input": {"password": "zzwknypaxn"}, "output": "zzwknyppqr"}, {"input": {"password": "dafapbx"}, "output": "daffghh"}, {"input": {"password": "rufjhk"}, "output": "ruuvww"}, {"input": {"password": "uqucknc"}, "output": "uquuvww"}, {"input": {"password": "wtdbw"}, "output": "wwxyy"}, {"input": {"password": "jcankzuu"}, "output": "jcappqrr"}, {"input": {"password": "dpsgsexbq"}, "output": "dpsgsstuu"}, {"input": {"password": "gtwutdbqa"}, "output": "gtwuttuvv"}, {"input": {"password": "dcpfqef"}, "output": "dcppqrr"}, {"input": {"password": "ekgja"}, "output": "ffghh"}], "error_log": []}
{"context": "Given a row of a certain length, how many ways can it be filled with red blocks of minimum length 3 units, ensuring that any two red blocks are separated by at least one grey square?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The length of the row in units.\nOutput:\n  `return` (int): The number of ways the row can be filled with red blocks of minimum length 3 units, separated by at least one grey square.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nd = {}\n\ndef g(n):\n    res = 1\n    if n in d:\n        res = d[n]\n    elif (2 < n):\n        if (3 == n):\n            res = 2\n        else:\n            res = g(n-1) + n - 2\n        for i in range(4, n-2):\n            res = res + g(n-i) - 1\n    d[n] = res\n    return res\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = g(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(4, 20)  # Reasonable range to avoid excessive computation\n    return {'n': n}", "io_pairs": [{"input": {"n": 16}, "output": 1292}, {"input": {"n": 19}, "output": 5473}, {"input": {"n": 10}, "output": 72}, {"input": {"n": 13}, "output": 305}, {"input": {"n": 14}, "output": 493}, {"input": {"n": 4}, "output": 4}, {"input": {"n": 18}, "output": 3383}, {"input": {"n": 15}, "output": 798}, {"input": {"n": 5}, "output": 7}, {"input": {"n": 12}, "output": 189}], "error_log": []}
{"context": "Given a set of points in both real and complex projective spaces, how can we determine the geometric distance between each pair of points in these spaces? Specifically, what are the distance matrices for the points in real and complex projective spaces?\n\nThe input and output requirements are as follows:\n\nInput:\n  `Y_real` (list of lists): A list of lists representing the points in real projective space. Each inner list should represent a point in the space.\n  `Y_complex` (list of lists): A list of lists representing the points in complex projective space. Each inner list should represent a point in the space.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `\"D_real\"` (list of lists): The distance matrix for the points in real projective space.\n    - `\"D_complex\"` (list of lists): The distance matrix for the points in complex projective space.", "reference_code": "# import necessary packages\nimport numpy as np\nimport numpy.linalg as LA\n\n# all class and function definitions in the code file, if any\ndef sqrt_validate(X):\n    \"\"\"Replace matrix with entries > 0.\"\"\"\n    tol = 1e-9\n    x_min = np.min(X)\n    if x_min > 0:\n        return X\n    elif x_min < -tol:\n        print('WARNING: matrix contains nontrivial negative values.')\n    bad_idx = X < 0\n    X[bad_idx] = 0\n    return X\n\ndef acos_validate(M, tol=1e-6):\n    \"\"\"Replace values outside of domain of acos with +/- 1.\"\"\"\n    if np.max(M) > 1 + tol or np.min(M) < -1 - tol:\n        print('Warning: matrix contained a value of %2.4f. Input may be '\\\n            'outside of [-1,1] by more than floating point error.' %np.max(M))\n    big_vals = M >= 1.0\n    M[big_vals] = 1.0\n    small_vals = M <= -1.0\n    M[small_vals] = -1.0\n    return M\n\ndef RPn_geo_distance_matrix(Y):\n    \"\"\"Construct the (exact) distance matrix of data Y on RP^d.\"\"\"\n    M = np.abs(Y.T@Y)\n    acos_validate(M)\n    D = np.arccos(M)    # Initial distance matrix\n    np.fill_diagonal(D, 0)\n    return D\n\ndef CPn_geo_distance_matrix(Y):\n    \"\"\"Construct the (exact) distance matrix of data Y on CP^n.\"\"\"\n    n = int(Y.shape[0]/2)\n    i_mtx = np.vstack(\n        (np.hstack((np.zeros((n, n)), -np.eye(n))),\n        np.hstack((np.eye(n), np.zeros((n, n)))))\n    )\n    M = (Y.T@Y)**2 + (Y.T@(i_mtx@Y))**2\n    M = np.sqrt(M)\n    acos_validate(M)\n    D = np.arccos(M)\n    np.fill_diagonal(D, 0)\n    return D\n\n# main function\ndef main_solution(Y_real, Y_complex):\n    \"\"\"\n    Compute the geometric distance matrix for points in real and complex projective spaces.\n\n    Parameters:\n    Y_real (list of lists): A list of lists representing the points in real projective space.\n    Y_complex (list of lists): A list of lists representing the points in complex projective space.\n\n    Returns:\n    dict: A dictionary containing the distance matrices for both real and complex projective spaces.\n    \"\"\"\n    # Convert input lists to numpy arrays\n    Y_real = np.array(Y_real)\n    Y_complex = np.array(Y_complex)\n\n    # Compute distance matrices\n    D_real = RPn_geo_distance_matrix(Y_real)\n    D_complex = CPn_geo_distance_matrix(Y_complex)\n\n    # Convert distance matrices to lists for JSON serialization\n    D_real = D_real.tolist()\n    D_complex = D_complex.tolist()\n\n    return {\"D_real\": D_real, \"D_complex\": D_complex}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the number of points (between 2 and 10) and dimensions (between 1 and 5)\n    num_points = random.randint(2, 10)\n    dim_real = random.randint(1, 5)\n    dim_complex = random.randint(1, 5)\n    \n    # Generate random points in real projective space (normalized)\n    Y_real = np.random.randn(num_points, dim_real + 1)\n    Y_real = Y_real / np.linalg.norm(Y_real, axis=1, keepdims=True)\n    \n    # Generate random points in complex projective space (normalized)\n    real_part = np.random.randn(num_points, dim_complex + 1)\n    imag_part = np.random.randn(num_points, dim_complex + 1)\n    Y_complex = real_part + 1j * imag_part\n    Y_complex = Y_complex / np.linalg.norm(Y_complex, axis=1, keepdims=True)\n    Y_complex = np.hstack([Y_complex.real, Y_complex.imag])\n    \n    return {\n        \"Y_real\": Y_real.tolist(),\n        \"Y_complex\": Y_complex.tolist()\n    }", "io_pairs": [], "error_log": []}
{"context": "In the context of a simplified version of the Mahjong game, where the goal is to form a winning hand with 14 tiles, what is the result of checking if the given hand of tiles forms a winning combination? The hand consists of tiles represented by integers, where each integer corresponds to a specific tile in the Mahjong set.\n\nThe input and output requirements are as follows:\n\nInput:\n  `hand` (list of integers): A list of integers representing the tiles in the hand. Each integer corresponds to a specific tile in the Mahjong set. The list should contain exactly 14 elements.\n\nOutput:\n  `return` (boolean): A boolean value indicating whether the hand is a winning hand (True) or not (False).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef calc_(list_):\n    #\u5269\u4e0b\u4e09\u5f20\u724c\n    if len(list_) == 3:\n        #\u4e09\u5f20\u724c\u76f8\u540c\n        if list_.count(list_[0]) == 3:\n            return True\n        #\u662f\u987a\u5b50\n        elif list_[0] + list_[2] == list_[1] * 2 and list_[0] <= 25:\n            return True\n        #\u4e0d\u76f8\u540c\uff0c\u4e0d\u987a\u5b50\uff0c\u8fd4\u56de\u5047\n        else:\n            return False\n    #\u5269\u4e0b\u4e24\u5f20\u724c\n    elif len(list_) == 2:\n        #\u4e24\u5f20\u724c\u76f8\u540c\u5373\u4e3a\u5c06\uff0c\u8fd4\u56de\u771f\uff0c\u5426\u5219\u8fd4\u56de\u5047\n        if list_.count(list_[0]) == 2:\n            return True\n        else:\n            return False\n    #\u5269\u4e0b\u7684\u724c\u6570\u5927\u4e8e3\n    else:\n        #\u8fd9\u91cc\u53ea\u9700\u8981\u8003\u8651\u5230\u6240\u6709\u60c5\u51b5\u5c31\u53ef\u4ee5\u4e86\uff0c\u4e0d\u9700\u8981else\u5224\u65ad\n        if list_.count(list_[0]) == 3:\n            #\u9996\u5f20\u724c\u76f8\u540c\u6709\u4e09\u5f20,\u53bb\u6389\u524d\u4e09\u7ae0\u5269\u4e0b\u7684\u4f5c\u4e3a\u5217\u8868\u9012\u5f52\uff0c\u5224\u65ad\u8fd4\u56de\u503c\n            if calc_(list_[3:]):\n                return True\n        if len(list_) % 3 == 2 and list_.count(list_[0]) == 2:\n            #\u5224\u65ad\u662f\u5426\u5df2\u6709\u5c06\uff0c\u82e5\u6ca1\u6709\u90a3\u4e48\u5c1d\u8bd5\u524d\u4e24\u5f20\u505a\u5c06\n            if calc_(list_[2:]):\n                return True\n        if list_.count(list_[0] + 1) >= 1 and list_.count(list_[0] + 2) >= 1 and list_[0] <= 25:\n            #\u90a3\u4e48\u5224\u65ad\u662f\u5426\u53ef\u7ec4\u6210\u987a\u5b50\n            if calc_(list_[3:]):\n                return True\n        #\u4e0d\u662f\u4e09\u5f20\u76f8\u540c\u7684\uff0c\u4e0d\u662f\u5c06\uff0c\u4e0d\u662f\u987a\uff0c\u90a3\u4e48\u9996\u5f20\u724c\u4e0d\u80fd\u7ec4\u6210\u4efb\u4f55\u724c\uff0c\u8fd4\u56de\u5047\n        return False\n\n# main function\ndef main_solution(hand):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    hand.sort()\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return calc_(hand)", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random hand of tiles (numbers between 1 and 30, typically Mahjong tiles are 1-9 for each suit, but allowing some flexibility)\n    # Randomly decide the length of the hand (between 2 and 14, as Mahjong hands are usually 13 or 14 tiles)\n    length = random.randint(2, 14)\n    \n    # Generate a hand with some randomness: could be random numbers, or some sequences/triplets\n    hand = []\n    for _ in range(length):\n        hand.append(random.randint(1, 30))\n    \n    # Sometimes make it a valid hand (triplets or sequences)\n    if random.random() < 0.3:\n        # Make a valid hand: e.g., triplets or sequences\n        hand = []\n        remaining = length\n        # Add some triplets\n        while remaining >= 3:\n            if random.random() < 0.5:\n                # Add a triplet\n                num = random.randint(1, 28)\n                hand.extend([num, num, num])\n                remaining -= 3\n            else:\n                # Add a sequence\n                num = random.randint(1, 25)\n                hand.extend([num, num + 1, num + 2])\n                remaining -= 3\n        # Add a pair if remaining is 2\n        if remaining == 2:\n            num = random.randint(1, 30)\n            hand.extend([num, num])\n    \n    # Shuffle the hand to randomize the order\n    random.shuffle(hand)\n    \n    return {'hand': hand}", "io_pairs": [{"input": {"hand": [1, 6, 13, 15, 20, 22, 27, 27]}, "output": false}, {"input": {"hand": [7, 8, 9, 19, 19, 19, 24, 25, 26]}, "output": true}, {"input": {"hand": [2, 8, 13, 14, 29]}, "output": false}, {"input": {"hand": [3, 7, 8, 9, 11, 15, 18, 21, 22, 23, 29, 30]}, "output": false}, {"input": {"hand": [7, 9, 10, 16, 17, 17, 18, 20, 20, 22, 22]}, "output": false}, {"input": {"hand": [12, 12, 12, 19, 20, 21]}, "output": true}, {"input": {"hand": [12, 13, 13, 14, 14, 15, 16, 17, 18, 22, 22, 22]}, "output": true}, {"input": {"hand": [9, 10, 10, 10, 10, 11, 20, 21, 22, 24, 24, 24]}, "output": false}, {"input": {"hand": [1, 15, 19, 24, 25]}, "output": false}, {"input": {"hand": [7, 7]}, "output": true}], "error_log": []}
{"context": "In the context of packet switching, how does the end-to-end delay vary with different packet sizes when a specific overhead is added to each packet? Specifically, what are the corresponding packet sizes and end-to-end delays when the overhead is `overhead` bits?\n\nThe input and output requirements are as follows:\n\nInput:\n  `overhead` (int): The overhead in bits added to each packet.\n\nOutput:\n  `return` (dict): A dictionary containing two lists:\n    - `x_values` (list of float): The packet sizes in bits.\n    - `y_values` (list of float): The corresponding end-to-end delays in seconds.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(overhead):\n    # Convert overhead to integer if it's not already\n    overhead = int(overhead)\n\n    # Initialize lists for x and y coordinates\n    listx = []\n    listy = []\n\n    # Constants\n    kb = math.pow(10, 3)\n    R = 4 * kb  # Bandwidth rate of 4kbps\n    L = 16 * kb  # Message size of 16kb\n    numberOfRouters = 2  # Number of Routers/Switches\n    largestPacket = 4 * kb  # Largest packet size\n    smallestPacket = 125  # Smallest packet size\n\n    # Loop to simulate packet switching segmentation\n    while largestPacket >= smallestPacket:\n        numberOfPackets = L / largestPacket\n        numberOfTransmissions = numberOfPackets + numberOfRouters\n        delay = (largestPacket + overhead) / R\n        endToEnd = numberOfTransmissions * delay\n        listx.append(largestPacket)\n        listy.append(endToEnd)\n        largestPacket = largestPacket / 2\n\n    # Return the final x and y coordinates as lists\n    return {\"x_values\": listx, \"y_values\": listy}", "input_generator": "import random\n\ndef input_generator():\n    overhead = random.randint(50, 500)\n    return {\"overhead\": overhead}", "io_pairs": [{"input": {"overhead": 129}, "output": {"x_values": [4000.0, 2000.0, 1000.0, 500.0, 250.0, 125.0], "y_values": [6.193499999999999, 5.3225, 5.0805, 5.3465, 6.2535, 8.255]}}, {"input": {"overhead": 101}, "output": {"x_values": [4000.0, 2000.0, 1000.0, 500.0, 250.0, 125.0], "y_values": [6.1515, 5.2524999999999995, 4.9544999999999995, 5.108499999999999, 5.791499999999999, 7.345000000000001]}}, {"input": {"overhead": 459}, "output": {"x_values": [4000.0, 2000.0, 1000.0, 500.0, 250.0, 125.0], "y_values": [6.6884999999999994, 6.1475, 6.5655, 8.1515, 11.6985, 18.98]}}, {"input": {"overhead": 251}, "output": {"x_values": [4000.0, 2000.0, 1000.0, 500.0, 250.0, 125.0], "y_values": [6.3765, 5.6274999999999995, 5.629499999999999, 6.3835, 8.2665, 12.22]}}, {"input": {"overhead": 146}, "output": {"x_values": [4000.0, 2000.0, 1000.0, 500.0, 250.0, 125.0], "y_values": [6.218999999999999, 5.365, 5.157, 5.4910000000000005, 6.534000000000001, 8.807500000000001]}}, {"input": {"overhead": 368}, "output": {"x_values": [4000.0, 2000.0, 1000.0, 500.0, 250.0, 125.0], "y_values": [6.5520000000000005, 5.92, 6.156000000000001, 7.378, 10.197, 16.0225]}}, {"input": {"overhead": 320}, "output": {"x_values": [4000.0, 2000.0, 1000.0, 500.0, 250.0, 125.0], "y_values": [6.48, 5.8, 5.94, 6.97, 9.405, 14.4625]}}, {"input": {"overhead": 95}, "output": {"x_values": [4000.0, 2000.0, 1000.0, 500.0, 250.0, 125.0], "y_values": [6.1425, 5.237500000000001, 4.9275, 5.0575, 5.6925, 7.15]}}, {"input": {"overhead": 479}, "output": {"x_values": [4000.0, 2000.0, 1000.0, 500.0, 250.0, 125.0], "y_values": [6.718500000000001, 6.1975, 6.6555, 8.3215, 12.0285, 19.63]}}, {"input": {"overhead": 200}, "output": {"x_values": [4000.0, 2000.0, 1000.0, 500.0, 250.0, 125.0], "y_values": [6.300000000000001, 5.5, 5.3999999999999995, 5.949999999999999, 7.425, 10.5625]}}], "error_log": []}
{"context": "In a queue for a \"Double Cola\" drink vending machine, Sheldon, Leonard, Penny, Rajesh, and Howard are waiting. Each person, when they drink a cola, doubles and goes to the end of the queue. Given the initial order of the queue and a specific position `n`, which person will drink the n-th cola?\n\nThe input and output requirements are as follows:\n\nInput:\n  `names` (list of strings): A list containing the names of the people in the queue. Each name is a string.\n  `n` (integer): The position in the queue for which we need to find the person who will drink the n-th cola. The value of `n` should be a positive integer.\n\nOutput:\n  `return` (string): The name of the person who will drink the n-th cola.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(names, n):\n    # Convert input to JSON serializable format if necessary\n    names = list(names)  # Ensure names is a list\n    n = int(n)  # Ensure n is an integer\n    \n    i = 0\n    mult = 1\n    while True:\n        for name in names:\n            i += mult\n            if i >= n:\n                return name\n        mult *= 2\n\n# Example usage:\n# print(main_solution([\"Sheldon\", \"Leonard\", \"Penny\", \"Rajesh\", \"Howard\"], 52))", "input_generator": "import random\n\ndef input_generator():\n    names_options = [\n        [\"Sheldon\", \"Leonard\", \"Penny\", \"Rajesh\", \"Howard\"],\n        [\"Alice\", \"Bob\", \"Charlie\", \"David\"],\n        [\"Eve\", \"Frank\", \"Grace\", \"Heidi\", \"Ivan\", \"Judy\"],\n        [\"Mallory\", \"Oscar\", \"Peggy\", \"Sybil\", \"Trent\"],\n        [\"Walter\", \"Xavier\", \"Yvonne\", \"Zoe\"]\n    ]\n    names = random.choice(names_options)\n    n = random.randint(1, 1000)\n    return {\"names\": names, \"n\": n}", "io_pairs": [{"input": {"names": ["Mallory", "Oscar", "Peggy", "Sybil", "Trent"], "n": 598}, "output": "Trent"}, {"input": {"names": ["Sheldon", "Leonard", "Penny", "Rajesh", "Howard"], "n": 539}, "output": "Rajesh"}, {"input": {"names": ["Sheldon", "Leonard", "Penny", "Rajesh", "Howard"], "n": 901}, "output": "Penny"}, {"input": {"names": ["Eve", "Frank", "Grace", "Heidi", "Ivan", "Judy"], "n": 381}, "output": "Eve"}, {"input": {"names": ["Alice", "Bob", "Charlie", "David"], "n": 642}, "output": "Bob"}, {"input": {"names": ["Walter", "Xavier", "Yvonne", "Zoe"], "n": 620}, "output": "Walter"}, {"input": {"names": ["Walter", "Xavier", "Yvonne", "Zoe"], "n": 190}, "output": "Yvonne"}, {"input": {"names": ["Mallory", "Oscar", "Peggy", "Sybil", "Trent"], "n": 543}, "output": "Sybil"}, {"input": {"names": ["Eve", "Frank", "Grace", "Heidi", "Ivan", "Judy"], "n": 632}, "output": "Heidi"}, {"input": {"names": ["Alice", "Bob", "Charlie", "David"], "n": 729}, "output": "Bob"}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, given the current state of the board, the markers chosen by the human and the computer, and the player who starts first, what will be the outcome of the game? Will the human win, the computer win, or will the game end in a draw?\n\nThe input and output requirements are as follows:\n\nInput:\n- `board_state` (list of lists of int): A 3x3 list representing the current state of the Tic-Tac-Toe board. Each cell can be 0 (empty), -1 (human's marker), or 1 (computer's marker).\n- `human_choice` (str): The marker chosen by the human ('X' or 'O').\n- `computer_choice` (str): The marker chosen by the computer ('X' or 'O').\n- `first_player` (str): The player who starts first ('H' for human, 'C' for computer).\n\nOutput:\n- `result` (str): The result of the game. It can be 'HUMAN_WINS', 'COMPUTER_WINS', or 'DRAW'.", "reference_code": "# import necessary packages\nfrom random import choice\n\n# Constants\nHUMAN = -1\nCOMPUTER = 1\n\ndef evaluate(state):\n    '''\n        Do the evaluation of the board current state\n        @{param} state: current board state\n        @{return} 1 if computer wins, -1 if human wins. 0 if draw\n    '''\n    if wins(state, COMPUTER):\n        score = +1\n    elif wins(state, HUMAN):\n        score = -1\n    else:\n        score = 0\n    return score\n\ndef wins(state, player):\n    '''\n        Given the board state, checks if the player won the game\n        @{param} state: current board state\n        @{param} player: which player is\n        @{return} True (has the victory) or False (Does not have the victory yet) \n    '''\n    win_state = [\n        [state[0][0], state[0][1], state[0][2]],\n        [state[1][0], state[1][1], state[1][2]],\n        [state[2][0], state[2][1], state[2][2]],\n        [state[0][0], state[1][0], state[2][0]],\n        [state[0][1], state[1][1], state[2][1]],\n        [state[0][2], state[1][2], state[2][2]],\n        [state[0][0], state[1][1], state[2][2]],\n        [state[0][2], state[1][1], state[2][0]],\n    ]\n    if [player, player, player] in win_state:\n        return True\n    else:\n        return False\n\ndef you_lost(state):\n    '''\n        Checks if the game is over\n        @{param} state: current board state\n        @{return} True if either the player or computer won the game, False otherwise\n    '''\n    return wins(state, HUMAN) or wins(state, COMPUTER)\n\ndef empty_cells(state):\n    '''\n        return a list of empty cells within the current board state\n    '''\n    cells = []\n    for x, row in enumerate(state):\n        for y, cell in enumerate(row):\n            if cell == 0:\n                cells.append([x, y])\n    return cells\n\ndef is_valid(state, x, y):\n    '''\n        Given an coordinate checks if the movement if valid or not\n    '''\n    if [x, y] in empty_cells(state):\n        return True\n    else:\n        return False\n\ndef set_move(state, x, y, player):\n    '''\n        Set the board coordinate as choosen by the player\n    '''\n    if is_valid(state, x, y):\n        state[x][y] = player\n        return True\n    else:\n        return False\n\ndef minmax(state, depth, player):\n    '''\n        @{param} state: current board State\n        @{param} depth: how many empty cells currently exists\n        @{param} player: who is playing with minmax\n        @{return} vector [X, Y, position Score]\n    '''\n    if player == COMPUTER:\n        best = [-1, -1, -float('inf')]\n    else:\n        best = [-1, -1, float('inf')]\n    \n    if depth == 0 or you_lost(state):\n        score = evaluate(state)\n        return [-1, -1, score]\n    \n    for cell in empty_cells(state):\n        x, y = cell[0], cell[1]\n        state[x][y] = player\n        score = minmax(state, depth - 1, -player)\n        state[x][y] = 0\n        score[0], score[1] = x, y\n        \n        if player == COMPUTER:\n            if score[2] > best[2]:\n                best = score\n        else:\n            if score[2] < best[2]:\n                best = score\n    return best\n\ndef main_solution(board_state, human_choice, computer_choice, first_player):\n    '''\n    Main function to determine the outcome of a Tic-Tac-Toe game.\n    \n    Input:\n    - board_state (list of lists of int): The current state of the Tic-Tac-Toe board.\n    - human_choice (str): The marker chosen by the human ('X' or 'O').\n    - computer_choice (str): The marker chosen by the computer ('X' or 'O').\n    - first_player (str): The player who starts first ('H' for human, 'C' for computer).\n    \n    Output:\n    - result (str): The result of the game ('HUMAN_WINS', 'COMPUTER_WINS', 'DRAW').\n    '''\n    board = board_state\n    human_choice = -1 if human_choice == 'X' else 1\n    computer_choice = -1 if computer_choice == 'X' else 1\n    \n    while len(empty_cells(board)) > 0 and not you_lost(board):\n        if first_player == 'C':\n            depth = len(empty_cells(board))\n            if depth == 0 or you_lost(board):\n                break\n            if depth == 9:\n                x = choice([0, 1, 2])\n                y = choice([0, 1, 2])\n            else:\n                move = minmax(board, depth, COMPUTER)\n                x, y = move[0], move[1]\n            set_move(board, x, y, COMPUTER)\n            first_player = ''\n        \n        depth = len(empty_cells(board))\n        if depth == 0 or you_lost(board):\n            break\n        move = minmax(board, depth, HUMAN)\n        x, y = move[0], move[1]\n        set_move(board, x, y, HUMAN)\n        \n        depth = len(empty_cells(board))\n        if depth == 0 or you_lost(board):\n            break\n        if depth == 9:\n            x = choice([0, 1, 2])\n            y = choice([0, 1, 2])\n        else:\n            move = minmax(board, depth, COMPUTER)\n            x, y = move[0], move[1]\n        set_move(board, x, y, COMPUTER)\n    \n    if wins(board, HUMAN):\n        return 'HUMAN_WINS'\n    elif wins(board, COMPUTER):\n        return 'COMPUTER_WINS'\n    else:\n        return 'DRAW'", "input_generator": "import random\nfrom random import choice\n\ndef input_generator():\n    # Generate a random board state (0: empty, -1: X, 1: O)\n    board_state = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    # Randomly fill some cells\n    for _ in range(random.randint(0, 4)):\n        x, y = random.randint(0, 2), random.randint(0, 2)\n        if board_state[x][y] == 0:\n            board_state[x][y] = random.choice([-1, 1])\n    \n    # Randomly choose human and computer choices (X or O)\n    human_choice = random.choice(['X', 'O'])\n    computer_choice = 'O' if human_choice == 'X' else 'X'\n    \n    # Randomly choose first player\n    first_player = random.choice(['H', 'C'])\n    \n    return {\n        'board_state': board_state,\n        'human_choice': human_choice,\n        'computer_choice': computer_choice,\n        'first_player': first_player\n    }", "io_pairs": [{"input": {"board_state": [[1, -1, 1], [-1, -1, 1], [1, 1, -1]], "human_choice": "X", "computer_choice": "O", "first_player": "C"}, "output": "DRAW"}, {"input": {"board_state": [[-1, -1, 1], [-1, 1, 0], [-1, 0, 0]], "human_choice": "O", "computer_choice": "X", "first_player": "H"}, "output": "HUMAN_WINS"}, {"input": {"board_state": [[-1, -1, 1], [1, 1, -1], [-1, 1, -1]], "human_choice": "O", "computer_choice": "X", "first_player": "H"}, "output": "DRAW"}, {"input": {"board_state": [[-1, -1, -1], [0, 0, 0], [0, 0, 0]], "human_choice": "O", "computer_choice": "X", "first_player": "H"}, "output": "HUMAN_WINS"}, {"input": {"board_state": [[-1, -1, 1], [1, 1, -1], [-1, 1, -1]], "human_choice": "O", "computer_choice": "X", "first_player": "H"}, "output": "DRAW"}, {"input": {"board_state": [[-1, 1, 1], [1, 1, -1], [-1, -1, 1]], "human_choice": "O", "computer_choice": "X", "first_player": "C"}, "output": "DRAW"}, {"input": {"board_state": [[1, -1, 1], [1, -1, -1], [-1, 1, 1]], "human_choice": "X", "computer_choice": "O", "first_player": "C"}, "output": "DRAW"}, {"input": {"board_state": [[-1, 1, -1], [-1, -1, 1], [-1, 0, 0]], "human_choice": "X", "computer_choice": "O", "first_player": "H"}, "output": "HUMAN_WINS"}, {"input": {"board_state": [[1, -1, 1], [0, 1, 0], [1, 0, 0]], "human_choice": "O", "computer_choice": "X", "first_player": "C"}, "output": "COMPUTER_WINS"}, {"input": {"board_state": [[1, -1, 1], [1, 1, -1], [1, 0, 0]], "human_choice": "O", "computer_choice": "X", "first_player": "C"}, "output": "COMPUTER_WINS"}], "error_log": []}
{"context": "Given a string consisting of uppercase letters, what are all the possible unique permutations of the string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of all unique permutations of the input string. Each permutation is represented as a string.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all permutations of the list of characters\n    permutations = [''.join(p) for p in itertools.permutations(char_list)]\n    \n    # Return the list of permutations\n    return permutations", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    input_string = ''.join(random.choice(string.ascii_letters) for _ in range(length))\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "kEy"}, "output": ["kEy", "kyE", "Eky", "Eyk", "ykE", "yEk"]}, {"input": {"input_string": "GV"}, "output": ["GV", "VG"]}, {"input": {"input_string": "f"}, "output": ["f"]}, {"input": {"input_string": "zc"}, "output": ["zc", "cz"]}, {"input": {"input_string": "a"}, "output": ["a"]}, {"input": {"input_string": "vpw"}, "output": ["vpw", "vwp", "pvw", "pwv", "wvp", "wpv"]}, {"input": {"input_string": "qp"}, "output": ["qp", "pq"]}, {"input": {"input_string": "gbk"}, "output": ["gbk", "gkb", "bgk", "bkg", "kgb", "kbg"]}, {"input": {"input_string": "b"}, "output": ["b"]}, {"input": {"input_string": "bXB"}, "output": ["bXB", "bBX", "XbB", "XBb", "BbX", "BXb"]}], "error_log": []}
{"context": "Given a set of 4 distinct integers, what is the smallest natural number that cannot be expressed using the basic arithmetic operations (`+`, `-`, `*`, `/`, `m`, `d`) on these integers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numbers` (list of int): A list of 4 distinct integers.\n\nOutput:\n  `return` (int): The least natural number that cannot be expressed using the arithmetic operations (`+`, `-`, `*`, `/`, `m`, `d`) on the given set of 4 distinct integers.", "reference_code": "# import necessary packages\nimport itertools as it\n\n# all class and function definitions in the code file, if any\noperations = '+', '-', '*', '/', 'm', 'd'\n\ndef arithmetic(a, b, bool, o):\n    if o == '+': return (a + b, bool)\n    if o == '-': return (a - b, bool)\n    if o == 'm': return (b - a, bool)\n    if o == '*': return (a * b, bool)\n    if o == '/':\n        if b != 0: return (1. * a / b, bool)\n        else: return (0, False)\n    if o == 'd':\n        if a != 0: return (1. * b / a, bool)\n        else: return (0, False)\n    return (0, False)\n\ndef expressible(A): #given set N of 4 distinct numbers, returns all possible values\n    values = []\n    for B in it.permutations(A, 4):\n        for o1 in operations:\n            for o2 in operations:\n                for o3 in operations:\n                    e, bool = arithmetic(B[2], B[3], True, o1)\n                    e, bool = arithmetic(B[1], e, bool, o2)\n                    e, bool = arithmetic(B[0], e, bool, o3)\n                    if bool and e > 0 and e == 1. * int(e): values.append(int(e))\n                    e, bool1 = arithmetic(B[2], B[3], True, o1)\n                    f, bool2 = arithmetic(B[0], B[1], True, o2)\n                    bool = bool1 and bool2\n                    e, bool = arithmetic(e, f, bool, o3)\n    values.sort()\n    last = values.pop()\n    newvalues = []\n    newvalues.append(last)\n    while(len(values) > 0):\n        next = values.pop()\n        if next != last:\n            newvalues.append(next)\n            last = next\n    newvalues.reverse()\n    return newvalues\n\ndef nonexpressible(A): #given set N of 4 distinct numbers, returns least nonexpressible natural number\n    L = expressible(A)\n    for i in range(len(L)):\n        if L[i] != i + 1: return i + 1\n    return len(L) + 1\n\n# main function\ndef main_solution(numbers):\n    # Convert the input list to a tuple\n    A = tuple(numbers)\n    # Get the least nonexpressible natural number\n    result = nonexpressible(A)\n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate 4 distinct numbers, could be integers between 1 and 20 for reasonable complexity\n    numbers = random.sample(range(1, 21), 4)\n    return {'numbers': numbers}", "io_pairs": [{"input": {"numbers": [2, 5, 18, 4]}, "output": 13}, {"input": {"numbers": [11, 9, 5, 17]}, "output": 1}, {"input": {"numbers": [8, 10, 14, 2]}, "output": 19}, {"input": {"numbers": [5, 11, 18, 6]}, "output": 10}, {"input": {"numbers": [17, 5, 8, 10]}, "output": 8}, {"input": {"numbers": [16, 20, 17, 2]}, "output": 3}, {"input": {"numbers": [20, 11, 14, 10]}, "output": 3}, {"input": {"numbers": [12, 14, 6, 19]}, "output": 2}, {"input": {"numbers": [2, 6, 18, 3]}, "output": 20}, {"input": {"numbers": [7, 14, 15, 18]}, "output": 8}], "error_log": []}
{"context": "Given a chessboard of size NxN, where N is a positive integer, how can you place N queens on the board such that no two queens threaten each other? Specifically, what is the first valid arrangement of queens on a chessboard of size N, where no two queens share the same row, column, or diagonal?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_queens` (int): The number of queens to be placed on an NxN chessboard. This value must be a positive integer.\n\nOutput:\n  `return` (list of int): A list representing the positions of the queens on the chessboard. Each integer in the list represents the column position of the queen in each row. The index of the list represents the row position.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef conflict(state, nextX):\n    nextY = len(state)\n    for i in range(nextY):\n        if abs(state[i] - nextX) in (0, nextY - i):\n            return True\n    return False\n\ndef queen(num, state=()):\n    for i in range(num):\n        if not conflict(state, i):\n            if len(state) == num - 1:\n                yield (i,)\n            else:\n                for result in queen(num, state + (i,)):\n                    yield (i,) + result\n\n# main function\ndef main_solution(num_queens):\n    # Convert the input to the required format\n    num_queens = int(num_queens)\n    \n    # Generate the first solution for the N-Queens problem\n    solution_generator = queen(num_queens)\n    solution = next(solution_generator)\n    \n    # Convert the solution to a JSON serializable format\n    solution_list = list(solution)\n    \n    return solution_list", "input_generator": "import random\n\ndef input_generator():\n    return {'num_queens': random.randint(4, 10)}", "io_pairs": [{"input": {"num_queens": 9}, "output": [0, 2, 5, 7, 1, 3, 8, 6, 4]}, {"input": {"num_queens": 6}, "output": [1, 3, 5, 0, 2, 4]}, {"input": {"num_queens": 5}, "output": [0, 2, 4, 1, 3]}, {"input": {"num_queens": 7}, "output": [0, 2, 4, 6, 1, 3, 5]}, {"input": {"num_queens": 8}, "output": [0, 4, 7, 5, 2, 6, 1, 3]}, {"input": {"num_queens": 4}, "output": [1, 3, 0, 2]}, {"input": {"num_queens": 10}, "output": [0, 2, 5, 7, 9, 4, 8, 1, 3, 6]}], "error_log": []}
{"context": "Given the parameters of a fluid flow system, including the friction factor, pipe length, flow rate, head loss, and kinematic viscosity, what are the calculated values for the pipe diameter, Reynolds number, and coefficient of friction?\n\nThe input and output requirements are as follows:\n\nInput:\n  `f` (float): Friction factor.\n  `l` (float): Length of the pipe.\n  `q` (float): Flow rate.\n  `dh` (float): Head loss.\n  `v` (float): Kinematic viscosity.\n\nOutput:\n  `return` (dict): A dictionary containing the calculated values:\n    - `D` (float): Diameter of the pipe, rounded to 4 decimal places.\n    - `Rey` (float): Reynolds number, rounded to 4 decimal places.\n    - `k` (float): Coefficient of friction, rounded to 4 decimal places.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(f, l, q, dh, v):\n    # Convert inputs to appropriate types if necessary\n    f = float(f)\n    l = float(l)\n    q = float(q)\n    dh = float(dh)\n    v = float(v)\n    \n    # Constants\n    g = 9.81\n    e = 0.000002\n    pi = 3.14\n    \n    # Calculations\n    D = ((8 * f * l * (q * q)) / (pi * g * dh)) ** 0.2\n    Rey = (4 * q) / (pi * D * v)\n    k = 0.25 / (math.log10((e / (3.7 * D)) + (5.74 / (Rey ** 0.9))) ** 2)\n    \n    # Return JSON serializable output\n    return {\n        \"D\": round(D, 4),\n        \"Rey\": round(Rey, 4),\n        \"k\": round(k, 4)\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    f = random.uniform(0.001, 0.1)\n    l = random.uniform(10, 1000)\n    q = random.uniform(0.1, 10)\n    dh = random.uniform(1, 100)\n    v = random.uniform(1e-6, 1e-4)\n    \n    return {\n        \"f\": f,\n        \"l\": l,\n        \"q\": q,\n        \"dh\": dh,\n        \"v\": v\n    }", "io_pairs": [{"input": {"f": 0.07467330922815053, "l": 297.2763786510511, "q": 9.970513358172818, "dh": 72.2523638685738, "v": 6.377791976223442e-05}, "output": {"D": 1.5131, "Rey": 131612.6068, "k": 0.0169}}, {"input": {"f": 0.08205854023359399, "l": 62.1995863422082, "q": 2.026960717335346, "dh": 87.95562497140955, "v": 7.275200664247094e-05}, "output": {"D": 0.5733, "Rey": 61910.5649, "k": 0.0198}}, {"input": {"f": 0.0024257032616199457, "l": 841.0415333141647, "q": 8.29552789126521, "dh": 50.12164634997466, "v": 6.676456147309194e-05}, "output": {"D": 0.9383, "Rey": 168681.1431, "k": 0.0161}}, {"input": {"f": 0.03072308478125508, "l": 852.0688315095252, "q": 1.7023138182538446, "dh": 60.58383991387581, "v": 3.0657573104988e-05}, "output": {"D": 0.7988, "Rey": 88552.6452, "k": 0.0183}}, {"input": {"f": 0.06853358203025842, "l": 594.2957743038234, "q": 8.948506746885357, "dh": 51.71900547109223, "v": 6.212492531186323e-05}, "output": {"D": 1.7492, "Rey": 104897.553, "k": 0.0177}}, {"input": {"f": 0.031173531443532635, "l": 403.10008460762157, "q": 6.702114258679585, "dh": 90.18669399690721, "v": 4.435133384220019e-05}, "output": {"D": 1.102, "Rey": 174679.2034, "k": 0.016}}, {"input": {"f": 0.06367599208632897, "l": 799.4156403564301, "q": 1.3232441462694764, "dh": 55.50966532214422, "v": 4.701971742318499e-05}, "output": {"D": 0.8395, "Rey": 42703.1685, "k": 0.0215}}, {"input": {"f": 0.021020768066516565, "l": 253.20130316088392, "q": 4.255964603634487, "dh": 88.20845238362526, "v": 6.1579427587055075e-06}, "output": {"D": 0.7774, "Rey": 1132594.298, "k": 0.0114}}, {"input": {"f": 0.055017234283634496, "l": 597.418150897022, "q": 4.270776242700463, "dh": 98.82520871940736, "v": 1.4040118431237445e-05}, "output": {"D": 1.0952, "Rey": 353820.923, "k": 0.014}}, {"input": {"f": 0.015710989550107742, "l": 27.27850967750827, "q": 2.337789278462606, "dh": 43.114830379202594, "v": 2.7030887898661693e-05}, "output": {"D": 0.4265, "Rey": 258330.3804, "k": 0.0148}}], "error_log": []}
{"context": "Given a grid of size n*n, how many unique paths can be taken from the top-left corner to the bottom-right corner, moving only right or down? Alternatively, if you were to write out all the numbers from 1 to n in words, how many letters would be used in total? (Note: The problem type and the value of n will be provided.)\n\nThe input and output requirements are as follows:\n\nInput:\n  `problem_type` (str): A string indicating the type of problem to solve. It can be either \"paths\" or \"letters\".\n  `n` (int): An integer representing the size of the grid for the \"paths\" problem or the upper limit for the \"letters\" problem. For \"paths\", `n` must be greater than 0. For \"letters\", `n` must be between 1 and 999 inclusive.\n\nOutput:\n  `return` (int): An integer representing the result of the problem. For \"paths\", it is the total number of possible paths in an n*n grid. For \"letters\", it is the sum of all letters in the numbers from 1 to n inclusive.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef EulerProblem15(n):\n    lst = [[1 for i in range(n+1)] for i in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            lst[i][j] = lst[i-1][j] + lst[i][j-1]\n    return lst[-1][-1]\n\ndef EulerProblem17(n):\n    dct = {1:3, 2:3, 3:5, 4:4, 5:4, 6:3, 7:5, 8:5, 9:4, 10:3, 11:6, 12:6, 13:8, 14:8, 15:7, 16:7, 17:9, 18:8, 19:8, 20:6, 30:6, 40:5, 50:5, 60:5, 70:7, 80:6, 90:6, 100:7}\n    totalletters = 0\n    for i in range(1, n+1):\n        temp = []\n        for j in range(len(str(i))-1, -1, -1):\n            if int(str(i)[-2:]) > 10 and int(str(i)[-2:]) < 20:\n                temp.append(int(str(i)[-2:]))\n                if i > 100:\n                    temp.insert(0, i - int(str(i)[-2:]))\n                break\n            temp.insert(0, int(str(i)[j]) * (10**(len(str(i))-1-j)))\n        for k in range(len(temp)):\n            if temp[k] != 0:\n                if temp[k] >= 100 and i % 100 != 0:\n                    totalletters += dct[100] + dct[temp[k]//100] + 3\n                elif i % 100 == 0:\n                    totalletters += dct[100] + dct[temp[k]//100]\n                else:\n                    totalletters += dct[temp[k]]\n    return totalletters\n\n# main function\ndef main_solution(problem_type, n):\n    if problem_type == \"paths\":\n        return EulerProblem15(n)\n    elif problem_type == \"letters\":\n        return EulerProblem17(n)\n    else:\n        raise ValueError(\"Invalid problem type\")", "input_generator": "import random\n\ndef input_generator():\n    problem_types = [\"paths\", \"letters\"]\n    problem_type = random.choice(problem_types)\n    \n    if problem_type == \"paths\":\n        n = random.randint(1, 20)\n    else:\n        n = random.randint(1, 1000)\n    \n    return {\"problem_type\": problem_type, \"n\": n}", "io_pairs": [{"input": {"problem_type": "letters", "n": 773}, "output": 15862}, {"input": {"problem_type": "paths", "n": 13}, "output": 10400600}, {"input": {"problem_type": "letters", "n": 59}, "output": 470}, {"input": {"problem_type": "letters", "n": 236}, "output": 3749}, {"input": {"problem_type": "letters", "n": 909}, "output": 19035}, {"input": {"problem_type": "letters", "n": 180}, "output": 2572}, {"input": {"problem_type": "letters", "n": 852}, "output": 17708}, {"input": {"problem_type": "paths", "n": 6}, "output": 924}, {"input": {"problem_type": "paths", "n": 5}, "output": 252}, {"input": {"problem_type": "paths", "n": 2}, "output": 6}], "error_log": []}
{"context": "Given a mathematical operation where a number is raised to its own power repeatedly, and the height of this operation is specified, what is the result of this operation modulo another given number? Specifically, what is the result of raising a base number to its own power a certain number of times, and then taking the result modulo a specified value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `base` (int): The base number for the tower operation.\n  `height` (int): The height of the tower operation.\n  `modulo` (int): The modulo value to apply to the result of the tower operation.\n\nOutput:\n  `return` (int): The result of the tower operation modulo the given value.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef tower(base, h, m):\n    \"\"\"Return base ** base ** ... ** base, where the height is h, modulo m. \"\"\"\n    if m == 1:\n        return 0\n    if base == 1:\n        return 1\n    if h == 0:\n        return 1\n    if h == 1:\n        return base % m\n\n    G, t = totient(m)\n\n    if base in G:\n        f = base\n        for j in range(h-2):\n            f = (base ** f) % t\n        return (base ** f) % m\n\n    return 100\n\ndef totient(m):\n    G = set()\n    G.add(1)\n    d = set()\n    for j in range(2, m):\n        if j in d:\n            continue\n        if m % j == 0:\n            d.add(j)\n            jj = j\n            while jj < m:\n                jj += j\n                d.add(jj)\n            continue\n        G.add(j)\n    return G, len(G)\n\n# main function\ndef main_solution(base, height, modulo):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = tower(base, height, modulo)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "input_generator": "import random\n\ndef input_generator():\n    base_options = [1, 2, 3, 5, 7, 10, 15, 20]\n    height_options = [0, 1, 2, 3, 4, 5]\n    modulo_options = [1, 2, 3, 5, 7, 10, 15, 20, 25, 30, 50, 100]\n    \n    base = random.choice(base_options)\n    height = random.choice(height_options)\n    modulo = random.choice(modulo_options)\n    \n    return {'base': base, 'height': height, 'modulo': modulo}", "io_pairs": [{"input": {"base": 20, "height": 2, "modulo": 5}, "output": 100}, {"input": {"base": 20, "height": 5, "modulo": 2}, "output": 100}, {"input": {"base": 3, "height": 4, "modulo": 2}, "output": 100}, {"input": {"base": 15, "height": 5, "modulo": 1}, "output": 0}, {"input": {"base": 2, "height": 2, "modulo": 1}, "output": 0}, {"input": {"base": 1, "height": 2, "modulo": 7}, "output": 1}, {"input": {"base": 3, "height": 2, "modulo": 5}, "output": 2}, {"input": {"base": 5, "height": 4, "modulo": 15}, "output": 100}, {"input": {"base": 15, "height": 0, "modulo": 1}, "output": 0}, {"input": {"base": 7, "height": 5, "modulo": 3}, "output": 100}], "error_log": []}
{"context": "In a classic 8-queens puzzle, the goal is to place eight queens on a chessboard such that no two queens can attack each other. Given a random initial configuration of queens on the board, what is the heuristic value and the search cost after applying the steepest ascent hill climbing algorithm to solve the puzzle?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (str): A comma-separated string representing the positions of the queens on the board. Each value should be an integer between 1 and 8. Example: \"1,2,3,4,5,6,7,8\".\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `heuristic` (int): The heuristic value of the final board configuration after applying the steepest ascent hill climbing algorithm.\n    - `cost` (int): The total search cost incurred during the algorithm's execution.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef generate_random_board():\n    random_board = [random.randint(1, 8) for _ in range(8)]\n    return random_board\n\ndef check_heuristic(board):\n    heuristic = 0\n    for index1 in range(len(board)):\n        descending_Calc1 = index1 + board[index1]\n        n = 1\n        for index2 in range(index1 + 1, len(board)):\n            descending_Calc2 = index2 + board[index2]\n            if (board[index1] == board[index2]) or (descending_Calc1 == descending_Calc2) or (\n                    ((index1 + n) == index2) and ((board[index1] + n) == board[index2])):\n                heuristic += 1\n            n += 1\n    return heuristic\n\ndef steepest_ascent_HC(board):\n    cost1 = 0\n    current_heuristic = check_heuristic(board)\n    if current_heuristic == 0:\n        return current_heuristic, cost1\n    else:\n        for i in range(len(board)):\n            j = 1\n            original = board[i]\n            while j <= len(board):\n                cost1 += 1\n                board[i] = j\n                if check_heuristic(board) < current_heuristic:\n                    return steepest_ascent_HC(board)\n                j += 1\n            board[i] = original\n    return current_heuristic, cost1\n\n# main function\ndef main_solution(board):\n    # Convert the input board to a list of integers\n    board = list(map(int, board.split(',')))\n    \n    # Call the steepest_ascent_HC function\n    heuristic, cost = steepest_ascent_HC(board)\n    \n    # Return the result as a dictionary\n    return {\"heuristic\": heuristic, \"cost\": cost}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random board configuration as a list of integers (1-8)\n    board = [random.randint(1, 8) for _ in range(8)]\n    # Convert the board to a comma-separated string\n    board_str = ','.join(map(str, board))\n    return {'board': board_str}", "io_pairs": [{"input": {"board": "3,2,4,5,6,4,6,6"}, "output": {"heuristic": 1, "cost": 64}}, {"input": {"board": "6,3,4,2,8,8,1,1"}, "output": {"heuristic": 0, "cost": 0}}, {"input": {"board": "1,7,1,6,5,2,2,8"}, "output": {"heuristic": 1, "cost": 64}}, {"input": {"board": "4,5,6,5,1,3,3,8"}, "output": {"heuristic": 0, "cost": 0}}, {"input": {"board": "6,5,4,5,5,8,6,7"}, "output": {"heuristic": 0, "cost": 0}}, {"input": {"board": "3,5,1,2,6,7,6,8"}, "output": {"heuristic": 2, "cost": 64}}, {"input": {"board": "6,2,4,6,2,5,6,4"}, "output": {"heuristic": 0, "cost": 0}}, {"input": {"board": "1,6,1,4,8,7,6,7"}, "output": {"heuristic": 2, "cost": 64}}, {"input": {"board": "6,4,1,4,7,5,8,8"}, "output": {"heuristic": 1, "cost": 64}}, {"input": {"board": "3,6,5,3,5,1,5,8"}, "output": {"heuristic": 3, "cost": 64}}], "error_log": []}
{"context": "Given a Japanese soroban represented by a list of strings, where each string corresponds to a row on the soroban, what is the integer value displayed on the soroban?\n\nThe input and output requirements are as follows:\n\nInput:\n  `soroban_frame` (list of strings): A list of 8 strings representing the soroban frame. Each string has 7 characters, where:\n  - The first two strings represent the upper deck.\n  - The third string is the dividing line.\n  - The next five strings represent the lower deck.\n  - Each character in the strings can be either 'O' (bead) or '|' (wire).\n\nOutput:\n  `return` (int): The integer value represented by the soroban frame.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(soroban_frame):\n    # Convert the input list of strings into a 2D list for easier manipulation\n    ff = [list(row) for row in soroban_frame]\n    a = []\n    \n    # Calculate the value of the upper deck\n    for i in range(len(ff[1])):\n        if ff[1][i] == \"O\":\n            a.append(5 * (10 ** (6 - i)))\n    \n    # Calculate the value of the lower deck\n    for i in range(4, len(ff)):\n        for j in range(len(ff[i])):\n            if ff[i][j] == \"|\":\n                a.append((i - 3) * (10 ** (6 - j)))\n    \n    # Return the sum of the values as the final result\n    return sum(a)", "input_generator": "import random\n\ndef input_generator():\n    # Define the structure of the soroban frame\n    rows = [\n        list(\"OOOOOOOO\"),\n        list(\"OOOOOOOO\"),\n        list(\"-------\"),\n        list(\"||||||||\"),\n        list(\"||||||||\"),\n        list(\"||||||||\"),\n        list(\"||||||||\")\n    ]\n    \n    # Randomly set upper deck beads (first two rows)\n    for i in range(len(rows[0])):\n        if random.random() < 0.3:  # 30% chance to have an 'O' in upper deck\n            rows[0][i] = 'O'\n            rows[1][i] = '-'  # Ensure the second row is '-' if first is 'O'\n        else:\n            rows[0][i] = '-'\n            rows[1][i] = 'O' if random.random() < 0.5 else '-'  # Randomly set second row\n    \n    # Randomly set lower deck beads (last four rows)\n    for i in range(len(rows[3])):\n        active_row = random.randint(3, 6)  # Choose a random row for the bead\n        for j in range(3, 7):\n            if j == active_row:\n                rows[j][i] = '|'\n            else:\n                rows[j][i] = '-'\n    \n    # Convert each row list to a string\n    soroban_frame = [''.join(row) for row in rows]\n    \n    return {'soroban_frame': soroban_frame}", "io_pairs": [{"input": {"soroban_frame": ["---OO-O-", "--O--O-O", "-------", "--|----|", "-|-|||--", "|-----|-", "--------"]}, "output": 2151162.5}, {"input": {"soroban_frame": ["O--O----", "-O---OO-", "-------", "-----|--", "----|-||", "|-------", "-|||----"]}, "output": 2833156.1}, {"input": {"soroban_frame": ["-OO-O-O-", "---O-O-O", "-------", "|-----|-", "--||----", "-|--||-|", "--------"]}, "output": 216270.7}, {"input": {"soroban_frame": ["O--O----", "-----OOO", "-------", "--------", "-|---|--", "--|||---", "|-----||"]}, "output": 3122268.8}, {"input": {"soroban_frame": ["O---OO--", "-O-O----", "-------", "|--|--|-", "-|--|---", "--|--|--", "-------|"]}, "output": 625120.3}, {"input": {"soroban_frame": ["-O---O-O", "--O-----", "-------", "--||----", "-|------", "|---|||-", "-------|"]}, "output": 2150222.3}, {"input": {"soroban_frame": ["-----OOO", "-O-O----", "-------", "--------", "||--||||", "--|-----", "---|----"]}, "output": 1628111.1}, {"input": {"soroban_frame": ["---O--O-", "-OO-OO--", "-------", "-|--|---", "---|-|-|", "|-----|-", "--|-----"]}, "output": 2581562.1}, {"input": {"soroban_frame": ["-O--OOO-", "--O-----", "-------", "|--|----", "----|---", "-|---|--", "--|---||"]}, "output": 280123.3}, {"input": {"soroban_frame": ["-OO--OOO", "O---O---", "-------", "|----|--", "-|-|----", "--|---|-", "----|--|"]}, "output": 5121802.3}], "error_log": []}
{"context": "Given a 15-puzzle game, which is a sliding puzzle that consists of a frame of numbered square tiles in random order with one tile missing, how many tiles are misplaced and what is the total Manhattan distance of all tiles from their goal positions after making a certain number of random moves from the goal state?\n\nThe input and output requirements are as follows:\n\nInput:\n  `depth` (int): The number of random moves to make from the goal state to create the initial puzzle state.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `misplaced_distance` (int): The number of tiles that are not in their correct positions.\n    - `manhattan_distance` (int): The sum of the Manhattan distances (city block distance) of the tiles from their goal positions.", "reference_code": "# import necessary packages\nfrom random import randint\nfrom copy import copy\n\nLineLength = 4\n\nUP = -LineLength\nDOWN = LineLength\nLEFT = -1\nRIGHT = 1\n\n# Represents a state of the puzzle.\nclass state:\n    def __init__(self, old, grid, empty):\n        self.oldState = old\n        self.grid = grid\n        self.emptyCell = empty\n        self.cost = 0\n        if self.oldState:\n            self.cost = self.oldState.cost + 1\n\n    # Signature of the state so we can check for duplicates.\n    def sig(self):\n        s = \"\"\n        for i in self.grid:\n            s += \"_\" + str(i)\n        return s\n\n    def misplacedDistance(self):\n        m = 0\n        for i in range(len(self.grid)):\n            if i != self.grid[i]: m += 1\n        return m\n\n    def manhattanDistance(self):\n        m = 0\n        for i in range(len(self.grid)):\n            j = self.grid[i]\n            m += (abs(i//LineLength - j//LineLength) + abs(i%LineLength - j%LineLength))\n        return m\n\n    def h1(self):\n        return self.misplacedDistance() + self.cost\n\n    def h2(self):\n        return self.manhattanDistance() + self.cost\n\n# Creates a randomised grid, starting from the goal position,\n# and then makes a number of random moves. This will guarantee\n# our puzzles are always solvable. Also ensures that a move cannot\n# reverse a previous move (0.25 chance of happening per move).\ndef randomisedStartState(depth):\n    grid = list(range(LineLength * LineLength))\n    s = state(None, grid, 0)\n    d = 0\n    move = -1\n    keys = []\n    while d < depth:\n        move = randint(0, 3)\n        if move == 0:\n            next = nextNode(s, UP)\n        elif move == 1:\n            next = nextNode(s, DOWN)\n        elif move == 2:\n            next = nextNode(s, LEFT)\n        elif move == 3:\n            next = nextNode(s, RIGHT)\n        if next:\n            if next.sig() not in keys:\n                s = next\n                keys.append(s.sig())\n                d += 1\n    s.cost = 0\n    s.oldState = None\n    return s\n\n# Creates a new grid by swapping elements in state's grid at oldPos and newPos\ndef swap(oldPos, newPos, state):\n    g = copy(state.grid)\n    tmp = g[newPos]\n    g[newPos] = g[oldPos]\n    g[oldPos] = tmp\n    return g\n\n# Get the next state when moving node in direction.\ndef nextNode(node, direction):\n    oldPos = node.emptyCell\n    newPos = oldPos + direction\n    if direction == UP:\n        if newPos < 0: return False\n    elif direction == DOWN:\n        if newPos > (LineLength * LineLength) - 1: return False\n    elif direction == LEFT:\n        if newPos % LineLength >= oldPos % LineLength: return False\n    elif direction == RIGHT:\n        if newPos % LineLength <= oldPos % LineLength: return False\n    return state(node, swap(oldPos, newPos, node), newPos)\n\n# main function\ndef main_solution(depth):\n    # Convert input to the required format\n    depth = int(depth)\n    \n    # Generate the initial state\n    initial_state = randomisedStartState(depth)\n    \n    # Calculate the heuristic values\n    misplaced_distance = initial_state.misplacedDistance()\n    manhattan_distance = initial_state.manhattanDistance()\n    \n    # Return the heuristic values\n    return {\n        \"misplaced_distance\": misplaced_distance,\n        \"manhattan_distance\": manhattan_distance\n    }", "input_generator": "import random\n\ndef input_generator():\n    depth = random.randint(5, 20)\n    return {\"depth\": depth}", "io_pairs": [{"input": {"depth": 13}, "output": {"misplaced_distance": 11, "manhattan_distance": 16}}, {"input": {"depth": 6}, "output": {"misplaced_distance": 7, "manhattan_distance": 10}}, {"input": {"depth": 18}, "output": {"misplaced_distance": 12, "manhattan_distance": 18}}, {"input": {"depth": 15}, "output": {"misplaced_distance": 12, "manhattan_distance": 18}}, {"input": {"depth": 7}, "output": {"misplaced_distance": 8, "manhattan_distance": 12}}, {"input": {"depth": 20}, "output": {"misplaced_distance": 12, "manhattan_distance": 16}}, {"input": {"depth": 16}, "output": {"misplaced_distance": 13, "manhattan_distance": 16}}, {"input": {"depth": 8}, "output": {"misplaced_distance": 9, "manhattan_distance": 10}}, {"input": {"depth": 14}, "output": {"misplaced_distance": 7, "manhattan_distance": 16}}, {"input": {"depth": 12}, "output": {"misplaced_distance": 8, "manhattan_distance": 10}}], "error_log": []}
{"context": "Given a backpack with a certain weight capacity and a set of items each with a specific benefit and weight, what is the optimal combination of items that maximizes the total benefit without exceeding the backpack's weight capacity?\n\nThe input and output requirements are as follows:\n\nInput:\n  `items` (list of tuples): A list of tuples where each tuple contains two integers: the benefit and the weight of an item.\n  `capacity` (int): The maximum weight capacity of the backpack.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `optima` (list of int): A list of benefits of the items included in the optimal solution.\n    - `benefitMax` (int): The maximum benefit achieved without exceeding the capacity.\n    - `weight` (int): The total weight of the items included in the optimal solution.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef pesoMochila(backpack):\n    weight = 0\n    for i in range(len(backpack)):\n        weight = weight + backpack[i][1]\n    return weight\n\ndef benefitMochila(backpack):\n    benefit = 0\n    for i in range(len(backpack)):\n        benefit = benefit + backpack[i][0]\n    return benefit\n\ndef copyBackpack(backpack):\n    newBackpack = []\n    for i in range(len(backpack)):\n        newBackpack.append(backpack[i][0])\n    return newBackpack\n\ndef fillBackpack(n, backpack, items, capacity):\n    benefit = benefitMochila(backpack)\n    weight = pesoMochila(backpack)\n\n    global benefitMax\n    global optima\n    if n >= len(items) or weight >= capacity:\n        if benefit > benefitMax:\n            benefitMax = benefit\n            optima = copyBackpack(backpack)\n    else:\n        x = items[n]\n        if weight + x[1] <= capacity:\n            backpack.append(x)\n            fillBackpack(n+1, backpack, items, capacity)\n            backpack.pop()\n        fillBackpack(n+1, backpack, items, capacity)\n\n# main function\ndef main_solution(items, capacity):\n    # Initialize global variables\n    global benefitMax\n    global optima\n    benefitMax = 0\n    optima = []\n    \n    # Convert items to a list of tuples\n    items = [(b, p) for b, p in items]\n    \n    # Call the fillBackpack function\n    fillBackpack(0, [], items, capacity)\n    \n    # Return the result as a dictionary\n    return {\"optima\": optima, \"benefitMax\": benefitMax, \"weight\": pesoMochila([(b, p) for b, p in zip(optima, [item[1] for item in items])])}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random number of items between 5 and 15\n    num_items = random.randint(5, 15)\n    \n    # Generate random items: each item is a tuple (benefit, weight)\n    items = []\n    for _ in range(num_items):\n        benefit = random.randint(1, 20)\n        weight = random.randint(1, 15)\n        items.append((benefit, weight))\n    \n    # Generate a random capacity between 10 and 30\n    capacity = random.randint(10, 30)\n    \n    return {\"items\": items, \"capacity\": capacity}", "io_pairs": [{"input": {"items": [[16, 4], [4, 4], [18, 4], [10, 13], [18, 5]], "capacity": 15}, "output": {"optima": [16, 18, 18], "benefitMax": 52, "weight": 12}}, {"input": {"items": [[1, 3], [12, 10], [1, 7], [18, 10], [12, 10], [17, 12]], "capacity": 12}, "output": {"optima": [18], "benefitMax": 18, "weight": 3}}, {"input": {"items": [[12, 12], [3, 12], [9, 12], [16, 9], [5, 4], [16, 8]], "capacity": 20}, "output": {"optima": [16, 16], "benefitMax": 32, "weight": 24}}, {"input": {"items": [[17, 15], [1, 3], [3, 1], [5, 9], [13, 15]], "capacity": 25}, "output": {"optima": [17, 3, 5], "benefitMax": 25, "weight": 19}}, {"input": {"items": [[11, 1], [18, 7], [10, 6], [11, 6], [2, 2]], "capacity": 17}, "output": {"optima": [11, 18, 11, 2], "benefitMax": 42, "weight": 20}}, {"input": {"items": [[12, 12], [10, 13], [19, 15], [16, 14], [19, 15], [15, 10]], "capacity": 10}, "output": {"optima": [15], "benefitMax": 15, "weight": 12}}, {"input": {"items": [[19, 7], [7, 3], [4, 8], [16, 15], [12, 4]], "capacity": 16}, "output": {"optima": [19, 7, 12], "benefitMax": 38, "weight": 18}}, {"input": {"items": [[19, 10], [3, 9], [10, 2], [17, 7], [2, 7]], "capacity": 20}, "output": {"optima": [19, 10, 17], "benefitMax": 46, "weight": 21}}, {"input": {"items": [[7, 15], [6, 13], [7, 13], [16, 3], [2, 14]], "capacity": 17}, "output": {"optima": [7, 16], "benefitMax": 23, "weight": 28}}, {"input": {"items": [[14, 15], [4, 6], [9, 6], [9, 2], [1, 10]], "capacity": 13}, "output": {"optima": [9, 9], "benefitMax": 18, "weight": 21}}], "error_log": []}
{"context": "Given a set of digits, what is the largest pandigital number that can be formed using all or some of these digits, which is also a prime number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `digits` (list of integers): A list of integers representing the digits to be used for generating pandigital numbers. The length of the list should be between 1 and 9.\n\nOutput:\n  `return` (string or None): The largest pandigital number formed from the given digits that is also a prime number. If no such number exists, returns `None`.", "reference_code": "# import necessary packages\nfrom itertools import permutations\nimport math\n\n# all class and function definitions in the code file, if any\ndef isPrime(n):\n    if n < 2:\n        return False\n    if n % 2 == 0 and n > 2: \n        return False\n    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))\n\n# main function\ndef main_solution(digits):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    digits = [str(x) for x in digits]\n    found = False\n    for i in range(len(digits), 0, -1):\n        pandigitals = reversed(list(permutations(digits[:i], i)))\n        for p in pandigitals:\n            if isPrime(int(''.join(p))):\n                return ''.join(p)\n    return None", "input_generator": "import random\nimport math\n\ndef input_generator():\n    length = random.randint(2, 7)\n    digits = random.sample(range(1, 10), length)\n    return {'digits': digits}", "io_pairs": [{"input": {"digits": [5, 6, 4, 2, 1, 3]}, "output": "5"}, {"input": {"digits": [2, 9, 6, 4, 7, 5, 3]}, "output": "76249"}, {"input": {"digits": [1, 4, 8]}, "output": "41"}, {"input": {"digits": [8, 3, 6, 1]}, "output": "683"}, {"input": {"digits": [3, 1]}, "output": "13"}, {"input": {"digits": [6, 4, 9, 1, 7]}, "output": "9461"}, {"input": {"digits": [6, 1, 7, 5]}, "output": "5167"}, {"input": {"digits": [6, 2, 8, 3, 5, 9, 7]}, "output": "7958263"}, {"input": {"digits": [2, 5, 6, 7]}, "output": "6257"}, {"input": {"digits": [8, 9, 4, 7, 1, 3]}, "output": "317489"}], "error_log": []}
{"context": "Given a 2D array of random numbers, how would the total sum of the array elements differ if the inner loop is over rows versus columns?\n\nThe input and output requirements are as follows:\n\nInput:\n  `array_shape` (list of int): A list containing two integers representing the shape of the 2D array (n x m).\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `total_row_inside` (float): The total sum of the array elements calculated with the inner loop over rows.\n    - `total_col_inside` (float): The total sum of the array elements calculated with the inner loop over columns.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom numba import jit\n\n# main function\ndef main_solution(array_shape):\n    # Convert JSON serializable input to the original input variables\n    x = np.random.randn(*array_shape)\n\n    @jit\n    def rowinside(x):\n        total = 0\n        n, m = x.shape\n        for i in range(n):\n            for j in range(m):\n                total += x[i, j]\n        return total\n\n    @jit\n    def colinside(x):\n        total = 0\n        n, m = x.shape\n        for j in range(m):\n            for i in range(n):\n                total += x[i, j]\n        return total\n\n    # Calculate the total sum using both row-inside and column-inside methods\n    total_row_inside = rowinside(x)\n    total_col_inside = colinside(x)\n\n    # Return the results as a dictionary\n    return {\n        \"total_row_inside\": total_row_inside,\n        \"total_col_inside\": total_col_inside\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate random array shape with reasonable size (e.g., between 10 and 100 for each dimension)\n    n = random.randint(10, 100)\n    m = random.randint(10, 100)\n    array_shape = (n, m)\n    return {\"array_shape\": array_shape}", "io_pairs": [{"input": {"array_shape": [63, 67]}, "output": {"total_row_inside": -1.5282297190826264, "total_col_inside": -1.5282297190825007}}, {"input": {"array_shape": [40, 42]}, "output": {"total_row_inside": 81.10667005826373, "total_col_inside": 81.10667005826373}}, {"input": {"array_shape": [47, 78]}, "output": {"total_row_inside": -68.03605659873398, "total_col_inside": -68.03605659873395}}, {"input": {"array_shape": [33, 10]}, "output": {"total_row_inside": -25.515880079282475, "total_col_inside": -25.515880079282496}}, {"input": {"array_shape": [89, 79]}, "output": {"total_row_inside": 2.7445829208699366, "total_col_inside": 2.744582920870007}}, {"input": {"array_shape": [73, 99]}, "output": {"total_row_inside": 94.22493989325861, "total_col_inside": 94.22493989325844}}, {"input": {"array_shape": [59, 38]}, "output": {"total_row_inside": 65.70547545364886, "total_col_inside": 65.70547545364882}}, {"input": {"array_shape": [28, 48]}, "output": {"total_row_inside": 46.681419269413716, "total_col_inside": 46.68141926941377}}, {"input": {"array_shape": [34, 61]}, "output": {"total_row_inside": -48.88271219986031, "total_col_inside": -48.88271219986036}}, {"input": {"array_shape": [38, 12]}, "output": {"total_row_inside": 37.389668209897, "total_col_inside": 37.38966820989701}}], "error_log": []}
{"context": "Given a square matrix \\( A \\) with dimensions \\( N \\times N \\), what is the determinant of the matrix, rounded to two decimal places?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of floats): A square matrix represented as a list of lists, where each inner list represents a row of the matrix. The matrix must be square (i.e., the number of rows equals the number of columns).\n\nOutput:\n  `return` (float): The determinant of the input matrix, rounded to 2 decimal places.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix):\n    # Convert the input list of lists to a numpy array\n    arr = np.array(matrix, dtype=float)\n    # Compute the determinant of the matrix\n    det = np.linalg.det(arr)\n    # Round the determinant to 2 decimal places\n    rounded_det = round(det, 2)\n    # Return the rounded determinant\n    return rounded_det", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.randint(2, 5)  # Generate matrices from 2x2 to 5x5\n    matrix = np.random.uniform(-10, 10, (size, size)).tolist()\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[6.376867371593409, -7.300520506611545], [-1.9363676935600793, -6.209363521527413]]}, "output": -53.73}, {"input": {"matrix": [[-0.0960986602769438, -7.844296515624432, 7.064961610086563], [8.673207864413037, -8.13355433460741, -8.00609726993519], [-7.253075132333208, -8.619655505040154, 7.989303770183909]]}, "output": -844.04}, {"input": {"matrix": [[-4.068992238102398, -6.080003899474249], [3.204032618352908, 6.8941369616738335]]}, "output": -8.57}, {"input": {"matrix": [[5.2398517640076605, 2.388599742383594], [3.9938647151028874, -9.61851143007319]]}, "output": -59.94}, {"input": {"matrix": [[-7.878393015025374, -5.892956236857727, 8.600401237271761], [-0.33001475627516896, 4.126763557486964, -3.905446330661757], [-6.461741130830019, -7.819432202528985, 5.976481411959334]]}, "output": 137.48}, {"input": {"matrix": [[-2.8401271831446095, -2.007058089344884, -8.433971898161815], [7.991309468072231, -8.305067812306683, -0.06889537694688208], [-9.34025622614209, 1.781364459873192, 8.020915785609219]]}, "output": 850.37}, {"input": {"matrix": [[9.83197241750345, 2.477618379283923, 1.684406945071391], [-2.6877075073761674, -0.9077747694464939, -4.099245505654794], [-0.18304425334846108, 7.905837636761781, -1.5704912018788768]]}, "output": 287.98}, {"input": {"matrix": [[5.852886343940909, 4.49538174143046], [-8.00131193407074, 2.7927506143587966]]}, "output": 52.31}, {"input": {"matrix": [[-1.1539698981533206, 8.424045823227612, 1.8607248179636553], [-3.3495721940805616, 6.031238791696055, -0.06399755955743913], [-0.3150274714905503, 7.258556075933264, -1.129456156457021]]}, "output": -66.08}, {"input": {"matrix": [[-3.0846130505077447, -2.315776728001058], [-9.144131939066106, -6.1761643565059625]]}, "output": -2.12}], "error_log": []}
{"context": "Given two vectors in three-dimensional space, what are the dot product and the cross product of these vectors?\n\nThe input and output requirements are as follows:\n\nInput:\n  `vector1` (list of float): A list containing three float values representing the x, y, and z components of the first vector.\n  `vector2` (list of float): A list containing three float values representing the x, y, and z components of the second vector.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `dot_product` (float): The dot product of the two vectors.\n    - `cross_product` (list of float): A list containing three float values representing the x, y, and z components of the cross product of the two vectors.", "reference_code": "# import necessary packages\nimport numpy as np\nimport numbers\nimport random\n\n# all class and function definitions in the code file, if any\nclass vector:  # Data type name\n    def __init__(self, i=0, j=0, k=0, orig=None):  # default parameters\n        if orig is None:\n            if not isinstance(i, numbers.Number) or not isinstance(j, numbers.Number) or not isinstance(k, numbers.Number):\n                raise TypeError('Invalid vector <{}, {}, {}> of type <{}, {}, {}>. Vector object must be composed of numeric objects'.format(i, j, k, type(i), type(j), type(k)))\n            self.x = i\n            self.y = j\n            self.z = k\n        else:\n            self.__copy_constructor__(orig)\n\n    def __copy_constructor__(self, orig):\n        self.x = orig.x\n        self.y = orig.y\n        self.z = orig.z\n\n    def __repr__(self):      # overload print function\n        return '<' + str(self.x) + ', ' + str(self.y) + ', ' + str(self.z) + '>'\n\n    def __add__(self, other):       # overload addition\n        return vector(self.x + other.x, self.y + other.y, self.z + other.z)\n\n    def __mul__(self, other):       # overload multiplication\n        if type(other) is type(self):   # check if types are equivalent\n            return self.x*other.x + self.y*other.y + self.z*other.z     # default to dot product\n        elif 'int' in str(type(other)) or 'float' in str(type(other)):\n            return vector(self.x*other, self.y*other, self.z*other)     # if scalar scalar multiply\n\n    def __sub__(self, other):       # Overload subtraction\n        return vector(self.x-other.x, self.y-other.y, self.z-other.z)\n\n    def __radd__(self, other):      # Overload reverse addition\n        return self + other\n\n    def __rmul__(self, other):      # overload reverse multiplication\n        return self*other\n\n    def __rsub__(self, other):      # overload reverse subtraction\n        return self-other\n\n    def __abs__(self):              # overload absolute value\n        return np.sqrt((self.x**2) + (self.y**2) + (self.z**2))\n\n    def __len__(self):\n        return np.sqrt((self.x**2) + (self.y**2) + (self.z**2))\n\n    def __truediv__(self, other):\n        if isinstance(other, int) or isinstance(other, float):\n            return vector(self.x/other, self.y/other, self.z/other)\n\n    def cx(self): return float(self.x)      # get x coord\n\n    def cy(self): return float(self.y)      # get y coord\n\n    def cz(self): return float(self.z)      # get z coord\n\n    def __eq__(self, other):                # overload equality test\n        if isinstance(other, self.__class__):       # check is types are equivalent\n            return self.__dict__ == other.__dict__\n        else:\n            return False\n\n    def __ne__(self, other):                # overload inequality test\n        return not self.__eq__(other)\n\n    def cross(self, other):     # Cross product\n        return vector(self.y*other.z - self.z*other.y, self.z*other.x - self.x*other.z, self.x*other.y - self.y*other.x)\n\n    def dot(self, other):       # dot product\n        return self.x*other.x + self.y*other.y + self.z*other.z\n\n    def __getitem__(self, key):\n        try:\n            assert isinstance(key, int)\n        except AssertionError as e:\n            e.args += ('Error! Index type must be int not {}'.format(type(key)), 'try with int')\n            raise\n        try:\n            assert 0 <= key <= 2\n        except AssertionError as e:\n            e.args += ('Error! Vector index out of range', 'Valid indices between 0 and 2')\n            raise\n        if key == 0:\n            return self.x\n        elif key == 1:\n            return self.y\n        elif key == 2:\n            return self.z\n\n    def __setitem__(self, key, value):\n        if not isinstance(key, int):\n            raise TypeError('Vector index must of of type int')\n        if not 0 <= key <= 2:\n            raise KeyError('Invalid vector index {}. Vector index must be in range [0, 2]'.format(key))\n        if not isinstance(value, numbers.Number):\n            raise TypeError('Invalid value {} of type {}. Vector must store numeric data'.format(value, type(value)))\n        if key == 0:\n            self.x = value\n        elif key == 1:\n            self.y = value\n        elif key == 2:\n            self.z = value\n\n    def aslist(self):\n        return [self.x, self.y, self.z]\n\n# main function\ndef main_solution(vector1, vector2):\n    # Convert JSON serializable inputs to vector objects\n    vec1 = vector(vector1[0], vector1[1], vector1[2])\n    vec2 = vector(vector2[0], vector2[1], vector2[2])\n    \n    # Perform vector operations\n    dot_product = vec1.dot(vec2)\n    cross_product = vec1.cross(vec2).aslist()\n    \n    # Convert results to JSON serializable outputs\n    result = {\n        \"dot_product\": dot_product,\n        \"cross_product\": cross_product\n    }\n    \n    return result", "input_generator": "import random\nimport numbers\n\ndef input_generator():\n    # Generate random coordinates for vector1 and vector2\n    vector1 = [random.uniform(-10.0, 10.0) for _ in range(3)]\n    vector2 = [random.uniform(-10.0, 10.0) for _ in range(3)]\n    \n    return {\n        \"vector1\": vector1,\n        \"vector2\": vector2\n    }", "io_pairs": [{"input": {"vector1": [-9.826226283960766, -7.0680165013762775, -3.952887488380492], "vector2": [-9.70158575110296, -4.890993453440544, 9.699178034670254]}, "output": {"dot_product": 91.55983983980533, "cross_product": [-87.88749722669169, 133.65559507007714, -20.510959751435188]}}, {"input": {"vector1": [-1.6180022882985927, -5.943408491900013, -0.2682688288509141], "vector2": [-2.428675534203797, -7.831955386265276, 7.489184229832038]}, "output": {"dot_product": 48.468998040401864, "cross_product": [-46.61235064807339, 12.769055162577692, -1.7624890572269418]}}, {"input": {"vector1": [-5.507129468126686, 3.154287245290771, 3.65293119604004], "vector2": [-6.131596793822702, 2.2494674186846897, 0.19063953990978888]}, "output": {"dot_product": 41.559356899921575, "cross_product": [-7.615817839003417, -21.348424581666723, 6.952709250991408]}}, {"input": {"vector1": [2.5212477271025495, 3.3917740282850524, 9.52531694654699], "vector2": [-0.34805555096665586, 4.5189038020943215, 1.3115422304641005]}, "output": {"dot_product": 26.942421719433725, "cross_product": [-38.59553609161748, -6.622062305519059, 12.573801718194526]}}, {"input": {"vector1": [-3.9318879586864552, -7.588643721472783, -9.54622429415397], "vector2": [-1.5018478138249218, 3.8126019316853625, -0.8433521225847311]}, "output": {"dot_product": -14.976551855256666, "cross_product": [42.79585197423653, 11.021010030733928, -26.387711609448516]}}, {"input": {"vector1": [3.295081989766132, -9.90029097132308, -7.273239606770248], "vector2": [9.78447041616905, 2.6373619365724785, 3.569639338597428]}, "output": {"dot_product": -19.83286054041346, "cross_product": [-16.15830282032858, -82.92705205672557, 105.55942793807094]}}, {"input": {"vector1": [-6.2897209680992034, 4.172672945468028, 4.8339795255070825], "vector2": [6.433934410712073, 7.0532374601143815, 8.702370711418382]}, "output": {"dot_product": 31.030282799719153, "cross_product": [2.2169413582363404, 85.83699074561822, -71.20959959435824]}}, {"input": {"vector1": [2.4793041744706006, 2.8326747090507194, 8.315999543991833], "vector2": [-5.156613909789782, -0.9854765462022144, 8.205154296474674]}, "output": {"dot_product": 52.65771050640137, "cross_product": [31.43775556831492, -63.225472221778816, 12.163713691758645]}}, {"input": {"vector1": [8.234846694512822, -1.1124128077020874, -6.8587192966014126], "vector2": [9.264813643817462, -2.394887825724952, -0.023163535828325976]}, "output": {"dot_product": 79.117296090577, "cross_product": [-16.400095929568433, -63.35400795181775, -9.41523673704453]}}, {"input": {"vector1": [-1.4088111373742578, 9.795495163399856, -9.205269145758306], "vector2": [-2.4526505244734125, -3.1044440344407453, -0.5558256057369615]}, "output": {"dot_product": -21.83772085053203, "cross_product": [-34.02182991766103, 21.79425489446301, 28.39850168106463]}}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, the AI needs to make a move based on the current state of the board and the selected difficulty level. Given the current board configuration and the difficulty level, what will be the state of the board after the AI makes its move?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists of strings): A 3x3 grid representing the Tic-Tac-Toe board. Each cell can be either \".\", \"X\", or \"O\".\n  `difficulty` (int): An integer representing the difficulty level of the AI. Valid values are 1, 2, or 3.\n\nOutput:\n  `return` (list of lists of strings): The updated 3x3 grid representing the Tic-Tac-Toe board after the AI's move.", "reference_code": "# import necessary packages\nimport copy\nimport random\n\n# all class and function definitions in the code file, if any\ndef place_tile(board, x, y, char):\n    board[y][x] = char\n    return is_win_move(board, x, y, char)\n\ndef is_win_move(hboard, x, y, mchar):\n    board_vals = [[0 for k in range(3)] for l in range(3)]\n\n    # Turn board into values\n    yi = 0\n    while yi < 3:\n        xi = 0\n        while xi < 3:\n            if hboard[yi][xi] == mchar:\n                board_vals[yi][xi] = 1\n            xi += 1\n        yi += 1\n\n    board_vals[y][x] = 1\n\n    # Check rows\n    yi = 0\n    while yi < 3:\n        sum_win = 0\n        xi = 0\n        while xi < 3:\n            sum_win += board_vals[yi][xi]\n            xi += 1\n        if sum_win == 3:\n            return True\n        yi += 1\n\n    # Check columns\n    yi = 0\n    while yi < 3:\n        sum_win = 0\n        xi = 0\n        while xi < 3:\n            sum_win += board_vals[xi][yi]\n            xi += 1\n        if sum_win == 3:\n            return True\n        yi += 1\n\n    # Check diagonals\n    if board_vals[0][0] == 1 and board_vals[1][1] == 1 and board_vals[2][2] == 1:\n        return True\n\n    # Check diagonals\n    if board_vals[0][2] == 1 and board_vals[1][1] == 1 and board_vals[2][0] == 1:\n        return True\n\n    return False\n\ndef ai_turn(board, difficulty):\n    def copy_board(in_board):\n        out_board = [0 for l in range(3)]\n        i = 0\n        for row in in_board:\n            out_board[i] = list(row)\n            i += 1\n        return out_board\n\n    def consider_possibilities(hboard, nchar):\n        next_turn_map = [[0 for j in range(3)] for i in range(3)]\n\n        y = 0\n        while y < 3:\n            x = 0\n            while x < 3:\n                eval_res = evaluate_turn(hboard, x, y, nchar)\n                if not eval_res:\n                    x += 1\n                    continue\n                elif eval_res == 45:\n                    next_turn_map[y][x] = 45\n                elif eval_res == 2:\n                    next_turn_map[y][x] = 2\n                elif eval_res == 100:\n                    next_turn_map[y][x] = 100\n\n                x += 1\n            y += 1\n\n        return next_turn_map\n\n    def evaluate_turn(hboard, mx, my, mchar):\n        if not is_valid_move(hboard, mx, my):\n            return False\n        if is_win_move(hboard, mx, my, mchar):\n            return 100\n        if need_to_block(hboard, mx, my, mchar):\n            return 45\n\n        return 2\n\n    def is_valid_move(hboard, x, y):\n        return hboard[y][x] == \".\"\n\n    def need_to_block(hboard, x, y, mchar):\n        if mchar == \"X\":\n            return is_win_move(hboard, x, y, \"O\")\n        else:\n            return is_win_move(hboard, x, y, \"X\")\n\n    def next_turn_win_lose(hboard, mchar):\n        next_turn_win = consider_possibilities(hboard, mchar)\n        found_next_turn = False\n        possible_moves = 0\n        next_move_x = -1\n        next_move_y = -1\n\n        y = 0\n        while y < 3:\n            x = 0\n            while x < 3:\n                if next_turn_win[y][x] == 100:\n                    found_next_turn = True\n                    next_move_x = x\n                    next_move_y = y\n                    return [found_next_turn, next_move_x, next_move_y, -1]\n                elif next_turn_win[y][x] == 45:\n                    next_move_x = x\n                    next_move_y = y\n                    found_next_turn = True\n                elif not next_turn_win[y][x] == 0:\n                    possible_moves += 1\n                    if possible_moves == 1 and not found_next_turn:\n                        next_move_x = x\n                        next_move_y = y\n                x += 1\n            y += 1\n\n        return [found_next_turn, next_move_x, next_move_y, possible_moves]\n\n    immediate_turn = next_turn_win_lose(board, \"O\")\n\n    if immediate_turn[0]:\n        return place_tile(board, immediate_turn[1], immediate_turn[2], \"O\")\n    elif immediate_turn[3] == 1:\n        return place_tile(board, immediate_turn[1], immediate_turn[2], \"O\")\n    else:\n        options = [[0 for l in range(3)] for k in range(3)]\n\n        y = 0\n        while y < 3:\n            x = 0\n            while x < 3:\n                if is_valid_move(board, x, y):\n                    hypot_board = copy_board(board)\n                    hypot_board[y][x] = \"O\"\n\n                    y1 = 0\n                    while y1 < 3:\n                        x1 = 0\n                        while x1 < 3:\n                            if is_valid_move(hypot_board, x1, y1):\n                                hypot_board2 = copy_board(hypot_board)\n                                hypot_board2[y1][x1] = \"X\"\n\n                                if not next_turn_win_lose(hypot_board2, \"O\")[3] == -1 and not difficulty == 1:\n                                    block_rate = 0\n                                    y2 = 0\n                                    while y2 < 3:\n                                        x2 = 0\n                                        while x2 < 3:\n                                            if is_valid_move(hypot_board2, x2, y2) and not is_win_move(hypot_board2, x2, y2, \"O\"):\n                                                if need_to_block(hypot_board2, x2, y2, \"O\"):\n                                                    block_rate += 1\n\n                                                hypot_board3 = copy_board(hypot_board2)\n                                                hypot_board3[y2][x2] = \"O\"\n\n                                                if not next_turn_win_lose(hypot_board3, \"X\")[3] == -1 and difficulty == 3:\n                                                    y3 = 0\n                                                    while y3 < 3:\n                                                        x3 = 0\n                                                        while x3 < 3:\n                                                            if is_valid_move(hypot_board3, x3, y3) and not is_win_move(hypot_board3, x3, y3, \"X\"):\n                                                                hypot_board4 = copy_board(hypot_board3)\n                                                                hypot_board4[y3][x3] = \"X\"\n\n                                                                block_rate2 = 0\n\n                                                                for row in consider_possibilities(hypot_board4, \"O\"):\n                                                                    for item in row:\n                                                                        if item == 45:\n                                                                            block_rate2 += 1\n\n                                                                if block_rate2 > 1:\n                                                                    options[y][x] -= 10\n\n                                                            x3 += 1\n                                                        y3 += 1\n                                            x2 += 1\n                                        y2 += 1\n\n                                    if block_rate > 1:\n                                        options[y][x] -= 20\n\n                            x1 += 1\n                        y1 += 1\n                else:\n                    options[y][x] = -550\n\n                x += 1\n            y += 1\n\n        best_option_cost = -2000\n        best_option_x = 0\n        best_option_y = 0\n\n        y = 0\n        while y < 3:\n            x = 0\n            while x < 3:\n                if options[y][x] > best_option_cost:\n                    best_option_cost = options[y][x]\n                    best_option_x = x\n                    best_option_y = y\n\n                x += 1\n            y += 1\n\n        return place_tile(board, best_option_x, best_option_y, \"O\")\n\n# main function\ndef main_solution(board, difficulty):\n    # Convert difficulty to integer if it's not already\n    difficulty = int(difficulty)\n    \n    # Call the AI turn function\n    ai_turn(board, difficulty)\n    \n    # Return the updated board\n    return board", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random board with some moves already made\n    board = [['.' for _ in range(3)] for _ in range(3)]\n    chars = ['X', 'O', '.']\n    for y in range(3):\n        for x in range(3):\n            board[y][x] = random.choice(chars)\n    \n    # Ensure at least one empty spot\n    empty_spots = [(x, y) for y in range(3) for x in range(3) if board[y][x] == '.']\n    if not empty_spots:\n        # If no empty spots, randomly pick one to empty\n        x, y = random.randint(0, 2), random.randint(0, 2)\n        board[y][x] = '.'\n    \n    # Random difficulty between 1 and 3\n    difficulty = random.randint(1, 3)\n    \n    return {\n        'board': board,\n        'difficulty': difficulty\n    }", "io_pairs": [{"input": {"board": [["X", "O", "O"], [".", "O", "X"], ["O", ".", "X"]], "difficulty": 1}, "output": [["X", "O", "O"], [".", "O", "X"], ["O", ".", "X"]]}, {"input": {"board": [["X", ".", "X"], ["O", "X", "."], ["X", "X", "O"]], "difficulty": 2}, "output": [["X", ".", "X"], ["O", "X", "."], ["X", "X", "O"]]}, {"input": {"board": [["O", "X", "X"], ["O", "O", "."], ["O", ".", "."]], "difficulty": 3}, "output": [["O", "X", "X"], ["O", "O", "."], ["O", ".", "."]]}, {"input": {"board": [[".", "X", "X"], ["X", "X", "X"], ["O", "X", "O"]], "difficulty": 1}, "output": [[".", "X", "X"], ["X", "X", "X"], ["O", "X", "O"]]}, {"input": {"board": [["O", "O", "O"], ["O", "O", "X"], ["O", "X", "O"]], "difficulty": 1}, "output": [["O", "O", "O"], ["O", "O", "X"], ["O", "X", "O"]]}, {"input": {"board": [["O", "O", "O"], [".", "O", "O"], [".", "O", "X"]], "difficulty": 1}, "output": [["O", "O", "O"], [".", "O", "O"], [".", "O", "X"]]}, {"input": {"board": [["O", "X", "O"], ["X", "O", "."], ["O", "O", "."]], "difficulty": 2}, "output": [["O", "X", "O"], ["X", "O", "."], ["O", "O", "."]]}, {"input": {"board": [["O", "X", "O"], ["O", "X", "O"], ["O", "X", "X"]], "difficulty": 3}, "output": [["O", "X", "O"], ["O", "X", "O"], ["O", "X", "X"]]}, {"input": {"board": [["O", "X", "X"], ["O", "O", "O"], [".", "X", "O"]], "difficulty": 2}, "output": [["O", "X", "X"], ["O", "O", "O"], [".", "X", "O"]]}, {"input": {"board": [["X", "X", "X"], [".", "O", "X"], ["O", "X", "X"]], "difficulty": 3}, "output": [["X", "X", "X"], [".", "O", "X"], ["O", "X", "X"]]}], "error_log": []}
{"context": "Given a sequence of integers, determine if this sequence could represent the post-order traversal of a Binary Search Tree (BST). What is the result indicating whether the sequence is a valid post-order traversal of a BST?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sequence` (list of integers): A list of integers representing the sequence to be verified as the post-order traversal of a Binary Search Tree (BST).\n\nOutput:\n  `return` (string): A string indicating whether the input sequence is a valid post-order traversal of a BST. The possible values are \"Yes\" or \"No\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, sequence):\n        if len(sequence) == 0:\n            return False\n\n        root = sequence[-1]\n        for index, value in enumerate(sequence):\n            if value > root:\n                break\n\n        for value in sequence[index: -1]:\n            if value < root:\n                return False\n\n        left = True\n        if index > 0:\n            left = self.VerifySquenceOfBST(sequence[:index])\n\n        right = True\n        if index < len(sequence) - 1:\n            right = self.VerifySquenceOfBST(sequence[index: -1])\n\n        return left and right\n\n# main function\ndef main_solution(sequence):\n    # Convert the input list to a JSON serializable format\n    sequence_list = list(sequence)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the VerifySquenceOfBST method\n    result = solution.VerifySquenceOfBST(sequence_list)\n    \n    # Convert the result to a JSON serializable format\n    return \"Yes\" if result else \"No\"", "input_generator": "import random\n\ndef input_generator():\n    def generate_sequence(length):\n        if length == 0:\n            return []\n        root = random.randint(1, 100)\n        left_length = random.randint(0, length - 1)\n        left = []\n        if left_length > 0:\n            left = generate_sequence(left_length)\n            left = [x for x in left if x < root]\n        right = []\n        if length - 1 - left_length > 0:\n            right = generate_sequence(length - 1 - left_length)\n            right = [x for x in right if x > root]\n        return left + right + [root]\n    \n    length = random.randint(0, 20)\n    sequence = generate_sequence(length)\n    # Randomly decide whether to shuffle to create invalid sequences sometimes\n    if random.random() < 0.3:\n        random.shuffle(sequence)\n    return {'sequence': sequence}", "io_pairs": [{"input": {"sequence": [30, 32, 7]}, "output": "Yes"}, {"input": {"sequence": [24]}, "output": "Yes"}, {"input": {"sequence": [88]}, "output": "Yes"}, {"input": {"sequence": [25, 94, 45]}, "output": "Yes"}, {"input": {"sequence": [57]}, "output": "Yes"}, {"input": {"sequence": [37, 96, 94, 84]}, "output": "Yes"}, {"input": {"sequence": [12, 47, 24, 9, 62, 50]}, "output": "Yes"}, {"input": {"sequence": [38, 23, 21]}, "output": "Yes"}, {"input": {"sequence": [76, 98, 45, 21, 58]}, "output": "No"}, {"input": {"sequence": [19, 66, 57, 50]}, "output": "Yes"}], "error_log": []}
{"context": "Given a maze represented by a grid of cells, where each cell can either be open (1) or blocked (0), determine if there is a path from the top-left corner to the bottom-right corner. If a path exists, return the path as a grid where each cell in the path is marked as 1. What is the path through the maze?\n\nThe input and output requirements are as follows:\n\nInput:\n  `maze` (list of lists of integers): A 2D list representing the maze. Each element is either 0 (blocked) or 1 (open). The maze is a square grid of size `n x n`.\n\nOutput:\n  `return` (list of lists of integers or None): A 2D list representing the path from the top-left corner to the bottom-right corner. Each element is either 0 (not part of the path) or 1 (part of the path). If no path exists, the function returns `None`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef solve_maze(maze, x, y, solution, n):\n    if x == n-1 and y == n-1 and maze[x][y] == 1:\n        solution[x][y] = 1\n        return True\n\n    if is_safe(maze, x, y, n):\n        solution[x][y] = 1\n\n        if solve_maze(maze, x+1, y, solution, n):\n            return True\n        if solve_maze(maze, x, y+1, solution, n):\n            return True\n\n        solution[x][y] = 0\n        return False\n\n    return False\n\ndef is_safe(maze, x, y, n):\n    if 0 <= x < n and 0 <= y < n and maze[x][y] == 1:\n        return True\n    return False\n\n# main function\ndef main_solution(maze):\n    n = len(maze)\n    solution = [[0 for _ in range(n)] for _ in range(n)]\n    \n    if solve_maze(maze, 0, 0, solution, n):\n        return solution\n    else:\n        return None", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(3, 10)  # Reasonable maze size between 3x3 and 10x10\n    maze = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Ensure there's a path from (0,0) to (n-1,n-1)\n    x, y = 0, 0\n    maze[x][y] = 1  # Start point is always open\n    \n    while x < n - 1 or y < n - 1:\n        if x < n - 1 and (random.choice([True, False]) or y == n - 1):\n            x += 1\n        elif y < n - 1:\n            y += 1\n        maze[x][y] = 1\n    \n    # Randomly add some other open paths\n    for i in range(n):\n        for j in range(n):\n            if maze[i][j] == 0 and random.random() < 0.3:  # 30% chance to open a cell\n                maze[i][j] = 1\n    \n    return {'maze': maze}", "io_pairs": [{"input": {"maze": [[1, 1, 0], [0, 1, 1], [1, 1, 1]]}, "output": [[1, 1, 0], [0, 1, 0], [0, 1, 1]]}, {"input": {"maze": [[1, 1, 0], [1, 1, 0], [0, 1, 1]]}, "output": [[1, 0, 0], [1, 1, 0], [0, 1, 1]]}, {"input": {"maze": [[1, 0, 1, 1], [1, 1, 0, 0], [0, 1, 0, 0], [0, 1, 1, 1]]}, "output": [[1, 0, 0, 0], [1, 1, 0, 0], [0, 1, 0, 0], [0, 1, 1, 1]]}, {"input": {"maze": [[1, 1, 1], [1, 1, 1], [1, 0, 1]]}, "output": [[1, 0, 0], [1, 1, 1], [0, 0, 1]]}, {"input": {"maze": [[1, 1, 1, 1], [1, 1, 0, 1], [0, 0, 1, 1], [1, 1, 0, 1]]}, "output": [[1, 1, 1, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]}, {"input": {"maze": [[1, 1, 0], [1, 1, 0], [1, 1, 1]]}, "output": [[1, 0, 0], [1, 0, 0], [1, 1, 1]]}, {"input": {"maze": [[1, 1, 0], [1, 1, 1], [0, 1, 1]]}, "output": [[1, 0, 0], [1, 1, 0], [0, 1, 1]]}, {"input": {"maze": [[1, 0, 0], [1, 1, 1], [0, 1, 1]]}, "output": [[1, 0, 0], [1, 1, 0], [0, 1, 1]]}, {"input": {"maze": [[1, 0, 1, 1], [1, 1, 0, 1], [1, 0, 1, 0], [1, 1, 1, 1]]}, "output": [[1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 1, 1, 1]]}, {"input": {"maze": [[1, 1, 1], [0, 0, 1], [0, 0, 1]]}, "output": [[1, 1, 1], [0, 0, 1], [0, 0, 1]]}], "error_log": []}
{"context": "Given a function \\( F(u, v) = u^2 + 2v^2 + 2\\sin(2\\pi u)\\sin(2\\pi v) \\), we want to find the minimum value of this function using Newton's method starting from different initial points. What are the final coordinates and the value of the function at these coordinates after a certain number of iterations, given specific parameters for the convergence threshold, learning rate, and maximum iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_point` (list of float): A list containing the initial coordinates `[u, v]` for the Newton's method.\n  `umb` (float): The threshold for the difference in function values to determine convergence.\n  `eta` (float): The learning rate for the Newton's method.\n  `maxIter` (int): The maximum number of iterations allowed.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `final_point` (list of float): The final coordinates `[u, v]` where the minimum is reached.\n    - `iterations` (int): The number of iterations taken to reach the minimum.\n    - `final_value` (float): The value of the function at the final coordinates.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef F(u, v):\n    return u**2 + 2*v**2 + 2*np.sin(2*u*np.pi)*np.sin(2*np.pi*v)\n\ndef dFu(u, v):\n    return 2*u + 4*np.pi*np.cos(2*np.pi*u)*np.sin(2*np.pi*v)\n\ndef dFv(u, v):\n    return 4*v + 4*np.pi*np.sin(2*np.pi*u)*np.cos(2*np.pi*v)\n\ndef d2Fu(u, v):\n    return 2 - 8*np.pi**2*np.sin(2*np.pi*v)*np.sin(2*np.pi*u)\n\ndef d2Fv(u, v):\n    return 4 - 8*np.pi**2*np.sin(2*np.pi*u)*np.sin(2*np.pi*v)\n\ndef dvu(u, v):\n    return 8*np.pi**2*np.cos(2*np.pi*u)*np.cos(2*np.pi*v)\n\ndef duv(u, v):\n    return 8*np.pi**2*np.cos(2*np.pi*v)*np.cos(2*np.pi*u)\n\ndef gradF(u, v):\n    return np.array([dFu(u, v), dFv(u, v)])\n\ndef metodo_newton(w, umb, eta, maxIter):\n    salir = False\n    it = 0.0\n    d = []\n    \n    while it < maxIter and salir == False:\n        q = F(w[0], w[1])\n        \n        d.append([it, F(w[0], w[1])])\n        \n        heussiana = np.array([[d2Fu(w[0], w[0]), duv(w[0], w[1])], [dvu(w[0], w[1]), d2Fv(w[0], w[1])]])\n        \n        w = w - eta * np.dot(np.linalg.pinv(heussiana), gradF(w[0], w[1]))\n        \n        if abs(F(w[0], w[1]) - q) < umb:\n            salir = True\n        \n        it += 1.0\n    \n    return w, d\n\n# main function\ndef main_solution(initial_point, umb, eta, maxIter):\n    # Convert JSON serializable inputs to the original input variables\n    initial_point = np.array(initial_point)\n    \n    # Call the original function\n    w, d = metodo_newton(initial_point, umb, eta, maxIter)\n    \n    # Convert the output to JSON serializable\n    final_point = w.tolist()\n    iterations = len(d)\n    final_value = F(w[0], w[1])\n    \n    return {\n        \"final_point\": final_point,\n        \"iterations\": iterations,\n        \"final_value\": final_value\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    initial_point = [random.uniform(-1.0, 1.0), random.uniform(-1.0, 1.0)]\n    umb = random.uniform(1e-6, 1e-4)\n    eta = random.uniform(0.01, 0.1)\n    maxIter = random.randint(50, 200)\n    \n    return {\n        \"initial_point\": initial_point,\n        \"umb\": umb,\n        \"eta\": eta,\n        \"maxIter\": maxIter\n    }", "io_pairs": [{"input": {"initial_point": [-0.9312927824960378, 0.1666441980486819], "umb": 2.7882630248552035e-05, "eta": 0.07456051609062596, "maxIter": 119}, "output": {"final_point": [-1.0005640241987248, 0.028022758142023086], "iterations": 48, "final_value": 1.0014574037913877}}, {"input": {"initial_point": [0.6603439910625664, -0.9415416007028479], "umb": 5.9392106758157487e-05, "eta": 0.04466313129263069, "maxIter": 160}, "output": {"final_point": [0.4520657017915777, -0.9854280736813157], "iterations": 89, "final_value": 2.200745460426631}}, {"input": {"initial_point": [0.26240495062128133, -0.14315585862917146], "umb": 9.517053204765893e-05, "eta": 0.024381430448883287, "maxIter": 132}, "output": {"final_point": [0.286261240049292, -0.19409056112559028], "iterations": 30, "final_value": -1.6720431298076637}}, {"input": {"initial_point": [0.8785565038788969, 0.6647251915274943], "umb": 6.753598241903192e-05, "eta": 0.09576473616530903, "maxIter": 66}, "output": {"final_point": [0.7716279853291865, 0.7885323832049144], "iterations": 34, "final_value": 3.7627461196552767}}, {"input": {"initial_point": [0.7812106541473132, 0.9233748357972695], "umb": 2.8945196361172417e-06, "eta": 0.06618651598694245, "maxIter": 80}, "output": {"final_point": [0.770236721548713, 0.7915421993268689], "iterations": 72, "final_value": 3.7629998560903934}}, {"input": {"initial_point": [-0.43988730642121676, 0.8904099591267465], "umb": 8.389977275824073e-05, "eta": 0.05487448960423077, "maxIter": 188}, "output": {"final_point": [-0.4490625286612126, 0.9609424725875583], "iterations": 21, "final_value": 2.2013487012741786}}, {"input": {"initial_point": [-0.040498209072781455, 0.534434258486703], "umb": 6.360252590818059e-05, "eta": 0.02621629008691191, "maxIter": 114}, "output": {"final_point": [0.02010902735899043, 0.5032531055729371], "iterations": 94, "final_value": 0.5017807372377897}}, {"input": {"initial_point": [-0.9855681675833663, -0.7038280299593629], "umb": 9.256009669090316e-05, "eta": 0.05135989954022884, "maxIter": 69}, "output": {"final_point": [-1.0257739719409493, -0.5324957979217296], "iterations": 57, "final_value": 1.5539310115416425}}, {"input": {"initial_point": [0.5393969343871949, 0.23681890267018213], "umb": 7.752000919740459e-05, "eta": 0.09322218383888804, "maxIter": 145}, "output": {"final_point": [0.2580035439967657, 0.2607506804424523], "iterations": 36, "final_value": 2.1954640368886635}}, {"input": {"initial_point": [-0.7371587213446704, -0.620452617826176], "umb": 7.356394657983424e-05, "eta": 0.08828029344484813, "maxIter": 199}, "output": {"final_point": [-0.7694999386106044, -0.7878447514329069], "iterations": 43, "final_value": 3.762681853808137}}], "error_log": []}
{"context": "In a simplified version of the Yahtzee game, a player is given a hand of dice and must decide which dice to hold to maximize their expected score. Given a hand of dice and the number of sides on each die, what is the optimal strategy for holding the dice to achieve the highest expected score?\n\nThe input and output requirements are as follows:\n\nInput:\n  `hand` (list of integers): A list of integers representing the dice in the hand. Each integer should be between 1 and `num_die_sides`.\n  `num_die_sides` (integer): An integer representing the number of sides on each die. This should be a positive integer greater than 1.\n\nOutput:\n  `return` (dictionary): A dictionary with the following keys:\n    - `expected_score` (float): The expected score of the optimal strategy.\n    - `hold_dice` (list of integers): A list of integers representing the dice to hold according to the optimal strategy.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef gen_all_sequences(outcomes, length):\n    \"\"\"\n    Iterative function that enumerates the set of all sequences of\n    outcomes of given length.\n    \"\"\"\n    answer_set = set([()])\n    for dummy_idx in range(length):\n        temp_set = set()\n        for partial_sequence in answer_set:\n            for item in outcomes:\n                new_sequence = list(partial_sequence)\n                new_sequence.append(item)\n                temp_set.add(tuple(new_sequence))\n        answer_set = temp_set\n    return answer_set\n\ndef score(hand):\n    \"\"\"\n    Compute the maximal score for a Yahtzee hand according to the\n    upper section of the Yahtzee score card.\n\n    hand: full yahtzee hand\n\n    Returns an integer score \n    \"\"\"\n    high_score = -1\n    operated_digits = []\n    \n    for out_indx in range(len(hand)):\n        digit_sum = 0\n        # Skip if already operated on it\n        if (hand[out_indx] in operated_digits):\n            continue\n        operated_digits.append(hand[out_indx])\n\n        # Calculate the total sum of digits\n        for inr_indx in range(out_indx, len(hand)):\n            if hand[inr_indx] != hand[out_indx]:\n                break\n            digit_sum += hand[out_indx]\n\n        # Compare with overall and change if needed\n        if high_score < digit_sum:\n            high_score = digit_sum\n\n    return high_score\n\ndef expected_value(held_dice, num_die_sides, num_free_dice):\n    \"\"\"\n    Compute the expected value based on held_dice given that there\n    are num_free_dice to be rolled, each with num_die_sides.\n\n    held_dice: dice that you will hold\n    num_die_sides: number of sides on each die\n    num_free_dice: number of dice to be rolled\n\n    Returns a floating point expected value\n    \"\"\"\n    \n    # get all the outcomes from free dices\n    outcomes = []\n    for possible_out in range(1, num_die_sides + 1):\n        outcomes.append(possible_out)\n    outcomes = tuple(outcomes)\n    all_free_seq = gen_all_sequences(outcomes, num_free_dice)\n\n    # For each free seq, create full seq, sort and calculate score\n    all_seq_score = []\n    for free_seq in all_free_seq:\n        full_seq = list(held_dice + free_seq)\n        full_seq.sort()\n        seq_score = score(tuple(full_seq))     \n        all_seq_score.append(seq_score)\n    \n    # get the average of all the possible scores\n    total_sum = 0\n    for seq_sum in all_seq_score:\n        total_sum += seq_sum\n    \n    average_sum = float(total_sum) / float(len(all_seq_score))\n    return average_sum\n\ndef gen_all_holds(hand):\n    \"\"\"\n    Generate all possible choices of dice from hand to hold.\n\n    hand: full yahtzee hand\n\n    Returns a set of tuples, where each tuple is dice to hold\n    \"\"\"\n    powerset = set()\n    powerset.add(())\n    for sset_len in range(1, len(hand) + 1):\n        len_ss_list = gen_subsets(hand, sset_len)\n        for len_ss in len_ss_list:\n            len_ss.sort()\n            tmp_tuple = tuple(len_ss)\n            powerset.add(tmp_tuple)\n    return powerset\n\ndef gen_subsets(ss_list, length):\n    \"\"\"\n    Generates subsets of particular length\n    returns a list of lists (subsets)\n    \"\"\"\n    if length == 0:\n        return [[]]\n    if len(ss_list) == 0:\n        return []\n    rec_list = ss_list[1:]\n    subsets = gen_subsets(rec_list, length - 1)\n    for element in subsets:\n        element.append(ss_list[0])\n    return subsets + gen_subsets(rec_list, length)\n\ndef strategy(hand, num_die_sides):\n    \"\"\"\n    Compute the hold that maximizes the expected value when the\n    discarded dice are rolled.\n\n    hand: full yahtzee hand\n    num_die_sides: number of sides on each die\n\n    Returns a tuple where the first element is the expected score and\n    the second element is a tuple of the dice to hold\n    (expected_score, (hold_dice))\n    \"\"\"\n    # Get all the hold possible\n    all_holds_set = gen_all_holds(hand)\n    \n    strategic_score = float(-1)\n    strategic_hold = ()\n\n    # For each hold get the average value\n    for hold_set in all_holds_set:\n        free_dice_to_roll = len(hand) - len(hold_set)\n        ave_exp_val = expected_value(hold_set, num_die_sides, free_dice_to_roll)\n        \n        # if Average value is higher than strategic_score, swap\n        if strategic_score < ave_exp_val:\n            strategic_score = ave_exp_val\n            strategic_hold = hold_set\n\n    return (strategic_score, strategic_hold)\n\n# main function\ndef main_solution(hand, num_die_sides):\n    \"\"\"\n    Compute the optimal strategy for a given Yahtzee hand and number of die sides.\n\n    hand: list of integers representing the dice in the hand\n    num_die_sides: integer representing the number of sides on each die\n\n    Returns a dictionary with keys 'expected_score' and 'hold_dice', where 'expected_score' is a float\n    representing the expected score and 'hold_dice' is a list of integers representing the dice to hold.\n    \"\"\"\n    # Convert hand to tuple for compatibility with existing functions\n    hand_tuple = tuple(hand)\n    \n    # Get the optimal strategy\n    expected_score, hold_dice = strategy(hand_tuple, num_die_sides)\n    \n    # Convert hold_dice back to list for JSON serializability\n    hold_dice_list = list(hold_dice)\n    \n    return {\n        'expected_score': expected_score,\n        'hold_dice': hold_dice_list\n    }", "input_generator": "import random\n\ndef input_generator():\n    num_die_sides = random.choice([4, 6, 8, 10, 12, 20])\n    hand_size = random.randint(1, 5)\n    hand = [random.randint(1, num_die_sides) for _ in range(hand_size)]\n    return {\n        'hand': hand,\n        'num_die_sides': num_die_sides\n    }", "io_pairs": [{"input": {"hand": [7, 4, 3, 1, 7], "num_die_sides": 8}, "output": {"expected_score": 16.724609375, "hold_dice": [7, 7]}}, {"input": {"hand": [2], "num_die_sides": 6}, "output": {"expected_score": 3.5, "hold_dice": []}}, {"input": {"hand": [4, 1], "num_die_sides": 6}, "output": {"expected_score": 5.166666666666667, "hold_dice": [4]}}, {"input": {"hand": [9, 9], "num_die_sides": 10}, "output": {"expected_score": 18.0, "hold_dice": [9, 9]}}, {"input": {"hand": [3], "num_die_sides": 4}, "output": {"expected_score": 3.0, "hold_dice": [3]}}, {"input": {"hand": [1, 1], "num_die_sides": 4}, "output": {"expected_score": 3.75, "hold_dice": []}}, {"input": {"hand": [7, 2, 6], "num_die_sides": 8}, "output": {"expected_score": 9.21875, "hold_dice": [7]}}, {"input": {"hand": [11], "num_die_sides": 12}, "output": {"expected_score": 11.0, "hold_dice": [11]}}, {"input": {"hand": [6], "num_die_sides": 8}, "output": {"expected_score": 6.0, "hold_dice": [6]}}, {"input": {"hand": [7, 3, 6, 2], "num_die_sides": 8}, "output": {"expected_score": 10.546875, "hold_dice": [7]}}], "error_log": []}
{"context": "In an experiment to study the relationship between current and voltage across a resistor, you have collected a set of data points. Given this data, how would you determine the voltage at a specific current value using both Newton's polynomial interpolation and polynomial regression? Specifically, what are the voltage values calculated using these two methods for a given target current?\n\nThe input and output requirements are as follows:\n\nInput:\n  `currents` (list of float): A list of current values measured in the experiment.\n  `voltages` (list of float): A list of voltage values corresponding to the current values.\n  `target_current` (float): The current value for which the voltage needs to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing the calculated voltage values.\n    - `voltage_newton` (float): The voltage calculated using Newton's polynomial interpolation.\n    - `voltage_regression` (float): The voltage calculated using polynomial regression.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef coef(x, y):\n    x.astype(float)\n    y.astype(float)\n    n = len(x)\n    a = []\n    for i in range(n):\n        a.append(y[i])\n\n    for j in range(1, n):\n        for i in range(n-1, j-1, -1):\n            a[i] = float(a[i]-a[i-1])/float(x[i]-x[i-j])\n    \n    return np.array(a)\n\ndef puntoa(x, y, a):\n    func = (lambda x1: a[0] + a[1]*(x1-x[0]) + a[2]*(x1-x[0])*(x1-x[1]) + a[3]*(x1-x[0])*(x1-x[1])*(x1-x[2]))\n    return func(0.10)\n\ndef b(i, V, punto):\n    C = np.polyfit(i, V, 3)\n    func = (lambda th: C[0]*th**3 + C[1]*th**2 + C[2]*th**1 + C[3])\n    return func(punto)\n\n# main function\ndef main_solution(currents, voltages, target_current):\n    # Convert inputs to numpy arrays\n    currents = np.array(currents)\n    voltages = np.array(voltages)\n    \n    # Calculate coefficients for Newton's polynomial interpolation\n    coefficients = coef(currents, voltages)\n    \n    # Calculate voltage using Newton's polynomial interpolation\n    voltage_newton = puntoa(currents, voltages, coefficients)\n    \n    # Calculate voltage using polynomial regression\n    voltage_regression = b(currents, voltages, target_current)\n    \n    # Return the results as a dictionary\n    return {\n        \"voltage_newton\": voltage_newton,\n        \"voltage_regression\": voltage_regression\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random number of points (between 4 and 10)\n    n = random.randint(4, 10)\n    \n    # Generate random currents (sorted to avoid division issues in coef)\n    currents = np.sort(np.random.uniform(0.1, 10.0, n))\n    \n    # Generate corresponding voltages (random but somewhat correlated with currents)\n    voltages = currents * np.random.uniform(0.5, 2.0, n) + np.random.normal(0, 0.5, n)\n    \n    # Generate a target current within the range of currents\n    target_current = random.uniform(min(currents), max(currents))\n    \n    return {\n        \"currents\": currents.tolist(),\n        \"voltages\": voltages.tolist(),\n        \"target_current\": target_current\n    }", "io_pairs": [{"input": {"currents": [3.1925573702278283, 4.976709394550438, 8.931050430228627, 9.963247897145475], "voltages": [5.555939137146347, 6.175418385625724, 16.370587882137883, 8.442319020317836], "target_current": 9.075822627334839}, "output": {"voltage_newton": 58.46360902853104, "voltage_regression": 15.713183157546553}}, {"input": {"currents": [3.793946947407754, 5.943887407613194, 6.16313654014008, 7.371570235426324, 9.472169526029742], "voltages": [3.187204942396086, 9.68041201460917, 7.379950266019223, 9.66309953020093, 10.247964625399776], "target_current": 4.247112543120873}, "output": {"voltage_newton": -657.0319428059832, "voltage_regression": 4.893304350241735}}, {"input": {"currents": [6.995028366651749, 7.928599785833024, 8.387623934621876, 9.580351509268707], "voltages": [3.4553686600448072, 7.789223819098023, 5.001956606229501, 6.755974857431752], "target_current": 7.2150994071084105}, "output": {"voltage_newton": -2565.329119403045, "voltage_regression": 6.5581860495281035}}, {"input": {"currents": [1.6614337307002998, 1.7053973468554458, 1.8633501046813143, 2.595985945899099, 5.511595144834334, 7.128956264537894, 9.140707194236496], "voltages": [1.4243096029199376, 3.1324047389877343, 1.1496173543213937, 3.6295958166876554, 7.774163211021125, 11.55950846531093, 12.915595845437343], "target_current": 5.246712898606765}, "output": {"voltage_newton": -1986.2135884249888, "voltage_regression": 7.764601260143555}}, {"input": {"currents": [4.088961279973512, 6.914809724260245, 8.952857671258027, 9.874620014800774], "voltages": [4.602510891052708, 5.116805432211262, 7.197500035634516, 18.607938330397797], "target_current": 8.81586261883051}, "output": {"voltage_newton": -143.87865367111118, "voltage_regression": 6.232908575147746}}, {"input": {"currents": [1.0902949621773792, 2.9732675475034194, 3.2471991921312497, 4.102952959202058, 4.492182152914688, 7.3221605190805255], "voltages": [1.5883539925006485, 3.24349037190575, 6.525677861082545, 2.1119822893166424, 9.430864804568012, 7.171540596569842], "target_current": 2.1321522802630515}, "output": {"voltage_newton": 75.76317532269722, "voltage_regression": 2.500913920566681}}, {"input": {"currents": [4.0284130347594385, 4.981379836570076, 5.383533341458012, 6.648699133926734], "voltages": [3.359484687177117, 6.961242391662154, 10.557133508438856, 10.920517409881219], "target_current": 5.49403937458833}, "output": {"voltage_newton": 409.55436804357436, "voltage_regression": 11.475852501253485}}, {"input": {"currents": [2.292659177424082, 5.559224601206006, 7.890465130968844, 8.407155649911042], "voltages": [0.4406306922874932, 9.216592095442051, 7.8261410412679915, 4.894177609626171], "target_current": 2.418493224596644}, "output": {"voltage_newton": 5.7788047324194025, "voltage_regression": 0.5872739200150789}}, {"input": {"currents": [0.9382449065782802, 6.832122416736965, 7.740488140983433, 8.062936469517082], "voltages": [1.4327298198906118, 9.710812578315808, 15.273094027337809, 15.56897205041648], "target_current": 6.214630240910635}, "output": {"voltage_newton": 33.964432087039704, "voltage_regression": 3.147948965027325}}, {"input": {"currents": [1.0518799246981896, 1.199232717292149, 4.456866355363842, 6.450760795502039, 8.76005519791234, 8.935653892834157, 9.917231207809701], "voltages": [1.877131247321718, 1.7513130369318273, 4.554466857119777, 4.842427356961581, 11.777932880612653, 16.915528788786364, 6.90567910241416], "target_current": 2.3116047313835453}, "output": {"voltage_newton": 3.756980222251163, "voltage_regression": -0.8717294529725113}}], "error_log": []}
{"context": "Given a step function, we approximate it using a Fourier series. The Gibbs phenomenon occurs at the points of discontinuity, where the Fourier series overshoots the function's value. What is the Wilbraham-Gibbs constant, which represents the maximum overshoot at the points of discontinuity, when using a Fourier series with a specified number of terms?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_terms` (int): The number of terms to include in the Fourier series approximation. This should be a positive integer.\n\nOutput:\n  `return` (dict): A dictionary containing the Wilbraham-Gibbs constant as a floating-point number under the key `\"wilbraham_gibbs_constant\"`.", "reference_code": "# import necessary packages\nfrom sympy import var, sqrt, integrate, conjugate, Abs, I, pi, sin, cos, sign, lambdify, Integral, S\n\n# Define necessary variables and functions\nx = var(\"x\", real=True)\n\ndef l2_norm(f, lim):\n    return sqrt(integrate(Abs(f)**2, lim))\n\ndef l2_inner_product(a, b, lim):\n    return integrate(conjugate(a)*b, lim)\n\ndef l2_projection(f, basis, lim):\n    r = 0\n    for b in basis:\n        r += l2_inner_product(f, b, lim) * b\n    return r\n\ndef l2_gram_schmidt(list, lim):\n    r = []\n    for a in list:\n        if r == []:\n            v = a\n        else:\n            v = a - l2_projection(a, r, lim)\n        v_norm = l2_norm(v, lim)\n        if v_norm == 0:\n            raise ValueError(\"The sequence is not linearly independent.\")\n        r.append(v/v_norm)\n    return r\n\ndef integ(f):\n    return integrate(f, (x, -pi, 0)) + integrate(-f, (x, 0, pi))\n\ndef series(L):\n    r = 0\n    for b in L:\n        r += integ(b)*b\n    return r\n\ndef msolve(f, x):\n    f = lambdify(x, f)\n    x0 = -0.001\n    dx = 0.001\n    while f(x0 - dx) * f(x0) > 0:\n        x0 = x0 - dx\n    x_max = x0 - dx\n    x_min = x0\n    assert f(x_max) > 0\n    assert f(x_min) < 0\n    for n in range(100):\n        x0 = (x_max + x_min)/2\n        if f(x0) > 0:\n            x_max = x0\n        else:\n            x_min = x0\n    return x0\n\n# main function\ndef main_solution(num_terms):\n    L = [1]\n    for i in range(1, num_terms):\n        L.append(cos(i*x))\n        L.append(sin(i*x))\n    L[0] /= sqrt(2)\n    L = [f/sqrt(pi) for f in L]\n\n    f = series(L)\n    x0 = msolve(f.diff(x), x)\n    max_value = f.subs(x, x0).evalf()\n    wilbraham_gibbs_constant = max_value * pi / 2\n    return {\"wilbraham_gibbs_constant\": float(wilbraham_gibbs_constant)}", "input_generator": "import random\n\ndef input_generator():\n    num_terms = random.randint(2, 10)\n    return {\"num_terms\": num_terms}", "io_pairs": [{"input": {"num_terms": 6}, "output": {"wilbraham_gibbs_constant": 1.8666666666666663}}, {"input": {"num_terms": 2}, "output": {"wilbraham_gibbs_constant": 2.0}}, {"input": {"num_terms": 7}, "output": {"wilbraham_gibbs_constant": 1.8666666666666663}}, {"input": {"num_terms": 9}, "output": {"wilbraham_gibbs_constant": 1.8601764896084347}}, {"input": {"num_terms": 5}, "output": {"wilbraham_gibbs_constant": 1.8856180831641265}}, {"input": {"num_terms": 8}, "output": {"wilbraham_gibbs_constant": 1.8601764896084347}}, {"input": {"num_terms": 3}, "output": {"wilbraham_gibbs_constant": 2.0}}, {"input": {"num_terms": 10}, "output": {"wilbraham_gibbs_constant": 1.8571968075395158}}, {"input": {"num_terms": 4}, "output": {"wilbraham_gibbs_constant": 1.8856180831641265}}], "error_log": []}
{"context": "Given a sequence generation algorithm, where each term in the sequence is determined by whether the previous term is even or odd, what is the sequence generated for a given length and initial value? Specifically, if the previous term is even, the next term is half of the previous term; if the previous term is odd, the next term is three times the previous term plus one.\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The length of the sequence to generate.\n  `a0` (int): The initial value of the sequence.\n\nOutput:\n  `return` (list of int): The generated sequence of integers.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef sequence(n, a0=1):\n    \"\"\" Generates a sequence\n    \"\"\"\n    seq = [a0]\n    for i in range(1, n):\n        if seq[-1] % 2 == 0:\n            seq.append(seq[-1] / 2)\n        else:\n            seq.append(3 * seq[-1] + 1)\n    return seq\n\n# main function\ndef main_solution(n, a0):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    seq = sequence(n, a0)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return seq", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 20)\n    a0 = random.randint(1, 100)\n    return {'n': n, 'a0': a0}", "io_pairs": [{"input": {"n": 14, "a0": 28}, "output": [28, 14.0, 7.0, 22.0, 11.0, 34.0, 17.0, 52.0, 26.0, 13.0, 40.0, 20.0, 10.0, 5.0]}, {"input": {"n": 17, "a0": 32}, "output": [32, 16.0, 8.0, 4.0, 2.0, 1.0, 4.0, 2.0, 1.0, 4.0, 2.0, 1.0, 4.0, 2.0, 1.0, 4.0, 2.0]}, {"input": {"n": 3, "a0": 89}, "output": [89, 268, 134.0]}, {"input": {"n": 7, "a0": 52}, "output": [52, 26.0, 13.0, 40.0, 20.0, 10.0, 5.0]}, {"input": {"n": 14, "a0": 9}, "output": [9, 28, 14.0, 7.0, 22.0, 11.0, 34.0, 17.0, 52.0, 26.0, 13.0, 40.0, 20.0, 10.0]}, {"input": {"n": 18, "a0": 34}, "output": [34, 17.0, 52.0, 26.0, 13.0, 40.0, 20.0, 10.0, 5.0, 16.0, 8.0, 4.0, 2.0, 1.0, 4.0, 2.0, 1.0, 4.0]}, {"input": {"n": 14, "a0": 65}, "output": [65, 196, 98.0, 49.0, 148.0, 74.0, 37.0, 112.0, 56.0, 28.0, 14.0, 7.0, 22.0, 11.0]}, {"input": {"n": 12, "a0": 52}, "output": [52, 26.0, 13.0, 40.0, 20.0, 10.0, 5.0, 16.0, 8.0, 4.0, 2.0, 1.0]}, {"input": {"n": 9, "a0": 13}, "output": [13, 40, 20.0, 10.0, 5.0, 16.0, 8.0, 4.0, 2.0]}, {"input": {"n": 17, "a0": 55}, "output": [55, 166, 83.0, 250.0, 125.0, 376.0, 188.0, 94.0, 47.0, 142.0, 71.0, 214.0, 107.0, 322.0, 161.0, 484.0, 242.0]}], "error_log": []}
{"context": "Given a binomial distribution with a certain probability of success, a number of trials, and a specific number of successes, what is the probability of observing exactly that number of successes in the given number of trials?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p_value` (float): The probability parameter in the binomial distribution.\n  `n_value` (int): The number of trials in the binomial distribution.\n  `x_value` (int): The number of successes in the binomial distribution.\n\nOutput:\n  `return` (float): The evaluated value of the binomial distribution function for the given parameters.", "reference_code": "# import necessary packages\nimport sympy as sym\nfrom sympy import Symbol\n\n# main function\ndef main_solution(p_value, n_value, x_value):\n    # Define the symbols\n    p = Symbol('p')\n    x = Symbol('x')\n    n = Symbol('n')\n    \n    # Define the parts of the binomial distribution function\n    my_function_3_part_0 = sym.factorial(n) / (sym.factorial(x) * sym.factorial(n - x))\n    my_function_3_part_1 = p ** x\n    my_function_3_part_2 = (1 - p) ** (n - x)\n    \n    # Combine the parts to form the binomial distribution function\n    my_function_3 = my_function_3_part_0 * my_function_3_part_1 * my_function_3_part_2\n    \n    # Substitute the given values into the function and evaluate\n    result = my_function_3.subs({p: p_value, n: n_value, x: x_value}).evalf()\n    \n    # Return the result as a float\n    return float(result)", "input_generator": "import random\nimport sympy as sym\n\ndef input_generator():\n    p_value = random.uniform(0.1, 0.9)  # Probability between 0.1 and 0.9\n    n_value = random.randint(1, 20)     # Number of trials between 1 and 20\n    x_value = random.randint(0, n_value) # Number of successes between 0 and n_value\n    return {'p_value': p_value, 'n_value': n_value, 'x_value': x_value}", "io_pairs": [{"input": {"p_value": 0.4177591527540131, "n_value": 7, "x_value": 3}, "output": 0.2932625768092819}, {"input": {"p_value": 0.538007432137959, "n_value": 11, "x_value": 2}, "output": 0.015263500360467155}, {"input": {"p_value": 0.2307318660529294, "n_value": 7, "x_value": 7}, "output": 3.481392979830628e-05}, {"input": {"p_value": 0.6816918712077621, "n_value": 4, "x_value": 4}, "output": 0.21594962849192115}, {"input": {"p_value": 0.44967892476918314, "n_value": 10, "x_value": 8}, "output": 0.02278584162540947}, {"input": {"p_value": 0.5921951907300645, "n_value": 19, "x_value": 13}, "output": 0.13747991559029166}, {"input": {"p_value": 0.20136771044009338, "n_value": 18, "x_value": 1}, "output": 0.07927916105624998}, {"input": {"p_value": 0.341530205859095, "n_value": 11, "x_value": 0}, "output": 0.01009007587208311}, {"input": {"p_value": 0.6024312702517249, "n_value": 16, "x_value": 15}, "output": 0.0031779334609119037}, {"input": {"p_value": 0.22261797233294045, "n_value": 16, "x_value": 2}, "output": 0.1750590771404315}], "error_log": []}
{"context": "Given a function \\( f(x) = x^2 \\), you are tasked with calculating the integral of this function over a specified interval using different numerical methods. The interval is defined by the lower bound `x1` and the upper bound `x2`. The interval is divided into `n` partitions, and the integral is computed using one of the following methods: short edge rectangles, long edge rectangles, midpoint rectangles, or trapezoidal rule. Which integral value will you obtain for the given interval and method?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x1` (float): The lower bound of the integral.\n  `x2` (float): The upper bound of the integral.\n  `n` (int): The number of partitions to divide the interval `[x1, x2]`.\n  `method` (str): The method to use for numerical integration. Possible values are \"short_edge\", \"long_edge\", \"midpoint\", and \"trapezoidal\".\n\nOutput:\n  `return` (float): The computed integral value using the specified method.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef f(x):\n    return x**2\n\n# main function\ndef main_solution(x1, x2, n, method):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    h = (x2 - x1) / n\n    integral = 0\n\n    if method == \"short_edge\":\n        for i in range(n):\n            integral += f(x1 + i * h) * h\n    elif method == \"long_edge\":\n        for i in range(1, n + 1):\n            integral += f(x1 + i * h) * h\n    elif method == \"midpoint\":\n        for i in range(n):\n            integral += f(x1 + h / 2 + i * h) * h\n    elif method == \"trapezoidal\":\n        for i in range(n):\n            integral += (f(x1 + i * h) + f(x1 + (i + 1) * h)) * h / 2\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return integral", "input_generator": "import random\n\ndef input_generator():\n    methods = [\"short_edge\", \"long_edge\", \"midpoint\", \"trapezoidal\"]\n    x1 = random.uniform(-10, 10)\n    x2 = x1 + random.uniform(1, 20)\n    n = random.randint(10, 100)\n    method = random.choice(methods)\n    return {\"x1\": x1, \"x2\": x2, \"n\": n, \"method\": method}", "io_pairs": [{"input": {"x1": -0.3426236919563408, "x2": 18.22702038842482, "n": 11, "method": "short_edge"}, "output": 1746.9966874833315}, {"input": {"x1": -8.573549518737488, "x2": -4.04171421859461, "n": 13, "method": "long_edge"}, "output": 178.1875815767592}, {"input": {"x1": 6.332238587250309, "x2": 20.17413209736182, "n": 14, "method": "midpoint"}, "output": 2651.1650121640514}, {"input": {"x1": -4.633212544799736, "x2": 6.700997101485051, "n": 47, "method": "short_edge"}, "output": 130.73623341412326}, {"input": {"x1": 2.3103344002984034, "x2": 14.694730843772172, "n": 52, "method": "long_edge"}, "output": 1078.7873915849996}, {"input": {"x1": 5.874353306844389, "x2": 16.513377874233427, "n": 58, "method": "short_edge"}, "output": 1411.6637771404212}, {"input": {"x1": -3.4721427821886035, "x2": 6.32961312975363, "n": 77, "method": "midpoint"}, "output": 98.46976734859825}, {"input": {"x1": -4.661015069289968, "x2": 4.528962617658628, "n": 99, "method": "trapezoidal"}, "output": 64.73208724273475}, {"input": {"x1": -6.644754086297997, "x2": 8.970092587246818, "n": 49, "method": "short_edge"}, "output": 332.8591324373252}, {"input": {"x1": 1.2158870400690862, "x2": 4.974188032142677, "n": 85, "method": "midpoint"}, "output": 40.42489918645268}], "error_log": []}
{"context": "Given a parameter \\( P \\), what is the maximum value of the function \\( x + P \\cdot 2^{-x/1.5} \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `P` (float): The parameter P in the function `x + P * 2**(-x/1.5)`.\n\nOutput:\n  `return` (float): The maximum value of the function `x + P * 2**(-x/1.5)`.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(P):\n    # Convert the input P to float if it's not already\n    P = float(P)\n    \n    # Calculate the optimal x value\n    x = -1.5 * math.log(3 / (2 * P * math.log(2))) / math.log(2)\n    \n    # Calculate the maximum value of the function\n    if x > 0:\n        result = x + P * (2 ** (-x / 1.5))\n    else:\n        result = P\n    \n    # Return the result as a float\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    P = random.uniform(0.1, 100.0)\n    return {'P': P}", "io_pairs": [{"input": {"P": 60.35597195532106}, "output": 9.366586182628453}, {"input": {"P": 43.747147730050195}, "output": 8.670124829787849}, {"input": {"P": 59.218863450418496}, "output": 9.325426596259284}, {"input": {"P": 70.40256825164657}, "output": 9.699783481125419}, {"input": {"P": 60.841807010329845}, "output": 9.383935896085642}, {"input": {"P": 34.01442876892161}, "output": 8.125561684665078}, {"input": {"P": 25.628899210104475}, "output": 7.512998665056488}, {"input": {"P": 87.63901180211468}, "output": 10.173701218535527}, {"input": {"P": 20.348949004433297}, "output": 7.013772817931098}, {"input": {"P": 69.19444286182899}, "output": 9.662325658536165}], "error_log": []}
{"context": "Given a partially filled Tic Tac Toe board, what is the optimal next move for the current player to either win or prevent the opponent from winning?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists): A 3x3 matrix representing the Tic Tac Toe board. Each element can be 'X', 'O', or `None`.\n\nOutput:\n  `return` (tuple): A tuple representing the optimal move `(i, j)` where `i` and `j` are integers between 0 and 2. If the game is over, returns `None`.", "reference_code": "# import necessary packages\nimport copy\nimport random\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    num_X = sum(row.count(X) for row in board)\n    num_O = sum(row.count(O) for row in board)\n    return X if num_X == num_O else O\n\n# Function to get all possible actions\ndef actions(board):\n    return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}\n\n# Function to get the result of an action\ndef result(board, action):\n    i, j = action\n    if board[i][j] != EMPTY:\n        raise ValueError\n    new_board = copy.deepcopy(board)\n    new_board[i][j] = player(board)\n    return new_board\n\n# Function to determine the winner\ndef winner(board):\n    lines = (\n        board[0], board[1], board[2],  # Rows\n        [board[i][0] for i in range(3)],  # Columns\n        [board[i][1] for i in range(3)],\n        [board[i][2] for i in range(3)],\n        [board[i][i] for i in range(3)],  # Diagonals\n        [board[i][2 - i] for i in range(3)]\n    )\n    for line in lines:\n        if line[0] == line[1] == line[2] and line[0] != EMPTY:\n            return line[0]\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or not any(EMPTY in row for row in board)\n\n# Function to get the utility of the board\ndef utility(board):\n    win = winner(board)\n    if win == X:\n        return 1\n    elif win == O:\n        return -1\n    return 0\n\n# Main function to solve the problem\ndef main_solution(board):\n    \"\"\"\n    Determines the optimal next move for the current player on the given board.\n    \n    Input:\n    board (list of lists): A 3x3 matrix representing the Tic Tac Toe board. Each element can be 'X', 'O', or None.\n    \n    Output:\n    tuple: A tuple representing the optimal move (i, j) where i and j are integers between 0 and 2.\n    \"\"\"\n    if terminal(board):\n        return None\n    acts = actions(board)\n    turn = player(board)\n    if turn == X:\n        val, action = max_value(board)\n    else:\n        val, action = min_value(board)\n    return action\n\n# Helper function for maximizing player\ndef max_value(board):\n    if terminal(board):\n        return utility(board), None\n    value = -500\n    opt_action = None\n    for action in actions(board):\n        res = result(board, action)\n        val, _ = min_value(res)\n        if val > value:\n            value = val\n            opt_action = action\n            if value == 1:\n                return value, opt_action\n    return value, opt_action\n\n# Helper function for minimizing player\ndef min_value(board):\n    if terminal(board):\n        return utility(board), None\n    value = 500\n    opt_action = None\n    for action in actions(board):\n        res = result(board, action)\n        val, _ = max_value(res)\n        if val < value:\n            value = val\n            opt_action = action\n            if value == -1:\n                return value, opt_action\n    return value, opt_action", "input_generator": "import random\n\ndef input_generator():\n    board = [[None, None, None], [None, None, None], [None, None, None]]\n    symbols = ['X', 'O', None]\n    for i in range(3):\n        for j in range(3):\n            board[i][j] = random.choice(symbols)\n    # Ensure the board is not terminal\n    while (winner(board) is not None) or (not any(None in row for row in board)):\n        board = [[None, None, None], [None, None, None], [None, None, None]]\n        for i in range(3):\n            for j in range(3):\n                board[i][j] = random.choice(symbols)\n    return {'board': board}", "io_pairs": [{"input": {"board": [["O", "O", null], [null, "X", "X"], [null, "O", "O"]]}, "output": [1, 0]}, {"input": {"board": [["X", null, null], ["X", null, "X"], [null, "O", null]]}, "output": [1, 1]}, {"input": {"board": [["X", "O", null], [null, null, null], ["X", "O", "O"]]}, "output": [1, 0]}, {"input": {"board": [[null, null, null], [null, "X", "O"], ["O", "X", "X"]]}, "output": [0, 1]}, {"input": {"board": [[null, "X", "X"], [null, "O", "X"], ["X", "X", null]]}, "output": [1, 0]}, {"input": {"board": [["O", "X", "O"], [null, "X", "X"], [null, "O", "O"]]}, "output": [1, 0]}, {"input": {"board": [["X", "X", null], ["O", null, null], ["O", "X", "X"]]}, "output": [1, 1]}, {"input": {"board": [["O", "O", null], ["X", null, "O"], ["X", "X", "O"]]}, "output": [1, 1]}, {"input": {"board": [["X", null, null], ["O", "O", "X"], [null, "X", "X"]]}, "output": [0, 1]}, {"input": {"board": [["O", null, "X"], ["O", null, null], ["X", "O", null]]}, "output": [0, 1]}], "error_log": []}
{"context": "In the context of Code Division Multiple Access (CDMA) communication systems, we need to verify if a set of binary codes are orthogonal. Orthogonal codes are essential for ensuring that multiple users can transmit simultaneously without interfering with each other. Given a set of binary codes, how can we determine if they are orthogonal?\n\nThe input and output requirements are as follows:\n\nInput:\n  `codes` (list of strings): A list of strings where each string represents a binary code. Each string should have the same length and contain only '0' and '1'.\n\nOutput:\n  `return` (bool): Returns `True` if the given codes are orthogonal (valid CDMA codes), otherwise returns `False`.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(codes):\n  # Convert the input list of strings to a list of lists for easier manipulation\n  codes = [list(code) for code in codes]\n  \n  bit_length = len(codes[0]) # Assuming all the same length\n  for i in range(len(codes)-1):\n    for j in range(i+1, len(codes)):\n      sumTotal = 0\n      for k in range(bit_length):\n        x, y = 1, 1\n        if codes[i][k] == '0':\n          x = -1\n        if codes[j][k] == '0':\n          y = -1\n        sumTotal += (x*y)\n      if sumTotal != 0:\n        return False\n  return True", "input_generator": "import random\n\ndef input_generator():\n    bit_length = random.randint(2, 10)\n    num_codes = random.randint(2, 10)\n    codes = []\n    \n    # Generate first code randomly\n    first_code = ''.join(random.choice(['0', '1']) for _ in range(bit_length))\n    codes.append(first_code)\n    \n    # Generate remaining codes to be orthogonal\n    for _ in range(num_codes - 1):\n        new_code = []\n        for bit in first_code:\n            if bit == '1':\n                new_code.append(random.choice(['0', '1']))\n            else:\n                new_code.append('1' if random.choice([True, False]) else '0')\n        codes.append(''.join(new_code))\n    \n    # Randomly decide whether to return orthogonal codes or not\n    if random.choice([True, False]):\n        return {'codes': codes}\n    else:\n        # Modify one code to break orthogonality\n        codes[-1] = ''.join(random.choice(['0', '1']) for _ in range(bit_length))\n        return {'codes': codes}", "io_pairs": [{"input": {"codes": ["1100", "1100"]}, "output": false}, {"input": {"codes": ["0100", "1111", "1100", "1111", "0000", "1110", "0000", "0100"]}, "output": false}, {"input": {"codes": ["10011001", "01011101", "00001010", "10100001"]}, "output": false}, {"input": {"codes": ["0001111", "1111011", "1101011", "1111001", "0101011"]}, "output": false}, {"input": {"codes": ["111010", "011010", "010110", "110111"]}, "output": false}, {"input": {"codes": ["01101", "10010", "11000", "01010", "00011"]}, "output": false}, {"input": {"codes": ["011000110", "001110100", "111111000", "001110010", "000101100"]}, "output": false}, {"input": {"codes": ["00000", "11110", "11011", "01011", "01100", "11101", "00100", "00100", "10100"]}, "output": false}, {"input": {"codes": ["11", "11", "00", "10", "10", "11"]}, "output": false}, {"input": {"codes": ["010", "100", "101", "011"]}, "output": false}], "error_log": []}
{"context": "In a game of Tic Tac Toe, the board is represented by a 3x3 grid where each cell can be empty, occupied by player 'O', or occupied by player 'X'. Given a specific state of the board, what would be the resulting board configuration after the computer makes its move, assuming the computer plays optimally to maximize its chances of winning or drawing?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (str): A string representing the Tic Tac Toe board. The board is a 3x3 grid where each cell can be `-100` (empty), `0` (O), or `1` (X). The cells in each row are separated by commas, and rows are separated by semicolons. For example, `\"-100,0,-100;-100,-100,-100;-100,-100,-100\"`.\n\nOutput:\n  `return` (str): A string representing the updated Tic Tac Toe board after the computer's move. The format is the same as the input string.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\ndef check(board):\n    for x in range(3):\n        sumrow = board[x][0] + board[x][1] + board[x][2] \n        if sumrow == 3:\n            return -100\n        elif sumrow == 0:\n            return 100\n    for x in range(3):\n        sumcol = board[0][x] + board[1][x] + board[2][x] \n        if sumcol == 3:\n            return -100\n        elif sumcol == 0:\n            return 100\n    sumdiag1 = board[0][0] + board[1][1] + board[2][2]\n    if sumdiag1 == 3:\n        return -100\n    elif sumdiag1 == 0:\n        return 100\n    sumdiag2 = board[0][2] + board[1][1] + board[2][0]\n    if sumdiag2 == 3:\n        return -100\n    elif sumdiag2 == 0:\n        return 100\n    flag = 0  #flag is for checking if any move is possible\n    for x in range(3):\n        for y in range(3):\n            if board[x][y] == -100:\n                flag = 1\n                return\n    if flag == 0:\n        return 0\n\ndef minmax(game, depth, move_whose):\n    if check(game) == 100:\n        return 100 - depth, 0\n    if check(game) == -100:\n        return depth - 100, 0\n    if check(game) == 0:\n        return 0, 0\n    maximum = -10000\n    minimum = 10000\n    trick = 0\n    trickmaxmove = 0\n    tricksumminmove = 0\n    trickmat = [[-10000 for x in range(3)] for x in range(3)]\n\n    for x in range(3):\n        for y in range(3):\n            if game[x][y] == -100:\n                if move_whose:\n                    game[x][y] = 1\n                else:\n                    game[x][y] = 0\n                temp, trick = minmax(game, depth + 1, not move_whose)\n                trickmat[x][y] = trick\n                if (temp == 100 - depth - 1) and not move_whose:\n                    game[x][y] = -100\n                    return temp, trick\n                if move_whose:\n                    tricksumminmove += trick\n                    if minimum > temp:\n                        minimum = temp\n                else:\n                    if maximum < temp:\n                        maximum = temp\n                        trickmaxmove = trick\n                game[x][y] = -100\n    if move_whose:\n        return minimum, tricksumminmove\n    else:\n        return maximum, trickmaxmove\n\ndef ttt_move(board):\n    score = [[-10000 for x in range(3)] for x in range(3)]\n    trick = [[-10000 for x in range(3)] for x in range(3)]\n    for x in range(3):\n        for y in range(3):\n            if board[x][y] == -100:\n                board[x][y] = 0\n                score[x][y], trick[x][y] = minmax(board, 0, True)\n                score[x][y] = score[x][y] + trick[x][y]\n                board[x][y] = -100\n    maximum = -10000\n    bestx = 1\n    besty = 1\n    for x in range(3):\n        for y in range(3):\n            if score[x][y] > maximum:\n                maximum = score[x][y]\n                bestx = x\n                besty = y \n    board[bestx][besty] = 0\n    return board\n\n# main function\ndef main_solution(board):\n    # Convert the board to a list of lists if it's not already\n    if isinstance(board, str):\n        board = [[int(cell) for cell in row.split(',')] for row in board.split(';')]\n    \n    # Perform the Tic Tac Toe move\n    updated_board = ttt_move(board)\n    \n    # Convert the updated board back to a string for JSON serialization\n    updated_board_str = ';'.join([','.join([str(cell) for cell in row]) for row in updated_board])\n    \n    return updated_board_str", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random Tic Tac Toe board\n    board = [[-100 for _ in range(3)] for _ in range(3)]\n    \n    # Randomly place some moves (0 for O, 1 for X)\n    moves = random.randint(0, 4)  # Number of moves to place\n    for _ in range(moves):\n        x, y = random.randint(0, 2), random.randint(0, 2)\n        while board[x][y] != -100:\n            x, y = random.randint(0, 2), random.randint(0, 2)\n        board[x][y] = random.choice([0, 1])\n    \n    # Ensure the game isn't already won or drawn\n    # If it is, regenerate the board\n    result = check(board)\n    while result is not None and result != 0:\n        board = [[-100 for _ in range(3)] for _ in range(3)]\n        moves = random.randint(0, 4)\n        for _ in range(moves):\n            x, y = random.randint(0, 2), random.randint(0, 2)\n            while board[x][y] != -100:\n                x, y = random.randint(0, 2), random.randint(0, 2)\n            board[x][y] = random.choice([0, 1])\n        result = check(board)\n    \n    return {'board': board}", "io_pairs": [{"input": {"board": [[0, -100, -100], [-100, -100, -100], [-100, -100, -100]]}, "output": "0,-100,-100;-100,-100,-100;-100,-100,-100"}, {"input": {"board": [[0, 0, -100], [-100, 1, -100], [1, -100, 1]]}, "output": "0,0,-100;-100,1,-100;1,-100,1"}, {"input": {"board": [[0, -100, -100], [-100, -100, -100], [-100, -100, -100]]}, "output": "0,-100,-100;-100,-100,-100;-100,-100,-100"}, {"input": {"board": [[0, 0, -100], [-100, -100, -100], [-100, -100, -100]]}, "output": "0,0,-100;-100,-100,-100;-100,-100,-100"}, {"input": {"board": [[0, -100, -100], [-100, 0, -100], [-100, -100, 0]]}, "output": "0,-100,-100;-100,0,-100;-100,-100,0"}, {"input": {"board": [[0, -100, -100], [-100, -100, -100], [-100, -100, -100]]}, "output": "0,-100,-100;-100,-100,-100;-100,-100,-100"}, {"input": {"board": [[1, 1, -100], [-100, -100, -100], [0, 0, 0]]}, "output": "1,1,-100;-100,-100,-100;0,0,0"}, {"input": {"board": [[1, 0, 0], [-100, -100, -100], [-100, 1, 1]]}, "output": "1,0,0;-100,-100,-100;-100,1,1"}, {"input": {"board": [[0, -100, -100], [-100, 1, -100], [-100, -100, 1]]}, "output": "0,-100,-100;-100,1,-100;-100,-100,1"}, {"input": {"board": [[0, -100, -100], [-100, 1, -100], [-100, -100, 0]]}, "output": "0,-100,-100;-100,1,-100;-100,-100,0"}], "error_log": []}
{"context": "In a country, vehicle registration number plates follow a specific format: \"KLL NNNL\", where \"K\" is a constant letter, \"LL\" are two variable letters, \"NNN\" are three variable numbers, and \"L\" is a variable letter. Given two valid number plates, how many vehicles are registered between these two plates (excluding the plates themselves)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `plate_1` (str): The first vehicle registration number plate in the format \"KLL NNNL\" where K is a constant letter, L is a letter, and N is a number.\n  `plate_2` (str): The second vehicle registration number plate in the same format as `plate_1`.\n\nOutput:\n  `return` (dict): A dictionary with the following structure:\n    - `\"car_difference\"` (int): The number of vehicles between the two number plates.\n    - `\"error\"` (str): A string indicating an error if the input plates are invalid or identical.", "reference_code": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\ndef populate_no_plates():\n    num_plates = {}\n    num, i = 0, 65\n    while True:\n        num += 1\n        num_plates[chr(i)] = (num, (num-1) * 999 * 26, (num-1) * 999 * 26 * 26)\n        i += 1\n        if i == 91:\n            break\n    return num_plates\n\ndef plate_value(plate_num):\n    num_plates = populate_no_plates()\n    myplate = plate_num.split()\n    last_letter_value = tuple(num_plates[myplate[1][-1]])[0]\n    nnn = int(myplate[1][:-1])\n    last_plate_value = (nnn - 1) * 26 + last_letter_value\n    last_letter_value_c = tuple(num_plates[myplate[0][-1]])[1]\n    second_letter_value_c = tuple(num_plates[myplate[0][1]])[2]\n    totol = last_plate_value + last_letter_value_c + second_letter_value_c\n    return totol\n\ndef plate_validity(plate_num):\n    pattern = r'K[A-Z][A-Z]\\s\\d\\d\\d[A-Z]'\n    return bool(re.match(pattern, plate_num))\n\n# main function\ndef main_solution(plate_1, plate_2):\n    if not plate_validity(plate_1) or not plate_validity(plate_2):\n        return {\"error\": \"Invalid number plate format\"}\n    \n    plate1_value = plate_value(plate_1)\n    plate2_value = plate_value(plate_2)\n    \n    if plate1_value == plate2_value:\n        return {\"error\": \"Number plates are identical\"}\n    \n    car_difference = abs(plate1_value - plate2_value) - 1\n    return {\"car_difference\": car_difference}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate two valid plates\n    def generate_plate():\n        letters = string.ascii_uppercase\n        first_part = 'K' + random.choice(letters) + random.choice(letters)\n        second_part = f\"{random.randint(1, 999):03d}\" + random.choice(letters)\n        return f\"{first_part} {second_part}\"\n    \n    plate1 = generate_plate()\n    plate2 = generate_plate()\n    \n    # Ensure plates are different\n    while plate1 == plate2:\n        plate2 = generate_plate()\n    \n    return {\"plate_1\": plate1, \"plate_2\": plate2}", "io_pairs": [{"input": {"plate_1": "KYH 865Q", "plate_2": "KRW 767C"}, "output": {"car_difference": 4340219}}, {"input": {"plate_1": "KEL 293V", "plate_2": "KQG 672L"}, "output": {"car_difference": 7983861}}, {"input": {"plate_1": "KPN 925Y", "plate_2": "KJB 452E"}, "output": {"car_difference": 4375949}}, {"input": {"plate_1": "KCI 919I", "plate_2": "KRV 253C"}, "output": {"car_difference": 10450199}}, {"input": {"plate_1": "KTM 371Q", "plate_2": "KJS 441B"}, "output": {"car_difference": 6595590}}, {"input": {"plate_1": "KHJ 693I", "plate_2": "KCA 890P"}, "output": {"car_difference": 3605256}}, {"input": {"plate_1": "KVQ 084J", "plate_2": "KGX 290A"}, "output": {"car_difference": 9942694}}, {"input": {"plate_1": "KVR 313K", "plate_2": "KBK 163U"}, "output": {"car_difference": 13692187}}, {"input": {"plate_1": "KZP 520P", "plate_2": "KLI 563G"}, "output": {"car_difference": 9635244}}, {"input": {"plate_1": "KEO 604T", "plate_2": "KFD 702Z"}, "output": {"car_difference": 392163}}], "error_log": []}
{"context": "Given the Fibonacci sequence, which starts with 0 and 1, and each subsequent number is the sum of the previous two, what is the index of the first term in the sequence that contains exactly `n` digits?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of digits the Fibonacci number should contain.\n\nOutput:\n  `return` (int): The index of the first Fibonacci number with 'n' digits.", "reference_code": "# import necessary packages\nfrom math import log10, sqrt, ceil\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    Returns the first term in the Fibonacci sequence that contains exactly 'n' digits.\n    \n    Parameters:\n    n (int): The number of digits the Fibonacci number should contain.\n    \n    Returns:\n    int: The index of the first Fibonacci number with 'n' digits.\n    \"\"\"\n    phi = (1 + sqrt(5)) / 2\n    return int(ceil((n - 1 + log10(5) / 2) / log10(phi)))", "input_generator": "import random\nfrom math import log10, sqrt, ceil\n\ndef input_generator():\n    n = random.randint(1, 100)  # Reasonable range for n digits (1 to 100)\n    return {'n': n}", "io_pairs": [{"input": {"n": 30}, "output": 141}, {"input": {"n": 48}, "output": 227}, {"input": {"n": 58}, "output": 275}, {"input": {"n": 50}, "output": 237}, {"input": {"n": 82}, "output": 390}, {"input": {"n": 56}, "output": 265}, {"input": {"n": 15}, "output": 69}, {"input": {"n": 79}, "output": 375}, {"input": {"n": 53}, "output": 251}, {"input": {"n": 96}, "output": 457}], "error_log": []}
{"context": "In a gathering, a group of friends decided to greet each other by shaking hands. Each friend shook hands with every other friend exactly once. Given the number of friends, how many handshakes were there in total?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of friends who shook hands.\n\nOutput:\n  `return` (int): The total number of handshakes that occurred.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef flattenedges(graph):\n    if len(graph) == 1:\n        return graph[0]\n    else:\n        return graph[0] + flattenedges(graph[1:])\n\ndef graph(nodes):\n    edges = []\n    for i in range(nodes):\n        edges.append([])\n        for j in range(nodes):\n            if i > j:\n                edges[i].append(1)\n            else:\n                edges[i].append(0)\n    return edges\n\n# main function\ndef main_solution(n):\n    # Convert input to integer\n    n = int(n)\n    \n    # Generate the graph\n    graph_edges = graph(n)\n    \n    # Flatten the edges and calculate the total number of handshakes\n    total_handshakes = sum(flattenedges(graph_edges))\n    \n    # Return the result as a JSON serializable output\n    return total_handshakes", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 100)\n    return {'n': n}", "io_pairs": [{"input": {"n": 45}, "output": 990}, {"input": {"n": 87}, "output": 3741}, {"input": {"n": 94}, "output": 4371}, {"input": {"n": 10}, "output": 45}, {"input": {"n": 72}, "output": 2556}, {"input": {"n": 80}, "output": 3160}, {"input": {"n": 15}, "output": 105}, {"input": {"n": 8}, "output": 28}, {"input": {"n": 70}, "output": 2415}, {"input": {"n": 63}, "output": 1953}], "error_log": []}
{"context": "In a tic-tac-toe game, given a partially filled 3x3 board and the current player's symbol (either 'X' or 'O'), what is the optimal move for the current player to make? The board is represented as a 3x3 grid where each cell can be either 'X', 'O', or empty (''). The optimal move should be returned as the column and row indices (0-based) of the board where the current player should place their symbol to maximize their chances of winning or preventing the opponent from winning.\n\nThe input and output requirements are as follows:\n\nInput:\n  - `board` (List[List[str]]): A 3x3 list representing the tic-tac-toe board. Each cell can be 'X', 'O', or ''.\n  - `current_player` (str): The current player, either 'X' or 'O'.\n\nOutput:\n  - `return` (List[int]): A list containing two integers representing the optimal move's column and row indices (0-based). If no move is possible, an empty list is returned.", "reference_code": "# import necessary packages\nfrom enum import Enum\nfrom typing import Optional, List\nfrom itertools import product\nfrom collections import Counter\n\n# all class and function definitions in the code file, if any\nclass Player(Enum):\n    \"\"\"\n    The \"X\" or \"O\" player - either on the board, or as information\n    who is playing\n    \"\"\"\n    X = 1\n    O = 2\n\nBoard = List[List[Optional[Player]]]\n\ndef who_wins(board: Board) -> Optional[Player]:\n    \"\"\"\n    Given a tic-tac-toe board, is any player winning?\n    \"\"\"\n    players = (Player.X, Player.O)\n\n    for row in board:\n        for player in players:\n            if row.count(player) == len(row):\n                return player\n\n    for column_index in range(len(board)):\n        column = [row[column_index] for row in board]\n        for player in players:\n            if column.count(player) == len(column):\n                return player\n\n    diagonal = [row[-index - 1] for index, row in enumerate(board)]\n    for player in players:\n        if diagonal.count(player) == len(diagonal):\n            return player\n\n    second_diagonal = [row[index] for index, row in enumerate(board)]\n    for player in players:\n        if second_diagonal.count(player) == len(second_diagonal):\n            return player\n\n    return None\n\ndef optimal(board: Board, playing_as: Player) -> (int, int):\n    \"\"\"\n    Gets the most optimal move for a given board\n    \"\"\"\n    somebody_wins = who_wins(board)\n    if somebody_wins:\n        return None\n\n    opponent = Player.X if playing_as == Player.O else Player.O\n\n    all_spaces = product(range(len(board)), range(len(board)))\n\n    empty_spaces = [(column, row) for (column, row) in all_spaces if not board[row][column]]\n\n    for column, row in empty_spaces:\n        board[row][column] = playing_as\n        winner = who_wins(board)\n        board[row][column] = None\n\n        if winner == playing_as:\n            return column, row\n\n    for column, row in empty_spaces:\n        board[row][column] = opponent\n        winner = who_wins(board)\n        board[row][column] = None\n\n        if winner == opponent:\n            return column, row\n\n    later_opponent_wins = Counter()\n\n    for column1, row1 in empty_spaces:\n        for column2, row2 in empty_spaces:\n            if (column1, row1) == (column2, row2):\n                continue\n            board[row1][column1] = opponent\n            board[row2][column2] = opponent\n            winner = who_wins(board)\n            board[row2][column2] = None\n            board[row1][column1] = None\n\n            if winner == opponent:\n                later_opponent_wins.update([ (column1, row1)] )\n                later_opponent_wins.update([ (column2, row2)] )\n\n    if len(later_opponent_wins) > 0:\n        return later_opponent_wins.most_common(1)[0][0]\n\n    if (1, 1) in empty_spaces:\n        return 1, 1\n\n    return empty_spaces[0]\n\n# main function\ndef main_solution(board: List[List[str]], current_player: str) -> List[int]:\n    \"\"\"\n    Determines the optimal move for the current player in a tic-tac-toe game.\n    \n    Parameters:\n    - board (List[List[str]]): A 3x3 list representing the tic-tac-toe board. Each cell can be 'X', 'O', or ''.\n    - current_player (str): The current player, either 'X' or 'O'.\n    \n    Returns:\n    - List[int]: A list containing two integers representing the optimal move's column and row indices (0-based).\n    \"\"\"\n    # Convert board to the required format\n    converted_board = [[Player.X if cell == 'X' else Player.O if cell == 'O' else None for cell in row] for row in board]\n    \n    # Determine the optimal move\n    move = optimal(converted_board, Player.X if current_player == 'X' else Player.O)\n    \n    # Return the move as a list of integers\n    return list(move) if move else []", "input_generator": "import random\nfrom typing import List\n\ndef input_generator():\n    # Generate a random board (3x3) with 'X', 'O', or ''\n    board = []\n    for _ in range(3):\n        row = []\n        for _ in range(3):\n            cell = random.choice(['X', 'O', ''])\n            row.append(cell)\n        board.append(row)\n    \n    # Randomly choose the current player\n    current_player = random.choice(['X', 'O'])\n    \n    return {\n        'board': board,\n        'current_player': current_player\n    }", "io_pairs": [{"input": {"board": [["O", "", "X"], ["", "", ""], ["O", "O", "X"]], "current_player": "O"}, "output": [0, 1]}, {"input": {"board": [["", "", "X"], ["X", "O", ""], ["X", "O", "X"]], "current_player": "O"}, "output": [1, 0]}, {"input": {"board": [["X", "X", ""], ["", "", "X"], ["X", "O", "X"]], "current_player": "X"}, "output": [0, 1]}, {"input": {"board": [["X", "X", "O"], ["O", "", "X"], ["", "O", "O"]], "current_player": "X"}, "output": [0, 2]}, {"input": {"board": [["", "", "O"], ["X", "", "X"], ["", "X", "X"]], "current_player": "O"}, "output": [0, 2]}, {"input": {"board": [["X", "O", ""], ["O", "", "O"], ["", "X", "O"]], "current_player": "X"}, "output": [1, 1]}, {"input": {"board": [["X", "O", ""], ["X", "O", ""], ["X", "", "O"]], "current_player": "X"}, "output": []}, {"input": {"board": [["O", "X", "O"], ["X", "O", ""], ["X", "O", "X"]], "current_player": "O"}, "output": [2, 1]}, {"input": {"board": [["", "O", "O"], ["X", "O", "X"], ["", "O", ""]], "current_player": "X"}, "output": []}, {"input": {"board": [["O", "", "X"], ["O", "O", "O"], ["O", "O", "O"]], "current_player": "O"}, "output": []}], "error_log": []}
{"context": "Given a position in the Fibonacci sequence, what is the sum of the squares of the last digits of the Fibonacci numbers up to that position, modulo 10?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number representing the position in the Fibonacci sequence for which the sum of the squares of the last digits is to be calculated. The value should be a non-negative integer.\n\nOutput:\n  `return` (int): The sum of the squares of the last digits of the Fibonacci sequence up to the nth position, modulo 10. The value is a non-negative integer between 0 and 9.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(n):\n    # Convert input to integer\n    n = int(n)\n    \n    # Constants\n    m = 10\n    pi = 60\n    \n    # Initialize variables\n    previous, current, sum = 0, 1, 1\n    n = n % pi\n\n    if n <= 1:\n        return n\n\n    for i in range(n - 1):\n        previous, current = current, (previous + current) % m\n        sum = (sum + (current ** 2) % m) % m\n\n    return sum", "input_generator": "import random\n\ndef input_generator():\n    return {'n': random.randint(0, 100)}", "io_pairs": [{"input": {"n": 71}, "output": 6}, {"input": {"n": 94}, "output": 5}, {"input": {"n": 50}, "output": 0}, {"input": {"n": 8}, "output": 4}, {"input": {"n": 73}, "output": 1}, {"input": {"n": 66}, "output": 4}, {"input": {"n": 46}, "output": 9}, {"input": {"n": 44}, "output": 0}, {"input": {"n": 9}, "output": 0}, {"input": {"n": 98}, "output": 4}], "error_log": []}
{"context": "Given a square matrix, what is the determinant of the matrix rounded to two decimal places?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of floats): A 2D list representing a square matrix. Each sublist represents a row in the matrix.\n\nOutput:\n  `return` (float): The determinant of the input matrix, rounded to 2 decimal places.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix):\n    # Convert the input list to a numpy array\n    np_matrix = np.array(matrix)\n    \n    # Compute the determinant of the matrix\n    determinant = np.linalg.det(np_matrix)\n    \n    # Round the determinant to 2 decimal places\n    rounded_determinant = round(determinant, 2)\n    \n    # Return the rounded determinant\n    return rounded_determinant", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.choice([2, 3, 4])\n    matrix = np.random.randint(-10, 10, size=(size, size)).tolist()\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[-5, -3], [9, -2]]}, "output": 37.0}, {"input": {"matrix": [[-5, 3, -6, 3], [4, 0, 9, -10], [-9, -9, 0, 9], [4, 4, 4, 0]]}, "output": -3744.0}, {"input": {"matrix": [[-7, -7], [-2, -8]]}, "output": 42.0}, {"input": {"matrix": [[0, 3, -6], [3, 5, 4], [0, 5, 5]]}, "output": -135.0}, {"input": {"matrix": [[-8, 1, 0], [8, -7, -6], [-7, -1, -8]]}, "output": -294.0}, {"input": {"matrix": [[-2, 6], [6, -3]]}, "output": -30.0}, {"input": {"matrix": [[-4, -1], [8, 4]]}, "output": -8.0}, {"input": {"matrix": [[8, -2], [-4, -4]]}, "output": -40.0}, {"input": {"matrix": [[8, 3], [1, 6]]}, "output": 45.0}, {"input": {"matrix": [[9, 2], [7, 3]]}, "output": 13.0}], "error_log": []}
{"context": "Given a range of digits from 1 to a specified maximum digit, what is the largest pandigital prime number that can be formed using those digits? A pandigital number is one that contains each digit from 1 to the specified maximum digit exactly once.\n\nThe input and output requirements are as follows:\n\nInput:\n  `max_digit` (int): The maximum number of digits to consider for generating pandigital numbers. It should be an integer between 2 and 9.\n\nOutput:\n  `return` (int): The largest pandigital prime number found within the specified range of digits. If no such number is found, it returns 0.", "reference_code": "# import necessary packages\nfrom math import sqrt\n\n# all class and function definitions in the code file, if any\ndef all_permutations(l):\n    if len(l) == 0:\n        yield ''\n    for s in l:\n        newl = list(l)\n        newl.pop(newl.index(s))\n        for t in all_permutations(newl):\n            yield s + t\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(max_digit):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    max_pan_prime = 0\n    for i in range(max_digit, 1, -1):\n        l = [str(x) for x in range(1, i + 1)][::-1]\n        for p in all_permutations(l):\n            n = int(p)\n            if is_prime(n):\n                max_pan_prime = max(max_pan_prime, n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return max_pan_prime", "input_generator": "import random\n\ndef input_generator():\n    return {'max_digit': random.randint(2, 9)}", "io_pairs": [{"input": {"max_digit": 5}, "output": 4231}, {"input": {"max_digit": 2}, "output": 0}, {"input": {"max_digit": 9}, "output": 7652413}, {"input": {"max_digit": 3}, "output": 0}, {"input": {"max_digit": 4}, "output": 4231}, {"input": {"max_digit": 8}, "output": 7652413}, {"input": {"max_digit": 6}, "output": 4231}, {"input": {"max_digit": 7}, "output": 7652413}], "error_log": []}
{"context": "Given a set of mathematical functions and a list of input values, what is the result of evaluating one of these functions with the provided input values? The functions include various mathematical operations such as exponentiation, trigonometric functions, and summation. The input values are provided as a list of numbers, and the function to be evaluated is specified by its name.\n\nThe input and output requirements are as follows:\n\nInput:\n- `function_name` (str): The name of the function to be evaluated. It should be one of the following: `\"f1\"`, `\"f3\"`, `\"f6\"`, `\"f7\"`, `\"SIAMf\"`.\n- `x` (list of str): A list of strings representing the input values for the function. Each string should be convertible to a float.\n\nOutput:\n- `return` (float): The result of the function evaluation, converted to a float.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\ndef f1(x):\n    return 100 * ((x[1] - (x[0]**2))**2) + ((1 - x[0])**2)\n\ndef f3(x):\n    sum = 0\n    for i in range(len(x)):\n        sum += (x[i] - i - 1)**2\n    return sum\n\ndef f6(x):\n    squareSum = 0\n    for i in range(len(x)):\n        squareSum += (x[i])**2\n    return 0.5 + ((math.sin(math.sqrt(squareSum))**2) - 0.5) / (1 + 0.001 * squareSum)**2\n\ndef f7(x):\n    squareSum = 0\n    for i in range(len(x)):\n        squareSum += (x[i])**2\n    return (squareSum**0.25) * (1 + math.sin(50 * (squareSum**0.1))**2)\n\ndef SIAMf(x):\n    result = math.exp(math.sin(50 * x[0])) + math.sin(60 * math.exp(x[1])) + math.sin(70 * math.sin(x[0])) + math.sin(math.sin(80 * x[1])) - math.sin(10 * x[0] + 10 * x[1]) + (x[0]**2 + x[1]**2) / 4.0\n    return result\n\n# main function\ndef main_solution(function_name, x):\n    # Convert JSON serializable input to the required format\n    x = [float(val) for val in x]\n    \n    # Invoke the appropriate function based on the function_name\n    if function_name == \"f1\":\n        result = f1(x)\n    elif function_name == \"f3\":\n        result = f3(x)\n    elif function_name == \"f6\":\n        result = f6(x)\n    elif function_name == \"f7\":\n        result = f7(x)\n    elif function_name == \"SIAMf\":\n        result = SIAMf(x)\n    else:\n        raise ValueError(\"Invalid function name\")\n    \n    # Convert the result to a JSON serializable output\n    return float(result)", "input_generator": "import random\nimport math\n\ndef input_generator():\n    function_choices = [\"f1\", \"f3\", \"f6\", \"f7\", \"SIAMf\"]\n    function_name = random.choice(function_choices)\n    \n    if function_name == \"f1\":\n        x = [random.uniform(-2, 2), random.uniform(-2, 2)]\n    elif function_name == \"f3\":\n        dim = random.randint(2, 5)\n        x = [random.uniform(-10, 10) for _ in range(dim)]\n    elif function_name == \"f6\":\n        dim = random.randint(2, 5)\n        x = [random.uniform(-100, 100) for _ in range(dim)]\n    elif function_name == \"f7\":\n        dim = random.randint(2, 5)\n        x = [random.uniform(-100, 100) for _ in range(dim)]\n    elif function_name == \"SIAMf\":\n        x = [random.uniform(-1, 1), random.uniform(-1, 1)]\n    \n    return {\"function_name\": function_name, \"x\": x}", "io_pairs": [{"input": {"function_name": "f3", "x": [4.636141601130287, 9.966072044825964, -3.5677198689394736, -6.300835267538418, 5.539147849289169]}, "output": 226.21266145604676}, {"input": {"function_name": "f3", "x": [-7.437921735571349, 7.4030247731622225]}, "output": 100.39119991503209}, {"input": {"function_name": "f7", "x": [9.067406397037203, 6.419347907416622, -52.742975008895286, 78.54001797607148]}, "output": 18.739916560981655}, {"input": {"function_name": "f7", "x": [62.119168239575515, 88.23446410505926, -36.28767947902367]}, "output": 10.754064852919106}, {"input": {"function_name": "f1", "x": [-0.37676707339824445, -0.16896129179086028]}, "output": 11.562283847601616}, {"input": {"function_name": "f1", "x": [-1.9744873708201136, -0.03239432025562916]}, "output": 1554.119506519567}, {"input": {"function_name": "f3", "x": [4.35214031967806, -6.739082657202733, 3.23642909428324, -4.48239674248801, -2.966414400904574]}, "output": 223.07912203276746}, {"input": {"function_name": "f1", "x": [1.1133514578221018, -1.9236887325031984]}, "output": 1000.6217055624197}, {"input": {"function_name": "f7", "x": [-23.442698669487868, 70.19366190311644]}, "output": 15.60485744666948}, {"input": {"function_name": "f7", "x": [26.778134405648586, -7.9386635605386004]}, "output": 5.3132469892694685}], "error_log": []}
{"context": "Given a 2D grid representing a map where each cell contains an integer representing the height of the terrain, and a starting point (r, c) on the map, determine the coordinates of all the spots that are part of the island connected to the starting point. An island is defined as a group of connected land spots (where the height is not zero) that can be reached from the starting point. What are the coordinates of the island spots connected to the starting point (r, c)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `map` (list of lists of int): A 2D grid representing the map where each cell contains an integer representing the height of the terrain.\n  `r` (int): The row index of the starting point.\n  `c` (int): The column index of the starting point.\n\nOutput:\n  `return` (list of lists of int): A list of coordinates (each coordinate is a list of two integers [row, column]) representing the spots of the island connected to the starting point (r, c).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef on_map(map, r, c):\n    if (r > len(map)-1) or (c > len(map[0])-1) or (r < 0) or (c < 0):\n        return False\n    else:\n        return map[r][c] >= 0\n\ndef neighbors(map, r, c):\n    neighbors_list = []\n    for i in range((r-1),(r+2)):\n        for j in range((c-1),(c+2)):\n            if on_map(map, i, j) and [i, j] != [r, c]:\n                tuple_point = tuple([i, j])\n                neighbors_list.append(tuple_point)\n    return neighbors_list\n\ndef get_island_spots(map, r, c):\n    if (on_map(map, r, c) == False) or map[r][c] == 0:\n        return []\n    to_do = []\n    answer = []\n    to_do.append((r,c))\n    \n    while len(to_do) != 0:\n        x = to_do.pop()\n        if (map[x[0]][x[1]] != 0) and (not(x in answer)):\n            answer.append(x)\n            xs = neighbors(map, x[0], x[1])\n            for i in xs:\n                if (not(i in answer)) and (map[i[0]][i[1]] != 0):\n                    to_do.append(i)\n    answer.sort()\n    return answer\n\n# main function\ndef main_solution(map, r, c):\n    # Convert input to the required format\n    map = [[int(x) for x in row] for row in map]\n    \n    # Find the island spots\n    island_spots = get_island_spots(map, r, c)\n    \n    # Convert the result to a JSON serializable format\n    return [list(spot) for spot in island_spots]", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(3, 10)\n    cols = random.randint(3, 10)\n    map = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n    # Generate some random islands\n    num_islands = random.randint(1, 3)\n    for _ in range(num_islands):\n        island_size = random.randint(2, 5)\n        start_r = random.randint(0, rows - 1)\n        start_c = random.randint(0, cols - 1)\n        for _ in range(island_size):\n            r = random.randint(max(0, start_r - 1), min(rows - 1, start_r + 1))\n            c = random.randint(max(0, start_c - 1), min(cols - 1, start_c + 1))\n            map[r][c] = 1\n    \n    # Ensure at least one non-zero cell\n    non_zero_cells = [(r, c) for r in range(rows) for c in range(cols) if map[r][c] == 1]\n    if not non_zero_cells:\n        r, c = random.randint(0, rows - 1), random.randint(0, cols - 1)\n        map[r][c] = 1\n        non_zero_cells = [(r, c)]\n    \n    # Choose a random starting point within an island\n    r, c = random.choice(non_zero_cells)\n    \n    return {'map': [[str(cell) for cell in row] for row in map], 'r': r, 'c': c}", "io_pairs": [], "error_log": []}
{"context": "Given a 2D grid representing the state of Conway's Game of Life, what will be the state of the grid after one iteration of the game's rules are applied? The grid consists of cells that are either populated ('I') or empty ('_'), and the rules determine how these cells change based on their neighbors.\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists of int): A 2D list representing the board, where each element is either 0 (empty) or 1 (populated). The size of the board should be reasonable, typically less than 10x10 for simplicity.\n\nOutput:\n  `return` (str): A string representing the next state of the board, where 'I' represents a populated cell and '_' represents an empty cell. Rows are separated by newline characters.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(board):\n    \"\"\"\n    Applies the rules of Conway's Game of Life to a given 2D board and returns the next state of the board as a string.\n\n    Parameters:\n    board (list of lists of int): A 2D list representing the board, where each element is either 0 (empty) or 1 (populated).\n\n    Returns:\n    str: A string representing the next state of the board, where 'I' represents a populated cell and '_' represents an empty cell. Rows are separated by newline characters.\n    \"\"\"\n    x = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    new = ''\n    for row in range(len(board)):\n        for i in range(len(board[row])):\n            n = 0\n            for j in x:\n                if 0 <= j[0] + row < len(board) and 0 <= j[1] + i < len(board[row]):\n                    n += board[j[0] + row][j[1] + i]\n            if board[row][i] == 1:\n                if n <= 1 or n >= 4:\n                    new += '_'\n                else:\n                    new += 'I'\n            else:\n                if n == 3:\n                    new += 'I'\n                else:\n                    new += '_'\n        new += '\\n'\n    return new.rstrip()", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(3, 10)\n    cols = random.randint(3, 10)\n    board = [[random.choice([0, 1]) for _ in range(cols)] for _ in range(rows)]\n    return {'board': board}", "io_pairs": [{"input": {"board": [[0, 1, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 1, 0, 0, 0, 0]]}, "output": "_____II_\nI______I\nII____I_\nII_I_II_"}, {"input": {"board": [[1, 1, 0, 0, 1, 1, 0], [1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 0, 1, 0, 1]]}, "output": "II__III\nI_II__I\n_I____I"}, {"input": {"board": [[1, 1, 0], [1, 0, 0], [1, 1, 1], [0, 0, 1], [1, 1, 0], [0, 1, 0]]}, "output": "II_\n__I\nI_I\n__I\nIII\nII_"}, {"input": {"board": [[1, 1, 1, 1], [1, 1, 0, 0], [0, 1, 0, 1]]}, "output": "I_I_\n___I\nIII_"}, {"input": {"board": [[0, 0, 1, 1, 1, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0]]}, "output": "_II_I___\n_I__I___\nIII_____\n________"}, {"input": {"board": [[1, 0, 1, 0], [1, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 1]]}, "output": "I_I_\nI__I\n____\n_I_I"}, {"input": {"board": [[1, 0, 0, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 1, 1, 0, 0, 1]]}, "output": "___II___\n__I__II_\n___II___"}, {"input": {"board": [[0, 0, 0], [1, 1, 0], [0, 0, 0]]}, "output": "___\n___\n___"}, {"input": {"board": [[1, 1, 1], [1, 1, 1], [0, 0, 1], [0, 1, 1]]}, "output": "I_I\nI__\nI__\n_II"}, {"input": {"board": [[1, 1, 1, 0], [0, 0, 1, 0], [1, 0, 1, 0], [1, 1, 0, 0], [0, 0, 0, 0], [1, 1, 1, 0]]}, "output": "_II_\nI_II\nI_I_\nII__\n__I_\n_I__"}], "error_log": []}
{"context": "In a waiting area, seats are arranged in a grid pattern. Each seat can be either empty ('L'), occupied ('#'), or a floor space ('.') where no seating is possible. The seating arrangement changes based on the following rules:\n- An empty seat ('L') becomes occupied ('#') if there are no occupied seats adjacent to it.\n- An occupied seat ('#') becomes empty ('L') if four or more adjacent seats are occupied.\n- Floor spaces ('.') never change.\n\nGiven a seating arrangement, how many seats end up being empty ('L') and how many end up being occupied ('#') after the seating arrangement stabilizes?\n\nThe input and output requirements are as follows:\n\nInput:\n  `my_map` (list of lists of str): A 2D grid representing the seating arrangement. Each cell can be either 'L' (empty seat), '#' (occupied seat), or '.' (floor).\n\nOutput:\n  `return` (dict): A dictionary with keys 'L' and '#' representing the count of empty and occupied seats respectively after the simulation stabilizes.", "reference_code": "# import necessary packages\nimport itertools\nfrom collections import Counter\nfrom copy import deepcopy\n\n# main function\ndef main_solution(my_map):\n    \"\"\"\n    Simulates the seating arrangement in a waiting area based on the rules provided.\n    \n    Args:\n    my_map (list of lists of str): A 2D grid representing the seating arrangement. Each cell can be either 'L' (empty seat), '#' (occupied seat), or '.' (floor).\n    \n    Returns:\n    dict: A dictionary with keys 'L' and '#' representing the count of empty and occupied seats respectively after the simulation stabilizes.\n    \"\"\"\n    \n    def adjacent(my_map, row, column):\n        adjacents = []\n        rows, cols = len(my_map), len(my_map[0])\n        \n        for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            r, c = row + dr, column + dc\n            if 0 <= r < rows and 0 <= c < cols:\n                adjacents.append(my_map[r][c])\n        \n        return adjacents\n    \n    while True:\n        new_map = deepcopy(my_map)\n        \n        for i, row in enumerate(my_map):\n            for j, cell in enumerate(row):\n                adj = adjacent(my_map, i, j)\n                total = Counter(adj)\n                \n                if cell == \"L\" and \"#\" not in total.keys():\n                    new_map[i][j] = \"#\"\n                elif cell == \"#\" and total[\"#\"] >= 4:\n                    new_map[i][j] = \"L\"\n        \n        if new_map == my_map:\n            break\n        \n        my_map = new_map\n    \n    totals = Counter(cell for row in my_map for cell in row)\n    return {\"L\": totals[\"L\"], \"#\": totals[\"#\"]}", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(5, 15)\n    cols = random.randint(5, 15)\n    my_map = []\n    for _ in range(rows):\n        row = []\n        for _ in range(cols):\n            cell = random.choice(['L', '.', '#'])\n            row.append(cell)\n        my_map.append(row)\n    return {'my_map': my_map}", "io_pairs": [], "error_log": []}
{"context": "In a game of Tic Tac Toe, given a specific board state, what is the optimal next move for the current player?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_state` (list of lists): A 3x3 matrix representing the Tic Tac Toe board. Each element can be 'X', 'O', or None.\n\nOutput:\n  `return` (tuple): A tuple representing the optimal move (i, j) where i is the row index and j is the column index.", "reference_code": "# import necessary packages\nimport math\nimport copy\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\nrows = 3\ncols = 3\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    xcount = sum(row.count(X) for row in board)\n    ocount = sum(row.count(O) for row in board)\n    return O if xcount > ocount else X\n\n# Function to get all possible actions\ndef actions(board):\n    return [(i, j) for i in range(rows) for j in range(cols) if board[i][j] == EMPTY]\n\n# Function to get the result of an action\ndef result(board, action):\n    if action not in actions(board):\n        raise ValueError('Invalid Action')\n    board_copy = copy.deepcopy(board)\n    board_copy[action[0]][action[1]] = player(board)\n    return board_copy\n\n# Function to determine the winner\ndef winner(board):\n    for i in range(rows):\n        if all(board[i][j] == X for j in range(cols)):\n            return X\n        if all(board[i][j] == O for j in range(cols)):\n            return O\n    for j in range(cols):\n        if all(board[i][j] == X for i in range(rows)):\n            return X\n        if all(board[i][j] == O for i in range(rows)):\n            return O\n    if all(board[i][i] == X for i in range(rows)) or all(board[i][rows - 1 - i] == X for i in range(rows)):\n        return X\n    if all(board[i][i] == O for i in range(rows)) or all(board[i][rows - 1 - i] == O for i in range(rows)):\n        return O\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or not any(EMPTY in row for row in board)\n\n# Function to get the utility of the board\ndef utility(board):\n    return 1 if winner(board) == X else -1 if winner(board) == O else 0\n\n# Function to get the optimal action using minimax\ndef minimax(board):\n    if terminal(board):\n        return None\n    if player(board) == X:\n        return max_value(board)[1]\n    else:\n        return min_value(board)[1]\n\ndef max_value(board):\n    if terminal(board):\n        return utility(board), None\n    v = -math.inf\n    best_action = None\n    for action in actions(board):\n        min_val = min_value(result(board, action))[0]\n        if min_val > v:\n            v = min_val\n            best_action = action\n    return v, best_action\n\ndef min_value(board):\n    if terminal(board):\n        return utility(board), None\n    v = math.inf\n    best_action = None\n    for action in actions(board):\n        max_val = max_value(result(board, action))[0]\n        if max_val < v:\n            v = max_val\n            best_action = action\n    return v, best_action\n\n# main function\ndef main_solution(board_state):\n    \"\"\"\n    Determines the optimal next move for the current player on the given board state.\n    \n    Args:\n    board_state (list of lists): A 3x3 matrix representing the Tic Tac Toe board. Each element can be 'X', 'O', or None.\n    \n    Returns:\n    tuple: A tuple representing the optimal move (i, j) where i is the row index and j is the column index.\n    \"\"\"\n    return minimax(board_state)", "input_generator": "import random\n\ndef input_generator():\n    board = [[None, None, None], [None, None, None], [None, None, None]]\n    symbols = ['X', 'O']\n    current_symbol = random.choice(symbols)\n    \n    # Randomly fill the board with some moves\n    for _ in range(random.randint(0, 8)):\n        empty_positions = [(i, j) for i in range(3) for j in range(3) if board[i][j] is None]\n        if not empty_positions:\n            break\n        pos = random.choice(empty_positions)\n        board[pos[0]][pos[1]] = current_symbol\n        current_symbol = 'O' if current_symbol == 'X' else 'X'\n    \n    return {'board_state': board}", "io_pairs": [{"input": {"board_state": [[null, null, null], [null, null, null], [null, null, null]]}, "output": [0, 0]}, {"input": {"board_state": [[null, "X", null], [null, null, "O"], [null, null, "X"]]}, "output": [1, 1]}, {"input": {"board_state": [["O", "O", null], ["X", null, "X"], [null, "X", "O"]]}, "output": [1, 1]}, {"input": {"board_state": [[null, null, null], [null, "X", null], [null, "O", null]]}, "output": [0, 0]}, {"input": {"board_state": [["O", null, null], [null, null, null], ["X", null, null]]}, "output": [0, 2]}, {"input": {"board_state": [["O", "O", "X"], ["O", null, "O"], [null, "X", "X"]]}, "output": [1, 1]}, {"input": {"board_state": [[null, null, null], [null, null, null], [null, "O", null]]}, "output": [0, 0]}, {"input": {"board_state": [["O", null, null], ["X", null, "X"], [null, "O", null]]}, "output": [0, 2]}, {"input": {"board_state": [[null, "X", null], ["X", null, null], [null, "O", null]]}, "output": [0, 0]}, {"input": {"board_state": [["X", null, "X"], ["X", null, "O"], [null, "O", null]]}, "output": [0, 1]}], "error_log": []}
{"context": "Given a circle of numbers from 0 to n-1, where n is a positive integer, and starting from 0, every m-th number is removed from the circle. The process continues from the next number after the removed one. What is the last number remaining in the circle after all deletions?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The total number of elements in the circle (0, 1, ..., n-1).\n  `m` (int): The step count to delete the next element in the circle.\n\nOutput:\n  `return` (int): The last remaining number in the circle after all deletions.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef last_remaining(n, m):\n    last = 0\n    for i in range(2, n + 1):\n        last = (last + m) % i\n    return last\n\n# main function\ndef main_solution(n, m):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = last_remaining(n, m)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 1000)\n    m = random.randint(1, 1000)\n    return {'n': n, 'm': m}", "io_pairs": [{"input": {"n": 70, "m": 916}, "output": 43}, {"input": {"n": 168, "m": 363}, "output": 103}, {"input": {"n": 960, "m": 890}, "output": 143}, {"input": {"n": 227, "m": 424}, "output": 43}, {"input": {"n": 330, "m": 747}, "output": 3}, {"input": {"n": 311, "m": 192}, "output": 57}, {"input": {"n": 402, "m": 309}, "output": 60}, {"input": {"n": 876, "m": 509}, "output": 227}, {"input": {"n": 765, "m": 715}, "output": 711}, {"input": {"n": 701, "m": 4}, "output": 46}], "error_log": []}
{"context": "Given a binary search tree, how can you convert it into a sorted doubly linked list without creating any new nodes, but only by adjusting the pointers of the existing nodes? What will be the sequence of node values in the resulting doubly linked list?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (str): A JSON string representing the structure of the binary search tree. Each node is represented as a list where the first element is the value of the node, the second element is the left subtree (another list), and the third element is the right subtree (another list). If a subtree is empty, it is represented as `null`.\n\nOutput:\n  `return` (list): A list of integers representing the values of the nodes in the converted sorted doubly linked list. The list is sorted in ascending order.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def Convert(self, pRootOfTree):\n        if not pRootOfTree:\n            return\n        self.arr = []\n        self.midTraversal(pRootOfTree)\n        for i, v in enumerate(self.arr[:-1]):\n            v.right = self.arr[i + 1]\n            self.arr[i + 1].left = v\n        return self.arr[0]\n\n    def midTraversal(self, root):\n        if not root:\n            return\n        self.midTraversal(root.left)\n        self.arr.append(root)\n        self.midTraversal(root.right)\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(data):\n        if not data:\n            return None\n        root = TreeNode(data[0])\n        root.left = build_tree(data[1])\n        root.right = build_tree(data[2])\n        return root\n\n    tree_structure = json.loads(tree_structure)\n    root = build_tree(tree_structure)\n    \n    # Invoke the solution function\n    solution = Solution()\n    converted_list = solution.Convert(root)\n    \n    # Convert the output to JSON serializable format\n    result = []\n    while converted_list:\n        result.append(converted_list.val)\n        converted_list = converted_list.right\n    \n    return result", "input_generator": "import json\nimport random\n\ndef input_generator():\n    def generate_tree(depth):\n        if depth == 0 or random.random() < 0.3:\n            return None\n        val = random.randint(1, 100)\n        left = generate_tree(depth - 1)\n        right = generate_tree(depth - 1)\n        return [val, left, right]\n    \n    tree_structure = generate_tree(random.randint(1, 5))\n    return {'tree_structure': json.dumps(tree_structure)}", "io_pairs": [{"input": {"tree_structure": "[38, [60, null, null], [51, null, null]]"}, "output": [60, 38, 51]}, {"input": {"tree_structure": "[79, [97, null, null], [70, null, null]]"}, "output": [97, 79, 70]}, {"input": {"tree_structure": "[84, [26, [96, null, null], [28, null, null]], [49, [25, null, null], null]]"}, "output": [96, 26, 28, 84, 25, 49]}, {"input": {"tree_structure": "[14, [7, [59, [14, null, null], [75, null, null]], [48, [3, null, null], null]], null]"}, "output": [14, 59, 75, 7, 3, 48, 14]}, {"input": {"tree_structure": "[42, [60, [54, null, [90, null, null]], null], null]"}, "output": [54, 90, 60, 42]}, {"input": {"tree_structure": "[91, [34, null, null], null]"}, "output": [34, 91]}, {"input": {"tree_structure": "[11, null, [23, null, [77, [83, null, [45, null, null]], [82, [99, null, null], null]]]]"}, "output": [11, 23, 83, 45, 77, 99, 82]}, {"input": {"tree_structure": "[30, null, [23, [10, [63, null, null], [39, null, null]], [24, null, [20, null, null]]]]"}, "output": [30, 63, 10, 39, 23, 24, 20]}, {"input": {"tree_structure": "null"}, "output": []}, {"input": {"tree_structure": "[3, null, null]"}, "output": [3]}], "error_log": []}
{"context": "Given a system of differential equations with parameters `a` and `b`, and initial conditions `initial_y`, what are the final values of `y0` and `y1` after integrating the system from `t_start` to `t_end` with `num_points` time points?\n\nThe input and output requirements are as follows:\n\nInput:\n- `a` (float): The parameter `a` in the system of differential equations.\n- `b` (float): The parameter `b` in the system of differential equations.\n- `initial_y` (list of floats): The initial conditions for `y0` and `y1`.\n- `t_start` (float): The start time for the integration.\n- `t_end` (float): The end time for the integration.\n- `num_points` (int): The number of points to use in the time array.\n\nOutput:\n- `return` (dict): A dictionary containing the final values of `y0` and `y1` at the end of the integration period.\n  - `final_y0` (float): The final value of `y0`.\n  - `final_y1` (float): The final value of `y1`.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy.integrate import odeint\n\n# all class and function definitions in the code file, if any\ndef system(y, t, a, b):\n    y0, y1 = y\n    dydt = [a * (y0 - y0 * y1), b * (-y1 + y0 * y1)]\n    return dydt\n\n# main function\ndef main_solution(a, b, initial_y, t_start, t_end, num_points):\n    # Convert JSON serializable inputs to original input variables\n    initial_y = np.array(initial_y)\n    t = np.linspace(t_start, t_end, num_points)\n    \n    # Solve the system of differential equations\n    sol = odeint(system, initial_y, t, args=(a, b))\n    \n    # Extract the final values of y0 and y1\n    final_y0 = sol[-1, 0]\n    final_y1 = sol[-1, 1]\n    \n    # Return the final values as JSON serializable outputs\n    return {\"final_y0\": final_y0, \"final_y1\": final_y1}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    a = random.uniform(0.1, 2.0)\n    b = random.uniform(0.1, 2.0)\n    initial_y = [random.uniform(0.1, 2.0), random.uniform(0.1, 2.0)]\n    t_start = random.uniform(0, 5)\n    t_end = t_start + random.uniform(1, 10)\n    num_points = random.randint(50, 200)\n    \n    return {\n        \"a\": a,\n        \"b\": b,\n        \"initial_y\": initial_y,\n        \"t_start\": t_start,\n        \"t_end\": t_end,\n        \"num_points\": num_points\n    }", "io_pairs": [{"input": {"a": 1.0098179422067466, "b": 0.8179441579893212, "initial_y": [1.862752746333316, 0.1940188621552632], "t_start": 2.4069444704673844, "t_end": 9.859724959920616, "num_points": 57}, "output": {"final_y0": 0.9169715973330751, "final_y1": 0.15381402812690134}}, {"input": {"a": 0.3850823369104416, "b": 1.3780532234313576, "initial_y": [0.3807149168216356, 1.0866628403872476], "t_start": 4.130198462801949, "t_end": 12.973788067982696, "num_points": 68}, "output": {"final_y0": 0.48468192582138186, "final_y1": 2.3498833280947378}}, {"input": {"a": 1.5583838451999075, "b": 0.935813399247163, "initial_y": [0.5058733708403916, 1.6266354428525833], "t_start": 3.061211616074368, "t_end": 6.467283760178528, "num_points": 178}, "output": {"final_y0": 1.7377107156053868, "final_y1": 0.5579411411521097}}, {"input": {"a": 1.7629468218551154, "b": 0.6582863167079097, "initial_y": [1.6011100785004317, 1.0051486935105802], "t_start": 2.397932487631937, "t_end": 11.202115903805279, "num_points": 69}, "output": {"final_y0": 0.5746895138468109, "final_y1": 0.9634534112788794}}, {"input": {"a": 0.5349745679885143, "b": 1.5700199891062916, "initial_y": [1.293657221199513, 0.49967435689562134], "t_start": 4.218822104894618, "t_end": 8.030594347917708, "num_points": 197}, "output": {"final_y0": 0.6163389177224343, "final_y1": 1.1066889793606438}}, {"input": {"a": 1.2970661293361547, "b": 0.3301249042748343, "initial_y": [0.47942421042206196, 1.4676985827918625], "t_start": 1.2182338602653686, "t_end": 2.7592631556949145, "num_points": 161}, "output": {"final_y0": 0.28545964829036025, "final_y1": 1.0539919208231563}}, {"input": {"a": 0.6671172332525908, "b": 1.0586616284162071, "initial_y": [0.5190894337567953, 0.3532573763804039], "t_start": 2.457313732607199, "t_end": 9.209831951578025, "num_points": 165}, "output": {"final_y0": 0.34137967936270974, "final_y1": 0.8602730176766261}}, {"input": {"a": 1.3961772115895865, "b": 1.9390876958928478, "initial_y": [1.9106375140398635, 1.4201078369525153], "t_start": 1.8432267364337522, "t_end": 3.7106298845141126, "num_points": 171}, "output": {"final_y0": 0.45278727537059293, "final_y1": 0.6258642135271675}}, {"input": {"a": 1.5928879690257465, "b": 1.156087246802964, "initial_y": [0.8644352359783416, 1.5168343054671336], "t_start": 0.3431061911393968, "t_end": 6.88629710571525, "num_points": 92}, "output": {"final_y0": 0.6843568914147358, "final_y1": 0.6893277696132948}}, {"input": {"a": 1.5723579009322046, "b": 1.7581848561299118, "initial_y": [0.8311847510308007, 0.2471644786751946], "t_start": 2.2278149340811537, "t_end": 8.845049651236758, "num_points": 162}, "output": {"final_y0": 0.30207079228332323, "final_y1": 1.5298981836583743}}], "error_log": []}
{"context": "Given a list of integers and a series of operations, what will be the final state of the list after performing the operations? The operations include appending new values, removing the last value, deleting a specific value by index, and retrieving a value by index. The list is implemented using a CTypesList, which is a resizeable list-like object using ctypes arrays.\n\nThe input and output requirements are as follows:\n\nInput:\n- `c_type_name` (str): The name of the ctypes type to use (e.g., \"c_int\").\n- `initial_data` (list of int): A list of initial values to append to the CTypesList.\n- `operations` (list of dict): A list of operations to perform. Each operation is a dictionary with keys:\n  - \"type\" (str): The type of operation (\"append\", \"pop\", \"del\", \"get\").\n  - \"index\" (int, optional): The index for \"del\" and \"get\" operations.\n  - \"value\" (int, optional): The value to append for \"append\" operations.\n\nOutput:\n- `return` (list of int): The final state of the CTypesList after all operations.", "reference_code": "# import necessary packages\nimport ctypes\nimport random\n\n# all class and function definitions in the code file, if any\nclass CTypesList(object):\n    \"create a list for the given type, with optional initial preallocation space\"\n    def __init__(self, c_type, prealloc_size=0):\n        self.c_type = c_type\n        self._typesize = ctypes.sizeof(c_type)\n        self.data = (c_type * prealloc_size)()\n        self.size = 0\n        self.prealloc_size = prealloc_size\n    def __len__(self):\n        return self.size\n    def __getitem__(self, i):\n        if i >= self.size:\n            raise IndexError(i)\n        if i < 0:\n            i = self.size + i\n            if i < 0:\n                raise IndexError(\"list index out of range\")\n        return self.data[i]\n\n    def __delitem__(self, i):\n        size = self.size\n        if i >= size:\n            raise IndexError(\"list index out of range\")\n        \n        if i < 0:\n            i = size + i\n            if i < 0:\n                raise IndexError(\"list index out of range\")\n\n        # shift everything left by one\n        address = ctypes.addressof(self.data)\n        typesize = self._typesize\n        to_address = address + i*typesize\n        from_address = to_address + typesize\n        ctypes.memmove(to_address, from_address, typesize*(size-i-1))\n\n        self.size = size = size-1\n\n        if self.prealloc_size > size*2:\n            self.compact()\n\n    def append(self, obj):\n        \"append to the list; the object must be assignable to the ctype\"\n        size = self.size\n        if size >= self.prealloc_size:\n            # Need to make new space.  There's no 'realloc' for\n            # ctypes so this isn't as nice as it is in C.\n            # I'm using Python's growth pattern, which is\n            #    0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...\n            if size < 9:\n                newsize = (size>>3) + 3 + size\n            else:\n                newsize = (size>>3) + 6 + size\n            newdata = (self.c_type * newsize)()\n            ctypes.memmove(newdata, self.data, ctypes.sizeof(self.data))\n            self.data = newdata\n            self.prealloc_size = newsize\n            \n        self.data[size] = obj\n        self.size = size+1\n        \n    def append_kwargs(self, **kwargs):\n        \"append to the list; assign each key/value to the new item\"\n        size = self.size\n        if size >= self.prealloc_size:\n            if size < 9:\n                newsize = (size>>3) + 3 + size\n            else:\n                newsize = (size>>3) + 6 + size\n            newdata = (self.c_type * newsize)()\n            ctypes.memmove(newdata, self.data, ctypes.sizeof(self.data))\n            self.data = newdata\n            self.prealloc_size = newsize\n\n        obj = self.data[size]\n        for k, v in kwargs.items():\n            setattr(obj, k, v)\n        self.size = size+1\n\n    def pop(self):\n        \"remove the last item from the list\"\n        # Not handling anything other than pop from the end\n        size = self.size\n        if size == 0:\n            raise IndexError(\"pop from empty list\")\n\n        if self.prealloc_size > self.size*2:\n            # Too much empty space; compact.  Be careful;\n            # can't dealloc the item I'm returning!\n            self.compact()\n\n        size -= 1\n        obj = self.data[size]\n        self.size = size\n        return obj\n\n    def compact(self):\n        \"remove any space preallocated for growth\"\n        if self.prealloc_size == self.size:\n            return\n        newdata = (self.c_type * self.size)()\n        ctypes.memmove(newdata, self.data, self.size*self._typesize)\n        self.data = newdata\n        self.prealloc_size = self.size\n\n# main function\ndef main_solution(c_type_name, initial_data, operations):\n    \"\"\"\n    Perform a series of operations on a CTypesList and return the final state.\n\n    Args:\n    c_type_name (str): The name of the ctypes type to use (e.g., \"c_int\").\n    initial_data (list): A list of initial values to append to the CTypesList.\n    operations (list of dict): A list of operations to perform. Each operation is a dictionary with keys:\n        - \"type\" (str): The type of operation (\"append\", \"pop\", \"del\", \"get\").\n        - \"index\" (int, optional): The index for \"del\" and \"get\" operations.\n        - \"value\" (int, optional): The value to append for \"append\" operations.\n\n    Returns:\n    list: The final state of the CTypesList after all operations.\n    \"\"\"\n    # Convert c_type_name to actual ctypes type\n    c_type = getattr(ctypes, c_type_name)\n    \n    # Initialize the CTypesList\n    clist = CTypesList(c_type)\n    \n    # Append initial data\n    for value in initial_data:\n        clist.append(value)\n    \n    # Perform operations\n    for op in operations:\n        if op[\"type\"] == \"append\":\n            clist.append(op[\"value\"])\n        elif op[\"type\"] == \"pop\":\n            clist.pop()\n        elif op[\"type\"] == \"del\":\n            del clist[op[\"index\"]]\n        elif op[\"type\"] == \"get\":\n            clist[op[\"index\"]]\n    \n    # Return the final state of the CTypesList\n    return [clist[i] for i in range(len(clist))]", "input_generator": "import random\nimport ctypes\n\ndef input_generator():\n    # Randomly choose a ctypes type\n    c_type_names = [\"c_int\", \"c_float\", \"c_double\", \"c_char\"]\n    c_type_name = random.choice(c_type_names)\n    \n    # Generate initial data with random length (0 to 10)\n    initial_data = []\n    if c_type_name == \"c_int\":\n        initial_data = [random.randint(-100, 100) for _ in range(random.randint(0, 10))]\n    elif c_type_name == \"c_float\":\n        initial_data = [random.uniform(-100.0, 100.0) for _ in range(random.randint(0, 10))]\n    elif c_type_name == \"c_double\":\n        initial_data = [random.uniform(-100.0, 100.0) for _ in range(random.randint(0, 10))]\n    elif c_type_name == \"c_char\":\n        initial_data = [random.choice(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\") for _ in range(random.randint(0, 10))]\n    \n    # Generate random operations (1 to 10 operations)\n    operations = []\n    operation_types = [\"append\", \"pop\", \"del\", \"get\"]\n    for _ in range(random.randint(1, 10)):\n        op_type = random.choice(operation_types)\n        op = {\"type\": op_type}\n        if op_type == \"append\":\n            if c_type_name == \"c_int\":\n                op[\"value\"] = random.randint(-100, 100)\n            elif c_type_name == \"c_float\":\n                op[\"value\"] = random.uniform(-100.0, 100.0)\n            elif c_type_name == \"c_double\":\n                op[\"value\"] = random.uniform(-100.0, 100.0)\n            elif c_type_name == \"c_char\":\n                op[\"value\"] = random.choice(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\n        elif op_type in [\"del\", \"get\"]:\n            if len(initial_data) + len([op for op in operations if op[\"type\"] == \"append\"]) - len([op for op in operations if op[\"type\"] == \"pop\" or op[\"type\"] == \"del\"]) > 0:\n                op[\"index\"] = random.randint(0, len(initial_data) + len([op for op in operations if op[\"type\"] == \"append\"]) - len([op for op in operations if op[\"type\"] == \"pop\" or op[\"type\"] == \"del\"]) - 1)\n        operations.append(op)\n    \n    return {\n        \"c_type_name\": c_type_name,\n        \"initial_data\": initial_data,\n        \"operations\": operations\n    }", "io_pairs": [{"input": {"c_type_name": "c_double", "initial_data": [20.139589728440527, -94.40488430334051, -30.902006203956873], "operations": [{"type": "pop"}]}, "output": [20.139589728440527, -94.40488430334051]}, {"input": {"c_type_name": "c_float", "initial_data": [], "operations": [{"type": "append", "value": 38.895403999726824}]}, "output": [38.89540481567383]}, {"input": {"c_type_name": "c_double", "initial_data": [-31.41827986725633], "operations": [{"type": "pop"}]}, "output": []}, {"input": {"c_type_name": "c_double", "initial_data": [-10.343866097879513, 61.929462911299424, -80.65469066386063, 50.43719423351607], "operations": [{"type": "pop"}]}, "output": [-10.343866097879513, 61.929462911299424, -80.65469066386063]}, {"input": {"c_type_name": "c_double", "initial_data": [18.731376319464104, 23.68252649024076], "operations": [{"type": "pop"}]}, "output": [18.731376319464104]}, {"input": {"c_type_name": "c_int", "initial_data": [92, -35], "operations": [{"type": "pop"}]}, "output": [92]}, {"input": {"c_type_name": "c_float", "initial_data": [68.38741927689804], "operations": [{"type": "pop"}]}, "output": []}, {"input": {"c_type_name": "c_double", "initial_data": [], "operations": [{"type": "append", "value": 65.24960219954116}]}, "output": [65.24960219954116]}, {"input": {"c_type_name": "c_double", "initial_data": [85.28482820434508], "operations": [{"type": "pop"}]}, "output": []}, {"input": {"c_type_name": "c_double", "initial_data": [-49.18325277838278, 10.893681775499914, -12.953303487140985], "operations": [{"type": "pop"}]}, "output": [-49.18325277838278, 10.893681775499914]}], "error_log": []}
{"context": "Given a k-Puzzle with a specific initial configuration and a goal configuration, what is the sequence of moves required to transform the initial configuration into the goal configuration? The puzzle consists of a grid where each cell contains a number from 0 to k-1, with 0 representing the blank space. The goal is to move the blank space and other tiles to achieve the goal configuration. If the puzzle is already in the goal state, indicate that it is \"ALREADY_SOLVED\". If the puzzle is unsolvable, indicate that it is \"UNSOLVABLE\".\n\nThe input and output requirements are as follows:\n\nInput:\n  `init_state` (list of lists of integers): A 2D list representing the initial state of the puzzle. Each sublist represents a row in the puzzle. The value `0` represents the blank space.\n  `goal_state` (list of lists of integers): A 2D list representing the goal state of the puzzle. Each sublist represents a row in the puzzle. The value `0` represents the blank space.\n\nOutput:\n  `return` (list of strings or string): A list of strings representing the sequence of moves to solve the puzzle from the initial state to the goal state. Each string is one of `\"UP\"`, `\"DOWN\"`, `\"LEFT\"`, or `\"RIGHT\"`. If the puzzle is already solved, it returns `\"ALREADY_SOLVED\"`. If the puzzle is unsolvable, it returns `\"UNSOLVABLE\"`.", "reference_code": "# import necessary packages\nimport random\nimport math\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    def __init__(self, state, parent=None, action=None, location=None):\n        self.state = state\n        self.parent = parent\n        self.dimension = len(state)\n        self.action = action\n        self.location = location\n        self.hash = self.gethash()\n\n    def findBlank(self):\n        for i in range(self.dimension):\n            for j in range(self.dimension):\n                if self.state[i][j] == 0:\n                    return (i, j)\n        raise ValueError(\"There's no zero in the puzzle error\")\n\n    def move(self, xsrc, ysrc, xdest, ydest):\n        output = [row[:] for row in self.state]\n        output[xsrc][ysrc], output[xdest][ydest] = output[xdest][ydest], output[xsrc][ysrc]\n        return output\n\n    def gethash(self):\n        temp = []\n        total = 0\n        for list in self.state:\n            for i in list:\n                temp.append(i)\n        x = len(temp)\n        for i in range(x-1):\n            greater = 0\n            y = x-i-1\n            factorial = 1\n            if (temp[i]==0):\n                continue\n            for j in range (i+1,x):\n                factorial *= y\n                y-=1\n                if (temp[j]<temp[i]):\n                    greater+=1\n            total += greater * factorial\n        return total \n\n    def get_neighbours(self):\n        new_states = []\n        if (self.location == None):\n            (x, y) = self.findBlank()\n        else:\n            (x, y) = self.location\n\n        if(y-1 >= 0):\n            new_states.append(\n                Node(self.move(x, y-1, x, y), self, \"RIGHT\", (x, y-1)))\n        if(y+1 < self.dimension):\n            new_states.append(\n                Node(self.move(x, y+1, x, y), self, \"LEFT\", (x, y+1)))\n        if(x+1 < self.dimension):\n            new_states.append(\n                Node(self.move(x+1, y, x, y), self, \"UP\", (x+1, y)))\n        if(x-1 >= 0):\n            new_states.append(\n                Node(self.move(x-1, y, x, y), self, \"DOWN\", (x-1, y)))\n\n        return new_states\n\nclass Puzzle(object):\n    def __init__(self, init_state, goal_state):\n        self.init_state = init_state\n        self.goal_state = goal_state\n        self.visited_states = [init_state]\n        self.goalhash = Node(goal_state).hash\n        self.hashTable = self.generateHashTable()\n\n    def isSolvable(self, state):\n        inversions = 0\n        singleDim = []\n        (y, x) = (0, 0)\n\n        for i in range(0, len(state)):\n            for j in range(0, len(state)):\n                singleDim.append(state[i][j])\n                if state[i][j] == 0:\n                    (y, x) = (i, j)\n        for i in range(0, len(singleDim)-1):\n            for j in range(i+1, len(singleDim)):\n                if singleDim[j] and singleDim[i] and singleDim[i] > singleDim[j]:\n                    inversions += 1\n\n        if len(state) % 2 == 1:\n            if (inversions % 2) == 0:\n                return True\n            else:\n                return False\n        else:\n            if (y % 2 == 0 and inversions % 2 == 1) or \\\n               (y % 2 == 1 and inversions % 2 == 0):\n                return True\n            else:\n                return False\n\n    def terminate(self, node):\n        output = []\n        while(node.parent != None):\n            output.insert(0, node.action)\n            node = node.parent\n        return output\n\n    def generateHashTable(self):\n        n = len(self.init_state)\n        return [0]*math.factorial(n*n)\n\n    def solve(self):\n        if self.isSolvable(Node(self.init_state).state) == False:\n            return [\"UNSOLVABLE\"]\n\n        source = Node(self.init_state)\n        self.hashTable[source.hash] = 1\n        if (source.hash==self.goalhash):\n            return None\n        \n        frontier = [source]\n        while (len(frontier)!=0):\n            node = frontier.pop(0)\n\n            for neighbour in node.get_neighbours():\n                if (self.hashTable[neighbour.hash]==0):\n                    self.hashTable[neighbour.hash]=1\n                    if (neighbour.hash==self.goalhash):\n                        return self.terminate(neighbour)\n                    frontier.append(neighbour)\n\n# main function\ndef main_solution(init_state, goal_state):\n    puzzle = Puzzle(init_state, goal_state)\n    result = puzzle.solve()\n    if result is None:\n        return \"ALREADY_SOLVED\"\n    elif result == [\"UNSOLVABLE\"]:\n        return \"UNSOLVABLE\"\n    else:\n        return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    dimension = random.choice([2, 3, 4])\n    numbers = list(range(dimension * dimension))\n    random.shuffle(numbers)\n    \n    init_state = []\n    for i in range(dimension):\n        row = numbers[i*dimension : (i+1)*dimension]\n        init_state.append(row)\n    \n    goal_numbers = list(range(dimension * dimension))\n    goal_state = []\n    for i in range(dimension):\n        row = goal_numbers[i*dimension : (i+1)*dimension]\n        goal_state.append(row)\n    \n    # Ensure the initial state is solvable by checking and adjusting if necessary\n    puzzle = Puzzle(init_state, goal_state)\n    if not puzzle.isSolvable(init_state):\n        # Swap two non-zero elements to make it solvable\n        for i in range(dimension):\n            for j in range(dimension):\n                if init_state[i][j] != 0:\n                    for k in range(dimension):\n                        for l in range(dimension):\n                            if init_state[k][l] != 0 and (i != k or j != l):\n                                init_state[i][j], init_state[k][l] = init_state[k][l], init_state[i][j]\n                                if puzzle.isSolvable(init_state):\n                                    return {'init_state': init_state, 'goal_state': goal_state}\n                                else:\n                                    init_state[i][j], init_state[k][l] = init_state[k][l], init_state[i][j]\n    \n    return {'init_state': init_state, 'goal_state': goal_state}", "io_pairs": [{"input": {"init_state": [[3, 1], [2, 0]], "goal_state": [[0, 1], [2, 3]]}, "output": "ALREADY_SOLVED"}, {"input": {"init_state": [[0, 3], [2, 1]], "goal_state": [[0, 1], [2, 3]]}, "output": "ALREADY_SOLVED"}, {"input": {"init_state": [[2, 0], [1, 3]], "goal_state": [[0, 1], [2, 3]]}, "output": "ALREADY_SOLVED"}, {"input": {"init_state": [[1, 2], [0, 3]], "goal_state": [[0, 1], [2, 3]]}, "output": "ALREADY_SOLVED"}, {"input": {"init_state": [[1, 2], [3, 0]], "goal_state": [[0, 1], [2, 3]]}, "output": "ALREADY_SOLVED"}, {"input": {"init_state": [[2, 3], [1, 0]], "goal_state": [[0, 1], [2, 3]]}, "output": "ALREADY_SOLVED"}, {"input": {"init_state": [[3, 1], [0, 2]], "goal_state": [[0, 1], [2, 3]]}, "output": "ALREADY_SOLVED"}, {"input": {"init_state": [[3, 0], [2, 1]], "goal_state": [[0, 1], [2, 3]]}, "output": "ALREADY_SOLVED"}, {"input": {"init_state": [[2, 3], [0, 1]], "goal_state": [[0, 1], [2, 3]]}, "output": "ALREADY_SOLVED"}, {"input": {"init_state": [[0, 1], [3, 2]], "goal_state": [[0, 1], [2, 3]]}, "output": "ALREADY_SOLVED"}], "error_log": []}
{"context": "Given a partially filled Sudoku grid, what is the complete and correct configuration of the grid that satisfies all Sudoku rules? The grid is represented as a string of 81 characters, where each character is either a digit from '1' to '9' or a period ('.').\n\nThe input and output requirements are as follows:\n\nInput:\n  `grid` (str): A string representing a Sudoku grid. The string should be of length 81, where each character represents a cell in the grid. Empty cells are represented by a period ('.').\n\nOutput:\n  `return` (dict): A dictionary representing the solved Sudoku grid. Keys are the box names (e.g., 'A1'), and values are the corresponding digits (e.g., '8').", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef cross(list1, list2):\n    \"\"\"Cross product of elements in A and elements in B.\"\"\"\n    return [elem1 + elem2 for elem1 in list1 for elem2 in list2]\n\nrows = 'ABCDEFGHI'\ncols = '123456789'\nboxes = cross(rows, cols)\nrow_units = [cross(r, cols) for r in rows]\ncolumn_units = [cross(rows, c) for c in cols]\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\ndiagonals = [[row + col for row, col in zip(rows, cols)], \n            [row + col for row, col in zip(rows, reversed(cols))]]\nunitlist = row_units + column_units + square_units + diagonals\nunits = dict((s, [u for u in unitlist if s in u]) for s in boxes)\npeers = dict((s, set(sum(units[s], [])) - set([s])) for s in boxes)\n\ndef assign_value(values, box, value):\n    \"\"\"Assigns a value to a given box. If it updates the board record it.\"\"\"\n    if values[box] == value:\n        return values\n    values[box] = value\n    return values\n\ndef naked_twins(values):\n    \"\"\"Eliminate values using the naked twins strategy.\"\"\"\n    for unit in unitlist:\n        naked_values = \"\"\n        naked_boxes = []\n        for i, box1 in enumerate(unit):\n            for box2 in unit[i+1:]:\n                if len(values[box1])==2 and values[box1] == values[box2] and box1 != box2:\n                    naked_values += values[box1]\n                    naked_boxes += [box1, box2]\n        if len(naked_values) > 0:\n            for box in unit:\n                if box not in naked_boxes:\n                    new_val = \"\".join([x for x in values[box] if x not in naked_values])\n                    assign_value(values, box, new_val)\n    return values\n\ndef grid_values(grid):\n    \"\"\"Convert grid into a dict of {square: char} with '123456789' for empties.\"\"\"\n    return dict(zip(boxes, [x if x in '123456789' else '123456789' for x in grid]))\n\ndef eliminate(values):\n    \"\"\"Eliminate values from peers of each box with a single value.\"\"\"\n    solved_boxes = [box for box in values if len(values[box]) == 1]\n    for box in solved_boxes:\n        for peer in peers[box]:\n            assign_value(values, peer, values[peer].replace(values[box], \"\"))\n    return values\n\ndef only_choice(values):\n    \"\"\"Finalize all values that are the only choice for a unit.\"\"\"\n    for unit in unitlist:\n        for value in '123456789':\n            box_list = [box for box in unit if value in values[box]]\n            if len(box_list) == 1:\n                assign_value(values, box_list[0], value)\n    return values\n\ndef reduce_puzzle(values):\n    \"\"\"Iterate eliminate() and only_choice().\"\"\"\n    stalled = False\n    while not stalled:\n        solved_values_before = len([box for box in values.keys() if len(values[box]) == 1])\n        values = eliminate(values)\n        values = only_choice(values)\n        values = naked_twins(values)\n        solved_values_after = len([box for box in values.keys() if len(values[box]) == 1])\n        stalled = solved_values_before == solved_values_after\n        if len([box for box in values.keys() if len(values[box]) == 0]):\n            return False\n    return values\n\ndef search(values):\n    \"\"\"Using depth-first search and propagation, create a search tree and solve the sudoku.\"\"\"\n    values = reduce_puzzle(values)\n    if values is False:\n        return False\n    if all(len(values[box]) == 1 for box in boxes): \n        return values\n    num, box = min((len(values[s]), s) for s in boxes if len(values[s]) > 1)\n    for value in values[box]:\n        new_values = values.copy()\n        assign_value(new_values, box, value)\n        solution = search(new_values)\n        if solution:\n            return solution\n\ndef solve(grid):\n    \"\"\"Find the solution to a Sudoku grid.\"\"\"\n    values = grid_values(grid)\n    solution = search(values)\n    return solution\n\n# main function\ndef main_solution(grid):\n    \"\"\"\n    Solve a Sudoku puzzle and return the solved grid.\n    \n    Args:\n        grid (str): A string representing a Sudoku grid.\n                    Example: '2.............62....1....7...6..8...3...9...7...6..4...4....8....52.............3'\n    \n    Returns:\n        dict: A dictionary representing the solved Sudoku grid.\n              Keys: The boxes, e.g., 'A1'\n              Values: The value in each box, e.g., '8'.\n    \"\"\"\n    solution = solve(grid)\n    return solution", "input_generator": "import random\n\ndef input_generator():\n    # Generate a partially filled Sudoku grid string\n    # Start with a solved Sudoku grid (a valid one)\n    solved_grid = [\n        '5', '3', '4', '6', '7', '8', '9', '1', '2',\n        '6', '7', '2', '1', '9', '5', '3', '4', '8',\n        '1', '9', '8', '3', '4', '2', '5', '6', '7',\n        '8', '5', '9', '7', '6', '1', '4', '2', '3',\n        '4', '2', '6', '8', '5', '3', '7', '9', '1',\n        '7', '1', '3', '9', '2', '4', '8', '5', '6',\n        '9', '6', '1', '5', '3', '7', '2', '8', '4',\n        '2', '8', '7', '4', '1', '9', '6', '3', '5',\n        '3', '4', '5', '2', '8', '6', '1', '7', '9'\n    ]\n    \n    # Randomly replace some numbers with '.' to create a puzzle\n    grid = solved_grid.copy()\n    for i in range(random.randint(40, 60)):  # Remove 40-60 numbers\n        pos = random.randint(0, 80)\n        grid[pos] = '.'\n    \n    grid_str = ''.join(grid)\n    return {'grid': grid_str}", "io_pairs": [{"input": {"grid": "5..6.89.2.72..53.8.9.3....7.5....42342...3.9.71.92.8.69615..2..287.1963.345286179"}, "output": false}, {"input": {"grid": ".3.6..91...219.348.9.34256785.76..2.4...5.7.1.1392485....5..28.2874.963534.2.6.7."}, "output": false}, {"input": {"grid": "..4.7...26..1.5.48198.42..7.59..1.2.4.....7.1.139..8.696.5.7...287.19....4.286..."}, "output": false}, {"input": {"grid": "5.46.......2......19.34.56.859.6.4..4..85.79..1.9.485.9615372..2..41.6..3...861.9"}, "output": false}, {"input": {"grid": "....7..1.6721953481..34..67..97614....6.5.79..1.9..8.6.6..3728428.4..6353...8.1.9"}, "output": false}, {"input": {"grid": "...678912672.9534.1.83..5...5..614.3..685.79171392485.961..72..287....353..2.6179"}, "output": false}, {"input": {"grid": "5..67891..721953481983.2.678.97614..4268.3.....392.8.6.61537284.8...9..5.45..6.79"}, "output": false}, {"input": {"grid": "5.46.891..7..9.34.1.8.42.67.5.7.1..342......1.1.9248.696.5.7284..7.........28...9"}, "output": false}, {"input": {"grid": "5.467.9.2..2.953...98..2.67.5.7.1....26.5379.71...4...9..537284.8..........286..."}, "output": false}, {"input": {"grid": "53467..1267.19..4819.3425..8.9.6...3...8...9..139248...6.537..42874...3534.286..9"}, "output": false}], "error_log": []}
{"context": "Given a composite integer `n`, which is the product of two prime numbers, what are the two prime factors `p` and `q` that multiply together to form `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): A composite integer that needs to be factored into two prime factors.\n\nOutput:\n  `return` (dict): A dictionary containing the two prime factors of `n`. The keys are `'p'` and `'q'`, and the values are the corresponding prime factors.", "reference_code": "# import necessary packages\nimport random\nimport math\n\n# all class and function definitions in the code file, if any\ndef gcd(a, b):\n    if a <= 0:\n        return b\n    return gcd(b % a, a)\n\ndef pollard_rho(number, x, y):\n    d = 1\n    while d == 1:\n        x = (x**2 + 1) % number\n        for i in range(2):\n            y = (y**2 + 1) % number\n        z = abs(x - y)\n        d = gcd(z, number)\n    return d\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    x = 2\n    y = 2\n    factor1 = pollard_rho(n, x, y)\n    while factor1 == 1:\n        x += 1\n        y += 1\n        factor1 = pollard_rho(n, x, y)\n    factor2 = int(n / factor1)\n    results = {'p': factor1, 'q': factor2}\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return results", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate two distinct primes p and q\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    p = random.randint(2, 1000)\n    while not is_prime(p):\n        p = random.randint(2, 1000)\n    \n    q = random.randint(2, 1000)\n    while not is_prime(q) or q == p:\n        q = random.randint(2, 1000)\n    \n    n = p * q\n    return {'n': n}", "io_pairs": [{"input": {"n": 9287}, "output": {"p": 37, "q": 251}}, {"input": {"n": 222359}, "output": {"p": 229, "q": 971}}, {"input": {"n": 37211}, "output": {"p": 127, "q": 293}}, {"input": {"n": 56759}, "output": {"p": 211, "q": 269}}, {"input": {"n": 25159}, "output": {"p": 181, "q": 139}}, {"input": {"n": 110387}, "output": {"p": 167, "q": 661}}, {"input": {"n": 531187}, "output": {"p": 821, "q": 647}}, {"input": {"n": 669043}, "output": {"p": 809, "q": 827}}, {"input": {"n": 21083}, "output": {"p": 29, "q": 727}}, {"input": {"n": 7453}, "output": {"p": 29, "q": 257}}], "error_log": []}
{"context": "Given a sequence of special Pythagorean triples where the two legs differ by exactly 1, what are the three integers that form the nth member of this sequence?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): A positive integer representing the position in the sequence of special Pythagorean triples where the two legs differ by 1.\n\nOutput:\n  `return` (dict): A dictionary containing the three integers `a`, `b`, and `c` that form the nth special Pythagorean triple. The keys are:\n    - `\"a\"` (int): The smaller leg of the Pythagorean triple.\n    - `\"b\"` (int): The larger leg of the Pythagorean triple.\n    - `\"c\"` (int): The hypotenuse of the Pythagorean triple.", "reference_code": "# import necessary packages\nfrom math import sqrt\n\n# all class and function definitions in the code file, if any\ndef pell(n):\n    a = 0\n    b = 1\n    for i in range(n):\n        a, b = b, 2*b + a\n    return a\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    x = pell(n)\n    y = pell(n + 1)\n    a = y * y - x * x\n    b = 2 * x * y\n    c = y * y + x * x\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"a\": min(a, b), \"b\": max(a, b), \"c\": c}", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 20)\n    return {\"n\": n}", "io_pairs": [{"input": {"n": 2}, "output": {"a": 20, "b": 21, "c": 29}}, {"input": {"n": 5}, "output": {"a": 4059, "b": 4060, "c": 5741}}, {"input": {"n": 7}, "output": {"a": 137903, "b": 137904, "c": 195025}}, {"input": {"n": 8}, "output": {"a": 803760, "b": 803761, "c": 1136689}}, {"input": {"n": 19}, "output": {"a": 211929657785303, "b": 211929657785304, "c": 299713796309065}}, {"input": {"n": 9}, "output": {"a": 4684659, "b": 4684660, "c": 6625109}}, {"input": {"n": 18}, "output": {"a": 36361380737780, "b": 36361380737781, "c": 51422757785981}}, {"input": {"n": 1}, "output": {"a": 3, "b": 4, "c": 5}}, {"input": {"n": 16}, "output": {"a": 1070379110496, "b": 1070379110497, "c": 1513744654945}}, {"input": {"n": 15}, "output": {"a": 183648021599, "b": 183648021600, "c": 259717522849}}], "error_log": []}
{"context": "Given a range of numbers from 1 to `n`, what is the ratio of numbers that have exactly `k` prime factors with a square in their factorization?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The upper limit of the range of numbers to consider.\n  `k` (int): The number of prime factors that should have a square in their factorization.\n\nOutput:\n  `return` (float): The ratio of numbers in the range [1, n] that have exactly `k` prime factors with a square in their factorization.", "reference_code": "# import necessary packages\nfrom math import sqrt\n\n# all class and function definitions in the code file, if any\ndef prime_factors(n):\n    d = {}\n    while not n % 2:\n        d[2] = d.get(2, 0) + 1\n        n /= 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while not n % i:\n            d[i] = d.get(i, 0) + 1\n            n /= i\n    if n > 2:\n        d[n] = d.get(n, 0) + 1\n    return d\n\ndef count_sqr(n):\n    count = 0\n    for mul in prime_factors(n).values():\n        if mul > 1:\n            count += 1\n    return count\n\ndef C_k(n, k):\n    count = 0\n    for i in range(1, n + 1):\n        if count_sqr(i) == k:\n            count += 1\n    return count\n\n# main function\ndef main_solution(n, k):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return C_k(n, k) / n", "input_generator": "import random\n\ndef input_generator():\n    k = random.randint(1, 5)\n    n = random.randint(10, 1000)\n    return {'n': n, 'k': k}", "io_pairs": [{"input": {"n": 331, "k": 1}, "output": 0.3413897280966767}, {"input": {"n": 28, "k": 4}, "output": 0.0}, {"input": {"n": 352, "k": 5}, "output": 0.0}, {"input": {"n": 579, "k": 3}, "output": 0.0}, {"input": {"n": 701, "k": 2}, "output": 0.04992867332382311}, {"input": {"n": 136, "k": 1}, "output": 0.3602941176470588}, {"input": {"n": 683, "k": 3}, "output": 0.0}, {"input": {"n": 791, "k": 2}, "output": 0.04804045512010114}, {"input": {"n": 175, "k": 2}, "output": 0.02857142857142857}, {"input": {"n": 44, "k": 5}, "output": 0.0}], "error_log": []}
{"context": "Given a text string and a set of formatting instructions, where each instruction specifies a type of HTML formatting (e.g., bold, italic, strike) and the range of indices in the text where the formatting should be applied, how can we generate the text with the appropriate HTML tags inserted to represent the specified formatting?\n\nThe input and output requirements are as follows:\n\nInput:\n  `text` (str): The input text string that needs to be formatted.\n  `formatting` (list of tuples): A list of tuples where each tuple represents a format to be applied to the text. Each tuple contains three elements:\n    - `format_type` (str): The type of format (e.g., \"b\" for bold, \"i\" for italic).\n    - `start_index` (int): The starting index (inclusive) of the format in the text.\n    - `end_index` (int): The ending index (exclusive) of the format in the text.\n\nOutput:\n  `return` (str): The formatted text string with HTML tags representing the start and end of different formats.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef helper(text, fmt):\n    out = text\n    for i in fmt:\n        out = \"<{1}>{0}</{1}>\".format(out, i)\n    return out\n\ndef start(fmt):\n    return \"<{}>\".format(fmt)\n\ndef end(fmt):\n    return \"</{}>\".format(fmt)\n\ndef htmlify(text, fmt):\n    n = len(text)\n    store = [[] for _ in range(n)]\n    for i in range(n):\n        for j in fmt:\n            if j[1] <= i < j[2]:\n                store[i].append(j[0])\n    out = \"\"\n    in_progress = []\n    end_everything = False\n    for i in range(n):\n        fmt_arr = store[i]\n        for ip in in_progress:\n            if ip in fmt_arr:\n                continue\n            else:\n                end_everything = True\n\n        if end_everything:\n            while in_progress != []:\n                out += end(in_progress.pop())\n            end_everything = False\n\n        for f in fmt_arr:\n            if f in in_progress:\n                continue\n            else:\n                out += start(f)\n                in_progress.append(f)\n        out += text[i]\n    while in_progress != []:\n        out += end(in_progress.pop())\n    return out\n\n# main function\ndef main_solution(text, formatting):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # convert JSON serializable inputs to the original input variables\n    formatting = [(f[0], int(f[1]), int(f[2])) for f in formatting]\n    \n    # call the original function with the converted inputs\n    result = htmlify(text, formatting)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    text_length = random.randint(5, 20)\n    text = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(text_length))\n    \n    num_formats = random.randint(1, 3)\n    formatting = []\n    tags = ['b', 'i', 'u', 'strong', 'em', 'span']\n    \n    for _ in range(num_formats):\n        tag = random.choice(tags)\n        start_pos = random.randint(0, text_length - 2)\n        end_pos = random.randint(start_pos + 1, text_length)\n        formatting.append([tag, start_pos, end_pos])\n    \n    return {\n        'text': text,\n        'formatting': formatting\n    }", "io_pairs": [{"input": {"text": "KphmbGQ", "formatting": [["span", 2, 5]]}, "output": "Kp<span>hmb</span>GQ"}, {"input": {"text": "oSV28T7SD1BfCwlqKVXt", "formatting": [["i", 17, 19]]}, "output": "oSV28T7SD1BfCwlqK<i>VX</i>t"}, {"input": {"text": "kYVDIsZP2Mz", "formatting": [["i", 5, 8], ["u", 1, 10]]}, "output": "k<u>YVDI<i>sZP</i></u><u>2M</u>z"}, {"input": {"text": "QO8ash", "formatting": [["em", 1, 2], ["span", 4, 6]]}, "output": "Q<em>O</em>8a<span>sh</span>"}, {"input": {"text": "iG2am", "formatting": [["strong", 1, 3], ["span", 1, 4], ["em", 3, 5]]}, "output": "i<strong><span>G2</span></strong><span><em>a</em></span><em>m</em>"}, {"input": {"text": "NSbSWyx1FdcPA", "formatting": [["span", 9, 13]]}, "output": "NSbSWyx1F<span>dcPA</span>"}, {"input": {"text": "tSMI0v", "formatting": [["span", 3, 5], ["em", 0, 1], ["u", 0, 1]]}, "output": "<em><u>t</u></em>SM<span>I0</span>v"}, {"input": {"text": "QBfcBx2cLG7569FI", "formatting": [["span", 5, 15]]}, "output": "QBfcB<span>x2cLG7569F</span>I"}, {"input": {"text": "dvEa5Tm", "formatting": [["span", 5, 6], ["i", 4, 6], ["b", 3, 4]]}, "output": "dvE<b>a</b><i>5<span>T</span></i>m"}, {"input": {"text": "97T2cdosysZbrNdTN7L", "formatting": [["span", 0, 7]]}, "output": "<span>97T2cdo</span>sysZbrNdTN7L"}], "error_log": []}
{"context": "Given a list of integers, how can we format the list to show ranges of consecutive numbers, separating different ranges by commas? Specifically, a range of numbers will be considered if three or more consecutive numbers are found in the list.\n\nThe input and output requirements are as follows:\n\nInput:\n  `ranges` (list of integers): A list of integers for which the function will identify and format ranges of consecutive numbers.\n\nOutput:\n  `return` (string): A string representing the ranges of consecutive numbers separated by commas. Each range is formatted as \"start-end\" if it contains three or more consecutive numbers, otherwise, individual numbers are listed.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# main function\ndef main_solution(ranges):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    ans = \"\"\n    if len(ranges) == 0:\n        return ans\n    R = [ranges[0]]\n    for cur in ranges[1:]:\n        if cur == R[-1] + 1:\n            R.append(cur)\n        else:\n            if len(R) >= 3:\n                ans += \", \" + str(R[0]) + \"-\" + str(R[-1])\n            else:\n                ans += \", \" + \", \".join(map(str, R))\n            R = [cur]\n    if len(R) >= 3:\n        ans += \", \" + str(R[0]) + \"-\" + str(R[-1])\n    else:\n        ans += \", \" + \", \".join(map(str, R))\n    return ans[2:]", "input_generator": "import random\n\ndef input_generator():\n    num_ranges = random.randint(0, 20)\n    ranges = []\n    if num_ranges > 0:\n        start = random.randint(0, 100)\n        ranges.append(start)\n        for _ in range(1, num_ranges):\n            if random.random() < 0.7:\n                start += 1\n            else:\n                start += random.randint(2, 5)\n            ranges.append(start)\n    return {'ranges': ranges}", "io_pairs": [{"input": {"ranges": [98, 99, 100, 102, 104, 109, 110, 111, 112, 114]}, "output": "98-100, 102, 104, 109-112, 114"}, {"input": {"ranges": [94, 98, 99, 104, 105]}, "output": "94, 98, 99, 104, 105"}, {"input": {"ranges": [52, 55, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71]}, "output": "52, 55, 60-71"}, {"input": {"ranges": [100, 101]}, "output": "100, 101"}, {"input": {"ranges": [8, 9, 12, 13, 15, 19, 20, 21, 22, 23, 24]}, "output": "8, 9, 12, 13, 15, 19-24"}, {"input": {"ranges": [74, 75, 76, 77, 78, 79, 80, 81, 83]}, "output": "74-81, 83"}, {"input": {"ranges": [9, 10]}, "output": "9, 10"}, {"input": {"ranges": [35]}, "output": "35"}, {"input": {"ranges": [29, 30, 32, 33, 37, 38, 39]}, "output": "29, 30, 32, 33, 37-39"}, {"input": {"ranges": [13, 17, 21, 25, 26, 27, 28, 32, 33, 35, 36, 37, 38]}, "output": "13, 17, 21, 25-28, 32, 33, 35-38"}], "error_log": []}
{"context": "Given a 3D vector and a rotation axis, what is the new position of the vector after rotating it by a specified angle around the axis?\n\nThe input and output requirements are as follows:\n\nInput:\n  `vector` (list of floats): A list representing the 3D vector to be rotated.\n  `axis` (list of floats): A list representing the 3D axis of rotation, which must be a normal vector.\n  `angle` (float): The angle of rotation in radians.\n\nOutput:\n  `return` (list of floats): A list representing the rotated 3D vector.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef rotate_vector(vector, axis, angle):\n    \"\"\"\n    Uses Rodrigues rotation formula\n    axis must be a normal vector\n    \"\"\"\n    k = axis\n    v = vector\n    v_rot = (v * np.cos(angle) + np.cross(k, v) * np.sin(angle) +\n             k * (np.dot(k, v)) * (1 - np.cos(angle)))\n\n    return v_rot\n\n# main function\ndef main_solution(vector, axis, angle):\n    # Convert JSON serializable inputs to numpy arrays\n    vector = np.array(vector)\n    axis = np.array(axis)\n    \n    # Call the rotate_vector function\n    rotated_vector = rotate_vector(vector, axis, angle)\n    \n    # Convert the result back to a JSON serializable format\n    rotated_vector = rotated_vector.tolist()\n    \n    # Return the result\n    return rotated_vector", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random 3D vector\n    vector = [random.uniform(-10, 10) for _ in range(3)]\n    \n    # Generate a random axis (normalized)\n    axis = np.random.randn(3)\n    axis = axis / np.linalg.norm(axis)\n    axis = axis.tolist()\n    \n    # Generate a random angle in radians between -2\u03c0 and 2\u03c0\n    angle = random.uniform(-2 * np.pi, 2 * np.pi)\n    \n    return {\n        'vector': vector,\n        'axis': axis,\n        'angle': angle\n    }", "io_pairs": [{"input": {"vector": [0.5304525893592427, 0.9053062353507553, 3.6644034125124527], "axis": [0.6790600824903444, 0.7120821711456543, -0.1783714828796843], "angle": -2.722993530852185}, "output": [-1.154517145525195, 0.7014096106489973, -3.5642567833607846]}, {"input": {"vector": [-4.342547149313187, -2.275422438095953, 5.086984774234848], "axis": [0.5550669222459937, -0.18264167092748473, 0.811506458304046], "angle": -1.827099758262925}, "output": [1.697718091985346, 6.22869905697233, 2.8694491539167313]}, {"input": {"vector": [-5.336847650459671, -3.4767808115815875, 8.117337358632138], "axis": [-0.7462504571606893, 0.26519340668479463, 0.6105593437483167], "angle": 3.5620010714964394}, "output": [-8.316848431749467, 6.098460949575297, 0.31610071125413697]}, {"input": {"vector": [0.9811008282718845, -2.2851821113887834, -7.319766908396533], "axis": [-0.6096139214837628, -0.7782809840717344, 0.15049776265952095], "angle": 4.102177129206261}, "output": [-5.588343858712586, 4.748927478158041, 2.4457523248867283]}, {"input": {"vector": [-1.5610948966770781, -9.464601381352121, -6.127028298842728], "axis": [-0.9814267610470097, -0.05061459753101151, 0.18503965849933193], "angle": 4.099999891551711}, "output": [-2.1455705023824434, 10.527402165622462, -3.758524074912538]}, {"input": {"vector": [-5.878257174505825, -5.599315709673787, -4.333473248141311], "axis": [0.19175434514176773, -0.6301301282279269, -0.7524402252795288], "angle": 3.1566583288930072}, "output": [8.071148741100181, -1.6154030821202747, -4.114883364069818]}, {"input": {"vector": [-3.3855867484463564, 2.238198004750334, -6.165210268899459], "axis": [-0.6308058167620102, 0.3861560484821339, 0.6730286232842383], "angle": 0.16872639438586656}, "output": [-3.9799629085627344, 1.16439703703044, -6.106195246312297]}, {"input": {"vector": [-9.25010941189218, 1.4715597112290961, -8.33879081695401], "axis": [-0.9417344875379353, -0.20509713837235846, 0.26659204566740524], "angle": 1.2782256087994446}, "output": [-5.551493740564457, -10.358867381565412, -4.374954653961484]}, {"input": {"vector": [0.7241585782588995, -5.745237555629748, 2.5378691113327427], "axis": [-0.09855519861098391, 0.40263554714913685, 0.9100392788218895], "angle": -5.081971073280974}, "output": [6.094511886501411, -1.246882354786653, 1.1292250005893378]}, {"input": {"vector": [-5.6837625447414775, -8.208668896838443, 6.0794754828310005], "axis": [0.10740271692733722, 0.9551474928486796, -0.2759672504148052], "angle": -5.3968452717736195}, "output": [-1.2498221344732765, -8.038324115619552, 8.394683669662722]}], "error_log": []}
{"context": "Given a large number of random points within a square of side length 2 centered at the origin, how can we estimate the value of \u03c0 to three decimal places using the proportion of points that fall within a quarter circle inscribed in the square?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_trials` (int): The number of random points to generate for the Monte Carlo simulation. This should be a positive integer.\n\nOutput:\n  `return` (float): The estimated value of \u03c0 to 3 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(num_trials):\n    hits = 0\n    for _ in range(num_trials):\n        x = random.uniform(-1, 1)\n        y = random.uniform(-1, 1)\n        if x**2 + y**2 <= 1:\n            hits += 1\n    estimate = 4.0 * (hits / num_trials)\n    return round(estimate, 3)", "input_generator": "import random\n\ndef input_generator():\n    return {'num_trials': random.randint(100, 10000)}", "io_pairs": [{"input": {"num_trials": 4258}, "output": 3.107}, {"input": {"num_trials": 6768}, "output": 3.146}, {"input": {"num_trials": 1499}, "output": 3.162}, {"input": {"num_trials": 5355}, "output": 3.136}, {"input": {"num_trials": 2051}, "output": 3.128}, {"input": {"num_trials": 573}, "output": 3.141}, {"input": {"num_trials": 1316}, "output": 3.164}, {"input": {"num_trials": 8203}, "output": 3.126}, {"input": {"num_trials": 5564}, "output": 3.165}, {"input": {"num_trials": 2682}, "output": 3.089}], "error_log": []}
{"context": "Given a range of numbers, how many numbers within the range are only increasing and contain at least one double digit, and how many of those also have at least one isolated double digit?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start` (int): The starting number of the range (inclusive).\n  `stop` (int): The ending number of the range (inclusive).\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `part1_count` (int): The count of numbers in the range that are only increasing and contain at least one double digit.\n    - `part2_count` (int): The count of numbers in the range that are only increasing, contain at least one double digit, and have at least one isolated double digit.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef only_increasing(number):\n    previous_num = ''\n    for c in str(number):\n        if len(previous_num) == 0: \n            previous_num = c\n            continue\n        \n        if int(c) < int(previous_num):\n            return False\n    \n        previous_num = c\n\n    return True\n\ndef contains_doubles(number):\n    number = str(number)\n\n    if len(number) < 2:\n        return False\n\n    for i in range(0, len(number)-1):\n        if number[i] == number[i+1]:\n            return True \n    return False \n\ndef isolated_double(number):\n    number = str(number)\n    length = len(number)\n    atleast_one_double = False\n\n    for x in range(0, length-1):\n        if x == 0:\n            if number[x] == number[x+1] and number[x+1] != number[x+2]:\n                return True\n        elif x+2 <= length-1:\n            if number[x-1] != number[x] and number[x] == number[x+1] and number[x+1] != number[x+2]:\n                return True\n        elif x+1 <= length-1:\n            if number[x-1] != number[x] and number[x] == number[x+1]:\n                return True\n        elif x <= length-1:\n            if number[x-2] != number[x-1] and number[x-1] == number[x]:\n                return True\n        \n    return False\n\n# main function\ndef main_solution(start, stop):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    count_part1 = 0\n    count_part2 = 0\n    \n    for i in range(start, stop+1):\n        if only_increasing(i) and contains_doubles(i):\n            count_part1 += 1\n            if isolated_double(i):\n                count_part2 += 1\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"part1_count\": count_part1, \"part2_count\": count_part2}", "input_generator": "import random\n\ndef input_generator():\n    start = random.randint(100000, 500000)\n    stop = start + random.randint(1000, 5000)\n    return {\"start\": start, \"stop\": stop}", "io_pairs": [{"input": {"start": 271944, "stop": 273812}, "output": {"part1_count": 0, "part2_count": 0}}, {"input": {"start": 148898, "stop": 153368}, "output": {"part1_count": 3, "part2_count": 1}}, {"input": {"start": 204597, "stop": 209326}, "output": {"part1_count": 0, "part2_count": 0}}, {"input": {"start": 410825, "stop": 414520}, "output": {"part1_count": 0, "part2_count": 0}}, {"input": {"start": 382532, "stop": 385150}, "output": {"part1_count": 0, "part2_count": 0}}, {"input": {"start": 282136, "stop": 284619}, "output": {"part1_count": 0, "part2_count": 0}}, {"input": {"start": 468957, "stop": 473779}, "output": {"part1_count": 2, "part2_count": 0}}, {"input": {"start": 197988, "stop": 202833}, "output": {"part1_count": 1, "part2_count": 0}}, {"input": {"start": 160210, "stop": 164349}, "output": {"part1_count": 0, "part2_count": 0}}, {"input": {"start": 324347, "stop": 329144}, "output": {"part1_count": 0, "part2_count": 0}}], "error_log": []}
{"context": "Given a key and a lock represented by 2D matrices, where 1s represent the parts of the key and lock that can interact, and 0s represent the empty parts, determine if the key can be rotated and positioned to unlock the lock. The lock is considered unlocked if all the 1s in the lock matrix are covered by the 1s in the key matrix after proper rotation and positioning. How can we determine if the key can unlock the lock?\n\nThe input and output requirements are as follows:\n\nInput:\n  `key` (list of lists of integers): A 2D list representing the key matrix. Each element is either 0 or 1.\n  `lock` (list of lists of integers): A 2D list representing the lock matrix. Each element is either 0 or 1.\n\nOutput:\n  `return` (boolean): Returns `True` if the key can be rotated and positioned to unlock the lock, otherwise returns `False`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef attach(x, y, M, key, board):\n    for i in range(M):\n        for j in range(M):\n            board[x + i][y + j] += key[i][j]\n\ndef detach(x, y, M, key, board):\n    for i in range(M):\n        for j in range(M):\n            board[x + i][y + j] -= key[i][j]\n\ndef rotate90(arr):\n    return list(zip(*arr[::-1]))\n\ndef check(board, M, N):\n    for i in range(N):\n        for j in range(N):\n            if board[M - 1 + i][M - 1 + j] != 1:\n                return False\n    return True\n\n# main function\ndef main_solution(key, lock):\n    M, N = len(key), len(lock)\n    board = [[0] * ((M - 1) * 2 + N) for _ in range((M - 1) * 2 + N)]\n    for i in range(N):\n        for j in range(N):\n            board[M - 1 + i][M - 1 + j] = lock[i][j]\n    rotated_key = key\n    for _ in range(4):\n        rotated_key = rotate90(rotated_key)\n        for x in range(0, M + N - 1):\n            for y in range(0, M + N - 1):\n                attach(x, y, M, rotated_key, board)\n                if check(board, M, N):\n                    return True\n                detach(x, y, M, rotated_key, board)\n    return False", "input_generator": "import random\n\ndef input_generator():\n    M = random.randint(1, 5)  # Key size (1x1 to 5x5)\n    N = random.randint(1, 10)  # Lock size (1x1 to 10x10)\n    \n    # Generate random key (0s and 1s)\n    key = [[random.randint(0, 1) for _ in range(M)] for _ in range(M)]\n    \n    # Generate lock with at least one 0 to make the problem non-trivial\n    lock = [[1 for _ in range(N)] for _ in range(N)]\n    zero_positions = random.sample(range(N * N), random.randint(1, N * N))\n    for pos in zero_positions:\n        i = pos // N\n        j = pos % N\n        lock[i][j] = 0\n    \n    return {'key': key, 'lock': lock}", "io_pairs": [{"input": {"key": [[1, 0], [0, 0]], "lock": [[1, 1, 1], [1, 0, 1], [1, 1, 1]]}, "output": true}, {"input": {"key": [[0, 0], [1, 1]], "lock": [[0, 0], [0, 1]]}, "output": false}, {"input": {"key": [[1]], "lock": [[1, 1, 1, 1], [0, 1, 0, 1], [1, 0, 1, 1], [1, 0, 0, 0]]}, "output": false}, {"input": {"key": [[1, 0, 1], [0, 1, 0], [0, 1, 0]], "lock": [[0]]}, "output": true}, {"input": {"key": [[1, 1], [0, 1]], "lock": [[1, 0, 0], [0, 1, 0], [0, 0, 0]]}, "output": false}, {"input": {"key": [[0]], "lock": [[0]]}, "output": false}, {"input": {"key": [[1, 1], [1, 1]], "lock": [[0, 0], [0, 0]]}, "output": true}, {"input": {"key": [[0]], "lock": [[1, 1, 0, 0], [1, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 0]]}, "output": false}, {"input": {"key": [[0]], "lock": [[0, 0, 1, 1], [0, 0, 0, 1], [1, 0, 0, 0], [0, 1, 1, 0]]}, "output": false}, {"input": {"key": [[1, 1], [0, 0]], "lock": [[0, 0], [0, 0]]}, "output": false}], "error_log": []}
{"context": "Given a mathematical expression \\( e^x \\), which represents the exponential function, how can we approximate its value using a finite number of terms from its Taylor series expansion? Specifically, what is the result of the Taylor series expansion for \\( e^x \\) when using `n` terms and for a given exponent value `x`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): The exponent value for which the exponential function e^x is to be calculated.\n  `n` (int): The number of terms in the Taylor series to use for the calculation.\n\nOutput:\n  `return` (float): The result of the Taylor series expansion for e^x.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(x: float, n: int) -> float:\n    \"\"\"\n    Calculate the exponential function e^x using Taylor series expansion up to n terms.\n\n    Parameters:\n    x (float): The exponent value.\n    n (int): The number of terms in the Taylor series to use.\n\n    Returns:\n    float: The result of the Taylor series expansion for e^x.\n    \"\"\"\n    total = 1 + x\n    for i in range(2, n+1):\n        total += x ** i / math.factorial(i)\n    return total", "input_generator": "import random\nimport math\n\ndef input_generator():\n    x = random.uniform(-10.0, 10.0)\n    n = random.randint(1, 20)\n    return {'x': x, 'n': n}", "io_pairs": [{"input": {"x": 1.1216950585104613, "n": 3}, "output": 2.9860143778350743}, {"input": {"x": 0.7340966619212992, "n": 1}, "output": 1.7340966619212992}, {"input": {"x": 2.7539558480520903, "n": 17}, "output": 15.704634299152413}, {"input": {"x": 0.5585806895553258, "n": 10}, "output": 1.7481895149681277}, {"input": {"x": 0.8591103094156587, "n": 20}, "output": 2.36105914688915}, {"input": {"x": 2.4944321548286137, "n": 16}, "output": 12.114852186420583}, {"input": {"x": 8.729357510787526, "n": 11}, "output": 5121.274631588429}, {"input": {"x": -8.589538915726981, "n": 11}, "output": -200.2810369415185}, {"input": {"x": 9.573942090248565, "n": 9}, "output": 7368.476420890796}, {"input": {"x": 3.756260007934797, "n": 15}, "output": 42.78800324359295}], "error_log": []}
{"context": "Given a decimal number with a repeating part enclosed in parentheses, what is the equivalent fraction in its lowest terms? For example, if the decimal is \"0.(6)\", what is the fraction representation of this number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `decimal_string` (str): A string representing a decimal number with a repeating part enclosed in parentheses. For example, \"0.(6)\" or \"0.19(2367)\".\n\nOutput:\n  `return` (str): A string representing the equivalent fraction in lowest terms. For example, \"2/3\" or \"5343/27775\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef fractions(d):\n    p_ent = d[:d.index('.')]\n    p_dec = d[d.index('.')+1:d.index('(')]\n    rep = d[d.index('(')+1:d.index(')')]\n\n    f = [int(rep), 10**len(p_dec)*(10**(len(rep))-1)]\n    f[0] += int(p_ent) * f[1]\n    if len(p_dec):\n        f[0] += int(p_dec) * (10**(len(rep))-1)\n\n    g = gcd(f[0], f[1])\n    f = [f[0] // g, f[1] // g]\n    \n    return str(f[0]) + '/' + str(f[1])\n\n# main function\ndef main_solution(decimal_string):\n    # Convert the input string to the required format for the fractions function\n    result = fractions(decimal_string)\n    # Return the result as a string\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random integer part (0 to 999)\n    integer_part = random.randint(0, 999)\n    \n    # Generate a random non-repeating decimal part (0 to 3 digits)\n    decimal_length = random.randint(0, 3)\n    decimal_part = ''.join(random.choices(string.digits, k=decimal_length)) if decimal_length > 0 else ''\n    \n    # Generate a random repeating part (1 to 3 digits)\n    repeat_length = random.randint(1, 3)\n    repeat_part = ''.join(random.choices(string.digits, k=repeat_length))\n    \n    # Construct the decimal string\n    decimal_string = f\"{integer_part}.\"\n    if decimal_part:\n        decimal_string += decimal_part\n    decimal_string += f\"({repeat_part})\"\n    \n    return {'decimal_string': decimal_string}", "io_pairs": [{"input": {"decimal_string": "745.255(376)"}, "output": "744510121/999000"}, {"input": {"decimal_string": "746.1(00)"}, "output": "7461/10"}, {"input": {"decimal_string": "860.(27)"}, "output": "9463/11"}, {"input": {"decimal_string": "942.676(167)"}, "output": "941733491/999000"}, {"input": {"decimal_string": "910.5(937)"}, "output": "4548416/4995"}, {"input": {"decimal_string": "355.8(120)"}, "output": "592427/1665"}, {"input": {"decimal_string": "58.340(19)"}, "output": "5775679/99000"}, {"input": {"decimal_string": "25.42(9)"}, "output": "2543/100"}, {"input": {"decimal_string": "340.(1)"}, "output": "3061/9"}, {"input": {"decimal_string": "371.3(14)"}, "output": "367601/990"}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, the board is represented by a 3x3 grid. Each cell in the grid can either be empty, occupied by player 'X', or occupied by player 'O'. Given the current state of the board, what is the next move the AI should make, and what is the resulting game status after this move?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_state` (list of lists of strings): A 3x3 grid representing the current state of the Tic-Tac-Toe board. Each cell can be `'X'`, `'O'`, or `None` (indicating an empty cell).\n\nOutput:\n  `return` (dictionary): A dictionary containing two keys:\n  - `\"board\"` (list of lists of strings): The updated 3x3 grid after the AI's move.\n  - `\"result\"` (string): The result of the game after the AI's move. It can be `'X'` (human wins), `'O'` (AI wins), `'tie'` (game is a tie), or `None` (game is still ongoing).", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# Global Variables\nhuman = 'X'\nai = 'O'\n\n# Function to check if three elements are equal and not None\ndef equals3(a, b, c):\n    return a == b and b == c and a != None\n\n# Function to check for a winner or tie\ndef check_winner(board):\n    winner = None\n    # Check horizontal\n    for i in range(3):\n        if equals3(board[i][0], board[i][1], board[i][2]):\n            winner = board[i][0]\n    # Check vertical\n    for i in range(3):\n        if equals3(board[0][i], board[1][i], board[2][i]):\n            winner = board[0][i]\n    # Check diagonal\n    if equals3(board[0][0], board[1][1], board[2][2]):\n        winner = board[0][0]\n    if equals3(board[2][0], board[1][1], board[0][2]):\n        winner = board[2][0]\n    # Check for a tie\n    open_spots = 0\n    for row in board:\n        for item in row:\n            if item == None:\n                open_spots += 1\n\n    if winner is None and open_spots == 0:\n        return 'tie'\n    else:\n        return winner\n\n# Minimax algorithm with alpha-beta pruning\ndef minimax(board, depth, alpha, beta, max_player):\n    result = check_winner(board)\n    if result == ai:\n        return 10\n    if result == human:\n        return -10\n    if result == 'tie':\n        return 0\n\n    if max_player:\n        max_val = -math.inf\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] == None:\n                    board[i][j] = ai\n                    cur_eval = minimax(board, depth+1, alpha, beta, False)\n                    max_val = max(max_val, cur_eval)\n                    board[i][j] = None\n                    alpha = max(alpha, cur_eval)\n                    if beta <= alpha:\n                        break\n        return max_val\n    else:\n        min_val = math.inf\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] == None:\n                    board[i][j] = human\n                    cur_eval = minimax(board, depth+1, alpha, beta, True)\n                    min_val = min(min_val, cur_eval)\n                    board[i][j] = None\n                    beta = min(beta, cur_eval)\n                    if beta <= alpha:\n                        break\n        return min_val\n\n# Function to find the best move for the AI\ndef find_best_move(board):\n    best_val = None\n    best_move = None\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == None:\n                board[i][j] = ai\n                move_val = minimax(board, 0, -math.inf, math.inf, False)\n                board[i][j] = None\n                if best_val is None or move_val > best_val:\n                    best_val = move_val\n                    best_move = [i, j]\n    return best_move\n\n# Main function to determine the next move and check the game status\ndef main_solution(board_state):\n    board = board_state\n    if check_winner(board) is None:\n        best_move = find_best_move(board)\n        board[best_move[0]][best_move[1]] = ai\n    result = check_winner(board)\n    return {\"board\": board, \"result\": result}", "input_generator": "import random\n\ndef input_generator():\n    board = [[None for _ in range(3)] for _ in range(3)]\n    symbols = ['X', 'O', None]\n    weights = [0.4, 0.4, 0.2]\n    \n    for i in range(3):\n        for j in range(3):\n            board[i][j] = random.choices(symbols, weights=weights)[0]\n    \n    return {\"board_state\": board}", "io_pairs": [{"input": {"board_state": [["X", "X", "X"], ["X", "X", "X"], ["O", "O", "O"]]}, "output": {"board": [["X", "X", "X"], ["X", "X", "X"], ["O", "O", "O"]], "result": "O"}}, {"input": {"board_state": [["X", "O", "X"], ["O", "O", "X"], [null, "X", "X"]]}, "output": {"board": [["X", "O", "X"], ["O", "O", "X"], [null, "X", "X"]], "result": "X"}}, {"input": {"board_state": [[null, "X", null], ["O", "X", "X"], ["O", "O", "O"]]}, "output": {"board": [[null, "X", null], ["O", "X", "X"], ["O", "O", "O"]], "result": "O"}}, {"input": {"board_state": [["O", "O", "O"], ["X", "O", "X"], ["O", null, null]]}, "output": {"board": [["O", "O", "O"], ["X", "O", "X"], ["O", null, null]], "result": "O"}}, {"input": {"board_state": [["X", "O", null], ["O", "O", "O"], ["X", "X", "O"]]}, "output": {"board": [["X", "O", null], ["O", "O", "O"], ["X", "X", "O"]], "result": "O"}}, {"input": {"board_state": [["X", "X", "O"], [null, "O", null], [null, "O", "X"]]}, "output": {"board": [["X", "X", "O"], [null, "O", null], [null, "O", "X"]], "result": null}}, {"input": {"board_state": [["O", "X", "X"], ["O", "O", "O"], ["X", "X", null]]}, "output": {"board": [["O", "X", "X"], ["O", "O", "O"], ["X", "X", null]], "result": "O"}}, {"input": {"board_state": [["X", "O", "X"], [null, "X", "X"], ["O", "O", "X"]]}, "output": {"board": [["X", "O", "X"], [null, "X", "X"], ["O", "O", "X"]], "result": "X"}}, {"input": {"board_state": [["X", "O", "X"], ["O", "O", "O"], [null, "X", "O"]]}, "output": {"board": [["X", "O", "X"], ["O", "O", "O"], [null, "X", "O"]], "result": "O"}}, {"input": {"board_state": [["X", "X", null], ["X", "X", null], ["X", "X", "X"]]}, "output": {"board": [["X", "X", null], ["X", "X", null], ["X", "X", "X"]], "result": "X"}}], "error_log": []}
{"context": "In a social network analysis, we are interested in understanding the structural properties of a network. Given a network with a certain number of nodes and edges, what is the maximum clustering coefficient and the total number of triangles in the network?\n\nThe input and output requirements are as follows:\n\nInput:\n  `nodes` (list of int): A list of integers representing the nodes in the network.\n  `edges` (list of tuple of int): A list of tuples, where each tuple represents an edge between two nodes.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `max_clustering_coefficient` (float): The maximum clustering coefficient of the network.\n    - `num_triangles` (float): The number of triangles in the network.", "reference_code": "# import necessary packages\nimport random\nfrom functools import reduce\nimport operator as op\n\n# all class and function definitions in the code file, if any\nclass Network():\n    def __init__(self, nodes, edges):\n        self.nodes = set()\n        self.edges = set()\n        self.n_nodes = 0\n        self.n_edges = 0\n        self.adj = {}\n        self.add_nodes(nodes)\n        self.add_edges(edges)\n\n    def add_nodes(self, nodes):\n        self.nodes.update(nodes)\n        for node in nodes:\n            self.adj[node] = set()\n        self.n_nodes = self.calc_n_nodes()\n\n    def add_edges(self, edges):\n        self.edges.update(edges)\n        for edge in edges:\n            self.adj[edge[0]].add(edge[1])\n            self.adj[edge[1]].add(edge[0])\n        self.n_edges = self.calc_n_edges()\n\n    def calc_n_nodes(self):\n        return len(self.nodes)\n\n    def calc_n_edges(self):\n        return len(self.edges)\n\n    def degree(self, node):\n        return len(self.adj[node])\n\n    def max_degree(self):\n        degrees = set()\n        for node in self.nodes:\n            degrees.add(self.degree(node))\n        return max(degrees)\n\n    def clustering_coefficient(self, node):\n        degree = self.degree(node)\n        if degree <= 1:\n            raise Exception(\"node has no edges, therefore no clustering coefficient\")\n        n_neighbor_edges = 0.0\n        neighbors = list(self.adj[node])\n        for i in range(0, len(neighbors)):\n            for j in range(i+1, len(neighbors)):\n                if (neighbors[i], neighbors[j]) in self.edges or (neighbors[j], neighbors[i]) in self.edges:\n                    n_neighbor_edges += 1.0\n        cc = 2.0 * n_neighbor_edges / (degree * (degree - 1.0))\n        return cc\n\n    def max_cc(self):\n        ccs = set()\n        for node in self.nodes:\n            try:\n                ccs.add(self.clustering_coefficient(node))\n            except Exception:\n                pass\n        return max(ccs) if ccs else 0.0\n\n    def n_triangles(self):\n        n_triangles = 0.0\n        finished_nodes = set()\n        for node in self.adj:\n            neighbors = list(self.adj[node].difference(finished_nodes))\n            for i in range(0, len(neighbors)):\n                for j in range(i + 1, len(neighbors)):\n                    if (neighbors[i], neighbors[j]) in self.edges or (neighbors[j], neighbors[i]) in self.edges:\n                        n_triangles += 1.0\n            finished_nodes.add(node)\n        return n_triangles\n\n# main function\ndef main_solution(nodes, edges):\n    # Convert JSON serializable inputs to original input variables\n    nodes = set(nodes)\n    edges = set(tuple(edge) for edge in edges)\n    \n    # Create network instance\n    network = Network(nodes, edges)\n    \n    # Calculate the maximum clustering coefficient\n    max_clustering_coefficient = network.max_cc()\n    \n    # Calculate the number of triangles in the network\n    num_triangles = network.n_triangles()\n    \n    # Convert outputs to JSON serializable format\n    result = {\n        \"max_clustering_coefficient\": max_clustering_coefficient,\n        \"num_triangles\": num_triangles\n    }\n    \n    return result", "input_generator": "import random\nimport itertools\n\ndef input_generator():\n    # Generate a random number of nodes between 5 and 15\n    n_nodes = random.randint(5, 15)\n    nodes = set(range(n_nodes))\n    \n    # Generate edges: ensure the graph is not too sparse or too dense\n    max_edges = n_nodes * (n_nodes - 1) // 2\n    n_edges = random.randint(n_nodes, min(max_edges, 2 * n_nodes))\n    \n    # Create a list of all possible edges\n    all_possible_edges = list(itertools.combinations(nodes, 2))\n    \n    # Randomly sample edges without replacement\n    edges = random.sample(all_possible_edges, n_edges)\n    \n    # Convert nodes and edges to lists of serializable types\n    nodes = list(nodes)\n    edges = [list(edge) for edge in edges]\n    \n    return {\"nodes\": nodes, \"edges\": edges}", "io_pairs": [], "error_log": []}
{"context": "Given a hexadecimal string, how can we convert it to its corresponding base64 encoded string? Specifically, what is the base64 encoded string for the provided hexadecimal input?\n\nThe input and output requirements are as follows:\n\nInput:\n  `hex_input` (str): A string representing the hex input. The string should contain only valid hexadecimal characters (0-9, a-f, A-F) and should have an even number of characters.\n\nOutput:\n  `return` (str): A string representing the base64 encoding of the input hex string.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\nclass Crypt1:\n    def hex_to_base64(self, hex_input):\n        \"\"\"\n        Converts a hexadecimal input to base 64 encoding\n        \"\"\"\n        # Valid input checker\n        self.hex_checker(hex_input)\n\n        # Convert hex to binary\n        binary_string = ''.join(self.hex_digit_to_4bit(i) for i in hex_input)\n\n        # Determine padding\n        numbyte = len(hex_input) // 2\n        if numbyte % 3 == 1:\n            base_holder = self.bin_to_base('', binary_string, 4 * (numbyte // 3))\n            padding_holder = binary_string[-8:] + '0000'\n            base_holder += self.bin_to_base('', padding_holder, 2)\n            base_holder += '=='\n        elif numbyte % 3 == 2:\n            base_holder = self.bin_to_base('', binary_string, 4 * (numbyte // 3))\n            padding_holder = binary_string[-16:] + '00'\n            base_holder += self.bin_to_base('', padding_holder, 3)\n            base_holder += '='\n        else:\n            base_holder = self.bin_to_base('', binary_string, 4 * (numbyte // 3))\n\n        return base_holder\n\n    def hex_digit_to_4bit(self, digit):\n        \"\"\"\n        Converts a digit of hexadecimal to 4 bit binary\n        \"\"\"\n        hex_holder = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']\n        dec = int(hex_holder.index(digit.lower()))\n        return self.base10_to_binary(dec, 4)\n\n    def bin_to_base(self, bass, str, itr):\n        \"\"\"\n        Creates a base64 encoding of a binary stream\n        \"\"\"\n        for i in range(itr):\n            bass += self.bitbin_to_ascii(str[0 + 6 * i: 6 + 6 * i])\n        return bass\n\n    def bitbin_to_ascii(self, binary):\n        \"\"\"\n        Converts a single 6 bit binary chunk into a base64 encoded character\n        \"\"\"\n        b64_index_table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n        return b64_index_table[self.n_bit_binary_decoder(binary, 6)]\n\n    def hex_checker(self, hex_input):\n        \"\"\"\n        Checks the hex string is correct\n        \"\"\"\n        alphabet = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','A','B','C','D','E','F']\n        if len(hex_input) % 2 != 0:\n            raise ValueError('Invalid hex input. It needs to be an even number of characters.')\n        for i in hex_input:\n            if i not in alphabet:\n                raise ValueError(f'Character {i} is an invalid hex character')\n\n    def n_bit_binary_decoder(self, bin, n):\n        \"\"\"\n        Decodes an nbit binary string into base 10\n        \"\"\"\n        max_bin = 2 ** (n - 1)\n        sum = 0\n        for i in range(n):\n            sum += int(bin[i]) * max_bin\n            max_bin /= 2\n        return int(sum)\n\n    def base10_to_binary(self, decimal, bits):\n        \"\"\"\n        Converts a decimal number to a binary string of the required number of bits\n        \"\"\"\n        binary_holder = []\n        while decimal >= 1:\n            if decimal % 2 > 0:\n                binary_holder.append('1')\n            else:\n                binary_holder.append('0')\n            decimal = decimal // 2\n        if len(binary_holder) < bits:\n            while len(binary_holder) < bits:\n                binary_holder.append('0')\n        binary_holder.reverse()\n        return ''.join(binary_holder)\n\n# main function\ndef main_solution(hex_input):\n    \"\"\"\n    Converts a hexadecimal string to a base64 encoded string.\n\n    Input:\n        hex_input (str): A string representing the hex input.\n\n    Output:\n        return (str): A string representing the base64 encoding of the input hex string.\n    \"\"\"\n    crypt = Crypt1()\n    return crypt.hex_to_base64(hex_input)", "input_generator": "import random\nimport string\n\ndef input_generator():\n    hex_chars = '0123456789abcdefABCDEF'\n    length = random.choice([4, 6, 8, 10, 12, 14, 16])  # Even lengths to ensure valid hex input\n    hex_input = ''.join(random.choice(hex_chars) for _ in range(length))\n    return {'hex_input': hex_input}", "io_pairs": [{"input": {"hex_input": "34eEEe76ad"}, "output": "NO7udq0="}, {"input": {"hex_input": "fA5f7EC7a6CB78"}, "output": "+l9+x6bLeA=="}, {"input": {"hex_input": "BAAdCe"}, "output": "uq3O"}, {"input": {"hex_input": "30E8F8E6"}, "output": "MOj45g=="}, {"input": {"hex_input": "870a7C6f1A021c2D"}, "output": "hwp8bxoCHC0="}, {"input": {"hex_input": "6ec4c7AC4c"}, "output": "bsTHrEw="}, {"input": {"hex_input": "82e4f8"}, "output": "guT4"}, {"input": {"hex_input": "01BD102A4a5Dd3"}, "output": "Ab0QKkpd0w=="}, {"input": {"hex_input": "d4D996"}, "output": "1NmW"}, {"input": {"hex_input": "6b7f9929564ad5"}, "output": "a3+ZKVZK1Q=="}], "error_log": []}
{"context": "In a game of Reversi (Othello), given a specific board configuration and a player, what is the optimal move that the player should make to maximize their advantage based on the weighted score of the board positions?\n\nThe input and output requirements are as follows:\n\nInput:\n  `player` (str): The player making the move, either 'o' (White) or '@' (Black).\n  `board_str` (str): A string representation of the board state, where each character represents a cell on the board. The string length is 64, and it should be formatted such that the first 8 characters represent the first row, the next 8 characters represent the second row, and so on.\n\nOutput:\n  `return` (int): The best move for the player, represented as an integer index (11 to 88) on the board.", "reference_code": "# import necessary packages\nimport random\n\n# Constants\nEMPTY, BLACK, WHITE, OUTER = '.', '@', 'o', '?'\nPIECES = (EMPTY, BLACK, WHITE, OUTER)\nPLAYERS = {BLACK: 'Black', WHITE: 'White'}\n\nUP, DOWN, LEFT, RIGHT = -10, 10, -1, 1\nUP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT = -9, 11, 9, -11\nDIRECTIONS = (UP, UP_RIGHT, RIGHT, DOWN_RIGHT, DOWN, DOWN_LEFT, LEFT, UP_LEFT)\n\n# Function definitions\ndef squares():\n    return [i for i in range(11, 89) if 1 <= (i % 10) <= 8]\n\ndef initial_board():\n    board = [OUTER] * 100\n    for i in squares():\n        board[i] = EMPTY\n    board[44], board[45] = WHITE, BLACK\n    board[54], board[55] = BLACK, WHITE\n    return board\n\ndef make_move(move, player, board):\n    board[move] = player\n    for d in DIRECTIONS:\n        make_flips(move, player, board, d)\n    return board\n\ndef make_flips(move, player, board, direction):\n    bracket = find_bracket(move, player, board, direction)\n    if not bracket:\n        return\n    square = move + direction\n    while square != bracket:\n        board[square] = player\n        square += direction\n\ndef find_bracket(square, player, board, direction):\n    bracket = square + direction\n    if board[bracket] == player:\n        return None\n    opp = opponent(player)\n    while board[bracket] == opp:\n        bracket += direction\n    return None if board[bracket] in (OUTER, EMPTY) else bracket\n\ndef opponent(player):\n    return BLACK if player == WHITE else WHITE\n\ndef legal_moves(player, board):\n    return [sq for sq in squares() if is_legal(sq, player, board)]\n\ndef is_legal(move, player, board):\n    hasbracket = lambda direction: find_bracket(move, player, board, direction)\n    return board[move] == EMPTY and any(map(hasbracket, DIRECTIONS))\n\ndef score(player, board):\n    mine, theirs = 0, 0\n    opp = opponent(player)\n    for sq in squares():\n        piece = board[sq]\n        if piece == player: mine += 1\n        elif piece == opp: theirs += 1\n    return mine - theirs\n\ndef random_strategy(player, board):\n    return random.choice(legal_moves(player, board))\n\ndef weighted_score(player, board):\n    opp = opponent(player)\n    total = 0\n    for sq in squares():\n        if board[sq] == player:\n            total += SQUARE_WEIGHTS[sq]\n        elif board[sq] == opp:\n            total -= SQUARE_WEIGHTS[sq]\n    return total\n\nSQUARE_WEIGHTS = [\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0, 120, -20,  20,   5,   5,  20, -20, 120,   0,\n    0, -20, -40,  -5,  -5,  -5,  -5, -40, -20,   0,\n    0,  20,  -5,  15,   3,   3,  15,  -5,  20,   0,\n    0,   5,  -5,   3,   3,   3,   3,  -5,   5,   0,\n    0,   5,  -5,   3,   3,   3,   3,  -5,   5,   0,\n    0,  20,  -5,  15,   3,   3,  15,  -5,  20,   0,\n    0, -20, -40,  -5,  -5,  -5,  -5, -40, -20,   0,\n    0, 120, -20,  20,   5,   5,  20, -20, 120,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n]\n\n# main function\ndef main_solution(player, board_str):\n    # Convert board_str to board list\n    board = [OUTER] * 100\n    for i, char in enumerate(board_str):\n        board[i + 11] = char\n    \n    # Determine the best move using weighted score strategy\n    strategy = maximizer(weighted_score)\n    move = strategy(player, board)\n    \n    # Return the best move\n    return move\n\ndef maximizer(evaluate):\n    def strategy(player, board):\n        def score_move(move):\n            return evaluate(player, make_move(move, player, list(board)))\n        return max(legal_moves(player, board), key=score_move)\n    return strategy", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random player (either BLACK or WHITE)\n    player = random.choice([BLACK, WHITE])\n    \n    # Initialize the board with some randomness\n    board = initial_board()\n    # Randomly place some additional pieces\n    for _ in range(random.randint(5, 20)):\n        legal = legal_moves(player, board)\n        if not legal:\n            break\n        move = random.choice(legal)\n        board = make_move(move, player, board)\n        player = opponent(player)\n    \n    # Convert the board to a string representation (only the squares)\n    board_str = ''.join(board[i] for i in squares())\n    \n    return {'player': player, 'board_str': board_str}", "io_pairs": [{"input": {"player": "@", "board_str": ".....@.......@@o..@..@.o..@o@o.o.oooo.....@.@o...@..o@.........."}, "output": 65}, {"input": {"player": "@", "board_str": "............@oo..o.@@o....oo@o....oo@@...ooo@...ooo............."}, "output": 18}, {"input": {"player": "o", "board_str": "..........@.......@@.o.....o@....ooo@@@..o..o@...o...@.......@.."}, "output": 66}, {"input": {"player": "@", "board_str": "...........@.......@@@.@...@oo@...ooo@.......o.................."}, "output": 67}, {"input": {"player": "@", "board_str": ".....................@.....ooooo..ooo..........................."}, "output": 52}, {"input": {"player": "@", "board_str": "........@o......ooo..o@...@oo@....@@@......@ooo....@......o@...."}, "output": 11}, {"input": {"player": "o", "board_str": ".................@o.......@ooo....o@@.......@..................."}, "output": 18}, {"input": {"player": "o", "board_str": ".............o.....@o......@@o....o@@@...oo....................."}, "output": 37}, {"input": {"player": "@", "board_str": ".........o.o......o@@@....@ooooo..o@o@@@.o.o@...o...o........o.."}, "output": 43}, {"input": {"player": "o", "board_str": ".............@.....@@......@@o....o@o.o....@...................."}, "output": 37}], "error_log": []}
{"context": "Given the geographical coordinates of two points, what is the distance between them in meters?\n\nThe input and output requirements are as follows:\n\nInput:\n- `point1` (list): A list containing the latitude and longitude of the first point in degrees. Example: `[64.28, 100.22]`.\n- `point2` (list): A list containing the latitude and longitude of the second point in degrees. Example: `[40.71, -74.01]`.\n\nOutput:\n- `return` (float): The distance in meters between the two points.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(point1, point2):\n    \"\"\"\n    Calculate the distance in meters between two geographical points.\n    \n    Input:\n    point1 (list): A list containing the latitude and longitude of the first point in degrees.\n    point2 (list): A list containing the latitude and longitude of the second point in degrees.\n    \n    Output:\n    float: The distance in meters between the two points.\n    \"\"\"\n    EarthRadius = 6371\n    lat1, lon1 = point1\n    lat2, lon2 = point2\n    \n    # Convert degrees to radians\n    lat1, lon1, lat2, lon2 = math.radians(lat1), math.radians(lon1), math.radians(lat2), math.radians(lon2)\n    \n    # Calculate the cosine of the central angle\n    cos_d_rad = math.sin(lat1) * math.sin(lat2) + math.cos(lat1) * math.cos(lat2) * math.cos(lon1 - lon2)\n    \n    # Calculate the central angle in radians\n    d = math.acos(cos_d_rad)\n    \n    # Calculate the distance in meters\n    L = d * EarthRadius * 1000\n    \n    return L", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random latitudes between -90 and 90 degrees\n    lat1 = random.uniform(-90, 90)\n    lon1 = random.uniform(-180, 180)\n    # Generate second point within a reasonable distance from the first point\n    lat2 = lat1 + random.uniform(-1, 1)\n    lon2 = lon1 + random.uniform(-1, 1)\n    # Ensure the points are within valid ranges\n    lat2 = max(-90, min(90, lat2))\n    lon2 = max(-180, min(180, lon2))\n    return {'point1': [lat1, lon1], 'point2': [lat2, lon2]}", "io_pairs": [{"input": {"point1": [-54.20916496541309, -131.6049431228701], "point2": [-53.981910166972476, -131.6610322359246]}, "output": 25532.897560873767}, {"input": {"point1": [-15.964602935542018, -10.771286059922573], "point2": [-16.7852947622122, -10.060867758862319]}, "output": 118625.01089671566}, {"input": {"point1": [36.481547970398424, 70.04344979748225], "point2": [36.62528973640912, 69.62040368920523]}, "output": 41029.01919870376}, {"input": {"point1": [51.701794455213985, -179.6033454850252], "point2": [51.671455937068814, -179.6756042902893]}, "output": 6016.109743821772}, {"input": {"point1": [-64.75184382496464, 84.30344307716166], "point2": [-64.51805805636171, 83.47530287315213]}, "output": 47242.48122046601}, {"input": {"point1": [63.50767087130794, 176.22497354617326], "point2": [64.064848000057, 175.2510746623018]}, "output": 78271.1252825393}, {"input": {"point1": [67.55029291645806, -134.27174929843156], "point2": [67.00754548038888, -134.585670468318]}, "output": 61838.22408752838}, {"input": {"point1": [7.649605653175996, 5.595292589411713], "point2": [8.263694773428462, 6.271726699571243]}, "output": 101052.66626624906}, {"input": {"point1": [11.64241427084498, 97.15677195655985], "point2": [10.957799777540757, 96.99906144511849]}, "output": 78043.8124209256}, {"input": {"point1": [-5.683768284453819, -4.1040970293665], "point2": [-5.760535381736643, -3.7630655617149937]}, "output": 38685.52325465586}], "error_log": []}
{"context": "In the context of a Kerbal Space Program physics calculator, given the initial mass of a rocket, the mass of fuel, the change in velocity, the duration of the flight, and the cross-sectional area of the rocket, what are the calculated values for the exhaust velocity, mass flow rate, thrust, gravity force, air resistance, and total force?\n\nThe input and output requirements are as follows:\n\nInput:\n- `mass0_tons` (float): Initial mass of the rocket in tons.\n- `fuel_tons` (float): Mass of fuel in tons.\n- `velocity` (float): Change in velocity in meters per second.\n- `duration` (float): Duration of the flight in seconds.\n- `area` (float): Cross-sectional area of the rocket in square meters.\n\nOutput:\n- `return` (dict): A dictionary containing the following keys:\n  - `exhaust_velocity` (float): Exhaust velocity in meters per second.\n  - `mass_flow_rate` (float): Mass flow rate in kilograms per second.\n  - `thrust` (float): Thrust in Newtons.\n  - `gravity_force` (float): Gravity force in Newtons.\n  - `air_resistance` (float): Air resistance force in Newtons.\n  - `total_force` (float): Total force in Newtons.", "reference_code": "# import necessary packages\nimport math\n\n# Constants\nTONS_TO_KG = 1000\nGRAVITY = 9.8\nAIR_DENSITY = 1.3\nCd = 1.0\n\n# main function\ndef main_solution(mass0_tons, fuel_tons, velocity, duration, area):\n    # Convert mass0 and fuel from tons to kg\n    mass0 = mass0_tons * TONS_TO_KG\n    mass1 = (mass0_tons - fuel_tons) * TONS_TO_KG\n    \n    # Calculate average acceleration\n    avg_accel = velocity / duration\n    \n    # Calculate exhaust velocity (Ve)\n    ve = velocity / math.log(mass0 / mass1)\n    \n    # Calculate mass flow rate (Mfr)\n    massfr = fuel_tons * TONS_TO_KG / duration\n    \n    # Calculate thrust (T)\n    thrust = ve * massfr\n    \n    # Calculate gravity force (Fg)\n    fg = mass0 * GRAVITY\n    \n    # Calculate air resistance (Fd)\n    fd = 0.5 * AIR_DENSITY * area * Cd * avg_accel * avg_accel\n    \n    # Calculate total force (Ftotal)\n    ftotal = thrust - fg - fd\n    \n    # Return results as a dictionary\n    return {\n        \"exhaust_velocity\": ve,\n        \"mass_flow_rate\": massfr,\n        \"thrust\": thrust,\n        \"gravity_force\": fg,\n        \"air_resistance\": fd,\n        \"total_force\": ftotal\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    mass0_tons = random.uniform(10.0, 100.0)  # Initial mass in tons (10 to 100 tons)\n    fuel_tons = random.uniform(1.0, mass0_tons - 1.0)  # Fuel mass in tons (1 to mass0_tons - 1)\n    velocity = random.uniform(100.0, 1000.0)  # Velocity in m/s (100 to 1000 m/s)\n    duration = random.uniform(10.0, 600.0)  # Duration in seconds (10 to 600 s)\n    area = random.uniform(1.0, 50.0)  # Cross-sectional area in m^2 (1 to 50 m^2)\n    \n    return {\n        \"mass0_tons\": mass0_tons,\n        \"fuel_tons\": fuel_tons,\n        \"velocity\": velocity,\n        \"duration\": duration,\n        \"area\": area\n    }", "io_pairs": [{"input": {"mass0_tons": 88.6106605559963, "fuel_tons": 85.2189925502868, "velocity": 982.2475671297283, "duration": 215.20644550775586, "area": 29.067988683148997}, "output": {"exhaust_velocity": 301.03234400381046, "mass_flow_rate": 395.98717570573683, "thrust": 119204.9476981467, "gravity_force": 868384.4734487638, "air_resistance": 393.60419075890314, "total_force": -749573.129941376}}, {"input": {"mass0_tons": 40.04556579507917, "fuel_tons": 33.31319928582554, "velocity": 199.16528009186635, "duration": 281.874472328801, "area": 40.40325084277564}, "output": {"exhaust_velocity": 111.69662909559163, "mass_flow_rate": 118.18452026037446, "thrust": 13200.81252436348, "gravity_force": 392446.54479177593, "air_resistance": 13.111290405134445, "total_force": -379258.8435578176}}, {"input": {"mass0_tons": 63.48459401737898, "fuel_tons": 18.688825925754, "velocity": 883.813571995159, "duration": 56.4927780148121, "area": 34.03196625548662}, "output": {"exhaust_velocity": 2534.7151335342023, "mass_flow_rate": 330.8179661629295, "thrust": 838529.3052781831, "gravity_force": 622149.0213703141, "air_resistance": 5414.219618731669, "total_force": 210966.06428913734}}, {"input": {"mass0_tons": 76.58798697563421, "fuel_tons": 28.534737568069193, "velocity": 487.2616967640637, "duration": 40.43534577110705, "area": 14.061276285751449}, "output": {"exhaust_velocity": 1045.3332703944282, "mass_flow_rate": 705.6879822320847, "thrust": 737679.1263447101, "gravity_force": 750562.2723612153, "air_resistance": 1327.212068930634, "total_force": -14210.358085435832}}, {"input": {"mass0_tons": 53.5685059999132, "fuel_tons": 14.822255599144485, "velocity": 895.548727729753, "duration": 281.29461839783704, "area": 30.406757432116112}, "output": {"exhaust_velocity": 2764.659339101152, "mass_flow_rate": 52.692993856644854, "thrust": 145678.17757097282, "gravity_force": 524971.3587991494, "air_resistance": 200.32680366892416, "total_force": -379493.5080318455}}, {"input": {"mass0_tons": 11.551098570839219, "fuel_tons": 1.8610611829811985, "velocity": 332.2318112176497, "duration": 376.6559093380311, "area": 37.222904197359306}, "output": {"exhaust_velocity": 1891.0947893522869, "mass_flow_rate": 4.9410115090242295, "thrust": 9343.921118845401, "gravity_force": 113200.76599422436, "air_resistance": 18.824197379703712, "total_force": -103875.66907275865}}, {"input": {"mass0_tons": 22.945138830483693, "fuel_tons": 12.800805378737591, "velocity": 350.51808090191366, "duration": 430.4965782628091, "area": 31.80960005261905}, "output": {"exhaust_velocity": 429.45603927772214, "mass_flow_rate": 29.73497589781763, "thrust": 12769.864977095289, "gravity_force": 224862.36053874018, "air_resistance": 13.707334407884325, "total_force": -212106.2028960528}}, {"input": {"mass0_tons": 20.585329558477568, "fuel_tons": 3.7812315836542845, "velocity": 701.1724290175633, "duration": 61.94961152983635, "area": 31.208897514263608}, "output": {"exhaust_velocity": 3454.8022238454782, "mass_flow_rate": 61.0372121838594, "thrust": 210871.49639012577, "gravity_force": 201736.2296730802, "air_resistance": 2598.7486124146203, "total_force": 6536.518104630948}}, {"input": {"mass0_tons": 32.54395828175949, "fuel_tons": 25.53082374530967, "velocity": 459.680567940927, "duration": 133.18880725065662, "area": 20.12330367663753}, "output": {"exhaust_velocity": 299.50382850448074, "mass_flow_rate": 191.68895849680194, "thrust": 57411.5769518287, "gravity_force": 318930.791161243, "air_resistance": 155.8078980915899, "total_force": -261675.02210750588}}, {"input": {"mass0_tons": 45.59188402681144, "fuel_tons": 40.55211549902453, "velocity": 979.8047864045387, "duration": 60.64598933959948, "area": 29.06519897339215}, "output": {"exhaust_velocity": 444.8866357674023, "mass_flow_rate": 668.669370235594, "thrust": 297482.066564821, "gravity_force": 446800.4634627522, "air_resistance": 4931.301996867487, "total_force": -154249.69889479867}}], "error_log": []}
{"context": "Given a string with unique characters, what are all the possible unique permutations of the string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string containing unique characters for which permutations need to be generated.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all permutations of the list of characters\n    permutations = list(itertools.permutations(char_list))\n    \n    # Convert each permutation tuple back to a string\n    result = [''.join(perm) for perm in permutations]\n    \n    # Return the list of permutations\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    input_string = ''.join(random.choice(string.ascii_letters) for _ in range(length))\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "a"}, "output": ["a"]}, {"input": {"input_string": "u"}, "output": ["u"]}, {"input": {"input_string": "ojU"}, "output": ["ojU", "oUj", "joU", "jUo", "Uoj", "Ujo"]}, {"input": {"input_string": "nM"}, "output": ["nM", "Mn"]}, {"input": {"input_string": "rjk"}, "output": ["rjk", "rkj", "jrk", "jkr", "krj", "kjr"]}, {"input": {"input_string": "Ex"}, "output": ["Ex", "xE"]}, {"input": {"input_string": "U"}, "output": ["U"]}, {"input": {"input_string": "JZ"}, "output": ["JZ", "ZJ"]}, {"input": {"input_string": "hpn"}, "output": ["hpn", "hnp", "phn", "pnh", "nhp", "nph"]}, {"input": {"input_string": "bnD"}, "output": ["bnD", "bDn", "nbD", "nDb", "Dbn", "Dnb"]}], "error_log": []}
{"context": "Given two sparse matrices represented as strings, where each matrix is described by its dimensions and a list of its non-zero elements, what is the resulting matrix when these two matrices are multiplied together? The matrices are represented in the format \"m n\\n x1 y1 value1\\n x2 y2 value2\\n ...\" where `m` and `n` are the dimensions of the matrix, and each subsequent line represents a non-zero element with its coordinates and value.\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix1_str` (str): A string representation of the first matrix in the format \"m n\\n x1 y1 value1\\n x2 y2 value2\\n ...\" where `m` and `n` are the dimensions of the matrix, and each subsequent line represents a non-zero element with its coordinates and value.\n  `matrix2_str` (str): A string representation of the second matrix in the same format as `matrix1_str`.\n\nOutput:\n  `return` (str): A string representation of the resulting matrix from the multiplication of `matrix1_str` and `matrix2_str`, in the same format as the input matrices.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef restore_matrix(matrix):\n    matrix_map = dict()\n    matrix = matrix.split(\"\\n\")\n    (m, n) = matrix[0].split(\" \")\n    for row in matrix[1:]:\n        (x, y, value) = row.split(\" \")\n        matrix_map[(int(x), int(y))] = float(value)\n    return (int(m), int(n), matrix_map)\n\ndef multiply(m1, m2):\n    if (m1[1] != m2[0]):\n        raise ValueError(\"Can't multiply: [{},{}] [{},{}]\".format(m1[0], m1[1], m2[0], m2[1]))\n    m_result = dict()\n    for i in range(1, m1[0]+1):\n        for j in range(1, m2[1]+1):\n            m_result[(i, j)] = 0\n            for k in range(1, m1[1]+1):\n                m_result[(i, j)] += float(m1[2].get((i, k), 0) * m2[2].get((k, j), 0))\n            if (m_result[(i, j)] == 0):\n                del m_result[(i, j)]\n    return (m1[0], m2[1], m_result)\n\n# main function\ndef main_solution(matrix1_str, matrix2_str):\n    # Convert JSON serializable inputs to original input variables\n    m1 = restore_matrix(matrix1_str)\n    m2 = restore_matrix(matrix2_str)\n    \n    # Perform the multiplication\n    m_result = multiply(m1, m2)\n    \n    # Convert the result to JSON serializable output\n    result_str = f\"{m_result[0]} {m_result[1]}\\n\"\n    for key, value in m_result[2].items():\n        result_str += f\"{key[0]} {key[1]} {value}\\n\"\n    \n    return result_str.strip()", "input_generator": "import random\n\ndef input_generator():\n    # Randomly decide the dimensions of the matrices\n    m = random.randint(1, 5)\n    n = random.randint(1, 5)\n    p = random.randint(1, 5)\n    \n    # Generate sparse matrix 1 (m x n)\n    matrix1_map = {}\n    num_non_zero1 = random.randint(1, min(m * n, 5))\n    for _ in range(num_non_zero1):\n        x = random.randint(1, m)\n        y = random.randint(1, n)\n        value = round(random.uniform(-10, 10), 2)\n        matrix1_map[(x, y)] = value\n    matrix1_str = f\"{m} {n}\\n\" + \"\\n\".join([f\"{k[0]} {k[1]} {v}\" for k, v in matrix1_map.items()])\n    \n    # Generate sparse matrix 2 (n x p)\n    matrix2_map = {}\n    num_non_zero2 = random.randint(1, min(n * p, 5))\n    for _ in range(num_non_zero2):\n        x = random.randint(1, n)\n        y = random.randint(1, p)\n        value = round(random.uniform(-10, 10), 2)\n        matrix2_map[(x, y)] = value\n    matrix2_str = f\"{n} {p}\\n\" + \"\\n\".join([f\"{k[0]} {k[1]} {v}\" for k, v in matrix2_map.items()])\n    \n    return {\"matrix1_str\": matrix1_str, \"matrix2_str\": matrix2_str}", "io_pairs": [{"input": {"matrix1_str": "5 4\n2 2 -0.67", "matrix2_str": "4 5\n1 3 8.33\n2 3 0.93\n2 2 -9.81"}, "output": "5 5\n2 2 6.572700000000001\n2 3 -0.6231000000000001"}, {"input": {"matrix1_str": "4 2\n4 2 4.98", "matrix2_str": "2 2\n1 2 -5.08\n1 1 -5.67\n2 2 -3.24"}, "output": "4 2\n4 2 -16.1352"}, {"input": {"matrix1_str": "1 2\n1 1 6.3", "matrix2_str": "2 2\n1 1 -1.28\n2 2 4.64"}, "output": "1 2\n1 1 -8.064"}, {"input": {"matrix1_str": "4 5\n2 5 -4.76\n4 1 4.08\n1 4 6.4\n4 4 4.16", "matrix2_str": "5 2\n3 2 4.09\n1 1 -8.22\n3 1 9.57\n1 2 5.09"}, "output": "4 2\n4 1 -33.537600000000005\n4 2 20.7672"}, {"input": {"matrix1_str": "1 3\n1 2 -2.17\n1 3 -1.6", "matrix2_str": "3 5\n1 3 -0.09\n1 4 2.29"}, "output": "1 5"}, {"input": {"matrix1_str": "1 1\n1 1 7.48", "matrix2_str": "1 2\n1 1 -3.63"}, "output": "1 2\n1 1 -27.1524"}, {"input": {"matrix1_str": "5 5\n4 4 -6.06\n3 3 0.73", "matrix2_str": "5 4\n5 3 -8.7"}, "output": "5 4"}, {"input": {"matrix1_str": "2 3\n2 3 0.6\n2 1 8.48\n1 1 -9.75", "matrix2_str": "3 2\n1 2 -0.23"}, "output": "2 2\n1 2 2.2425\n2 2 -1.9504000000000001"}, {"input": {"matrix1_str": "2 2\n1 1 -8.29\n1 2 -6.81\n2 1 8.53", "matrix2_str": "2 3\n2 1 4.39"}, "output": "2 3\n1 1 -29.895899999999997"}, {"input": {"matrix1_str": "2 4\n2 3 -0.18\n1 4 0.37\n2 2 -9.12", "matrix2_str": "4 3\n2 2 3.44\n4 2 6.07\n3 1 -4.55\n2 1 5.37"}, "output": "2 3\n1 2 2.2459000000000002\n2 1 -48.15539999999999\n2 2 -31.372799999999998"}], "error_log": []}
{"context": "In a game of Mancala, a player can choose a pit on their side of the board to distribute pebbles from. Given a specific player and a pit index, what will be the final state of the board after the player's turn, and has the game ended in a win or a tie?\n\nThe input and output requirements are as follows:\n\nInput:\n  `player` (int): The player number, which can be either 0 or 1.\n  `pit` (int): The pit index from which the player will start distributing pebbles. This should be a valid pit index (0-13) that is not empty and belongs to the player.\n\nOutput:\n  `return` (dict): A dictionary containing the final state of the board and the result of the game.\n    - `board` (list): A list representing the final state of the Mancala board after the turn.\n    - `result` (bool or None): A boolean indicating whether the game ended in a win (True) or a tie (False), or None if the game has not ended.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\ndef new_board(): \n    board = []\n    start_pebble_count = 4\n    start_store_count = 0\n    for right_house in range(6):\n        board.append(start_pebble_count)\n    board.append(start_store_count) # Add player1 store at index 6\n    for left_house in range(6):\n        board.append(start_pebble_count)\n    board.append(start_store_count) # Add player0 store at index 13\n    return board\n\ndef get_available_moves(board, player):\n    if (player == 0): player_pits = [0, 1, 2, 10, 11, 12]\n    else: player_pits = [3, 4, 5, 7, 8, 9]\n    available_moves = []\n    for pit in player_pits: \n        # Check that pit is not currently empty\n        if (board[pit] != 0): \n            available_moves.append(pit)\n    return available_moves\n\ndef distr_pebbles(pit, board, player): \n    # Get pebbles in current pit and remove from curent pit\n    pebbles = board[pit]\n    board[pit] = 0\n    # Get next pit to start dropping pebbles in\n    next_pit = (pit + 1) % 14\n    while pebbles > 0:\n        pit = next_pit\n        if (pit == 6):\n            # This store belongs to current player, add a pebble to the store\n            if (player == 1): \n                board[pit] += 1 \n                pebbles -= 1\n            else: next_pit = (pit + 1) % 14 # Skip this store\n        elif (pit == 13): \n            if (player == 0): \n                board[pit] += 1\n                pebbles -= 1\n            else: next_pit = (pit + 1) % 14\n        else: # Next pit is a house \n            board[pit] += 1\n            pebbles -= 1\n        next_pit = (pit + 1) % 14\n    # Return the last pit to receive a pebble\n    return pit\n\ndef run_turn(pit, board, player):\n    new_board = board[:] # Deepcopy of board\n    next_pit = distr_pebbles(pit, new_board, player)\n    # If the last pit already has pebbles in it then pick up all pebbles from \n    # that pit and continue distributing\n    while ((new_board[next_pit] > 1) and (next_pit != 6) and (next_pit != 13)):\n        pebbles = new_board[next_pit]\n        next_pit = distr_pebbles(next_pit, new_board, player)\n    # If next pit doesn't have any pebbles in it or is one of the stores\n    return new_board\n\ndef is_end_match(board):\n    for pit in range(len(board)): \n        # If the pit is a store, ignore it\n        if ((pit == 6) or (pit == 13)): \n            continue\n        else: \n            house = board[pit]\n            if (house != 0): # Check if the house has pebbles in it\n                return False\n    return True\n\ndef is_win(board):\n    # Assume that end_match() is True\n    store0 = board[13]\n    store1 = board[6]\n    if (store1 > store0): \n        return True\n    elif (store0 > store1): \n        return True\n    else: \n        return False\n\n# main function\ndef main_solution(player, pit):\n    # Initialize the board\n    board = new_board()\n    \n    # Run the turn with the given pit and player\n    board = run_turn(pit, board, player)\n    \n    # Check if the match has ended\n    if is_end_match(board):\n        # Determine if the game ended in a win\n        result = is_win(board)\n    else:\n        result = None\n    \n    # Return the final board state and the result\n    return {\"board\": board, \"result\": result}", "input_generator": "import random\n\ndef input_generator():\n    player = random.randint(0, 1)\n    available_moves = get_available_moves(new_board(), player)\n    pit = random.choice(available_moves) if available_moves else 0\n    return {\"player\": player, \"pit\": pit}", "io_pairs": [{"input": {"player": 0, "pit": 0}, "output": {"board": [1, 4, 1, 10, 1, 1, 0, 9, 3, 0, 2, 9, 2, 5], "result": null}}, {"input": {"player": 1, "pit": 8}, "output": {"board": [7, 7, 1, 7, 0, 7, 3, 6, 0, 1, 0, 7, 2, 0], "result": null}}, {"input": {"player": 1, "pit": 9}, "output": {"board": [1, 1, 9, 3, 0, 2, 5, 2, 9, 1, 4, 1, 10, 0], "result": null}}, {"input": {"player": 1, "pit": 5}, "output": {"board": [5, 0, 5, 5, 5, 1, 2, 5, 5, 0, 5, 5, 5, 0], "result": null}}, {"input": {"player": 0, "pit": 11}, "output": {"board": [6, 1, 6, 6, 0, 6, 0, 1, 6, 6, 6, 0, 1, 3], "result": null}}, {"input": {"player": 1, "pit": 3}, "output": {"board": [9, 2, 9, 1, 4, 1, 6, 1, 1, 9, 3, 0, 2, 0], "result": null}}, {"input": {"player": 0, "pit": 10}, "output": {"board": [1, 1, 9, 3, 0, 2, 0, 9, 2, 9, 1, 4, 1, 6], "result": null}}, {"input": {"player": 1, "pit": 4}, "output": {"board": [1, 6, 6, 6, 0, 1, 3, 6, 1, 6, 6, 0, 6, 0], "result": null}}, {"input": {"player": 0, "pit": 2}, "output": {"board": [2, 9, 1, 4, 1, 10, 0, 1, 1, 9, 3, 0, 2, 5], "result": null}}, {"input": {"player": 0, "pit": 1}, "output": {"board": [6, 0, 1, 0, 7, 2, 0, 7, 7, 1, 7, 0, 7, 3], "result": null}}], "error_log": []}
{"context": "Given a list of heights above the Earth's surface, what are the corresponding gravitational accelerations at each height?\n\nThe input and output requirements are as follows:\n\nInput:\n  `heights` (list of float): A list of heights above the Earth's surface in meters. Each height should be a positive number.\n\nOutput:\n  `return` (list of float): A list of gravitational pulls corresponding to each height in the input list. Each gravitational pull is a float value representing the gravitational acceleration at that height.", "reference_code": "# import necessary packages\nimport numpy as np\nimport math\n\n# Constants\nG = 9.82\nR = 6.371 * 10 ** 6\n\n# Function to calculate gravitational pull\ndef gravitationalPull(x):\n    if x >= R:\n        g = G * R ** 2 / x ** 2\n    else:\n        g = G * x / R\n    return g\n\n# main function\ndef main_solution(heights):\n    # Convert the input list of heights to a numpy array\n    heights_array = np.array(heights)\n    \n    # Calculate gravitational pull for each height\n    gravitational_pulls = [gravitationalPull(height) for height in heights_array]\n    \n    # Return the list of gravitational pulls\n    return gravitational_pulls", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random number of heights between 1 and 20\n    num_heights = random.randint(1, 20)\n    \n    # Generate heights: some below R, some above, and some exactly R\n    heights = []\n    for _ in range(num_heights):\n        choice = random.random()\n        if choice < 0.4:\n            # Below R (0 to R)\n            heights.append(random.uniform(0, 6.371 * 10**6))\n        elif choice < 0.8:\n            # Above R (R to 2*R)\n            heights.append(random.uniform(6.371 * 10**6, 2 * 6.371 * 10**6))\n        else:\n            # Exactly R\n            heights.append(6.371 * 10**6)\n    \n    return {'heights': heights}", "io_pairs": [{"input": {"heights": [562229.739356481, 1348593.7657978546, 6371000.0, 8788940.752226913, 7841306.870431148, 6371000.0, 354372.5179180577, 9601007.814786905, 4641904.7067597015, 10416675.87794188, 9157161.3224101, 6483360.547266089, 6371000.0, 5062241.968482386, 1818384.8638364621, 9439630.832890192, 6371000.0, 11533999.107501497]}, "output": [0.8665980286423863, 2.0786675216033483, 9.82, 5.160046606764065, 6.48260854355842, 9.82, 0.5462153705784534, 4.3240733422205215, 7.154842916399351, 3.673401474246353, 4.753406628410379, 9.482576393561459, 9.82, 7.802733657274688, 2.802784392226347, 4.473183122864994, 9.82, 2.996172896218977]}, {"input": {"heights": [3068238.9085842893, 10300037.851076556, 3238788.891790043, 1280383.0413744817, 6371000.0, 5337630.302711586, 6371000.0, 2498866.2817310127, 12279496.36904176, 1837238.6914271691, 1784582.6826745362, 6371000.0, 7204807.222408956, 531213.3707875323, 3875482.461534779, 6371000.0, 10689217.600598961, 1052616.1489827503, 3794338.3973948383]}, "output": [4.72925852806431, 3.7570680093109527, 4.992137328108338, 1.9735302882275012, 9.82, 8.227206023014874, 9.82, 3.8516507434623364, 2.643416447612698, 2.83184491442706, 2.750683086464283, 9.82, 7.678598646584325, 0.8187906609847069, 5.973510873060984, 9.82, 3.4884689497084422, 1.6224596739931891, 5.848438716436559]}, {"input": {"heights": [12262731.048295116, 9459672.591887088, 6371000.0, 5119988.231132048, 6371000.0, 5784635.924747692, 9577041.414184527, 5966282.918465093, 10433302.701944342, 5863247.045330408, 10408918.53619247, 10002044.739050305, 3787213.0400877087]}, "output": [2.650649423614179, 4.454248960367529, 9.82, 7.891741395340875, 9.82, 8.91620228865521, 4.34574227708503, 9.196185568878859, 3.6617027179700226, 9.037370269211209, 3.678878786593186, 3.9842732198112927, 5.837455980797567]}, {"input": {"heights": [11756718.793575473, 11225084.034605745, 5132909.680647212, 3294899.3309448776, 4351386.538590319, 326716.0892404422, 6371000.0, 11252324.272317681, 8047568.261199988, 3738723.9111053185, 1826869.0403914277, 8593730.154440576, 3451093.794962486, 6278679.876832005, 11385366.49413592, 1403360.0423252904]}, "output": [2.883728946842294, 3.1633518221928654, 7.911657991517129, 5.078623674443368, 6.707050040646199, 0.5035868774668251, 9.82, 3.148054333343324, 6.154564956070139, 5.762716811655035, 2.815861556528617, 5.397134893619059, 5.3193754617064215, 9.67770152103128, 3.0749118331774508, 2.163082030393086]}, {"input": {"heights": [4009727.717635831, 6995360.65348056, 400996.2606140516, 6024147.281440017, 3340268.0162330223, 3647047.356526981, 1581390.97873782, 11076464.070865024, 1213690.3705802322, 1092368.1867644473, 10141264.633156601, 9965312.020789038, 11251564.872845963, 1879543.350643947, 4947357.681765864, 11440414.965955827, 6862275.690852705, 1714269.3792974409]}, "output": [6.180431044919771, 8.145288627240463, 0.6180793092497233, 9.285375341977863, 5.148553118726775, 5.621410303107041, 2.4374916671174685, 3.2488107367402588, 1.8707329209069035, 1.6837318464961344, 3.875631407159283, 4.013699878709675, 3.1484792896049405, 2.8970515936781607, 7.625655695328957, 3.04539158291347, 8.464286878136486, 2.642305023497233]}, {"input": {"heights": [6371000.0, 8790138.82079348, 8321380.506805016, 9061207.031732444, 8854463.967970712, 6371000.0, 6371000.0, 6371000.0, 3878854.2180694803, 8314972.72907583, 7524180.183075, 8443719.835097997, 6371000.0, 4646245.32644555, 6970176.454997525, 9511144.9683481, 6426684.0619413555]}, "output": [9.82, 5.158640106032321, 5.756200800842089, 4.854612739905792, 5.0839602701398805, 9.82, 9.82, 9.82, 5.9787079613, 5.76507603559158, 7.040578152810807, 5.590608342123756, 9.82, 7.161533370851561, 8.204255040154017, 4.40616844077609, 9.650566266992296]}, {"input": {"heights": [6071660.020265048, 6371000.0]}, "output": [9.358609543086294, 9.82]}, {"input": {"heights": [6371000.0, 6371000.0, 5852346.087791382, 6539428.300905426, 7365380.086751068, 6371000.0, 7443894.056648478, 6371000.0, 3377037.75575388, 11114688.03345982, 12095320.627000596, 6953679.775739015]}, "output": [9.82, 9.82, 9.020567977101141, 9.320670021815465, 7.347445465833023, 9.82, 7.193269487086492, 9.82, 5.205228498116952, 3.226503518587274, 2.72453208952991, 8.24322821979467]}, {"input": {"heights": [9109222.202428408, 6371000.0, 4177841.1290372475, 6586227.94198846, 10452261.627573859, 3425366.3125719647, 10011673.8064926, 700095.3000159329, 4494804.728748785]}, "output": [4.803569802038493, 9.82, 6.439554212391426, 9.188681195429831, 3.648431142654481, 5.279720167863239, 3.976612885097792, 1.0790983905441, 6.9281089995782565]}, {"input": {"heights": [6371000.0, 6371000.0, 10689762.51559373, 1410339.6250544633, 6588910.049984601, 883722.8901364037, 9802140.497554721, 3904702.044901341, 5607971.594005217, 10449073.868059127, 10794721.000946116]}, "output": [9.82, 9.82, 3.4881133065242933, 2.173840075032935, 9.181201955595574, 1.362134481421988, 4.148440368328474, 6.01854874916515, 8.643899082268282, 3.650657578279388, 3.4206123056589535]}], "error_log": []}
{"context": "Given an undirected graph with a set of vertices and edges, determine whether the graph has an Euler Circuit or an Euler Trail. What is the result of the analysis for the given vertices and edges?\n\nThe input and output requirements are as follows:\n\nInput:\n  `vertices` (list of str): A list of vertex names in the graph.\n  `edges` (list of tuples): A list of tuples representing edges between vertices. Each tuple contains two vertex names.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `has_euler_circuit` (bool): True if the graph has an Euler Circuit, False otherwise.\n    - `has_euler_trail` (bool): True if the graph has an Euler Trail, False otherwise.\n    - `reason` (str or bool): A string explaining why the graph does not have an Euler Circuit or Trail, or True if the graph has one of them.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass UserInterface:\n    def display_vertices(self, vertices):\n        pass\n\n    def display_edges(self, edges):\n        pass\n\n    def display_degree(self, vertex, degree):\n        pass\n\n    def display_facts(self):\n        pass\n\n    def result(self, reason, type):\n        pass\n\n    def get_input_type(self):\n        return '1'\n\n    def get_vertex(self):\n        return []\n\n    def get_edges(self):\n        return []\n\n    def intro(self):\n        pass\n\nclass Euler_CT:\n    def __init__(self):\n        self.vertices = []\n        self.edges = {}\n        self.UI = UserInterface()\n        self.reason = None\n\n    def create_vertex(self, v):\n        if v != \"\":\n            self.vertices.append(v)\n\n    def _create_dict(self):\n        for i in self.vertices:\n            self.edges[i] = []\n\n    def create_edge(self, v1, v2):\n        if len(self.edges) == 0:\n            self._create_dict()\n        if v1 in self.vertices and v2 in self.vertices:\n            for i in self.edges:\n                if i == v1 and v2 not in self.edges[i]:\n                    self.edges[i].append(v2)\n                    self.edges[v2].append(i)\n                    return True\n\n    def get_degree(self, v):\n        if v in self.edges:\n            return len(self.edges[v])\n\n    def has_circuit(self):\n        for i in self.edges:\n            if (self.get_degree(i) == 0) or (self.get_degree(i) % 2 != 0):\n                self.reason = \"The graph does not have an Euler Circuit, deg(\" + i + \") is odd or 0.\"\n                return False\n        if len(self.vertices) == 0:\n            self.reason = \"The graph does not have an Euler Circuit, no vertices or edges found.\"\n            return False\n        else:\n            self.reason = True\n            return True\n\n    def has_trail(self):\n        odd = 0\n        for i in self.edges:\n            if (self.get_degree(i) % 2 != 0):\n                odd += 1\n        if odd == 2:\n            self.reason = True\n            return True\n        else:\n            self.reason = \"The graph does not have an Euler trail. Must be exactly 2 vertices with odd degree.\"\n            return False\n\n# main function\ndef main_solution(vertices, edges):\n    \"\"\"\n    This function determines whether a given undirected graph has an Euler Circuit or an Euler Trail.\n    \"\"\"\n    euler = Euler_CT()\n    \n    # Create vertices\n    for v in vertices:\n        euler.create_vertex(v)\n    \n    # Create edges\n    for edge in edges:\n        euler.create_edge(edge[0], edge[1])\n    \n    # Check for Euler Circuit\n    circuit = euler.has_circuit()\n    \n    # Check for Euler Trail\n    trail = euler.has_trail()\n    \n    # Return the results\n    return {\n        \"has_euler_circuit\": circuit,\n        \"has_euler_trail\": trail,\n        \"reason\": euler.reason\n    }", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Randomly decide the number of vertices (between 3 and 10)\n    num_vertices = random.randint(3, 10)\n    vertices = list(string.ascii_uppercase[:num_vertices])\n    \n    # Generate edges: ensure the graph is connected and has some randomness\n    edges = []\n    # First create a simple path to ensure connectivity\n    for i in range(num_vertices - 1):\n        edges.append((vertices[i], vertices[i+1]))\n    \n    # Add some random edges\n    max_extra_edges = random.randint(1, num_vertices * 2)\n    for _ in range(max_extra_edges):\n        v1 = random.choice(vertices)\n        v2 = random.choice(vertices)\n        if v1 != v2 and (v1, v2) not in edges and (v2, v1) not in edges:\n            edges.append((v1, v2))\n    \n    return {\n        \"vertices\": vertices,\n        \"edges\": edges\n    }", "io_pairs": [{"input": {"vertices": ["A", "B", "C", "D"], "edges": [["A", "B"], ["B", "C"], ["C", "D"], ["D", "A"]]}, "output": {"has_euler_circuit": true, "has_euler_trail": false, "reason": "The graph does not have an Euler trail. Must be exactly 2 vertices with odd degree."}}, {"input": {"vertices": ["A", "B", "C"], "edges": [["A", "B"], ["B", "C"]]}, "output": {"has_euler_circuit": false, "has_euler_trail": true, "reason": true}}, {"input": {"vertices": ["A", "B", "C"], "edges": [["A", "B"], ["B", "C"], ["C", "A"]]}, "output": {"has_euler_circuit": true, "has_euler_trail": false, "reason": "The graph does not have an Euler trail. Must be exactly 2 vertices with odd degree."}}, {"input": {"vertices": ["A", "B", "C", "D"], "edges": [["A", "B"], ["B", "C"], ["C", "D"], ["C", "A"], ["D", "B"]]}, "output": {"has_euler_circuit": false, "has_euler_trail": true, "reason": true}}, {"input": {"vertices": ["A", "B", "C", "D"], "edges": [["A", "B"], ["B", "C"], ["C", "D"], ["D", "B"]]}, "output": {"has_euler_circuit": false, "has_euler_trail": true, "reason": true}}, {"input": {"vertices": ["A", "B", "C", "D"], "edges": [["A", "B"], ["B", "C"], ["C", "D"], ["A", "C"], ["D", "A"]]}, "output": {"has_euler_circuit": false, "has_euler_trail": true, "reason": true}}, {"input": {"vertices": ["A", "B", "C"], "edges": [["A", "B"], ["B", "C"], ["A", "C"]]}, "output": {"has_euler_circuit": true, "has_euler_trail": false, "reason": "The graph does not have an Euler trail. Must be exactly 2 vertices with odd degree."}}, {"input": {"vertices": ["A", "B", "C", "D"], "edges": [["A", "B"], ["B", "C"], ["C", "D"], ["A", "D"], ["C", "A"]]}, "output": {"has_euler_circuit": false, "has_euler_trail": true, "reason": true}}, {"input": {"vertices": ["A", "B", "C", "D"], "edges": [["A", "B"], ["B", "C"], ["C", "D"], ["D", "A"], ["C", "A"]]}, "output": {"has_euler_circuit": false, "has_euler_trail": true, "reason": true}}, {"input": {"vertices": ["A", "B", "C", "D"], "edges": [["A", "B"], ["B", "C"], ["C", "D"], ["A", "C"]]}, "output": {"has_euler_circuit": false, "has_euler_trail": true, "reason": true}}], "error_log": []}
{"context": "Given an encrypted message where each character's ASCII value has been XORed with a secret key, and knowing that the key consists of exactly three lowercase characters, what is the sum of the ASCII values of the characters in the original, decrypted message?\n\nThe input and output requirements are as follows:\n\nInput:\n  `cipher_text` (list of int): A list of integers representing the encrypted ASCII codes of the message.\n  `key` (str): A string of three lowercase characters representing the encryption key.\n\nOutput:\n  `return` (int): The sum of the ASCII values of the characters in the decrypted message.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef d2b(n):\n    res = bin(n)[2:]\n    while(8 > len(res)):\n        res = '0' + res\n    return res\n    \ndef xor(a, b):\n    if(a > b):\n        return xor(b, a)\n    else:\n        res = ''\n        xa = d2b(a)\n        xb = d2b(b)\n        d = len(xb) - len(xa)\n        res = xb[:d]\n        xb = xb[d:]\n        i = 0\n        while(i < len(xa)):\n            if(xa[i] != xb[i]):\n                res = res + '1'\n            else:\n                res = res + '0'\n            i = i + 1\n        return res\n\ndef b2d(x):\n    res = 0\n    b = 1\n    i = len(x) - 1\n    while(0 <= i):\n        res = res + int(x[i]) * b\n        i = i - 1\n        b = b * 2\n    return res\n\n# main function\ndef main_solution(cipher_text, key):\n    # Convert key to binary representation\n    key_bin = ''.join(d2b(ord(char)) for char in key)\n    \n    # Decrypt the cipher text\n    decrypted_text = []\n    for i, char_code in enumerate(cipher_text):\n        decrypted_char = int(char_code) ^ int(key_bin[i % len(key_bin)], 2)\n        decrypted_text.append(decrypted_char)\n    \n    # Calculate the sum of ASCII values in the original text\n    ascii_sum = sum(decrypted_text)\n    \n    return ascii_sum", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random key of length between 1 and 10\n    key_length = random.randint(1, 10)\n    key = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(key_length))\n    \n    # Generate cipher_text as a list of integers (0-255) with length between 5 and 50\n    cipher_length = random.randint(5, 50)\n    cipher_text = [random.randint(0, 255) for _ in range(cipher_length)]\n    \n    return {'cipher_text': cipher_text, 'key': key}", "io_pairs": [{"input": {"cipher_text": [242, 145, 224, 9, 192, 241, 129], "key": "ZTTFFq"}, "output": 1180}, {"input": {"cipher_text": [166, 221, 148, 161, 173, 194, 233], "key": "21Z4OVk"}, "output": 1295}, {"input": {"cipher_text": [117, 81, 152, 19, 77, 154, 217, 41, 248, 32], "key": "PqZoWr"}, "output": 1137}, {"input": {"cipher_text": [191, 14, 134, 17, 96], "key": "ZzlDMX"}, "output": 453}, {"input": {"cipher_text": [224, 169, 61, 28, 139, 183, 15, 50, 102, 230], "key": "WPzT"}, "output": 1201}, {"input": {"cipher_text": [252, 196, 214, 68, 73], "key": "WtTkiCvE"}, "output": 805}, {"input": {"cipher_text": [211, 160, 96, 40, 152, 185, 150, 245, 128, 208], "key": "mKyJbVY"}, "output": 1577}, {"input": {"cipher_text": [184, 188, 47, 203, 172, 18, 62, 121, 168, 195, 36], "key": "q8ymSM"}, "output": 1393}, {"input": {"cipher_text": [247, 97, 160, 166, 111, 91, 223, 114], "key": "myZJ"}, "output": 1208}, {"input": {"cipher_text": [21, 238, 35, 187, 251, 185, 126, 111, 189], "key": "T2h"}, "output": 1342}], "error_log": []}
{"context": "Given a beta distribution with parameters \\(\\alpha\\) and \\(\\beta\\), what is the probability or statistical measure (mode, mean, variance) of the distribution based on the specified type of calculation?\n\nThe input and output requirements are as follows:\n\nInput:\n- `alpha` (float): The alpha parameter of the beta distribution.\n- `beta` (float): The beta parameter of the beta distribution.\n- `x1` (float): The first boundary value for probability calculations.\n- `x2` (float): The second boundary value for probability calculations (only used when `ty` is 3).\n- `ty` (int): The type of calculation to perform:\n  - 1: Probability that x is less than `x1`.\n  - 2: Probability that x is greater than `x1`.\n  - 3: Probability that x is between `x1` and `x2`.\n  - 6: Mode of the beta distribution.\n  - 7: Mean and variance of the beta distribution.\n\nOutput:\n- `return` (float or dictionary): \n  - If `ty` is 1, 2, or 3, returns a float representing the probability.\n  - If `ty` is 6, returns a float representing the mode.\n  - If `ty` is 7, returns a dictionary with keys `mean` and `variance`, each containing a float representing the mean and variance of the beta distribution, respectively.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# main function\ndef main_solution(alpha, beta, x1, x2, ty):\n    # Convert JSON serializable inputs to the original input variables\n    alpha = float(alpha)\n    beta = float(beta)\n    x1 = float(x1)\n    x2 = float(x2)\n    ty = int(ty)\n\n    if ty == 1:\n        result = round(math.gamma(alpha + beta) / (math.gamma(alpha) * math.gamma(beta)), 4) * integrate_beta_distribution(alpha, beta, 0, x1)\n    elif ty == 2:\n        result = round(math.gamma(alpha + beta) / (math.gamma(alpha) * math.gamma(beta)), 4) * integrate_beta_distribution(alpha, beta, x1, 1)\n    elif ty == 3:\n        result = round(math.gamma(alpha + beta) / (math.gamma(alpha) * math.gamma(beta)), 4) * integrate_beta_distribution(alpha, beta, x1, x2)\n    elif ty == 6:\n        result = round((alpha - 1) / (alpha + beta - 2), 4)\n    elif ty == 7:\n        mean = round(alpha / (alpha + beta), 4)\n        variance = round((alpha * beta) / (((alpha + beta) ** 2) * (alpha + beta + 1)), 4)\n        result = {\"mean\": mean, \"variance\": variance}\n    else:\n        result = None\n\n    # Convert the result to JSON serializable output\n    if isinstance(result, float):\n        result = round(result, 4)\n\n    return result\n\ndef integrate_beta_distribution(alpha, beta, a, b):\n    # Placeholder for integration function (not implemented here)\n    # This function should compute the integral of the beta distribution from a to b\n    # For simplicity, we assume it returns a constant value here\n    return 0.5  # Example value", "input_generator": "import random\nimport math\n\ndef input_generator():\n    alpha = random.uniform(0.1, 10.0)\n    beta = random.uniform(0.1, 10.0)\n    x1 = random.uniform(0.0, 1.0)\n    x2 = random.uniform(0.0, 1.0)\n    ty = random.choice([1, 2, 3, 6, 7])\n    \n    # Ensure x2 > x1 when ty is 3\n    if ty == 3 and x2 <= x1:\n        x2 = random.uniform(x1, 1.0)\n    \n    return {\n        'alpha': alpha,\n        'beta': beta,\n        'x1': x1,\n        'x2': x2,\n        'ty': ty\n    }", "io_pairs": [{"input": {"alpha": 3.5065808588418603, "beta": 8.335091749717023, "x1": 0.8605294450970303, "x2": 0.5554054844447545, "ty": 2}, "output": 406.3934}, {"input": {"alpha": 6.666979031795988, "beta": 8.48391535950124, "x1": 0.2537262299064871, "x2": 0.6895467586228878, "ty": 6}, "output": 0.4309}, {"input": {"alpha": 9.406445323118866, "beta": 7.045612854275215, "x1": 0.056087062244864816, "x2": 0.6222903089306666, "ty": 6}, "output": 0.5817}, {"input": {"alpha": 7.837630170936865, "beta": 2.5419713566112323, "x1": 0.2953325288284532, "x2": 0.3554716191038684, "ty": 1}, "output": 86.1985}, {"input": {"alpha": 9.787452241085484, "beta": 5.954961643417115, "x1": 0.35315763805861144, "x2": 0.838280782295673, "ty": 3}, "output": 12910.2576}, {"input": {"alpha": 9.76558594670871, "beta": 4.995444531136736, "x1": 0.9612602769923286, "x2": 0.973872330648109, "ty": 6}, "output": 0.6869}, {"input": {"alpha": 6.991473900048678, "beta": 3.80338974816988, "x1": 0.6052683202063383, "x2": 0.11579792433121705, "ty": 2}, "output": 336.0224}, {"input": {"alpha": 0.1905993610172638, "beta": 9.24304543610487, "x1": 0.6898491876458557, "x2": 0.6106139174785528, "ty": 1}, "output": 0.1568}, {"input": {"alpha": 5.842931583665822, "beta": 2.9310296512568494, "x1": 0.39155084466496215, "x2": 0.8691591746446802, "ty": 7}, "output": {"mean": 0.6659, "variance": 0.0228}}, {"input": {"alpha": 7.845817084460401, "beta": 3.2744936643010734, "x1": 0.1451671458261139, "x2": 0.10760070876004069, "ty": 1}, "output": 249.1602}], "error_log": []}
{"context": "Given the coordinates of two locations on Earth, what is the distance between them in kilometers? The coordinates are provided in degrees for both longitude and latitude.\n\nThe input and output requirements are as follows:\n\nInput:\n  `lon1` (float): Longitude of the first location in degrees.\n  `lat1` (float): Latitude of the first location in degrees.\n  `lon2` (float): Longitude of the second location in degrees.\n  `lat2` (float): Latitude of the second location in degrees.\n\nOutput:\n  `return` (float): The Haversine distance between the two locations in kilometers.", "reference_code": "# import necessary packages\nfrom math import radians, cos, sin, asin, sqrt\n\n# main function\ndef main_solution(lon1, lat1, lon2, lat2):\n    # Convert input arguments to float\n    lon1, lat1, lon2, lat2 = map(float, [lon1, lat1, lon2, lat2])\n    \n    # Calculate the Haversine distance\n    dlon = abs(lon2 - lon1)\n    dlat = abs(lat2 - lat1)\n    a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2\n    c = 2 * asin(sqrt(a))\n    r = 6371  # Radius of Earth in kilometers\n    \n    # Calculate the distance\n    distance = c * r\n    \n    # Return the distance as a float\n    return distance", "input_generator": "import random\n\ndef input_generator():\n    # Generate random latitudes and longitudes within valid ranges\n    lat1 = random.uniform(-90, 90)\n    lon1 = random.uniform(-180, 180)\n    lat2 = random.uniform(-90, 90)\n    lon2 = random.uniform(-180, 180)\n    \n    return {\n        'lon1': lon1,\n        'lat1': lat1,\n        'lon2': lon2,\n        'lat2': lat2\n    }", "io_pairs": [{"input": {"lon1": 40.086567533140396, "lat1": -57.471291336755364, "lon2": 145.1015919479209, "lat2": 9.595772048634274}, "output": 8263.684748576412}, {"input": {"lon1": -109.63766169271709, "lat1": 53.41182828339856, "lon2": 25.45453815531812, "lat2": -61.69403669570263}, "output": 7279.330878310339}, {"input": {"lon1": 135.42957546400584, "lat1": 83.35820596633897, "lon2": -94.4373622756463, "lat2": -53.867467396381976}, "output": 7660.92520161126}, {"input": {"lon1": 131.3223765332279, "lat1": -73.99350168992433, "lon2": 119.41389150657142, "lat2": -87.53494942902799}, "output": 6450.6729611848705}, {"input": {"lon1": -34.243466319548844, "lat1": 34.44526365894819, "lon2": 30.90054685943298, "lat2": -63.51122530258462}, "output": 7021.87824478778}, {"input": {"lon1": -32.15343092296757, "lat1": 37.886553306961744, "lon2": 98.82302063604243, "lat2": 67.11249057731885}, "output": 12639.813507674131}, {"input": {"lon1": 43.769433410427524, "lat1": -19.940811109139872, "lon2": -51.66184911601772, "lat2": 82.09011223705792}, "output": 11242.915626122282}, {"input": {"lon1": -12.197334729627158, "lat1": 68.90424988839032, "lon2": -52.18751047763348, "lat2": 71.66947103964756}, "output": 7238.697785512843}, {"input": {"lon1": 52.77935215714973, "lat1": -59.996877570839274, "lon2": 36.064145365232775, "lat2": 55.20908350624134}, "output": 11141.819628636316}, {"input": {"lon1": -107.63144121113702, "lat1": -63.00003649800879, "lon2": -19.948480498491534, "lat2": 4.966260353805637}, "output": 7386.599102278078}], "error_log": []}
{"context": "Given a range of two-digit numerators and denominators, identify the four non-trivial fractions that can be incorrectly simplified by canceling out a common digit. What is the simplified form of the product of these four fractions in its lowest common terms?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numerator_range` (list of int): A list containing two integers representing the range of numerators (inclusive).\n  `denominator_range` (list of int): A list containing two integers representing the range of denominators (inclusive).\n\nOutput:\n  `return` (str): A string representing the simplified fraction in the form \"numerator/denominator\".", "reference_code": "# import necessary packages\nfrom fractions import Fraction\n\n# main function\ndef main_solution(numerator_range, denominator_range):\n    # Convert JSON serializable inputs to original input variables\n    numerator = [i for i in range(numerator_range[0], numerator_range[1] + 1)]\n    denominator = [k for k in range(denominator_range[0], denominator_range[1] + 1)]\n    \n    four_nums = []\n    four_denoms = []\n    \n    def incorrect_cancel(num, denom):\n        num_digits = [i for i in str(num)]\n        denom_digits = [k for k in str(denom)]\n        for digit in num_digits:\n            if digit in denom_digits:\n                num_digits.remove(digit)\n                denom_digits.remove(digit)\n            if len(num_digits) == 1:\n                fraction = num_digits + denom_digits\n            else:\n                fraction = [1,1]\n        if int(fraction[1]) != 0:\n            value = int(fraction[0]) / int(fraction[1])\n            if value == (num / denom) and denom % 10 != 0:\n                four_nums.append(int(fraction[0]))\n                four_denoms.append(int(fraction[1]))\n    \n    for i in numerator:\n        for k in denominator:\n            if i / k < 1:\n                incorrect_cancel(i, k)\n    \n    final_num = 1\n    final_denom = 1\n    \n    for j in four_nums:\n        final_num = final_num * j\n    \n    for j in four_denoms:\n        final_denom = final_denom * j\n    \n    # Convert the final output to JSON serializable format\n    result = str(Fraction(final_num / final_denom).limit_denominator(10000))\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate reasonable ranges for numerators and denominators\n    # Ensure the ranges are not too large to keep the input size small\n    numerator_start = random.randint(10, 50)\n    numerator_end = numerator_start + random.randint(5, 20)\n    \n    denominator_start = random.randint(numerator_start + 1, numerator_end + 10)\n    denominator_end = denominator_start + random.randint(5, 20)\n    \n    return {\n        'numerator_range': [numerator_start, numerator_end],\n        'denominator_range': [denominator_start, denominator_end]\n    }", "io_pairs": [{"input": {"numerator_range": [45, 59], "denominator_range": [47, 60]}, "output": "1"}, {"input": {"numerator_range": [12, 27], "denominator_range": [23, 35]}, "output": "1"}, {"input": {"numerator_range": [24, 32], "denominator_range": [37, 48]}, "output": "1"}, {"input": {"numerator_range": [18, 24], "denominator_range": [32, 39]}, "output": "1"}, {"input": {"numerator_range": [47, 65], "denominator_range": [71, 89]}, "output": "1"}, {"input": {"numerator_range": [33, 43], "denominator_range": [36, 50]}, "output": "1"}, {"input": {"numerator_range": [43, 58], "denominator_range": [53, 72]}, "output": "1"}, {"input": {"numerator_range": [19, 29], "denominator_range": [37, 53]}, "output": "1"}, {"input": {"numerator_range": [35, 44], "denominator_range": [43, 52]}, "output": "1"}, {"input": {"numerator_range": [22, 41], "denominator_range": [47, 65]}, "output": "2/5"}], "error_log": []}
{"context": "In a game of Tic Tac Toe, given a specific board state, what is the optimal move for the current player to make? The board is represented by a 3x3 grid where each cell can be either `\"X\"`, `\"O\"`, or empty (`None`). The goal is to determine the best move that maximizes the chances of winning or at least securing a draw.\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists of strings/None): A 3x3 grid representing the Tic Tac Toe board. Each cell can be `\"X\"`, `\"O\"`, or `None` (empty).\n\nOutput:\n  `return` (tuple of integers or None): A tuple `(i, j)` representing the optimal move for the current player on the board. If the game is over, returns `None`.", "reference_code": "# import necessary packages\nimport copy\nimport random\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    x_count = sum(row.count(X) for row in board)\n    o_count = sum(row.count(O) for row in board)\n    return O if x_count > o_count else X\n\n# Function to get all possible actions\ndef actions(board):\n    return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}\n\n# Function to get the result of an action\ndef result(board, action):\n    new_board = copy.deepcopy(board)\n    new_board[action[0]][action[1]] = player(board)\n    return new_board\n\n# Function to determine the winner\ndef winner(board):\n    lines = [\n        [(0, 0), (0, 1), (0, 2)],\n        [(1, 0), (1, 1), (1, 2)],\n        [(2, 0), (2, 1), (2, 2)],\n        [(0, 0), (1, 0), (2, 0)],\n        [(0, 1), (1, 1), (2, 1)],\n        [(0, 2), (1, 2), (2, 2)],\n        [(0, 0), (1, 1), (2, 2)],\n        [(0, 2), (1, 1), (2, 0)],\n    ]\n    for line in lines:\n        if board[line[0][0]][line[0][1]] == board[line[1][0]][line[1][1]] == board[line[2][0]][line[2][1]] != EMPTY:\n            return board[line[0][0]][line[0][1]]\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or all(all(cell is not EMPTY for cell in row) for row in board)\n\n# Function to get the utility of the board\ndef utility(board):\n    win = winner(board)\n    if win == X:\n        return 1\n    elif win == O:\n        return -1\n    else:\n        return 0\n\n# Minimax functions\ndef max_value(board):\n    if terminal(board):\n        return utility(board)\n    v = -2\n    for action in actions(board):\n        v = max(v, min_value(result(board, action)))\n    return v\n\ndef min_value(board):\n    if terminal(board):\n        return utility(board)\n    v = 2\n    for action in actions(board):\n        v = min(v, max_value(result(board, action)))\n    return v\n\n# Main function\ndef main_solution(board):\n    \"\"\"\n    Returns the optimal action for the current player on the board.\n    \"\"\"\n    if terminal(board):\n        return None\n    if player(board) == X:\n        best_move = None\n        best_value = -2\n        for action in actions(board):\n            move_value = min_value(result(board, action))\n            if move_value > best_value:\n                best_value = move_value\n                best_move = action\n        return best_move\n    else:\n        best_move = None\n        best_value = 2\n        for action in actions(board):\n            move_value = max_value(result(board, action))\n            if move_value < best_value:\n                best_value = move_value\n                best_move = action\n        return best_move", "input_generator": "import random\n\ndef input_generator():\n    board = [[None for _ in range(3)] for _ in range(3)]\n    symbols = ['X', 'O', None]\n    for i in range(3):\n        for j in range(3):\n            board[i][j] = random.choice(symbols)\n    \n    # Ensure the board is not terminal\n    def is_terminal(board):\n        # Check rows\n        for row in board:\n            if row[0] == row[1] == row[2] and row[0] is not None:\n                return True\n        # Check columns\n        for col in range(3):\n            if board[0][col] == board[1][col] == board[2][col] and board[0][col] is not None:\n                return True\n        # Check diagonals\n        if board[0][0] == board[1][1] == board[2][2] and board[0][0] is not None:\n            return True\n        if board[0][2] == board[1][1] == board[2][0] and board[0][2] is not None:\n            return True\n        # Check if board is full\n        if all(cell is not None for row in board for cell in row):\n            return True\n        return False\n    \n    while is_terminal(board):\n        board = [[None for _ in range(3)] for _ in range(3)]\n        for i in range(3):\n            for j in range(3):\n                board[i][j] = random.choice(symbols)\n    \n    return {'board': board}", "io_pairs": [{"input": {"board": [["O", "X", null], ["O", null, "O"], ["X", null, null]]}, "output": [1, 1]}, {"input": {"board": [["X", "X", "O"], ["O", "X", "O"], ["O", "O", null]]}, "output": [2, 2]}, {"input": {"board": [["O", null, null], [null, null, "O"], [null, null, "X"]]}, "output": [2, 1]}, {"input": {"board": [[null, "X", "O"], ["X", null, "O"], [null, null, null]]}, "output": [2, 2]}, {"input": {"board": [[null, "O", null], [null, "O", "O"], ["O", "X", "O"]]}, "output": [1, 0]}, {"input": {"board": [[null, "X", "O"], ["O", null, null], ["O", null, "X"]]}, "output": [1, 1]}, {"input": {"board": [[null, "O", "X"], ["O", "X", null], [null, "O", null]]}, "output": [2, 2]}, {"input": {"board": [["X", null, "X"], ["X", null, null], [null, "X", null]]}, "output": [0, 1]}, {"input": {"board": [[null, "X", "O"], [null, null, null], [null, "X", null]]}, "output": [1, 1]}, {"input": {"board": [["X", "X", "O"], ["X", "O", "X"], [null, "X", null]]}, "output": [2, 0]}], "error_log": []}
{"context": "Given a system that uses universal hashing to map keys to hash values, what is the resulting hash value for a specific key when using a hash matrix with a specified number of rows?\n\nThe input and output requirements are as follows:\n\nInput:\n  `b` (int): The number of rows in the hash matrix, which determines the number of hash functions.\n  `key` (int): The integer key to be hashed.\n\nOutput:\n  `return` (dict): A dictionary containing the hash value of the key. The dictionary has a single key `\"hash_value\"` with an integer value representing the hash value.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass UniversalHashing:\n    __u = 32\n\n    # Constructor\n    def __init__(self, b):\n        self.__b = b\n        self.hash = [[0 for x in range(self.__u)] for y in range(self.__b)]\n\n    # Generate random matrix of zeros and ones to use it in hashing process\n    def build_hash_function(self):\n        for i in range(self.__b):\n            for j in range(self.__u):\n                value = random.random()\n                self.hash[i][j] = True if (round(value) == 1) else False\n\n    # Calculate the hash value of key using the matrix method\n    def hash_value(self, key):\n        hash_value = 0\n        for i in range(self.__b):\n            temp = key\n            val = 0\n            for j in range(self.__u):\n                flag = True if (temp & 1) else False\n                x = self.hash[i][j] & flag\n                temp >>= 1\n                val ^= x\n            hash_value |= val\n            hash_value <<= 1\n        return hash_value\n\n# main function\ndef main_solution(b, key):\n    # Convert JSON serializable inputs to the original input variables\n    b = int(b)\n    key = int(key)\n    \n    # Create an instance of UniversalHashing\n    hasher = UniversalHashing(b)\n    hasher.build_hash_function()\n    \n    # Calculate the hash value\n    hash_value = hasher.hash_value(key)\n    \n    # Convert the output to JSON serializable format\n    return {\"hash_value\": hash_value}", "input_generator": "import random\n\ndef input_generator():\n    b = random.randint(1, 16)  # Reasonable range for b to avoid too large hash matrices\n    key = random.randint(0, 2**32 - 1)  # Key within 32-bit unsigned range\n    return {\"b\": b, \"key\": key}", "io_pairs": [{"input": {"b": 4, "key": 3079829992}, "output": {"hash_value": 22}}, {"input": {"b": 3, "key": 1583431104}, "output": {"hash_value": 14}}, {"input": {"b": 7, "key": 1422006336}, "output": {"hash_value": 198}}, {"input": {"b": 3, "key": 1792659391}, "output": {"hash_value": 6}}, {"input": {"b": 12, "key": 2051642508}, "output": {"hash_value": 3920}}, {"input": {"b": 3, "key": 2046396719}, "output": {"hash_value": 10}}, {"input": {"b": 6, "key": 4146302405}, "output": {"hash_value": 18}}, {"input": {"b": 5, "key": 1273762061}, "output": {"hash_value": 42}}, {"input": {"b": 1, "key": 836775122}, "output": {"hash_value": 0}}, {"input": {"b": 13, "key": 2227571684}, "output": {"hash_value": 13200}}], "error_log": []}
{"context": "In a distant galaxy, traders use a unique system of galactic numerals and metals for their transactions. They have a set of rules to convert these galactic numerals to Roman numerals and then to Arabic numerals. They also have a way to determine the value of various metals in Credits based on these conversions. Given a series of input statements that define the values of galactic numerals, the prices of metals in Credits, and questions asking for conversions or metal prices, what are the answers to these questions?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_text` (str): A string containing multiple lines of text, each line representing a different input statement or question. The format should follow the rules specified in the original code file.\n\nOutput:\n  `return` (dict): A dictionary with a single key \"answers\" whose value is a list of strings. Each string in the list represents the answer to a corresponding question in the input_text.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\nclass Colores:\n    Color = {'WARNING': '\\033[93m', 'ENDC': '\\033[0m'}\n\ndef convertRoman(roman):\n    # Placeholder for the actual Roman numeral conversion logic\n    # This function should be implemented to convert Roman numerals to integers\n    return 0  # Placeholder return value\n\nclass libros:\n    valor = {}\n    metales = {}\n\ndef leer(input):\n    peticiones = []\n    ecuaciones = []\n    error = []\n    paint = Colores()\n    info = input\n    info = [line for line in info if line.strip() != '']\n    for lineas in info:\n        lineaNoSalto = lineas.rstrip(\"\\n\")\n        lineaSeparada = lineaNoSalto.split(' ')\n        lineaSeparada = [line for line in lineaSeparada if line.strip() != '']\n        if \"?\" in lineas and lineaSeparada[0] == \"how\":\n            peticiones.append(lineaSeparada)\n        elif \"Credits\" in lineas and \"?\" not in lineas and lineaSeparada[-3] == 'is':\n            try:\n                costo = int(lineaSeparada[-2])\n                ecuaciones.append(lineaSeparada)\n            except ValueError:\n                error.append(lineaNoSalto)\n                continue\n        elif lineas.split()[-1] in 'IVXLCDM' and len(lineaSeparada) == 3 and lineaSeparada[1] == 'is':\n            if lineaSeparada[0] not in libros.valor:\n                libros.valor.update({lineaSeparada[0]: lineaSeparada[2]})\n            else:\n                continue\n        else:\n            error.append(lineaNoSalto)\n    return ecuaciones, peticiones\n\ndef precioMetales(valores, metales):\n    for lineas in metales:\n        numeros = []\n        flag2 = 0\n        for palabra in lineas[:-4]:\n            if palabra in valores:\n                numeros.append(valores[palabra])\n            else:\n                flag2 = 1\n                break\n        if flag2 == 0:\n            denominador = convertRoman(\"\".join(numeros))\n            if denominador is not None:\n                numerador = float(lineas[-2])\n                libros.metales.update({lineas[-4]: float(numerador / denominador)})\n    return None\n\ndef conversionGalactica(galaxyDolars, valores):\n    numeros = []\n    for items in galaxyDolars:\n        if items in valores:\n            numeros.append(valores[items])\n        else:\n            return None\n    creditos = convertRoman(\"\".join(numeros))\n    return creditos\n\ndef respuestas(peticiones, valores, metales):\n    respuestas = []\n    for preguntas in peticiones:\n        if \"much\" in preguntas and preguntas[2] == 'is':\n            creditos = conversionGalactica(preguntas[3:-1], valores)\n            if creditos is not None:\n                respuestas.append(\" \".join(preguntas[3:-1]) + \" is \" + str(creditos) + \" Credits\")\n            else:\n                respuestas.append(\"I have no idea what you are talking about\")\n        elif \"many\" in preguntas and preguntas[3] == 'is' and preguntas[-2] in metales:\n            creditos = conversionGalactica(preguntas[4:-2], valores)\n            if creditos is not None:\n                creditos = creditos * metales[preguntas[-2]]\n                respuestas.append(\" \".join(preguntas[4:-1]) + \" is \" + str(creditos) + \" Credits\")\n            else:\n                respuestas.append(\"I have no idea what you are talking about\")\n        else:\n            respuestas.append(\"I have no idea what you are talking about\")\n    return respuestas\n\n# main function\ndef main_solution(input_text):\n    # Convert input_text to a list of strings\n    input_lines = input_text.split('\\n')\n    \n    # Call the leer function to process the input\n    ecuaciones, peticiones = leer(input_lines)\n    \n    # Call the precioMetales function to calculate metal prices\n    precioMetales(libros.valor, ecuaciones)\n    \n    # Call the respuestas function to get the final answers\n    result = respuestas(peticiones, libros.valor, libros.metales)\n    \n    # Convert the result list to a JSON serializable format\n    result_json = {\"answers\": result}\n    \n    return result_json", "input_generator": "import random\nimport string\n\ndef input_generator():\n    roman_symbols = ['I', 'V', 'X', 'L', 'C', 'D', 'M']\n    galaxy_symbols = ['glob', 'prok', 'pish', 'tegj', 'vax', 'zork', 'blip', 'quux']\n    metals = ['Silver', 'Gold', 'Iron', 'Copper', 'Platinum']\n    \n    input_lines = []\n    \n    # Generate symbol to Roman mappings\n    for _ in range(random.randint(3, 6)):\n        symbol = random.choice(galaxy_symbols)\n        roman = random.choice(roman_symbols)\n        input_lines.append(f\"{symbol} is {roman}\")\n    \n    # Generate metal credit equations\n    for _ in range(random.randint(2, 4)):\n        metal = random.choice(metals)\n        num_symbols = random.randint(2, 4)\n        symbols = random.sample(galaxy_symbols, num_symbols)\n        credit = random.randint(10, 1000)\n        input_lines.append(f\"{' '.join(symbols)} {metal} is {credit} Credits\")\n    \n    # Generate questions\n    question_types = ['much', 'many']\n    for _ in range(random.randint(2, 5)):\n        q_type = random.choice(question_types)\n        if q_type == 'much':\n            num_symbols = random.randint(2, 4)\n            symbols = random.sample(galaxy_symbols, num_symbols)\n            input_lines.append(f\"how much is {' '.join(symbols)} ?\")\n        else:\n            metal = random.choice(metals)\n            num_symbols = random.randint(2, 4)\n            symbols = random.sample(galaxy_symbols, num_symbols)\n            input_lines.append(f\"how many Credits is {' '.join(symbols)} {metal} ?\")\n    \n    # Add some invalid lines\n    for _ in range(random.randint(1, 3)):\n        input_lines.append(''.join(random.choices(string.ascii_letters + string.digits, k=random.randint(5, 15))))\n    \n    random.shuffle(input_lines)\n    input_text = '\\n'.join(input_lines)\n    \n    return {'input_text': input_text}", "io_pairs": [], "error_log": []}
{"context": "Given a set of data points with x-values and corresponding y-values, what are the final values of the slope and intercept, along with the cost, after performing gradient descent to fit a linear regression model?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (list of float): A list of x-values representing the independent variable.\n  `y` (list of float): A list of y-values representing the dependent variable.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `m_curr` (float): The final value of the slope (m) after gradient descent.\n    - `b_curr` (float): The final value of the intercept (b) after gradient descent.\n    - `cost` (float): The final cost value after gradient descent.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(x, y):\n    # Convert JSON serializable inputs to numpy arrays\n    x = np.array(x)\n    y = np.array(y)\n    \n    m_curr = 0\n    b_curr = 0\n    iteration = 10000\n    n = len(x)\n    learning_rate = 0.01\n\n    for i in range(iteration):\n        y_prediction = m_curr * x + b_curr\n        cost = 1/n * sum(val ** 2 for val in (y - y_prediction))\n        md = -(2 / n) * sum(x * (y - y_prediction))\n        bd = (2 / n) * sum(y - y_prediction)\n        m_curr = m_curr - learning_rate * md\n        b_curr = b_curr - learning_rate * bd\n    \n    # Convert the final output to JSON serializable format\n    return {\"m_curr\": m_curr, \"b_curr\": b_curr, \"cost\": cost}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    n = random.randint(5, 20)\n    m_true = random.uniform(-5, 5)\n    b_true = random.uniform(-10, 10)\n    x = np.linspace(0, 10, n).tolist()\n    noise = np.random.normal(0, 1, n).tolist()\n    y = [m_true * xi + b_true + noise[i] for i, xi in enumerate(x)]\n    return {\"x\": x, \"y\": y}", "io_pairs": [{"input": {"x": [0.0, 1.6666666666666667, 3.3333333333333335, 5.0, 6.666666666666667, 8.333333333333334, 10.0], "y": [-7.512753095731044, 1.0882229254409368, 6.693768523295944, 15.470677467138051, 23.923069207745364, 32.221913177978884, 37.87901804740963]}, "output": {"m_curr": -1.3690090987484554e+27, "b_curr": 9.9731669088226e+27, "cost": 3.0228984547998294e+55}}, {"input": {"x": [0.0, 2.0, 4.0, 6.0, 8.0, 10.0], "y": [-5.961146412806339, -5.232793838838769, -4.977681055628418, -8.95741965789799, -8.466436665152418, -7.659587182695729]}, "output": {"m_curr": -8.531511519668148e+27, "b_curr": 6.311752714123414e+28, "cost": 1.251508394203846e+57}}, {"input": {"x": [0.0, 1.6666666666666667, 3.3333333333333335, 5.0, 6.666666666666667, 8.333333333333334, 10.0], "y": [-5.517160059627301, -4.04113326049523, -3.018351929865509, -2.9478984805960238, -2.703112894994106, -2.532434937325347, -1.4370551271200669]}, "output": {"m_curr": -9.661286792905565e+26, "b_curr": 7.038201997907601e+27, "cost": 1.5055002706534412e+55}}, {"input": {"x": [0.0, 2.5, 5.0, 7.5, 10.0], "y": [5.196028792639002, -0.24491838329456206, -10.54954868842221, -16.099972008180526, -25.02089897433654]}, "output": {"m_curr": 1.7480272488087612e+29, "b_curr": -1.3228829496411692e+30, "cost": 5.755948345456085e+59}}, {"input": {"x": [0.0, 2.5, 5.0, 7.5, 10.0], "y": [-5.107199443152665, 5.5340948703126385, 13.584909513606313, 26.05240558987053, 35.03161887021272]}, "output": {"m_curr": -1.4614539731581174e+29, "b_curr": 1.106008241057876e+30, "cost": 4.023377435536272e+59}}, {"input": {"x": [0.0, 2.0, 4.0, 6.0, 8.0, 10.0], "y": [6.611469343620403, 0.29752516442961774, -9.606481358054591, -17.284159495464884, -22.552507664659572, -29.485288163390383]}, "output": {"m_curr": 9.33544506785995e+27, "b_curr": -6.906515991776686e+28, "cost": 1.4984831349373568e+57}}, {"input": {"x": [0.0, 2.5, 5.0, 7.5, 10.0], "y": [0.5289852023538368, 5.873891477000573, 9.675802099616712, 15.833913216439159, 19.88045218129431]}, "output": {"m_curr": 2.8016494961678867e+28, "b_curr": -2.1202497569056737e+29, "cost": 1.4785911217230228e+58}}, {"input": {"x": [0.0, 1.6666666666666667, 3.3333333333333335, 5.0, 6.666666666666667, 8.333333333333334, 10.0], "y": [-9.166046901942638, -14.197343571192652, -13.342486068184652, -16.35927261596768, -17.324582438610765, -20.309742888222114, -22.025652709725094]}, "output": {"m_curr": -2.0949713872756412e+27, "b_curr": 1.52617680434764e+28, "cost": 7.078921251994117e+55}}, {"input": {"x": [0.0, 2.0, 4.0, 6.0, 8.0, 10.0], "y": [-8.334647711251053, -14.663638255647948, -20.436989888397836, -25.75601123913542, -30.126669561092278, -37.15948881146196]}, "output": {"m_curr": -1.4610820006235047e+28, "b_curr": 1.0809325242933018e+29, "cost": 3.670548653727925e+57}}, {"input": {"x": [0.0, 1.4285714285714286, 2.857142857142857, 4.285714285714286, 5.714285714285714, 7.142857142857143, 8.571428571428571, 10.0], "y": [6.467458022658266, 3.554477804997925, -0.11150503146546797, 0.4366160592414783, -3.5516762915694224, -8.350915584851071, -9.380905807442355, -12.318824510755388]}, "output": {"m_curr": 2.7328665569610466e+26, "b_curr": -1.96876971070684e+27, "cost": 1.1489088332892957e+54}}], "error_log": []}
{"context": "Given a chessboard of size `n x n`, a knight is placed at a specific starting position `(start_row, start_col)`. The knight follows the rules of the knight's move in chess (an L-shaped move). What is the sequence of moves that the knight can take to visit every square on the chessboard exactly once, starting from the given position?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the chessboard (n x n).\n  `start_row` (int): The starting row index for the knight (0-based index).\n  `start_col` (int): The starting column index for the knight (0-based index).\n\nOutput:\n  `return` (list of lists of int): A 2D list representing the chessboard with the knight's tour path marked by consecutive numbers starting from 1.", "reference_code": "# import necessary packages\nimport random\n\n# Constants\nM = 8\nNDIR = 8\nFALSE = 0\nTRUE = 1\n\nrowchange = [-2, -1, 1, 2, 2, 1, -1, -2]\ncolchange = [-1, -2, -2, -1, 1, 2, 2, 1]\n\ndef getCost(a, row, col, n):\n    count = 0\n    if(row < 0 or row >= n or col < 0 or col >= n or a[row][col] == TRUE):\n        return NDIR + 1\n    for i in range(NDIR):\n        newrow = row + rowchange[i]\n        newcol = col + colchange[i]\n        if(newrow >= 0 and newrow < n and newcol >= 0 and newcol < n and a[newrow][newcol] == FALSE):\n            count += 1\n    return count if count > 0 else NDIR + 1\n\ndef knight(a, n, row, col, num):\n    mincost = NDIR + 2\n    mindir = -1\n    a[row][col] = num\n    if(num == n * n):\n        return a\n    for i in range(NDIR):\n        newrow = row + rowchange[i]\n        newcol = col + colchange[i]\n        cost = getCost(a, newrow, newcol, n)\n        if(cost < mincost):\n            mincost = cost\n            mindir = i\n    if mindir != -1:\n        a = knight(a, n, row + rowchange[mindir], col + colchange[mindir], num + 1)\n    return a\n\n# main function\ndef main_solution(n, start_row, start_col):\n    a = [[FALSE for _ in range(n)] for _ in range(n)]\n    result = knight(a, n, start_row, start_col, 1)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(5, 8)  # Reasonable board size\n    start_row = random.randint(0, n - 1)\n    start_col = random.randint(0, n - 1)\n    return {'n': n, 'start_row': start_row, 'start_col': start_col}", "io_pairs": [{"input": {"n": 5, "start_row": 1, "start_col": 2}, "output": [[2, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 25, 0, 0, 0], [0, 0, 0, 0, 0], [24, 0, 0, 0, 0]]}, {"input": {"n": 5, "start_row": 0, "start_col": 4}, "output": [[25, 0, 0, 0, 1], [0, 0, 24, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]}, {"input": {"n": 5, "start_row": 4, "start_col": 4}, "output": [[0, 0, 0, 0, 25], [0, 0, 0, 0, 0], [0, 0, 0, 24, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1]]}, {"input": {"n": 6, "start_row": 4, "start_col": 5}, "output": [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 35, 0, 0, 0, 1], [0, 0, 0, 36, 0, 0]]}, {"input": {"n": 5, "start_row": 0, "start_col": 0}, "output": [[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 24, 0, 0, 0], [0, 0, 0, 0, 0], [25, 0, 0, 0, 0]]}, {"input": {"n": 6, "start_row": 2, "start_col": 0}, "output": [[0, 36, 0, 0, 0, 0], [0, 0, 0, 35, 0, 0], [1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]}, {"input": {"n": 5, "start_row": 3, "start_col": 2}, "output": [[24, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 25, 0, 0, 0], [0, 0, 1, 0, 0], [2, 0, 0, 0, 0]]}, {"input": {"n": 5, "start_row": 3, "start_col": 1}, "output": [[0, 0, 25, 0, 0], [24, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0]]}, {"input": {"n": 6, "start_row": 5, "start_col": 3}, "output": [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 35, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 36], [0, 0, 0, 1, 0, 0]]}, {"input": {"n": 5, "start_row": 2, "start_col": 3}, "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 25, 0, 0], [24, 0, 0, 0, 2]]}], "error_log": []}
{"context": "Given two binary trees represented by their node values in a list format, where `None` indicates a missing node, determine whether the second tree is a substructure of the first tree. A substructure means that there exists a subtree in the first tree that has the same structure and node values as the second tree. What is the result of this comparison?\n\nThe input and output requirements are as follows:\n\nInput:\n  `A` (List[int]): A list representing the structure of binary tree A. Each element in the list corresponds to a node value in the tree. `None` represents a missing node.\n  `B` (List[int]): A list representing the structure of binary tree B. Each element in the list corresponds to a node value in the tree. `None` represents a missing node.\nOutput:\n  `return` (bool): A boolean value indicating whether tree B is a substructure of tree A.", "reference_code": "# import necessary packages\nimport json\nfrom typing import List, Dict\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# Function to convert a list to a binary tree\ndef list_to_tree(lst: List[int]) -> TreeNode:\n    if not lst:\n        return None\n    root = TreeNode(lst[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(lst):\n        node = queue.pop(0)\n        if lst[i] is not None:\n            node.left = TreeNode(lst[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(lst) and lst[i] is not None:\n            node.right = TreeNode(lst[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\n# Function to convert a binary tree to a list\ndef tree_to_list(root: TreeNode) -> List[int]:\n    if not root:\n        return []\n    queue = [root]\n    lst = []\n    while queue:\n        node = queue.pop(0)\n        if node:\n            lst.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            lst.append(None)\n    while lst[-1] is None:\n        lst.pop()\n    return lst\n\n# main function\ndef main_solution(A: List[int], B: List[int]) -> bool:\n    # Convert JSON serializable inputs to TreeNode objects\n    A_tree = list_to_tree(A)\n    B_tree = list_to_tree(B)\n    \n    # Define the solution function\n    def isSubStructure(A: TreeNode, B: TreeNode) -> bool:\n        def recur(A, B):\n            if not B:\n                return True\n            if not A or A.val != B.val:\n                return False\n            return recur(A.left, B.left) and recur(A.right, B.right)\n        return bool(A and B) and (recur(A, B) or isSubStructure(A.left, B) or isSubStructure(A.right, B))\n    \n    # Get the result\n    result = isSubStructure(A_tree, B_tree)\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\nfrom typing import List, Dict\n\ndef input_generator() -> Dict:\n    # Generate a random binary tree A with 5 to 15 nodes\n    size_A = random.randint(5, 15)\n    A = []\n    for _ in range(size_A):\n        if random.random() < 0.8:  # 80% chance to have a node\n            A.append(random.randint(1, 100))\n        else:\n            A.append(None)\n    # Ensure the first element is not None\n    if A[0] is None:\n        A[0] = random.randint(1, 100)\n    \n    # Generate a random binary tree B with 1 to 5 nodes, sometimes as a subtree of A\n    size_B = random.randint(1, 5)\n    B = []\n    if random.random() < 0.5:  # 50% chance to make B a subtree of A\n        # Pick a random subtree from A\n        start = random.randint(0, len(A) - 1)\n        B = A[start:start + size_B]\n        # Ensure B is not empty and starts with a non-None value\n        while len(B) == 0 or B[0] is None:\n            start = random.randint(0, len(A) - 1)\n            B = A[start:start + size_B]\n    else:\n        # Generate a random B\n        for _ in range(size_B):\n            if random.random() < 0.8:  # 80% chance to have a node\n                B.append(random.randint(1, 100))\n            else:\n                B.append(None)\n        # Ensure the first element is not None\n        if B[0] is None:\n            B[0] = random.randint(1, 100)\n    \n    return {'A': A, 'B': B}", "io_pairs": [{"input": {"A": [34, 9, 32, 82, 95, 24, null], "B": [41, 22]}, "output": false}, {"input": {"A": [71, null, 66, 26, 54, 16, 28, 71], "B": [38, 10]}, "output": false}, {"input": {"A": [59, null, null, null, null, 72, 3, 2, 21], "B": [66]}, "output": false}, {"input": {"A": [92, 79, 35, 52, null, 11, 81, 43, 80, 15], "B": [80, 5]}, "output": false}, {"input": {"A": [27, 27, 61, 63, 6, 78], "B": [27, 27, 61, 63]}, "output": true}, {"input": {"A": [50, 97, 29, 93, null, 74, 34, 32, 69], "B": [97, 29, 93, null, 74]}, "output": false}, {"input": {"A": [21, 61, 79, 23, 5, 66, 76, 89, 89, 85, 88, null], "B": [16, 56, 96]}, "output": false}, {"input": {"A": [82, 31, 46, 94, 85, 55, 77, null, 94, 5], "B": [5]}, "output": true}, {"input": {"A": [23, 78, 97, 89, 36, 74, 65, 31, 4, 57, 89, 22, 34, null], "B": [74, 65, 31]}, "output": false}, {"input": {"A": [91, 8, null, 7, 6, 51, null, 65, null, 3, 49], "B": [16, 74]}, "output": false}], "error_log": []}
{"context": "Given a set of data points with known x and y coordinates, how can we estimate the y-coordinate for a specific x-coordinate using Newton's interpolation method? Specifically, what is the interpolated y-coordinate for the x-coordinate `xp`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (list of floats): List of x-coordinates of the data points.\n  `y` (list of floats): List of y-coordinates of the data points.\n  `xp` (float): The x-coordinate at which the interpolation is to be performed.\n\nOutput:\n  `return` (float): The interpolated y-coordinate corresponding to the input `xp`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(x, y, xp):\n    # Convert input lists to numpy arrays for easier manipulation\n    x = np.array(x)\n    y = np.array(y)\n    \n    n = len(x) - 1\n    Dy = np.zeros((n+1, n+1))\n    Dy[:, 0] = y\n    \n    # Compute the divided differences table\n    for j in range(n):\n        for i in range(j+1, n+1):\n            Dy[i, j+1] = (Dy[i, j] - Dy[j, j]) / (x[i] - x[j])\n    \n    # Perform the interpolation\n    yp = Dy[0, 0]\n    for i in range(n):\n        xprod = 1\n        for j in range(i+1):\n            xprod *= (xp - x[j])\n        yp += xprod * Dy[i+1, i+1]\n    \n    # Return the interpolated value as a float\n    return float(yp)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random number of points between 3 and 10\n    n = random.randint(3, 10)\n    \n    # Generate x values as sorted random floats to avoid duplicates\n    x = sorted(np.round(np.random.uniform(-10, 10, n), 2))\n    \n    # Generate corresponding y values as random floats\n    y = np.round(np.random.uniform(-100, 100, n), 2)\n    \n    # Generate xp within the range of x values or slightly outside\n    x_min, x_max = min(x), max(x)\n    xp = np.round(random.uniform(x_min - 5, x_max + 5), 2)\n    \n    return {'x': x.tolist(), 'y': y.tolist(), 'xp': xp}", "io_pairs": [], "error_log": []}
{"context": "Given a mathematical function \\( g(x) = \\log_{10}(x^2) \\), and an interval \\([a, b]\\), what is the approximated root of the function within the interval, considering a specified error tolerance and a maximum number of iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The lower bound of the interval in which to search for the root.\n  `b` (float): The upper bound of the interval in which to search for the root.\n  `erro` (float): The desired accuracy or error tolerance for the root approximation.\n  `iteracoes` (int): The maximum number of iterations allowed to find the root.\n\nOutput:\n  `return` (dict or str): If the method is applicable, returns a dictionary with keys:\n    - `root` (float): The approximated root of the function within the interval.\n    - `error` (float): The relative error of the root approximation.\n    - `iterations` (int): The number of iterations performed to find the root.\n    If the method is not applicable, returns a string indicating that the method cannot be applied.", "reference_code": "# import necessary packages\nimport math as mt\n\n# all class and function definitions in the code file, if any\ndef g(x):\n    return mt.log10(x**2)\n\ndef bisseccao(f, a, b, erro, iteracoes):\n    it = 0\n    x = b\n    er = 10**4\n    while er >= erro and it < iteracoes:\n        xold = x\n        x = (a + b)/2\n        er = abs((x - xold)/x)\n        if f(a) * f(x) < 0:\n            b = x\n        if f(b) * f(x) < 0:\n            a = x\n        if f(a) * f(b) > 0:\n            return 'N\u00e3o \u00e9 poss\u00edvel aplicar o m\u00e9todo da Bisse\u00e7\u00e3o neste intervalo', er, it\n        it += 1\n    return x, er, it\n\n# main function\ndef main_solution(a, b, erro, iteracoes):\n    # Convert input arguments to appropriate types if necessary\n    a = float(a)\n    b = float(b)\n    erro = float(erro)\n    iteracoes = int(iteracoes)\n    \n    # Call the bisseccao function with the function g\n    root, error, iterations = bisseccao(g, a, b, erro, iteracoes)\n    \n    # Convert the output to JSON serializable format\n    if isinstance(root, str):\n        result = root\n    else:\n        result = {\n            \"root\": root,\n            \"error\": error,\n            \"iterations\": iterations\n        }\n    \n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random interval [a, b] where g(a) * g(b) < 0\n    while True:\n        a = random.uniform(0.1, 10.0)\n        b = random.uniform(0.1, 10.0)\n        if a > b:\n            a, b = b, a\n        if math.log10(a**2) * math.log10(b**2) < 0:\n            break\n    \n    # Generate random error between 1e-10 and 1e-5\n    erro = 10 ** random.uniform(-10, -5)\n    \n    # Generate random iterations between 10 and 100\n    iteracoes = random.randint(10, 100)\n    \n    return {\n        'a': a,\n        'b': b,\n        'erro': erro,\n        'iteracoes': iteracoes\n    }", "io_pairs": [{"input": {"a": 0.769913011426353, "b": 8.1074909333329, "erro": 2.588425824700105e-07, "iteracoes": 20}, "output": {"root": 1.0000030570217215, "error": 6.997638216722033e-06, "iterations": 20}}, {"input": {"a": 0.7783294058965389, "b": 5.608315503604937, "erro": 3.598025848893258e-09, "iteracoes": 77}, "output": {"root": 1.0000000006648333, "error": 2.2491375413803996e-09, "iterations": 31}}, {"input": {"a": 0.7298129853486051, "b": 5.343601133007315, "erro": 9.083445142595287e-10, "iteracoes": 51}, "output": {"root": 1.0000000003825136, "error": 5.371156850563701e-10, "iterations": 33}}, {"input": {"a": 0.9147263457298419, "b": 7.94663307575677, "erro": 7.864476676281305e-06, "iteracoes": 18}, "output": {"root": 1.0000017344274874, "error": 2.682454884993959e-05, "iterations": 18}}, {"input": {"a": 0.8345374000888408, "b": 1.8625629512997082, "erro": 1.1790389837073683e-06, "iteracoes": 57}, "output": {"root": 1.0000007525815637, "error": 9.804008269891223e-07, "iterations": 20}}, {"input": {"a": 0.7924756883037635, "b": 5.096787070211163, "erro": 4.520597442616146e-06, "iteracoes": 23}, "output": {"root": 0.9999994747649532, "error": 4.104913370874953e-06, "iterations": 20}}, {"input": {"a": 0.6484200734893174, "b": 1.5197923685117642, "erro": 6.337085911399051e-10, "iteracoes": 46}, "output": {"root": 0.9999999999451807, "error": 4.0576431106224593e-10, "iterations": 31}}, {"input": {"a": 0.2673022365558896, "b": 8.642012971534559, "erro": 1.5461008476348222e-10, "iteracoes": 43}, "output": {"root": 1.0000000001169875, "error": 1.2186807117582176e-10, "iterations": 36}}, {"input": {"a": 0.1494693534826362, "b": 3.9523304098123, "erro": 1.4170818694841057e-06, "iteracoes": 47}, "output": {"root": 1.000000000965669, "error": 9.066727286859182e-07, "iterations": 22}}, {"input": {"a": 0.9404003167873667, "b": 1.3286078921846565, "erro": 9.767327402995072e-08, "iteracoes": 58}, "output": {"root": 0.9999999290789776, "error": 9.255590506514942e-08, "iterations": 22}}], "error_log": []}
{"context": "Given a set of 2-SAT instances, each represented by a file containing clauses of two literals, determine the satisfiability of each instance. What is the 6-bit string where each bit indicates whether the corresponding 2-SAT instance is satisfiable or not?\n\nThe input and output requirements are as follows:\n\nInput:\n  `file_contents` (str): A string containing the contents of the file with the 2-SAT instances. The first line specifies the number of variables and clauses, and each subsequent line specifies a clause via its two literals.\n\nOutput:\n  `return` (str): A 6-bit string where each bit indicates whether the corresponding 2-SAT instance is satisfiable (1) or unsatisfiable (0).", "reference_code": "# import necessary packages\nfrom collections import deque, defaultdict\n\n# all class and function definitions in the code file, if any\nclass Kosaraju:\n    def __init__(self, graph, rev_graph):\n        self.__graph, self.__rev_graph = graph, rev_graph\n        self.__current_leader = None\n        self.__leaders = defaultdict(set)\n        self.__done, self.__explored = set(), set()\n        self.__order = deque()\n\n    def __dfs(self, graph, node):\n        stack = deque([node])\n        while stack:\n            vertex = stack.pop()\n            if vertex not in self.__explored:\n                self.__explored.add(vertex)\n                if self.__current_leader is not None:\n                    self.__leaders[self.__current_leader].add(vertex)\n                stack.append(vertex)\n                to_add = graph[vertex] - self.__explored if vertex in graph else set()\n                if len(to_add) > 0:\n                    stack.extend(to_add)\n            else:\n                if vertex not in self.__done:\n                    self.__done.add(vertex)\n                    self.__order.appendleft(vertex)\n\n    def __calculate_magic_numbers(self):\n        for node in self.__rev_graph.keys():\n            if node not in self.__explored:\n                self.__dfs(self.__rev_graph, node)\n\n    def __calculate_leaders(self):\n        self.__calculate_magic_numbers()\n        self.__explored = set()\n        for node in self.__order:\n            if node not in self.__explored:\n                self.__current_leader = node\n                self.__dfs(self.__graph, node)\n\n    @property\n    def leaders(self):\n        self.__calculate_leaders()\n        return self.__leaders\n\ndef load_data(file_contents):\n    graph, rev_graph = defaultdict(set), defaultdict(set)\n    lines = file_contents.split('\\n')\n    lines.pop(0)\n    for line in lines:\n        spl = line.split()\n        if spl:\n            var1, var2 = map(int, spl)\n            graph[-var1].add(var2)\n            graph[-var2].add(var1)\n            rev_graph[var2].add(-var1)\n            rev_graph[var1].add(-var2)\n    return graph, rev_graph\n\ndef check_2_sat(scc_dictionary):\n    for leader in scc_dictionary.keys():\n        for variable in scc_dictionary[leader]:\n            if -variable in scc_dictionary[leader]:\n                return False\n    return True\n\n# main function\ndef main_solution(file_contents):\n    file_names = ['2sat{0}.txt'.format(i) for i in range(1, 7)]\n    answer = str()\n    for name in file_names:\n        g1, g2 = load_data(file_contents)\n        kosaraju = Kosaraju(g1, g2)\n        leaders_dict = kosaraju.leaders\n        answer += '1' if check_2_sat(leaders_dict) else '0'\n    return answer", "input_generator": "import random\nfrom collections import defaultdict\n\ndef input_generator():\n    num_clauses = random.randint(5, 20)\n    clauses = []\n    variables = set()\n    \n    for _ in range(num_clauses):\n        var1 = random.randint(1, 10)\n        var2 = random.randint(1, 10)\n        if random.random() < 0.5:\n            var1 *= -1\n        if random.random() < 0.5:\n            var2 *= -1\n        clauses.append((var1, var2))\n        variables.update({abs(var1), abs(var2)})\n    \n    file_contents = f\"{num_clauses}\\n\" + \"\\n\".join(f\"{c[0]} {c[1]}\" for c in clauses)\n    \n    return {'file_contents': file_contents}", "io_pairs": [{"input": {"file_contents": "17\n3 -2\n5 -2\n-4 -10\n-6 7\n-5 9\n1 2\n-4 3\n-4 -8\n2 -2\n4 2\n1 -8\n-1 4\n6 3\n-3 -2\n8 -7\n-10 10\n10 3"}, "output": "111111"}, {"input": {"file_contents": "13\n7 -2\n-4 10\n-4 -3\n-3 2\n-8 -10\n1 -6\n3 -9\n-8 -2\n4 -9\n8 -5\n-4 10\n6 4\n-4 7"}, "output": "111111"}, {"input": {"file_contents": "5\n9 5\n5 -8\n9 3\n-1 -1\n8 -9"}, "output": "111111"}, {"input": {"file_contents": "13\n9 2\n-6 8\n-1 -3\n-8 10\n-6 -9\n4 -8\n6 -6\n-2 -2\n-6 -6\n7 6\n1 -7\n6 -5\n8 10"}, "output": "111111"}, {"input": {"file_contents": "6\n-10 3\n-2 -3\n7 -3\n-6 2\n-9 -5\n-2 -8"}, "output": "111111"}, {"input": {"file_contents": "11\n4 8\n1 -8\n1 -2\n6 7\n2 6\n2 -10\n9 -6\n-10 4\n10 -4\n8 6\n1 -4"}, "output": "111111"}, {"input": {"file_contents": "12\n-8 9\n10 -4\n-5 -5\n8 3\n-2 2\n6 2\n6 -5\n6 8\n-6 7\n-4 7\n8 10\n10 -4"}, "output": "111111"}, {"input": {"file_contents": "16\n-6 -9\n-6 -9\n-6 5\n-5 -4\n5 -1\n-2 -6\n8 -6\n-8 -8\n-7 8\n5 -5\n-2 7\n-1 -1\n10 -6\n8 8\n-4 1\n7 2"}, "output": "000000"}, {"input": {"file_contents": "14\n4 3\n3 4\n-7 7\n3 8\n6 -8\n3 6\n-3 7\n-4 -5\n-2 9\n-1 1\n-7 6\n-2 2\n3 -2\n7 -8"}, "output": "111111"}, {"input": {"file_contents": "5\n-9 2\n3 -7\n5 -10\n10 -4\n8 9"}, "output": "111111"}], "error_log": []}
{"context": "Given a partially filled Tic Tac Toe board, what is the optimal move for the current player to maximize their chances of winning or forcing a draw? The board is represented as a 3x3 grid, where each cell can be either `\"X\"`, `\"O\"`, or empty (`None`). The optimal move should be returned as a tuple `(i, j)` indicating the row and column indices of the best move.\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_state` (list of lists of strings/None): A 3x3 grid representing the Tic Tac Toe board. Each cell can be `\"X\"`, `\"O\"`, or `None` (representing an empty cell).\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"optimal_action\"` whose value is a tuple `(i, j)` representing the optimal move for the current player on the board.", "reference_code": "# import necessary packages\nimport math\nimport copy\nimport random\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    number_of_Xs = sum(row.count(X) for row in board)\n    number_of_Os = sum(row.count(O) for row in board)\n    return X if number_of_Xs <= number_of_Os else O\n\n# Function to get all possible actions\ndef actions(board):\n    return {(i, j) for i, row in enumerate(board) for j, value in enumerate(row) if value == EMPTY}\n\n# Function to get the result of an action\ndef result(board, action):\n    copy_board = copy.deepcopy(board)\n    copy_board[action[0]][action[1]] = player(board)\n    return copy_board\n\n# Function to determine the winner\ndef winner(board):\n    lines = [\n        [(0, 0), (0, 1), (0, 2)],\n        [(1, 0), (1, 1), (1, 2)],\n        [(2, 0), (2, 1), (2, 2)],\n        [(0, 0), (1, 0), (2, 0)],\n        [(0, 1), (1, 1), (2, 1)],\n        [(0, 2), (1, 2), (2, 2)],\n        [(0, 0), (1, 1), (2, 2)],\n        [(2, 0), (1, 1), (0, 2)],\n    ]\n    for line in lines:\n        if all(board[i][j] == X for i, j in line):\n            return X\n        if all(board[i][j] == O for i, j in line):\n            return O\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or not actions(board)\n\n# Function to get the utility of the board\ndef utility(board):\n    win = winner(board)\n    if win == X:\n        return 1\n    elif win == O:\n        return -1\n    else:\n        return 0\n\n# Function to get the optimal action using minimax\ndef minimax(board):\n    if terminal(board):\n        return None\n    if board == initial_state():\n        return (random.randint(0, 2), random.randint(0, 2))\n\n    if player(board) == X:\n        value = -math.inf\n        best_action = None\n        for action in actions(board):\n            min_val = min_value(result(board, action))\n            if min_val > value:\n                value = min_val\n                best_action = action\n    else:\n        value = math.inf\n        best_action = None\n        for action in actions(board):\n            max_val = max_value(result(board, action))\n            if max_val < value:\n                value = max_val\n                best_action = action\n    return best_action\n\n# Function to get the min value of the board\ndef min_value(board):\n    if terminal(board):\n        return utility(board)\n    v = math.inf\n    for action in actions(board):\n        v = min(v, max_value(result(board, action)))\n    return v\n\n# Function to get the max value of the board\ndef max_value(board):\n    if terminal(board):\n        return utility(board)\n    v = -math.inf\n    for action in actions(board):\n        v = max(v, min_value(result(board, action)))\n    return v\n\n# main function\ndef main_solution(board_state):\n    # Convert the JSON serializable input to the original input variable\n    board = [row[:] for row in board_state]\n    \n    # Get the optimal action using minimax\n    optimal_action = minimax(board)\n    \n    # Convert the output to JSON serializable format\n    return {\"optimal_action\": optimal_action}", "input_generator": "import random\n\ndef input_generator():\n    board = [[None, None, None], [None, None, None], [None, None, None]]\n    moves = random.randint(0, 9)\n    current_player = 'X'\n    \n    for _ in range(moves):\n        empty_positions = [(i, j) for i in range(3) for j in range(3) if board[i][j] is None]\n        if not empty_positions:\n            break\n        move = random.choice(empty_positions)\n        board[move[0]][move[1]] = current_player\n        current_player = 'O' if current_player == 'X' else 'X'\n    \n    return {\"board_state\": board}", "io_pairs": [{"input": {"board_state": [["X", null, null], [null, "O", "X"], ["O", null, null]]}, "output": {"optimal_action": [0, 2]}}, {"input": {"board_state": [["X", "O", null], [null, null, "O"], [null, null, "X"]]}, "output": {"optimal_action": [2, 1]}}, {"input": {"board_state": [["X", "X", "O"], ["O", "X", "X"], ["O", "O", "X"]]}, "output": {"optimal_action": null}}, {"input": {"board_state": [["X", "O", "O"], [null, "X", "X"], ["O", "X", null]]}, "output": {"optimal_action": [1, 0]}}, {"input": {"board_state": [[null, null, null], ["O", null, "X"], [null, null, null]]}, "output": {"optimal_action": [0, 1]}}, {"input": {"board_state": [[null, null, null], ["X", null, null], [null, null, null]]}, "output": {"optimal_action": [1, 2]}}, {"input": {"board_state": [[null, null, null], [null, null, null], [null, null, null]]}, "output": {"optimal_action": [2, 2]}}, {"input": {"board_state": [[null, null, null], [null, null, "X"], [null, null, "O"]]}, "output": {"optimal_action": [2, 1]}}, {"input": {"board_state": [[null, null, null], [null, null, "X"], [null, null, null]]}, "output": {"optimal_action": [1, 1]}}, {"input": {"board_state": [["X", "O", null], [null, "X", "X"], [null, "O", null]]}, "output": {"optimal_action": [1, 0]}}], "error_log": []}
{"context": "Given a neural network designed to learn the XOR function with 2 input features, 2 hidden neurons, and 1 output neuron, what is the runtime in milliseconds for training the network using a specified seed, number of epochs, and learning rate?\n\nThe input and output requirements are as follows:\n\nInput:\n  `seed` (int): A seed value for random number generation to ensure reproducibility.\n  `epochs` (int): The number of training iterations for the neural network.\n  `alpha` (float): The learning rate for gradient descent.\n\nOutput:\n  `return` (dict): A dictionary containing the runtime of the training process in milliseconds. The key is `\"runtime\"` and the value is an integer.", "reference_code": "# import necessary packages\nimport numpy as np\nimport random\nfrom time import time\n\n# all class and function definitions in the code file, if any\ndef sigmoid(z):\n    return 1. / (1. + np.exp(-z))\n\n# main function\ndef main_solution(seed, epochs, alpha):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert JSON serializable inputs to original input variables\n    seed = int(seed)\n    epochs = int(epochs)\n    alpha = float(alpha)\n\n    # Generate dataset of `XOR` examples\n    x = np.array([[0., 0., 1., 1.], [0., 1., 0., 1.]])\n    y = np.array([[0., 1., 1., 0.]])\n    n = x.shape[1]\n\n    # Set seed for reproducibility\n    random.seed(seed)\n    start = time()\n\n    # Initialize weights and biases\n    w0 = np.random.rand(2, 2)\n    b0 = np.random.rand(2, 1)\n    w1 = np.random.rand(2, 1)\n    b1 = np.random.rand(1, 1)\n\n    # Train using gradient descent\n    for _ in range(epochs):\n        # Forward propagation\n        a1 = sigmoid(np.dot(w0.T, x) + b0)\n        y_hat = sigmoid(np.dot(w1.T, a1) + b1)\n\n        # Loss (MSE) multiplied by a 1/2 term to make the derivative easier\n        _loss = (1. / (2. * n)) * np.sum((y_hat - y) ** 2)\n\n        # Backpropagation\n        dy_hat = (y_hat - y) / float(n)\n        dz2 = (y_hat * (1. - y_hat)) * dy_hat\n        dw1 = np.dot(a1, dz2.T)\n        db1 = np.sum(dz2, axis=1, keepdims=True)\n        dz1 = (a1 * (1. - a1)) * np.dot(w1, (dy_hat * (y_hat * (1. - y_hat))))\n        dw0 = np.dot(x, dz1.T)\n        db0 = np.sum(dz1, axis=1, keepdims=True)\n\n        # Weight and bias update\n        w0 = w0 - alpha * (dw0 / float(n))\n        w1 = w1 - alpha * (dw1 / float(n))\n        b0 = b0 - alpha * (db0 / float(n))\n        b1 = b1 - alpha * (db1 / float(n))\n\n    # Record the time\n    runtime = round((time() - start) * 1000.)\n\n    # Convert output to JSON serializable\n    return {\"runtime\": runtime}", "input_generator": "import random\n\ndef input_generator():\n    seed = random.randint(0, 1000)\n    epochs = random.randint(100, 1000)\n    alpha = random.uniform(0.001, 0.1)\n    return {\"seed\": seed, \"epochs\": epochs, \"alpha\": alpha}", "io_pairs": [{"input": {"seed": 826, "epochs": 241, "alpha": 0.07233182044395148}, "output": {"runtime": 27}}, {"input": {"seed": 566, "epochs": 904, "alpha": 0.06415506780757069}, "output": {"runtime": 66}}, {"input": {"seed": 815, "epochs": 597, "alpha": 0.05612651847469457}, "output": {"runtime": 43}}, {"input": {"seed": 917, "epochs": 113, "alpha": 0.02945430535718198}, "output": {"runtime": 0}}, {"input": {"seed": 878, "epochs": 869, "alpha": 0.05276856160182402}, "output": {"runtime": 79}}, {"input": {"seed": 820, "epochs": 656, "alpha": 0.05696221400042221}, "output": {"runtime": 47}}, {"input": {"seed": 221, "epochs": 450, "alpha": 0.09174472919459468}, "output": {"runtime": 36}}, {"input": {"seed": 251, "epochs": 535, "alpha": 0.010265773145254432}, "output": {"runtime": 29}}, {"input": {"seed": 455, "epochs": 775, "alpha": 0.038862065141435094}, "output": {"runtime": 68}}, {"input": {"seed": 927, "epochs": 980, "alpha": 0.07287237320451992}, "output": {"runtime": 71}}], "error_log": []}
{"context": "In a game of chess, the current state of the board is represented by a FEN string. Given this FEN string, what is the UCI format of a randomly selected legal move for the current player?\n\nThe input and output requirements are as follows:\n\nInput:\n  `fen` (str): A FEN (Forsyth-Edwards Notation) string representing the current state of the chessboard. The string should be in the standard FEN format, which includes information about the pieces on the board, the active player, castling rights, en passant targets, halfmove clock, and fullmove number.\n\nOutput:\n  `return` (str): A string representing the UCI (Universal Chess Interface) format of the selected move. The string will be in the format \"from_squareto_square\" (e.g., \"e2e4\").", "reference_code": "# import necessary packages\nimport random\nimport chess\n\n# all class and function definitions in the code file, if any\ndef enemy_into_check(board, move) -> bool:\n    \"\"\"\n    Checks if the given move would leave the king in check or put it into\n    check. The move must be at least pseudo legal.\n    \"\"\"\n    king = board.king(not board.turn)\n    if king is None:\n        return False\n\n    checkers = board.attackers_mask(board.turn, king)\n    if checkers:\n        # If already in check, look if it is an evasion.\n        if move not in board._generate_evasions(checkers, king, chess.BB_SQUARES[move.from_square], chess.BB_SQUARES[move.to_square]):\n            return True\n\n    return not board._is_safe(king, board._slider_blockers(king), move)\n\n# main function\ndef main_solution(fen: str) -> str:\n    # Convert the FEN string to a chess board\n    board = chess.Board(fen)\n    \n    # Get a random legal move\n    move = random.choice(list(board.legal_moves))\n    \n    # Convert the move to UCI format\n    uci_move = board.uci(move)\n    \n    return uci_move", "input_generator": "import chess\nimport random\n\ndef input_generator():\n    # Generate a random FEN string representing a reasonable chess position\n    board = chess.Board()\n    for _ in range(random.randint(0, 20)):  # Make some random moves\n        legal_moves = list(board.legal_moves)\n        if not legal_moves:\n            break\n        move = random.choice(legal_moves)\n        board.push(move)\n    \n    # Occasionally use the starting position\n    if random.random() < 0.2:\n        board = chess.Board()\n    \n    return {'fen': board.fen()}", "io_pairs": [{"input": {"fen": "rnbqkbnr/1pppp1pp/8/p4p2/3PP3/8/PPP2PPP/RNBQKBNR b KQkq - 1 4"}, "output": "b7b5"}, {"input": {"fen": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"}, "output": "b1a3"}, {"input": {"fen": "rnbqkbnr/pp1pppp1/7p/2p5/8/P4PP1/1PPPP2P/RNBQKBNR b KQkq - 0 3"}, "output": "g7g5"}, {"input": {"fen": "rnbqkbnr/ppp2p1p/B3p1p1/3p4/3PP3/2N5/PPP2PPP/R1BQK1NR b KQkq - 1 4"}, "output": "f8g7"}, {"input": {"fen": "1rbqkbnr/ppppp1pp/2n2p2/8/8/NPPP4/P3PPPP/R1BQKBNR b KQk - 0 4"}, "output": "e8f7"}, {"input": {"fen": "2b1kb1r/rpp1pp1p/3R2pn/pq6/P1P4P/5P2/1P1PP1PR/1NBQKBN1 w k - 1 11"}, "output": "e2e3"}, {"input": {"fen": "r1b1k2r/ppp1b2p/n6n/5pp1/1P3P2/P6P/2Pq2P1/RNB1KBNR w KQkq - 0 11"}, "output": "b1d2"}, {"input": {"fen": "r1bqkbnr/pppppppp/2n5/8/8/P7/1PPPPPPP/RNBQKBNR w KQkq - 1 2"}, "output": "a1a2"}, {"input": {"fen": "rnbqkb2/pp1ppppr/7n/2p4p/3P1P2/2P4N/PP2P1PP/RNBQKB1R w KQq - 1 5"}, "output": "b2b3"}, {"input": {"fen": "r1bqkbnr/1pppppp1/2n4p/p7/8/2N2P2/PPPPPKPP/R1BQ1BNR w kq - 2 4"}, "output": "d2d4"}], "error_log": []}
{"context": "Given a list of words, how can we rearrange the words such that all palindromic words are moved to the end of the list while maintaining their original order among themselves?\n\nThe input and output requirements are as follows:\n\nInput:\n  `words` (list of strings): A list of words to be checked for palindromes and rearranged accordingly.\n\nOutput:\n  `return` (string): A space-separated string of words that are palindromes, rearranged as per the problem's requirements.", "reference_code": "# import necessary packages\nimport string\nimport random\n\n# Node Class with constructor and is_wordPalindrome methods\nclass LLNode(object):\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        \n    def is_wordPalindrome(self):\n        if self.data is None:\n            return False\n        else:\n            lower_word = self.data.lower()\n            reversed_word = lower_word[::-1]\n            return lower_word == reversed_word\n\n# Class for Queue single LinkedList object \nclass QueueLinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        \n    def checkPalindrome(self): \n        cur_node = self.head\n        queueSize = self.getSize()\n\n        if self.head is None:\n            return\n        else:\n            while queueSize >= 1:\n                if cur_node.is_wordPalindrome():\n                    if self.queueDeq() is not None:\n                        self.queueEnq(cur_node.data)\n                        cur_node = cur_node.next\n                else:\n                    if self.queueDeq() is not None:\n                        cur_node = cur_node.next\n                queueSize -= 1\n\n    def getSize(self):\n        count = 0\n        cur_node = self.head\n        while cur_node:\n            count += 1\n            cur_node = cur_node.next\n        return count\n       \n    def queueToString(self):\n        cur_node = self.head\n        LLString = \"\"\n        if self.head is None and self.tail is None:\n            return LLString\n        while cur_node:\n            LLString += cur_node.data + \" \"\n            cur_node = cur_node.next\n        return LLString.strip()\n    \n    def queueEnq(self, data):\n        new_node = LLNode(data)\n        if self.head is None and self.tail is None:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n        return self\n\n    def queueDeq(self):\n        if self.head is None and self.tail is None:\n            return None\n        else:\n            curr_data = self.head.data\n            self.head = self.head.next\n            return curr_data\n\n# main function\ndef main_solution(words):\n    # Convert input list to QueueLinkedList\n    queue = QueueLinkedList()\n    for word in words:\n        queue.queueEnq(word)\n    \n    # Check for palindromes and rearrange the queue\n    queue.checkPalindrome()\n    \n    # Convert the queue to a string of palindromes\n    palindrome_string = queue.queueToString()\n    \n    # Return the string of palindromes\n    return palindrome_string", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random list of words, some of which are palindromes\n    words = []\n    num_words = random.randint(5, 15)\n    \n    # Generate palindromic words\n    palindromes = ['madam', 'racecar', 'level', 'deified', 'rotor', 'civic']\n    \n    # Generate non-palindromic words\n    non_palindromes = ['hello', 'world', 'python', 'code', 'generator', 'random']\n    \n    for _ in range(num_words):\n        if random.choice([True, False]):\n            word = random.choice(palindromes)\n        else:\n            word = random.choice(non_palindromes)\n        words.append(word)\n    \n    # Occasionally shuffle the list to add more randomness\n    random.shuffle(words)\n    \n    return {'words': words}", "io_pairs": [{"input": {"words": ["hello", "civic", "madam", "code", "world", "random"]}, "output": "civic madam"}, {"input": {"words": ["deified", "level", "code", "level", "civic", "hello", "madam", "racecar", "generator", "civic", "racecar", "madam", "world", "rotor"]}, "output": "deified level level civic madam racecar civic racecar madam rotor"}, {"input": {"words": ["racecar", "generator", "rotor", "hello", "hello", "world", "racecar", "deified", "deified", "racecar"]}, "output": "racecar rotor racecar deified deified racecar"}, {"input": {"words": ["racecar", "hello", "random", "code", "random", "civic", "rotor", "random", "level"]}, "output": "racecar civic rotor level"}, {"input": {"words": ["level", "racecar", "deified", "rotor", "rotor", "deified", "civic"]}, "output": "level racecar deified rotor rotor deified civic"}, {"input": {"words": ["madam", "deified", "racecar", "racecar", "level"]}, "output": "madam deified racecar racecar level"}, {"input": {"words": ["random", "deified", "generator", "level", "hello", "racecar", "code", "madam", "world", "deified", "hello", "deified", "racecar", "level", "generator"]}, "output": "deified level racecar madam deified deified racecar level"}, {"input": {"words": ["madam", "code", "racecar", "madam", "racecar", "civic", "generator"]}, "output": "madam racecar madam racecar civic"}, {"input": {"words": ["rotor", "civic", "civic", "code", "madam"]}, "output": "rotor civic civic madam"}, {"input": {"words": ["level", "civic", "generator", "deified", "racecar", "generator", "world", "world", "rotor", "racecar", "hello", "python", "world", "civic", "code"]}, "output": "level civic deified racecar rotor racecar civic"}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, given the current state of the board and the player whose turn it is, what is the optimal move for the current player to make? The board is represented by a list of integers where `0` indicates an empty space, `1` indicates a move by player 'X', and `-1` indicates a move by player 'O'. The current player is either 'X' or 'O'.\n\nThe input and output requirements are as follows:\n\nInput:\n  `numerical_board` (list of int): A list representing the current state of the Tic-Tac-Toe board. Each element in the list can be `0` (empty), `1` (player 'X'), or `-1` (player 'O'). The list has exactly 9 elements corresponding to the 9 positions on the board.\n  `current_player` (str): A string representing the current player, either 'X' or 'O'.\n\nOutput:\n  `return` (int): An integer representing the best move position on the board (0-8) for the current player.", "reference_code": "# import necessary packages\nimport math\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\ndef get_possible_pos(state, player):\n    pos_moves = []\n    temp = deepcopy(state)\n    for i, s in enumerate(state):\n        if s == 0:\n            temp[i] = player\n            pos_moves.append((i, temp))\n            temp = deepcopy(state)\n    return pos_moves\n\ndef minimax(state, depth, maximizing_player):\n    if Board.winner(state) != 0:\n        return {'position': None, 'score': depth * Board.winner(state)}\n\n    if depth == 0:\n        return {'position': None, 'score': Board.winner(state)}\n\n    if maximizing_player:\n        max_eval = -math.inf\n        position = None\n        for s in get_possible_pos(state, 1):\n            result = minimax(s[1], depth-1, False)\n            if result['score'] > max_eval:\n                max_eval = result['score']\n                position = s[0]\n        return {'position': position, 'score': max_eval}\n    else:\n        min_eval = math.inf\n        position = None\n        for s in get_possible_pos(state, -1):\n            result = minimax(s[1], depth-1, True)\n            if result['score'] < min_eval:\n                min_eval = result['score']\n                position = s[0]\n        return {'position': position, 'score': min_eval}\n\nclass Board:\n    @staticmethod\n    def winner(m):\n        # rows\n        count = 0\n        for i in range(3):\n            s = m[count] + m[count + 1] + m[count + 2]\n            if s == 3:\n                return 1\n            elif s == -3:\n                return -1\n            count = count + 3\n        # columns\n        count = 0\n        for i in range(3):\n            s = m[count] + m[count + 3] + m[count + 6]\n            if s == 3:\n                return 1\n            elif s == -3:\n                return -1\n            count = count + 1\n        # diagonals\n        if m[0] + m[4] + m[8] == 3 or m[2] + m[4] + m[6] == 3:\n            return 1\n        elif m[0] + m[4] + m[8] == -3 or m[2] + m[4] + m[6] == -3:\n            return -1\n        return 0\n\n# main function\ndef main_solution(numerical_board, current_player):\n    # Convert current_player to numerical value\n    player = 1 if current_player == 'X' else -1\n    \n    # Get the best move using minimax algorithm\n    move = minimax(deepcopy(numerical_board), len([x for x in numerical_board if x == 0]), player == 1)['position']\n    \n    # Return the best move position\n    return move", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random Tic-Tac-Toe board with 0 (empty), 1 (X), or -1 (O)\n    numerical_board = [0] * 9\n    # Randomly fill some positions\n    for i in range(random.randint(0, 8)):\n        pos = random.randint(0, 8)\n        if numerical_board[pos] == 0:\n            numerical_board[pos] = random.choice([1, -1])\n    \n    # Randomly choose current player\n    current_player = random.choice(['X', 'O'])\n    \n    return {\n        'numerical_board': numerical_board,\n        'current_player': current_player\n    }", "io_pairs": [{"input": {"numerical_board": [0, 0, 0, 0, 0, 0, 0, 0, 0], "current_player": "X"}, "output": 0}, {"input": {"numerical_board": [0, 0, -1, 0, 0, 0, 0, 1, -1], "current_player": "O"}, "output": 5}, {"input": {"numerical_board": [-1, 1, 0, 0, 1, 1, 0, 0, 0], "current_player": "O"}, "output": 2}, {"input": {"numerical_board": [0, 0, 0, 0, 0, 0, 0, 0, 0], "current_player": "O"}, "output": 0}, {"input": {"numerical_board": [1, 0, 0, 0, 0, -1, -1, 0, 0], "current_player": "X"}, "output": 2}, {"input": {"numerical_board": [0, 0, 0, 0, -1, -1, 1, 0, 1], "current_player": "X"}, "output": 7}, {"input": {"numerical_board": [-1, 0, -1, 1, 1, 0, 0, 0, -1], "current_player": "O"}, "output": 1}, {"input": {"numerical_board": [1, 0, 0, 0, -1, 1, 0, 0, -1], "current_player": "O"}, "output": 6}, {"input": {"numerical_board": [1, 0, 0, 0, 0, 0, -1, 1, 0], "current_player": "X"}, "output": 1}, {"input": {"numerical_board": [1, 0, 0, -1, 1, 0, -1, 1, 0], "current_player": "O"}, "output": 1}], "error_log": []}
{"context": "Given a partially filled Sudoku grid, what is the complete and correct solution for the Sudoku puzzle? The grid is represented as a list of strings, where each string corresponds to a row in the grid. Each character in the string is a digit from '0' to '9', with '0' indicating an empty cell.\n\nThe input and output requirements are as follows:\n\nInput:\n- `puzzle` (List[str]): A list of 9 strings, each representing a row in the Sudoku grid. Each string contains 9 characters, where each character is a digit from '0' to '9'. '0' represents an empty cell.\n\nOutput:\n- `return` (List[str]): A list of 9 strings, each representing a row in the solved Sudoku grid. Each string contains 9 characters, where each character is a digit from '1' to '9'.", "reference_code": "# import necessary packages\nfrom typing import List, Tuple\nimport random\n\n# all class and function definitions in the code file, if any\nclass Sudoku:\n    \"\"\"A mutable sudoku puzzle.\"\"\"\n\n    def __init__(self, puzzle: List[str]):\n        self._grid: List[str] = puzzle\n\n    def place(self, value: int, x: int, y: int) -> None:\n        \"\"\"Place value at x,y.\"\"\"\n        row = self._grid[y]\n        new_row = row[:x] + str(value) + row[x + 1:]\n        self._grid[y] = new_row\n\n    def unplace(self, x: int, y: int) -> None:\n        \"\"\"Remove (unplace) a number at x,y.\"\"\"\n        row = self._grid[y]\n        new_row = row[:x] + \"0\" + row[x + 1:]\n        self._grid[y] = new_row\n\n    def value_at(self, x: int, y: int) -> int:\n        \"\"\"Returns the value at x,y.\"\"\"\n        return int(self._grid[y][x])\n\n    def options_at(self, x: int, y: int) -> List[int]:\n        \"\"\"Returns all possible values (options) at x,y.\"\"\"\n        options = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        for value in self.row_values(y):\n            if value in options:\n                options.remove(value)\n        for value in self.column_values(x):\n            if value in options:\n                options.remove(value)\n        block_index = (y // 3) * 3 + x // 3\n        for value in self.block_values(block_index):\n            if value in options:\n                options.remove(value)\n        return options\n\n    def next_empty_index(self) -> Tuple[int, int]:\n        \"\"\"Returns the next index (x,y) that is empty (value 0).\"\"\"\n        for y in range(9):\n            for x in range(9):\n                if self.value_at(x, y) == 0:\n                    return x, y\n        return -1, -1\n\n    def row_values(self, i: int) -> List[int]:\n        \"\"\"Returns all values at i-th row.\"\"\"\n        return list(map(int, self._grid[i]))\n\n    def column_values(self, i: int) -> List[int]:\n        \"\"\"Returns all values at i-th column.\"\"\"\n        return [int(row[i]) for row in self._grid]\n\n    def block_values(self, i: int) -> List[int]:\n        \"\"\"Returns all values at i-th block.\"\"\"\n        values = []\n        x_start = (i % 3) * 3\n        y_start = (i // 3) * 3\n        for x in range(x_start, x_start + 3):\n            for y in range(y_start, y_start + 3):\n                values.append(self.value_at(x, y))\n        return values\n\n    def is_solved(self) -> bool:\n        \"\"\"Returns True if and only if all rows, columns and blocks contain only the numbers 1 through 9.\"\"\"\n        return all(0 not in self.row_values(i) for i in range(9))\n\n    def __str__(self) -> str:\n        return \"\\n\".join(self._grid)\n\n# main function\ndef main_solution(puzzle: List[str]) -> List[str]:\n    \"\"\"\n    Solves a Sudoku puzzle and returns the solved grid.\n    \n    Input:\n    - puzzle (List[str]): A list of strings representing the Sudoku grid. Each string is a row in the grid.\n    \n    Output:\n    - List[str]: The solved Sudoku grid as a list of strings.\n    \"\"\"\n    def solve(sudoku: Sudoku) -> bool:\n        x, y = sudoku.next_empty_index()\n        if x == -1 and y == -1:\n            return True\n        for value in sudoku.options_at(x, y):\n            sudoku.place(value, x, y)\n            if solve(sudoku):\n                return True\n            sudoku.unplace(x, y)\n        return False\n\n    sudoku = Sudoku(puzzle)\n    solve(sudoku)\n    return sudoku._grid", "input_generator": "import random\nfrom typing import List\n\ndef input_generator() -> dict:\n    # Generate a partially filled Sudoku puzzle (as a list of strings)\n    # Start with a solved Sudoku grid\n    solved_grid = [\n        \"534678912\",\n        \"672195348\",\n        \"198342567\",\n        \"859761423\",\n        \"426853791\",\n        \"713924856\",\n        \"961537284\",\n        \"287419635\",\n        \"345286179\"\n    ]\n    \n    # Randomly remove some numbers to create a puzzle\n    puzzle = []\n    for row in solved_grid:\n        new_row = []\n        for c in row:\n            if random.random() < 0.6:  # 60% chance to keep the number\n                new_row.append(c)\n            else:\n                new_row.append('0')\n        puzzle.append(''.join(new_row))\n    \n    return {\"puzzle\": puzzle}", "io_pairs": [{"input": {"puzzle": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, "output": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, {"input": {"puzzle": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, "output": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, {"input": {"puzzle": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, "output": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, {"input": {"puzzle": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, "output": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, {"input": {"puzzle": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, "output": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, {"input": {"puzzle": ["534678219", "672195348", "198342567", "859761423", "426853791", "713924856", "941537682", "287416935", "365289174"]}, "output": ["534678219", "672195348", "198342567", "859761423", "426853791", "713924856", "941537682", "287416935", "365289174"]}, {"input": {"puzzle": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, "output": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, {"input": {"puzzle": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, "output": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, {"input": {"puzzle": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, "output": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, {"input": {"puzzle": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}, "output": ["534678912", "672195348", "198342567", "859761423", "426853791", "713924856", "961537284", "287419635", "345286179"]}], "error_log": []}
{"context": "Given two pairs of integers, (a, b) and (c, d), where each pair represents a base and an exponent, determine the result of subtracting the value of c raised to the power of d from the value of a raised to the power of b. What is the result of this subtraction?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): The first base number.\n  `b` (int): The exponent for the first base number.\n  `c` (int): The second base number.\n  `d` (int): The exponent for the second base number.\n\nOutput:\n  `return` (dict): A dictionary containing the key `result` which holds the result of the subtraction of the two exponentiated numbers. The result can be a positive or negative integer.", "reference_code": "# import necessary packages\nimport random\nimport sys\n\n# all class and function definitions in the code file, if any\ndef shift(A, n):\n    if n == 0:\n        return A\n    return [0] + shift(A, n-1)\n\ndef mult(X, Y):\n    if zero(Y):\n        return [0]\n    Z = mult(X, div2(Y))\n    if even(Y):\n        return add(Z, Z)\n    else:\n        return add(X, add(Z, Z))\n\ndef zero(X):\n    if len(X) == 0:\n        return True\n    else:\n        for j in range(len(X)):\n            if X[j] == 1:\n                return False\n    return True\n\ndef div2(Y):\n    if len(Y) == 0:\n        return Y\n    else:\n        return Y[1:]\n\ndef even(X):\n    if ((len(X) == 0) or (X[0] == 0)):\n        return True\n    else:\n        return False\n\ndef add(A, B):\n    A1 = A[:]\n    B1 = B[:]\n    n = len(A1)\n    m = len(B1)\n    if n < m:\n        for j in range(len(B1)-len(A1)):\n            A1.append(0)\n    else:\n        for j in range(len(A1)-len(B1)):\n            B1.append(0)\n    N = max(m, n)\n    C = []\n    carry = 0\n    for j in range(N):\n        C.append(exc_or(A1[j], B1[j], carry))\n        carry = nextcarry(carry, A1[j], B1[j])\n    if carry == 1:\n        C.append(carry)\n    return C\n\ndef exc_or(a, b, c):\n    return (a ^ (b ^ c))\n\ndef nextcarry(a, b, c):\n    if ((a & b) | (b & c) | (c & a)):\n        return 1\n    else:\n        return 0\n\ndef bin2dec(A):\n    if len(A) == 0:\n        return 0\n    val = A[0]\n    pow = 2\n    for j in range(1, len(A)):\n        val = val + pow * A[j]\n        pow = pow * 2\n    return val\n\ndef reverse(A):\n    B = A[::-1]\n    return B\n\ndef trim(A):\n    if len(A) == 0:\n        return A\n    A1 = reverse(A)\n    while ((not (len(A1) == 0)) and (A1[0] == 0)):\n        A1.pop(0)\n    return reverse(A1)\n\ndef compare(A, B):\n    A1 = reverse(trim(A))\n    A2 = reverse(trim(B))\n    if len(A1) > len(A2):\n        return 1\n    elif len(A1) < len(A2):\n        return 2\n    else:\n        for j in range(len(A1)):\n            if A1[j] > A2[j]:\n                return 1\n            elif A1[j] < A2[j]:\n                return 2\n        return 0\n\ndef dec2bin(n):\n    if n == 0:\n        return []\n    m = n // 2\n    A = dec2bin(m)\n    fbit = n % 2\n    return [fbit] + A\n\ndef sub(A, B):\n    A1 = A[:]\n    B1 = B[:]\n    n = len(A1)\n    m = len(B1)\n    if n < m:\n        for j in range(len(B1)-len(A1)):\n            A1.append(0)\n    else:\n        for j in range(len(A1)-len(B1)):\n            B1.append(0)\n    B1 = twoComplement(B1)\n    B1 = add(B1, [1])\n    N = max(m, n)\n    C = []\n    carry = 0\n    for j in range(N):\n        C.append(exc_or(A1[j], B1[j], carry))\n        carry = nextcarry(carry, A1[j], B1[j])\n    return C\n\ndef twoComplement(a):\n    for i in range(len(a)):\n        if a[i] & 1 == 1:\n            a[i] = 0\n        else:\n            a[i] = 1\n    return a\n\ndef expo(a, b):\n    if b == dec2bin(1):\n        return a\n    if b == dec2bin(2):\n        return mult(a, a)\n    if even(b):\n        return expo(expo(a, div2(b)), [0, 1])\n    else:\n        return mult(a, expo(expo(a, div2(sub(b, [1]))), dec2bin(2)))\n\n# main function\ndef main_solution(a, b, c, d):\n    a_bin = dec2bin(a)\n    b_bin = dec2bin(b)\n    c_bin = dec2bin(c)\n    d_bin = dec2bin(d)\n    \n    aRaisedb = expo(a_bin, b_bin)\n    cRaisedd = expo(c_bin, d_bin)\n    \n    if compare(aRaisedb, cRaisedd) == 2:\n        remainder = sub(cRaisedd, aRaisedb)\n        return {\"result\": -bin2dec(remainder)}\n    else:\n        remainder = sub(aRaisedb, cRaisedd)\n        return {\"result\": bin2dec(remainder)}", "input_generator": "import random\n\ndef input_generator():\n    # Generate random integers for a, b, c, d within reasonable bounds\n    # To keep the numbers manageable, limit exponents to small values (e.g., 1-5)\n    a = random.randint(1, 10)\n    b = random.randint(1, 5)\n    c = random.randint(1, 10)\n    d = random.randint(1, 5)\n    \n    return {\"a\": a, \"b\": b, \"c\": c, \"d\": d}", "io_pairs": [{"input": {"a": 10, "b": 5, "c": 8, "d": 3}, "output": {"result": 99488}}, {"input": {"a": 7, "b": 5, "c": 10, "d": 2}, "output": {"result": 16707}}, {"input": {"a": 5, "b": 2, "c": 2, "d": 1}, "output": {"result": 23}}, {"input": {"a": 9, "b": 5, "c": 8, "d": 3}, "output": {"result": 58537}}, {"input": {"a": 7, "b": 4, "c": 10, "d": 1}, "output": {"result": 2391}}, {"input": {"a": 7, "b": 1, "c": 1, "d": 1}, "output": {"result": 6}}, {"input": {"a": 2, "b": 1, "c": 10, "d": 3}, "output": {"result": -998}}, {"input": {"a": 9, "b": 4, "c": 9, "d": 1}, "output": {"result": 6552}}, {"input": {"a": 8, "b": 5, "c": 5, "d": 1}, "output": {"result": 32763}}, {"input": {"a": 1, "b": 3, "c": 8, "d": 2}, "output": {"result": -63}}], "error_log": []}
{"context": "Given a number of labeled leaves, how many unrooted binary trees can be formed with that many leaves, modulo 1,000,000?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of labeled leaves in the unrooted binary tree.\n\nOutput:\n  `return` (int): The number of unrooted binary trees with `n` labeled leaves, modulo 1,000,000.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(n):\n    # Convert the input to an integer if it's not already\n    n = int(n)\n    \n    # Calculate the number of unrooted binary trees with n labeled leaves\n    recur = 2 * n - 5\n    product = 1\n    while recur > 1:\n        product = (recur * product) % 1000000\n        recur -= 2\n    \n    # Return the result as an integer\n    return product", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(3, 1000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 941}, "output": 859375}, {"input": {"n": 731}, "output": 390625}, {"input": {"n": 860}, "output": 921875}, {"input": {"n": 451}, "output": 890625}, {"input": {"n": 408}, "output": 546875}, {"input": {"n": 118}, "output": 15625}, {"input": {"n": 165}, "output": 359375}, {"input": {"n": 859}, "output": 390625}, {"input": {"n": 103}, "output": 640625}, {"input": {"n": 674}, "output": 890625}], "error_log": []}
{"context": "Given a range defined by a left limit (`l_limit`) and a right limit (`r_limit`), and a number of nodes (`n`) within this range, what are the values of the polynomial that interpolates the cosine function at these nodes, evaluated at points within the interval with a step size of 0.01?\n\nThe input and output requirements are as follows:\n\nInput:\n  `l_limit` (float): The left limit of the interval over which the polynomial is to be constructed.\n  `r_limit` (float): The right limit of the interval over which the polynomial is to be constructed.\n  `n` (int): The number of nodes (points) to use for constructing the polynomial.\n\nOutput:\n  `return` (list of float): A list of polynomial values evaluated at points within the interval `[l_limit, r_limit]` with a step size of 0.01.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\n# main function\ndef main_solution(l_limit, r_limit, n):\n    # Convert JSON serializable inputs to original input variables\n    x = np.linspace(l_limit, r_limit, n)\n    y = np.cos(x)\n\n    # Construct the equation matrix\n    equation = [[x[i]**j for j in range(len(x))] for i in range(len(x))]\n    equation = np.array(equation)\n\n    # Solve for the polynomial coefficients\n    ai = np.linalg.solve(equation, y)\n\n    # Create the polynomial function\n    polynom = np.poly1d(ai[::-1])\n\n    # Evaluate the polynomial at a set of points for output\n    t = np.arange(l_limit, r_limit, 0.01)\n    polynomial_values = polynom(t).tolist()\n\n    # Return the polynomial values as a JSON serializable output\n    return polynomial_values", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    l_limit = random.uniform(-10.0, 10.0)\n    r_limit = l_limit + random.uniform(1.0, 10.0)\n    n = random.randint(3, 10)\n    return {'l_limit': l_limit, 'r_limit': r_limit, 'n': n}", "io_pairs": [], "error_log": []}
{"context": "Given a grid of cells, where each cell is either white ('O') or black ('X'), how many distinct black shapes are there? A black shape is defined as one or more adjacent 'X' cells (diagonals not included).\n\nThe input and output requirements are as follows:\n\nInput:\n  `field` (str): A string representing the N * M field of 'O's and 'X's. Each row is separated by a newline character ('\\n').\n\nOutput:\n  `return` (int): The number of distinct black shapes in the field.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    # @param A : list of strings\n    # @return an integer\n\n    # if we find one X, there is one shape.\n    # use dfs to visit all connected adjacent X for the same shape.\n    # if we then find another unvisited X, it must belong to a new shape!\n    def black(self, A):\n        def dfs(r, c): # mark all adjacent X as visited\n            stack = [(r,c)]\n            while stack:\n                r, c = stack.pop()\n                for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):\n                    nr, nc = r + dr, c + dc\n                    if (nr, nc) not in visited \\\n                        and 0 <= nr < rows and 0 <= nc < cols \\\n                        and A[nr][nc] == 'X':\n                        stack.append((nr, nc))\n                        visited.add((nr, nc))\n        rows = len(A)\n        cols = len(A[0])\n        visited = set()\n        res = 0\n        for r in range(rows):\n            for c in range(cols):\n                if A[r][c] == 'X' and (r,c) not in visited:\n                    res += 1 # found a new shape\n                    visited.add((r, c)) # mark this X as visited\n                    dfs(r,c) # mark all adjacent X as visited\n        return res\n\n# main function\ndef main_solution(field):\n  # Convert the input field to a list of strings\n  A = field.split('\\n')\n  # Call the black method of the Solution class\n  result = Solution().black(A)\n  # Return the result as an integer\n  return result", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(1, 10)\n    cols = random.randint(1, 10)\n    field = []\n    for _ in range(rows):\n        row = []\n        for _ in range(cols):\n            if random.random() < 0.3:  # 30% chance to be 'X'\n                row.append('X')\n            else:\n                row.append('O')\n        field.append(''.join(row))\n    return {'field': '\\n'.join(field)}", "io_pairs": [{"input": {"field": "XOXOOO"}, "output": 2}, {"input": {"field": "OOOOOOOXX\nOOOOOOOOO\nOOOXOOOOO\nOXOXOXOOO\nOOOOOOOOO\nXOXOOOOOO\nXOOXOXXOO\nOOXOOOXOO"}, "output": 9}, {"input": {"field": "OOOXOX"}, "output": 2}, {"input": {"field": "OOOOXX\nOOOXOO\nXXOOXO\nOXOOOO\nXOOXXO\nOOOOXX\nXOOXXO\nXOOXXO\nOOOOOO"}, "output": 7}, {"input": {"field": "XXXXOOOOO\nOXXOOOXXO\nOOOXOOOOX\nXOOXOOOXX\nOXOOOOOOO\nXOOOOOXXO\nOOOOXOXXO"}, "output": 9}, {"input": {"field": "OOXXOOOOOO\nXOOXOOOXXX\nOXOOOXXOOO\nXXXOXXXOOO"}, "output": 5}, {"input": {"field": "OO\nOO"}, "output": 0}, {"input": {"field": "OXXOXXOOO\nOOOOXOOOX\nOOXXOOXOX\nOXXOXOOOO\nOOOXXXXOO\nOOOXXXOOO\nOOOXOXOOO"}, "output": 6}, {"input": {"field": "OOOOO\nOXOXO\nOOOOO\nOOOOX\nOXOOO\nOOOOO\nOOOXO\nOXXOX"}, "output": 7}, {"input": {"field": "XXOOXOOO\nOOOOOOOO\nOOOOOOOX\nXOOXOXOO\nOOOOOXOX\nOOOOXOXX\nOOOOXXXX"}, "output": 7}], "error_log": []}
{"context": "Given a binary tree and a target sum, what are all the paths from the root node to the leaf nodes that sum up to the target sum? Each path should be represented as a list of node values from the root to the leaf.\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (list of int or None): A list representing the binary tree in level order traversal. Each element represents the value of a node, with `None` indicating a missing node.\n  `target_sum` (int): The target sum for which paths need to be found in the binary tree.\n\nOutput:\n  `return` (str): A JSON serialized string representing a list of lists. Each inner list represents a path in the binary tree that sums up to the `target_sum`.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def find_path(self, root, num):\n        if not root:\n            return None\n        result = []\n\n        def core(root, path, cur):\n            cur += root.val\n            path.append(root.val)\n\n            # \u5224\u65ad\u662f\u5426\u5230\u8fbe\u53f6\u8282\u70b9\n            flag = (root.left == None and root.right == None)\n\n            if flag and cur == num:\n                result.append(path[:])\n\n            if cur < num:\n                if root.left:\n                    core(root.left, path, cur)\n                if root.right:\n                    core(root.right, path, cur)\n            path.pop() # pop is to delete this visited path\n\n        core(root, [], 0)\n        return result\n\n# main function\ndef main_solution(tree_structure, target_sum):\n    # Convert JSON serializable input to original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            node = queue.pop(0)\n            if nodes[i] is not None:\n                node.left = TreeNode(nodes[i])\n                queue.append(node.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                node.right = TreeNode(nodes[i])\n                queue.append(node.right)\n            i += 1\n        return root\n\n    root = build_tree(tree_structure)\n    solution = Solution()\n    paths = solution.find_path(root, target_sum)\n    \n    # Convert output to JSON serializable format\n    return json.dumps(paths)", "input_generator": "import random\nimport json\n\ndef input_generator():\n    # Generate a random binary tree structure as a list (level-order traversal with possible None values)\n    def generate_tree_structure():\n        depth = random.randint(2, 5)  # Reasonable depth for the tree\n        tree = []\n        nodes_in_level = 1\n        for level in range(depth):\n            for _ in range(nodes_in_level):\n                if random.random() > 0.3:  # 70% chance to have a node\n                    tree.append(random.randint(1, 20))  # Node value between 1 and 20\n                else:\n                    tree.append(None)  # No node here\n            nodes_in_level *= 2\n        # Ensure at least one path exists by adding some non-None leaves\n        # Trim the tree to remove trailing None values for compactness\n        while len(tree) > 0 and tree[-1] is None:\n            tree.pop()\n        return tree\n\n    tree_structure = generate_tree_structure()\n    # Generate a target sum that could possibly match some path sums\n    # Choose a sum between 10 and 100 to have reasonable chance of matching\n    target_sum = random.randint(10, 100)\n    \n    return {\n        'tree_structure': tree_structure,\n        'target_sum': target_sum\n    }", "io_pairs": [{"input": {"tree_structure": [18, 7, 12, null, 14, 5], "target_sum": 45}, "output": "[]"}, {"input": {"tree_structure": [18, null, 3, null, 20, null, 6], "target_sum": 20}, "output": "[]"}, {"input": {"tree_structure": [3, 2, 8], "target_sum": 55}, "output": "[]"}, {"input": {"tree_structure": [2, 8, 7], "target_sum": 69}, "output": "[]"}, {"input": {"tree_structure": [9, null, null, 4, 9, 19, 17], "target_sum": 38}, "output": "[]"}, {"input": {"tree_structure": [18, 4, 18], "target_sum": 47}, "output": "[]"}, {"input": {"tree_structure": [18, null, 19], "target_sum": 63}, "output": "[]"}, {"input": {"tree_structure": [15, 10, 1], "target_sum": 79}, "output": "[]"}, {"input": {"tree_structure": [19, 5, 5, 9, 8, null, 10], "target_sum": 88}, "output": "[]"}, {"input": {"tree_structure": [9, 5, null, 1, 16, 16, 7], "target_sum": 43}, "output": "[]"}], "error_log": []}
{"context": "In a memory reallocation routine, there are multiple memory banks, each holding a certain number of blocks. The routine aims to balance the blocks between the memory banks by redistributing them in cycles. In each cycle, the memory bank with the most blocks (ties won by the lowest-numbered bank) has its blocks redistributed among the banks. The process continues until a configuration is repeated. Given the initial block counts in the memory banks, how many redistribution cycles must be completed before a configuration is produced that has been seen before?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_blocks` (str): A string representing the initial block counts in the memory banks, separated by spaces.\n\nOutput:\n  `return` (int): The number of redistribution cycles required before a configuration is produced that has been seen before.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(initial_blocks):\n    # Convert the input list of strings to integers\n    inp = [int(x) for x in initial_blocks.split()]\n    # Maintain a set of seen states\n    seen = set()\n    # And maintain the step count\n    for count in itertools.count():\n        # Break if we have seen this state before\n        if tuple(inp) in seen:\n            break\n        seen.add(tuple(inp))\n        # Find the first largest bucket index\n        index = inp.index(max(inp))\n        # Note how big it is and zero it\n        num = inp[index]\n        inp[index] = 0\n        # Redistribute the data starting with the next index\n        index += 1\n        for i in range(0, num):\n            inp[(index + i) % len(inp)] += 1\n    # Return the steps before we see the same state twice\n    return count", "input_generator": "import random\n\ndef input_generator():\n    num_blocks = random.randint(5, 10)\n    blocks = [random.randint(0, 15) for _ in range(num_blocks)]\n    return {'initial_blocks': ' '.join(map(str, blocks))}", "io_pairs": [{"input": {"initial_blocks": "0 8 0 2 9 0"}, "output": 13}, {"input": {"initial_blocks": "10 5 7 10 14 13 3"}, "output": 17}, {"input": {"initial_blocks": "1 4 1 11 2 15 5"}, "output": 71}, {"input": {"initial_blocks": "2 12 0 5 10 14 4 7"}, "output": 42}, {"input": {"initial_blocks": "6 12 8 13 7 2 8 3 8 13"}, "output": 42}, {"input": {"initial_blocks": "14 9 9 10 0 0"}, "output": 15}, {"input": {"initial_blocks": "7 10 2 7 9"}, "output": 19}, {"input": {"initial_blocks": "7 10 15 1 10 3 4 8 0 12"}, "output": 160}, {"input": {"initial_blocks": "2 13 3 2 15 4"}, "output": 13}, {"input": {"initial_blocks": "0 7 4 14 8 15 14 0 11 4"}, "output": 29}], "error_log": []}
{"context": "Given a set of observations with X and Y values, how can we estimate the value of Y at a specific X using Newton's forward interpolation method?\n\nThe input and output requirements are as follows:\n\nInput:\n- `observations` (int): The number of observations.\n- `x_values` (list of float): The list of X values.\n- `y_values` (list of float): The list of Y values corresponding to the X values.\n- `interpol_x` (float): The X value at which to estimate Y.\n\nOutput:\n- `interpolated_y` (float): The estimated value of Y at the given X.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(observations, x_values, y_values, interpol_x):\n    \"\"\"\n    This function performs Newton's forward interpolation to estimate the value of Y at a given X.\n    \n    Parameters:\n    - observations (int): The number of observations.\n    - x_values (list of float): The list of X values.\n    - y_values (list of float): The list of Y values corresponding to the X values.\n    - interpol_x (float): The X value at which to estimate Y.\n    \n    Returns:\n    - interpolated_y (float): The estimated value of Y at the given X.\n    \"\"\"\n    \n    def ncr(n, r):\n        numerator = 1\n        denominator1 = 1\n        denominator2 = 1\n        for i in range(1, n + 1):\n            numerator *= i\n        for i in range(1, r + 1):\n            denominator1 *= i\n        for i in range(1, (n - r + 1)):\n            denominator2 *= i\n        return numerator // (denominator1 * denominator2)\n    \n    delta_y = []\n    for t in range(1, observations):\n        k = 0\n        for i in range(t + 1):\n            k += ncr(t, i) * y_values[t - i] * ((-1) ** i)\n        delta_y.append(k)\n    \n    p = (interpol_x - x_values[0]) / (x_values[1] - x_values[0])\n    interpolated_y = y_values[0]\n    deno = 1\n    l = 1\n    for i in range(observations - 1):\n        deno *= (i + 1)\n        l *= (p - i)\n        interpolated_y += (l / deno) * delta_y[i]\n    \n    return interpolated_y", "input_generator": "import random\n\ndef input_generator():\n    observations = random.randint(3, 10)\n    x_start = random.uniform(-10.0, 10.0)\n    x_step = random.uniform(0.5, 2.0)\n    x_values = [x_start + i * x_step for i in range(observations)]\n    y_values = [random.uniform(-100.0, 100.0) for _ in range(observations)]\n    min_x = min(x_values)\n    max_x = max(x_values)\n    interpol_x = random.uniform(min_x, max_x)\n    \n    return {\n        'observations': observations,\n        'x_values': x_values,\n        'y_values': y_values,\n        'interpol_x': interpol_x\n    }", "io_pairs": [{"input": {"observations": 3, "x_values": [1.3986799303099655, 2.2475841044843587, 3.096488278658752], "y_values": [-97.65673053071473, -5.3013004252457705, -78.84320004419834], "interpol_x": 2.6281737693246283}, "output": -17.756664423192987}, {"input": {"observations": 4, "x_values": [7.589223031764156, 8.856912546943795, 10.124602062123433, 11.39229157730307], "y_values": [74.15455078316708, 64.97854577147234, 52.81272847699199, 21.146018488413816], "interpol_x": 8.472079780367775}, "output": 67.3217591164748}, {"input": {"observations": 5, "x_values": [2.6348091636077893, 3.430893387512686, 4.226977611417583, 5.023061835322481, 5.819146059227378], "y_values": [42.82320046412124, -81.27255471574188, 77.24394116387921, 35.62671827549423, 45.727600137436525], "interpol_x": 3.8350364522135685}, "output": 11.413575615682333}, {"input": {"observations": 3, "x_values": [-9.34560210122286, -8.03358635080435, -6.72157060038584], "y_values": [75.67653187512204, 94.0678721217534, -14.735088451110954], "interpol_x": -8.983406659229004}, "output": 93.46360486928937}, {"input": {"observations": 5, "x_values": [-3.264756264416004, -1.7273755603807763, -0.1899948563455487, 1.3473858476896794, 2.8847665517249066], "y_values": [38.72231336228512, 73.10617590892693, 84.85383578706626, -10.033861084342163, 7.328914936944656], "interpol_x": -2.806422257330944}, "output": 34.21303341158246}, {"input": {"observations": 5, "x_values": [9.154458256077113, 9.76091373171872, 10.367369207360325, 10.973824683001931, 11.580280158643536], "y_values": [61.0728586741063, 51.09556125970886, 12.88753702295611, 6.583175717168373, 26.492099401332254], "interpol_x": 9.374942996008057}, "output": 67.2444926931938}, {"input": {"observations": 5, "x_values": [-9.125032607870917, -8.098826349200685, -7.072620090530453, -6.046413831860221, -5.020207573189989], "y_values": [-33.34400360394663, -48.1814661730463, -73.19491873897871, 9.280341464656232, 7.06279817164048], "interpol_x": -7.994349495766114}, "output": -54.707728539403874}, {"input": {"observations": 4, "x_values": [5.979685345381636, 7.24966442239341, 8.519643499405184, 9.789622576416956], "y_values": [28.16578523436263, -41.13916660683539, -92.37471001265767, 22.667972140987388], "interpol_x": 7.276907863372313}, "output": -42.95756836745041}, {"input": {"observations": 4, "x_values": [6.138511827751049, 6.674265458340942, 7.210019088930835, 7.745772719520727], "y_values": [17.052448005360347, 89.06759979162538, 13.717006818764332, -0.38272082844660815], "interpol_x": 7.62764545211923}, "output": -13.171824165661349}, {"input": {"observations": 5, "x_values": [-7.8410222242357275, -6.62694255618702, -5.412862888138311, -4.198783220089602, -2.9847035520408944], "y_values": [-42.92996597506165, -20.154243443385923, -10.500702755897677, 20.34768093498724, -13.610805662153751], "interpol_x": -7.028261628917054}, "output": -21.106828697468632}], "error_log": []}
{"context": "Given the initial state of a row of 8 prison cells, where each cell is either occupied or vacant, and a number of days, determine the state of the prison cells after that many days. Each day, the state of a cell changes based on the states of its adjacent cells. If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant. The first and last cells in the row do not have two adjacent neighbors. What will be the state of the prison cells after N days?\n\nThe input and output requirements are as follows:\n\nInput:\n  `cells` (tuple of integers): A tuple of 8 integers where each integer is either 0 (vacant) or 1 (occupied). This represents the initial state of the prison cells.\n  `N` (integer): The number of days to simulate the prison cell state changes.\n\nOutput:\n  `return` (tuple of integers): A tuple of 8 integers representing the state of the prison cells after N days. Each integer is either 0 (vacant) or 1 (occupied).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution957:\n    def prisonAfterNDays(self, cells, N):\n        def nextDay(cells):\n            return [int(i > 0 and i < 7 and cells[i-1] == cells[i+1]) for i in range(8)]\n        \n        seen = {}\n        while N > 0:\n            c = tuple(cells)\n            if c in seen:\n                N %= seen[c] - N\n            seen[c] = N\n            \n            if N >= 1:\n                N -= 1\n                cells = nextDay(cells)\n        \n        return cells\n\n# main function\ndef main_solution(cells, N):\n    # Convert list to tuple for JSON serializable input\n    cells = tuple(cells)\n    \n    # Create an instance of the Solution957 class\n    solution = Solution957()\n    \n    # Call the prisonAfterNDays method\n    result = solution.prisonAfterNDays(list(cells), N)\n    \n    # Convert the result back to tuple for JSON serializable output\n    return tuple(result)", "input_generator": "import random\n\ndef input_generator():\n    cells = [random.randint(0, 1) for _ in range(8)]\n    N = random.randint(1, 100)\n    return {'cells': cells, 'N': N}", "io_pairs": [{"input": {"cells": [1, 1, 1, 0, 1, 0, 1, 1], "N": 57}, "output": [0, 1, 0, 1, 1, 1, 0, 0]}, {"input": {"cells": [0, 0, 1, 0, 0, 1, 1, 1], "N": 16}, "output": [0, 0, 1, 0, 1, 0, 1, 0]}, {"input": {"cells": [0, 0, 0, 0, 0, 1, 0, 1], "N": 95}, "output": [0, 1, 1, 0, 1, 0, 0, 0]}, {"input": {"cells": [1, 0, 0, 1, 1, 0, 0, 1], "N": 96}, "output": [0, 1, 0, 0, 0, 0, 1, 0]}, {"input": {"cells": [1, 1, 0, 1, 1, 0, 1, 0], "N": 81}, "output": [0, 0, 1, 0, 1, 1, 0, 0]}, {"input": {"cells": [0, 0, 1, 1, 1, 0, 1, 1], "N": 83}, "output": [0, 0, 0, 0, 1, 0, 1, 0]}, {"input": {"cells": [0, 1, 0, 0, 1, 1, 0, 0], "N": 44}, "output": [0, 1, 0, 1, 1, 1, 1, 0]}, {"input": {"cells": [1, 0, 1, 0, 1, 0, 0, 0], "N": 39}, "output": [0, 1, 0, 1, 0, 1, 1, 0]}, {"input": {"cells": [1, 0, 0, 1, 0, 0, 0, 0], "N": 14}, "output": [0, 0, 1, 1, 1, 0, 1, 0]}, {"input": {"cells": [1, 0, 1, 0, 1, 1, 1, 1], "N": 64}, "output": [0, 1, 1, 0, 1, 1, 1, 0]}], "error_log": []}
{"context": "Given the starting position of a king on an 8x8 chessboard and the number of moves it can make, what is the probability that the king remains on the board after making all the moves?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (int): The x-coordinate of the king's starting position on an 8x8 chessboard (0 \u2264 x \u2264 7).\n  `y` (int): The y-coordinate of the king's starting position on an 8x8 chessboard (0 \u2264 y \u2264 7).\n  `N` (int): The number of moves the king can make (0 \u2264 N \u2264 10).\n\nOutput:\n  `return` (float): The probability that the king remains on the board after N moves, rounded to four decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass KingProbability:\n    def remainOnBoardProb(self, x, y, N):\n        DP = [[0.0 for _ in range(8)] for _ in range(8)]\n        DP[x][y] = 1.0\n\n        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n\n        for _ in range(N):\n            newDP = [[0.0 for _ in range(8)] for _ in range(8)]\n            for i in range(8):\n                for j in range(8):\n                    if DP[i][j] > 0:\n                        for dx, dy in directions:\n                            ni, nj = i + dx, j + dy\n                            if 0 <= ni < 8 and 0 <= nj < 8:\n                                newDP[ni][nj] += DP[i][j] / 8.0\n            DP = newDP\n\n        return sum(sum(row) for row in DP)\n\n# main function\ndef main_solution(x, y, N):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert JSON serializable inputs to the original input variables\n    x = int(x)\n    y = int(y)\n    N = int(N)\n    \n    # Create an instance of KingProbability and calculate the probability\n    king_prob = KingProbability()\n    result = king_prob.remainOnBoardProb(x, y, N)\n    \n    # Convert the result to a JSON serializable output\n    return round(result, 4)", "input_generator": "import random\n\ndef input_generator():\n    x = random.randint(0, 7)\n    y = random.randint(0, 7)\n    N = random.randint(1, 20)\n    return {'x': x, 'y': y, 'N': N}", "io_pairs": [{"input": {"x": 0, "y": 2, "N": 16}, "output": 0.1066}, {"input": {"x": 3, "y": 0, "N": 18}, "output": 0.1007}, {"input": {"x": 1, "y": 2, "N": 11}, "output": 0.3197}, {"input": {"x": 3, "y": 4, "N": 4}, "output": 0.9607}, {"input": {"x": 5, "y": 0, "N": 11}, "output": 0.1707}, {"input": {"x": 2, "y": 6, "N": 4}, "output": 0.6553}, {"input": {"x": 5, "y": 0, "N": 14}, "output": 0.1285}, {"input": {"x": 3, "y": 1, "N": 20}, "output": 0.1571}, {"input": {"x": 7, "y": 1, "N": 11}, "output": 0.1272}, {"input": {"x": 7, "y": 7, "N": 5}, "output": 0.1389}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, the AI player needs to decide the best move based on the current state of the board. Given the current state of the board represented by a 3x3 matrix, where each cell can be either empty ('-'), occupied by the AI player ('O'), or occupied by the human player ('+'), what is the optimal move for the AI player? The AI player aims to maximize its chances of winning or at least securing a draw.\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of str): A 3x3 matrix representing the Tic-Tac-Toe board. Each element can be one of three values: '-', 'O', or '+'.\n\nOutput:\n  `return` (dict): A dictionary containing the best move for the AI player. The dictionary has two keys:\n    - `row` (int): The row number (1-3) of the best move.\n    - `col` (int): The column number (1-3) of the best move.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass create_env:\n    def __init__(self, matrix):\n        self.matrix = matrix\n        \n    def get_element(self, row, col):\n        return self.matrix[row-1][col-1]\n    \n    def update(self, row, col, mark):\n        self.matrix[row-1][col-1] = mark\n    \n    def is_full(self):\n        cnt = 0\n        for i in range(3):\n            for j in range(3):\n                cnt += (self.matrix[i][j] == '-')\n        return cnt == 0\n\nclass minimax:\n    def __init__(self, matrix):\n        self.matrix = matrix\n        self.row = -1\n        self.col = -1\n    \n    def is_full(self):\n        cnt = 0\n        for i in range(3):\n            for j in range(3):\n                cnt += (self.matrix[i][j] == '-')\n        return cnt == 0\n    \n    def reward(self):\n        # row checker\n        for i in range(3):\n            sc1, sc2 = 0, 0\n            for j in range(3):\n                sc1 += (self.matrix[i][j] == 'O')\n                sc2 += (self.matrix[i][j] == '+')\n            if sc1 == 3:\n                return 1\n            if sc2 == 3:\n                return -1\n            \n        # col checker\n        for i in range(3):\n            sc1, sc2 = 0, 0\n            for j in range(3):\n                sc1 += (self.matrix[j][i] == 'O')\n                sc2 += (self.matrix[j][i] == '+')\n            if sc1 == 3:\n                return 1\n            if sc2 == 3:\n                return -1\n            \n        # diagonal1 checker\n        sc1, sc2 = 0, 0\n        for i in range(3):\n            sc1 += (self.matrix[i][i] == 'O')\n            sc2 += (self.matrix[i][i] == '+')\n        if sc1 == 3:\n            return 1\n        if sc2 == 3:\n            return -1\n        \n        # diagonal2 checker\n        sc1, sc2 = 0, 0 \n        for i in range(3):\n            sc1 += (self.matrix[i][(2-i)] == 'O')\n            sc2 += (self.matrix[i][(2-i)] == '+')\n        if sc1 == 3:\n            return 1\n        if sc2 == 3:\n            return -1\n        return 0\n        \n    def get_row_col(self, mx):\n        if mx:\n            best = [-1000, -1, -1]\n        else:\n            best = [1000, -1, -1]\n\n        if self.is_full() or self.reward() in [-1, 1]:\n            return [self.reward(), -1, -1] \n        \n        if mx:\n            for i in range(3):\n                for j in range(3):\n                    if self.matrix[i][j] == '-':\n                        self.matrix[i][j] = 'O'\n                        score = self.get_row_col(False)\n                        self.matrix[i][j] = '-'\n                        score[1], score[2] = i+1, j+1\n                        if score[0] > best[0]:\n                            best = score\n            return best\n                        \n        if not mx:\n            for i in range(3):\n                for j in range(3):\n                    if self.matrix[i][j] == '-':\n                        self.matrix[i][j] = '+'\n                        score = self.get_row_col(True)\n                        self.matrix[i][j] = '-'\n                        score[1], score[2] = i+1, j+1\n                        if score[0] < best[0]:\n                            best = score\n            return best\n\n# main function\ndef main_solution(matrix):\n    # Convert the input matrix to a list of lists if it's not already\n    if not isinstance(matrix, list):\n        raise ValueError(\"Input matrix must be a list of lists\")\n    \n    env = create_env(matrix)\n    A = minimax(env.matrix)\n    best = A.get_row_col(True)\n    \n    # Return the best move as a dictionary\n    return {\"row\": best[1], \"col\": best[2]}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a 3x3 Tic-Tac-Toe board with some random moves\n    marks = ['O', '+', '-']\n    matrix = [['-' for _ in range(3)] for _ in range(3)]\n    \n    # Randomly decide the number of moves already made (between 0 and 8)\n    num_moves = random.randint(0, 8)\n    current_mark = 'O' if random.choice([True, False]) else '+'\n    \n    for _ in range(num_moves):\n        empty_positions = [(i, j) for i in range(3) for j in range(3) if matrix[i][j] == '-']\n        if not empty_positions:\n            break\n        i, j = random.choice(empty_positions)\n        matrix[i][j] = current_mark\n        current_mark = 'O' if current_mark == '+' else '+'\n    \n    return {\"matrix\": matrix}", "io_pairs": [{"input": {"matrix": [["-", "-", "O"], ["+", "+", "+"], ["-", "O", "-"]]}, "output": {"row": -1, "col": -1}}, {"input": {"matrix": [["O", "-", "-"], ["-", "-", "-"], ["-", "-", "+"]]}, "output": {"row": 1, "col": 3}}, {"input": {"matrix": [["+", "O", "O"], ["+", "-", "-"], ["-", "+", "O"]]}, "output": {"row": 2, "col": 3}}, {"input": {"matrix": [["-", "-", "-"], ["-", "O", "-"], ["+", "-", "-"]]}, "output": {"row": 1, "col": 1}}, {"input": {"matrix": [["+", "-", "O"], ["O", "-", "O"], ["+", "+", "-"]]}, "output": {"row": 2, "col": 2}}, {"input": {"matrix": [["O", "-", "-"], ["-", "-", "-"], ["-", "+", "+"]]}, "output": {"row": 3, "col": 1}}, {"input": {"matrix": [["+", "-", "O"], ["-", "O", "-"], ["+", "-", "-"]]}, "output": {"row": 2, "col": 1}}, {"input": {"matrix": [["O", "-", "-"], ["-", "-", "+"], ["-", "-", "+"]]}, "output": {"row": 1, "col": 3}}, {"input": {"matrix": [["+", "-", "-"], ["+", "-", "-"], ["-", "O", "O"]]}, "output": {"row": 3, "col": 1}}, {"input": {"matrix": [["-", "-", "O"], ["+", "O", "-"], ["-", "+", "O"]]}, "output": {"row": 1, "col": 1}}], "error_log": []}
{"context": "Given a range of numbers and a maximum number of iterations, how many numbers within that range are Lychrel numbers, which do not form a palindrome when iteratively adding their reverse within the specified iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `max_iter` (int): The maximum number of iterations to check if a number becomes a palindrome.\n  `upper_bound` (int): The upper limit of the range of numbers to check for Lychrel numbers.\n\nOutput:\n  `return` (int): The count of Lychrel numbers found within the specified range and iterations.", "reference_code": "# import necessary packages\nfrom datetime import datetime\n\n# all class and function definitions in the code file, if any\ndef getRev(num):\n    s = str(num)\n    return int(s[::-1])\n\ndef rad(num):\n    return num + getRev(num)\n\ndef isPal(num):\n    n = str(num)\n    l = len(n)\n    for i in range(l // 2 + 1):\n        if n[i] != n[l-i-1]:\n            return False\n    return True\n\n# main function\ndef main_solution(max_iter, upper_bound):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    count = 0\n    x = 1\n    while x < upper_bound:\n        flag = False\n        i = 0\n        y = rad(x)\n        while not flag and i < max_iter:\n            flag = isPal(y)\n            i += 1\n            y = rad(y)\n        if flag:\n            count += 1\n        x += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count", "input_generator": "import random\n\ndef input_generator():\n    max_iter = random.randint(5, 20)\n    upper_bound = random.randint(100, 10000)\n    return {'max_iter': max_iter, 'upper_bound': upper_bound}", "io_pairs": [{"input": {"max_iter": 8, "upper_bound": 8757}, "output": 8112}, {"input": {"max_iter": 18, "upper_bound": 9147}, "output": 8845}, {"input": {"max_iter": 15, "upper_bound": 8484}, "output": 8139}, {"input": {"max_iter": 7, "upper_bound": 5883}, "output": 5525}, {"input": {"max_iter": 8, "upper_bound": 4843}, "output": 4576}, {"input": {"max_iter": 16, "upper_bound": 8815}, "output": 8499}, {"input": {"max_iter": 15, "upper_bound": 1535}, "output": 1496}, {"input": {"max_iter": 12, "upper_bound": 9654}, "output": 9083}, {"input": {"max_iter": 15, "upper_bound": 8493}, "output": 8146}, {"input": {"max_iter": 5, "upper_bound": 1574}, "output": 1455}], "error_log": []}
{"context": "In a game of falling jewels, a new faller consisting of three jewels is introduced. The faller has a top, middle, and bottom jewel. The game board is a 13x6 grid, and the faller starts at the top of a randomly chosen column. The faller can either float, land, or freeze in place. After the faller has fallen, determine if there are any matching jewels on the board, if the faller has frozen, and if the game is over due to the faller not being able to fall. What are the results of the faller's action on the game board?\n\nThe input and output requirements are as follows:\n\nInput:\n  `topF` (str): The top jewel of the faller.\n  `midF` (str): The middle jewel of the faller.\n  `botF` (str): The bottom jewel of the faller.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `isMatching` (bool): Indicates if there are any matching jewels after the faller has fallen.\n    - `hasFroze` (bool): Indicates if the faller has frozen in place.\n    - `gameOver` (bool): Indicates if the game is over due to the faller not being able to fall.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass GameState:\n    def __init__(self) -> None:\n        self._field = []\n\n    def initialize_field(self) -> list:\n        rows = 13\n        cols = 6\n        for i in range(rows + 1):\n            self._field.append([])\n            for j in range(cols):\n                if i == rows:\n                    self._field[i].append('---')\n                else:\n                    self._field[i].append('   ')\n        return self._field\n\nclass Faller:\n    def __init__(self, topF: str, midF: str, botF: str) -> None:\n        self._topF = topF\n        self._midF = midF\n        self._botF = botF\n        self._row = 0\n        self._col = random.randint(1, 6)\n        self._faller_state = 0\n\n    def show_faller_info(self) -> tuple:\n        return self._topF, self._midF, self._botF, self._col, self._faller_state\n\n    def show_column_info(self) -> tuple:\n        return self._topF, self._midF, self._botF\n\n    def show_current_row_col(self) -> tuple:\n        return self._row, self._col\n\n    def show_column_state(self) -> int:\n        return self._faller_state\n\n    def faller_rotating(self, topF: str, midF: str, botF: str) -> tuple:\n        self._topF = botF\n        self._midF = topF\n        self._botF = midF\n        return self._topF, self._midF, self._botF\n\n    def faller_right(self) -> int:\n        self._col += 1\n        return self._col\n\n    def faller_left(self) -> int:\n        self._col -= 1\n        return self._col\n\n    def faller_next_state(self) -> int:\n        self._faller_state += 1\n        return self._faller_state\n\n    def faller_previous_state(self) -> int:\n        self._faller_state -= 1\n        return self._faller_state\n\n    def next_row(self) -> int:\n        self._row += 1\n        return self._row\n\ndef faller_falling(fallerObj: Faller, gameField: list) -> tuple:\n    topF, midF, botF = fallerObj.show_column_info()\n    row, col = fallerObj.show_current_row_col()\n    fallState = fallerObj.show_column_state()\n    col = col - 1\n    isMatching = False\n    hasFroze = False\n    gameOver = False\n    emptyCount = 0\n    for i in range(len(gameField)):\n        if gameField[i][col] == '   ':\n            emptyCount += 1\n    if emptyCount == 0 and fallState != 1:\n        gameOver = True\n        return isMatching, hasFroze, gameOver\n    if fallState == 0:\n        if gameField[row + 1][col] != '   ':\n            fallerObj.faller_next_state()\n            tF, mF, bF = _faller_status(fallerObj)\n        else:\n            tF, mF, bF = _faller_status(fallerObj)\n        if row >= 0:\n            gameField[row][col] = bF\n        if row - 1 >= 0:\n            gameField[row - 1][col] = mF\n        if row - 2 >= 0:\n            gameField[row - 2][col] = tF\n        gameField[len(gameField) - 1][col] = '---'\n        i = 3\n        while row - i >= 0:\n            gameField[row - i][col] = '   '\n            i += 1\n    else:\n        tF = f\" {topF} \"\n        mF = f\" {midF} \"\n        bF = f\" {botF} \"\n        if row - 1 >= 0:\n            gameField[row - 1][col] = bF\n        if row - 2 >= 0:\n            gameField[row - 2][col] = mF\n        if row - 3 >= 0:\n            gameField[row - 3][col] = tF\n        hasFroze = True\n        isMatching = _winning_conditions(gameField)\n        if not isMatching and row - 3 < 0:\n            gameOver = True\n    fallerObj.next_row()\n    return isMatching, hasFroze, gameOver\n\ndef _faller_status(fallerObj: Faller) -> tuple:\n    topF, midF, botF = fallerObj.show_column_info()\n    fallState = fallerObj.show_column_state()\n    if fallState == 0:\n        bF = f\"[{botF}]\"\n        mF = f\"[{midF}]\"\n        tF = f\"[{topF}]\"\n    elif fallState == 1:\n        bF = f\"|{botF}|\"\n        mF = f\"|{midF}|\"\n        tF = f\"|{topF}|\"\n    else:\n        bF = f\" {botF} \"\n        mF = f\" {midF} \"\n        tF = f\" {topF} \"\n    return tF, mF, bF\n\ndef _winning_conditions(gameField: list) -> bool:\n    maxRow = len(gameField) - 1\n    maxCol = len(gameField[0])\n    isMatching = False\n    for col in range(maxCol):\n        matchCounter = 1\n        for row in range(1, maxRow):\n            if gameField[row][col][1] == gameField[row - 1][col][1] and gameField[row][col] != '   ':\n                matchCounter += 1\n                if matchCounter >= 3 and gameField[row][col][1] != gameField[row + 1][col][1]:\n                    isMatching = True\n                    theJewel = gameField[row][col].strip().strip('*')\n                    for i in range(matchCounter):\n                        gameField[row - i][col] = f\"*{theJewel}*\"\n            else:\n                matchCounter = 1\n    for row in range(maxRow):\n        matchCounter = 1\n        for col in range(1, maxCol):\n            if gameField[row][col][1] == gameField[row][col - 1][1] and gameField[row][col] != '   ':\n                matchCounter += 1\n                if matchCounter >= 3 and (col >= maxCol - 1 or gameField[row][col][1] != gameField[row][col + 1][1]):\n                    isMatching = True\n                    theJewel = gameField[row][col].strip().strip('*')\n                    for i in range(matchCounter):\n                        gameField[row][col - i] = f\"*{theJewel}*\"\n            else:\n                matchCounter = 1\n    return isMatching\n\n# main function\ndef main_solution(topF: str, midF: str, botF: str) -> dict:\n    # Initialize game state and faller\n    game_state = GameState()\n    game_field = game_state.initialize_field()\n    faller = Faller(topF, midF, botF)\n    \n    # Simulate the faller falling\n    isMatching, hasFroze, gameOver = faller_falling(faller, game_field)\n    \n    # Return the result\n    return {\n        \"isMatching\": isMatching,\n        \"hasFroze\": hasFroze,\n        \"gameOver\": gameOver\n    }", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate random single uppercase letters for the faller pieces\n    topF = random.choice(string.ascii_uppercase)\n    midF = random.choice(string.ascii_uppercase)\n    botF = random.choice(string.ascii_uppercase)\n    \n    return {\n        \"topF\": topF,\n        \"midF\": midF,\n        \"botF\": botF\n    }", "io_pairs": [{"input": {"topF": "X", "midF": "F", "botF": "K"}, "output": {"isMatching": false, "hasFroze": false, "gameOver": false}}, {"input": {"topF": "R", "midF": "W", "botF": "S"}, "output": {"isMatching": false, "hasFroze": false, "gameOver": false}}, {"input": {"topF": "Y", "midF": "A", "botF": "R"}, "output": {"isMatching": false, "hasFroze": false, "gameOver": false}}, {"input": {"topF": "K", "midF": "I", "botF": "I"}, "output": {"isMatching": false, "hasFroze": false, "gameOver": false}}, {"input": {"topF": "X", "midF": "L", "botF": "K"}, "output": {"isMatching": false, "hasFroze": false, "gameOver": false}}, {"input": {"topF": "B", "midF": "V", "botF": "W"}, "output": {"isMatching": false, "hasFroze": false, "gameOver": false}}, {"input": {"topF": "F", "midF": "F", "botF": "O"}, "output": {"isMatching": false, "hasFroze": false, "gameOver": false}}, {"input": {"topF": "Q", "midF": "K", "botF": "O"}, "output": {"isMatching": false, "hasFroze": false, "gameOver": false}}, {"input": {"topF": "W", "midF": "K", "botF": "Z"}, "output": {"isMatching": false, "hasFroze": false, "gameOver": false}}, {"input": {"topF": "S", "midF": "A", "botF": "D"}, "output": {"isMatching": false, "hasFroze": false, "gameOver": false}}], "error_log": []}
{"context": "In a high-stakes casino, security is paramount. Recently, there have been reports of money being stolen from the casino floor. The security team has installed a sophisticated system that captures the layout of the floor in the form of a string. The string contains specific characters representing different elements on the floor: empty spaces ('x'), thieves ('T'), guards ('G'), and money ('$'). The system needs to determine if any money is at risk of being stolen by checking if there is a thief adjacent to the money with no guard in between. Given the layout of the casino floor, can you determine if the money is safe or if an alarm should be triggered?\n\nThe input and output requirements are as follows:\n\nInput:\n  `casino_layout` (str): A string representing the layout of the casino floor. The string can contain the following characters:\n    - 'x': Empty space\n    - 'T': Thief\n    - 'G': Guard\n    - '$': Money\n\nOutput:\n  `return` (str): A string indicating the security status of the casino. It can be either:\n    - \"ALARM!\": If a thief is detected next to money with no guard in between.\n    - \"Safe\": If all money is protected by a guard or if there are no thieves or no money.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef security(txt):\n    a, x, T, G, S = [], [], [], [], []\n    \n    for i in txt: \n        if i != \"x\": a.append(i)\n    \n    for i in range(len(a)):\n        if a[i]==\"T\": T.append(i)\n        elif a[i]==\"G\": G.append(i)    \n        elif a[i]==\"$\": S.append(i)    \n    \n    if len(T) == 0 or len(S)==0: return \"Safe\"\n\n    for i in T:\n        for j in S:\n            if abs(i-j) == 1: return \"ALARM!\"\n\n    return \"Safe\"\n\n# main function\ndef main_solution(casino_layout):\n    # Convert the input string to a list of characters excluding 'x'\n    a = [char for char in casino_layout if char != 'x']\n    \n    # Identify positions of Thieves (T), Guards (G), and Money ($)\n    T, G, S = [], [], []\n    for i, char in enumerate(a):\n        if char == 'T':\n            T.append(i)\n        elif char == 'G':\n            G.append(i)\n        elif char == '$':\n            S.append(i)\n    \n    # Check if there are no Thieves or no Money\n    if not T or not S:\n        return \"Safe\"\n    \n    # Check if any Thief is adjacent to any Money\n    for thief in T:\n        for money in S:\n            if abs(thief - money) == 1:\n                return \"ALARM!\"\n    \n    return \"Safe\"", "input_generator": "import random\n\ndef input_generator():\n    characters = ['T', 'G', '$', 'x']\n    weights = [0.1, 0.2, 0.1, 0.6]  # Higher probability for 'x' to make it more realistic\n    \n    length = random.randint(5, 20)\n    casino_layout = ''.join(random.choices(characters, weights=weights, k=length))\n    \n    return {'casino_layout': casino_layout}", "io_pairs": [{"input": {"casino_layout": "Gxxxxx$xxTT$xTT$"}, "output": "ALARM!"}, {"input": {"casino_layout": "GxGxxTG"}, "output": "Safe"}, {"input": {"casino_layout": "xxxx$GGGxx"}, "output": "Safe"}, {"input": {"casino_layout": "xxxxxGxGxT$xxxTx"}, "output": "ALARM!"}, {"input": {"casino_layout": "TxxxxG"}, "output": "Safe"}, {"input": {"casino_layout": "xGGGGx"}, "output": "Safe"}, {"input": {"casino_layout": "Gxxxxx$$xxT$$"}, "output": "ALARM!"}, {"input": {"casino_layout": "xxxxxxxGTTx"}, "output": "Safe"}, {"input": {"casino_layout": "xxTTxxGGG"}, "output": "Safe"}, {"input": {"casino_layout": "GxxxxxTxxxTGTxxxG"}, "output": "Safe"}], "error_log": []}
{"context": "Given a musical equal temperament (ET) system with a certain number of divisions, and a fraction representing a musical interval, what is the closest division in the ET system that approximates this interval, and what is the error percentage between the closest division and the actual interval?\n\nThe input and output requirements are as follows:\n\nInput:\n  `division` (int): The number of divisions in the equal temperament (ET) system.\n  `fraction_str` (str): A string representing a fraction in the format \"numerator/denominator\".\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `fraction` (str): The input fraction as a string.\n    - `closest_division` (int): The closest division in the given ET system.\n    - `error_percentage` (float): The error percentage between the closest division and the actual fraction.", "reference_code": "# import necessary packages\nfrom fractions import Fraction\nfrom math import floor, log\n\n# main function\ndef main_solution(division, fraction_str):\n    # Convert the input fraction string to a Fraction object\n    f = Fraction(fraction_str)\n    \n    # Calculate the closest division in the given equal temperament (ET)\n    closest_int = floor(division * (log(f) / log(2)) + .5)\n    \n    # Calculate the error percentage\n    error = ((2.0**(float(closest_int)/division))/f - 1.0) * 100.0\n    \n    # Return the results as a dictionary\n    return {\n        \"fraction\": str(f),\n        \"closest_division\": int(closest_int),\n        \"error_percentage\": float(error)\n    }", "input_generator": "import random\nfrom fractions import Fraction\n\ndef input_generator():\n    # Common fractions used in music theory\n    common_fractions = [\n        \"3/2\",  # Perfect fifth\n        \"4/3\",  # Perfect fourth\n        \"5/4\",  # Major third\n        \"6/5\",  # Minor third\n        \"9/8\",  # Major second\n        \"16/15\", # Minor second\n        \"5/3\",  # Major sixth\n        \"8/5\",  # Minor sixth\n        \"15/8\", # Major seventh\n        \"9/5\",  # Minor seventh\n    ]\n    \n    # Randomly choose between common fractions and random fractions\n    if random.random() < 0.7:\n        fraction_str = random.choice(common_fractions)\n    else:\n        # Generate random numerator and denominator (1-20)\n        numerator = random.randint(1, 20)\n        denominator = random.randint(1, 20)\n        fraction_str = f\"{numerator}/{denominator}\"\n    \n    # Generate division (common ET divisions or random)\n    common_divisions = [12, 19, 24, 31, 53]  # Common ET divisions\n    if random.random() < 0.7:\n        division = random.choice(common_divisions)\n    else:\n        division = random.randint(5, 100)\n    \n    return {\n        \"division\": division,\n        \"fraction_str\": fraction_str\n    }", "io_pairs": [{"input": {"division": 73, "fraction_str": "15/8"}, "output": {"fraction": "15/8", "closest_division": 66, "error_percentage": -0.19257901433406}}, {"input": {"division": 53, "fraction_str": "4/16"}, "output": {"fraction": "1/4", "closest_division": -106, "error_percentage": 0.0}}, {"input": {"division": 55, "fraction_str": "16/15"}, "output": {"fraction": "16/15", "closest_division": 5, "error_percentage": -0.15239786500349517}}, {"input": {"division": 44, "fraction_str": "8/5"}, "output": {"fraction": "8/5", "closest_division": 30, "error_percentage": 0.2600095536534619}}, {"input": {"division": 12, "fraction_str": "7/12"}, "output": {"fraction": "7/12", "closest_division": -9, "error_percentage": 1.93203842880465}}, {"input": {"division": 79, "fraction_str": "15/8"}, "output": {"fraction": "15/8", "closest_division": 72, "error_percentage": 0.31252900985256904}}, {"input": {"division": 12, "fraction_str": "8/5"}, "output": {"fraction": "8/5", "closest_division": 8, "error_percentage": -0.7874342519875399}}, {"input": {"division": 46, "fraction_str": "11/13"}, "output": {"fraction": "11/13", "closest_division": -11, "error_percentage": 0.13023453236122862}}, {"input": {"division": 24, "fraction_str": "2/2"}, "output": {"fraction": "1", "closest_division": 0, "error_percentage": 0.0}}, {"input": {"division": 31, "fraction_str": "8/5"}, "output": {"fraction": "8/5", "closest_division": 21, "error_percentage": -0.04522111042700727}}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = (x-3)(x-5)(x-7) + 85 \\), you are tasked with determining the integral of this function over a specified interval \\([a, b]\\) using two different methods: one using a high-accuracy numerical integration technique and another using a trapezoid approximation with a given number of points \\(N\\). What are the results of these two methods, including the estimated error for the high-accuracy method?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The left boundary of the integration interval.\n  `b` (float): The right boundary of the integration interval.\n  `N` (int): The number of points to use in the trapezoid approximation.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `integral` (float): The result of the integral calculated using SciPy's `quad` function.\n    - `error` (float): The estimated error of the integral calculated using SciPy's `quad` function.\n    - `integral_trapezoid` (float): The result of the integral calculated using the trapezoid approximation.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy.integrate import quad\n\n# main function\ndef main_solution(a, b, N):\n  # Convert JSON serializable inputs to original input variables\n  a = float(a)\n  b = float(b)\n  N = int(N)\n\n  # Define the function to integrate\n  def f(x):\n    return (x-3)*(x-5)*(x-7)+85\n\n  # Use SciPy to calculate the integral\n  integral, error = quad(f, a, b)\n\n  # Use NumPy to calculate the area with the trapezoid approximation\n  xint = np.linspace(a, b, N)\n  yint = f(xint)\n  integral_trapezoid = sum((xint[1:] - xint[:-1]) * (yint[1:] + yint[:-1])) / 2\n\n  # Convert outputs to JSON serializable format\n  return {\n    \"integral\": integral,\n    \"error\": error,\n    \"integral_trapezoid\": integral_trapezoid\n  }", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    a = random.uniform(0, 10)\n    b = random.uniform(a, 20)\n    N = random.randint(10, 1000)\n    return {\n        \"a\": a,\n        \"b\": b,\n        \"N\": N\n    }", "io_pairs": [{"input": {"a": 5.073091631295695, "b": 5.199418032220115, "N": 573}, "output": {"integral": 10.669281977823593, "error": 1.1845282507997982e-13, "integral_trapezoid": 10.66928197824336}}, {"input": {"a": 9.110832650882028, "b": 15.184820678757802, "N": 914}, "output": {"integral": 2961.2400470518874, "error": 3.287636881679087e-11, "integral_trapezoid": 2961.2410078325515}}, {"input": {"a": 3.973036179754126, "b": 13.15541170579663, "N": 68}, "output": {"integral": 1755.2313116445578, "error": 1.9486982157308018e-11, "integral_trapezoid": 1755.5386738981597}}, {"input": {"a": 2.098110226813793, "b": 8.155647751508205, "N": 802}, "output": {"integral": 518.8792351920405, "error": 5.760716739100952e-12, "integral_trapezoid": 518.8792571697797}}, {"input": {"a": 0.668826886976881, "b": 19.15533575411592, "N": 152}, "output": {"integral": 11157.536638513257, "error": 1.238735407417619e-10, "integral_trapezoid": 11158.217167091985}}, {"input": {"a": 1.1864813168893518, "b": 6.73973331767293, "N": 974}, "output": {"integral": 444.4749463551687, "error": 4.934663193125396e-12, "integral_trapezoid": 444.47485257299763}}, {"input": {"a": 0.4130378603599705, "b": 17.21249032777858, "N": 863}, "output": {"integral": 6622.123121978941, "error": 7.352033561923644e-11, "integral_trapezoid": 6622.135286101572}}, {"input": {"a": 2.637647445481633, "b": 18.581295480035322, "N": 683}, "output": {"integral": 9495.27922736182, "error": 1.0541877623462059e-10, "integral_trapezoid": 9495.30366652288}}, {"input": {"a": 5.949090741323346, "b": 13.567677572830963, "N": 373}, "output": {"integral": 1849.4455205653421, "error": 2.0532969997215013e-11, "integral_trapezoid": 1849.4531232484821}}, {"input": {"a": 7.676170256718726, "b": 16.960698911011395, "N": 226}, "output": {"integral": 5620.989534711616, "error": 6.240552002613882e-11, "integral_trapezoid": 5621.047384629393}}], "error_log": []}
{"context": "Given a complex number \\( c \\) and the parameters of a Mandelbrot set, determine the number of iterations it takes for the sequence \\( z_{n+1} = z_n^2 + c \\) to become unbounded, or indicate if the sequence remains bounded. What is the result for the given complex number \\( c \\) within the specified Mandelbrot set parameters?\n\nThe input and output requirements are as follows:\n\nInput:\n  `centerX` (float): The x-coordinate of the center of the Mandelbrot set.\n  `centerY` (float): The y-coordinate of the center of the Mandelbrot set.\n  `axisLength` (float): The length of the axis for the Mandelbrot set.\n  `c_real` (float): The real part of the complex number c.\n  `c_imag` (float): The imaginary part of the complex number c.\n\nOutput:\n  `return` (int): The number of iterations before the sequence becomes unbounded or 77 if the sequence is bounded.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Gradient:\n    def __init__(self):\n        pass\n\nclass Fractal:\n    def __init__(self):\n        pass\n\nclass Mandelbrot(Fractal):\n    def __init__(self, name, centerX, centerY, axisLength):\n        self.__name = name\n        self.__gradient = Gradient()\n        self.__width = 640\n        self.__size = 320\n        self.__centerX = centerX\n        self.__centerY = centerY\n        self.__axisLength = axisLength\n\n    def getName(self): return self.__name\n\n    def getWidth(self): return self.__width\n\n    def getSize(self): return self.__size\n\n    def getCenterX(self): return self.__centerX\n\n    def getCenterY(self): return self.__centerY\n\n    def getAxisLength(self): return self.__axisLength\n\n    def count(self, c):\n        MAX_ITERATIONS = 100\n        z = complex(0, 0)  # z0\n        for i in range(MAX_ITERATIONS):\n            z = z * z + c  # Get z1, z2, ...\n            if abs(z) > 2:\n                return i  # The sequence is unbounded\n        return 77   # Indicate a bounded sequence\n\n# main function\ndef main_solution(centerX, centerY, axisLength, c_real, c_imag):\n    # Convert JSON serializable inputs to the original input variables\n    c = complex(c_real, c_imag)\n    \n    # Create an instance of Mandelbrot\n    mandelbrot = Mandelbrot(\"Mandelbrot Set\", centerX, centerY, axisLength)\n    \n    # Calculate the count for the given complex number c\n    result = mandelbrot.count(c)\n    \n    # Return the result, which is JSON serializable\n    return result", "input_generator": "import random\n\ndef input_generator():\n    centerX = random.uniform(-2.0, 2.0)\n    centerY = random.uniform(-2.0, 2.0)\n    axisLength = random.uniform(0.5, 4.0)\n    c_real = random.uniform(-2.0, 2.0)\n    c_imag = random.uniform(-2.0, 2.0)\n    return {\n        'centerX': centerX,\n        'centerY': centerY,\n        'axisLength': axisLength,\n        'c_real': c_real,\n        'c_imag': c_imag\n    }", "io_pairs": [{"input": {"centerX": 1.3570507011043436, "centerY": 0.30451459968292527, "axisLength": 1.9733988672436407, "c_real": 0.8837879561756448, "c_imag": 1.121154234318293}, "output": 1}, {"input": {"centerX": -0.21349252992761203, "centerY": -0.43363791818541975, "axisLength": 2.998805664882782, "c_real": -1.5736162235640379, "c_imag": -1.2885553233198066}, "output": 0}, {"input": {"centerX": 0.5354770919821221, "centerY": -0.8945413831091287, "axisLength": 0.6762868769748491, "c_real": 0.811438445054057, "c_imag": 0.1427869472300971}, "output": 2}, {"input": {"centerX": 1.706868492863777, "centerY": 1.064548860361552, "axisLength": 3.58838782456348, "c_real": 0.9799932084465057, "c_imag": -1.4387456940873071}, "output": 1}, {"input": {"centerX": -0.9572453773403251, "centerY": 1.5592283012462413, "axisLength": 3.7311398330891996, "c_real": 1.8531928961796273, "c_imag": 1.952982292104109}, "output": 0}, {"input": {"centerX": -0.22934823715004082, "centerY": 1.6907411878731042, "axisLength": 2.176727943794775, "c_real": -0.24607630109196466, "c_imag": -1.6469174128959008}, "output": 1}, {"input": {"centerX": 0.7566469613517626, "centerY": 1.236946388837398, "axisLength": 3.5751142706622905, "c_real": -1.509050176482115, "c_imag": -0.19676628181577227}, "output": 4}, {"input": {"centerX": 0.4410694337811898, "centerY": -0.2411232616686454, "axisLength": 0.9575116739104517, "c_real": -1.3080246494658612, "c_imag": -0.794042441225387}, "output": 2}, {"input": {"centerX": 0.5530905203518519, "centerY": 0.4339133633280401, "axisLength": 1.7812709369838378, "c_real": -0.17552538321382327, "c_imag": -0.324759386735443}, "output": 77}, {"input": {"centerX": -0.280534428614454, "centerY": 0.9611143764299253, "axisLength": 2.6079409204947632, "c_real": 0.15841351835999928, "c_imag": -1.501631634101647}, "output": 1}], "error_log": []}
{"context": "In a river crossing puzzle, a farmer needs to transport a cabbage, a goat, and a wolf from one side of the river to the other using a boat. The farmer can only take one item at a time, and certain combinations of items left unattended can lead to undesirable outcomes (e.g., the goat eating the cabbage, or the wolf eating the goat). Given an initial arrangement of the items on both sides of the river, what is the final arrangement of the items after the farmer successfully transports all items to the other side without any undesirable outcomes occurring?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start_state` (list of tuples): A list containing two tuples representing the initial state of the river crossing problem. The first tuple contains the items on the left side of the river, and the second tuple contains the items on the right side of the river. Each tuple can contain the characters 'F' (Farmer), 'C' (Cabbage), 'G' (Goat), and 'W' (Wolf).\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `left_side` (list): A list of characters representing the items on the left side of the river after the solution is found.\n    - `right_side` (list): A list of characters representing the items on the right side of the river after the solution is found.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef state_to_string(s):\n    return \"\".join(s[0]) + \"||\" + \"\".join(s[1])\n\ndef remove_actions(letter, possible_actions, s, farmer_inx):\n    if letter not in s[farmer_inx]:\n        new_possible_actions = []\n        for action in possible_actions:\n            if letter not in action:\n                new_possible_actions.append(action)\n    else:  # Nothing to do\n        new_possible_actions = possible_actions\n    return new_possible_actions\n\ndef action(s):\n    # Find out which side the farmer is on\n    farmer_inx = 0\n    if 'F' in s[1]:\n        farmer_inx = 1\n    possible_actions = [\"F>\", \"FC>\", \"FG>\", \"FW>\", \"F<\", \"FC<\", \"FG<\", \"FW<\"]\n    if farmer_inx == 0:\n        possible_actions = possible_actions[0:4]\n    else:\n        possible_actions = possible_actions[4:8]\n\n    possible_actions = remove_actions('C', possible_actions, s, farmer_inx)\n    possible_actions = remove_actions('G', possible_actions, s, farmer_inx)\n    possible_actions = remove_actions('W', possible_actions, s, farmer_inx)\n\n    return possible_actions\n\ndef succ(s, a):\n    new_s = (list(s[0]), list(s[1]))\n    if '<' in a:\n        # moving farmer from right to left\n        new_s[1].remove(\"F\")\n        new_s[0].append(\"F\")\n        if len(a) == 3:\n            new_s[1].remove(str(a[1]))\n            new_s[0].append(str(a[1]))\n    else:\n        new_s[0].remove(\"F\")\n        new_s[1].append(\"F\")\n        if len(a) == 3:\n            new_s[0].remove(str(a[1]))\n            new_s[1].append(str(a[1]))\n    return (tuple(new_s[0]), tuple(new_s[1]))\n\ndef isEnd(s):\n    return len(s[0]) == 0\n\ndef cost(current_s, a):\n    s = succ(current_s, a)\n    max_cost = 1000\n\n    non_farmer_inx = 1\n    if 'F' in s[1]:\n        non_farmer_inx = 0\n\n    if \"C\" in s[non_farmer_inx] and \"G\" in s[non_farmer_inx]:\n        return max_cost\n\n    if \"W\" in s[non_farmer_inx] and \"G\" in s[non_farmer_inx]:\n        return max_cost\n\n    return 1\n\ndef bfs(start):\n    queue = [start]\n    visited = set()\n    while queue:\n        current_state = queue.pop(0)\n        if isEnd(current_state):\n            return current_state\n        if current_state not in visited:\n            visited.add(current_state)\n            for act in action(current_state):\n                new_state = succ(current_state, act)\n                if new_state not in visited:\n                    queue.append(new_state)\n    return None\n\n# main function\ndef main_solution(start_state):\n    # Convert input to tuple if it's not already\n    start_state = tuple(start_state)\n    \n    # Run BFS to find the solution\n    final_state = bfs(start_state)\n    \n    # Convert the final state to a JSON serializable format\n    if final_state:\n        return {\"left_side\": list(final_state[0]), \"right_side\": list(final_state[1])}\n    else:\n        return {\"left_side\": [], \"right_side\": []}", "input_generator": "import random\n\ndef input_generator():\n    # Possible entities: Farmer (F), Chicken (C), Grain (G), Wolf (W)\n    entities = ['F', 'C', 'G', 'W']\n    \n    # Randomly decide the side for each entity\n    left_side = []\n    right_side = []\n    \n    for entity in entities:\n        if random.choice([True, False]):\n            left_side.append(entity)\n        else:\n            right_side.append(entity)\n    \n    # Ensure the farmer is on one side (required for the problem)\n    if 'F' not in left_side and 'F' not in right_side:\n        if random.choice([True, False]):\n            left_side.append('F')\n        else:\n            right_side.append('F')\n    \n    start_state = (tuple(left_side), tuple(right_side))\n    \n    return {\"start_state\": start_state}", "io_pairs": [{"input": {"start_state": [["C"], ["F", "G", "W"]]}, "output": {"left_side": [], "right_side": ["G", "W", "F", "C"]}}, {"input": {"start_state": [["W"], ["F", "C", "G"]]}, "output": {"left_side": [], "right_side": ["C", "G", "F", "W"]}}, {"input": {"start_state": [["F", "G", "W"], ["C"]]}, "output": {"left_side": [], "right_side": ["C", "G", "F", "W"]}}, {"input": {"start_state": [["F", "C", "G"], ["W"]]}, "output": {"left_side": [], "right_side": ["W", "C", "F", "G"]}}, {"input": {"start_state": [["F"], ["C", "G", "W"]]}, "output": {"left_side": [], "right_side": ["C", "G", "W", "F"]}}, {"input": {"start_state": [["F", "W"], ["C", "G"]]}, "output": {"left_side": [], "right_side": ["C", "G", "F", "W"]}}, {"input": {"start_state": [["C", "W"], ["F", "G"]]}, "output": {"left_side": [], "right_side": ["G", "C", "F", "W"]}}, {"input": {"start_state": [["C", "G"], ["F", "W"]]}, "output": {"left_side": [], "right_side": ["W", "C", "F", "G"]}}, {"input": {"start_state": [["C", "G", "W"], ["F"]]}, "output": {"left_side": [], "right_side": ["C", "G", "F", "W"]}}, {"input": {"start_state": [["G"], ["F", "C", "W"]]}, "output": {"left_side": [], "right_side": ["C", "W", "F", "G"]}}], "error_log": []}
{"context": "Given a circular singly-linked list, you are tasked with performing a series of operations on it. The operations include inserting new nodes, deleting nodes based on their data, and searching for nodes by their data. What will be the result of the search operations after performing the given series of insertions and deletions?\n\nThe input and output requirements are as follows:\n\nInput:\n  `operations` (list of dictionaries): A list of operations to be performed on the linked list. Each dictionary has the following keys:\n    - `type` (string): The type of operation to perform. Can be \"insert\", \"delete\", or \"search\".\n    - `data` (int): The data to insert into the linked list (only used if `type` is \"insert\").\n    - `key` (int): The key to search for or delete from the linked list (used if `type` is \"search\" or \"delete\").\n\nOutput:\n  `return` (list of integers or None): A list of results from the search operations. Each element is the data of the node found by the search operation, or `None` if the node was not found.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass LinkedList(object):\n    class Node(object):\n        def __init__(self, data=None, nxt=None):\n            self.data = data\n            self.nxt = nxt\n\n    @staticmethod\n    def insert_after(linked_list, node, new_node):\n        new_node.nxt = node.nxt\n        node.nxt = new_node\n        if linked_list.tail == node:\n            linked_list.tail = new_node\n\n    @staticmethod\n    def delete_after(linked_list, node):\n        if linked_list.tail:\n            if node.nxt == linked_list.tail:\n                linked_list.tail = node\n            node.nxt = node.nxt.nxt\n\n    def __init__(self):\n        self.tail = None\n\n    def search(self, key):\n        if self.tail:\n            x = self.tail.nxt\n            if x.data == key:\n                return x\n            else:\n                x = x.nxt\n                while (x != self.tail.nxt) and (x.data != key):\n                    x = x.nxt\n                return x if x != self.tail.nxt else None\n        return None\n\n    def insert(self, x):\n        if self.tail:\n            x.nxt = self.tail.nxt\n            self.tail.nxt = x\n        else:\n            self.tail = x\n            self.tail.nxt = self.tail\n\n    def delete(self, x):\n        if not self.tail:\n            return False\n        if self.tail.nxt == self.tail:\n            if self.tail == x:\n                self.tail = None\n                return True\n            return False\n        if self.tail.nxt == x:\n            self.tail.nxt = self.tail.nxt.nxt\n            return True\n        else:\n            node = self.tail.nxt\n            while node.nxt != self.tail.nxt and node.nxt != x:\n                node = node.nxt\n            if node.nxt != self.tail.nxt:\n                node.nxt = x.nxt\n                return True\n            return False\n\n    def insert_by_data(self, data):\n        new_node = LinkedList.Node(data)\n        self.insert(new_node)\n\n    def delete_by_key(self, key):\n        x = self.search(key)\n        if x:\n            return self.delete(x)\n        return False\n\n    def append(self, x):\n        if self.tail:\n            LinkedList.insert_after(self, self.tail, x)\n        else:\n            self.insert(x)\n\n# main function\ndef main_solution(operations):\n    # Initialize the linked list\n    linked_list = LinkedList()\n    \n    # Process each operation\n    results = []\n    for op in operations:\n        if op['type'] == 'insert':\n            linked_list.insert_by_data(op['data'])\n        elif op['type'] == 'delete':\n            linked_list.delete_by_key(op['key'])\n        elif op['type'] == 'search':\n            node = linked_list.search(op['key'])\n            results.append(node.data if node else None)\n    \n    # Return the results of search operations\n    return results", "input_generator": "import random\n\ndef input_generator():\n    operation_types = ['insert', 'delete', 'search']\n    operations = []\n    data_pool = [random.randint(1, 100) for _ in range(20)]\n    \n    for _ in range(random.randint(5, 20)):\n        op_type = random.choice(operation_types)\n        if op_type == 'insert':\n            operations.append({\n                'type': 'insert',\n                'data': random.choice(data_pool)\n            })\n        elif op_type == 'delete':\n            operations.append({\n                'type': 'delete',\n                'key': random.choice(data_pool)\n            })\n        else:  # search\n            operations.append({\n                'type': 'search',\n                'key': random.choice(data_pool)\n            })\n    \n    return {'operations': operations}", "io_pairs": [], "error_log": []}
{"context": "Given a number `n`, what are all the possible permutations of the numbers from 1 to `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer representing the number of elements to permute (1 to n).\n\nOutput:\n  `return` (str): A JSON serialized string representing the list of permutations of the numbers from 1 to n.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef fp(k, n, res, hashtable):\n    for i in range(n):\n        if not hashtable[i]:\n            res[k] = i + 1\n            hashtable[i] = True\n            if k + 1 < n:\n                fp(k + 1, n, res, hashtable)\n            else:\n                return res[:]\n            hashtable[i] = False\n    return res[:]\n\n# main function\ndef main_solution(n):\n    # Convert input to the required format\n    n = int(n)\n    hashtable = [False] * n\n    res = [0] * n\n    \n    # Call the recursive function\n    result = fp(0, n, res, hashtable)\n    \n    # Convert the result to a JSON serializable format\n    return json.dumps(result)", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)\n    return {'n': n}", "io_pairs": [{"input": {"n": 2}, "output": "[1, 2]"}, {"input": {"n": 10}, "output": "[9, 8, 7, 6, 5, 4, 3, 2, 1, 10]"}, {"input": {"n": 3}, "output": "[2, 1, 3]"}, {"input": {"n": 6}, "output": "[5, 4, 3, 2, 1, 6]"}, {"input": {"n": 5}, "output": "[4, 3, 2, 1, 5]"}, {"input": {"n": 4}, "output": "[3, 2, 1, 4]"}, {"input": {"n": 9}, "output": "[8, 7, 6, 5, 4, 3, 2, 1, 9]"}, {"input": {"n": 7}, "output": "[6, 5, 4, 3, 2, 1, 7]"}, {"input": {"n": 1}, "output": "[1]"}, {"input": {"n": 8}, "output": "[7, 6, 5, 4, 3, 2, 1, 8]"}], "error_log": []}
{"context": "In a special family of Engineers and Doctors, each person has two children following specific rules. The first child of an Engineer is an Engineer, and the second child is a Doctor. The first child of a Doctor is a Doctor, and the second child is an Engineer. Given the level and position of a person in the family tree, what is the profession of that person?\n\nThe input and output requirements are as follows:\n\nInput:\n  `level` (int): The level in the family tree where the person is located. This is a positive integer.\n  `pos` (int): The position of the person within the specified level. This is a positive integer.\n\nOutput:\n  `return` (str): The profession of the person at the specified level and position. It can be either \"Doctor\" or \"Engineer\".", "reference_code": "# import necessary packages\n\n# main function\ndef main_solution(level, pos):\n    # Convert the position to a binary string and process it to determine the profession\n    binary = str(bin(pos-1))[2:]\n    prof = 0\n    for i in reversed(binary):\n        if int(i):\n            prof = not prof\n\n    # Return the profession as a string\n    if prof:\n        return 'Doctor'\n    else:\n        return 'Engineer'", "input_generator": "import random\n\ndef input_generator():\n    level = random.randint(1, 20)\n    max_pos = 2 ** level\n    pos = random.randint(1, max_pos)\n    return {'level': level, 'pos': pos}", "io_pairs": [{"input": {"level": 19, "pos": 7154}, "output": "Doctor"}, {"input": {"level": 10, "pos": 840}, "output": "Engineer"}, {"input": {"level": 19, "pos": 446372}, "output": "Engineer"}, {"input": {"level": 13, "pos": 727}, "output": "Engineer"}, {"input": {"level": 16, "pos": 53613}, "output": "Engineer"}, {"input": {"level": 6, "pos": 34}, "output": "Engineer"}, {"input": {"level": 19, "pos": 242109}, "output": "Doctor"}, {"input": {"level": 14, "pos": 5077}, "output": "Doctor"}, {"input": {"level": 1, "pos": 1}, "output": "Engineer"}, {"input": {"level": 7, "pos": 40}, "output": "Engineer"}], "error_log": []}
{"context": "In the context of RSA encryption, given a message, how can we ensure that the message is securely encrypted and subsequently decrypted to retrieve the original message? Specifically, what are the encrypted and decrypted forms of the message?\n\nThe input and output requirements are as follows:\n\nInput:\n  `message` (str): The message to be encrypted and decrypted. It should be a string of reasonable length (less than 1KB).\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `encrypted_message` (list of int): A list of integers representing the encrypted message.\n    - `decrypted_message` (str): The decrypted message, which should be the same as the input message.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# \u8ba1\u7b97\u7d20\u6570\u8868\ndef prime_table(n):\n    result = [2, 3]\n    for i in range(5, n+1, 2):\n        for j in range(2, int(math.sqrt(i))+2):\n            if i % j == 0:\n                break\n        else:\n            result.append(i)\n    return result\n\n# \u8ba1\u7b97n\u7684\u503c\ndef compute_n():\n    result = prime_table(10000)\n    l = random.randint(700, len(result)-1)\n    r = random.randint(700, len(result)-1)\n    while l == r:\n        l = random.randint(700, len(result)-1)\n        r = random.randint(700, len(result)-1)\n    return result[l], result[r], result[l] * result[r]\n\n# \u8ba1\u7b97\u03c6(n)\u7684\u503c\ndef euler_n(p, q):\n    return (p-1)*(q-1)\n\n# \u4ece1\u5230\u03c6(n)\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u4e0e\u03c6(n)\u4e92\u8d28\u7684\u6570e\ndef random_select_e(n):\n    primes = prime_table(min(10000, n))\n    index = random.randint(10, len(primes)-1)\n    return primes[index]\n\n# \u6269\u5c55\u6b27\u51e0\u91cc\u7684\u7b97\u6cd5\ndef ext_euclid(a, b):\n    x1 = 1\n    x2 = 0\n    x3 = b\n    y1 = 0\n    y2 = 1\n    y3 = a\n    while y3 != 1:\n        if y3 == 0:\n            return 0\n        q = x3//y3\n        t1 = x1-q*y1\n        t2 = x2-q*y2\n        t3 = x3-q*y3\n        x1 = y1\n        x2 = y2\n        x3 = y3\n        y1 = t1\n        y2 = t2\n        y3 = t3\n    return y2 % b\n\n# main function\ndef main_solution(message):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # Convert the message string to a list of unicode values\n    a = [ord(i) for i in message]\n    \n    # Compute p, q, and n\n    p, q, n = compute_n()\n    \n    # Compute Euler's totient function \u03c6(n)\n    en = euler_n(p, q)\n    \n    # Randomly select e\n    e = random_select_e(en)\n    \n    # Compute the modular inverse d\n    d = ext_euclid(e, en)\n    \n    # Encrypt the message\n    c = [pow(i, e, n) for i in a]\n    \n    # Decrypt the message\n    m = [pow(i, d, n) for i in c]\n    \n    # Convert the decrypted unicode values back to a string\n    decrypted_message = ''.join([chr(i) for i in m])\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"encrypted_message\": c, \"decrypted_message\": decrypted_message}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random message of reasonable length (e.g., 5 to 20 characters)\n    message_length = random.randint(5, 20)\n    message = ''.join(random.choices(string.ascii_letters + string.digits + string.punctuation + ' ', k=message_length))\n    \n    return {\"message\": message}", "io_pairs": [{"input": {"message": "Dd(@m_5&?"}, "output": {"encrypted_message": [32298632, 3704496, 34077704, 74558316, 66087367, 17049673, 10383346, 67630213, 58858673], "decrypted_message": "Dd(@m_5&?"}}, {"input": {"message": "Y@5JjW?]V'|3"}, "output": {"encrypted_message": [12910006, 13392943, 1074786, 54910135, 60005803, 47520805, 33880551, 37214857, 17220107, 15669975, 18209292, 53985574], "decrypted_message": "Y@5JjW?]V'|3"}}, {"input": {"message": "1kr<]17,af?h^"}, "output": {"encrypted_message": [8698536, 37729915, 37989294, 41804282, 38404331, 8698536, 4170955, 37850380, 30388235, 39386795, 41042332, 34426483, 21912457], "decrypted_message": "1kr<]17,af?h^"}}, {"input": {"message": "Iq^4q}A"}, "output": {"encrypted_message": [47142475, 42257943, 14112768, 22870215, 42257943, 33930203, 25263563], "decrypted_message": "Iq^4q}A"}}, {"input": {"message": "P  BCy"}, "output": {"encrypted_message": [61565062, 10731052, 10731052, 17854416, 47096249, 49799181], "decrypted_message": "P  BCy"}}, {"input": {"message": "Cm7P gp}:ND "}, "output": {"encrypted_message": [37560980, 37208900, 38469651, 13668654, 23003699, 20797576, 40772936, 27347088, 1731781, 18410782, 7141841, 23003699], "decrypted_message": "Cm7P gp}:ND "}}, {"input": {"message": "sikFPVT"}, "output": {"encrypted_message": [11007193, 15192161, 14905831, 30802342, 493910, 22106377, 14151772], "decrypted_message": "sikFPVT"}}, {"input": {"message": "d(89pP.yG}$[\""}, "output": {"encrypted_message": [33719903, 31108146, 28439061, 29234120, 1080658, 18505618, 31449619, 30682074, 188337, 37601296, 35430391, 37930380, 6571455], "decrypted_message": "d(89pP.yG}$[\""}}, {"input": {"message": "0I$Ujp|."}, "output": {"encrypted_message": [12131820, 11699997, 54549848, 8497628, 27576518, 48834025, 27893563, 47877870], "decrypted_message": "0I$Ujp|."}}, {"input": {"message": ".%|Cx,b>Gu3+"}, "output": {"encrypted_message": [46804004, 2492404, 65735596, 14222963, 72761843, 70028000, 11275059, 13937757, 62874520, 59573477, 44740385, 25079968], "decrypted_message": ".%|Cx,b>Gu3+"}}], "error_log": []}
{"context": "Given a historical algorithm developed by the Chudnovsky brothers, which is known for its high precision in computing the value of Pi, how would the approximated value of Pi change with different numbers of iterations? Specifically, what is the approximated value of Pi after a certain number of iterations, denoted by `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of iterations to perform in the Chudnovsky algorithm to approximate Pi.\n\nOutput:\n  `return` (str): The approximated value of Pi as a string.", "reference_code": "# import necessary packages\nimport math\nfrom decimal import Decimal\n\n# main function\ndef main_solution(n):\n    # Convert input to Decimal for precision\n    n = Decimal(n)\n    \n    pi = Decimal(0)\n    k = 0\n    while k < n:\n        pi += (Decimal(-1) ** k) * (\n            Decimal(math.factorial(6 * k)) / ((math.factorial(k) ** 3) * (math.factorial(3 * k))) * (\n                13591409 + 545140134 * k) / (\n                640320 ** (3 * k)))\n        k += 1\n    pi = pi * Decimal(10005).sqrt() / 4270934400\n    pi = pi ** (-1)\n    \n    # Convert the result to a string to ensure JSON serializability\n    return str(pi)", "input_generator": "import random\nfrom decimal import Decimal\n\ndef input_generator():\n    n = random.randint(1, 10)\n    return {'n': n}", "io_pairs": [{"input": {"n": 6}, "output": "3.141592653589793238462643384"}, {"input": {"n": 8}, "output": "3.141592653589793238462643384"}, {"input": {"n": 3}, "output": "3.141592653589793238462643384"}, {"input": {"n": 9}, "output": "3.141592653589793238462643384"}, {"input": {"n": 5}, "output": "3.141592653589793238462643384"}, {"input": {"n": 7}, "output": "3.141592653589793238462643384"}, {"input": {"n": 2}, "output": "3.141592653589793238462643384"}, {"input": {"n": 1}, "output": "3.141592653589734207668453590"}, {"input": {"n": 4}, "output": "3.141592653589793238462643384"}, {"input": {"n": 10}, "output": "3.141592653589793238462643384"}], "error_log": []}
{"context": "George has a collection of stick parts that were cut from sticks of the same original length. Each part is at most 50 units long, and there are at most 64 parts. George wants to determine the smallest possible original length of the sticks before they were cut. Given the lengths of the stick parts, what is the smallest possible original length of the sticks?\n\nThe input and output requirements are as follows:\n\nInput:\n  `stick_parts` (list of int): A list of integers representing the lengths of stick parts after cutting. Each integer is greater than zero and the total number of parts is at most 64.\n\nOutput:\n  `return` (int): The smallest possible original length of the sticks before they were cut. If no valid length is found, returns `None`.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(stick_parts):\n    # Convert the input list of stick parts to a sorted list of integers\n    dataint = sorted([int(part) for part in stick_parts], reverse=True)\n    totallen = sum(dataint)\n    maxlen = max(dataint)\n    \n    # Function to perform depth-first search to find the smallest possible original length\n    def dfs(s, length, pos, L, k):\n        if s == k:\n            return True\n        for i in range(pos + 1, len(dataint)):\n            if v[i]:\n                continue\n            if length + dataint[i] == L:\n                v[i] = True\n                if dfs(s + 1, 0, -1, L, k):\n                    return True\n                v[i] = False\n                return False\n            elif dataint[i] + length < L:\n                v[i] = True\n                if dfs(s, length + dataint[i], i, L, k):\n                    return True\n                v[i] = False\n                if length == 0:\n                    return False\n        return False\n    \n    # Iterate over possible lengths to find the smallest one that fits\n    for L in range(maxlen, totallen + 1):\n        if totallen % L != 0:\n            continue\n        n = totallen // L\n        v = [False] * len(dataint)\n        if dfs(1, 0, -1, L, n):\n            return L\n    return None", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random number of stick parts between 3 and 20\n    num_parts = random.randint(3, 20)\n    \n    # Generate stick parts with lengths between 1 and 50\n    stick_parts = [str(random.randint(1, 50)) for _ in range(num_parts)]\n    \n    # Occasionally add some duplicates to make it more interesting\n    if random.random() < 0.3:\n        duplicate_index = random.randint(0, num_parts - 1)\n        stick_parts.append(stick_parts[duplicate_index])\n    \n    return {'stick_parts': stick_parts}", "io_pairs": [{"input": {"stick_parts": ["21", "8", "39", "28", "15", "7", "9", "18"]}, "output": 145}, {"input": {"stick_parts": ["21", "12", "2", "29", "24", "35", "21"]}, "output": 144}, {"input": {"stick_parts": ["48", "12", "31", "41", "12", "46", "17", "33", "12"]}, "output": 252}, {"input": {"stick_parts": ["47", "22", "18", "34", "23"]}, "output": 144}, {"input": {"stick_parts": ["31", "13", "33", "19", "34", "50", "30", "2", "13", "19", "31"]}, "output": 275}, {"input": {"stick_parts": ["18", "18", "4", "15", "48", "33", "33", "49", "18"]}, "output": 118}, {"input": {"stick_parts": ["21", "39", "40", "2"]}, "output": 102}, {"input": {"stick_parts": ["25", "24", "42", "31", "24"]}, "output": 73}, {"input": {"stick_parts": ["35", "29", "39", "41", "22"]}, "output": 166}, {"input": {"stick_parts": ["8", "41", "43", "14", "14"]}, "output": 120}], "error_log": []}
{"context": "Given a knight's starting position and its desired finishing position on an 8x8 chessboard, how many moves are required for the knight to reach the finishing position from the starting position, following the standard knight's move pattern? The starting and finishing positions are provided as coordinates on the chessboard.\n\nThe input and output requirements are as follows:\n\nInput:\n  `start` (list of int): A list containing two integers representing the starting position of the knight on a chessboard. The first integer is the row (1-8) and the second integer is the column (1-8).\n  `finish` (list of int): A list containing two integers representing the finishing position of the knight on a chessboard. The first integer is the row (1-8) and the second integer is the column (1-8).\n\nOutput:\n  `return` (int): The minimum number of moves required for the knight to travel from the starting position to the finishing position on the chessboard.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Queue:\n    def __init__(self):\n        self.queue = []\n    def enqueue(self, value):\n        self.queue.append(value)\n    def dequeue(self):\n        if self.size() > 0:\n            return self.queue.pop(0)\n        else:\n            return None\n    def size(self):\n        return len(self.queue)\n\ndef bfs(starting_vertex, destination_vertex, graph):\n    \"\"\"\n    Return a list containing the shortest path from\n    starting_vertex to destination_vertex in\n    breath-first order.\n    \"\"\"\n    # create empty queue holding paths this time\n    q = Queue()\n    # empty set for visited vertexes\n    visited = set()\n\n    # enqueue a list representing path to starting_vertex which is just itself\n    q.enqueue([starting_vertex])\n\n    # while the queue isn't empty\n    while q.size() > 0:\n        # dequeue path\n        v = q.dequeue()\n        # node is the last vertex in path\n        node = v[-1]\n\n        # if we haven't visited node yet\n        if node not in visited:\n            # loop through neighbors\n            for neighbor in graph[node]:\n                # add neighbor to path\n                path = list(v)\n                path.append(neighbor)\n                # enqueue the path for more searching\n                q.enqueue(path)\n                # if neighbor is goal, return the path\n                if neighbor == destination_vertex:\n                    return path\n            \n            # add vertex to visited after we've searched it\n            visited.add(node)\n\ndef knight_moves(start, finish):\n    # lets build a graph of every square, and the possible squares that a knight can move from that square\n    graph = {}\n\n    # create the vertices of our graph, 1 for each square on the chessboard initialized to an empty set\n    for i in range(1, 9):\n        for j in range(1, 9):\n            graph[(i, j)] = set()\n\n    # fill the empty sets with the potential squares we can move from that square\n    for square in graph:\n        # 8 possible moves from each point, make sure each point within the bounds of the board\n        # if so, add that move to the square's set\n        x = square[0]\n        y = square[1]\n        # up2/right1\n        if x < 8 and y < 7:\n            graph[square].add((x+1, y+2))\n        # up2/left1\n        if x > 1 and y < 7:\n            graph[square].add((x-1, y+2))\n        # up1/right2\n        if x < 7 and y < 8:\n            graph[square].add((x+2, y+1))\n        # up1/left2\n        if x > 2 and y < 8:\n            graph[square].add((x-2, y+1))\n        # down2/right1\n        if x < 8 and y > 2:\n            graph[square].add((x+1, y-2))\n        # down2/left1\n        if x > 1 and y > 2:\n            graph[square].add((x-1, y-2))\n        # down1/right2\n        if x < 7 and y > 1:\n            graph[square].add((x+2, y-1))\n        # down1/left2\n        if x > 2 and y > 1:\n            graph[square].add((x-2, y-1))\n    \n    # do a BFS from start to finish to find the shortest path, return the length of that path\n    path = bfs(start, finish, graph)\n    # subtract 1 from len(path) since bfs path includes start node\n    return len(path) - 1\n\n# main function\ndef main_solution(start, finish):\n    # Convert JSON serializable inputs to the original input variables\n    start = tuple(start)\n    finish = tuple(finish)\n    \n    # Call the knight_moves function\n    result = knight_moves(start, finish)\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate random start and finish positions on an 8x8 chessboard\n    start = (random.randint(1, 8), random.randint(1, 8))\n    finish = (random.randint(1, 8), random.randint(1, 8))\n    \n    # Ensure start and finish are not the same\n    while start == finish:\n        finish = (random.randint(1, 8), random.randint(1, 8))\n    \n    return {'start': start, 'finish': finish}", "io_pairs": [{"input": {"start": [8, 1], "finish": [1, 2]}, "output": 4}, {"input": {"start": [4, 2], "finish": [6, 4]}, "output": 4}, {"input": {"start": [2, 6], "finish": [5, 3]}, "output": 2}, {"input": {"start": [6, 7], "finish": [3, 7]}, "output": 3}, {"input": {"start": [8, 5], "finish": [2, 7]}, "output": 4}, {"input": {"start": [7, 1], "finish": [1, 3]}, "output": 4}, {"input": {"start": [1, 5], "finish": [7, 4]}, "output": 3}, {"input": {"start": [2, 5], "finish": [4, 8]}, "output": 3}, {"input": {"start": [8, 2], "finish": [5, 8]}, "output": 3}, {"input": {"start": [7, 6], "finish": [1, 6]}, "output": 4}], "error_log": []}
{"context": "Given the Lorenz system with standard parameters for sigma, b, and r, and an initial condition, how can we determine the sequence of maximum values of the z-coordinate over time using numerical integration? Specifically, what are the maximum z-values and their corresponding times for a given number of time steps and a specified time step?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n_steps` (int): The number of time steps to perform the integration.\n  `time_step` (float): The time step to be used in the numerical integration.\n  `initial_condition` (list of float): The initial condition for the Lorenz system, represented as a list of three floats.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `z_max` (list of float): A list of the maximum values of the z-coordinate in the Lorenz system.\n    - `t_max` (list of float): A list of the corresponding times at which these maxima occur.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy.signal import argrelmax\n\n# all class and function definitions in the code file, if any\ndef lorenz(x, s=10, b=8./3., r=28.):\n    \"\"\"The Lorenz system with standard parameters for sigma, b and r.\"\"\"\n    return np.array([\n        s * (x[1] - x[0]),\n        r * x[0] - x[1] - x[0] * x[2],\n        x[0] * x[1] - b * x[2]\n    ])\n\ndef runge_kutta(f, delta_t, initial):\n    k1 = f(initial) * delta_t\n    k2 = f(initial + 0.5 * k1) * delta_t\n    k3 = f(initial + 0.5 * k2) * delta_t\n    k4 = f(initial + k3) * delta_t\n    return initial + 1. / 6. * (k1 + 2. * k2 + 2. * k3 + k4)\n\n# main function\ndef main_solution(n_steps, time_step, initial_condition):\n    # Convert JSON serializable inputs to the original input variables\n    initial_condition = np.array(initial_condition)\n\n    # compute the Lorenz map by storing the values with time\n    z_values = []\n    times = []\n\n    previous = initial_condition\n    current_time = 0\n\n    for _ in range(n_steps):\n        z_values.append(previous[-1])\n        times.append(current_time)\n        current_time += time_step\n        previous = runge_kutta(lorenz, time_step, previous)\n\n    # compute the indices of the maxima in the sequence\n    z_max_idx = argrelmax(np.array(z_values))[0]\n\n    z_max = []\n    t_max = []\n\n    for idx in z_max_idx:\n        z_max.append(z_values[idx])\n        t_max.append(times[idx])\n\n    # Convert the output to JSON serializable format\n    z_max = list(z_max)\n    t_max = list(t_max)\n\n    return {\"z_max\": z_max, \"t_max\": t_max}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    n_steps = random.randint(100, 1000)\n    time_step = random.uniform(0.01, 0.1)\n    initial_condition = [\n        random.uniform(-10, 10),\n        random.uniform(-10, 10),\n        random.uniform(-10, 10)\n    ]\n    return {\n        \"n_steps\": n_steps,\n        \"time_step\": time_step,\n        \"initial_condition\": initial_condition\n    }", "io_pairs": [{"input": {"n_steps": 101, "time_step": 0.02923902157001513, "initial_condition": [-4.263331337273857, 6.875302038975647, 9.885108441448448]}, "output": {"z_max": [43.85998634058907, 33.850087813601455, 34.55880453245281, 35.51421999152098], "t_max": [0.40934630198021177, 1.0526047765205446, 1.7251022726308924, 2.3975997687412405]}}, {"input": {"n_steps": 120, "time_step": 0.02841241850559815, "initial_condition": [-2.5500250234052, 4.890209243407877, -7.530480183556671]}, "output": {"z_max": [52.014986220619704, 29.388827203836822, 29.547691284461838, 29.712201917253932, 29.8847397691526], "t_max": [0.39777385907837415, 1.2785588327519164, 1.9036320398750737, 2.528705246998231, 3.1537784541213885]}}, {"input": {"n_steps": 185, "time_step": 0.017237605688972518, "initial_condition": [8.86894516096691, 2.799258910486625, 1.622692528540366]}, "output": {"z_max": [47.22740712151013, 29.963619883135912, 30.157402729561554, 30.36793854136748, 30.58774497802645], "t_max": [0.22408887395664268, 0.8446426787596528, 1.465196483562662, 2.0857502883656713, 2.7063040931686806]}}, {"input": {"n_steps": 101, "time_step": 0.030043935623319293, "initial_condition": [-8.232357740972418, 7.960857537360297, -1.7473855561108937]}, "output": {"z_max": [49.638805118491035, 27.30629600506759, 27.323230801419175, 27.34262725957357, 27.363064372772424], "t_max": [0.3304832918565123, 1.0815816824394948, 1.7125043305292003, 2.313383042995586, 2.9443056910852916]}}, {"input": {"n_steps": 352, "time_step": 0.012362885369371754, "initial_condition": [4.899309534010751, 6.725637734742225, -8.327189491729602]}, "output": {"z_max": [55.277640219526496, 33.70706676841985, 32.98695998145326, 33.53883506021938, 34.21267966702866, 35.043301840027176, 36.12627867824437], "t_max": [0.21016905127931979, 0.42033810255863946, 1.100296797874088, 1.7555297224507935, 2.4107626470274917, 3.078358456973557, 3.7583171522889938]}}, {"input": {"n_steps": 335, "time_step": 0.013986459653016434, "initial_condition": [7.640942292547834, 1.5553589315707477, -3.9548282688984315]}, "output": {"z_max": [51.43075121791431, 28.70017417799805, 28.80111533361342, 28.914710427852697, 29.03526457570292, 29.16080560391694, 29.291171220918624], "t_max": [0.2237833544482629, 1.1049303125882992, 1.7203345373210195, 2.3497252217067617, 2.9651294464394917, 3.5805336711722218, 4.209924355557962]}}, {"input": {"n_steps": 186, "time_step": 0.01822754717296213, "initial_condition": [0.1821476873473511, 3.3928677651722, 9.034158769223207]}, "output": {"z_max": [43.321812151400486, 34.39187593049831, 35.24987363795422, 36.422570632802746, 38.30583733535489], "t_max": [0.3827784906322049, 1.0389701888588423, 1.6951618870854759, 2.4060362268309956, 3.1351381137494774]}}, {"input": {"n_steps": 141, "time_step": 0.04271825365558281, "initial_condition": [-5.588335237071645, -1.9400023080436988, 9.918266784371198]}, "output": {"z_max": [41.29629119987598, 36.6430897536323, 38.81557209002872, 41.956704297709976, 36.12323493981119, 37.59423749511285, 40.918243244337184, 37.77771872948176], "t_max": [0.2990277755890796, 1.0252380877339873, 1.7514483998788948, 2.648531726646137, 3.332023785135465, 4.058234097280375, 4.869880916736444, 5.596091228881348]}}, {"input": {"n_steps": 381, "time_step": 0.012901602043169508, "initial_condition": [6.399715271591791, 3.7903099926977486, 6.437119150704472]}, "output": {"z_max": [43.70079337854041, 34.00813820814577, 34.795528770346145, 35.777823723251515, 37.17921574003712, 39.621610912494184, 40.16769919504928], "t_max": [0.25803204086339016, 0.9031121430218642, 1.5739954492666821, 2.257780357554666, 2.954466867885812, 3.7414645925191437, 4.528462317152475]}}, {"input": {"n_steps": 194, "time_step": 0.013808326442321103, "initial_condition": [3.073987797638635, 2.1215143362517725, 6.589270135336612]}, "output": {"z_max": [44.11790626990258, 33.45163281142353, 34.08149893639213, 34.89427737870355], "t_max": [0.3313998346157065, 0.9665828509624773, 1.6293825201938854, 2.292182189425298]}}], "error_log": []}
{"context": "In a game of Tic Tac Toe, a player and a computer take turns marking spaces in a 3x3 grid. The player can choose to be either 'X' or 'O'. Given the player's chosen letter and a sequence of moves they intend to make, what will be the outcome of the game after processing all the player's moves? Will the player win, the computer win, or will the game end in a tie? If the player makes an invalid move, indicate that as well.\n\nThe input and output requirements are as follows:\n\nInput:\n- `player_letter` (int): The letter chosen by the player, either 1 ('X') or 2 ('O').\n- `player_moves` (list of int): A list of integers representing the positions (1-9) where the player wants to place their letter.\n\nOutput:\n- `return` (str): A string indicating the result of the game. Possible values are:\n  - 'Player Won': If the player wins the game.\n  - 'Computer Won': If the computer wins the game.\n  - 'Tie': If the game ends in a tie.\n  - 'Invalid Move': If the player makes an invalid move.\n  - 'Game Ongoing': If the game is still ongoing after processing all player moves.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Board:\n    def __init__(self):\n        self.board = [0] * 10\n\n    def makeMove(self, letter, move):\n        if self.board[move] == 0:\n            self.board[move] = letter\n            return True\n        return False\n\n    def isWinner(self, le):\n        win_conditions = [\n            (1, 2, 3), (4, 5, 6), (7, 8, 9),  # rows\n            (1, 4, 7), (2, 5, 8), (3, 6, 9),  # columns\n            (1, 5, 9), (3, 5, 7)              # diagonals\n        ]\n        for a, b, c in win_conditions:\n            if self.board[a] == self.board[b] == self.board[c] == le:\n                return True\n        return False\n\n    def isBoardFull(self):\n        return all(self.board[i] != 0 for i in range(1, 10))\n\n    def getBoardCopy(self):\n        dupeBoard = Board()\n        dupeBoard.board = self.board[:]\n        return dupeBoard\n\nclass TTTGame:\n    def __init__(self):\n        self.board = Board()\n        self.playerLetter = 1  # 1 = 'X', 2 = 'O', default is 'X'\n        self.computerLetter = 2\n        self.setLetter = False\n\n    def setPLetter(self, le):\n        if self.setLetter:\n            return 'Done'\n        self.playerLetter = le\n        self.computerLetter = 3 - le  # Toggle between 1 and 2\n        if self.playerLetter == 2:\n            self.makeComputerMove()\n        self.setLetter = True\n        return 'Set'\n\n    def makeComputerMove(self):\n        move = self.getComputerMove()\n        self.board.makeMove(self.computerLetter, move)\n\n    def getComputerMove(self):\n        for i in range(1, 10):\n            if self.board.board[i] == 0 and self.testWinMove(self.board, self.computerLetter, i):\n                return i\n        for i in range(1, 10):\n            if self.board.board[i] == 0 and self.testWinMove(self.board, self.playerLetter, i):\n                return i\n        for i in range(1, 10):\n            if self.board.board[i] == 0 and self.testForkMove(self.computerLetter, i):\n                return i\n        for i in range(1, 10):\n            if self.board.board[i] == 0 and self.testForkMove(self.playerLetter, i):\n                return i\n        if self.board.board[5] == 0:\n            return 5\n        corners = [1, 3, 7, 9]\n        random.shuffle(corners)\n        for corner in corners:\n            if self.board.board[corner] == 0:\n                return corner\n        sides = [2, 4, 6, 8]\n        random.shuffle(sides)\n        for side in sides:\n            if self.board.board[side] == 0:\n                return side\n\n    def testWinMove(self, board, letter, i):\n        bCopy = board.getBoardCopy()\n        bCopy.board[i] = letter\n        return bCopy.isWinner(letter)\n\n    def testForkMove(self, letter, i):\n        bCopy = self.board.getBoardCopy()\n        bCopy.board[i] = letter\n        winningMoves = 0\n        for j in range(1, 10):\n            if self.testWinMove(bCopy, letter, j) and bCopy.board[j] == 0:\n                winningMoves += 1\n        return winningMoves >= 2\n\n# main function\ndef main_solution(player_letter, player_moves):\n    game = TTTGame()\n    game.setPLetter(player_letter)\n    \n    for move in player_moves:\n        if game.board.makeMove(game.playerLetter, move):\n            if game.board.isWinner(game.playerLetter):\n                return 'Player Won'\n            if game.board.isBoardFull():\n                return 'Tie'\n            game.makeComputerMove()\n            if game.board.isWinner(game.computerLetter):\n                return 'Computer Won'\n            if game.board.isBoardFull():\n                return 'Tie'\n        else:\n            return 'Invalid Move'\n    \n    return 'Game Ongoing'", "input_generator": "import random\n\ndef input_generator():\n    player_letter = random.choice([1, 2])\n    num_moves = random.randint(1, 5)\n    player_moves = random.sample(range(1, 10), num_moves)\n    return {\n        'player_letter': player_letter,\n        'player_moves': player_moves\n    }", "io_pairs": [{"input": {"player_letter": 1, "player_moves": [5, 1]}, "output": "Invalid Move"}, {"input": {"player_letter": 1, "player_moves": [6, 3, 2]}, "output": "Computer Won"}, {"input": {"player_letter": 2, "player_moves": [3, 4]}, "output": "Game Ongoing"}, {"input": {"player_letter": 2, "player_moves": [2]}, "output": "Game Ongoing"}, {"input": {"player_letter": 1, "player_moves": [2, 1, 5, 7, 6]}, "output": "Invalid Move"}, {"input": {"player_letter": 1, "player_moves": [1, 6, 9, 5]}, "output": "Computer Won"}, {"input": {"player_letter": 2, "player_moves": [6, 2, 8, 4]}, "output": "Computer Won"}, {"input": {"player_letter": 1, "player_moves": [8, 5]}, "output": "Invalid Move"}, {"input": {"player_letter": 1, "player_moves": [9, 8, 7, 3]}, "output": "Invalid Move"}, {"input": {"player_letter": 1, "player_moves": [3, 5, 8, 7]}, "output": "Invalid Move"}], "error_log": []}
{"context": "Given a set of `n` disks stacked on rod `a`, how many steps are required to move all the disks to rod `b` using rod `c` as an auxiliary rod, following the rules of the Tower of Hanoi puzzle?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of disks to be moved.\n  `a` (str): The source rod from which disks are to be moved.\n  `b` (str): The destination rod to which disks are to be moved.\n  `c` (str): The auxiliary rod used for moving disks.\n\nOutput:\n  `return` (int): The total number of steps required to move `n` disks from rod `a` to rod `b` using rod `c`.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ncount = 0\n\ndef mov(n, a, b, c):\n    global count\n    if n <= 0:\n        return\n    if n == 1:\n        count += 1 \n    else:\n        mov(n-1, a, c, b)\n        mov(1, a, b, c)\n        mov(n-1, c, b, a)\n\n# main function\ndef main_solution(n, a, b, c):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    global count\n    count = 0\n    mov(n, a, b, c)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)\n    a = random.choice(['A', 'B', 'C'])\n    b = random.choice(['A', 'B', 'C'])\n    c = random.choice(['A', 'B', 'C'])\n    while b == a:\n        b = random.choice(['A', 'B', 'C'])\n    while c == a or c == b:\n        c = random.choice(['A', 'B', 'C'])\n    return {'n': n, 'a': a, 'b': b, 'c': c}", "io_pairs": [{"input": {"n": 7, "a": "C", "b": "B", "c": "A"}, "output": 127}, {"input": {"n": 8, "a": "C", "b": "A", "c": "B"}, "output": 255}, {"input": {"n": 9, "a": "B", "b": "A", "c": "C"}, "output": 511}, {"input": {"n": 6, "a": "B", "b": "C", "c": "A"}, "output": 63}, {"input": {"n": 9, "a": "A", "b": "B", "c": "C"}, "output": 511}, {"input": {"n": 8, "a": "C", "b": "B", "c": "A"}, "output": 255}, {"input": {"n": 3, "a": "C", "b": "B", "c": "A"}, "output": 7}, {"input": {"n": 4, "a": "A", "b": "C", "c": "B"}, "output": 15}, {"input": {"n": 4, "a": "B", "b": "C", "c": "A"}, "output": 15}, {"input": {"n": 1, "a": "C", "b": "A", "c": "B"}, "output": 1}], "error_log": []}
{"context": "Given a scenario where you are conducting a series of independent trials, each with a fixed probability of success, what is the probability of achieving exactly a specified number of successes in a given number of trials?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): Number of trials.\n  `p` (float): Probability of success in each trial.\n  `k` (int): Number of successes.\n\nOutput:\n  `return` (float): Probability of getting exactly k successes in n trials.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# main function\ndef main_solution(n, p, k):\n    \"\"\"\n    Calculate the probability of getting exactly k successes in n Bernoulli trials\n    with a success probability of p.\n\n    Parameters:\n    n (int): Number of trials.\n    p (float): Probability of success in each trial.\n    k (int): Number of successes.\n\n    Returns:\n    float: Probability of getting exactly k successes in n trials.\n    \"\"\"\n    # Calculate the binomial coefficient\n    binomial_coefficient = math.comb(n, k)\n    \n    # Calculate the probability using the binomial distribution formula\n    probability = binomial_coefficient * (p ** k) * ((1 - p) ** (n - k))\n    \n    return probability", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(1, 20)\n    p = round(random.uniform(0.1, 0.9), 2)\n    k = random.randint(0, n)\n    return {'n': n, 'p': p, 'k': k}", "io_pairs": [{"input": {"n": 16, "p": 0.56, "k": 6}, "output": 0.06717056345673043}, {"input": {"n": 2, "p": 0.73, "k": 1}, "output": 0.3942}, {"input": {"n": 13, "p": 0.68, "k": 9}, "output": 0.23306988905506684}, {"input": {"n": 1, "p": 0.24, "k": 1}, "output": 0.24}, {"input": {"n": 16, "p": 0.44, "k": 12}, "output": 0.009424441301326985}, {"input": {"n": 9, "p": 0.4, "k": 6}, "output": 0.07431782400000002}, {"input": {"n": 11, "p": 0.72, "k": 1}, "output": 2.34587839222776e-05}, {"input": {"n": 17, "p": 0.84, "k": 8}, "output": 0.00041409414625334054}, {"input": {"n": 16, "p": 0.34, "k": 0}, "output": 0.0012962923816305}, {"input": {"n": 1, "p": 0.13, "k": 1}, "output": 0.13}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = x^2 \\), we want to determine the time taken to compute its integral over a specified interval using two different Monte Carlo methods: one using vectorized operations and the other using a loop. What are the respective times taken by these methods for a given interval \\([a, b]\\) and a specified number of points (`num_puntos`)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The lower bound of the interval.\n  `b` (float): The upper bound of the interval.\n  `num_puntos` (int): The number of points to use in the Monte Carlo integration.\n\nOutput:\n  `return` (dict): A dictionary containing the time taken for the vectorized approach (`vector_time`) and the loop-based approach (`loop_time`). Both values are floats representing the time in milliseconds.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy import integrate\nimport time\n\n# all class and function definitions in the code file, if any\ndef function(a):\n    \"\"\"Returns f(a)\"\"\"\n    return a**2\n\ndef max_point(fun, a, b):\n    \"\"\"Calculate the maximum point of the function fun between a, b values\"\"\"\n    M = fun(a)\n    for i in range(1000):\n        rnd = np.random.uniform(a, b)\n        if rnd > M: \n            M = rnd \n    return M\n\ndef integra_mc_vector(fun, a, b, num_puntos=10000):\n    \"\"\"Calculate the integral of the function fun with Monte Carlo method\n     with vectors and returns the result in seconds\"\"\"\n    tic = time.process_time()\n\n    # Step 1 - Calculate the maximum of the function\n    M = max_point(fun, a, b)\n\n    # Step 2 - Generate random points\n    x = np.random.uniform(a, b, num_puntos)\n    y = np.random.uniform(0.0, M, num_puntos)\n    \n    x = fun(x)\n    below = np.sum(y < x)   # Number of points below the curve\n\n    # Step 3 - Calculate the area below the curve\n    area = (below / num_puntos) * (b - a) * M\n    \n    toc = time.process_time()\n    return 1000 * (toc - tic)\n\ndef integra_mc_loop(fun, a, b, num_puntos=10000):\n    \"\"\"Calculate the integral of the function fun with Monte Carlo method\n     with a loop with num_puntos iterations and return the result in seconds\"\"\"\n    tic = time.process_time()\n    M = max_point(fun, a, b)\n\n    below = 0   # Number of points below the curve\n    for j in range(num_puntos):\n        x = np.random.uniform(a, b)\n        y = np.random.uniform(0.0, M)\n\n        if y <= fun(x):\n            below += 1\n        \n    area = (below / num_puntos) * (b - a) * M\n    \n    toc = time.process_time()\n    return 1000 * (toc - tic)\n\n# main function\ndef main_solution(a, b, num_puntos):\n    \"\"\"\n    Calculate the time taken to compute the integral of a function using Monte Carlo methods with both vectorized and loop-based approaches.\n    \n    Parameters:\n    a (float): The lower bound of the interval.\n    b (float): The upper bound of the interval.\n    num_puntos (int): The number of points to use in the Monte Carlo integration.\n    \n    Returns:\n    dict: A dictionary containing the time taken for the vectorized approach and the loop-based approach.\n    \"\"\"\n    vector_time = integra_mc_vector(function, a, b, num_puntos)\n    loop_time = integra_mc_loop(function, a, b, num_puntos)\n    \n    return {\n        \"vector_time\": vector_time,\n        \"loop_time\": loop_time\n    }", "input_generator": "import numpy as np\n\ndef input_generator():\n    a = np.random.uniform(-10, 0)  # Random lower bound between -10 and 0\n    b = np.random.uniform(0, 10)   # Random upper bound between 0 and 10\n    num_puntos = np.random.randint(1000, 100000)  # Random number of points between 1000 and 100000\n    return {\n        \"a\": a,\n        \"b\": b,\n        \"num_puntos\": num_puntos\n    }", "io_pairs": [{"input": {"a": -9.014932211153585, "b": 0.3532491888375311, "num_puntos": 4461}, "output": {"vector_time": 0.0, "loop_time": 31.25}}, {"input": {"a": -5.812098880190119, "b": 0.5197393578555598, "num_puntos": 59961}, "output": {"vector_time": 0.0, "loop_time": 343.75}}, {"input": {"a": -0.10872721607014313, "b": 5.801465867658269, "num_puntos": 91274}, "output": {"vector_time": 0.0, "loop_time": 515.625}}, {"input": {"a": -6.426095840815033, "b": 5.460117320884962, "num_puntos": 15331}, "output": {"vector_time": 0.0, "loop_time": 93.75}}, {"input": {"a": -7.114607221077852, "b": 8.582156859803854, "num_puntos": 29514}, "output": {"vector_time": 0.0, "loop_time": 171.875}}, {"input": {"a": -0.9221625577688162, "b": 4.469567292794418, "num_puntos": 74620}, "output": {"vector_time": 0.0, "loop_time": 437.5}}, {"input": {"a": -6.7366650342078715, "b": 6.727552583639238, "num_puntos": 53074}, "output": {"vector_time": 0.0, "loop_time": 296.875}}, {"input": {"a": -1.2180263635422044, "b": 0.34188714623735295, "num_puntos": 25070}, "output": {"vector_time": 15.625, "loop_time": 140.625}}, {"input": {"a": -1.4662443307372843, "b": 8.629242096713433, "num_puntos": 69499}, "output": {"vector_time": 0.0, "loop_time": 390.625}}, {"input": {"a": -7.090095488743962, "b": 3.9647708010261673, "num_puntos": 44961}, "output": {"vector_time": 0.0, "loop_time": 265.625}}], "error_log": []}
{"context": "In a data center network, a fat tree topology is used to efficiently route traffic between servers. Given a fat tree network with a parameter `k`, which defines the size of the network, and two server nodes `v1` and `v2`, what is the shortest path between these two nodes that does not conflict with any reserved paths?\n\nThe input and output requirements are as follows:\n\nInput:\n  `k` (int): The parameter for the fat tree topology, determining the size of the network.\n  `v1` (int): The starting vertex for the path search.\n  `v2` (int): The ending vertex for the path search.\n\nOutput:\n  `return` (list of int or None): The shortest path between `v1` and `v2` as a list of vertex indices. If no path exists, returns `None`.", "reference_code": "# import necessary packages\nimport random\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.edges = {}\n        self.k = -1\n        self.X = -1\n        self.Y = -1\n        self.Z = -1\n        self.END = -1\n\n    def add_vertices(self, vertex_list):\n        for v in vertex_list:\n            self.vertices[v] = Node(v)\n\n    def get_neighbors(self, vertex):\n        return self.vertices[vertex].neighbors\n\n    def is_path_free(self, path):\n        for i in range(len(path) - 1):\n            e1 = (path[i], path[i+1])\n            e2 = (path[i+1], path[i])\n            if e1 in self.edges:\n                e = self.edges[e1]\n                if e.reserved:\n                    return False\n            else:\n                e = self.edges[e2]\n                if e.reserved:\n                    return False\n        return True\n\n    def reserve_path(self, path):\n        for i in range(len(path) - 1):\n            e1 = (path[i], path[i+1])\n            e2 = (path[i+1], path[i])\n            if e1 in self.edges:\n                e = self.edges[e1]\n                e.set_reserved()\n            else:\n                e = self.edges[e2]\n                e.set_reserved()\n\n    def pair_shortest_paths(self, v1, v2):\n        queue = deque()\n        v1_list = [v1]\n        queue.append(v1_list)\n\n        answers = []\n        stop = False\n        while len(queue) > 0:\n            path = queue.popleft()\n            x = path[-1]\n            for y in self.get_neighbors(x):\n                if y == v2:\n                    temp = path.copy()\n                    temp.append(y)\n                    answers.append(temp)\n                stop |= y == v2\n                if not stop:\n                    temp = path.copy()\n                    temp.append(y)\n                    queue.append(temp)\n        return answers\n\n    def get_pod(self, vertex):\n        return ((vertex - self.Z) // (self.k // 2)) // (self.k // 2) \n\n    def get_switch_from_server(self, vertex, pod):\n        z_index = (vertex - self.Z) // (self.k // 2)\n        return self.Y + z_index\n\n    def get_switch_from_core(self, core, pod):\n        half_k = self.k // 2\n        core_index = core // half_k\n        return self.X + (pod * half_k) + core_index\n\n    def get_core_path(self, core, v1, v2):\n        pod1 = self.get_pod(v1)\n        pod2 = self.get_pod(v2)\n        top_switch_1 = self.get_switch_from_core(core, pod1)\n        top_switch_2 = self.get_switch_from_core(core, pod2)\n        bottom_switch_1 = self.get_switch_from_server(v1, pod1)\n        bottom_switch_2 = self.get_switch_from_server(v2, pod2)\n        return [v1, bottom_switch_1, top_switch_1, core, top_switch_2, bottom_switch_2, v2]\n\n    def get_path_linear_cores(self, v1, v2):\n        assert(v1 != v2)\n        if (self.get_pod(v1) == self.get_pod(v2)):\n            return None\n        for i in range (0, (self.k ** 2) // 4):\n            path = self.get_core_path(i, v1, v2)\n            if self.is_path_free(path):\n                self.reserve_path(path)\n                return path\n        return None\n\n    def add_edge(self, e):\n        self.edges[e] = Edge(e)\n        v1 = self.vertices.get(e[0])\n        v1.add_neighbor(e[1])\n        v2 = self.vertices.get(e[1])\n        v2.add_neighbor(e[0])\n\n    def add_edges(self, edge_list):\n        for e in edge_list:\n            self.add_edge(e)\n\nclass Node:\n    BUFFER_SIZE = 200\n    def __init__(self, label):\n        self.name = label\n        self.neighbors = set()\n        self.queue = deque()\n        self.dropped_set = set()\n\n    def __eq__(self, other):\n        return self.name == other.name\n    def __str__(self):\n        return str(self.name)\n    def __hash__(self):\n        return hash(self.name)\n\n    def add_neighbor(self, n):\n        self.neighbors.add(n)\n\n    def degree(self):\n        return len(self.neighbors)\n\nclass Edge:\n    def __init__(self, e):\n        self.first = e[0]\n        self.second = e[1]\n        self.rate = 1\n        self.reserved = False\n    def __eq__(self, other):\n        return self.first == other.first and self.second == other.second\n    def __str__(self):\n        return \"{} , {}\".format(self.first, self.second)\n    def __hash__(self):\n        return hash((self.first, self.second))\n    def set_reserved(self):\n        assert(not self.reserved)\n        self.reserved = True\n\ndef build_fat_tree(k):\n    g = Graph()\n    g.k = k\n    X = (k**2 ) // 4\n    Y = X + (k ** 2) // 2\n    Z = Y + (k ** 2) // 2\n    END = Z + (k ** 3) // 4\n    g.X = X\n    g.Y = Y\n    g.Z = Z\n    g.END = END\n    g.add_vertices(range(END))\n\n    temp = Y\n    for i in range(Z, END, k // 2):\n        g.add_edges([(temp, server) for server in range(i, i + k // 2)])\n        temp += 1\n\n    for i in range(Y, Z):\n        index = (i - Y) // (k // 2)\n        pod = (index * (k // 2)) + X\n        g.add_edges([(i, first_agg) for first_agg in range(pod, pod + k // 2)])\n\n    for i in range(0, X, k//2):\n        core_nodes = range(i, i + k//2)\n        for j in range(X + (i // (k // 2)), Y, k // 2):\n            g.add_edges([(j, core_node) for core_node in core_nodes])\n\n    return g\n\n# main function\ndef main_solution(k, v1, v2):\n    # Build the fat tree graph\n    graph = build_fat_tree(k)\n    \n    # Find the shortest path between v1 and v2\n    path = graph.get_path_linear_cores(v1, v2)\n    \n    # Convert the path to a JSON serializable format\n    if path is None:\n        return None\n    return path", "input_generator": "import random\n\ndef input_generator():\n    k = random.choice([4, 6, 8])  # Reasonable values for k in fat-tree topology\n    graph = build_fat_tree(k)\n    \n    # Generate random server vertices (v1 and v2 must be in different pods)\n    servers = list(range(graph.Z, graph.END))\n    v1 = random.choice(servers)\n    pod1 = graph.get_pod(v1)\n    \n    # Ensure v2 is in a different pod\n    servers_in_other_pods = [v for v in servers if graph.get_pod(v) != pod1]\n    if not servers_in_other_pods:\n        v2 = v1\n        while v2 == v1:  # Fallback if all servers are in the same pod (unlikely for k >=4)\n            v2 = random.choice(servers)\n    else:\n        v2 = random.choice(servers_in_other_pods)\n    \n    return {'k': k, 'v1': v1, 'v2': v2}", "io_pairs": [{"input": {"k": 6, "v1": 63, "v2": 54}, "output": [63, 33, 15, 0, 12, 30, 54]}, {"input": {"k": 8, "v1": 136, "v2": 81}, "output": [136, 62, 28, 0, 16, 48, 81]}, {"input": {"k": 6, "v1": 89, "v2": 59}, "output": [89, 41, 21, 0, 12, 31, 59]}, {"input": {"k": 6, "v1": 66, "v2": 60}, "output": [66, 34, 15, 0, 12, 32, 60]}, {"input": {"k": 8, "v1": 130, "v2": 122}, "output": [130, 60, 28, 0, 24, 58, 122]}, {"input": {"k": 8, "v1": 103, "v2": 153}, "output": [103, 53, 20, 0, 32, 66, 153]}, {"input": {"k": 6, "v1": 86, "v2": 76}, "output": [86, 40, 21, 0, 18, 37, 76]}, {"input": {"k": 6, "v1": 77, "v2": 65}, "output": [77, 37, 18, 0, 15, 33, 65]}, {"input": {"k": 6, "v1": 49, "v2": 54}, "output": [49, 28, 9, 0, 12, 30, 54]}, {"input": {"k": 6, "v1": 80, "v2": 90}, "output": [80, 38, 18, 0, 24, 42, 90]}], "error_log": []}
{"context": "In a strategic decision-making scenario, an agent uses a tree structure to decide whether to cooperate or defect based on its memory. Given the depth of the tree, the length of the memory, and the memory state, what decision will the agent make?\n\nThe input and output requirements are as follows:\n\nInput:\n  `depth` (int): The depth of the tree to be created.\n  `memoryLength` (int): The length of the memory used for evaluation.\n  `memory` (list of tuples): A list of tuples where each tuple contains two integers representing the memory state.\n\nOutput:\n  `return` (str): The decision made by the agent, either 'cooperate' or 'defect'.", "reference_code": "# import necessary packages\nfrom copy import deepcopy\nimport random\nimport math\n\n# all class and function definitions in the code file, if any\nclass Tree:\n    def __init__(self):\n        self.tree_list = []\n\n    def add(self, value):\n        self.tree_list.append(value)\n\n    def get_tree_list(self):\n        return self.tree_list\n\n# main function\ndef main_solution(depth, memoryLength, memory):\n    # Convert memory to a list of tuples\n    memory = [(int(m[0]), int(m[1])) for m in memory]\n\n    # Create a tree and its list representation\n    tree, tree_list = createTree(depth, memoryLength)\n\n    # Reorder the tree list\n    tree_list = reorder(depth, tree_list)\n\n    # Evaluate the tree based on the memory\n    decision = evaluate(memory, memoryLength, tree_list)\n\n    # Return the decision\n    return decision\n\ndef createTree(depth, memoryLength):\n    funcNodes = ['AND', 'OR', 'NOT', 'XOR']\n    agents = ['P', 'O']\n    tree_list = []\n\n    # Initialize a tree\n    tree = Tree()\n\n    if depth == 1:\n        # Obtain the two things needed to make a leaf\n        agent = random.choice(agents)\n        num = random.randrange(1, (memoryLength + 1))\n\n        # The termination node created\n        leaf = agent + str(num)\n\n        # Set the value equal to the created leaf\n        tree.add(leaf)\n        tree_list.append(leaf)\n    else:\n        for level in range(depth):\n            if level == 0:\n                value = random.choice(funcNodes)\n\n                tree.add(value)\n                tree_list.append(value)\n            elif level is not (depth - 1):\n                for node in range(2 ** level):\n                    value = random.choice(funcNodes)\n\n                    tree.add(value)\n                    tree_list.append(value)\n            else:\n                for node in range(2 ** level):\n                    agent = random.choice(agents)\n                    num = random.randrange(1, (memoryLength + 1))\n\n                    leaf = agent + str(num)\n\n                    tree.add(leaf)\n                    tree_list.append(leaf)\n\n    return tree, tree_list\n\ndef reorder(depth, list):\n    count = 0\n    num = 0\n    # Holds the position of the element we want to move\n    position = (2**(depth - 1) - 1)\n\n    # We don't need to worry about these two trees\n    if depth == 1 or depth == 2:\n        return list\n    # Worry about the rest\n    else:\n        # If the depth is 3 then we move the elements 1 back\n        if depth == 3:\n            count = 2\n        # Otherwise we move the elements back by a power of 2 (in terms of the loop)\n        else:\n            num = depth - 2\n            count += 2**num\n\n        for level in reversed(range(count)):\n            for i in range(0, 2):\n                x = list[position]\n                del list[position]\n                list.insert(position - level, x)\n                position += 1\t\n\n    return list\n\ndef evaluate(memory, memoryLength, tree):\n    # Holds a tree that I can change\n    temp = deepcopy(tree)\n\n    # Go through the list backwards\n    for loc in reversed(range(len(temp))):\n        # Determine whether it is a leaf node or not\n        if temp[loc][1:].isdigit():\n            # Location of the memory spot\n            memoryLocation = memoryLength - int(temp[loc][1:])\n\n            # Unpacking the memory tuple\n            x, y = memory[memoryLocation]\n\n            # If the leaf has a P in it use the x position, else use the y\n            if temp[loc][0] == 'P':\n                temp[loc] = x\n            elif temp[loc][0] == 'O':\n                temp[loc] = y\n        else:\n            # If the locations to the right of temp have been evaluated already\n            if temp[loc+1] == 0 or temp[loc+1] == 1:\n                if temp[loc] == 'NOT':\n                    if temp[loc+1] >= temp[loc+2]:\n                        t = temp[loc+1] - temp[loc+2]\n                    else:\n                        t = temp[loc+2] - temp[loc+1]\n\n                    # Does the flipping of the bit\n                    if t == 1:\n                        t = 0\n                    else:\n                        t = 1\n\n                    # Gets rid of the completely evaluated locations\n                    del temp[loc + 2]\n                    del temp[loc + 1]\n\n                    temp[loc] = t\n                elif temp[loc] == 'AND':\n                    # Determines whether it should be a 1 or a zero\n                    if temp[loc+1] == 1 and temp[loc+2] == 1:\n                        t = 1\n                    else:\n                        t = 0\n\n                    # Gets rid of the completely evaluated locations\n                    del temp[loc + 2]\n                    del temp[loc + 1]\n\n                    temp[loc] = t\n                if temp[loc] == 'OR':\n                    # Determines whether it should be a 1 or a zero\n                    if temp[loc+1] == 1 or temp[loc+2] == 1:\n                        t = 1\n                    else:\n                        t = 0\n\n                    # Gets rid of the completely evaluated locations\n                    del temp[loc + 2]\n                    del temp[loc + 1]\n\n                    temp[loc] = t\n                if temp[loc] == 'XOR':\n                    # Determines whether it should be a 1 or a zero\n                    if temp[loc+1] == 1 and temp[loc+2] == 0:\n                        t = 1\n                    elif temp[loc+1] == 0 and temp[loc+2] == 1:\n                        t = 1\n                    else:\n                        t = 0\n\n                    # Gets rid of the completely evaluated locations\n                    del temp[loc + 2]\n                    del temp[loc + 1]\n\n                    temp[loc] = t\n\n    # Determines whether the agent cooperates or defects based on the tree evaluation\n    if temp[0] == 1:\n        return 'cooperate'\n    elif temp[0] == 0:\n        return 'defect'", "input_generator": "import random\n\ndef input_generator():\n    depth = random.randint(1, 5)\n    memoryLength = random.randint(1, 10)\n    memory = []\n    for _ in range(memoryLength):\n        x = random.randint(0, 1)\n        y = random.randint(0, 1)\n        memory.append((str(x), str(y)))\n    return {\n        'depth': depth,\n        'memoryLength': memoryLength,\n        'memory': memory\n    }", "io_pairs": [{"input": {"depth": 3, "memoryLength": 3, "memory": [["1", "1"], ["1", "1"], ["0", "0"]]}, "output": "cooperate"}, {"input": {"depth": 3, "memoryLength": 2, "memory": [["0", "1"], ["0", "1"]]}, "output": "cooperate"}, {"input": {"depth": 4, "memoryLength": 2, "memory": [["0", "0"], ["0", "1"]]}, "output": "defect"}, {"input": {"depth": 1, "memoryLength": 2, "memory": [["0", "0"], ["0", "1"]]}, "output": "defect"}, {"input": {"depth": 2, "memoryLength": 3, "memory": [["0", "0"], ["0", "0"], ["1", "1"]]}, "output": "defect"}, {"input": {"depth": 1, "memoryLength": 1, "memory": [["1", "0"]]}, "output": "cooperate"}, {"input": {"depth": 1, "memoryLength": 3, "memory": [["1", "1"], ["0", "1"], ["0", "1"]]}, "output": "cooperate"}, {"input": {"depth": 4, "memoryLength": 3, "memory": [["0", "1"], ["0", "0"], ["0", "1"]]}, "output": "defect"}, {"input": {"depth": 2, "memoryLength": 1, "memory": [["1", "0"]]}, "output": "cooperate"}, {"input": {"depth": 4, "memoryLength": 1, "memory": [["1", "1"]]}, "output": "cooperate"}], "error_log": []}
{"context": "Given a positive integer, determine whether it has exactly three distinct factors. What is the result of this determination for a given integer `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): A positive integer to be checked if it has exactly three distinct factors.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input integer `n` has exactly three distinct factors.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef isThreeDisctFactors(n):\n    if n < 2:\n        return False\n    num = int(math.sqrt(n))\n\n    # judge n is a square number\n    if num ** 2 == n:\n        if isprime(num):\n            return True\n        else:\n            return False\n    else:\n        return False\n\n# judge n is a prime \ndef isprime(num):\n    if num < 2:\n        return False\n    sqrt_num = int(math.sqrt(num))\n    for i in range(2, sqrt_num + 1):\n        if num % i == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = isThreeDisctFactors(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a small prime number to ensure n = p^2 is manageable\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    p = random.choice(primes)\n    n = p ** 2\n    \n    # Occasionally return a non-square or square of non-prime to test negative cases\n    if random.random() < 0.3:\n        if random.random() < 0.5:\n            # Non-square number\n            n = random.randint(2, 100)\n            while int(math.sqrt(n)) ** 2 == n:\n                n = random.randint(2, 100)\n        else:\n            # Square of a non-prime\n            non_primes = [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38, 39, 40, 42, 44, 45, 46, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 60, 62, 63, 64, 65, 66, 68, 69, 70, 72, 74, 75, 76, 77, 78, 80, 81, 82, 84, 85, 86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 98, 99, 100]\n            q = random.choice(non_primes)\n            n = q ** 2\n    \n    return {'n': n}", "io_pairs": [{"input": {"n": 841}, "output": true}, {"input": {"n": 48}, "output": false}, {"input": {"n": 3844}, "output": false}, {"input": {"n": 76}, "output": false}, {"input": {"n": 30}, "output": false}, {"input": {"n": 7921}, "output": true}, {"input": {"n": 5329}, "output": true}, {"input": {"n": 961}, "output": true}, {"input": {"n": 121}, "output": true}, {"input": {"n": 9025}, "output": false}], "error_log": []}
{"context": "In the context of fluid dynamics, you are tasked with determining the diameter of a pipe, the Reynolds number, and the friction coefficient for a given set of parameters. Given the friction factor (`f`), the length of the pipe (`l`), the flow rate (`q`), the head loss (`deltaH`), and the kinematic viscosity (`v`), what are the calculated values for the pipe diameter (`d`), the Reynolds number (`rey`), and the friction coefficient (`k`)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `f` (float): Friction factor.\n  `l` (float): Length of the pipe.\n  `q` (float): Flow rate.\n  `deltaH` (float): Head loss.\n  `v` (float): Kinematic viscosity.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `d` (float): Diameter of the pipe, rounded to 4 decimal places.\n    - `rey` (float): Reynolds number, rounded to 4 decimal places.\n    - `k` (float): Friction coefficient, rounded to 4 decimal places.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(f, l, q, deltaH, v):\n    # Convert inputs to appropriate types if necessary\n    f = float(f)\n    l = float(l)\n    q = float(q)\n    deltaH = float(deltaH)\n    v = float(v)\n    \n    # Constants\n    g = 9.81\n    epsilon = 0.000002\n    \n    # Calculate d\n    d = ((8 * f * l * (q ** 2)) / ((math.pi ** 2) * g * deltaH)) ** (0.2)\n    \n    # Calculate rey\n    rey = ((4 * q) / (math.pi * d * v))\n    \n    # Calculate k\n    k = (0.25) / (math.log10(((epsilon) / (3.7 * d)) + ((5.74) / (rey ** 0.9)))) ** 2\n    \n    # Return the results as a dictionary\n    return {\n        'd': round(d, 4),\n        'rey': round(rey, 4),\n        'k': round(k, 4)\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate reasonable random values for the inputs\n    f = random.uniform(0.001, 0.1)  # Friction factor\n    l = random.uniform(10, 1000)    # Length of pipe (m)\n    q = random.uniform(0.1, 10)     # Flow rate (m^3/s)\n    deltaH = random.uniform(1, 100) # Head loss (m)\n    v = random.uniform(1e-6, 1e-4)  # Kinematic viscosity (m^2/s)\n    \n    return {\n        'f': f,\n        'l': l,\n        'q': q,\n        'deltaH': deltaH,\n        'v': v\n    }", "io_pairs": [{"input": {"f": 0.03213002620162524, "l": 73.27016822510797, "q": 5.799709042335609, "deltaH": 99.51207023004808, "v": 1.314868719493444e-05}, "output": {"d": 0.5802, "rey": 967953.9594, "k": 0.0118}}, {"input": {"f": 0.015467403647405575, "l": 767.0988027208107, "q": 4.92280775062393, "deltaH": 48.331310478392055, "v": 2.9163177378111644e-05}, "output": {"d": 0.8676, "rey": 247725.5077, "k": 0.0149}}, {"input": {"f": 0.017363937673081593, "l": 185.27579790178197, "q": 7.481542776331189, "deltaH": 95.06101528361219, "v": 1.0803500932356495e-05}, "output": {"d": 0.6901, "rey": 1277683.139, "k": 0.0112}}, {"input": {"f": 0.05596986731128998, "l": 112.84313854949994, "q": 3.5552174988130987, "deltaH": 68.77662568017121, "v": 8.504124720598455e-05}, "output": {"d": 0.6257, "rey": 85070.3544, "k": 0.0185}}, {"input": {"f": 0.06376305714945846, "l": 428.237097574078, "q": 7.71084636668962, "deltaH": 73.66310137891676, "v": 6.482569615708456e-05}, "output": {"d": 1.1274, "rey": 134338.1084, "k": 0.0168}}, {"input": {"f": 0.09946265437969974, "l": 240.56534912340416, "q": 1.9161754264360453, "deltaH": 67.9852073190074, "v": 5.355798318145575e-05}, "output": {"d": 0.6393, "rey": 71256.9253, "k": 0.0192}}, {"input": {"f": 0.05430030958377366, "l": 982.32949008406, "q": 3.974736695166376, "deltaH": 99.8209856995282, "v": 6.638375796969923e-05}, "output": {"d": 0.9305, "rey": 81929.7311, "k": 0.0186}}, {"input": {"f": 0.0644584003407823, "l": 537.9680597154168, "q": 6.996962913256357, "deltaH": 48.688539295479366, "v": 5.216777100505416e-05}, "output": {"d": 1.2357, "rey": 138199.8209, "k": 0.0167}}, {"input": {"f": 0.017855680221268547, "l": 213.5591424102243, "q": 6.517292948169628, "deltaH": 91.24415619441922, "v": 9.423439793108227e-05}, "output": {"d": 0.6812, "rey": 129270.3294, "k": 0.017}}, {"input": {"f": 0.09037010917193508, "l": 429.65222349841616, "q": 3.96589707993447, "deltaH": 58.850545570743876, "v": 1.2169338856141766e-05}, "output": {"d": 0.9697, "rey": 427903.1424, "k": 0.0135}}], "error_log": []}
{"context": "In the context of cellular automata, consider a grid of cells that evolve over time based on a specific rule. Given the number of rows and columns in the grid, and a rule number that defines the behavior of the cells, what is the final state of the grid after a certain number of iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `rows` (int): The number of rows in the automaton grid.\n  `columns` (int): The number of columns in the automaton grid.\n  `rule` (int): The rule number (0-255) that defines the cellular automaton behavior.\n\nOutput:\n  `return` (list of lists of int): The final state of the automaton grid, where each element is either 0 or 1.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef to_bin(x):\n    tmp = bin(x).replace(\"b\", \"\")\n    difference = 0\n\n    if len(tmp) < 8:\n        difference = 8 - len(tmp)\n\n    zeros = \"\"\n    for i in range(0, difference):\n        zeros += \"0\"\n\n    tmp = zeros + tmp\n    if len(tmp) > 8:\n        tmp = tmp[1:len(tmp)]\n    return tmp\n\n\ndef to_reversed_array(bin_string):\n    bin_array = np.zeros((1, 8), int)[0]\n    i = 0\n    for x in bin_string:\n        bin_array[7 - i] = int(x)\n        i += 1\n    return bin_array\n\n\ndef set_cell(string_number, sample):\n    number = int(string_number, 2)\n    if sample[number] == 1:\n        return 1\n    else:\n        return 0\n\n\n# main function\ndef main_solution(rows, columns, rule):\n    # Convert rule to a reversed binary array\n    sample = to_reversed_array(to_bin(rule))\n\n    # Initialize the automaton grid\n    automat = np.zeros((rows, columns), int)\n    automat[0][int(columns / 2)] = 1\n\n    # Update the automaton grid based on the rule\n    for i in range(1, rows):\n        for j in range(0, columns):\n            if j == 0:\n                tmp = str(automat[i - 1][columns - 1]) + str(automat[i - 1][j]) + str(automat[i - 1][j + 1])\n                automat[i][j] = set_cell(tmp, sample)\n            elif j == columns - 1:\n                tmp = str(automat[i - 1][j - 1]) + str(automat[i - 1][j]) + str(automat[i - 1][0])\n                automat[i][j] = set_cell(tmp, sample)\n            else:\n                tmp = str(automat[i - 1][j - 1]) + str(automat[i - 1][j]) + str(automat[i - 1][j + 1])\n                automat[i][j] = set_cell(tmp, sample)\n\n    # Convert the final state of the automaton to a JSON serializable format\n    final_state = automat.tolist()\n    return final_state", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    rows = random.randint(5, 20)\n    columns = random.randint(5, 20)\n    rule = random.randint(0, 255)\n    return {'rows': rows, 'columns': columns, 'rule': rule}", "io_pairs": [{"input": {"rows": 6, "columns": 9, "rule": 141}, "output": [[0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 1, 1], [1, 1, 0, 0, 1, 0, 1, 1, 1], [1, 0, 0, 0, 1, 0, 1, 1, 1], [0, 0, 1, 0, 1, 0, 1, 1, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0]]}, {"input": {"rows": 5, "columns": 7, "rule": 166}, "output": [[0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1]]}, {"input": {"rows": 8, "columns": 5, "rule": 13}, "output": [[0, 0, 1, 0, 0], [1, 0, 1, 0, 1], [0, 0, 1, 0, 1], [0, 0, 1, 0, 1], [0, 0, 1, 0, 1], [0, 0, 1, 0, 1], [0, 0, 1, 0, 1], [0, 0, 1, 0, 1]]}, {"input": {"rows": 7, "columns": 7, "rule": 138}, "output": [[0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0]]}, {"input": {"rows": 8, "columns": 6, "rule": 107}, "output": [[0, 0, 0, 1, 0, 0], [1, 1, 1, 0, 0, 1], [0, 0, 1, 0, 1, 1], [0, 1, 0, 1, 1, 1], [1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1]]}, {"input": {"rows": 6, "columns": 9, "rule": 209}, "output": [[0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0, 0]]}, {"input": {"rows": 5, "columns": 7, "rule": 152}, "output": [[0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0]]}, {"input": {"rows": 5, "columns": 5, "rule": 179}, "output": [[0, 0, 1, 0, 0], [1, 1, 0, 1, 1], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1]]}, {"input": {"rows": 7, "columns": 7, "rule": 101}, "output": [[0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 0, 1, 1, 1], [1, 0, 1, 1, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0]]}, {"input": {"rows": 5, "columns": 6, "rule": 243}, "output": [[0, 0, 0, 1, 0, 0], [1, 1, 1, 0, 1, 1], [1, 1, 1, 1, 0, 1], [1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1]]}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, the AI needs to make a move on a given board. Given the size of the board and its initial state, what will be the board's state after the AI makes its move?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_size` (int): The size of the board (e.g., 3 for a 3x3 board).\n  `initial_state` (list of lists of int): The initial state of the board represented as a 2D list of integers. Each element can be 0 (empty), 1 (X), or -1 (O).\n\nOutput:\n  `return` (list of lists of int): The final state of the board after the AI's move, represented as a 2D list of integers.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef ai_turn(state):\n    state_list = expand(state, depth=1)\n    for i in range(len(state_list)):\n        if is_win(state_list[i][0]):\n            state_list[i][1] = 5\n        else:\n            sub_state_list = expand(state_list[i][0], depth=2)\n            state_list[i][1] = get_state_value(sub_state_list, depth=2)\n    \n    state_list = sorted(state_list, key=lambda tup: tup[1], reverse=True)\n    return state_list, state_list[0][0]\n\ndef get_state_value(state_list, depth=None):\n    if len(state_list) == 1:\n        return 0\n    \n    val = 0\n    for i in range(len(state_list)):\n        if is_win(state_list[i][0]):\n            if depth % 2 == 1:\n                state_list[i][1] = -10\n            else:\n                state_list[i][1] = 1        \n        else:\n            sub_state_list = expand(state_list[i][0], depth=depth)\n            state_list[i][1] = get_state_value(sub_state_list, depth=depth + 1)\n\n        val += state_list[i][1]\n\n    return val    \n\ndef expand(state, depth=None):\n    sub_state_list = []\n    ip = -1 if depth % 2 == 0 else 1\n\n    for i in range(state.shape[0]):\n        for j in range(state.shape[0]):\n            sub_state = state.copy()\n            if state[i, j] == 0: \n                sub_state[i, j] = ip\n                sub_state_list.append([sub_state, 0])   \n    \n    return sub_state_list\n\ndef is_win(state):\n    for i in range(state.shape[0]):\n        for j in range(state.shape[0]):\n            if state[i, j] != 0:\n                # Horizontal\n                if j != 0 and j != state.shape[0] - 1:\n                    if state[i, j] == state[i, j - 1] and state[i, j] == state[i, j + 1]:\n                        return True\n                # Vertical\n                if i != 0 and i != state.shape[0] - 1:\n                    if state[i, j] == state[i - 1, j] and state[i, j] == state[i + 1, j]:\n                        return True\n                \n                # Diagonal main\n                if i != 0 and j != 0 and i != state.shape[0] - 1 and j != state.shape[0] - 1:\n                    if state[i, j] == state[i - 1, j - 1] and state[i, j] == state[i + 1, j + 1]:\n                        return True\n                \n                # Diagonal alt\n                if i != 0 and j != 0 and i != state.shape[0] - 1 and j != state.shape[0] - 1:\n                    if state[i, j] == state[i - 1, j + 1] and state[i, j] == state[i + 1, j - 1]:\n                        return True\n    return False\n\n# main function\ndef main_solution(board_size, initial_state):\n    # Convert JSON serializable input to numpy array\n    state = np.array(initial_state)\n    \n    # AI's turn\n    state_list, state = ai_turn(state)\n    \n    # Convert numpy array back to JSON serializable output\n    final_state = state.tolist()\n    \n    return final_state", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    board_size = random.randint(3, 5)\n    initial_state = np.zeros((board_size, board_size), dtype=int).tolist()\n    \n    # Randomly place some moves (1 for player, -1 for AI)\n    moves = random.randint(0, board_size * board_size // 2)\n    for _ in range(moves):\n        i, j = random.randint(0, board_size-1), random.randint(0, board_size-1)\n        while initial_state[i][j] != 0:\n            i, j = random.randint(0, board_size-1), random.randint(0, board_size-1)\n        initial_state[i][j] = random.choice([1, -1])\n    \n    return {\n        'board_size': board_size,\n        'initial_state': initial_state\n    }", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given two polynomials represented by their coefficients, what are the coefficients of the resulting polynomial after performing a specified arithmetic operation (addition, subtraction, or multiplication) on them?\n\nThe input and output requirements are as follows:\n\nInput:\n  `poly1_coeffs` (list of int or float): Coefficients of the first polynomial in descending order of powers.\n  `poly2_coeffs` (list of int or float): Coefficients of the second polynomial in descending order of powers.\n  `operation` (str): The operation to perform on the two polynomials. Valid values are \"add\", \"subtract\", and \"multiply\".\n\nOutput:\n  `return` (list of int or float): Coefficients of the resulting polynomial in descending order of powers after performing the specified operation.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Polynomial(object):\n    def __init__(self, other):        \n        if not isinstance(other, list):\n            raise TypeError(\"Wrong type!\")\n        elif len(other)==0:\n            raise TypeError(\"Wrong type!\")\n        else:\n            for i in range(len(other)):\n                if not (isinstance(other[i], int) or isinstance(other[i], float)):\n                    raise TypeError(\"Wrong type!\")\n            self.coeffs = other[:]\n            _co = self.coeffs\n            if _co:\n                offs = 0\n                if _co[offs]==0 and len(_co)>1:\n                    offs += 1\n                    while offs < len(_co)-1 and _co[offs]==0:\n                        offs += 1\n                    del _co[:offs]\n\n    def __add__(self, val):\n        if isinstance(val, Polynomial):\n            if len(self.coeffs) > len(val.coeffs):\n                res = self.coeffs[:]\n                for i in range(len(val.coeffs)):\n                    res[len(self.coeffs) - i - 1] += val.coeffs[len(val.coeffs) - i - 1] \n            else:\n                res = val.coeffs[:]\n                for i in range(len(self.coeffs)-1,-1,-1):\n                    res[len(val.coeffs) - i - 1] += self.coeffs[len(self.coeffs) - i - 1]      \n        else:\n            if not (isinstance(val, int) or isinstance(val, float)):\n                raise TypeError(\"Wrong type!\")\n            else:\n                if self.coeffs:\n                    res = self.coeffs[:]\n                    res[-1] += val\n                else:\n                    res = val\n        return Polynomial(res)\n    def __radd__(self, other):\n        return self + other\n    def __rmul__(self, other):\n        return self * other\n    def __eq__(self, val):\n        if isinstance(val, Polynomial):\n            return self.coeffs == val.coeffs\n        elif not (isinstance(val, int) or isinstance(val, float)):\n            raise TypeError(\"Wrong type!\")\n        else:\n            return len(self.coeffs)==1 and self.coeffs[0]==val\n\n    def __mul__(self, val):\n        if isinstance(val, Polynomial):\n            selfcoeffs = self.coeffs\n            valcoeffs = val.coeffs\n            res = [0]*(len(selfcoeffs)+len(valcoeffs)-1)\n            for selfpow,selfcoef in enumerate(selfcoeffs):\n                for valpow,valcoef in enumerate(valcoeffs):\n                    res[selfpow+valpow] += selfcoef*valcoef\n        elif not (isinstance(val, int) or isinstance(val, float)):\n            raise TypeError(\"Wrong type!\")\n        else:\n            res = [coef*val for coef in self.coeffs]\n        return Polynomial(res)\n\n    def __str__(self):\n        res = []\n        c = self.coeffs[::-1]\n        for po,co in enumerate(c):\n            if co:\n                if po==0:\n                    po = ''\n                elif po == 1:\n                    po = 'x'\n                else:\n                    po = 'x'+str(po)\n                if po != '' and abs(co)==1:\n                    res.append(('-' if co<0 else '+')+po)\n                else:\n                    res.append(('-'+str(abs(co)) if co<0 else '+'+str(co))+po)\n        if res:\n            res.reverse()\n            res = ''.join(res)\n            if res[0]=='+':\n                return ''.join(res[1::])\n            return res\n        else:\n            return \"0\"\n\n    def __sub__(self, val):\n        return self.__add__(-val)\n    def __neg__(self):\n        return Polynomial([-co for co in self.coeffs])\n\n# main function\ndef main_solution(poly1_coeffs, poly2_coeffs, operation):\n    # Convert JSON serializable inputs to Polynomial objects\n    poly1 = Polynomial(poly1_coeffs)\n    poly2 = Polynomial(poly2_coeffs)\n    \n    # Perform the specified operation\n    if operation == \"add\":\n        result = poly1 + poly2\n    elif operation == \"subtract\":\n        result = poly1 - poly2\n    elif operation == \"multiply\":\n        result = poly1 * poly2\n    else:\n        raise ValueError(\"Invalid operation\")\n    \n    # Convert the result back to a JSON serializable format\n    return result.coeffs", "input_generator": "import random\n\ndef input_generator():\n    operations = [\"add\", \"subtract\", \"multiply\"]\n    operation = random.choice(operations)\n    \n    # Generate random coefficients for poly1\n    length1 = random.randint(1, 5)\n    poly1_coeffs = [random.randint(-10, 10) for _ in range(length1)]\n    \n    # Generate random coefficients for poly2\n    length2 = random.randint(1, 5)\n    poly2_coeffs = [random.randint(-10, 10) for _ in range(length2)]\n    \n    return {\n        \"poly1_coeffs\": poly1_coeffs,\n        \"poly2_coeffs\": poly2_coeffs,\n        \"operation\": operation\n    }", "io_pairs": [{"input": {"poly1_coeffs": [1, -9, 6], "poly2_coeffs": [-6, -1, 6], "operation": "multiply"}, "output": [-6, 53, -21, -60, 36]}, {"input": {"poly1_coeffs": [-9], "poly2_coeffs": [-5, -7, 10], "operation": "multiply"}, "output": [45, 63, -90]}, {"input": {"poly1_coeffs": [4, 8, -7, -7, -3], "poly2_coeffs": [-4, -4, -10], "operation": "multiply"}, "output": [-16, -48, -44, -24, 110, 82, 30]}, {"input": {"poly1_coeffs": [-4], "poly2_coeffs": [-7, -4, 8], "operation": "multiply"}, "output": [28, 16, -32]}, {"input": {"poly1_coeffs": [-3, 4, 8, 3], "poly2_coeffs": [7, -8, -3], "operation": "add"}, "output": [-3, 11, 0, 0]}, {"input": {"poly1_coeffs": [-5, -5], "poly2_coeffs": [8, 3, -5], "operation": "multiply"}, "output": [-40, -55, 10, 25]}, {"input": {"poly1_coeffs": [7, -7, 4], "poly2_coeffs": [1], "operation": "subtract"}, "output": [7, -7, 3]}, {"input": {"poly1_coeffs": [-9], "poly2_coeffs": [-6, -10, 8, 6, 5], "operation": "subtract"}, "output": [6, 10, -8, -6, -14]}, {"input": {"poly1_coeffs": [-6, -9], "poly2_coeffs": [-9], "operation": "add"}, "output": [-6, -18]}, {"input": {"poly1_coeffs": [4], "poly2_coeffs": [-9, -10, -2], "operation": "add"}, "output": [-9, -10, 2]}], "error_log": []}
{"context": "Given a matrix represented by its dimensions and a list of its elements, what are the orthogonal matrix Q and the upper triangular matrix R obtained from the QR decomposition of the matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): Number of rows in the matrix.\n  `n` (int): Number of columns in the matrix.\n  `entries` (list of int): List of integers representing the elements of the matrix in row-major order.\n\nOutput:\n  `return` (dict): A dictionary containing the QR decomposition results.\n    - `Q` (list of list of float): The orthogonal matrix Q.\n    - `R` (list of list of float): The upper triangular matrix R.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef qr(a):\n    m, n = a.shape\n    Q = a[:, 0] / np.sqrt(np.dot(a[:, 0], a[:, 0]))\n    for j in range(1, n):\n        q = a[:, j] - np.dot(Q, np.dot(Q.T, a[:, j]))\n        r = np.sqrt(q.dot(q))\n        Q = np.column_stack([Q, q / r])\n    R = np.dot(Q.T, a)\n    return Q, R\n\n# main function\ndef main_solution(m, n, entries):\n    # Convert JSON serializable inputs to numpy array\n    a = np.array(entries).reshape(m, n)\n    \n    # Perform QR decomposition\n    Q, R = qr(a)\n    \n    # Convert outputs to JSON serializable format\n    Q_list = Q.tolist()\n    R_list = R.tolist()\n    \n    return {\"Q\": Q_list, \"R\": R_list}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    m = random.randint(2, 5)\n    n = random.randint(2, 5)\n    entries = np.random.uniform(-10.0, 10.0, size=(m * n)).tolist()\n    return {\"m\": m, \"n\": n, \"entries\": entries}", "io_pairs": [{"input": {"m": 2, "n": 2, "entries": [2.5700685910977263, -3.862932096939855, -0.8882327682893774, -7.562159727978656]}, "output": {"Q": [[0.945145831841805, -0.3266486744991665], [-0.32664867449916657, -0.9451458318418051]], "R": [[2.719229672832007, -1.1808647186154213], [2.064052251906876e-16, 8.409165395766676]]}}, {"input": {"m": 2, "n": 2, "entries": [-5.680780451677736, 6.919954412813929, 1.482553288999938, 5.931276145256636]}, "output": {"Q": [[-0.9675918668407038, 0.25251926505461303], [0.2525192650546132, 0.9675918668407036]], "R": [[5.8710502292936, -5.197930115711031], [7.982304952244336e-16, 7.486476360671801]]}}, {"input": {"m": 2, "n": 2, "entries": [-3.96656870881102, -9.46643537223169, 5.3409842155553875, -2.045222633376911]}, "output": {"Q": [[-0.596225240590437, -0.8028172036540294], [0.8028172036540295, -0.5962252405904371]], "R": [[6.652802395421836, 4.002187791965081], [-5.595992149342895e-16, 8.819230530752792]]}}, {"input": {"m": 2, "n": 2, "entries": [-6.449173830602859, 2.6483937820132546, 6.148261336620443, 3.0463291959130423]}, "output": {"Q": [[-0.7237908432488697, 0.6900194310518295], [0.6900194310518295, 0.7237908432488696]], "R": [[8.910272754563385, 0.18514316982205803], [-5.091151668495348e-16, 4.03234834818954]]}}, {"input": {"m": 2, "n": 2, "entries": [5.757508366239916, -5.65175667926761, 5.201836095129517, 2.228515048755998]}, "output": {"Q": [[0.7420060944494031, -0.6703931352571739], [0.6703931352571739, 0.7420060944494031]], "R": [[7.759381505501255, -2.6996567098583597], [-1.737307113329391e-16, 5.442470627674046]]}}, {"input": {"m": 2, "n": 2, "entries": [-4.7186451649253325, -6.799822662845704, 7.698742800645391, 2.5154047972931863]}, "output": {"Q": [[-0.5225669580082785, -0.852598249117352], [0.8525982491173518, -0.5225669580082781]], "R": [[9.02974268199058, 5.69799236991259], [3.5630796768929865e-15, 4.483049463569809]]}}, {"input": {"m": 2, "n": 2, "entries": [-8.80826225342291, 7.613549050408285, -4.392366837999138, 0.07458409518235243]}, "output": {"Q": [[-0.8949047727503123, 0.44625715423812723], [-0.44625715423812773, -0.8949047727503124]], "R": [[9.842681055720002, -6.846685068846484], [4.864223770588321e-15, 3.330855070137646]]}}, {"input": {"m": 2, "n": 2, "entries": [2.2170261471525983, -9.215298603780727, -8.162818283699833, -2.8692207237906437]}, "output": {"Q": [[0.2621052294269014, -0.9650392990480084], [-0.9650392990480084, -0.2621052294269014]], "R": [[8.458534581702825, 0.35353280131959064], [-1.841574357724657e-16, 9.645163061196211]]}}, {"input": {"m": 2, "n": 2, "entries": [9.368280116923835, 1.2662587397466591, 5.3293173219484675, 7.23380767733088]}, "output": {"Q": [[0.8692001606732045, -0.49446039344489], [0.49446039344489007, 0.8692001606732045]], "R": [[10.77804692266509, 4.677463690279339], [8.155638947291453e-16, 5.661512000756898]]}}, {"input": {"m": 2, "n": 2, "entries": [5.458809875462933, 7.478426111706241, 7.160236878635157, -8.598539889649885]}, "output": {"Q": [[0.6062815015011991, 0.7952501121895246], [0.7952501121895246, -0.6062815015011991]], "R": [[9.00375462874342, -2.3039584000391393], [-1.0375365807668088e-16, 11.160354879350345]]}}], "error_log": []}
{"context": "Given the dimensions of a matrix, what is the zero matrix and its determinant?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The number of rows in the matrix.\n  `n` (int): The number of columns in the matrix.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `matrix` (list of lists of float): The zero matrix represented as a list of lists.\n    - `determinant` (float): The determinant of the zero matrix, which is always 0.0.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(m, n):\n    # Convert input arguments to the required types\n    m = int(m)\n    n = int(n)\n    \n    # Generate the zero matrix\n    a = np.zeros([m, n])\n    \n    # Calculate the determinant of the zero matrix (which is always 0)\n    determinant = 0.0\n    \n    # Return the zero matrix and its determinant\n    return {\"matrix\": a.tolist(), \"determinant\": determinant}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    m = random.randint(1, 10)\n    n = random.randint(1, 10)\n    return {\"m\": m, \"n\": n}", "io_pairs": [{"input": {"m": 1, "n": 9}, "output": {"matrix": [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]], "determinant": 0.0}}, {"input": {"m": 1, "n": 8}, "output": {"matrix": [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]], "determinant": 0.0}}, {"input": {"m": 6, "n": 1}, "output": {"matrix": [[0.0], [0.0], [0.0], [0.0], [0.0], [0.0]], "determinant": 0.0}}, {"input": {"m": 4, "n": 2}, "output": {"matrix": [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]], "determinant": 0.0}}, {"input": {"m": 2, "n": 3}, "output": {"matrix": [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]], "determinant": 0.0}}, {"input": {"m": 1, "n": 3}, "output": {"matrix": [[0.0, 0.0, 0.0]], "determinant": 0.0}}, {"input": {"m": 3, "n": 3}, "output": {"matrix": [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]], "determinant": 0.0}}, {"input": {"m": 1, "n": 5}, "output": {"matrix": [[0.0, 0.0, 0.0, 0.0, 0.0]], "determinant": 0.0}}, {"input": {"m": 3, "n": 2}, "output": {"matrix": [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0]], "determinant": 0.0}}, {"input": {"m": 1, "n": 10}, "output": {"matrix": [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]], "determinant": 0.0}}], "error_log": []}
{"context": "Given the historical information about the Gregorian calendar, including the rules for leap years, how many Sundays fell on the first of the month during a specified range of years from `start_year` to `end_year`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start_year` (int): The starting year of the range (inclusive).\n  `end_year` (int): The ending year of the range (inclusive).\n\nOutput:\n  `return` (int): The total number of Sundays that fell on the first of the month during the specified range of years.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(start_year, end_year):\n    # Initialize the weekday for 1 Jan 1900 (Monday)\n    weekday = 2\n    total_sundays = 0\n\n    # Loop through each year from start_year to end_year\n    for year in range(start_year, end_year + 1):\n        for month in range(1, 12 + 1):\n            if month in (4, 6, 9, 11):\n                days = 30\n            elif month in (1, 3, 5, 7, 8, 10, 12):\n                days = 31\n            elif year % 4 == 0 and not (year % 100 == 0 and year % 400 != 0):\n                days = 29\n            else:\n                days = 28\n\n            # Adjust weekday for the next month\n            while days >= 0:\n                days -= 7\n\n            while days < 0:\n                weekday -= 1\n                if weekday == 0:\n                    weekday = 7\n                days += 1\n\n            # Check if the first day of the month is a Sunday and count it\n            if weekday == 1 and year >= start_year:\n                total_sundays += 1\n\n    # Return the total number of Sundays that fell on the first of the month\n    return total_sundays", "input_generator": "import random\n\ndef input_generator():\n    start_year = random.randint(1900, 2000)\n    end_year = random.randint(start_year, start_year + random.randint(1, 100))\n    return {'start_year': start_year, 'end_year': end_year}", "io_pairs": [{"input": {"start_year": 1956, "end_year": 2000}, "output": 77}, {"input": {"start_year": 1904, "end_year": 1918}, "output": 25}, {"input": {"start_year": 1966, "end_year": 2007}, "output": 71}, {"input": {"start_year": 1943, "end_year": 1973}, "output": 54}, {"input": {"start_year": 1966, "end_year": 1972}, "output": 12}, {"input": {"start_year": 1935, "end_year": 1947}, "output": 24}, {"input": {"start_year": 1923, "end_year": 1945}, "output": 40}, {"input": {"start_year": 1929, "end_year": 1948}, "output": 36}, {"input": {"start_year": 1997, "end_year": 2058}, "output": 106}, {"input": {"start_year": 1955, "end_year": 1980}, "output": 45}], "error_log": []}
{"context": "Given a large number formed by multiplying a coefficient with 2 raised to a very large exponent and then adding an increment, what are the last ten digits of this number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `exponent` (int): The exponent to which 2 is raised in the expression.\n  `coefficient` (int): The coefficient multiplied by 2 raised to the power of `exponent`.\n  `increment` (int): The increment added to the result of the multiplication.\n  `digits` (int): The number of digits to return from the end of the result.\n\nOutput:\n  `return` (int): The last `digits` digits of the number formed by `coefficient * 2^exponent + increment`.", "reference_code": "# import necessary packages\n\n# main function\ndef main_solution(exponent: int, coefficient: int, increment: int, digits: int):\n    # Calculate the last 'digits' digits of the number formed by coefficient * 2^exponent + increment\n    result = (coefficient * 2**exponent + increment) % (10**digits)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    exponent = random.randint(1, 20)\n    coefficient = random.randint(1, 100)\n    increment = random.randint(0, 1000)\n    digits = random.randint(1, 5)\n    return {\n        'exponent': exponent,\n        'coefficient': coefficient,\n        'increment': increment,\n        'digits': digits\n    }", "io_pairs": [{"input": {"exponent": 15, "coefficient": 26, "increment": 348, "digits": 5}, "output": 52316}, {"input": {"exponent": 9, "coefficient": 60, "increment": 103, "digits": 2}, "output": 23}, {"input": {"exponent": 18, "coefficient": 16, "increment": 204, "digits": 2}, "output": 8}, {"input": {"exponent": 15, "coefficient": 49, "increment": 328, "digits": 4}, "output": 5960}, {"input": {"exponent": 14, "coefficient": 8, "increment": 441, "digits": 1}, "output": 3}, {"input": {"exponent": 13, "coefficient": 48, "increment": 431, "digits": 2}, "output": 47}, {"input": {"exponent": 4, "coefficient": 50, "increment": 525, "digits": 3}, "output": 325}, {"input": {"exponent": 20, "coefficient": 100, "increment": 270, "digits": 5}, "output": 57870}, {"input": {"exponent": 6, "coefficient": 64, "increment": 44, "digits": 5}, "output": 4140}, {"input": {"exponent": 5, "coefficient": 12, "increment": 846, "digits": 5}, "output": 1230}], "error_log": []}
{"context": "A manager is deciding between two machines, A and B, for daily operation in an industrial plant. The number of repairs needed for each machine follows a Poisson distribution. Machine A has a mean number of repairs of `mean_of_A`, and machine B has a mean number of repairs of `mean_of_B`. The daily cost for operating machine A is calculated as `160 + 40 * (mean_of_A + mean_of_A^2)`, and for machine B, it is `128 + 40 * (mean_of_B + mean_of_B^2)`. What are the expected daily costs for operating each machine, rounded to three decimal places?\n\nThe input and output requirements are as follows:\n\nInput:\n  `mean_of_A` (float): The mean number of repairs for machine A.\n  `mean_of_B` (float): The mean number of repairs for machine B.\n\nOutput:\n  `return` (dict): A dictionary containing the expected daily costs for both machines.\n    - `\"CostX\"` (float): The expected daily cost for machine A, rounded to three decimal places.\n    - `\"CostY\"` (float): The expected daily cost for machine B, rounded to three decimal places.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(mean_of_A, mean_of_B):\n    # Calculate the expected daily cost for machine A\n    CostX = 160 + 40 * (mean_of_A + mean_of_A**2)\n    \n    # Calculate the expected daily cost for machine B\n    CostY = 128 + 40 * (mean_of_B + mean_of_B**2)\n    \n    # Return the rounded costs as a dictionary\n    return {\"CostX\": round(CostX, 3), \"CostY\": round(CostY, 3)}", "input_generator": "import random\n\ndef input_generator():\n    mean_of_A = round(random.uniform(0.5, 5.0), 2)\n    mean_of_B = round(random.uniform(0.5, 5.0), 2)\n    return {\"mean_of_A\": mean_of_A, \"mean_of_B\": mean_of_B}", "io_pairs": [{"input": {"mean_of_A": 4.47, "mean_of_B": 1.33}, "output": {"CostX": 1138.036, "CostY": 251.956}}, {"input": {"mean_of_A": 4.68, "mean_of_B": 1.92}, "output": {"CostX": 1223.296, "CostY": 352.256}}, {"input": {"mean_of_A": 3.93, "mean_of_B": 3.62}, "output": {"CostX": 934.996, "CostY": 796.976}}, {"input": {"mean_of_A": 1.94, "mean_of_B": 2.69}, "output": {"CostX": 388.144, "CostY": 525.044}}, {"input": {"mean_of_A": 2.83, "mean_of_B": 4.61}, "output": {"CostX": 593.556, "CostY": 1162.484}}, {"input": {"mean_of_A": 1.65, "mean_of_B": 2.84}, "output": {"CostX": 334.9, "CostY": 564.224}}, {"input": {"mean_of_A": 2.21, "mean_of_B": 4.3}, "output": {"CostX": 443.764, "CostY": 1039.6}}, {"input": {"mean_of_A": 0.69, "mean_of_B": 0.65}, "output": {"CostX": 206.644, "CostY": 170.9}}, {"input": {"mean_of_A": 4.82, "mean_of_B": 3.57}, "output": {"CostX": 1282.096, "CostY": 780.596}}, {"input": {"mean_of_A": 4.34, "mean_of_B": 2.14}, "output": {"CostX": 1087.024, "CostY": 396.784}}], "error_log": []}
{"context": "In a large bathroom with `N` stalls, `k` people are about to occupy the stalls. Each person will choose the stall that maximizes the distance to the nearest occupied stall. After all `k` people have occupied the stalls, what are the maximum and minimum distances from the last occupied stall to its nearest occupied neighbor?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The total number of stalls in the bathroom.\n  `k` (int): The number of people who will occupy the stalls.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `maxval` (int): The maximum distance from the last occupied stall to its nearest occupied neighbor.\n    - `minval` (int): The minimum distance from the last occupied stall to its nearest occupied neighbor.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef findGaps(bathroom):\n    gaps = []\n    occupied = []\n    for i in range(0, len(bathroom)):\n        if bathroom[i] == 0:\n            occupied.append(i)\n    for i in range(len(occupied) - 1):\n        gaps.append([occupied[i] + 1, occupied[i + 1] - 1])\n    return gaps\n\ndef findStall(bathroom):\n    gaps = findGaps(bathroom)\n    maxdiff = -10\n    maxgap = []\n    for gap in gaps:\n        left = gap[0]  # Upper limit\n        right = gap[1]  # Lower limit\n        diff = right - left\n        if diff > maxdiff:\n            maxdiff = diff\n            maxgap = [left, right]\n    left = maxgap[0]\n    right = maxgap[1]\n    s = int(left - 1 + math.ceil((right - left + 1) / 2))\n    return s\n\n# main function\ndef main_solution(N, k):\n    # Convert JSON serializable inputs to original input variables\n    N = int(N)\n    k = int(k)\n    \n    if N == k:\n        return {\"maxval\": 0, \"minval\": 0}\n    \n    bathroom = [-1 for i in range(0, N + 2)]\n    bathroom[0] = 0\n    bathroom[N + 1] = 0\n    s = int(math.ceil(N / 2))\n    bathroom[s] = 0\n    k -= 1\n    \n    while k != 0:\n        s = findStall(bathroom)\n        bathroom[s] = 0\n        k -= 1\n    \n    occupied = [i for i in range(0, len(bathroom)) if bathroom[i] == 0]\n    i = occupied.index(s)\n    l = occupied[i] - occupied[i - 1] - 1\n    r = occupied[i + 1] - occupied[i] - 1\n    minval = min(l, r)\n    maxval = max(l, r)\n    \n    # Convert output to JSON serializable\n    return {\"maxval\": maxval, \"minval\": minval}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    N = random.randint(1, 1000)\n    k = random.randint(1, N)\n    return {\"N\": N, \"k\": k}", "io_pairs": [{"input": {"N": 490, "k": 53}, "output": {"maxval": 7, "minval": 6}}, {"input": {"N": 511, "k": 235}, "output": {"maxval": 1, "minval": 1}}, {"input": {"N": 755, "k": 88}, "output": {"maxval": 5, "minval": 5}}, {"input": {"N": 487, "k": 9}, "output": {"maxval": 30, "minval": 29}}, {"input": {"N": 297, "k": 205}, "output": {"maxval": 0, "minval": 0}}, {"input": {"N": 192, "k": 173}, "output": {"maxval": 0, "minval": 0}}, {"input": {"N": 412, "k": 44}, "output": {"maxval": 6, "minval": 5}}, {"input": {"N": 879, "k": 610}, "output": {"maxval": 0, "minval": 0}}, {"input": {"N": 55, "k": 52}, "output": {"maxval": 0, "minval": 0}}, {"input": {"N": 736, "k": 451}, "output": {"maxval": 1, "minval": 0}}], "error_log": []}
{"context": "Given a mathematical function and its exact integral over a specified interval, how can we approximate the integral using the trapezoidal rule and determine the error between the exact and approximate values? Specifically, what are the approximate integral and the error when using the trapezoidal rule for the function `function_name` over the interval `[a, b]` with `n` intervals, given the exact integral value `exact_integral`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `function_name` (str): The name of the function to be integrated. Possible values are \"f_1\", \"f_2\", \"f_3\", and \"cos\".\n  `a` (float): The lower bound of the integral.\n  `b` (float): The upper bound of the integral.\n  `n` (int): The number of intervals to use in the trapezoidal rule.\n  `exact_integral` (float): The exact value of the integral for error calculation.\n\nOutput:\n  `return` (dict): A dictionary containing the approximate integral and the error.\n    - `approx_integral` (float): The approximate value of the integral calculated using the trapezoidal rule.\n    - `error` (float): The absolute error between the exact integral and the approximate integral.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef trapecoidal_rule(f, a, b, n):\n    h = float((b - a) / n)\n    I = 0\n    for i in range(n):\n        I += f(a + i * h) + f(a + ((i + 1) * h))\n    I *= 1 / 2 * h\n    return I\n\ndef f_1(x):\n    return 2 * x + 1\n\ndef f_2(x):\n    return x ** 2\n\ndef f_3(x):\n    return 3 / 2 * (math.sin(x)) ** 3\n\n# main function\ndef main_solution(function_name, a, b, n, exact_integral):\n    # Convert function_name to the corresponding function\n    if function_name == \"f_1\":\n        f = f_1\n    elif function_name == \"f_2\":\n        f = f_2\n    elif function_name == \"f_3\":\n        f = f_3\n    elif function_name == \"cos\":\n        f = math.cos\n    else:\n        raise ValueError(\"Invalid function name\")\n    \n    # Calculate the approximate integral using the trapezoidal rule\n    approx_integral = trapecoidal_rule(f, a, b, n)\n    \n    # Calculate the error\n    error = math.fabs(exact_integral - approx_integral)\n    \n    # Return the result as a dictionary\n    return {\n        \"approx_integral\": approx_integral,\n        \"error\": error\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Randomly select a function name\n    function_choices = [\"f_1\", \"f_2\", \"f_3\", \"cos\"]\n    function_name = random.choice(function_choices)\n    \n    # Generate random a and b, ensuring a < b\n    a = random.uniform(-10.0, 10.0)\n    b = random.uniform(a + 1.0, a + 20.0)  # Ensure b is at least 1.0 greater than a\n    \n    # Generate a reasonable n (number of intervals)\n    n = random.randint(10, 1000)\n    \n    # Calculate exact integral based on the function\n    if function_name == \"f_1\":\n        exact_integral = (b**2 + b) - (a**2 + a)\n    elif function_name == \"f_2\":\n        exact_integral = (b**3 / 3) - (a**3 / 3)\n    elif function_name == \"f_3\":\n        exact_integral = (math.cos(a)**3 - math.cos(b)**3) / 2\n    elif function_name == \"cos\":\n        exact_integral = math.sin(b) - math.sin(a)\n    \n    return {\n        \"function_name\": function_name,\n        \"a\": a,\n        \"b\": b,\n        \"n\": n,\n        \"exact_integral\": exact_integral\n    }", "io_pairs": [{"input": {"function_name": "f_1", "a": 7.063739351033178, "b": 8.564358204731722, "n": 503, "exact_integral": 24.952436693319477}, "output": {"approx_integral": 24.952436693319477, "error": 0.0}}, {"input": {"function_name": "cos", "a": 6.0671840737644445, "b": 23.587975342353094, "n": 752, "exact_integral": -0.7853357246030598}, "output": {"approx_integral": -0.7853001983187324, "error": 3.552628432734739e-05}}, {"input": {"function_name": "cos", "a": -1.62222679863733, "b": 15.010854576315165, "n": 446, "exact_integral": 1.640681347762975}, "output": {"approx_integral": 1.6404911835592453, "error": 0.00019016420372963694}}, {"input": {"function_name": "cos", "a": -7.1929086387819785, "b": -0.34268825588452057, "n": 359, "exact_integral": 0.453313655565214}, "output": {"approx_integral": 0.45329990120539265, "error": 1.3754359821371853e-05}}, {"input": {"function_name": "cos", "a": 9.753159378598859, "b": 23.498945266413568, "n": 754, "exact_integral": -0.6755048219057016}, "output": {"approx_integral": -0.6754861130997292, "error": 1.870880597243385e-05}}, {"input": {"function_name": "f_2", "a": 3.0057921462976616, "b": 16.486337175302086, "n": 188, "exact_integral": 1484.606145198354}, "output": {"approx_integral": 1484.6176971511438, "error": 0.011551952789886855}}, {"input": {"function_name": "f_3", "a": 0.6022298915293369, "b": 19.16871607646448, "n": 332, "exact_integral": -0.14819602816894756}, "output": {"approx_integral": -0.040141784248574806, "error": 0.10805424392037274}}, {"input": {"function_name": "f_3", "a": 9.650931986971585, "b": 17.18741710106576, "n": 321, "exact_integral": -0.46238888039238946}, "output": {"approx_integral": -0.8626003823350528, "error": 0.4002115019426633}}, {"input": {"function_name": "f_2", "a": 2.901840321835344, "b": 13.537664647081233, "n": 900, "exact_integral": 818.8633975903149}, "output": {"approx_integral": 818.8636451484468, "error": 0.0002475581319458797}}, {"input": {"function_name": "f_2", "a": -9.444774040812343, "b": 10.087202959135363, "n": 956, "exact_integral": 622.96633566618}, "output": {"approx_integral": 622.9676945163653, "error": 0.0013588501852836998}}], "error_log": []}
{"context": "Given a mathematical problem involving Legendre polynomials, how can we compute the first `n` Legendre polynomials using a corrected formula and represent them in a format suitable for further analysis?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of Legendre polynomials to compute.\n\nOutput:\n  `return` (list of str): A list of strings, where each string represents a Legendre polynomial in terms of the symbol 'x'.", "reference_code": "# import necessary packages\nimport sympy as sp\n\n# scalar product in C[-1,1] intended for polynomials\n# first two arguments (f1 and f2) are sympy expressions, \n# the third argument (x) is the sympy Symbol with which both are defined \n# and with which they are to be integrated\ndef scalar_prod(f1, f2, x):\n    # integrate using sympy integrate function (first argument is a sympy\n    # 'function', second argument is tuple (symbol over which to integrate,\n    # lower boundary, upper boundary))\n    return sp.integrate(f1 * f2, (x, -1, 1))\n\n# main function\ndef main_solution(n):\n    # n (int): The number of Legendre polynomials to compute.\n    \n    x = sp.Symbol('x')\n    \n    # Initialize the list with the first Legendre polynomial\n    L = [1]\n    \n    # Compute the first n Legendre polynomials using the corrected formula\n    for m in range(1, n):\n        L_m = L[-1] * x\n        for i in range(m):\n            L_m -= (scalar_prod(L_m, L[i], x) / scalar_prod(L[i], L[i], x)) * L[i]\n        L.append(L_m.simplify())\n    \n    # Convert the list of Legendre polynomials to a JSON serializable format\n    L_serializable = [str(poly) for poly in L]\n    \n    return L_serializable", "input_generator": "import random\n\ndef input_generator():\n    return {'n': random.randint(1, 10)}", "io_pairs": [{"input": {"n": 5}, "output": ["1", "x", "x**2 - 1/3", "x*(x**2 - 3/5)", "x**4 - 6*x**2/7 + 3/35"]}, {"input": {"n": 1}, "output": ["1"]}, {"input": {"n": 9}, "output": ["1", "x", "x**2 - 1/3", "x*(x**2 - 3/5)", "x**4 - 6*x**2/7 + 3/35", "x*(63*x**4 - 70*x**2 + 15)/63", "x**6 - 15*x**4/11 + 5*x**2/11 - 5/231", "x*(429*x**6 - 693*x**4 + 315*x**2 - 35)/429", "x**8 - 28*x**6/15 + 14*x**4/13 - 28*x**2/143 + 7/1287"]}, {"input": {"n": 8}, "output": ["1", "x", "x**2 - 1/3", "x*(x**2 - 3/5)", "x**4 - 6*x**2/7 + 3/35", "x*(63*x**4 - 70*x**2 + 15)/63", "x**6 - 15*x**4/11 + 5*x**2/11 - 5/231", "x*(429*x**6 - 693*x**4 + 315*x**2 - 35)/429"]}, {"input": {"n": 3}, "output": ["1", "x", "x**2 - 1/3"]}, {"input": {"n": 7}, "output": ["1", "x", "x**2 - 1/3", "x*(x**2 - 3/5)", "x**4 - 6*x**2/7 + 3/35", "x*(63*x**4 - 70*x**2 + 15)/63", "x**6 - 15*x**4/11 + 5*x**2/11 - 5/231"]}, {"input": {"n": 10}, "output": ["1", "x", "x**2 - 1/3", "x*(x**2 - 3/5)", "x**4 - 6*x**2/7 + 3/35", "x*(63*x**4 - 70*x**2 + 15)/63", "x**6 - 15*x**4/11 + 5*x**2/11 - 5/231", "x*(429*x**6 - 693*x**4 + 315*x**2 - 35)/429", "x**8 - 28*x**6/15 + 14*x**4/13 - 28*x**2/143 + 7/1287", "x*(12155*x**8 - 25740*x**6 + 18018*x**4 - 4620*x**2 + 315)/12155"]}, {"input": {"n": 4}, "output": ["1", "x", "x**2 - 1/3", "x*(x**2 - 3/5)"]}, {"input": {"n": 2}, "output": ["1", "x"]}, {"input": {"n": 6}, "output": ["1", "x", "x**2 - 1/3", "x*(x**2 - 3/5)", "x**4 - 6*x**2/7 + 3/35", "x*(63*x**4 - 70*x**2 + 15)/63"]}], "error_log": []}
{"context": "Given two samples in a multi-dimensional space, how can we measure their similarity using a Gaussian kernel with a specified bandwidth? Specifically, what is the similarity score between the two samples when using a Gaussian kernel with the given bandwidth?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x1` (list of float): Sample 1, represented as a list of floats.\n  `x2` (list of float): Sample 2, represented as a list of floats.\n  `sigma` (float): Bandwidth for the Gaussian kernel.\n\nOutput:\n  `return` (float): The similarity between `x1` and `x2` with bandwidth `sigma`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(x1, x2, sigma):\n    \"\"\"\n    Computes the similarity between two samples using a Gaussian kernel.\n\n    Parameters:\n    x1 (list of float): Sample 1, represented as a list of floats.\n    x2 (list of float): Sample 2, represented as a list of floats.\n    sigma (float): Bandwidth for the Gaussian kernel.\n\n    Returns:\n    float: The similarity between x1 and x2 with bandwidth sigma.\n    \"\"\"\n    # Convert input lists to numpy arrays\n    x1_array = np.array(x1)\n    x2_array = np.array(x2)\n    \n    # Compute the Gaussian kernel similarity\n    similarity = np.exp(-np.sum(np.square(x1_array - x2_array)) / (2.0 * sigma ** 2))\n    \n    # Return the similarity as a float\n    return float(similarity)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the length of the vectors (between 2 and 10)\n    length = random.randint(2, 10)\n    \n    # Generate random vectors x1 and x2 with values between -10 and 10\n    x1 = [random.uniform(-10, 10) for _ in range(length)]\n    x2 = [random.uniform(-10, 10) for _ in range(length)]\n    \n    # Generate a random sigma value between 0.1 and 5.0\n    sigma = random.uniform(0.1, 5.0)\n    \n    return {'x1': x1, 'x2': x2, 'sigma': sigma}", "io_pairs": [{"input": {"x1": [9.76189417079997, 2.253603435881139, 9.21180697823366, -3.171328491744811, 3.4979996641626325, -4.530234434435467], "x2": [-2.211687988999591, 3.906993622270395, -1.8125705567559365, -1.4097950694371786, -2.421460436936467, -6.609852698549377], "sigma": 0.40127871276106786}, "output": 0.0}, {"input": {"x1": [6.158382457627038, -8.875796704687321], "x2": [7.311476321947119, 8.263944403760199], "sigma": 2.6530140091667813}, "output": 7.865632471901016e-10}, {"input": {"x1": [-9.743210231922408, -9.289203535037998, -0.5085151016144351, 0.9978196496645495], "x2": [7.505922121203227, -0.43949386283702907, 5.346938912307733, -8.56373719274994], "sigma": 2.611260050149482}, "output": 1.0650304885002757e-16}, {"input": {"x1": [-4.858336132892553, 5.937057771169458], "x2": [-4.860579194086842, 5.276311938649842], "sigma": 3.204348917188885}, "output": 0.9789643520993684}, {"input": {"x1": [-4.325109652361019, 9.950671206672897, -9.207284504383143, 7.3293885401043966, -0.44347731327119, -6.127437731878825, 8.093937142657168], "x2": [-3.2355982326976402, 5.1806091417020195, 7.823055052861466, 5.457229391733344, 9.091990118073529, 1.671672029179799, -2.9612637580959422], "sigma": 3.8231023997142524}, "output": 1.6332470983942578e-09}, {"input": {"x1": [5.798742495532974, -3.7152469438304303, -2.2653546215769493, -1.7965936770433455, -2.744685483373239, 6.436964730364426, 9.351092167074174, 6.298875719323913], "x2": [1.2984275711426925, 1.9851527223697154, -0.22422386539385997, -6.6456276462177115, 9.324954449302826, -9.89182455036879, -0.5889691200390033, -0.1298011140343096], "sigma": 4.2285813639519505}, "output": 2.0626767564182986e-08}, {"input": {"x1": [-5.2365451007899155, -6.167924760396852, -4.1697129048814, -7.381363929595537], "x2": [-1.1686337203664738, -2.4645294302912273, 3.211551299197028, -7.990135420335617], "sigma": 1.6685958229822404}, "output": 2.2990486214200705e-07}, {"input": {"x1": [-5.988564448298677, -1.6696304098927879], "x2": [-2.410047763159275, 5.992808850112555], "sigma": 3.5927059047562984}, "output": 0.06263528734465595}, {"input": {"x1": [5.53079423483406, 6.735644519581918], "x2": [2.1146057814691144, -2.320683668001724], "sigma": 4.09132104494611}, "output": 0.06090178946895405}, {"input": {"x1": [7.2913923234075675, -6.5053271530278645, 8.190872541225243, 9.64823984326404, 4.477279053192271, -3.5743887124948914], "x2": [3.389781101235542, 5.96643917621304, -6.858777057370831, 3.4847460212211505, 2.9519623284152434, -4.357715081050991], "sigma": 2.766489360594229}, "output": 3.6943570945457765e-13}], "error_log": []}
{"context": "Given a range of two-digit numbers, identify the four non-trivial fractions where the last digit of the numerator matches the first digit of the denominator, and the fraction can be simplified by cancelling these digits. What is the value of the denominator of the product of these four fractions in its lowest common terms?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start_range` (int): The starting range for the two-digit numbers (e.g., 10).\n  `end_range` (int): The ending range for the two-digit numbers (e.g., 99).\n\nOutput:\n  `return` (int): The value of the denominator of the product of the four fractions in its lowest common terms.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef ends_in_zero(n):\n    \"\"\"\n    Check if the number ends in zero.\n    \"\"\"\n    return str(n)[-1] == '0'\n\ndef first_digits_matches_last(x, y):\n    \"\"\"\n    Check if the last digit of x matches the first digit of y and if the fraction x/y can be simplified by cancelling these digits.\n    \"\"\"\n    sx = str(x)\n    sy = str(y)\n\n    if sx[-1] == sy[0] and float(sx[0]) / float(sy[-1]) == float(x) / float(y) and x != y:\n        return True\n    return False\n\n# main function\ndef main_solution(start_range, end_range):\n    \"\"\"\n    Find the value of the denominator of the product of four non-trivial fractions with two digits in the numerator and denominator.\n    \n    Args:\n    start_range (int): The starting range for the two-digit numbers.\n    end_range (int): The ending range for the two-digit numbers.\n    \n    Returns:\n    int: The value of the denominator of the product of the four fractions in its lowest common terms.\n    \"\"\"\n    # Generate the list of two-digit numbers within the specified range that do not end in zero\n    lst = [x for x in range(start_range, end_range + 1) if not ends_in_zero(x)]\n\n    num = []\n    denom = []\n\n    # Find the non-trivial fractions\n    for i in lst:\n        for j in lst:\n            if first_digits_matches_last(i, j):\n                num.append(i)\n                denom.append(j)\n\n    # Calculate the product of the denominators and numerators, then find the denominator in its lowest common terms\n    ans = int(float(np.prod(denom)) / float(np.prod(num)))\n    return ans", "input_generator": "import random\n\ndef input_generator():\n    start = random.randint(10, 50)\n    end = random.randint(start + 1, 99)\n    return {'start_range': start, 'end_range': end}", "io_pairs": [{"input": {"start_range": 44, "end_range": 56}, "output": 1}, {"input": {"start_range": 37, "end_range": 57}, "output": 1}, {"input": {"start_range": 37, "end_range": 69}, "output": 1}, {"input": {"start_range": 42, "end_range": 85}, "output": 1}, {"input": {"start_range": 33, "end_range": 95}, "output": 1}, {"input": {"start_range": 23, "end_range": 58}, "output": 1}, {"input": {"start_range": 50, "end_range": 54}, "output": 1}, {"input": {"start_range": 17, "end_range": 19}, "output": 1}, {"input": {"start_range": 21, "end_range": 93}, "output": 2}, {"input": {"start_range": 21, "end_range": 29}, "output": 1}], "error_log": []}
{"context": "Given a chessboard of a certain size and an initial arrangement of queens, what is the number of pairs of queens that are attacking each other after a random mutation of the queen positions?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_size` (int): The size of the board, which is also the number of queens.\n  `initial_state` (list of tuples): A list of tuples representing the initial positions of the queens on the board. Each tuple contains two integers representing the row and column of a queen.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `fitness` (int): The number of pairs of queens that are attacking each other.\n    - `state` (list of tuples): The new positions of the queens on the board after mutation. Each tuple contains two integers representing the row and column of a queen.", "reference_code": "# import necessary packages\nfrom random import shuffle, randint, sample\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\nclass BoardUnconstrained:\n\n    def __init__(self, N=8):\n        self.board_size = N\n        self.state = []\n        queens_left = N\n        while queens_left > 0:\n            row = randint(0, self.board_size - 1)\n            col = randint(0, self.board_size - 1)\n            if (row, col) not in self.state:\n                self.state.append((row, col))\n                queens_left -= 1\n        self.state = sorted(self.state)\n\n    def positionFree(self, pos_tuple):\n        return pos_tuple not in self.state\n\n    def mutate(self):\n        index = randint(0, self.board_size - 1)\n        while True:\n            row = randint(0, self.board_size - 1)\n            col = randint(0, self.board_size - 1)\n            if self.positionFree((row, col)):\n                self.state[index] = (row, col)\n                break\n        self.state = sorted(self.state)\n\n    def fitnessFunction(self):\n        pairs = 0\n        for i in range(self.board_size):\n            for j in range(i + 1, self.board_size):\n                if (self.state[j][0] == self.state[i][0]) or (self.state[j][1] == self.state[i][1]):\n                    pairs += 1\n                if abs((self.state[j][0] - self.state[i][0])) == abs((self.state[j][1] - self.state[i][1])):\n                    pairs += 1\n        return pairs\n\n    def isSameBoard(self, other_board):\n        return set(self.state) == set(other_board.state)\n\n    def mate(self, other_board):\n        newboard_1 = deepcopy(self)\n        newboard_2 = deepcopy(other_board)\n        N_switch = randint(0, self.board_size - 1)\n        switch_indices = sample(list(range(self.board_size)), N_switch)\n\n        for index in switch_indices:\n            temp = newboard_1.state[index]\n            newboard_1.state[index] = newboard_2.state[index]\n            newboard_2.state[index] = temp\n\n        newboard_1.state = sorted(newboard_1.state)\n        newboard_2.state = sorted(newboard_2.state)\n        return newboard_1, newboard_2\n\n# main function\ndef main_solution(board_size, initial_state):\n    # Convert JSON serializable input to original input variables\n    board = BoardUnconstrained(board_size)\n    board.state = initial_state\n\n    # Perform mutation\n    board.mutate()\n\n    # Calculate fitness function\n    fitness = board.fitnessFunction()\n\n    # Convert output to JSON serializable\n    return {\"fitness\": fitness, \"state\": board.state}", "input_generator": "import random\nfrom random import randint\n\ndef input_generator():\n    board_size = random.choice([4, 8, 10, 12])\n    initial_state = []\n    positions = set()\n    while len(initial_state) < board_size:\n        row = randint(0, board_size - 1)\n        col = randint(0, board_size - 1)\n        if (row, col) not in positions:\n            initial_state.append((row, col))\n            positions.add((row, col))\n    initial_state = sorted(initial_state)\n    return {\"board_size\": board_size, \"initial_state\": initial_state}", "io_pairs": [{"input": {"board_size": 4, "initial_state": [[0, 2], [0, 3], [3, 1], [1, 3]]}, "output": {"fitness": 4, "state": [[0, 2], [0, 3], [1, 3], [3, 1]]}}, {"input": {"board_size": 4, "initial_state": [[3, 0], [1, 2], [1, 3], [2, 1]]}, "output": {"fitness": 4, "state": [[1, 2], [1, 3], [2, 1], [3, 0]]}}, {"input": {"board_size": 4, "initial_state": [[0, 0], [0, 2], [2, 0], [3, 1]]}, "output": {"fitness": 4, "state": [[0, 0], [0, 2], [2, 0], [3, 1]]}}, {"input": {"board_size": 4, "initial_state": [[1, 0], [3, 2], [2, 3], [3, 0]]}, "output": {"fitness": 4, "state": [[1, 0], [2, 3], [3, 0], [3, 2]]}}, {"input": {"board_size": 4, "initial_state": [[0, 1], [0, 3], [1, 2], [3, 1]]}, "output": {"fitness": 4, "state": [[0, 1], [0, 3], [1, 2], [3, 1]]}}, {"input": {"board_size": 4, "initial_state": [[0, 3], [2, 1], [2, 2], [2, 3]]}, "output": {"fitness": 5, "state": [[0, 3], [2, 1], [2, 2], [2, 3]]}}, {"input": {"board_size": 4, "initial_state": [[0, 0], [0, 1], [2, 2], [3, 3]]}, "output": {"fitness": 4, "state": [[0, 0], [0, 1], [2, 2], [3, 3]]}}, {"input": {"board_size": 4, "initial_state": [[1, 0], [2, 1], [2, 3], [3, 3]]}, "output": {"fitness": 3, "state": [[1, 0], [2, 1], [2, 3], [3, 3]]}}, {"input": {"board_size": 4, "initial_state": [[2, 0], [1, 2], [2, 1], [2, 2]]}, "output": {"fitness": 5, "state": [[1, 2], [2, 0], [2, 1], [2, 2]]}}, {"input": {"board_size": 4, "initial_state": [[0, 1], [1, 1], [3, 0], [2, 2]]}, "output": {"fitness": 2, "state": [[0, 1], [1, 1], [2, 2], [3, 0]]}}], "error_log": []}
{"context": "Given a Markov chain with a known transition probability matrix and an initial state probability distribution, what is the probability distribution of the states after a specified number of time steps?\n\nThe input and output requirements are as follows:\n\nInput:\n  `transition_matrix` (list of lists of float): The transition probability matrix of the Markov chain, where each inner list represents a row of probabilities.\n  `initial_state` (list of float): The initial state probabilities, where each float represents the probability of starting in that state.\n  `time_steps` (int): The number of time steps to iterate, must be a positive integer.\n\nOutput:\n  `return` (list of float): The probability distribution of the states after the specified number of time steps, where each float represents the probability of being in that state.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(transition_matrix, initial_state, time_steps):\n    \"\"\"\n    Determines the probability of a Markov chain being in a particular state after a specified number of iterations.\n    \n    Args:\n    transition_matrix (list of lists of float): The transition probability matrix of the Markov chain.\n    initial_state (list of float): The initial state probabilities.\n    time_steps (int): The number of time steps to iterate.\n    \n    Returns:\n    list of float: The probability distribution of the states after the specified number of time steps.\n    \"\"\"\n    # Convert JSON serializable inputs to numpy arrays\n    P = np.array(transition_matrix)\n    s = np.array([initial_state])\n    t = time_steps\n    \n    # Check for valid inputs\n    if type(P) is not np.ndarray or len(P.shape) != 2:\n        return None\n    if type(s) is not np.ndarray or len(s.shape) != 2:\n        return None\n    if P.shape[0] != P.shape[1]:\n        return None\n    if P.shape[1] != s.shape[1]:\n        return None\n    if t <= 0:\n        return None\n    \n    # Calculate the state probabilities after the specified number of time steps\n    pState = np.dot(s, np.linalg.matrix_power(P, t))\n    \n    # Convert the result to a JSON serializable output\n    return pState.tolist()[0]", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the number of states (between 2 and 5)\n    num_states = random.randint(2, 5)\n    \n    # Generate a valid transition matrix\n    transition_matrix = []\n    for _ in range(num_states):\n        row = [random.random() for _ in range(num_states)]\n        row_sum = sum(row)\n        row = [x / row_sum for x in row]  # Normalize to make row sum to 1\n        transition_matrix.append(row)\n    \n    # Generate a valid initial state distribution\n    initial_state = [random.random() for _ in range(num_states)]\n    initial_sum = sum(initial_state)\n    initial_state = [x / initial_sum for x in initial_state]  # Normalize\n    \n    # Randomly choose time steps (between 1 and 10)\n    time_steps = random.randint(1, 10)\n    \n    return {\n        'transition_matrix': transition_matrix,\n        'initial_state': initial_state,\n        'time_steps': time_steps\n    }", "io_pairs": [{"input": {"transition_matrix": [[0.27570552686112726, 0.7242944731388726], [0.09378587051172256, 0.9062141294882774]], "initial_state": [0.6944656382862874, 0.3055343617137125], "time_steps": 4}, "output": [0.11527645357823632, 0.8847235464217634]}, {"input": {"transition_matrix": [[0.3044247516548523, 0.6955752483451477], [0.47629046281793364, 0.5237095371820663]], "initial_state": [0.7484356469660464, 0.2515643530339537], "time_steps": 1}, "output": [0.3476600380923132, 0.6523399619076868]}, {"input": {"transition_matrix": [[0.34757554323905904, 0.652424456760941], [0.8939819358275736, 0.10601806417242639]], "initial_state": [0.6418306873041917, 0.35816931269580826], "time_steps": 5}, "output": [0.5749989429917899, 0.42500105700820995]}, {"input": {"transition_matrix": [[0.4634575571967667, 0.5365424428032332], [0.4935527366741235, 0.5064472633258764]], "initial_state": [0.39965462399446816, 0.6003453760055317], "time_steps": 4}, "output": [0.4791330736679066, 0.5208669263320931]}, {"input": {"transition_matrix": [[0.6731713631189167, 0.3268286368810833], [0.6297887745467999, 0.37021122545319995]], "initial_state": [0.27539540169322024, 0.7246045983067797], "time_steps": 8}, "output": [0.6583496882020545, 0.34165031179794514]}, {"input": {"transition_matrix": [[0.2135015723971831, 0.7864984276028169], [0.10898720598140729, 0.8910127940185927]], "initial_state": [0.9206993249937776, 0.07930067500622241], "time_steps": 6}, "output": [0.12170841654114802, 0.8782915834588517]}, {"input": {"transition_matrix": [[0.05591517173855356, 0.9440848282614465], [0.11025088000804167, 0.8897491199919584]], "initial_state": [0.4257964407420829, 0.5742035592579171], "time_steps": 3}, "output": [0.10451751578758675, 0.8954824842124134]}, {"input": {"transition_matrix": [[0.7291692440531695, 0.2708307559468305], [0.7069201307413195, 0.29307986925868046]], "initial_state": [0.962801925142334, 0.03719807485766602], "time_steps": 3}, "output": [0.723009022717742, 0.276990977282258]}, {"input": {"transition_matrix": [[0.1477507628277803, 0.8522492371722197], [0.5346376384146839, 0.46536236158531613]], "initial_state": [0.35193595582532605, 0.648064044174674], "time_steps": 2}, "output": [0.3804716386765401, 0.61952836132346]}, {"input": {"transition_matrix": [[0.9624013420288675, 0.037598657971132474], [0.4778838330488224, 0.5221161669511777]], "initial_state": [0.5773086807994697, 0.42269131920053027], "time_steps": 9}, "output": [0.9265465411840523, 0.07345345881594781]}], "error_log": []}
{"context": "Given a quadratic function of the form \\( f(x) = ax^2 + bx + c \\), where \\( a \\), \\( b \\), and \\( c \\) are coefficients, what is the derivative of this function with respect to \\( x \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): Coefficient of the quadratic term in the quadratic function.\n  `b` (float): Coefficient of the linear term in the quadratic function.\n  `c` (float): Constant term in the quadratic function.\n\nOutput:\n  `return` (str): The derivative of the quadratic function in string format. The format is a simplified polynomial expression in terms of 'x'.", "reference_code": "# import necessary packages\nimport sympy as sp\n\n# main function\ndef main_solution(a, b, c):\n    # Define the symbols\n    x = sp.symbols('x')\n    \n    # Define the quadratic function\n    f = a * x**2 + b * x + c\n    \n    # Compute the derivative\n    der = sp.diff(f, x)\n    \n    # Convert the derivative to a string for JSON serialization\n    derivative_str = str(der)\n    \n    return derivative_str", "input_generator": "import random\nimport sympy as sp\n\ndef input_generator():\n    a = random.choice([1, -1, 2, -2, 0.5, -0.5, 3, -3])\n    b = random.uniform(-10, 10)\n    c = random.uniform(-10, 10)\n    return {'a': a, 'b': b, 'c': c}", "io_pairs": [{"input": {"a": 3, "b": 7.698563637082671, "c": -4.039294417155331}, "output": "6*x + 7.69856363708267"}, {"input": {"a": -1, "b": 7.90925505605194, "c": -9.902921309244876}, "output": "7.90925505605194 - 2*x"}, {"input": {"a": 3, "b": 1.403253134022215, "c": -7.71931122906749}, "output": "6*x + 1.40325313402221"}, {"input": {"a": 2, "b": -1.8417563891858624, "c": 5.211180223642502}, "output": "4*x - 1.84175638918586"}, {"input": {"a": 3, "b": -2.402923040640001, "c": 8.370524814645584}, "output": "6*x - 2.40292304064"}, {"input": {"a": -0.5, "b": 8.399224897627363, "c": 4.245310354469979}, "output": "8.39922489762736 - 1.0*x"}, {"input": {"a": -0.5, "b": -3.929242582028687, "c": 9.611993566020157}, "output": "-1.0*x - 3.92924258202869"}, {"input": {"a": -1, "b": 4.058718868152898, "c": 9.648138780104038}, "output": "4.0587188681529 - 2*x"}, {"input": {"a": 3, "b": 4.46003710728084, "c": -7.779087307924273}, "output": "6*x + 4.46003710728084"}, {"input": {"a": -3, "b": -6.3326376602474, "c": -8.698681110355928}, "output": "-6*x - 6.3326376602474"}], "error_log": []}
{"context": "Given a matrix \\( A \\) and a set of random vectors, how can we estimate the maximum norm of the matrix using these vectors? Specifically, what is the maximum norm of the matrix \\( A \\) when estimated using \\( N \\) random vectors of dimension \\( p \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `A` (list of lists of floats): A 2D list representing the matrix for which the norm is to be estimated.\n  `p` (int): The dimension of the vectors used in the estimation.\n  `N` (int): The number of random vectors to be used in the estimation.\n\nOutput:\n  `return` (float): The maximum norm estimated using the random vectors.", "reference_code": "# import necessary packages\nimport numpy as np\nimport numpy.linalg as LA\n\n# main function\ndef main_solution(A, p, N):\n    # Convert input to numpy arrays if they are not already\n    A = np.array(A)\n    \n    # Initialize an array to store the norms\n    y = np.zeros(N)\n    \n    for i in range(N):\n        vector = np.random.randn(p)\n        norma = LA.norm(A @ vector, np.inf) / LA.norm(vector, np.inf)\n        y[i] = norma\n    \n    # Calculate the maximum norm\n    max_norm = np.max(y)\n    \n    # Return the maximum norm as a float\n    return float(max_norm)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the dimensions of matrix A (m x p)\n    m = random.randint(2, 10)\n    p = random.randint(2, 10)\n    \n    # Generate a random matrix A with values between -10 and 10\n    A = np.random.uniform(-10, 10, (m, p)).tolist()\n    \n    # Randomly choose N (number of iterations) between 10 and 100\n    N = random.randint(10, 100)\n    \n    return {'A': A, 'p': p, 'N': N}", "io_pairs": [{"input": {"A": [[1.5672525570753226, -6.3467907231915, -2.8422233939090225, -3.06237594719623, 9.345198835637166], [-7.106948891548921, 4.225751563354445, 0.27013577428475344, 9.65171891026133, 5.6857820013599785]], "p": 5, "N": 93}, "output": 19.612513973088795}, {"input": {"A": [[-0.33240361526687856, -7.300089916178987, 5.686784383037772, -3.0664182699699527, 7.273865856672948], [-6.990839482098461, -7.150150241504614, 8.984509966369828, 0.9672264999987092, -7.52038210323869]], "p": 5, "N": 40}, "output": 17.614643364429977}, {"input": {"A": [[-9.028540811431684, 6.990975064582599, -4.676754866011324, -0.8601973134662781], [-5.187701846324715, 1.9135732275500992, -5.152161423701558, 1.3747226726791624]], "p": 4, "N": 87}, "output": 18.34734558942713}, {"input": {"A": [[-6.341255546720519, -6.71327165856815], [3.2277765383871966, -9.763551295708854], [-1.3095876254286498, 4.872864946257675]], "p": 2, "N": 10}, "output": 12.675248882219078}, {"input": {"A": [[-1.2508829328731643, -6.854452127718802, 0.9014946285619345, 9.442684159831838], [-7.440687339029366, 3.276755099612158, -0.22215909918798005, -7.4139819778912734]], "p": 4, "N": 18}, "output": 15.846476270342396}, {"input": {"A": [[-4.222263163873777, 2.340077746744951], [3.1837878490725853, -7.706533235005988]], "p": 2, "N": 66}, "output": 10.715365673484744}, {"input": {"A": [[4.12596003913521, -7.879708551966345, -0.18153313780581826], [1.8927284786097793, -5.471441411573277, 8.93673932234907]], "p": 3, "N": 64}, "output": 14.38727879383434}, {"input": {"A": [[-5.000003952610383, -4.795049964678427], [-7.477657837346987, -3.281232966364948]], "p": 2, "N": 43}, "output": 10.670518576365222}, {"input": {"A": [[2.7539746857579708, 7.33788636278301, -9.22668812993585, -2.047205364368385, 4.0634411127375625, 4.1446658107573615], [-7.621244729218965, 2.93722077304092, -0.1606951627600104, 0.6138086199604498, 7.510214715006924, -2.926263928505552]], "p": 6, "N": 86}, "output": 18.68900830485809}, {"input": {"A": [[-3.492228196699079, 3.668145146321102, -0.08140390311516477, 5.34525920559971, -3.4083702012451926], [7.118931705365078, 4.25068152776441, -7.1089542928527845, -5.495646848954088, -1.9559195304805144]], "p": 5, "N": 100}, "output": 20.686123018500364}], "error_log": []}
{"context": "Given a range of numbers from 1 to n, what is the smallest positive number that can be evenly divided by each number in this range?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The upper limit of the range of numbers to find the least common multiple (LCM) for.\n\nOutput:\n  `return` (int): The smallest positive number that is evenly divisible by all of the numbers from 1 to n.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    Calculate the smallest positive number that is evenly divisible by all of the numbers from 1 to n.\n    \n    Args:\n    n (int): The upper limit of the range of numbers to find the least common multiple (LCM) for.\n    \n    Returns:\n    int: The smallest positive number that is evenly divisible by all of the numbers from 1 to n.\n    \"\"\"\n    def lcm(a, b):\n        return abs(a * b) // math.gcd(a, b)\n    \n    result = 1\n    for i in range(1, n + 1):\n        result = lcm(result, i)\n    \n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(1, 20)  # Reasonable range to avoid overly large LCM calculations\n    return {'n': n}", "io_pairs": [{"input": {"n": 18}, "output": 12252240}, {"input": {"n": 14}, "output": 360360}, {"input": {"n": 17}, "output": 12252240}, {"input": {"n": 15}, "output": 360360}, {"input": {"n": 3}, "output": 6}, {"input": {"n": 11}, "output": 27720}, {"input": {"n": 4}, "output": 12}, {"input": {"n": 10}, "output": 2520}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 5}, "output": 60}], "error_log": []}
{"context": "Given a sequence of numbers, determine the next 10 numbers in the sequence if the sequence follows a regular pattern. What are the next 10 numbers in the sequence `num_list`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_list` (str): A comma-separated string of integers representing the initial sequence.\n\nOutput:\n  `return` (list): A list of integers representing the next 10 numbers in the sequence if the sequence is regular. If the sequence is irregular, it returns the string \"False\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# Function to check if all elements in a list are the same\ndef equalInList(numList):\n    No1 = numList[0]\n    for i in numList:\n        if No1 != i:\n            No1 = i\n            break\n    if No1 == numList[0]:\n        return True\n    else:\n        return False\n\n# Function to determine if the elements in a list repeat and return the repeating sequence\ndef orderNext_getTile(linkList):\n    listLen = len(linkList)\n    harftLen = listLen // 2\n    for i in range(1, harftLen + 1):\n        part = linkList[0:i]\n        tern = int(listLen / i)\n        last = listLen - tern * i\n        leave = linkList[i * tern:]\n        snos = True\n        for j in range(1, tern):\n            start = i * j\n            if part != linkList[start:start + i]:\n                snos = False\n                break\n        for o in range(0, last):\n            if part[o] != leave[o]:\n                snos = False\n                break\n        if snos:\n            return part\n    return False\n\n# Generator to infinitely repeat a given sequence\ndef orderNext_reTile(tileList):\n    long = len(tileList)\n    i = 0\n    while True:\n        yield tileList[i]\n        i += 1\n        if i >= long:\n            i = 0\n\n# Function to generate a sequence based on a given pattern\ndef getNext_fromLinear(numList):\n    le_s = []\n    le_n = []\n\n    for i in numList:\n        if i >= 0:\n            le_s.append('+')\n            le_n.append(i)\n        elif i < 0:\n            le_s.append('-')\n            le_n.append(-i)\n        else:\n            return False\n\n    elfs = orderNext_getTile(le_s)\n    elfn = orderNext_getTile(le_n)\n\n    if elfn != False and elfs != False:\n        def foNext():\n            nlis = orderNext_reTile(elfn)\n            slis = orderNext_reTile(elfs)\n            while True:\n                n = next(nlis)\n                s = next(slis)\n                if s == '-':\n                    num = -n\n                else:\n                    num = n\n                nextNum = num\n                yield nextNum\n        return foNext\n    elif elfn == False and elfs != False:\n        le_nn = []\n        for i in range(0, len(le_n) - 1):\n            le_nn.append(le_n[i + 1] - le_n[i])\n        if le_nn != []:\n            yel = getNext_fromLinear(le_nn)\n            if yel != False:\n                def ffnext():\n                    start = le_n[0]\n                    a = yel()\n                    fsl = orderNext_reTile(elfs)\n                    while True:\n                        fsl_s = next(fsl)\n                        if fsl_s == '-':\n                            renn = -start\n                        else:\n                            renn = start\n                        yield renn\n                        yel_n = next(a)\n                        start += yel_n\n                return ffnext\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n\n# main function\ndef main_solution(num_list):\n    # Convert input to the required format\n    num_list = [int(x) for x in num_list.split(',')]\n    \n    # Get the sequence generator\n    af = getNext_fromLinear(num_list)\n    \n    # Generate the next 10 numbers in the sequence\n    if af == False:\n        return \"False\"\n    else:\n        yelist = af()\n        result = []\n        for i in range(10):\n            result.append(next(yelist))\n        return result", "input_generator": "import random\n\ndef input_generator():\n    patterns = [\n        [1, 2, 3, 4, 5],\n        [2, 4, 6, 8, 10],\n        [1, -1, 1, -1, 1],\n        [5, 10, 15, 20, 25],\n        [1, 1, 2, 3, 5, 8],\n        [3, 6, 9, 12, 15],\n        [-1, -2, -3, -4, -5],\n        [10, 20, 30, 40, 50],\n        [2, -4, 6, -8, 10],\n        [1, 4, 9, 16, 25]\n    ]\n    \n    chosen_pattern = random.choice(patterns)\n    num_list = ','.join(map(str, chosen_pattern))\n    \n    return {'num_list': num_list}", "io_pairs": [{"input": {"num_list": "10,20,30,40,50"}, "output": [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]}, {"input": {"num_list": "2,-4,6,-8,10"}, "output": [2, -4, 6, -8, 10, -12, 14, -16, 18, -20]}, {"input": {"num_list": "2,4,6,8,10"}, "output": [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]}, {"input": {"num_list": "1,2,3,4,5"}, "output": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}, {"input": {"num_list": "1,4,9,16,25"}, "output": [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]}, {"input": {"num_list": "-1,-2,-3,-4,-5"}, "output": [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]}, {"input": {"num_list": "1,-1,1,-1,1"}, "output": [1, -1, 1, -1, 1, -1, 1, -1, 1, -1]}, {"input": {"num_list": "1,1,2,3,5,8"}, "output": "False"}, {"input": {"num_list": "3,6,9,12,15"}, "output": [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]}, {"input": {"num_list": "5,10,15,20,25"}, "output": [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]}], "error_log": []}
{"context": "Given a string and a pattern, determine if the string matches the pattern. The pattern may contain special characters: `.` which matches any single character, and `*` which matches zero or more of the preceding element. What is the result of matching the string against the pattern?\n\nThe input and output requirements are as follows:\n\nInput:\n- `input_string` (str): The input string that needs to be matched against the pattern.\n- `pattern` (str): The pattern string that may contain special characters like `.` and `*`.\n\nOutput:\n- `return` (dict): A dictionary with a single key `\"match\"` whose value is a boolean indicating whether the input string matches the pattern (`True`) or not (`False`).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef let_check(a, b):\n    if a == b or a == '.':\n        return True\n    else:\n        return False\n\ndef string_comp(s, p):\n    if '*' not in p:\n        if len(p) != len(s):\n            return False\n        else:\n            for x in range(len(p)):\n                if let_check(p[x], s[x]):\n                    continue\n                else:\n                    return False\n            else:\n                return True\n    elif '*' in p and p[-1] != '*':\n        if s[-1] != p[-1] and p[-1] != '.':\n            return False\n\n    star_indices = {}\n    for a in range(len(p)):\n        if p[a] == '*':\n            star_indices[a-1-len(star_indices)] = [-1, -1]\n\n    highest_active = -1\n    index_list = sorted(list(star_indices.keys()))\n    b = ''\n    for a in p:\n        if a != '*':\n            b += a\n\n    s_ind = 0\n    b_ind = 0\n    highest_ind = 0\n    while s_ind < len(s) and b_ind < len(b):\n        if b_ind in star_indices.keys():\n            if b_ind == len(b)-1:\n                if highest_active == -1:\n                    if let_check(b[b_ind], s[s_ind]):\n                        if s_ind == (len(s)-1):\n                            s_ind += 1\n                            b_ind += 1\n                            break\n                        else:\n                            s_ind += 1\n                            continue\n                    else:\n                        return False\n                else:\n                    if let_check(b[b_ind], s[s_ind]):\n                        if s_ind == (len(s)-1):\n                            s_ind += 1\n                            b_ind += 1\n                            break\n                        else:\n                            s_ind += 1\n                            continue\n                    else:\n                        highest_ind = index_list[highest_active]\n                        b_ind = highest_ind\n                        s_ind = star_indices[highest_ind][1]\n                        continue\n            else:\n                if highest_active == -1:\n                    star_indices[b_ind][0] = 0\n                    star_indices[b_ind][1] = s_ind\n                    b_ind += 1\n                    highest_active += 1\n                    highest_ind = index_list[highest_active]\n                    continue\n                else:\n                    if star_indices[b_ind][0] == -1:\n                        highest_active += 1\n                        highest_ind = index_list[highest_active]\n                        star_indices[b_ind][0] = 0\n                        star_indices[b_ind][1] = s_ind\n                        b_ind += 1\n                        continue\n                    elif star_indices[b_ind][0] == 0:\n                        d = b_ind\n                        e = s_ind\n                        if let_check(b[d], s[e]):\n                            star_indices[b_ind][1] = s_ind + 1\n                            star_indices[b_ind][0] = 1\n                            b_ind += 1\n                            s_ind += 1\n                            continue\n                        else:\n                            if highest_active == 0:\n                                return False\n                            else:\n                                star_indices[highest_ind][0] = -1\n                                highest_active -= 1\n                                highest_ind = index_list[highest_active]\n                                b_ind = highest_ind\n                                s_ind = star_indices[highest_ind][1]\n                                continue\n                    elif star_indices[b_ind][0] >= 1:\n                        d = b_ind\n                        e = star_indices[b_ind][1]\n                        if let_check(b[d], s[e]):\n                            star_indices[b_ind][0] += 1\n                            star_indices[b_ind][1] += 1\n                            b_ind += 1\n                            s_ind += 1\n                            continue\n                        else:\n                            if highest_active == 0:\n                                return False\n                            else:\n                                star_indices[b_ind][0] = -1\n                                highest_active -= 1\n                                highest_ind = index_list[highest_active]\n                                continue\n                continue\n        else:\n            if let_check(b[b_ind], s[s_ind]) and (b_ind != len(b)-1 or s_ind == len(s)-1 or highest_active == -1):\n                b_ind += 1\n                s_ind += 1\n                continue\n            else:\n                while 1 == 1:\n                    if highest_active == -1:\n                        return False\n                    elif star_indices[highest_ind][0] == 0:\n                        star_indices[highest_ind][0] = 1\n                        d = highest_ind\n                        e = star_indices[highest_ind][1]\n                        if let_check(b[d], s[e]):\n                            b_ind = d + 1\n                            s_ind = e + 1\n                            star_indices[highest_ind][1] = s_ind\n                            break\n                        else:\n                            if highest_active == 0:\n                                return False\n                            else:\n                                star_indices[highest_ind][0] = -1\n                                highest_active -= 1\n                                highest_ind = index_list[highest_active]\n                                continue\n                    elif star_indices[highest_ind][0] >= 1:\n                        star_indices[highest_ind][0] += 1\n                        d = highest_ind\n                        e = star_indices[highest_ind][1]\n                        if let_check(b[d], s[e]):\n                            b_ind = d + 1\n                            s_ind = e + 1\n                            star_indices[highest_ind][1] = e + 1\n                            break\n                        else:\n                            if highest_active == 0:\n                                return False\n                            else:\n                                highest_active -= 1\n                                highest_ind = index_list[highest_active]\n                                star_indices[highest_ind][0] = -1\n                                continue\n\n    if s_ind == len(s) and b_ind == len(b):\n        return True\n    elif s_ind == len(s):\n        for y in range((b_ind), len(b)):\n            if y in star_indices.keys():\n                continue\n            else:\n                return False\n        else:\n            return True\n    else:\n        return False\n\n# main function\ndef main_solution(input_string, pattern):\n    # Convert input to JSON serializable types if necessary\n    input_string = str(input_string)\n    pattern = str(pattern)\n    \n    # Call the original function with the converted inputs\n    result = string_comp(input_string, pattern)\n    \n    # Convert the result to a JSON serializable type\n    return {\"match\": result}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Define possible characters for strings and patterns\n    letters = string.ascii_lowercase\n    pattern_chars = letters + '.' + '*'\n    \n    # Randomly decide the type of test case\n    case_type = random.randint(0, 3)\n    \n    if case_type == 0:\n        # Simple exact match without wildcards\n        s_len = random.randint(1, 10)\n        s = ''.join(random.choice(letters) for _ in range(s_len))\n        p = s  # Exact match\n    elif case_type == 1:\n        # Simple match with '.' wildcards\n        s_len = random.randint(1, 10)\n        s = ''.join(random.choice(letters) for _ in range(s_len))\n        p = ''.join(random.choice(letters + '.') for _ in range(s_len))\n    elif case_type == 2:\n        # Match with '*' wildcards\n        s_len = random.randint(1, 10)\n        s = ''.join(random.choice(letters) for _ in range(s_len))\n        p = ''\n        for _ in range(random.randint(1, s_len)):\n            char = random.choice(letters + '.')\n            p += char\n            if random.choice([True, False]):\n                p += '*'\n    else:\n        # Random strings and patterns, may or may not match\n        s_len = random.randint(1, 10)\n        s = ''.join(random.choice(letters) for _ in range(s_len))\n        p_len = random.randint(1, 10)\n        p = ''.join(random.choice(pattern_chars) for _ in range(p_len))\n    \n    return {\"input_string\": s, \"pattern\": p}", "io_pairs": [{"input": {"input_string": "rrrtsvuqm", "pattern": "ssy*n*ee*i"}, "output": {"match": false}}, {"input": {"input_string": "cvhmg", "pattern": "cvhmg"}, "output": {"match": true}}, {"input": {"input_string": "yzb", "pattern": "yzb"}, "output": {"match": true}}, {"input": {"input_string": "mijbctakh", "pattern": ".*snk*a"}, "output": {"match": false}}, {"input": {"input_string": "yihsq", "pattern": "zkbpk"}, "output": {"match": false}}, {"input": {"input_string": "j", "pattern": "u"}, "output": {"match": false}}, {"input": {"input_string": "cwlp", "pattern": "faar"}, "output": {"match": false}}, {"input": {"input_string": "z", "pattern": "z"}, "output": {"match": true}}, {"input": {"input_string": "dbqa", "pattern": "dbqa"}, "output": {"match": true}}, {"input": {"input_string": "d", "pattern": "n*"}, "output": {"match": false}}], "error_log": []}
{"context": "In a grid of size NxN, a robot starts at the top-left corner and needs to reach the bottom-right corner. The robot can only move right or down. How many unique paths can the robot take to reach the destination?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The size of the grid (NxN). It represents the number of steps in one direction (either right or down) required to reach the bottom-right corner from the top-left corner.\n\nOutput:\n  `return` (int): The number of unique lattice paths from the top-left corner to the bottom-right corner in an NxN grid.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef binomial_coeff(n, k):\n    result = 1\n    # calculate n!/k!\n    for i in range(k+1, n+1):\n        result *= i\n    # divide into (n-k!):\n    for i in range(1, n-k+1):\n        result /= i\n    return int(result)\n\n# main function\ndef main_solution(N):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # calculate the number of lattice paths in an NxN grid using the binomial coefficient\n    result = binomial_coeff(2 * N, N)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    N = random.randint(1, 20)\n    return {'N': N}", "io_pairs": [{"input": {"N": 19}, "output": 35345263800}, {"input": {"N": 12}, "output": 2704156}, {"input": {"N": 16}, "output": 601080389}, {"input": {"N": 4}, "output": 70}, {"input": {"N": 11}, "output": 705432}, {"input": {"N": 18}, "output": 9075135299}, {"input": {"N": 5}, "output": 252}, {"input": {"N": 13}, "output": 10400600}, {"input": {"N": 17}, "output": 2333606219}, {"input": {"N": 10}, "output": 184756}], "error_log": []}
{"context": "Given a 2x2 matrix and an operation to perform on it, what is the result of the operation? The possible operations are finding the determinant, computing the transpose, or calculating the inverse of the matrix.\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_values` (list of integers): A list of 4 integers representing the elements of a 2x2 matrix in row-major order.\n  `operation` (string): A string indicating the operation to perform on the matrix. Valid values are \"determinant\", \"transpose\", and \"inverse\".\n\nOutput:\n  `return` (float or list of lists of floats): The result of the operation. If the operation is \"determinant\", the output is a float. If the operation is \"transpose\" or \"inverse\", the output is a list of lists of floats representing the resulting matrix.", "reference_code": "# import necessary packages\nimport numpy as np\nimport random\n\n# main function\ndef main_solution(matrix_values, operation):\n    # Convert the input list to a numpy array\n    matrix = np.array(matrix_values).reshape(2, 2)\n    \n    # Perform the specified operation\n    if operation == 'determinant':\n        result = np.linalg.det(matrix)\n    elif operation == 'transpose':\n        result = matrix.T.tolist()\n    elif operation == 'inverse':\n        result = np.linalg.inv(matrix).tolist()\n    else:\n        raise ValueError(\"Invalid operation\")\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    operations = ['determinant', 'transpose', 'inverse']\n    operation = random.choice(operations)\n    \n    # Generate a 2x2 matrix with random integers between -10 and 10\n    matrix_values = [random.randint(-10, 10) for _ in range(4)]\n    \n    return {\n        'matrix_values': matrix_values,\n        'operation': operation\n    }", "io_pairs": [{"input": {"matrix_values": [-5, -5, -10, -8], "operation": "inverse"}, "output": [[0.8, -0.5], [-1.0, 0.5]]}, {"input": {"matrix_values": [-8, -10, -6, -3], "operation": "determinant"}, "output": -36.0}, {"input": {"matrix_values": [9, -2, 6, 6], "operation": "transpose"}, "output": [[9, 6], [-2, 6]]}, {"input": {"matrix_values": [6, 9, 0, -7], "operation": "inverse"}, "output": [[0.16666666666666666, 0.21428571428571425], [-0.0, -0.14285714285714285]]}, {"input": {"matrix_values": [-8, -3, 9, 6], "operation": "inverse"}, "output": [[-0.2857142857142857, -0.14285714285714288], [0.4285714285714286, 0.380952380952381]]}, {"input": {"matrix_values": [2, 8, -3, 3], "operation": "inverse"}, "output": [[0.1, -0.26666666666666666], [0.1, 0.06666666666666667]]}, {"input": {"matrix_values": [-10, -2, -3, 7], "operation": "inverse"}, "output": [[-0.09210526315789475, -0.02631578947368421], [-0.03947368421052632, 0.13157894736842105]]}, {"input": {"matrix_values": [6, 3, 6, -6], "operation": "determinant"}, "output": -54.00000000000001}, {"input": {"matrix_values": [-7, -9, -5, 10], "operation": "determinant"}, "output": -115.00000000000001}, {"input": {"matrix_values": [8, -5, -6, -2], "operation": "determinant"}, "output": -46.0}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = x^3 - x^2 + 2 \\), we need to find the root of this function using either the bisection method or the Newton-Raphson method. What is the root of the function when using the specified method within the given interval or starting from the initial guess, with a specified tolerance level?\n\nThe input and output requirements are as follows:\n\nInput:\n  `method` (str): The method to use for finding the root. It can be either \"bisection\" or \"newton_raphson\".\n  `a` (float): The lower bound of the interval for the bisection method.\n  `b` (float): The upper bound of the interval for the bisection method.\n  `x` (float): The initial guess for the Newton-Raphson method.\n  `epsilon` (float): The tolerance level for the root finding methods.\n\nOutput:\n  `return` (dict): A dictionary containing the key \"result\" with the value being the root found by the specified method.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef bisection(a, b, epsilon, fun):\n    c = a\n    while b - a > epsilon:\n        c = (b + a) / 2\n        if fun(c) == 0:\n            break\n        elif fun(c) > 0:\n            b = c\n        else:\n            a = c\n    return c\n\ndef newton_raphson(x, epsilon, fun, derivative):\n    h = fun(x) / derivative(x)\n    while abs(h) > epsilon:\n        h = fun(x) / derivative(x)\n        x -= h\n    return x\n\ndef derivative(x):\n    return 3 * x * x - 2 * x\n\ndef fun(x):\n    return x ** 3 - x ** 2 + 2\n\n# main function\ndef main_solution(method, a, b, x, epsilon):\n    # Convert JSON serializable inputs to original input variables\n    if method == \"bisection\":\n        result = bisection(a, b, epsilon, fun)\n    elif method == \"newton_raphson\":\n        result = newton_raphson(x, epsilon, fun, derivative)\n    else:\n        raise ValueError(\"Invalid method specified\")\n    \n    # Convert the result to a JSON serializable output\n    return {\"result\": result}", "input_generator": "import random\n\ndef input_generator():\n    method = random.choice([\"bisection\", \"newton_raphson\"])\n    epsilon = random.uniform(1e-10, 1e-5)\n    \n    if method == \"bisection\":\n        a = random.uniform(-10.0, 10.0)\n        b = random.uniform(a + 0.1, a + 10.0)  # Ensure b > a\n        x = 0.0  # Not used in bisection, but included for completeness\n    else:  # newton_raphson\n        x = random.uniform(-10.0, 10.0)\n        a = 0.0  # Not used in newton_raphson, but included for completeness\n        b = 0.0  # Not used in newton_raphson, but included for completeness\n    \n    return {\n        \"method\": method,\n        \"a\": a,\n        \"b\": b,\n        \"x\": x,\n        \"epsilon\": epsilon\n    }", "io_pairs": [{"input": {"method": "newton_raphson", "a": 0.0, "b": 0.0, "x": 1.345316280723729, "epsilon": 5.74520785211327e-06}, "output": {"result": -1.000000000000008}}, {"input": {"method": "bisection", "a": -0.16233595201048168, "b": 0.0138269388297151, "x": 0.0, "epsilon": 6.0529442109786654e-06}, "output": {"result": -0.16233057594569772}}, {"input": {"method": "bisection", "a": -6.679679600252218, "b": -0.586976890730706, "x": 0.0, "epsilon": 6.167722658735274e-06}, "output": {"result": -1.0000013989217362}}, {"input": {"method": "newton_raphson", "a": 0.0, "b": 0.0, "x": 9.199524693139722, "epsilon": 9.19615066273557e-06}, "output": {"result": -1.0000000000000002}}, {"input": {"method": "bisection", "a": 6.876018949499901, "b": 16.26618783325306, "x": 0.0, "epsilon": 1.3506724761028746e-06}, "output": {"result": 6.876020068895262}}, {"input": {"method": "bisection", "a": -2.1739108228400035, "b": 3.294513706743889, "x": 0.0, "epsilon": 6.455380349196873e-06}, "output": {"result": -0.9999979226927518}}, {"input": {"method": "newton_raphson", "a": 0.0, "b": 0.0, "x": 6.070660627528028, "epsilon": 4.437812778024196e-06}, "output": {"result": -1.0000000000074374}}, {"input": {"method": "newton_raphson", "a": 0.0, "b": 0.0, "x": -4.237249796284597, "epsilon": 2.0361494296393938e-06}, "output": {"result": -1.0}}, {"input": {"method": "bisection", "a": 2.0112594073272643, "b": 6.864710872282503, "x": 0.0, "epsilon": 2.1908729709142806e-06}, "output": {"result": 2.011260564480266}}, {"input": {"method": "newton_raphson", "a": 0.0, "b": 0.0, "x": -8.938847242644572, "epsilon": 3.3386060105767025e-06}, "output": {"result": -1.000000000000042}}], "error_log": []}
{"context": "In the classic Hanoi Tower problem, there are three rods and a number of disks of different sizes that can slide onto any rod. The puzzle starts with the disks neatly stacked in order of size on one rod, the smallest at the top, making a conical shape. The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:\n1. Only one disk can be moved at a time.\n2. Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty rod.\n3. No disk may be placed on top of a smaller disk.\n\nHowever, in this variation of the Hanoi Tower problem, there is an additional rule: a disk cannot be moved directly from the leftmost rod to the rightmost rod or from the rightmost rod to the leftmost rod without passing through the middle rod. Given the number of layers in the Hanoi Tower, how many steps are required to move all the disks to the target rod following these rules?\n\nThe input and output requirements are as follows:\n\nInput:\n  `steps` (int): The number of layers in the Hanoi Tower problem.\n\nOutput:\n  `return` (int): The total number of steps required to move the Hanoi Tower with the given number of layers, following the rule that a layer cannot be moved directly between the leftmost and rightmost positions without passing through the middle.", "reference_code": "# import necessary packages\nimport sys\n\n# main function\ndef main_solution(steps):\n    # Convert the input to an integer\n    steps = int(steps)\n    \n    # Define the recursive function to calculate the steps\n    def calculate_step(n):\n        if n == 1:\n            return 2\n        else:\n            return 3 * calculate_step(n - 1) + 2\n    \n    # Calculate the result\n    result = calculate_step(steps)\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    steps = random.randint(1, 10)\n    return {'steps': steps}", "io_pairs": [{"input": {"steps": 3}, "output": 26}, {"input": {"steps": 10}, "output": 59048}, {"input": {"steps": 9}, "output": 19682}, {"input": {"steps": 8}, "output": 6560}, {"input": {"steps": 7}, "output": 2186}, {"input": {"steps": 1}, "output": 2}, {"input": {"steps": 5}, "output": 242}, {"input": {"steps": 6}, "output": 728}, {"input": {"steps": 4}, "output": 80}, {"input": {"steps": 2}, "output": 8}], "error_log": []}
{"context": "Given a message, how can we ensure that the message remains confidential during transmission by encrypting it using RSA encryption and then decrypting it back to its original form? What will be the decrypted message after the encryption and decryption processes?\n\nThe input and output requirements are as follows:\n\nInput:\n  `message` (str): The message to be encrypted and decrypted. It should be a string of characters.\n\nOutput:\n  `return` (str): The decrypted message, which should be the same as the input message if the encryption and decryption processes are correct.", "reference_code": "# import necessary packages\nimport random\nimport math\n\n# dictionary mapping\nletters = {chr(i): i for i in range(256)}\nnumbers = {num: letter for letter, num in letters.items()}\n\ndef exponentMod(A, B, C):\n    # Base cases \n    if A == 0:\n        return 0\n    if B == 0:\n        return 1\n\n    # If B is even \n    if B % 2 == 0:\n        y = exponentMod(A, B / 2, C)\n        y = (y * y) % C\n\n    # If B is odd \n    else:\n        y = A % C\n        y = (y * exponentMod(A, B - 1, C) % C) % C\n\n    return (int)((y + C) % C)\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef gen_public_key(n, phi):\n    list_random_e = [i for i in range(1, phi) if (n % i != 0 and gcd(i, phi) == 1)]\n    e = random.choice(list_random_e)\n    return (n, e)\n\ndef gen_private_key(n, phi, e):\n    list_random_k = [i for i in range(1, phi) if (((i * phi) + 1) % e == 0)]\n    k = random.choice(list_random_k)\n    d = ((k * phi) + 1) // e\n    return (n, d)\n\ndef change(c):\n    d = \"\"\n    while c > 0:\n        digit = c % 10\n        e = random.randint(0, 9)\n        d += str(e) + str(digit)  # adding random then actual digit , on reversing we get actual digit followed by random no\n        c = c // 10\n    return d[::-1]\n\ndef changeback(i):\n    original = \"\"\n    for n in range(0, len(i)):\n        if n % 2 == 0:\n            original += i[n]\n    return int(original)\n\n# main function\ndef main_solution(message):\n    # Generate primes and keys\n    primes = [i for i in range(26, 1000) if isPrime(i)]\n    p = random.choice(primes)\n    primes.remove(p)\n    q = random.choice(primes)\n    n = p * q\n    phi = (p - 1) * (q - 1)\n    public_key = gen_public_key(n, phi)\n    private_key = gen_private_key(n, phi, public_key[1])\n\n    # Encrypt the message\n    encrypted_message = []\n    for char in message:\n        c = exponentMod(letters[char], public_key[1], n)\n        s = change(c)\n        encrypted_message.append(s)\n\n    # Decrypt the message\n    decrypted_message = []\n    for s in encrypted_message:\n        cipher = changeback(s)\n        decryp = exponentMod(cipher, private_key[1], n)\n        dmsg = numbers[decryp]\n        decrypted_message.append(dmsg)\n\n    # Return the decrypted message as a string\n    return ''.join(decrypted_message)", "input_generator": "import random\nimport string\n\ndef input_generator():\n    message_length = random.randint(5, 20)\n    message = ''.join(random.choice(string.ascii_letters + string.digits + string.punctuation) for _ in range(message_length))\n    return {'message': message}", "io_pairs": [{"input": {"message": "kGk@y"}, "output": "kGk@y"}, {"input": {"message": "^EFomB'?"}, "output": "^EFomB'?"}, {"input": {"message": "L*3)pj\"C"}, "output": "L*3)pj\"C"}, {"input": {"message": "Q'M9MMZfA~3OM2}8R["}, "output": "Q'M9MMZfA~3OM2}8R["}, {"input": {"message": "Z}3tCB"}, "output": "Z}3tCB"}, {"input": {"message": "Divthing"}, "output": "Divthing"}, {"input": {"message": "\"_S?~BV-@ov~"}, "output": "\"_S?~BV-@ov~"}, {"input": {"message": "LHy8!Yf^"}, "output": "LHy8!Yf^"}, {"input": {"message": "&GB{CONpq^jm]UK?"}, "output": "&GB{CONpq^jm]UK?"}, {"input": {"message": "VtUb5O"}, "output": "VtUb5O"}], "error_log": []}
{"context": "Given a dataset of numerical values, how can we determine if a hypothesized mean value falls within the confidence interval of the dataset? Specifically, what is the result of the hypothesis test for the given dataset and hypothesized mean?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data_list` (list of float): A list of numerical data points.\n  `hypothesis_mean` (float): The hypothesized mean value to be tested.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"is_hypothesis_in_ci\"` whose value is a boolean indicating whether the hypothesized mean is within the confidence interval of the data.", "reference_code": "# import necessary packages\nfrom math import sqrt\nimport random\n\n# all class and function definitions in the code file, if any\ndef mean(l):\n    return float(sum(l)) / len(l)\n\ndef var(l):\n    m = mean(l)\n    return sum([(x - m) ** 2 for x in l]) / len(l)\n\ndef factor(l):\n    return 1.96\n\ndef conf(l):\n    # confidence interval\n    return factor(l) * sqrt(var(l) / len(l))\n\ndef test(l, h):\n    m = mean(l)\n    c = conf(l)\n    return abs(h - m) <= c\n\n# main function\ndef main_solution(data_list, hypothesis_mean):\n    # Convert JSON serializable inputs to original input variables\n    data_list = list(data_list)\n    hypothesis_mean = float(hypothesis_mean)\n    \n    # Perform the hypothesis test\n    result = test(data_list, hypothesis_mean)\n    \n    # Convert the result to a JSON serializable output\n    return {\"is_hypothesis_in_ci\": result}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random data list with reasonable values\n    data_size = random.randint(5, 20)\n    mean_val = random.uniform(10, 100)\n    std_dev = random.uniform(1, 20)\n    data_list = [random.gauss(mean_val, std_dev) for _ in range(data_size)]\n    \n    # Generate a hypothesis mean around the mean of the data list with some randomness\n    hypothesis_mean = mean_val + random.uniform(-2 * std_dev, 2 * std_dev)\n    \n    return {\n        \"data_list\": data_list,\n        \"hypothesis_mean\": hypothesis_mean\n    }", "io_pairs": [{"input": {"data_list": [89.95077702996745, 53.71999560233152, 64.18330827034721, 109.55585492789444, 82.84828644947623, 50.146171064319574, 69.24991312811137, 83.27522565009102, 46.563330176610755, 90.32304530464128], "hypothesis_mean": 81.38157219308818}, "output": {"is_hypothesis_in_ci": true}}, {"input": {"data_list": [91.28110162861606, 91.4328803522318, 92.9125561017299, 90.21467594669171, 91.11098059635975, 91.87766934139631, 91.91569161971694, 89.40047047425077, 90.93224620034108, 91.22430089570557, 91.11929424061063, 90.56081692723045, 89.30269994281855, 90.08184956293329, 91.38217452987487], "hypothesis_mean": 92.2791930107874}, "output": {"is_hypothesis_in_ci": false}}, {"input": {"data_list": [38.29005807830237, 36.94397735847093, 31.927762640898294, 38.479485924633366, 36.764268356987095, 30.39874680693971, 21.84240811544968, 35.71365673825083, 44.42700902867211, 27.962654962775595], "hypothesis_mean": 37.07002442961121}, "output": {"is_hypothesis_in_ci": true}}, {"input": {"data_list": [67.24181388502996, 70.32614731405403, 92.85607871536028, 50.55611556871083, 76.617719431091, 111.0145554493489, 64.58849175474244, 87.83426055120516, 58.45607869855206, 110.22815570532882, 64.99122797755791, 52.77887941345483], "hypothesis_mean": 61.602069272412024}, "output": {"is_hypothesis_in_ci": false}}, {"input": {"data_list": [58.9384107911724, 59.14261509874879, 56.362927092483375, 59.70526799943645, 60.727672955890604, 63.10669447879349, 57.872601429070095, 58.50576566642223, 62.250196483092566, 58.277670820949616, 63.532949610877864, 61.70978690354815, 59.9480702705605, 58.74030004249429], "hypothesis_mean": 59.04074305755839}, "output": {"is_hypothesis_in_ci": true}}, {"input": {"data_list": [83.64225652123648, 83.3074184924584, 81.75986376296666, 80.7559316579523, 84.1435415620457, 83.69511258632018, 82.71790672678614, 82.01063363911624, 84.46492636793904, 83.42033060218168, 81.28430177186584, 84.6448208288055, 83.50389764047031, 83.84831057672884, 82.06689081414142, 86.47924513168886], "hypothesis_mean": 86.25455603355924}, "output": {"is_hypothesis_in_ci": false}}, {"input": {"data_list": [21.02226688676193, 23.97419665807452, 6.207455255368274, 23.60653827756703, 27.017981889385144, 16.795964029704844, 21.467828864174095, 18.98707090908517, 18.35480025672134, 29.375193496682186, 25.23152534405463, 27.867603946458093, 25.624798129741713], "hypothesis_mean": 32.76925182213034}, "output": {"is_hypothesis_in_ci": false}}, {"input": {"data_list": [88.04340474643057, 85.56198026529393, 105.75962973442437, 89.04774747877352, 76.62745403229928, 64.8313344948966], "hypothesis_mean": 100.3009839413338}, "output": {"is_hypothesis_in_ci": false}}, {"input": {"data_list": [8.8528824933969, 26.820004053356705, 13.634581124391907, 19.60646862617072, -5.685632677261417, 41.865170156640104, 26.089218298404475, 46.33246392705716, 21.776009297079614, 14.392645293973708, 43.951772178020185], "hypothesis_mean": 34.31817796089292}, "output": {"is_hypothesis_in_ci": false}}, {"input": {"data_list": [76.43439631140303, 95.96717034079639, 73.0992633161702, 70.86548968367588, 84.37961236420884, 73.52222043667811, 93.0075513874009, 86.23831095896331], "hypothesis_mean": 93.24585270274426}, "output": {"is_hypothesis_in_ci": false}}], "error_log": []}
{"context": "Given a 2x3 sliding puzzle board, where each cell contains a unique number from 0 to 5, and the goal is to rearrange the board to match the target configuration `[[1,2,3],[4,5,0]]` by sliding the tiles into the empty space (represented by 0), how many moves are required to achieve this configuration? If it is impossible to reach the target configuration, what should be returned?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (str): A string representation of the 2x3 puzzle board. The board is represented as a string where rows are separated by semicolons (`;`) and elements within each row are separated by commas (`,`). For example, the board `[[1,2,3],[4,5,0]]` would be represented as `\"1,2,3;4,5,0\"`.\n\nOutput:\n  `return` (int): The minimum number of moves required to solve the puzzle. If the puzzle cannot be solved, it returns `-1`.", "reference_code": "# import necessary packages\nimport copy\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def slidingPuzzle(self, board):\n        if board == [[1,2,3],[4,5,0]]: return 0\n        move = {(0,0): ('up', 'left'), (0,1): ('up', 'left', 'right'), (0,2): ('up', 'right'),\n                (1,0): ('down', 'left'), (1,1): ('down', 'left', 'right'), (1,2): ('down', 'right')}\n\n        def findZero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n        \n        def slide(board, direction, i, j):\n            grid = copy.deepcopy(board)\n            if direction == 'left':\n                grid[i][j] = grid[i][j+1]\n                grid[i][j+1] = 0\n                return grid, i, j+1\n            if direction == 'right':\n                grid[i][j] = grid[i][j-1]\n                grid[i][j-1] = 0\n                return grid, i, j-1\n            if direction == 'up':\n                grid[i][j] = grid[i+1][j]\n                grid[i+1][j] = 0\n                return grid, i+1, j\n            if direction == 'down':\n                grid[i][j] = grid[i-1][j]\n                grid[i-1][j] = 0\n                return grid, i-1, j\n\n        i, j = findZero(board)\n        Q = [(board, i, j, 0)]\n        seen = []\n        while Q:\n            grid, i, j, count = Q.pop(0)\n            for direction in move[(i,j)]:\n                status, x, y = slide(grid, direction, i, j)\n                if status == [[1,2,3],[4,5,0]]:\n                    return count + 1\n                elif status not in seen:\n                    seen.append(status)\n                    Q.append((status, x, y, count+1))\n        return -1\n\n# main function\ndef main_solution(board):\n    # Convert the input board to a list of lists if it's not already\n    if isinstance(board, str):\n        board = [list(map(int, row.split(','))) for row in board.split(';')]\n    \n    # Create an instance of the Solution class and call the slidingPuzzle method\n    sol = Solution()\n    result = sol.slidingPuzzle(board)\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random board configuration for the 2x3 sliding puzzle\n    numbers = [0, 1, 2, 3, 4, 5]\n    random.shuffle(numbers)\n    board = [\n        [numbers[0], numbers[1], numbers[2]],\n        [numbers[3], numbers[4], numbers[5]]\n    ]\n    return {'board': board}", "io_pairs": [{"input": {"board": [[3, 0, 2], [1, 5, 4]]}, "output": 12}, {"input": {"board": [[5, 4, 1], [2, 0, 3]]}, "output": -1}, {"input": {"board": [[4, 3, 0], [2, 5, 1]]}, "output": -1}, {"input": {"board": [[2, 5, 1], [0, 4, 3]]}, "output": -1}, {"input": {"board": [[3, 4, 5], [2, 1, 0]]}, "output": -1}, {"input": {"board": [[4, 2, 5], [0, 3, 1]]}, "output": -1}, {"input": {"board": [[5, 1, 4], [3, 0, 2]]}, "output": -1}, {"input": {"board": [[0, 3, 1], [4, 2, 5]]}, "output": -1}, {"input": {"board": [[4, 3, 0], [2, 1, 5]]}, "output": 7}, {"input": {"board": [[4, 1, 5], [0, 3, 2]]}, "output": 8}], "error_log": []}
{"context": "Given a mathematical series, you are tasked with computing an approximation for either \u03c0 or the golden ratio. The series type and the number of terms to consider are provided. What is the computed approximation for the given series type and number of terms?\n\nThe input and output requirements are as follows:\n\nInput:\n  `type` (str): A string indicating the type of computation to perform. It can be either \"pi\" to compute an approximation of \u03c0 or \"goldenratio\" to compute an approximation of the golden ratio.\n  `N` (int): An integer greater than 0 indicating the number of terms to use in the computation. For \"pi\", it represents the number of terms in the series. For \"goldenratio\", it represents the number of terms in the Fibonacci sequence.\n\nOutput:\n  `return` (float): The computed approximation. If `type` is \"pi\", it returns an approximation of \u03c0. If `type` is \"goldenratio\", it returns an approximation of the golden ratio.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(type, N):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    assert N > 0, 'N has to be greater than 0'\n    \n    if type == 'pi':\n        pi = 0\n        for n in range(1, N + 1):\n            pi += 1 / (n ** 2)\n        pi = (pi * 6) ** (1 / 2)\n        return pi\n    \n    elif type == 'goldenratio':\n        F = [1, 1]\n        if N == 1:\n            fib = F[0]\n        elif N == 2:\n            fib = F[1]\n        else:\n            for n in range(2, N):\n                F.append(F[-1] + F[-2])\n            fib = F[-1] / F[-2]\n        return fib\n    \n    else:\n        raise ValueError(\"Type not programmed in! Please check the series in question.\")", "input_generator": "import random\n\ndef input_generator():\n    types = ['pi', 'goldenratio']\n    type_choice = random.choice(types)\n    if type_choice == 'pi':\n        N = random.randint(1, 1000)\n    else:\n        N = random.randint(1, 100)\n    return {'type': type_choice, 'N': N}", "io_pairs": [{"input": {"type": "goldenratio", "N": 18}, "output": 1.6180338134001253}, {"input": {"type": "pi", "N": 895}, "output": 3.140526107880882}, {"input": {"type": "pi", "N": 205}, "output": 3.1369423613467577}, {"input": {"type": "pi", "N": 398}, "output": 3.1391954299245053}, {"input": {"type": "goldenratio", "N": 46}, "output": 1.618033988749895}, {"input": {"type": "goldenratio", "N": 49}, "output": 1.618033988749895}, {"input": {"type": "pi", "N": 976}, "output": 3.140614590869942}, {"input": {"type": "pi", "N": 507}, "output": 3.139710455570083}, {"input": {"type": "pi", "N": 769}, "output": 3.140351434351185}, {"input": {"type": "goldenratio", "N": 66}, "output": 1.618033988749895}], "error_log": []}
{"context": "Given a series of terms where each term is defined as `1/(4^x)` for `x` ranging from 1 to `N`, what is the sum of the first `N` terms of this series?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The number of terms in the series to sum. It should be a positive integer.\n\nOutput:\n  `return` (float): The sum of the series `1/(4^1) + 1/(4^2) + ... + 1/(4^N)`. The result is a floating-point number.", "reference_code": "# import necessary packages\nimport numpy as np\nimport sympy as sp\n\n# main function\ndef main_solution(N):\n    # Convert the input to an integer\n    N = int(N)\n    \n    # Calculate the sum of the series\n    c = 0\n    for x in range(1, N + 1):\n        c += 1 / (4 ** x)\n    \n    # Return the result as a float\n    return float(c)", "input_generator": "import random\n\ndef input_generator():\n    N = random.randint(1, 100)\n    return {'N': N}", "io_pairs": [{"input": {"N": 54}, "output": 0.3333333333333333}, {"input": {"N": 15}, "output": 0.3333333330228925}, {"input": {"N": 80}, "output": 0.3333333333333333}, {"input": {"N": 9}, "output": 0.3333320617675781}, {"input": {"N": 68}, "output": 0.3333333333333333}, {"input": {"N": 60}, "output": 0.3333333333333333}, {"input": {"N": 79}, "output": 0.3333333333333333}, {"input": {"N": 3}, "output": 0.328125}, {"input": {"N": 20}, "output": 0.33333333333303017}, {"input": {"N": 16}, "output": 0.3333333332557231}], "error_log": []}
{"context": "Given a text string, how can we encrypt it using a predefined name and optionally specify the length of the encrypted output?\n\nThe input and output requirements are as follows:\n\nInput:\n  `context` (str): The text to be encrypted.\n  `num` (int, optional): The length of the encrypted output. If not provided, the default length is 11 characters.\n\nOutput:\n  `return` (str): The encrypted text of the specified length.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(context, num=None):\n    # Convert context to string if it's not already\n    context = str(context)\n    \n    # Initialize character groups\n    lower_index, upper_index, number_index, mark_index = [], [], [], []\n    \n    # Populate character groups\n    for i in range(97, 123):\n        lower_index.append(chr(i))\n    for i in range(65, 91):\n        upper_index.append(chr(i))\n    for i in range(48, 58):\n        number_index.append(chr(i))\n    for i in range(33, 123):\n        if chr(i) not in lower_index and chr(i) not in upper_index and chr(i) not in number_index:\n            if i != 0 and i != 1:\n                mark_index.append(chr(i))\n    \n    index_list = [lower_index, upper_index, number_index, mark_index]\n    \n    # Define the name to be used for encryption\n    name = 'yanghuichun'\n    \n    # Adjust length of context or name to match the other\n    if len(name) > len(context):\n        cycle = len(name) // len(context)\n        added = len(name) % len(context)\n        context = context * cycle + context[:added]\n    else:\n        cycle = len(context) // len(name)\n        added = len(context) % len(name)\n        name = name * cycle + name[:added]\n    \n    output = ''\n    \n    # Encrypt the context using the name\n    for i in range(len(name)):\n        sub2 = ord(name[i]) + ord(context[i])\n        index_choose_list = sub2 % 4\n        index_choose_index = sub2 % len(index_list[index_choose_list])\n        key = index_list[index_choose_list][index_choose_index]\n        \n        # Ensure the key is unique in the output\n        while key in output:\n            index_choose_list = (index_choose_list + 1) % 4\n            index_choose_index = (1 + index_choose_index) % len(index_list[index_choose_list])\n            key = index_list[index_choose_list][index_choose_index]\n        \n        output += key\n    \n    # Return the encrypted output with the specified length or default to 11 characters\n    if num:\n        return output[:int(num)]\n    else:\n        return output[:11]", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random context string with a reasonable length (between 5 and 20 characters)\n    context_length = random.randint(5, 20)\n    context = ''.join(random.choices(string.ascii_letters + string.digits + string.punctuation, k=context_length))\n    \n    # Randomly decide whether to include num or not (50% chance)\n    if random.random() < 0.5:\n        num = random.randint(1, 20)\n        return {'context': context, 'num': num}\n    else:\n        return {'context': context}", "io_pairs": [{"input": {"context": "Usydo%scKu", "num": 15}, "output": "6e(i>4m8,&`"}, {"input": {"context": "^h@|$ef^+h3", "num": 16}, "output": ">T4$k8,L(NF"}, {"input": {"context": "m@hU]zpsnS<J"}, "output": "0F4gP:J&Hs\""}, {"input": {"context": "}3yW=V(\"{cWK*nC"}, "output": "6s(0JiPD$\"c"}, {"input": {"context": "Q-GfCOfa9", "num": 18}, "output": "2$ZXeo,PF8:"}, {"input": {"context": "pd`#Nd'%lIEbHx9..Rf"}, "output": "ZP682Joge0,"}, {"input": {"context": "wxaQv)>$8h%", "num": 13}, "output": "gJ,c28`\\eN("}, {"input": {"context": "@,Hn1c2`j0Q%19pl%^b", "num": 2}, "output": "DL"}, {"input": {"context": "m}RIDX^", "num": 9}, "output": "02kuqX$aV"}, {"input": {"context": "@{W{a85", "num": 14}, "output": "DmP6TR8\\$wZ"}], "error_log": []}
{"context": "Given four distinct integers between 1 and 9, what is the largest integer `n` such that all integers from 1 to `n` can be obtained by applying the basic arithmetic operations (+, -, *, /) to the sequence of these four numbers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): The first number in the sequence.\n  `b` (int): The second number in the sequence.\n  `c` (int): The third number in the sequence.\n  `d` (int): The fourth number in the sequence.\n\nOutput:\n  `return` (int): The largest integer `n` such that all integers from 1 to `n` can be obtained by applying the basic arithmetic operations (+, -, *, /) to the sequence of numbers `[a, b, c, d]`.", "reference_code": "# import necessary packages\nfrom itertools import permutations, product\n\n# all class and function definitions in the code file, if any\ndef opAdd(a, b):\n    return a + b\ndef opSub(a, b):\n    return a - b\ndef opMul(a, b):\n    return a * b\ndef opDiv(a, b):\n    return float(a) / float(b)\n\ndef calExpression1(numbers, ops):\n    r = ops[0](numbers[0], numbers[1])\n    r = ops[1](r, numbers[2])\n    r = ops[2](r, numbers[3])\n    return r\n\ndef calExpression2(numbers, ops):\n    r = ops[0](numbers[0], numbers[1])\n    p = ops[2](numbers[2], numbers[3])\n    r = ops[1](r, p)\n    return r\n\ndef calExpression3(numbers, ops):\n    r = ops[1](numbers[1], numbers[2])\n    r = ops[0](numbers[0], r)\n    r = ops[2](r, numbers[3])\n    return r\n\ndef calExpression4(numbers, ops):\n    r = ops[1](numbers[1], numbers[2])\n    r = ops[2](r, numbers[3])\n    r = ops[0](numbers[0], r)\n    return r\n\ndef calExpression5(numbers, ops):\n    r = ops[2](numbers[2], numbers[3])\n    r = ops[1](numbers[1], r)\n    r = ops[0](numbers[0], r)\n    return r\n\ndef findLargestConsecutive(a, b, c, d):\n    numbers = [a, b, c, d]\n    ops = [opAdd, opSub, opMul, opDiv]\n    cals = [calExpression1, calExpression2, calExpression3, calExpression4, calExpression5]\n    results = set()\n    for n in permutations(numbers):\n        for o in product(ops, repeat=3):\n            for c in cals:\n                try:\n                    r = c(n, o)\n                    if r > 0 and float(r).is_integer():\n                        results.add(r)\n                except ZeroDivisionError:\n                    continue\n    largestConsecutive = 1\n    for x in range(1, max(results)):\n        if x not in results:\n            largestConsecutive = x - 1\n            break\n    return largestConsecutive\n\n# main function\ndef main_solution(a, b, c, d):\n    # Convert JSON serializable inputs to original input variables\n    a, b, c, d = int(a), int(b), int(c), int(d)\n    \n    # Call the core function\n    result = findLargestConsecutive(a, b, c, d)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate four random integers between 1 and 9 (inclusive)\n    a = random.randint(1, 9)\n    b = random.randint(1, 9)\n    c = random.randint(1, 9)\n    d = random.randint(1, 9)\n    \n    return {'a': a, 'b': b, 'c': c, 'd': d}", "io_pairs": [{"input": {"a": 1, "b": 9, "c": 4, "d": 5}, "output": 12}, {"input": {"a": 8, "b": 2, "c": 9, "d": 8}, "output": 21}, {"input": {"a": 9, "b": 2, "c": 8, "d": 7}, "output": 22}, {"input": {"a": 5, "b": 9, "c": 6, "d": 4}, "output": 8}, {"input": {"a": 1, "b": 2, "c": 2, "d": 3}, "output": 16}, {"input": {"a": 2, "b": 6, "c": 1, "d": 5}, "output": 43}, {"input": {"a": 6, "b": 7, "c": 9, "d": 4}, "output": 14}, {"input": {"a": 1, "b": 4, "c": 8, "d": 2}, "output": 26}, {"input": {"a": 9, "b": 2, "c": 8, "d": 9}, "output": 20}, {"input": {"a": 4, "b": 8, "c": 9, "d": 6}, "output": 30}], "error_log": []}
{"context": "Given a tree structure, where each node can either be a binary tree node with left and right children or an n-ary tree node with multiple children, what would be the mirrored structure of the tree after interchanging the positions of the children?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (dict): A dictionary representing the structure of the tree. For binary trees, it contains keys `\"value\"`, `\"left\"`, and `\"right\"`. For n-ary trees, it contains keys `\"value\"` and `\"children\"`, where `\"children\"` is a list of child nodes.\n\nOutput:\n  `return` (dict): A dictionary representing the mirrored structure of the input tree. The structure is the same as the input, but the positions of the children are reversed.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.children = []\n\ndef mirrorBTree(root):\n    if root is None:\n        return root\n    left = mirrorBTree(root.left)\n    right = mirrorBTree(root.right)\n    root.left = right\n    root.right = left\n    return root\n\ndef mirrorNTree(root):\n    if root is None:\n        return root\n    temp = []\n    for child in root.children:\n        temp.append(mirrorNTree(child))\n    temp.reverse()\n    root.children = temp\n    return root\n\ndef tree_to_dict(root):\n    if root is None:\n        return None\n    if root.children:  # n-ary tree\n        return {\n            \"value\": root.value,\n            \"children\": [tree_to_dict(child) for child in root.children]\n        }\n    else:  # binary tree\n        return {\n            \"value\": root.value,\n            \"left\": tree_to_dict(root.left),\n            \"right\": tree_to_dict(root.right)\n        }\n\ndef dict_to_tree(d):\n    if d is None:\n        return None\n    node = TreeNode(d[\"value\"])\n    if \"children\" in d:  # n-ary tree\n        node.children = [dict_to_tree(child) for child in d[\"children\"]]\n    else:  # binary tree\n        node.left = dict_to_tree(d[\"left\"])\n        node.right = dict_to_tree(d[\"right\"])\n    return node\n\n# main function\ndef main_solution(tree_structure):\n    # Convert JSON serializable input to TreeNode\n    root = dict_to_tree(tree_structure)\n    \n    # Determine if it's a binary tree or n-ary tree\n    if \"children\" in tree_structure:\n        mirrored_root = mirrorNTree(root)\n    else:\n        mirrored_root = mirrorBTree(root)\n    \n    # Convert TreeNode back to JSON serializable output\n    mirrored_tree_structure = tree_to_dict(mirrored_root)\n    \n    return mirrored_tree_structure", "input_generator": "import random\nimport json\n\ndef input_generator():\n    tree_type = random.choice(['binary', 'nary'])\n    \n    if tree_type == 'binary':\n        depth = random.randint(1, 4)\n        def build_binary_tree(d):\n            if d == 0:\n                return None\n            node = {\"value\": random.randint(1, 100)}\n            node[\"left\"] = build_binary_tree(d - 1)\n            node[\"right\"] = build_binary_tree(d - 1)\n            return node\n        tree_structure = build_binary_tree(depth)\n    else:\n        depth = random.randint(1, 3)\n        max_children = random.randint(2, 4)\n        def build_nary_tree(d):\n            if d == 0:\n                return None\n            node = {\"value\": random.randint(1, 100), \"children\": []}\n            num_children = random.randint(0, max_children)\n            for _ in range(num_children):\n                child = build_nary_tree(d - 1)\n                if child is not None:\n                    node[\"children\"].append(child)\n            return node if node[\"children\"] or random.random() > 0.5 else None\n        tree_structure = build_nary_tree(depth)\n        if tree_structure is None:\n            tree_structure = {\"value\": random.randint(1, 100), \"children\": []}\n    \n    return {\"tree_structure\": tree_structure}", "io_pairs": [{"input": {"tree_structure": {"value": 41, "children": []}}, "output": {"value": 41, "left": null, "right": null}}, {"input": {"tree_structure": {"value": 60, "children": [{"value": 87, "children": []}]}}, "output": {"value": 60, "children": [{"value": 87, "left": null, "right": null}]}}, {"input": {"tree_structure": {"value": 13, "children": [{"value": 31, "children": []}]}}, "output": {"value": 13, "children": [{"value": 31, "left": null, "right": null}]}}, {"input": {"tree_structure": {"value": 44, "children": []}}, "output": {"value": 44, "left": null, "right": null}}, {"input": {"tree_structure": {"value": 69, "children": [{"value": 40, "children": []}]}}, "output": {"value": 69, "children": [{"value": 40, "left": null, "right": null}]}}, {"input": {"tree_structure": {"value": 51, "children": []}}, "output": {"value": 51, "left": null, "right": null}}, {"input": {"tree_structure": {"value": 45, "left": null, "right": null}}, "output": {"value": 45, "left": null, "right": null}}, {"input": {"tree_structure": {"value": 91, "left": null, "right": null}}, "output": {"value": 91, "left": null, "right": null}}, {"input": {"tree_structure": {"value": 100, "children": []}}, "output": {"value": 100, "left": null, "right": null}}, {"input": {"tree_structure": {"value": 91, "children": []}}, "output": {"value": 91, "left": null, "right": null}}], "error_log": []}
{"context": "Given a number `n`, how many numbers `i` in the range from 1 to `n` satisfy the condition where the number of times 5 divides the factorial of `2*i-1` is less than twice the number of times 5 divides the factorial of `i`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The upper limit of the range for which the function will check the condition.\n\nOutput:\n  `return` (int): The count of numbers `i` in the range from 1 to `n` that satisfy the condition `f5(factorial(2*i-1)) < 2*f5(factorial(i))`.", "reference_code": "# import necessary packages\nfrom math import factorial\n\n# all class and function definitions in the code file, if any\ndef numberToBase(n, b):\n    if n == 0:\n        return [0]\n    digits = []\n    while n:\n        digits.append(n % b)\n        n //= b\n    return digits[::-1]\n\ndef f5(n):\n    count = 0\n    while n % 5 == 0:\n        count += 1\n        n //= 5\n    return count\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    count = 0\n    for i in range(1, n+1):\n        if f5(factorial(2*i-1)) < 2*f5(factorial(i)):\n            count += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 100)\n    return {'n': n}", "io_pairs": [{"input": {"n": 30}, "output": 4}, {"input": {"n": 58}, "output": 7}, {"input": {"n": 29}, "output": 3}, {"input": {"n": 6}, "output": 1}, {"input": {"n": 46}, "output": 5}, {"input": {"n": 68}, "output": 8}, {"input": {"n": 63}, "output": 8}, {"input": {"n": 72}, "output": 8}, {"input": {"n": 75}, "output": 9}, {"input": {"n": 61}, "output": 8}], "error_log": []}
{"context": "In a game theory scenario, a game tree is used to represent the possible moves and outcomes of a game. The tree is structured such that each node can be either a terminal node (with a specific value) or a non-terminal node (with branches representing possible moves). Given a game tree, what are the utility values of the root node when treated as a max node and a min node?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree` (list): A nested list representing the game tree. Each element can be either an integer (terminal node) or another list (non-terminal node).\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `max_utility` (int): The utility value of the root node when treated as a max node.\n    - `min_utility` (int): The utility value of the root node when treated as a min node.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef max_value(tree, alpha=float('-inf'), beta=float('inf')):\n    if type(tree) == int:\n        return tree\n    \n    v = float('-inf')\n    for i, node in enumerate(tree): \n        v = max(v, min_value(node, alpha, beta))\n        \n        if v >= beta and tree[i+1:]:\n            return v\n        \n        alpha = max(alpha, v)\n    return v\n\ndef min_value(tree, alpha=float('-inf'), beta=float('inf')):\n    if type(tree) == int:\n        return tree    \n    \n    v = float('inf')\n    for i, node in enumerate(tree):\n        v = min(v, max_value(node, alpha, beta))\n        \n        if v <= alpha and tree[i+1:]:\n            return v\n        beta = min(beta, v)\n    return v\n\n# main function\ndef main_solution(tree):\n    # Convert the input tree to a list of lists if it's not already\n    if not isinstance(tree, list):\n        raise ValueError(\"The input tree must be a list of lists or integers.\")\n    \n    # Compute the utility of the root as a max node\n    max_utility = max_value(tree)\n    \n    # Compute the utility of the root as a min node\n    min_utility = min_value(tree)\n    \n    # Return the results as a dictionary\n    return {\n        \"max_utility\": max_utility,\n        \"min_utility\": min_utility\n    }", "input_generator": "import random\n\ndef input_generator():\n    def generate_tree(depth):\n        if depth == 0:\n            return random.randint(-10, 10)\n        else:\n            num_children = random.randint(1, 3)\n            return [generate_tree(depth - 1) for _ in range(num_children)]\n    \n    depth = random.randint(1, 4)\n    tree = generate_tree(depth)\n    return {\"tree\": tree}", "io_pairs": [{"input": {"tree": [[-9]]}, "output": {"max_utility": -9, "min_utility": -9}}, {"input": {"tree": [[0, 7], [-7, -5], [-4]]}, "output": {"max_utility": 0, "min_utility": -5}}, {"input": {"tree": [-7]}, "output": {"max_utility": -7, "min_utility": -7}}, {"input": {"tree": [[9, -5], [1, 8, -3]]}, "output": {"max_utility": -3, "min_utility": 8}}, {"input": {"tree": [[8], [5, 4, 8], [5, -10, 9]]}, "output": {"max_utility": 8, "min_utility": 8}}, {"input": {"tree": [1, -1]}, "output": {"max_utility": 1, "min_utility": -1}}, {"input": {"tree": [[10, 5, -6], [2, 7, 5], [0]]}, "output": {"max_utility": 2, "min_utility": 0}}, {"input": {"tree": [[5, 9], [3, 0, -7]]}, "output": {"max_utility": 5, "min_utility": 3}}, {"input": {"tree": [[-9, -10], [-7], [5]]}, "output": {"max_utility": 5, "min_utility": -9}}, {"input": {"tree": [-10]}, "output": {"max_utility": -10, "min_utility": -10}}], "error_log": []}
{"context": "Given a graph represented by its adjacency matrix and a set of colors, determine the color assignment for each vertex such that no two adjacent vertices share the same color. What is the color assignment for each vertex in the graph?\n\nThe input and output requirements are as follows:\n\nInput:\n  `graph` (list of lists of integers): A 2D list representing the adjacency matrix of the graph. Each element `graph[i][j]` is `1` if there is an edge between vertex `i` and vertex `j`, otherwise `0`.\n  `m` (integer): The number of colors available for coloring the graph.\n\nOutput:\n  `return` (list of integers): A list representing the color assignment for each vertex. Each element `return[i]` is the color assigned to vertex `i`. If no valid coloring is possible, the function returns `None`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef graphColoring(graph, m, v, color):\n    if v == len(graph):\n        return color\n    for c in range(1, m + 1):\n        if isSafe(graph, color, c, v):\n            color[v] = c\n            result = graphColoring(graph, m, v + 1, color)\n            if result:\n                return result\n            # backtracking\n            color[v] = 0\n    return None\n\ndef isSafe(graph, color, c, v):\n    for i in range(v):\n        if graph[v][i] == 1 and color[i] == c:\n            return False\n    return True\n\n# main function\ndef main_solution(graph, m):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    v = 0\n    color = [0] * len(graph)  # colors are 1, 2, 3, ..., m\n    result = graphColoring(graph, m, v, color)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random number of vertices (between 3 and 10 for reasonable size)\n    v = random.randint(3, 10)\n    \n    # Generate a random graph (adjacency matrix) with some edges\n    graph = [[0 for _ in range(v)] for _ in range(v)]\n    for i in range(v):\n        for j in range(i + 1, v):\n            if random.random() < 0.3:  # 30% chance of an edge between two vertices\n                graph[i][j] = 1\n                graph[j][i] = 1\n    \n    # Generate a random number of colors (between 2 and 5 for reasonable size)\n    m = random.randint(2, 5)\n    \n    return {'graph': graph, 'm': m}", "io_pairs": [{"input": {"graph": [[0, 0, 0], [0, 0, 0], [0, 0, 0]], "m": 5}, "output": [1, 1, 1]}, {"input": {"graph": [[0, 0, 1], [0, 0, 1], [1, 1, 0]], "m": 2}, "output": [1, 1, 2]}, {"input": {"graph": [[0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0]], "m": 5}, "output": [1, 1, 1, 2]}, {"input": {"graph": [[0, 0, 0], [0, 0, 1], [0, 1, 0]], "m": 2}, "output": [1, 1, 2]}, {"input": {"graph": [[0, 0, 1, 1], [0, 0, 0, 1], [1, 0, 0, 0], [1, 1, 0, 0]], "m": 5}, "output": [1, 1, 2, 2]}, {"input": {"graph": [[0, 0, 1], [0, 0, 0], [1, 0, 0]], "m": 5}, "output": [1, 1, 2]}, {"input": {"graph": [[0, 0, 1], [0, 0, 0], [1, 0, 0]], "m": 4}, "output": [1, 1, 2]}, {"input": {"graph": [[0, 1, 0], [1, 0, 0], [0, 0, 0]], "m": 4}, "output": [1, 2, 1]}, {"input": {"graph": [[0, 1, 1], [1, 0, 1], [1, 1, 0]], "m": 3}, "output": [1, 2, 3]}, {"input": {"graph": [[0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 0], [0, 1, 0, 0]], "m": 2}, "output": [1, 1, 1, 2]}], "error_log": []}
{"context": "In a social networking scenario, users form connections with each other. Given a social graph with a certain number of users and an average number of friendships per user, what is the shortest path from a specified user to the first user in the network?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numUsers` (int): The number of users to be created in the social graph.\n  `avgFriendships` (int): The average number of friendships each user should have.\n  `startingUserID` (int): The ID of the user from whom the shortest path is to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing the shortest path from the starting user to the first user. The key is `\"shortest_path\"` and the value is a list representing the shortest path.", "reference_code": "# import necessary packages\nimport random\nfrom itertools import combinations\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass User:\n    def __init__(self, name):\n        self.name = name\n\nclass SocialGraph:\n    def __init__(self):\n        self.lastID = 0\n        self.users = {}\n        self.friendships = {}\n\n    def addFriendship(self, userID, friendID):\n        \"\"\"\n        Creates a bi-directional friendship\n        \"\"\"\n        if userID == friendID:\n            print(\"WARNING: You cannot be friends with yourself\")\n        elif friendID in self.friendships[userID] or userID in self.friendships[friendID]:\n            print(\"WARNING: Friendship already exists\")\n        else:\n            self.friendships[userID].add(friendID)\n            self.friendships[friendID].add(userID)\n\n    def addUser(self, name):\n        \"\"\"\n        Create a new user with a sequential integer ID\n        \"\"\"\n        self.lastID += 1  # automatically increment the ID to assign the new user\n        self.users[self.lastID] = User(name) \n        self.friendships[self.lastID] = set()\n\n    def bfs(self, starting_vertex, target): \n        visited_bfs = []\n        queue = deque()\n        queue.append([starting_vertex])\n        visited = {}\n        \n        while queue:     \n            path = queue.popleft()\n            last_node = path[-1:][0]\n            if last_node not in visited_bfs:\n                visited[last_node] = path\n                if last_node == target:\n                    return path\n                visited_bfs.append(last_node)\n                for v in self.friendships[last_node]:\n                    new_list = list(path)\n                    new_list.append(v)\n                    queue.append(new_list)\n        return visited\n\n    def populateGraph(self, numUsers, avgFriendships):\n        \"\"\"\n        Takes a number of users and an average number of friendships\n        as arguments\n\n        Creates that number of users and a randomly distributed friendships\n        between those users.\n\n        The number of users must be greater than the average number of friendships.\n        \"\"\"\n        # Reset graph\n        self.lastID = 0\n        self.users = {}\n        self.friendships = {}\n\n        # Add users\n        for i in range(numUsers):\n            self.addUser(f'User {i}')        \n\n        # Create friendship pairs  \n        possible_friendships = list(combinations(range(1, numUsers+1), 2))\n        random.shuffle(possible_friendships)\n        T = int(numUsers/2 * avgFriendships)\n        actual_friendships = possible_friendships[:T]\n\n        for friendship in actual_friendships:\n            self.addFriendship(friendship[0], friendship[1])\n\n    def getAllSocialPaths(self, userID):\n        \"\"\"\n        Takes a user's userID as an argument\n\n        Returns a dictionary containing every user in that user's\n        extended network with the shortest friendship path between them.\n\n        The key is the friend's ID and the value is the path.\n        \"\"\"\n        return self.bfs(userID, self.users[1])\n\n# main function\ndef main_solution(numUsers, avgFriendships, startingUserID):\n    # Convert JSON serializable inputs to original input variables\n    sg = SocialGraph()\n    sg.populateGraph(numUsers, avgFriendships)\n    \n    # Get the shortest path from startingUserID to the first user\n    result = sg.getAllSocialPaths(startingUserID)\n    \n    # Convert the result to JSON serializable output\n    return {\"shortest_path\": result}", "input_generator": "import random\n\ndef input_generator():\n    numUsers = random.randint(5, 20)\n    avgFriendships = random.randint(1, min(5, numUsers - 1))\n    startingUserID = random.randint(1, numUsers)\n    return {\n        \"numUsers\": numUsers,\n        \"avgFriendships\": avgFriendships,\n        \"startingUserID\": startingUserID\n    }", "io_pairs": [{"input": {"numUsers": 15, "avgFriendships": 2, "startingUserID": 10}, "output": {"shortest_path": {"10": [10], "5": [10, 5]}}}, {"input": {"numUsers": 19, "avgFriendships": 2, "startingUserID": 17}, "output": {"shortest_path": {"17": [17]}}}, {"input": {"numUsers": 5, "avgFriendships": 4, "startingUserID": 1}, "output": {"shortest_path": {"1": [1], "2": [1, 2], "3": [1, 3], "4": [1, 4], "5": [1, 5]}}}, {"input": {"numUsers": 10, "avgFriendships": 1, "startingUserID": 10}, "output": {"shortest_path": {"10": [10], "7": [10, 7], "5": [10, 7, 5]}}}, {"input": {"numUsers": 12, "avgFriendships": 1, "startingUserID": 2}, "output": {"shortest_path": {"2": [2]}}}, {"input": {"numUsers": 11, "avgFriendships": 1, "startingUserID": 10}, "output": {"shortest_path": {"10": [10]}}}, {"input": {"numUsers": 16, "avgFriendships": 1, "startingUserID": 14}, "output": {"shortest_path": {"14": [14], "2": [14, 2]}}}, {"input": {"numUsers": 5, "avgFriendships": 1, "startingUserID": 2}, "output": {"shortest_path": {"2": [2], "1": [2, 1], "4": [2, 4]}}}, {"input": {"numUsers": 5, "avgFriendships": 1, "startingUserID": 5}, "output": {"shortest_path": {"5": [5]}}}, {"input": {"numUsers": 11, "avgFriendships": 1, "startingUserID": 2}, "output": {"shortest_path": {"2": [2], "5": [2, 5], "1": [2, 5, 1]}}}], "error_log": []}
{"context": "Given a range of integers from 0 to N, where N is a positive integer, determine how many numbers within this range have an odd periodicity in their continued fraction representation of the square root. The periodicity of a number's square root is defined as the length of the repeating sequence in its continued fraction representation. What is the count of such numbers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): An integer representing the upper limit of the range for which the periodicity of square roots is to be checked.\n\nOutput:\n  `return` (int): An integer representing the count of numbers within the range [0, N] whose square root's periodicity is odd.", "reference_code": "# import necessary packages\nfrom math import sqrt\n\n# all class and function definitions in the code file, if any\ndef periodicity(a):\n    if not a:\n        return 0\n    for i in range(1, len(a) // 2 + 1):\n        if all([a[j:j + i] == a[:i] for j in range(0, min(5, len(a) // i), i)]):\n            return i\n    return 0\n\ndef find_periodicity(N):\n    a0 = int(sqrt(N))\n    tmp = sqrt(N)\n    a = []\n    step = 0\n    while periodicity(a) == 0 or step < 100:\n        tmp = 1 / (tmp % 1) \n        a.append(int(tmp))\n        step += 1\n    return periodicity(a)\n\n# main function\ndef main_solution(N):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    odd = 0\n    for n in range(N + 1):\n        if sqrt(n) % 1 == 0:\n            continue\n        if find_periodicity(n) % 2 == 1:\n            odd += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return odd", "input_generator": "import random\nimport math\n\ndef input_generator():\n    N = random.randint(1, 1000)\n    return {'N': N}", "io_pairs": [{"input": {"N": 561}, "output": 381}, {"input": {"N": 780}, "output": 560}, {"input": {"N": 424}, "output": 270}, {"input": {"N": 491}, "output": 321}, {"input": {"N": 993}, "output": 739}, {"input": {"N": 45}, "output": 16}, {"input": {"N": 13}, "output": 4}, {"input": {"N": 731}, "output": 518}, {"input": {"N": 630}, "output": 433}, {"input": {"N": 1}, "output": 0}], "error_log": []}
{"context": "Given a string of digits, how many distinct prime numbers can be formed by permuting the digits of the string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numbers` (str): A string of digits from which permutations will be generated to check for prime numbers.\n\nOutput:\n  `return` (int): The count of prime numbers that can be formed by permuting the digits of the input string.", "reference_code": "# import necessary packages\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef prime_number(alpha):\n    for i in range(2, alpha):\n        if alpha % i == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(numbers):\n    # Convert the input string to a list of characters\n    numbers = list(numbers)\n    temp = set()\n    for i in range(1, len(numbers) + 1):\n        alpha = permutations(numbers, i)\n        for j in alpha:\n            temp.add(int(''.join(j)))\n\n    count = 0\n    for alpha in temp:\n        if prime_number(alpha) and alpha not in (0, 1):\n            count += 1\n    return count", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    numbers = ''.join(random.choices(string.digits, k=length))\n    return {'numbers': numbers}", "io_pairs": [{"input": {"numbers": "9"}, "output": 0}, {"input": {"numbers": "2"}, "output": 1}, {"input": {"numbers": "3980"}, "output": 11}, {"input": {"numbers": "1520"}, "output": 5}, {"input": {"numbers": "973"}, "output": 10}, {"input": {"numbers": "210"}, "output": 1}, {"input": {"numbers": "069"}, "output": 0}, {"input": {"numbers": "63"}, "output": 1}, {"input": {"numbers": "999"}, "output": 0}, {"input": {"numbers": "54568"}, "output": 1}], "error_log": []}
{"context": "Given a string that may represent a number, determine if the string can be interpreted as a valid numerical value. The string may contain spaces, digits, dots, 'e' or 'E', and signs ('+' or '-'). What is the result of checking if the string `s` represents a valid number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `s` (str): A string representing a potential number. The string can contain spaces, digits, dots, 'e' or 'E', and signs ('+' or '-'). The length of the string is between 1 and 20 characters.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input string `s` represents a valid number.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        # skip blanks at the beginning\n        str_len = len(s)\n        i = 0\n        while i < str_len and s[i] == \" \":\n            i += 1\n        \n        # skip blanks at the end\n        while str_len > 0 and s[str_len - 1] == \" \":\n            str_len -= 1\n        \n        # check for empty string after trimming\n        if i >= str_len:\n            return False\n        \n        # check for sign\n        if s[i] in ['+', '-']:\n            i += 1\n        \n        # check for digits before dot\n        has_digits = False\n        while i < str_len and s[i].isdigit():\n            i += 1\n            has_digits = True\n        \n        # check for dot\n        if i < str_len and s[i] == '.':\n            i += 1\n        \n        # check for digits after dot\n        while i < str_len and s[i].isdigit():\n            i += 1\n            has_digits = True\n        \n        # check for exponent\n        if has_digits and i < str_len and s[i] in ['e', 'E']:\n            i += 1\n            if i < str_len and s[i] in ['+', '-']:\n                i += 1\n            has_digits = False\n            while i < str_len and s[i].isdigit():\n                i += 1\n                has_digits = True\n        \n        return has_digits and i == str_len\n\n# main function\ndef main_solution(s: str) -> bool:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return solution.isNumber(s)", "input_generator": "import random\nimport string\n\ndef input_generator():\n    choices = [\n        # Valid numbers\n        \"123\",\n        \"-123\",\n        \"+123\",\n        \"123.456\",\n        \"-123.456\",\n        \"+123.456\",\n        \"123e10\",\n        \"123E10\",\n        \"123e-10\",\n        \"123E-10\",\n        \"123.456e10\",\n        \"123.456E10\",\n        \"123.456e-10\",\n        \"123.456E-10\",\n        \".123\",\n        \".123e10\",\n        \".123E10\",\n        \".123e-10\",\n        \".123E-10\",\n        \"  123  \",\n        \"  -123.456e-10  \",\n        # Invalid numbers\n        \"abc\",\n        \"123a\",\n        \"e10\",\n        \".\",\n        \"1.2.3\",\n        \"1e2e3\",\n        \"+-123\",\n        \"  \",\n        \"\",\n        \"123e\",\n        \"123e+\",\n        \"123e-\",\n        \"123E\",\n        \"123E+\",\n        \"123E-\",\n    ]\n    \n    # Randomly choose between valid and invalid numbers\n    s = random.choice(choices)\n    \n    # Sometimes add random spaces\n    if random.choice([True, False]):\n        s = ' ' * random.randint(0, 3) + s + ' ' * random.randint(0, 3)\n    \n    return {'s': s}", "io_pairs": [{"input": {"s": "+-123"}, "output": false}, {"input": {"s": "123e+"}, "output": false}, {"input": {"s": " 123E- "}, "output": false}, {"input": {"s": "1.2.3"}, "output": false}, {"input": {"s": "123.456e10"}, "output": true}, {"input": {"s": "e10"}, "output": false}, {"input": {"s": ".123E-10"}, "output": true}, {"input": {"s": "123E"}, "output": false}, {"input": {"s": " e10   "}, "output": false}, {"input": {"s": "     "}, "output": false}], "error_log": []}
{"context": "Given a string consisting of lowercase letters, what are all the possible unique permutations of the string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Generate all permutations of the input string\n    permutations = [''.join(p) for p in itertools.permutations(input_string)]\n    # Convert the list of permutations to a JSON serializable format\n    return permutations", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    input_string = ''.join(random.choice(string.ascii_letters) for _ in range(length))\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "W"}, "output": ["W"]}, {"input": {"input_string": "E"}, "output": ["E"]}, {"input": {"input_string": "J"}, "output": ["J"]}, {"input": {"input_string": "KCf"}, "output": ["KCf", "KfC", "CKf", "CfK", "fKC", "fCK"]}, {"input": {"input_string": "Sg"}, "output": ["Sg", "gS"]}, {"input": {"input_string": "jjI"}, "output": ["jjI", "jIj", "jjI", "jIj", "Ijj", "Ijj"]}, {"input": {"input_string": "KVV"}, "output": ["KVV", "KVV", "VKV", "VVK", "VKV", "VVK"]}, {"input": {"input_string": "YwH"}, "output": ["YwH", "YHw", "wYH", "wHY", "HYw", "HwY"]}, {"input": {"input_string": "kfV"}, "output": ["kfV", "kVf", "fkV", "fVk", "Vkf", "Vfk"]}, {"input": {"input_string": "SEi"}, "output": ["SEi", "SiE", "ESi", "EiS", "iSE", "iES"]}], "error_log": []}
{"context": "Imagine you are a strategist tasked with recruiting an army to maximize its combat power. You have limited resources: food, wood, and gold. Each type of unit in your army requires a specific amount of these resources. Given the constraints on food, wood, and gold, what is the maximum combat power you can achieve and what is the composition of your army?\n\nThe input and output requirements are as follows:\n\nInput:\n  `food_limit` (int): The maximum amount of food available for recruiting the army.\n  `wood_limit` (int): The maximum amount of wood available for recruiting the army.\n  `gold_limit` (int): The maximum amount of gold available for recruiting the army.\n\nOutput:\n  `return` (dict): A dictionary containing the optimal power and the composition of the army.\n    - `optimal_power` (float): The maximum power of the army that can be achieved with the given resources. If no optimal solution is found, this will be `None`.\n    - `army` (dict): A dictionary containing the number of each type of unit in the optimal army.\n      - `swordsmen` (float): The number of swordsmen in the optimal army. If no optimal solution is found, this will be `None`.\n      - `bowmen` (float): The number of bowmen in the optimal army. If no optimal solution is found, this will be `None`.\n      - `horsemen` (float): The number of horsemen in the optimal army. If no optimal solution is found, this will be `None`.", "reference_code": "# import necessary packages\nimport ortools\nfrom ortools.linear_solver import pywraplp\n\n# main function\ndef main_solution(food_limit, wood_limit, gold_limit):\n  # Create a solver using the GLOP backend\n  solver = pywraplp.Solver('Maximize army power', pywraplp.Solver.GLOP_LINEAR_PROGRAMMING)\n\n  # Create the variables we want to optimize, and their range\n  swordsmen = solver.IntVar(0, solver.infinity(), 'swordsmen')\n  bowmen = solver.IntVar(0, solver.infinity(), 'bowmen')\n  horsemen = solver.IntVar(0, solver.infinity(), 'horsemen')\n\n  # Resource constraints\n  solver.Add(swordsmen*60 + bowmen*80 + horsemen*140 <= food_limit) # Food\n  solver.Add(swordsmen*20 + bowmen*10 <= wood_limit) # Wood\n  solver.Add(bowmen*40 + horsemen*100 <= gold_limit) # Gold\n\n  # Objective function: maximize power\n  solver.Maximize(swordsmen*70 + bowmen*95 + horsemen*230)\n\n  # Solve the problem\n  status = solver.Solve()\n\n  # Prepare the output\n  if status == pywraplp.Solver.OPTIMAL:\n    result = {\n      'optimal_power': solver.Objective().Value(),\n      'army': {\n        'swordsmen': swordsmen.solution_value(),\n        'bowmen': bowmen.solution_value(),\n        'horsemen': horsemen.solution_value()\n      }\n    }\n  else:\n    result = {\n      'optimal_power': None,\n      'army': {\n        'swordsmen': None,\n        'bowmen': None,\n        'horsemen': None\n      }\n    }\n\n  return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate random resource limits, ensuring they are reasonable and non-negative\n    food_limit = random.randint(1000, 10000)\n    wood_limit = random.randint(500, 5000)\n    gold_limit = random.randint(500, 5000)\n    \n    return {\n        'food_limit': food_limit,\n        'wood_limit': wood_limit,\n        'gold_limit': gold_limit\n    }", "io_pairs": [{"input": {"food_limit": 7825, "wood_limit": 4195, "gold_limit": 4996}, "output": {"optimal_power": 12459.833333333336, "army": {"swordsmen": 13.843333333333359, "bowmen": 0.0, "horsemen": 49.96}}}, {"input": {"food_limit": 4236, "wood_limit": 1524, "gold_limit": 1538}, "output": {"optimal_power": 5967.333333333334, "army": {"swordsmen": 34.713333333333345, "bowmen": 0.0, "horsemen": 15.379999999999997}}}, {"input": {"food_limit": 6198, "wood_limit": 3516, "gold_limit": 1688}, "output": {"optimal_power": 8356.333333333332, "army": {"swordsmen": 63.913333333333334, "bowmen": 0.0, "horsemen": 16.88}}}, {"input": {"food_limit": 1769, "wood_limit": 1840, "gold_limit": 2446}, "output": {"optimal_power": 2906.2142857142867, "army": {"swordsmen": 0.0, "bowmen": 0.0, "horsemen": 12.63571428571429}}}, {"input": {"food_limit": 6601, "wood_limit": 3690, "gold_limit": 3863}, "output": {"optimal_power": 10276.5, "army": {"swordsmen": 19.88000000000001, "bowmen": 0.0, "horsemen": 38.629999999999995}}}, {"input": {"food_limit": 7366, "wood_limit": 1217, "gold_limit": 2288}, "output": {"optimal_power": 9521.900000000001, "army": {"swordsmen": 60.85000000000001, "bowmen": 0.0, "horsemen": 22.88}}}, {"input": {"food_limit": 8845, "wood_limit": 4000, "gold_limit": 1175}, "output": {"optimal_power": 11102.499999999998, "army": {"swordsmen": 119.99999999999999, "bowmen": 0.0, "horsemen": 11.749999999999998}}}, {"input": {"food_limit": 2803, "wood_limit": 4024, "gold_limit": 3277}, "output": {"optimal_power": 4604.928571428573, "army": {"swordsmen": 0.0, "bowmen": 0.0, "horsemen": 20.02142857142858}}}, {"input": {"food_limit": 1355, "wood_limit": 4296, "gold_limit": 611}, "output": {"optimal_power": 1988.166666666667, "army": {"swordsmen": 8.32666666666667, "bowmen": 0.0, "horsemen": 6.109999999999999}}}, {"input": {"food_limit": 9810, "wood_limit": 4886, "gold_limit": 4716}, "output": {"optimal_power": 14589.000000000002, "army": {"swordsmen": 53.460000000000036, "bowmen": 0.0, "horsemen": 47.16}}}], "error_log": []}
{"context": "Given a grid with `m` rows and `n` columns, a robot starts at the top-left corner (coordinate [0,0]). The robot can move to adjacent cells (up, down, left, right) but cannot move outside the grid or to a cell where the sum of the digits of the row and column indices exceeds `k`. How many cells can the robot reach?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The number of rows in the grid.\n  `n` (int): The number of columns in the grid.\n  `k` (int): The maximum sum of the digits of the row and column indices that the robot can move to.\n\nOutput:\n  `return` (int): The number of cells the robot can reach in the grid.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def movingCount(self, m: int, n: int, k: int) -> int:\n        if m < 1 or n < 1:\n            return 0\n        direction = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        reached = set()\n        queue = [(0, 0)]\n\n        def num_sum(num):\n            res = 0\n            while num > 0:\n                res += (num % 10)\n                num //= 10\n            return res\n\n        while len(queue) > 0:\n            i, j = queue.pop(0)\n            if (i, j) in reached:\n                continue\n            reached.add((i, j))\n            node_list = [(i + x, j + y) for x, y in direction if\n                         0 <= i + x < m and 0 <= j + y < n and\n                         num_sum(i + x) + num_sum(j + y) <= k]\n            queue.extend(node_list)\n\n        return len(reached)\n\n# main function\ndef main_solution(m: int, n: int, k: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.movingCount(m, n, k)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    m = random.randint(1, 100)\n    n = random.randint(1, 100)\n    k = random.randint(0, 20)\n    return {'m': m, 'n': n, 'k': k}", "io_pairs": [{"input": {"m": 22, "n": 60, "k": 12}, "output": 607}, {"input": {"m": 31, "n": 51, "k": 11}, "output": 509}, {"input": {"m": 52, "n": 18, "k": 14}, "output": 745}, {"input": {"m": 16, "n": 61, "k": 7}, "output": 36}, {"input": {"m": 57, "n": 15, "k": 10}, "output": 239}, {"input": {"m": 60, "n": 89, "k": 0}, "output": 1}, {"input": {"m": 90, "n": 30, "k": 6}, "output": 28}, {"input": {"m": 58, "n": 28, "k": 18}, "output": 1527}, {"input": {"m": 96, "n": 10, "k": 7}, "output": 36}, {"input": {"m": 33, "n": 62, "k": 3}, "output": 10}], "error_log": []}
{"context": "Given a natural number, what are all the prime numbers that are less than or equal to this number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `limit` (int): An integer representing the upper limit for generating prime numbers. The function will return all prime numbers less than or equal to this limit.\n\nOutput:\n  `return` (list of int): A list of integers representing all prime numbers less than or equal to the given limit.", "reference_code": "# import necessary packages\nfrom math import sqrt, ceil\n\n# all class and function definitions in the code file, if any\nclass Primes:\n    @staticmethod\n    def stream():\n        yield 2\n        n = 2\n        while True:\n            m = ceil(sqrt(n))\n            fail = False\n            while m >= 2:\n                # not prime number\n                if (n / m) % 1 == 0:\n                    fail = True\n                    break\n                m -= 1\n\n            if fail is False:\n                yield n\n            n += 1\n\n# main function\ndef main_solution(limit):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    prime_list = []\n    for p in Primes.stream():\n        if p > limit:\n            break\n        prime_list.append(p)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return prime_list", "input_generator": "import random\n\ndef input_generator():\n    limit = random.choice([10, 50, 100, 200, 500, 1000])\n    return {'limit': limit}", "io_pairs": [{"input": {"limit": 50}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]}, {"input": {"limit": 10}, "output": [2, 3, 5, 7]}], "error_log": []}
{"context": "Given a dataset with two distinct groups of points, how accurately can a perceptron classify these points after a specified number of training epochs? The dataset consists of `num_samples` points, with `test_percentage` of them reserved for testing. The perceptron uses an initial `learning_rate` and trains for `epochs` iterations. What is the final accuracy of the perceptron on the test set?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_samples` (int): The number of data points to generate for training and testing.\n  `learning_rate` (float): The initial learning rate for the perceptron.\n  `test_percentage` (int): The percentage of data to be used for testing.\n  `epochs` (int): The number of epochs to train the perceptron.\n\nOutput:\n  `return` (dict): A dictionary containing the key `accuracy` with a float value representing the accuracy of the perceptron on the test set.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Perceptron(list):\n    def __init__(self, num_inputs, learning_rate=1.0):\n        self.params = np.random.normal(size=num_inputs)\n        self.bias = np.random.normal()\n        self.learning_rate = learning_rate\n\n    def error(self, guess, correct):\n        return correct - guess\n\n    def activate(self, val, fun='step'):\n        if fun == 'step':\n            return 1 if val >= 0 else 0\n        elif fun == 'tanh':\n            return np.tanh(val)\n\n    def predict(self, x):\n        return self.activate(np.dot(x, self.params) + self.bias)\n\n    def predict_set(self, test_set):\n        errors = 0\n        for x, y in test_set:\n            out = self.predict(x)\n            if out != y:\n                errors += 1\n        return 1 - errors / len(test_set)\n\n    def decision_boundary(self):\n        return ((0, -self.bias / self.params[1]), (-self.bias / self.params[0], 0))\n\n    def train(self, train_set, dev_set, epochs=10):\n        for epoch in range(epochs):\n            np.random.shuffle(train_set)\n            for x, y in train_set:\n                out = self.predict(x)\n                error = self.error(out, y)\n                if error != 0:\n                    self.bias += self.learning_rate * error\n                    for i in range(len(x)):\n                        self.params[i] += self.learning_rate * error * x[i]\n            self.learning_rate *= 0.9\n\n# main function\ndef main_solution(num_samples, learning_rate, test_percentage, epochs):\n    np.random.seed(seed=3)\n    test_size = num_samples // test_percentage\n    train_size = num_samples - test_size\n\n    x_blue = np.random.normal(loc=0, size=num_samples)\n    y_blue = np.random.normal(loc=0, scale=0.5, size=num_samples)\n    x_red = np.random.normal(loc=2, size=num_samples)\n    y_red = np.random.normal(loc=2, scale=0.5, size=num_samples)\n\n    data = list(zip(zip(x_blue, y_blue), [0] * num_samples))\n    data += list(zip(zip(x_red, y_red), [1] * num_samples))\n    np.random.shuffle(data)\n\n    train_set = data[:train_size]\n    test_set = data[train_size:]\n\n    p = Perceptron(2, learning_rate)\n    p.train(train_set, test_set, epochs=epochs)\n\n    accuracy = p.predict_set(test_set)\n    return {\"accuracy\": accuracy}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    num_samples = random.randint(100, 1000)\n    learning_rate = random.uniform(0.01, 1.0)\n    test_percentage = random.randint(5, 20)\n    epochs = random.randint(5, 50)\n    return {\n        \"num_samples\": num_samples,\n        \"learning_rate\": learning_rate,\n        \"test_percentage\": test_percentage,\n        \"epochs\": epochs\n    }", "io_pairs": [{"input": {"num_samples": 483, "learning_rate": 0.34041829161410364, "test_percentage": 9, "epochs": 50}, "output": {"accuracy": 0.9832089552238806}}, {"input": {"num_samples": 744, "learning_rate": 0.9915189345503326, "test_percentage": 15, "epochs": 20}, "output": {"accuracy": 0.9899117276166457}}, {"input": {"num_samples": 186, "learning_rate": 0.8992136241709485, "test_percentage": 8, "epochs": 44}, "output": {"accuracy": 0.9856459330143541}}, {"input": {"num_samples": 402, "learning_rate": 0.2902642015561128, "test_percentage": 19, "epochs": 27}, "output": {"accuracy": 0.9905437352245863}}, {"input": {"num_samples": 203, "learning_rate": 0.5473229906632977, "test_percentage": 5, "epochs": 37}, "output": {"accuracy": 0.9670781893004116}}, {"input": {"num_samples": 380, "learning_rate": 0.24227623563786818, "test_percentage": 13, "epochs": 14}, "output": {"accuracy": 0.9877750611246944}}, {"input": {"num_samples": 168, "learning_rate": 0.48818233564218466, "test_percentage": 15, "epochs": 37}, "output": {"accuracy": 0.9608938547486033}}, {"input": {"num_samples": 549, "learning_rate": 0.44091426705568704, "test_percentage": 12, "epochs": 30}, "output": {"accuracy": 0.9882154882154882}}, {"input": {"num_samples": 285, "learning_rate": 0.658859205569843, "test_percentage": 11, "epochs": 6}, "output": {"accuracy": 0.964516129032258}}, {"input": {"num_samples": 279, "learning_rate": 0.24753486465461716, "test_percentage": 16, "epochs": 35}, "output": {"accuracy": 0.9695945945945946}}], "error_log": []}
{"context": "Given a set of points on a Cartesian plane, what is the simplified polynomial expression that represents the Lagrange interpolation polynomial for these points?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x_points` (list of float): List of x-coordinates of the points.\n  `y_points` (list of float): List of y-coordinates of the points.\nOutput:\n  `return` (str): The simplified polynomial expression in string format.", "reference_code": "# import necessary packages\nfrom sympy import Symbol, simplify\n\n# main function\ndef main_solution(x_points, y_points):\n    \"\"\"\n    This function computes the Lagrange interpolation polynomial for given points.\n    \n    Input:\n    - x_points (list of float): List of x-coordinates of the points.\n    - y_points (list of float): List of y-coordinates of the points.\n    \n    Output:\n    - return (str): The simplified polynomial expression in string format.\n    \"\"\"\n    n = len(x_points)\n    x = Symbol('x')\n    polinomio = 0\n    for k in range(n):\n        prod = 1\n        for i in range(n):\n            if i != k:\n                prod *= (x - x_points[i]) / (x_points[k] - x_points[i])\n        polinomio += prod * y_points[k]\n\n    # Convert the polynomial to a string before returning\n    return str(simplify(polinomio))", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(2, 5)  # Generate between 2 to 5 points\n    x_points = sorted(random.sample(range(-10, 11), n))  # Ensure unique and sorted x points\n    y_points = [random.uniform(-10.0, 10.0) for _ in range(n)]\n    return {'x_points': x_points, 'y_points': y_points}", "io_pairs": [{"input": {"x_points": [-9, 2, 8], "y_points": [-6.402909396214433, -4.388184127857722, -8.729772246693637]}, "output": "-0.0533385213166982*x**2 - 0.190212806639004*x - 3.79440442931292"}, {"input": {"x_points": [-10, -7, -2, -1], "y_points": [-5.936041117804636, 9.558699218074622, -2.8326122321161806, -6.002096928503208]}, "output": "0.0933548036138809*x**3 + 0.818344301747331*x**2 - 1.3679354164422*x - 8.09502184307886"}, {"input": {"x_points": [-7, 2], "y_points": [9.828033243056929, 5.111887106964597]}, "output": "6.15991958165178 - 0.524016237343592*x"}, {"input": {"x_points": [-10, -4], "y_points": [-6.383477819817733, 3.0031612459056785]}, "output": "1.56443984428724*x + 9.26092062305462"}, {"input": {"x_points": [1, 6], "y_points": [-0.40955252772027784, 1.7880112738412208]}, "output": "0.4395127603123*x - 0.849065288032578"}, {"input": {"x_points": [-3, 7], "y_points": [-9.592463304919951, 1.3407266632691304]}, "output": "1.09331899681891*x - 6.31250631446323"}, {"input": {"x_points": [-5, -4, 10], "y_points": [-0.7354292472449728, -2.445974272425479, 5.2800707096170445]}, "output": "0.150827025402712*x**2 - 0.353101796556094*x - 6.27161386509325"}, {"input": {"x_points": [-9, -7, -1], "y_points": [-4.918217320396825, -7.779803068601656, 0.07967862141970095]}, "output": "0.342588311138247*x**2 + 4.05062010410953*x + 3.78771041439099"}, {"input": {"x_points": [-7, -5, 10], "y_points": [2.328721869085408, 3.1604129473738922, -0.7788724563227838]}, "output": "-0.0399096803563149*x**2 - 0.0630706251315371*x + 3.84280183062408"}, {"input": {"x_points": [-8, -5], "y_points": [-4.748989034518793, -0.22655318006343528]}, "output": "1.50747861815179*x + 7.31083991069549"}], "error_log": []}
{"context": "Given a set of data points represented by their x and y coordinates, and a specific x-coordinate, what is the interpolated y-value at that x-coordinate using the Newton interpolation method?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x_array` (list of float): A list of x-coordinates of the data points.\n  `y_array` (list of float): A list of y-coordinates of the data points.\n  `x_value` (float): The x-coordinate at which the interpolation polynomial should be evaluated.\n\nOutput:\n  `return` (float): The interpolated y-value corresponding to the given `x_value`.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom operator import mul\nfrom functools import reduce\n\n# all class and function definitions in the code file, if any\ndef prod(iterable):\n    return reduce(mul, iterable, 1)\n\ndef newton_interpol(x_array, y_array):\n    # Check that x_array and y_array are the same size and store the size of x_array\n    if (x_array.size) != y_array.size:\n        raise ValueError(\"x-array and y-array are not the same size\")\n    n = x_array.size\n\n    A = np.zeros((n, n))\n\n    # Calculation of The Coefficients Matrix #\n\n    # Initialize the first column of the matrix\n    for i in range(n):\n        A[i, 0] = y_array[i]\n    # Calculate the remaining entries\n    for j in range(1, n):\n        for i in range(n - j):\n            A[i, j] = (A[i + 1, j - 1] - A[i, j - 1]) / (x_array[i + j] - x_array[i])\n\n    # End --- Calculation of The Coefficients Matrix #\n\n    # Construct the interpolation polynom\n    def interpolation_polynom(x):\n        total = A[0, 0]\n        for j in range(1, n):\n            total += A[0, j] * prod(x - x_array[i] for i in range(j))\n\n        return total\n\n    return interpolation_polynom\n\n# main function\ndef main_solution(x_array, y_array, x_value):\n    # Convert JSON serializable inputs to numpy arrays\n    x_array = np.array(x_array, dtype=float)\n    y_array = np.array(y_array, dtype=float)\n    x_value = float(x_value)\n\n    # Get the interpolation polynomial\n    interpolation_polynom = newton_interpol(x_array, y_array)\n\n    # Evaluate the polynomial at the given x_value\n    result = interpolation_polynom(x_value)\n\n    # Convert the result to a JSON serializable output\n    return float(result)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random number of points between 2 and 10\n    n = random.randint(2, 10)\n    \n    # Generate random x values, ensuring they are unique and sorted\n    x_array = np.sort(np.random.uniform(-10, 10, n))\n    \n    # Generate corresponding y values\n    y_array = np.random.uniform(-100, 100, n)\n    \n    # Generate a random x_value within a reasonable range\n    x_value = random.uniform(min(x_array) - 5, max(x_array) + 5)\n    \n    return {\n        'x_array': x_array.tolist(),\n        'y_array': y_array.tolist(),\n        'x_value': x_value\n    }", "io_pairs": [{"input": {"x_array": [-4.510272059374854, -2.1576369078855695, -0.27290815282435155, 2.924650237993635, 5.073813223355579, 5.094671949252945, 8.161762182336197], "y_array": [54.173743285369056, 23.756051753785542, -15.33761805262614, 42.97112591054463, 46.61664206497491, 35.13821479801385, 19.74723993311376], "x_value": -0.5255506374557246}, "output": 44.767173770799054}, {"input": {"x_array": [-7.181833182323071, -6.313814414663641, 0.7738816763245495, 1.260939482718939, 4.293666447040227, 6.707379162710033, 7.225801464712443], "y_array": [95.04963645686144, -68.32182795881442, 62.457603740178115, 6.955788650583841, -9.715306269016978, -72.08703211595977, -2.055924755730018], "x_value": 8.144319667674715}, "output": 482.80212026377967}, {"input": {"x_array": [-1.8441145384554574, 0.16081664969556542, 0.4311865135511894, 9.68560471972808, 9.877322925093793], "y_array": [64.3075591043204, 64.9537092624152, -9.22768322105911, -3.7171851563877, -87.58375142507266], "x_value": 9.126159468174759}, "output": 135.32497191634752}, {"input": {"x_array": [-8.348203204924294, -8.297529944791863, -5.852973548881007, -1.353559503950784, 2.493636586020866, 6.636459290484169], "y_array": [-2.7181136207229883, 48.35345961962682, 69.96616176917968, 89.94405933763983, 71.8615560017447, -1.435269177301052], "x_value": 5.441932200860828}, "output": -1281.0139940451118}, {"input": {"x_array": [-3.6379784460382396, -2.8132363778740244, 8.675223094134576], "y_array": [-82.63044722147448, 14.977656695683606, -68.37451520947901], "x_value": -4.473784065283893}, "output": -195.70563363105228}, {"input": {"x_array": [-9.997842614678609, -8.410915695794266, -8.179444974304618, -5.7377645810359486, 0.18424613965023795, 0.8629365207251709, 9.870121125098521], "y_array": [-55.4612154794051, 75.6623381675928, -35.85642482081593, -19.275290120681603, 39.85573509702289, 97.13747624790429, 67.8407583361221], "x_value": 14.034179732725379}, "output": -653680.9886510228}, {"input": {"x_array": [-5.000810067252144, 6.94152976291349, 9.65065748336541], "y_array": [-88.9659936431439, 20.411889194984553, 12.431626071889852], "x_value": 11.126099577295559}, "output": 2.984608018300058}, {"input": {"x_array": [-7.621189984828803, -7.356811090685936, -5.090424211077343, -2.4700753428927458, -2.0165985577199645, -1.3849055908977714, 5.096408601088346], "y_array": [69.86039854120921, 4.116734016235313, 57.77878639508802, -12.02239275455004, -56.78605489728468, -15.659327907103489, -51.874404134811016], "x_value": -8.325788993080508}, "output": 268.56379299848277}, {"input": {"x_array": [-7.689835079611871, -6.477131537949825, -5.533770489875609, -4.928270898234399, 4.51444912452555, 8.500857625812454], "y_array": [-59.96093711540287, 31.421498310903075, 89.85905713753709, 97.32484123459452, 12.669223244145172, -39.852971636760294], "x_value": 5.810182476587393}, "output": 439.947380657582}, {"input": {"x_array": [-7.579019132643454, 1.8615899386030499, 2.5717644906668333, 5.9690825067508335], "y_array": [41.92617057749871, 88.79603405581886, 52.88889168985793, 15.372675779263062], "x_value": -3.486031787348086}, "output": 329.66681696762817}], "error_log": []}
{"context": "Given a string of characters, how can we determine the encoded value using arithmetic encoding?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string of characters to be encoded. The string should contain only ASCII characters.\n\nOutput:\n  `return` (dict): A dictionary containing the encoded value of the input string. The dictionary has one key:\n    - `encoded_value` (float): The encoded value of the input string.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\nclass Element:\n    \"\"\"\n    \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0445\u0440\u0430\u043d\u0438\u0442 \u0441\u0438\u043c\u0432\u043e\u043b \u0438 \u0435\u0433\u043e \u0447\u0430\u0441\u0442\u043e\u0442\u0443\n    \"\"\"\n    def __init__(self, value, char):\n        self.value = value\n        self.char = char\n\nclass Segment:\n    \"\"\"\n    \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0445\u0440\u0430\u043d\u0438\u0442 \u0441\u0438\u043c\u0432\u043e\u043b \u0438 \u0435\u0433\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\n    \"\"\"\n    def __init__(self, right, left, char):\n        self.RightBorder = right\n        self.LeftBorder = left\n        self.char = char\n\ndef makeSegments(probs):\n    top = 1.0 #\u0412\u0435\u0440\u0445\u043d\u044f\u044f \u0433\u0440\u0430\u043d\u0438\u0446\u0430\n    bottom = 0.0 #\u041d\u0438\u0436\u043d\u044f\u044f \u0433\u0440\u0430\u043d\u0438\u0446\u0430\n    segment_list = [] #\u0421\u043f\u0438\u0441\u043e\u043a \u0441\u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0437\u0445 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u043e\u0432\n\n    for i in probs:\n        top_segment = top\n        bottom_segment = top - i.value\n        segment_list.append(Segment(top_segment, bottom_segment, i.char))\n        top = bottom_segment\n\n    return segment_list\n\ndef arithmetic_encode(segments, inputStr):\n    top = float(1)\n    bottom = float(0)\n\n    for i in range(len(inputStr)):\n        for j in segments:\n            if j.char == inputStr[i]:\n                new_top = recalculation(bottom, top-bottom, j.RightBorder)\n                new_bottom = recalculation(bottom, top-bottom, j.LeftBorder)\n                top, bottom = new_top, new_bottom\n\n    return (top + bottom) / 2\n\ndef recalculation(oldLow, old_range, Symbol_segment_range):\n    return oldLow + old_range * Symbol_segment_range\n\ndef process_string(s):\n    freq_list = []\n    added_elements = []\n\n    for ch in s:\n        if ch not in added_elements:\n            freq_list.append(Element(s.count(ch) / len(s), ch))\n            added_elements.append(ch)\n\n    freq_list = sorted(freq_list, key=lambda x: x.value, reverse=True)\n    return freq_list, s\n\n# main function\ndef main_solution(input_string):\n    # Convert input string to a list of Elements with their frequencies\n    probabilities, string_from_cli = process_string(input_string)\n    \n    # Create segments from the probabilities\n    segments = makeSegments(probabilities)\n    \n    # Encode the input string\n    encoded_value = arithmetic_encode(segments, string_from_cli)\n    \n    # Return the encoded value\n    return {\"encoded_value\": encoded_value}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random string with varying length (1 to 20 characters)\n    length = random.randint(1, 20)\n    chars = random.choices(string.ascii_letters + string.digits, k=length)\n    input_string = ''.join(chars)\n    \n    return {\"input_string\": input_string}", "io_pairs": [{"input": {"input_string": "cRU3kFHMKhcNhF"}, "output": {"encoded_value": 0.9332225651660138}}, {"input": {"input_string": "bEDwxtp2m"}, "output": {"encoded_value": 0.9843750016535651}}, {"input": {"input_string": "A"}, "output": {"encoded_value": 0.5}}, {"input": {"input_string": "Wb8RQGtHraM2iTrZ"}, "output": {"encoded_value": 0.8622222223589455}}, {"input": {"input_string": "qWEulZWEz"}, "output": {"encoded_value": 0.5465604195239142}}, {"input": {"input_string": "bAQDmoGSB"}, "output": {"encoded_value": 0.9843750016535651}}, {"input": {"input_string": "mmYp74K2GJKix"}, "output": {"encoded_value": 0.9919464329873904}}, {"input": {"input_string": "cA5z7B7"}, "output": {"encoded_value": 0.6392125244219186}}, {"input": {"input_string": "fcend81gVlgnUndmgQRO"}, "output": {"encoded_value": 0.5762432863149409}}, {"input": {"input_string": "JnCqaPdVYYoX7"}, "output": {"encoded_value": 0.8263888898946079}}], "error_log": []}
{"context": "Given a partially filled Tic Tac Toe board, what is the optimal next move for the current player to maximize their chances of winning or forcing a draw?\n\nThe input and output requirements are as follows:\n\nInput:\n- `board` (list of lists): A 3x3 matrix representing the Tic Tac Toe board. Each cell can be 'X', 'O', or `None`.\n\nOutput:\n- `return` (tuple): A tuple representing the optimal move `(i, j)` where `i` and `j` are integers between 0 and 2. If the game is over, returns `None`.", "reference_code": "# import necessary packages\nimport copy\nimport random\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    count = sum(cell is not EMPTY for row in board for cell in row)\n    return O if count % 2 != 0 else X\n\n# Function to get all possible actions\ndef actions(board):\n    return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}\n\n# Function to get the result of an action\ndef result(board, action):\n    if terminal(board):\n        raise ValueError(\"Game over.\")\n    elif action not in actions(board):\n        raise ValueError(\"Invalid action.\")\n    else:\n        p = player(board)\n        result_board = copy.deepcopy(board)\n        (i, j) = action\n        result_board[i][j] = p\n    return result_board\n\n# Function to determine the winner\ndef winner(board):\n    lines = [\n        [(0, 0), (0, 1), (0, 2)],\n        [(1, 0), (1, 1), (1, 2)],\n        [(2, 0), (2, 1), (2, 2)],\n        [(0, 0), (1, 0), (2, 0)],\n        [(0, 1), (1, 1), (2, 1)],\n        [(0, 2), (1, 2), (2, 2)],\n        [(0, 0), (1, 1), (2, 2)],\n        [(0, 2), (1, 1), (2, 0)],\n    ]\n    for line in lines:\n        (a, b, c) = line\n        if board[a[0]][a[1]] == board[b[0]][b[1]] == board[c[0]][c[1]] != EMPTY:\n            return board[a[0]][a[1]]\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or all(cell is not EMPTY for row in board for cell in row)\n\n# Function to get the utility of the board\ndef utility(board):\n    w = winner(board)\n    if w == X:\n        return 1\n    elif w == O:\n        return -1\n    else:\n        return 0\n\n# Main function to solve the problem\ndef main_solution(board):\n    \"\"\"\n    Determines the optimal next move for the current player on the given board.\n    \n    Input:\n    board (list of lists): A 3x3 matrix representing the Tic Tac Toe board. Each cell can be 'X', 'O', or None.\n    \n    Output:\n    tuple: A tuple representing the optimal move (i, j) where i and j are integers between 0 and 2.\n    \"\"\"\n    if terminal(board):\n        return None\n    return minimax(board)\n\n# Function to determine the optimal move using the minimax algorithm\ndef minimax(board):\n    p = player(board)\n    if p == X:\n        v = float(\"-inf\")\n        move = None\n        for action in actions(board):\n            minValueResult = minValue(result(board, action))\n            if minValueResult > v:\n                v = minValueResult\n                move = action\n    elif p == O:\n        v = float(\"inf\")\n        move = None\n        for action in actions(board):\n            maxValueResult = maxValue(result(board, action))\n            if maxValueResult < v:\n                v = maxValueResult\n                move = action\n    return move\n\n# Helper function for the minimax algorithm\ndef maxValue(board):\n    if terminal(board):\n        return utility(board)\n    v = float(\"-inf\")\n    for action in actions(board):\n        v = max(v, minValue(result(board, action)))\n    return v\n\n# Helper function for the minimax algorithm\ndef minValue(board):\n    if terminal(board):\n        return utility(board)\n    v = float(\"inf\")\n    for action in actions(board):\n        v = min(v, maxValue(result(board, action)))\n    return v", "input_generator": "import random\n\ndef input_generator():\n    board = [[None, None, None], [None, None, None], [None, None, None]]\n    moves = random.randint(0, 8)\n    current_player = 'X'\n    for _ in range(moves):\n        possible_actions = [(i, j) for i in range(3) for j in range(3) if board[i][j] is None]\n        if not possible_actions:\n            break\n        action = random.choice(possible_actions)\n        board[action[0]][action[1]] = current_player\n        current_player = 'O' if current_player == 'X' else 'X'\n    return {'board': board}", "io_pairs": [{"input": {"board": [[null, "X", null], [null, null, null], [null, null, null]]}, "output": [2, 1]}, {"input": {"board": [[null, null, null], [null, null, null], [null, null, null]]}, "output": [0, 1]}, {"input": {"board": [["X", null, null], [null, "X", "O"], [null, null, null]]}, "output": [0, 1]}, {"input": {"board": [[null, null, null], [null, null, "X"], [null, "O", null]]}, "output": [1, 1]}, {"input": {"board": [["O", null, "X"], ["X", "X", "O"], ["O", "O", "X"]]}, "output": [0, 1]}, {"input": {"board": [[null, null, null], ["X", null, null], [null, "X", "O"]]}, "output": [0, 2]}, {"input": {"board": [["X", null, null], [null, null, null], [null, null, null]]}, "output": [1, 1]}, {"input": {"board": [["X", "X", "O"], ["O", "X", "X"], ["O", null, "O"]]}, "output": [2, 1]}, {"input": {"board": [[null, "X", null], [null, null, "O"], ["X", "X", "O"]]}, "output": [0, 2]}, {"input": {"board": [["O", "X", "X"], ["X", null, "O"], ["X", "O", "O"]]}, "output": [1, 1]}], "error_log": []}
{"context": "Given a set of circuit instructions, what is the value of a specific wire after evaluating the circuit? The instructions define various gates and direct assignments that manipulate the values of different wires.\n\nThe input and output requirements are as follows:\n\nInput:\n  `lines` (list of strings): A list of strings where each string represents a line of instructions for the circuit. Each line follows a specific format that defines a gate or a direct assignment.\n  `wire` (string): The name of the wire whose value is to be determined. It should be a string that appears in the right-hand side of one of the lines in the `lines` list.\n\nOutput:\n  `return` (integer): The value of the specified wire after evaluating the circuit based on the provided instructions.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef shortNOT(val):\n    return (~(val & 65535) & 65535)\n\ndef shortLSHIFT(val, shift):\n    return ((val & 65535) << shift) & 65535\n\ndef shortRSHIFT(val, shift):\n    return ((val & 65535) >> shift) & 65535\n\ndef shortAND(val1, val2):\n    return (val1 & 65535) & (val2 & 65535)\n\ndef shortOR(val1, val2):\n    return (val1 & 65535) | (val2 & 65535)\n\ndef findVal(lines, wires, wire):\n    # If the wire was already calculated, just return that\n    if wire in wires:\n        return wires[wire]\n        \n    # If it's a digit, just return that\n    if wire.isdigit():\n        return int(wire)\n\n    # Go through every line to find the gate that\n    # contains the wire we're looking for. Then,\n    # recursively find the value for each wire on\n    # that gate.\n    for line in lines:\n        words = line.split()\n\n        # Simple assignment\n        if words[1] == '->':\n            if words[2] != wire:\n                continue\n\n            wires[wire] = findVal(lines, wires, words[0])\n            return wires[wire]\n\n        elif words[0] == 'NOT':\n            if words[3] != wire:\n                continue\n\n            wires[wire] = shortNOT(findVal(lines, wires, words[1]))\n            return wires[wire]\n\n        else:\n            if words[4] != wire:\n                continue\n\n            lhs = findVal(lines, wires, words[0])\n            rhs = findVal(lines, wires, words[2])\n\n            if words[1] == 'AND':\n                wires[wire] = shortAND(lhs, rhs)\n            elif words[1] == 'OR':\n                wires[wire] = shortOR(lhs, rhs)\n            elif words[1] == 'LSHIFT':\n                wires[wire] = shortLSHIFT(lhs, rhs)\n            elif words[1] == 'RSHIFT':\n                wires[wire] = shortRSHIFT(lhs, rhs)\n\n            return wires[wire]\n\n    # If we get here, we're boned :) \n    return None\n\n# main function\ndef main_solution(lines, wire):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    wires = {}\n    result = findVal(lines, wires, wire)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    gates = ['AND', 'OR', 'LSHIFT', 'RSHIFT']\n    wires = ['x', 'y', 'z', 'a', 'b', 'c', 'd', 'e', 'f', 'g']\n    lines = []\n    \n    # Generate some simple assignments\n    for i in range(random.randint(2, 5)):\n        val = random.randint(0, 65535)\n        wire = random.choice(wires)\n        lines.append(f\"{val} -> {wire}\")\n    \n    # Generate some NOT gates\n    for i in range(random.randint(1, 3)):\n        wire_in = random.choice(wires)\n        wire_out = random.choice([w for w in wires if w != wire_in])\n        lines.append(f\"NOT {wire_in} -> {wire_out}\")\n    \n    # Generate some binary gates\n    for i in range(random.randint(2, 4)):\n        gate = random.choice(gates)\n        wire1 = random.choice(wires)\n        wire2 = random.choice(wires)\n        wire_out = random.choice([w for w in wires if w != wire1 and w != wire2])\n        lines.append(f\"{wire1} {gate} {wire2} -> {wire_out}\")\n    \n    # Choose a random wire to query\n    wire_query = random.choice(wires)\n    \n    return {\n        \"lines\": lines,\n        \"wire\": wire_query\n    }", "io_pairs": [{"input": {"lines": ["13137 -> y", "28056 -> g", "NOT d -> e", "x LSHIFT y -> d", "f LSHIFT z -> e", "z AND d -> b"], "wire": "g"}, "output": 28056}, {"input": {"lines": ["61406 -> a", "29977 -> x", "22681 -> x", "NOT c -> y", "b RSHIFT y -> f", "a RSHIFT g -> z", "a OR y -> g", "g RSHIFT b -> c"], "wire": "a"}, "output": 61406}, {"input": {"lines": ["19520 -> e", "332 -> b", "NOT x -> b", "NOT b -> z", "b LSHIFT c -> e", "f AND a -> b"], "wire": "e"}, "output": 19520}, {"input": {"lines": ["31136 -> d", "46196 -> c", "31249 -> f", "NOT g -> y", "NOT z -> c", "f RSHIFT c -> d", "d RSHIFT x -> b"], "wire": "c"}, "output": 46196}, {"input": {"lines": ["22173 -> x", "56631 -> f", "51502 -> a", "6897 -> g", "NOT d -> z", "NOT g -> e", "a RSHIFT e -> d", "f AND f -> x"], "wire": "d"}, "output": 0}, {"input": {"lines": ["6268 -> e", "28999 -> b", "55142 -> c", "20115 -> f", "NOT a -> z", "NOT a -> y", "e LSHIFT b -> d", "b AND y -> f"], "wire": "c"}, "output": 55142}, {"input": {"lines": ["36128 -> e", "27676 -> b", "NOT c -> g", "g RSHIFT c -> d", "c OR a -> f"], "wire": "b"}, "output": 27676}, {"input": {"lines": ["19244 -> b", "99 -> g", "59715 -> c", "44427 -> b", "NOT g -> y", "y OR d -> b", "c RSHIFT c -> y", "a AND x -> c"], "wire": "g"}, "output": 99}, {"input": {"lines": ["64229 -> f", "14791 -> z", "NOT g -> z", "g OR d -> f", "b OR f -> a", "y OR y -> d", "x RSHIFT e -> c"], "wire": "f"}, "output": 64229}, {"input": {"lines": ["26591 -> a", "47336 -> x", "11909 -> g", "16409 -> z", "NOT e -> c", "g LSHIFT g -> d", "z OR y -> g", "a RSHIFT g -> b"], "wire": "z"}, "output": 16409}], "error_log": []}
{"context": "Given a number, determine its binary and base 10 representations, check if these representations are palindromic, and verify if the number is prime. What are the results of these checks for a randomly generated number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number` (int): The integer number to be analyzed.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `number` (int): The input number.\n    - `base2_representation` (str): The binary representation of the input number.\n    - `base10_representation` (str): The base 10 representation of the input number.\n    - `is_palindrome_base2` (bool): True if the binary representation of the number is a palindrome, False otherwise.\n    - `is_palindrome_base10` (bool): True if the base 10 representation of the number is a palindrome, False otherwise.\n    - `is_prime_number` (bool): True if the number is prime, False otherwise.", "reference_code": "# import necessary packages\nfrom bisect import bisect_left\nfrom math import sqrt\nfrom array import array\nimport random\n\n# all class and function definitions in the code file, if any\nclass IsPrime():\n    \"\"\"Determine whether a given number is prime or compound.\"\"\"\n\n    primes = []\n\n    def __init__(self):\n        self.primes = [2, 3]\n\n    def __call__(self, n):\n        \"\"\"Return True if n is prime; False otherwise.\"\"\"\n        if n <= 1:\n            return False\n        if int(n) != n:\n            return False\n        x = find_ge(self.primes, n)\n        if x == n:\n            return True\n        retval = self._check(n)\n        if retval is not None:\n            return retval\n        while not find_ge(self.primes, sqrt(n)):\n            old_last = len(self.primes) - 1\n            self.extend(self.primes[-1]**2)\n            retval = self._check(n, self.primes[old_last:])\n            if retval is not None:\n                return retval\n\n    def _check(self, n, primes=None):\n        if primes is None:\n            primes = self.primes\n        for prime in primes:\n            if prime == n:\n                return True\n            elif n % prime == 0:\n                return False\n            elif prime > sqrt(n):\n                return True\n\n    def extend(self, n):\n        \"\"\"Extend the list of known primes to at least n.\"\"\"\n        lastPrime = self.primes[-1]\n        i = lastPrime - (lastPrime % 6) - 6\n        while self.primes[-1] <= n:\n            i += 6\n            if self.__call__(i - 1):\n                self.primes.append(i - 1)\n            if self.__call__(i + 1):\n                self.primes.append(i + 1)\n\n# Convenience instance of IsPrime() suitable for importing like a function.\nis_prime = IsPrime()\n\ndef find_ge(a, x):\n    \"\"\"Find whether an item greater than or equal to x occurs in a.\"\"\"\n    i = bisect_left(a, x)\n    if i != len(a):\n        return a[i]\n    return False\n\ndef isPalindrome(obj):\n    \"\"\"Determine whether a given object is palindromic or not.\"\"\"\n    return str(obj) == str(obj)[::-1]\n\ndef toBase10(num):\n    \"\"\"Represent an integer in base ten, as a string.\"\"\"\n    return str(int(num))\n\ndef toBase2(num):\n    \"\"\"Represent an integer in base two, as a string.\"\"\"\n    return \"{0:b}\".format(int(num))\n\ndef fib(n):\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    if (n < 1): return 0\n    if (n == 1 or n == 2): return n\n    thisfib = 0\n    i = 3\n    prevprev = 1\n    prev = 2\n    while (i <= n):\n        thisfib = prevprev + prev\n        prevprev = prev\n        prev = thisfib\n        i = i + 1\n    return thisfib\n\ndef factorize(n):\n    i=1\n    factors = array('L')\n    while i*i <= n:\n        if n%i == 0:\n            factors.append(i)\n        i += 1\n    if factors[-1]**2 == n:\n        for i in factors[-2::-1]:\n            factors.append(n/i)\n    else:\n        for i in factors[-1::-1]:\n            factors.append(n/i)\n    return factors\n\n# main function\ndef main_solution(number):\n    # Convert the number to base 2 and base 10\n    base2_representation = toBase2(number)\n    base10_representation = toBase10(number)\n    \n    # Check if the number is a palindrome in both base 2 and base 10\n    is_palindrome_base2 = isPalindrome(base2_representation)\n    is_palindrome_base10 = isPalindrome(base10_representation)\n    \n    # Check if the number is prime\n    is_prime_number = is_prime(number)\n    \n    # Return the results as a dictionary\n    return {\n        \"number\": number,\n        \"base2_representation\": base2_representation,\n        \"base10_representation\": base10_representation,\n        \"is_palindrome_base2\": is_palindrome_base2,\n        \"is_palindrome_base10\": is_palindrome_base10,\n        \"is_prime_number\": is_prime_number\n    }", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random number with different probabilities for different ranges\n    # to ensure variety in test cases (small, medium, large numbers, primes, palindromes, etc.)\n    choice = random.random()\n    if choice < 0.3:\n        # Small numbers (1-100)\n        number = random.randint(1, 100)\n    elif choice < 0.6:\n        # Medium numbers (100-10000)\n        number = random.randint(100, 10000)\n    elif choice < 0.8:\n        # Large numbers (10000-100000)\n        number = random.randint(10000, 100000)\n    else:\n        # Special cases: primes or palindromes\n        if random.random() < 0.5:\n            # Known primes (from a small list)\n            primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n            number = random.choice(primes)\n        else:\n            # Palindromic numbers\n            num_str = str(random.randint(1, 1000))\n            number = int(num_str + num_str[::-1])\n    \n    return {\"number\": number}", "io_pairs": [{"input": {"number": 96}, "output": {"number": 96, "base2_representation": "1100000", "base10_representation": "96", "is_palindrome_base2": false, "is_palindrome_base10": false, "is_prime_number": false}}, {"input": {"number": 285582}, "output": {"number": 285582, "base2_representation": "1000101101110001110", "base10_representation": "285582", "is_palindrome_base2": false, "is_palindrome_base10": true, "is_prime_number": false}}, {"input": {"number": 4096}, "output": {"number": 4096, "base2_representation": "1000000000000", "base10_representation": "4096", "is_palindrome_base2": false, "is_palindrome_base10": false, "is_prime_number": false}}, {"input": {"number": 7439}, "output": {"number": 7439, "base2_representation": "1110100001111", "base10_representation": "7439", "is_palindrome_base2": false, "is_palindrome_base10": false, "is_prime_number": false}}, {"input": {"number": 19}, "output": {"number": 19, "base2_representation": "10011", "base10_representation": "19", "is_palindrome_base2": false, "is_palindrome_base10": false, "is_prime_number": true}}, {"input": {"number": 9977}, "output": {"number": 9977, "base2_representation": "10011011111001", "base10_representation": "9977", "is_palindrome_base2": false, "is_palindrome_base10": false, "is_prime_number": false}}, {"input": {"number": 508805}, "output": {"number": 508805, "base2_representation": "1111100001110000101", "base10_representation": "508805", "is_palindrome_base2": false, "is_palindrome_base10": true, "is_prime_number": false}}, {"input": {"number": 54920}, "output": {"number": 54920, "base2_representation": "1101011010001000", "base10_representation": "54920", "is_palindrome_base2": false, "is_palindrome_base10": false, "is_prime_number": false}}, {"input": {"number": 4664}, "output": {"number": 4664, "base2_representation": "1001000111000", "base10_representation": "4664", "is_palindrome_base2": false, "is_palindrome_base10": true, "is_prime_number": false}}, {"input": {"number": 367763}, "output": {"number": 367763, "base2_representation": "1011001110010010011", "base10_representation": "367763", "is_palindrome_base2": false, "is_palindrome_base10": true, "is_prime_number": false}}], "error_log": []}
{"context": "Given a linear system represented by the matrix A and the vector b, what is the solution vector x obtained by applying the Gradient Descent method with a specified maximum number of iterations and tolerance for convergence?\n\nThe input and output requirements are as follows:\n\nInput:\n  `A_values` (list of lists of floats): The values of the matrix A. Each inner list represents a row of the matrix.\n  `b_values` (list of floats): The values of the vector b.\n  `max_iters` (int): The maximum number of iterations for the gradient descent algorithm.\n  `tol` (float): The tolerance for convergence. The algorithm stops if the relative difference between consecutive estimates of x is less than this value.\n\nOutput:\n  `return` (list of floats): The solution vector x, obtained by solving the linear system Ax = b using the Gradient Descent method.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(A_values, b_values, max_iters, tol):\n    \"\"\"\n    Solves the linear system Ax = b using the Gradient Descent method.\n\n    Parameters:\n    - A_values (list of lists): The values of the matrix A.\n    - b_values (list): The values of the vector b.\n    - max_iters (int): The maximum number of iterations.\n    - tol (float): The tolerance for convergence.\n\n    Returns:\n    - list: The solution vector x.\n    \"\"\"\n    # Convert JSON serializable inputs to numpy arrays\n    A = np.array(A_values)\n    b = np.array(b_values)\n\n    # Initialize the solution vector x\n    n = A.shape[0]\n    x = np.random.randn(n)\n\n    # Gradient Descent algorithm\n    for i in range(max_iters):\n        d = b - A @ x  # Compute gradient with respect to x.\n        alpha = (d.T @ d) / (d.T @ A @ d)  # Compute optimal step size.\n        x_new = x + alpha * d  # Compute new estimate of x.\n        if np.allclose(x_new, x, rtol=tol):\n            break\n        x = x_new\n\n    # Convert the solution vector x to a list for JSON serialization\n    return x.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the size of the matrix (2x2 to 5x5)\n    n = random.randint(2, 5)\n    \n    # Generate a symmetric positive definite matrix A\n    A = np.random.rand(n, n)\n    A = A @ A.T  # Ensure positive definiteness\n    A_values = A.tolist()\n    \n    # Generate a random vector b\n    b_values = np.random.rand(n).tolist()\n    \n    # Randomly choose max_iters between 100 and 1000\n    max_iters = random.randint(100, 1000)\n    \n    # Randomly choose tol between 1e-6 and 1e-4\n    tol = random.uniform(1e-6, 1e-4)\n    \n    return {\n        'A_values': A_values,\n        'b_values': b_values,\n        'max_iters': max_iters,\n        'tol': tol\n    }", "io_pairs": [{"input": {"A_values": [[0.5045316231700683, 0.5221996281884062], [0.5221996281884062, 0.5522289625496855]], "b_values": [0.437374870620281, 0.19772970860087502], "max_iters": 893, "tol": 1.3357058556472035e-05}, "output": [23.332896343745457, -21.706460364598623]}, {"input": {"A_values": [[1.0664620431074763, 0.5174108210753944], [0.5174108210753944, 0.2561846362492538]], "b_values": [0.1653217878609583, 0.7452476666524168], "max_iters": 202, "tol": 7.65163546732408e-05}, "output": [-59.44179345448866, 122.7251233930366]}, {"input": {"A_values": [[0.6677856721551587, 0.6382351777280124], [0.6382351777280124, 0.9389128594928485]], "b_values": [0.4749189977359445, 0.9213496401141861], "max_iters": 672, "tol": 5.416738077213634e-05}, "output": [-0.6470796269859372, 1.4211387682342647]}, {"input": {"A_values": [[0.16393358111449005, 0.23318909684502206], [0.23318909684502206, 0.3904524517021226]], "b_values": [0.6198185094542846, 0.8901132920841274], "max_iters": 711, "tol": 4.142621554967311e-05}, "output": [3.5764223421944266, 0.1437568121600445]}, {"input": {"A_values": [[0.28110772954616897, 0.23336886847056434], [0.23336886847056434, 0.2320553354212364]], "b_values": [0.4624436669783666, 0.7894886479178493], "max_iters": 193, "tol": 1.4978610811887616e-05}, "output": [-7.141308916035714, 10.583639008252279]}, {"input": {"A_values": [[0.5575108937789786, 0.38877785694897077], [0.38877785694897077, 0.272388604493017]], "b_values": [0.8719837188815706, 0.45559452479875784], "max_iters": 894, "tol": 9.716290224677431e-05}, "output": [84.41351831893658, -118.82342809666628]}, {"input": {"A_values": [[1.2639252600193847, 0.8392897747879131], [0.8392897747879131, 0.6735022112223857]], "b_values": [0.8416880503205926, 0.19903280960187975], "max_iters": 711, "tol": 1.700468698404731e-05}, "output": [2.7226984323412933, -3.097315568958775]}, {"input": {"A_values": [[0.7208888597889036, 0.6372039277353032], [0.6372039277353032, 0.876701067420523]], "b_values": [0.5719872064235791, 0.9374628616333276], "max_iters": 686, "tol": 9.91467641879493e-05}, "output": [-0.4243206604311269, 1.377657586129226]}, {"input": {"A_values": [[0.27809411970684084, 0.4209534421352028], [0.4209534421352028, 1.1593359282428681]], "b_values": [0.5025557595595698, 0.8753402306257693], "max_iters": 523, "tol": 7.143271276625046e-05}, "output": [1.474842134597102, 0.21951642190108508]}, {"input": {"A_values": [[1.1758681030070597, 0.4563219874620142], [0.4563219874620142, 0.9119871655507751]], "b_values": [0.7920672130638728, 0.041328907729610176], "max_iters": 202, "tol": 1.9117206297937948e-05}, "output": [0.8140806600720307, -0.3620113273424085]}], "error_log": []}
{"context": "Given a dataset with three input features and their corresponding target values, how can we estimate the parameter theta using gradient descent to fit a linear model? Specifically, what is the final value of theta after performing a specified number of iterations with a given learning rate?\n\nThe input and output requirements are as follows:\n\nInput:\n  `X` (list of lists of floats): A 3x1 matrix representing the input features.\n  `Y` (list of floats): A 3x1 matrix representing the target values.\n  `alpha` (float): The learning rate for the gradient descent algorithm.\n  `iterations` (int): The number of iterations for the gradient descent algorithm.\n\nOutput:\n  `return` (float): The final value of theta after performing gradient descent.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom numpy.linalg import inv\nfrom numpy import dot, mat\n\n# main function\ndef main_solution(X, Y, alpha, iterations):\n    # Convert JSON serializable inputs to numpy arrays\n    X = np.array(X)\n    Y = np.array(Y)\n    \n    # Initialize theta\n    theta = 1.0\n    \n    # Gradient descent\n    for _ in range(iterations):\n        theta = theta + np.sum(alpha * (Y - dot(X, theta)) * X.reshape(1, 3)) / 3.0\n    \n    # Convert theta to a JSON serializable output\n    return float(theta)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate random X with 3 features, values between -10 and 10\n    X = [random.uniform(-10, 10) for _ in range(3)]\n    # Generate random Y, value between -20 and 20\n    Y = random.uniform(-20, 20)\n    # Generate random alpha between 0.001 and 0.1\n    alpha = random.uniform(0.001, 0.1)\n    # Generate random iterations between 100 and 1000\n    iterations = random.randint(100, 1000)\n    \n    return {\n        'X': X,\n        'Y': Y,\n        'alpha': alpha,\n        'iterations': iterations\n    }", "io_pairs": [{"input": {"X": [-2.2422940446423834, 3.264952083003683, 7.089344464972925], "Y": 11.425260559207405, "alpha": 0.09067934554657386, "iterations": 936}, "output": 1.404633129572159}, {"input": {"X": [0.8957919026374412, 3.8708532712674106, -0.4615326151852628], "Y": 7.508598896236268, "alpha": 0.015523477516359813, "iterations": 221}, "output": 2.0204664704377713}, {"input": {"X": [-2.283877669069156, 0.7238955134041554, 2.2439500439046007], "Y": -2.76581886770726, "alpha": 0.03705655315682619, "iterations": 836}, "output": -0.17555964234533225}, {"input": {"X": [5.882219522378245, 5.335291795411916, 3.971845600606617], "Y": 2.245307714247428, "alpha": 0.09528301042099849, "iterations": 184}, "output": 2.354347522176944e+32}, {"input": {"X": [4.211876618236213, 0.775529007253656, 8.120885411818012], "Y": -10.901516024157733, "alpha": 0.015206313235174723, "iterations": 493}, "output": -1.6953378194938244}, {"input": {"X": [-7.0212652373741875, 5.936207142551428, 0.5322931028035782], "Y": 8.567655156526929, "alpha": 0.09776673473097047, "iterations": 347}, "output": -3.7594020850181934e+85}, {"input": {"X": [-0.39303231815075, -8.691724014484691, 9.104906603882828], "Y": -12.469032585932268, "alpha": 0.044310794425569455, "iterations": 445}, "output": -8.540321661135738e+56}, {"input": {"X": [-2.6993103788099333, 7.553318177176617, -7.663299834684429], "Y": -0.24527849803335044, "alpha": 0.02815747100229002, "iterations": 572}, "output": 0.005599143668955584}, {"input": {"X": [-8.808359524780464, 2.111918889351678, -1.2275304475098707], "Y": 10.525048203499484, "alpha": 0.05741031443650331, "iterations": 510}, "output": -0.9981562596932463}, {"input": {"X": [1.5569479584000856, 7.2706648138834105, 8.514274126719908], "Y": 2.116574172999858, "alpha": 0.07104054945966531, "iterations": 466}, "output": 5.384779251571759e+142}], "error_log": []}
{"context": "Given a square matrix, what is the inverse of the matrix? The matrix is represented as a list of lists, where each element is a number. If the matrix is singular, the inverse does not exist.\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of float or int): A square matrix represented as a list of lists. Each element in the matrix should be a float or int.\n\nOutput:\n  `return` (list of lists of float): The inverse of the matrix, represented as a list of lists of floats. If the matrix is singular (i.e., its determinant is zero), the function returns `None`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef determinant(matrix):\n    \"\"\" matrix is a list of lists whose determinant should be calculated\n        If matrix is not a list of lists, raise a TypeError with the message:\n        \"matrix must be a list of lists\"\n        If matrix is not square, raise a ValueError with the message:\n        \"matrix must be a square matrix\"\n        The list [[]] represents a 0x0 matrix\n        Returns: the determinant of matrix\n    \"\"\"\n    if (type(matrix) != list or len(matrix) == 0 or\n       not all([type(m) == list for m in matrix])):\n        raise TypeError(\"matrix must be a list of lists\")\n    lm = len(matrix)\n    if lm == 1 and len(matrix[0]) == 0:\n        return 1\n    if not all([len(n) == lm for n in matrix]):\n        raise ValueError(\"matrix must be a square matrix\")\n    if lm == 1 and len(matrix[0]) == 1:\n        return matrix[0][0]\n\n    # for 2x2 matrix minimun case\n\n    if lm == 2:\n        a = matrix[0][0]\n        b = matrix[0][1]\n        c = matrix[1][0]\n        d = matrix[1][1]\n        det = a*d - c*b\n        return det\n\n    # for general case --recursive\n\n    det = 0\n    for i, k in enumerate(matrix[0]):\n        new_m = [[m[n] for n in range(len(m)) if n != i]for m in matrix[1:]]\n        det += k * (-1)**(i) * determinant(new_m)\n\n    return det\n\n\ndef adjugate(matrix):\n    \"\"\" calculates the adjugate matrix of a matrix:\n\n        matrix is a list of lists whose minor matrix should be calculated\n        If matrix is not a list of lists, raise a TypeError with the message:\n        \"matrix must be a list of lists\"\n\n        If matrix is not square or is empty, raise a ValueError with\n        the message: \"matrix must be a non-empty square matrix\"\n\n        Returns: the adjugate matrix of matrix\n    \"\"\"\n    if (type(matrix) != list or len(matrix) == 0 or\n       not all([type(m) == list for m in matrix])):\n        raise TypeError(\"matrix must be a list of lists\")\n    lm = len(matrix)\n    if lm == 1 and len(matrix[0]) == 0:\n        raise ValueError(\"matrix must be a non-empty square matrix\")\n    if not all([len(n) == lm for n in matrix]):\n        raise ValueError(\"matrix must be a non-empty square matrix\")\n    if lm == 1 and len(matrix[0]) == 1:\n        return [[1]]\n    new_matrix = []\n    for i in range(lm):\n        sub_new_matrix = []\n        for j in range(lm):\n\n            # set sub matrix -- colums-rows swap\n\n            temp_m = [[matrix[n][m] for n in range(lm) if (n != j and m != i)]\n                      for m in range(lm)]\n\n            # delete empty nodes\n\n            temp_m = [m for m in temp_m if len(m) == lm-1]\n\n            # calculate and add determinant , multiplied by factor\n\n            sub_new_matrix.append((-1)**(i+j)*determinant(temp_m))\n\n        new_matrix.append(sub_new_matrix)\n\n    return new_matrix\n\n\ndef inverse(matrix):\n    \"\"\" calculates the inverse of a matrix\n        matrix is a list of lists whose inverse should be calculated\n\n        If matrix is not a list of lists, raise a TypeError with the message:\n            \"matrix must be a list of lists\"\n\n        If matrix is not square or is empty, raise a ValueError\n            with the message: \"matrix must be a non-empty square matrix\"\n\n        Returns: the inverse of matrix, or None if matrix is singular\n    \"\"\"\n    if (type(matrix) != list or len(matrix) == 0 or\n       not all([type(m) == list for m in matrix])):\n        raise TypeError(\"matrix must be a list of lists\")\n    lm = len(matrix)\n    if lm == 1 and len(matrix[0]) == 0:\n        raise ValueError(\"matrix must be a non-empty square matrix\")\n    if not all([len(n) == lm for n in matrix]):\n        raise ValueError(\"matrix must be a non-empty square matrix\")\n    if lm == 1 and len(matrix[0]) == 1:\n        return [[1/(matrix[0][0])]]\n\n    # get determinant\n\n    det = determinant(matrix)\n    if det == 0:\n        return None\n\n    # calculate adjugate matrix\n\n    adj_matrix = adjugate(matrix)\n\n    # divide by determinant\n\n    inv_matrix = [[x/det for x in sub] for sub in adj_matrix]\n\n    return inv_matrix\n\n# main function\ndef main_solution(matrix):\n    \"\"\"\n    Calculates the inverse of a given square matrix.\n\n    Args:\n    matrix (list of lists of float or int): A square matrix represented as a list of lists.\n\n    Returns:\n    list of lists of float: The inverse of the matrix, or None if the matrix is singular.\n    \"\"\"\n    # Convert input to the required format\n    matrix = [[float(x) for x in row] for row in matrix]\n    \n    # Calculate the inverse of the matrix\n    inv_matrix = inverse(matrix)\n    \n    # Convert the output to JSON serializable format\n    if inv_matrix is None:\n        return None\n    return [[float(x) for x in row] for row in inv_matrix]", "input_generator": "import random\n\ndef input_generator():\n    size = random.choice([1, 2, 3, 4, 5])\n    matrix = []\n    for _ in range(size):\n        row = [random.randint(-10, 10) for _ in range(size)]\n        matrix.append(row)\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[2]]}, "output": [[0.5]]}, {"input": {"matrix": [[6]]}, "output": [[0.16666666666666666]]}, {"input": {"matrix": [[1, 2, 2], [2, -3, -5], [-3, 8, -4]]}, "output": [[0.4642857142857143, 0.21428571428571427, -0.03571428571428571], [0.20535714285714285, 0.017857142857142856, 0.08035714285714286], [0.0625, -0.125, -0.0625]]}, {"input": {"matrix": [[-10]]}, "output": [[-0.1]]}, {"input": {"matrix": [[-5, -9], [-4, 7]]}, "output": [[-0.09859154929577464, -0.1267605633802817], [-0.056338028169014086, 0.07042253521126761]]}, {"input": {"matrix": [[10, -4, 5], [5, -7, 0], [2, -3, 3]]}, "output": [[0.13548387096774195, 0.01935483870967742, -0.22580645161290322], [0.0967741935483871, -0.12903225806451613, -0.16129032258064516], [0.0064516129032258064, -0.14193548387096774, 0.3225806451612903]]}, {"input": {"matrix": [[-6]]}, "output": [[-0.16666666666666666]]}, {"input": {"matrix": [[-1]]}, "output": [[-1.0]]}, {"input": {"matrix": [[-2, 3, 2], [1, 3, -10], [10, 10, -9]]}, "output": [[-0.15904139433551198, -0.10239651416122005, 0.0784313725490196], [0.19825708061002179, 0.004357298474945534, 0.0392156862745098], [0.04357298474945534, -0.10893246187363835, 0.0196078431372549]]}, {"input": {"matrix": [[-1, 9, -8], [0, 1, -5], [5, -9, 7]]}, "output": [[0.2585034013605442, -0.061224489795918366, 0.25170068027210885], [0.17006802721088435, -0.22448979591836735, 0.034013605442176874], [0.034013605442176874, -0.24489795918367346, 0.006802721088435374]]}], "error_log": []}
{"context": "Given a function \\( f(x) = \\ln(1 + \\sqrt{|x|}) \\), you are tasked with estimating the integral of this function over a specified interval \\([a, b]\\) using the Monte Carlo method. The goal is to determine the fraction of 95% confidence intervals that contain the actual integral value, as well as the sample size required to achieve a confidence interval with a half-length of 0.1. What is the fraction of 95% confidence intervals that contain the actual integral value, and what is the required sample size for a half-length of 0.1?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The lower bound of the interval for the integral.\n  `b` (float): The upper bound of the interval for the integral.\n  `n` (int): The number of random samples to generate for the Monte Carlo method.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `fraction_CI` (float): The fraction of 95% confidence intervals that contain the actual integral value.\n    - `sample_size_n` (int): The sample size needed for a half-length of 0.1 in the confidence interval.\n    - `actual_val` (float): The actual integral value calculated using the `scipy.integrate.quad` function.\n    - `lower_CI` (float): The lower bound of the 95% confidence interval.\n    - `upper_CI` (float): The upper bound of the 95% confidence interval.", "reference_code": "# import necessary packages\nimport math\nimport random\nimport statistics as s\nfrom scipy import stats\nfrom scipy import integrate\n\n# Define function\ndef f(x):\n    return math.log(1 + math.sqrt(abs(x)))\n\n# main function\ndef main_solution(a, b, n):\n    # Convert inputs to appropriate types if necessary\n    a = float(a)\n    b = float(b)\n    n = int(n)\n    \n    # Store variable in list\n    xs = []\n    ys = []\n    fraction = 0\n    \n    # Generate random x, and compute y\n    for k in range(100):\n        for i in range(n):\n            u = random.uniform(0, 1)\n            x = a + (b - a) * u\n            xs.append(x)\n            y = (b - a) * f(x)\n            ys.append(y)\n        \n        sample_mean = s.mean(ys)\n        sample_stdev = s.stdev(ys)\n        \n        # Calculate 95% confidence interval\n        t_quantile = stats.t.ppf(1 - 0.025, 99)\n        Hn0 = t_quantile * sample_stdev / math.sqrt(n)\n        lower_CI = sample_mean - Hn0\n        upper_CI = sample_mean + Hn0\n        \n        # Calculate sample size needed for 0.1 half length\n        sample_size_n = math.ceil(n * math.pow(Hn0 / 0.1, 2))\n        \n        # Calculate actual integral value\n        actual_val = integrate.quad(lambda x: f(x), a, b)[0]\n        \n        # Check if actual value is within the confidence interval\n        if lower_CI <= actual_val <= upper_CI:\n            fraction += 1\n    \n    # Calculate the fraction of 95% CI containing the actual value\n    fraction_CI = fraction / 100\n    \n    # Return the result as a dictionary\n    return {\n        \"fraction_CI\": fraction_CI,\n        \"sample_size_n\": sample_size_n,\n        \"actual_val\": actual_val,\n        \"lower_CI\": lower_CI,\n        \"upper_CI\": upper_CI\n    }", "input_generator": "import random\n\ndef input_generator():\n    a = random.uniform(-10, 10)\n    b = random.uniform(a + 0.1, a + 20)  # Ensure b > a\n    n = random.randint(10, 1000)\n    return {\n        \"a\": a,\n        \"b\": b,\n        \"n\": n\n    }", "io_pairs": [{"input": {"a": -2.299188641493995, "b": -2.14430690966361, "n": 139}, "output": {"fraction_CI": 1.0, "sample_size_n": 1, "actual_val": 0.14132280715155607, "lower_CI": 0.14116244834600264, "upper_CI": 0.14147528709961568}}, {"input": {"a": -2.0592338822539924, "b": 4.930237007762155, "n": 36}, "output": {"fraction_CI": 1.0, "sample_size_n": 1155, "actual_val": 5.699795270158206, "lower_CI": 5.147600006181787, "upper_CI": 6.28034078465964}}, {"input": {"a": 2.8726729315317368, "b": 17.870223240020504, "n": 209}, "output": {"fraction_CI": 1.0, "sample_size_n": 2827, "actual_val": 21.07879131684702, "lower_CI": 20.714133578191884, "upper_CI": 21.449647334051605}}, {"input": {"a": -3.542648195155122, "b": 10.872468688455616, "n": 130}, "output": {"fraction_CI": 1.0, "sample_size_n": 7529, "actual_val": 15.057528278981188, "lower_CI": 14.252014306190537, "upper_CI": 15.774020422855996}}, {"input": {"a": 5.374553973993015, "b": 22.038718166055585, "n": 712}, "output": {"fraction_CI": 1.0, "sample_size_n": 2451, "actual_val": 25.39408917976775, "lower_CI": 25.20998169019308, "upper_CI": 25.581007461085814}}, {"input": {"a": -9.225781584546791, "b": 5.468670404567474, "n": 171}, "output": {"fraction_CI": 1.0, "sample_size_n": 6149, "actual_val": 14.895696564948675, "lower_CI": 14.31121695637813, "upper_CI": 15.510458524930309}}, {"input": {"a": -7.405378856918472, "b": 10.194308793752562, "n": 48}, "output": {"fraction_CI": 1.0, "sample_size_n": 9224, "actual_val": 18.710348141916135, "lower_CI": 17.26956374655508, "upper_CI": 20.042027250429314}}, {"input": {"a": 7.676706077106989, "b": 14.526356258203002, "n": 89}, "output": {"fraction_CI": 1.0, "sample_size_n": 91, "actual_val": 10.003719694409664, "lower_CI": 9.901346295599357, "upper_CI": 10.10280503425125}}, {"input": {"a": 4.440471023234711, "b": 4.741725473414173, "n": 100}, "output": {"fraction_CI": 0.99, "sample_size_n": 1, "actual_val": 0.34494418792749953, "lower_CI": 0.3446030971425269, "upper_CI": 0.34537676886724056}}, {"input": {"a": -1.8263125077335012, "b": 11.427419242094087, "n": 752}, "output": {"fraction_CI": 1.0, "sample_size_n": 7304, "actual_val": 14.214371635911075, "lower_CI": 13.912089563870602, "upper_CI": 14.535354398718535}}], "error_log": []}
{"context": "Given a position in the Fibonacci sequence, what is the corresponding Fibonacci number at that position?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The position in the Fibonacci sequence for which the Fibonacci number is to be calculated.\nOutput:\n  `return` (int): The Fibonacci number at position `n` in the sequence.", "reference_code": "# import necessary packages\nfrom math import sqrt\nimport random\n\n# all class and function definitions in the code file, if any\ndef fexp1(b, e):\n    if(e == 0):\n        return 1\n    elif(e == 1):\n        return b\n    elif(e < 0):\n        e = -e\n        b = 1/b\n    acc = 1.0\n    while(e>1):\n        if(e % 2 == 0):\n            e //= 2\n        else:\n            acc *= b\n            e = (e-1)//2\n        b *= b\n    return acc * b\n\ndef biner_formula(n):\n    s = sqrt(5)\n    p = (1 + s) / 2 # phi\n    m = (fexp1(p, n) + fexp1(1-p, n)) / s\n    return round(m)\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = biner_formula(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(-100, 100)\n    return {'n': n}", "io_pairs": [{"input": {"n": -15}, "output": -610}, {"input": {"n": -47}, "output": -2971215073}, {"input": {"n": -52}, "output": 32951280099}, {"input": {"n": -5}, "output": -5}, {"input": {"n": -35}, "output": -9227465}, {"input": {"n": 61}, "output": 2504730781961}, {"input": {"n": -90}, "output": 2880067194370801152}, {"input": {"n": -51}, "output": -20365011074}, {"input": {"n": -81}, "output": -37889062373143728}, {"input": {"n": -22}, "output": 17711}], "error_log": []}
{"context": "Given a binary tree, determine if it is symmetric around its center. A tree is symmetric if the left subtree is a mirror reflection of the right subtree. What is the result of checking the symmetry of the given binary tree structure?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (str): A JSON string representing the structure of the binary tree. Each node is represented as a dictionary with keys `\"val\"` (int), `\"left\"` (dict or null), and `\"right\"` (dict or null).\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetric.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isMirror(self, t1: TreeNode, t2: TreeNode):\n        if t1 is None and t2 is None:\n            return True\n        if t1 is None or t2 is None:\n            return False\n        return (t1.val == t2.val) and self.isMirror(t1.right, t2.left) and self.isMirror(t1.left, t2.right)\n\n    def isSymmetric(self, root: TreeNode):\n        return self.isMirror(root, root)\n\n# main function\ndef main_solution(tree_structure: str):\n    # Convert the JSON serializable input to the original input variables\n    tree_dict = json.loads(tree_structure)\n    \n    def build_tree(node_dict):\n        if not node_dict:\n            return None\n        root = TreeNode(node_dict['val'])\n        root.left = build_tree(node_dict['left'])\n        root.right = build_tree(node_dict['right'])\n        return root\n    \n    root = build_tree(tree_dict)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution()\n    result = solution.isSymmetric(root)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import json\nimport random\n\ndef input_generator():\n    def generate_random_tree(depth):\n        if depth == 0 or random.random() < 0.3:\n            return None\n        val = random.randint(1, 100)\n        left = generate_random_tree(depth - 1)\n        right = generate_random_tree(depth - 1)\n        return {'val': val, 'left': left, 'right': right}\n    \n    def generate_symmetric_tree(depth):\n        if depth == 0 or random.random() < 0.3:\n            return None\n        val = random.randint(1, 100)\n        subtree = generate_symmetric_tree(depth - 1)\n        return {'val': val, 'left': subtree, 'right': subtree}\n    \n    # Randomly decide whether to generate a symmetric or asymmetric tree\n    if random.random() < 0.5:\n        tree = generate_symmetric_tree(random.randint(2, 4))\n    else:\n        tree = generate_random_tree(random.randint(2, 4))\n    \n    return {'tree_structure': json.dumps(tree)}", "io_pairs": [{"input": {"tree_structure": "null"}, "output": true}, {"input": {"tree_structure": "{\"val\": 91, \"left\": null, \"right\": {\"val\": 90, \"left\": null, \"right\": null}}"}, "output": false}, {"input": {"tree_structure": "{\"val\": 89, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 45, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 71, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 97, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 66, \"left\": null, \"right\": {\"val\": 78, \"left\": null, \"right\": null}}"}, "output": false}, {"input": {"tree_structure": "{\"val\": 80, \"left\": {\"val\": 33, \"left\": null, \"right\": null}, \"right\": null}"}, "output": false}, {"input": {"tree_structure": "{\"val\": 63, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 91, \"left\": null, \"right\": null}"}, "output": true}], "error_log": []}
{"context": "Given a Tic Tac Toe board in a certain state, and a mode of play (either random or smart computer move), what is the optimal next move for the computer to make? The board is represented as a list of strings, where each string can be 'X', 'O', or '', and the mode of play is indicated by a string '1' for random move or '2' for a smart move using the minimax algorithm.\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_layout` (list of strings): A list representing the current state of the Tic Tac Toe board. Each element in the list is a string ('X', 'O', or '') representing the state of a cell. The list has 9 elements corresponding to the 9 cells of the board.\n  `radio_button` (string): A string representing the mode of the game. Possible values are '1' for random computer move and '2' for smart computer move using the minimax algorithm.\n\nOutput:\n  `return` (dictionary): A dictionary containing the next move for the computer. The dictionary has a single key \"next_move\" which maps to another dictionary with keys \"row\" and \"column\" representing the row and column indices of the next move.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef get_matrix_board(board_layout):\n    board = [[], [], []]\n    for i in range(len(board_layout)):\n        # converts the visual board to a matrix\n        board[i // 3].append(board_layout[i])\n    return board\n\ndef empty_cells(board):\n    # returns a indexes list of the empty cells\n    return [(row, column) for row in range(3) for column in range(3) if board[row][column] == '']\n\ndef minimax(board, min_max):\n    \"\"\"Computes all possible ways to proceed from the current state and selects the optimal way.\"\"\"\n    result = win_draw(board)\n    if result != 2:\n        return result, None\n    maximum = -1\n    minimum = 1\n    best_index = (0, 0)\n    for index in empty_cells(board):\n        new_board = [i.copy() for i in board]\n        # puts in the board X or O according the turn\n        new_board[index[0]][index[1]] = 'O' if min_max is True else 'X'\n        # the recursive step\n        result = minimax(new_board, not min_max)[0]\n        # computer turn\n        if min_max is True:\n            # improvement of the algorithm for saving unnecessary steps\n            if result == 1:\n                return 1, index\n            # Finds the maximum result out of the possible ways and its index (one step from the current board)\n            if maximum <= result:\n                maximum = result\n                best_index = index\n        # player turn\n        else:\n            # improvement of the algorithm for saving unnecessary steps\n            if result == -1:\n                return -1, index\n            # Finds the minimum result out of the possible ways and its index (one step from the current board)\n            if minimum >= result:\n                minimum = result\n                best_index = index\n    # returns the result and the optimal index\n    return (maximum, best_index) if min_max is True else (minimum, best_index)\n\ndef win_draw(board):\n    # checks win\n    for i in range(3):\n        # checks rows\n        if board[i][0] == board[i][1] == board[i][2]:\n            if board[i][0] != '':\n                return 1 if board[i][0] == 'O' else -1 if board[i][0] == 'X' else 2\n        # checks columns\n        if board[0][i] == board[1][i] == board[2][i]:\n            if board[0][i] != '':\n                return 1 if board[0][i] == 'O' else -1 if board[0][i] == 'X' else 2\n        # checks diagonals\n        if (board[0][0] == board[1][1] == board[2][2]) or (board[2][0] == board[1][1] == board[0][2]):\n            if board[1][1] != '':\n                return 1 if board[1][1] == 'O' else -1 if board[1][1] == 'X' else 2\n    # checks draw\n    return 0 if '' not in [board[i][j] for i in range(3) for j in range(3)] else 2\n\n# main function\ndef main_solution(board_layout, radio_button):\n    # Convert the board_layout to a matrix\n    current_board = get_matrix_board(board_layout)\n    \n    # Determine the next move based on the radio_button value\n    if radio_button == '1':\n        # Random step\n        index = random.choice(empty_cells(current_board))\n    elif radio_button == '2':\n        # Smart step (minimax algorithm)\n        index = minimax(current_board, True)[1]\n    else:\n        return {\"error\": \"Invalid radio_button value\"}\n    \n    # Convert the index to a JSON serializable format\n    row, column = index\n    return {\"next_move\": {\"row\": row, \"column\": column}}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random board layout with some empty cells and some filled with 'X' or 'O'\n    choices = ['X', 'O', '']\n    board_layout = [random.choice(choices) for _ in range(9)]\n    \n    # Ensure at least one empty cell exists\n    if '' not in board_layout:\n        board_layout[random.randint(0, 8)] = ''\n    \n    # Randomly choose between '1' (random step) and '2' (smart step)\n    radio_button = random.choice(['1', '2'])\n    \n    return {\n        \"board_layout\": board_layout,\n        \"radio_button\": radio_button\n    }", "io_pairs": [{"input": {"board_layout": ["", "O", "X", "X", "", "O", "O", "O", ""], "radio_button": "2"}, "output": {"next_move": {"row": 0, "column": 0}}}, {"input": {"board_layout": ["", "", "O", "X", "", "X", "O", "X", "O"], "radio_button": "2"}, "output": {"next_move": {"row": 1, "column": 1}}}, {"input": {"board_layout": ["X", "X", "", "", "X", "O", "O", "", ""], "radio_button": "2"}, "output": {"next_move": {"row": 2, "column": 2}}}, {"input": {"board_layout": ["", "O", "", "X", "O", "", "", "", "O"], "radio_button": "2"}, "output": {"next_move": {"row": 0, "column": 0}}}, {"input": {"board_layout": ["O", "O", "X", "O", "O", "X", "", "O", "X"], "radio_button": "1"}, "output": {"next_move": {"row": 2, "column": 0}}}, {"input": {"board_layout": ["O", "", "O", "X", "", "X", "X", "X", "X"], "radio_button": "1"}, "output": {"next_move": {"row": 0, "column": 1}}}, {"input": {"board_layout": ["O", "X", "X", "X", "X", "", "", "X", "X"], "radio_button": "1"}, "output": {"next_move": {"row": 1, "column": 2}}}, {"input": {"board_layout": ["O", "", "X", "", "", "O", "", "", "X"], "radio_button": "1"}, "output": {"next_move": {"row": 2, "column": 0}}}, {"input": {"board_layout": ["X", "O", "X", "", "O", "", "O", "O", "O"], "radio_button": "1"}, "output": {"next_move": {"row": 1, "column": 2}}}, {"input": {"board_layout": ["O", "X", "", "X", "X", "X", "O", "O", "O"], "radio_button": "1"}, "output": {"next_move": {"row": 0, "column": 2}}}], "error_log": []}
{"context": "In a microbiology lab, three types of bacteria (estafilococo, salmonela, and coli) are grown in a test tube with three different types of food. The quantities of each type of food placed in the test tube are known. Given the consumption rates of each type of food by the bacteria, what are the populations of each type of bacteria, and which type of bacteria has the smallest population?\n\nThe input and output requirements are as follows:\n\nInput:\n  `food_quantities` (list of floats): A list of three float values representing the quantities of three types of food placed in a test tube. The order of the food types is assumed to be consistent with the consumption matrix.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `estafilococo` (float): The population of the estafilococo bacteria, rounded to one decimal place.\n    - `salmonela` (float): The population of the salmonela bacteria, rounded to one decimal place.\n    - `coli` (float): The population of the coli bacteria, rounded to one decimal place.\n    - `min_bacteria` (str): The type of bacteria with the smallest population among the three.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(food_quantities):\n    # Convert the input list to a numpy array and transpose it\n    a = np.array(food_quantities).T\n    \n    # Define the consumption matrix\n    c = np.array([[2, 1, 4], [1, 2, 0], [2, 3, 2]])\n    \n    # Solve the system to find the population of each bacteria type\n    p = np.dot(np.linalg.inv(c), a)\n    \n    # Round the results to one decimal place\n    p_rounded = np.round(p, 1)\n    \n    # Determine the bacteria with the smallest population\n    min_index = np.argmin(p_rounded)\n    bacteria_types = [\"estafilococo\", \"salmonela\", \"coli\"]\n    min_bacteria = bacteria_types[min_index]\n    \n    # Prepare the output dictionary\n    result = {\n        \"estafilococo\": p_rounded[0].item(),\n        \"salmonela\": p_rounded[1].item(),\n        \"coli\": p_rounded[2].item(),\n        \"min_bacteria\": min_bacteria\n    }\n    \n    return result", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate random populations for the bacteria types (positive values)\n    p_estafilococo = random.uniform(1.0, 10.0)\n    p_salmonela = random.uniform(1.0, 10.0)\n    p_coli = random.uniform(1.0, 10.0)\n    p = np.array([p_estafilococo, p_salmonela, p_coli])\n    \n    # Define the consumption matrix\n    c = np.array([[2, 1, 4], [1, 2, 0], [2, 3, 2]])\n    \n    # Calculate the food quantities\n    a = np.dot(c, p)\n    \n    # Round to one decimal place to match the main_solution's precision\n    food_quantities = np.round(a, 1).tolist()\n    \n    return {\"food_quantities\": food_quantities}", "io_pairs": [{"input": {"food_quantities": [50.2, 13.3, 39.6]}, "output": {"estafilococo": 8.5, "salmonela": 2.4, "coli": 7.7, "min_bacteria": "salmonela"}}, {"input": {"food_quantities": [53.3, 23.5, 54.1]}, "output": {"estafilococo": 7.7, "salmonela": 7.9, "coli": 7.5, "min_bacteria": "coli"}}, {"input": {"food_quantities": [17.7, 12.5, 23.5]}, "output": {"estafilococo": 3.9, "salmonela": 4.3, "coli": 1.4, "min_bacteria": "coli"}}, {"input": {"food_quantities": [31.3, 4.8, 21.1]}, "output": {"estafilococo": 2.2, "salmonela": 1.3, "coli": 6.4, "min_bacteria": "salmonela"}}, {"input": {"food_quantities": [44.8, 23.3, 49.7]}, "output": {"estafilococo": 7.3, "salmonela": 8.0, "coli": 5.6, "min_bacteria": "coli"}}, {"input": {"food_quantities": [21.6, 9.6, 22.1]}, "output": {"estafilococo": 2.8, "salmonela": 3.4, "coli": 3.2, "min_bacteria": "estafilococo"}}, {"input": {"food_quantities": [40.0, 12.5, 33.5]}, "output": {"estafilococo": 8.5, "salmonela": 2.0, "coli": 5.2, "min_bacteria": "salmonela"}}, {"input": {"food_quantities": [50.8, 23.4, 53.8]}, "output": {"estafilococo": 3.4, "salmonela": 10.0, "coli": 8.5, "min_bacteria": "estafilococo"}}, {"input": {"food_quantities": [45.8, 20.4, 47.4]}, "output": {"estafilococo": 4.0, "salmonela": 8.2, "coli": 7.4, "min_bacteria": "estafilococo"}}, {"input": {"food_quantities": [51.7, 19.1, 47.8]}, "output": {"estafilococo": 7.7, "salmonela": 5.7, "coli": 7.6, "min_bacteria": "salmonela"}}], "error_log": []}
{"context": "Given a sequence of integers, determine if this sequence could represent the post-order traversal of a Binary Search Tree (BST). What is the result of this verification?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sequence` (list of integers): A list of integers representing the sequence to be verified as the post-order traversal of a Binary Search Tree (BST).\n\nOutput:\n  `return` (string): A string indicating whether the input sequence is a valid post-order traversal of a BST. The possible values are \"Yes\" or \"No\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, sequence):\n        if not len(sequence):\n            return False\n        if len(sequence) == 1:\n            return True\n        length = len(sequence)\n        root = sequence[-1]\n        i = 0\n        while sequence[i] < root:\n            i = i + 1\n        k = i\n        for j in range(i, length - 1):\n            if sequence[j] < root:\n                return False\n        left_s = sequence[:k]\n        right_s = sequence[k:length - 1]\n        left, right = True, True\n        if len(left_s) > 0:\n            left = self.VerifySquenceOfBST(left_s)\n        if len(right_s) > 0:\n            right = self.VerifySquenceOfBST(right_s)\n        return left and right\n\n# main function\ndef main_solution(sequence):\n    # Convert input to the required format\n    sequence = list(sequence)\n    \n    # Create an instance of the Solution class\n    obj = Solution()\n    \n    # Call the VerifySquenceOfBST method\n    result = obj.VerifySquenceOfBST(sequence)\n    \n    # Convert the result to a JSON serializable output\n    return \"Yes\" if result else \"No\"", "input_generator": "import random\n\ndef input_generator():\n    def generate_sequence(length):\n        if random.random() < 0.5:\n            # Generate a valid BST postorder sequence\n            def build_valid_sequence(start, end):\n                if start > end:\n                    return []\n                root = random.randint(start, end)\n                left = build_valid_sequence(start, root - 1)\n                right = build_valid_sequence(root + 1, end)\n                return left + right + [root]\n            sequence = build_valid_sequence(1, length)\n        else:\n            # Generate a random sequence which may or may not be valid\n            sequence = [random.randint(1, 100) for _ in range(length)]\n        return sequence\n\n    length = random.randint(0, 20)\n    sequence = generate_sequence(length)\n    return {'sequence': sequence}", "io_pairs": [{"input": {"sequence": [93, 16, 14, 30, 50, 11, 17, 53]}, "output": "No"}, {"input": {"sequence": [1, 3, 6, 7, 9, 11, 10, 8, 5, 4, 2, 15, 14, 17, 16, 13, 12]}, "output": "Yes"}, {"input": {"sequence": [2, 3, 1, 5, 4, 7, 6, 8]}, "output": "Yes"}, {"input": {"sequence": [1, 2, 3]}, "output": "Yes"}, {"input": {"sequence": [3, 4, 2, 1, 6, 8, 7, 9, 5, 11, 12, 13, 10]}, "output": "Yes"}, {"input": {"sequence": [2, 1, 3]}, "output": "Yes"}, {"input": {"sequence": [1, 2]}, "output": "Yes"}, {"input": {"sequence": [44, 72, 1, 10, 63, 5, 99, 95, 91, 95, 55, 55, 23, 34]}, "output": "No"}, {"input": {"sequence": [2, 1]}, "output": "Yes"}, {"input": {"sequence": [52, 46]}, "output": "Yes"}], "error_log": []}
{"context": "Given a mathematical function and a set of points, how can we approximate the derivative of the function at these points using different numerical differentiation methods? Specifically, what are the derivative values at the given points when using the forward, backward, central, or Richardson extrapolation methods?\n\nThe input and output requirements are as follows:\n\nInput:\n  `function_str` (str): A string representation of the function to be evaluated. The function should be in a form that can be evaluated using Python's `eval` function.\n  `x_values` (list of float): List of x values at which the derivative is to be computed.\n  `h` (float): Step size for the numerical differentiation.\n  `method` (str): Method to use for differentiation. Options are 'forward', 'backward', 'central', or 'richardson'.\n  `n` (int, optional): Number of levels of extrapolation for Richardson's method. Required if method is 'richardson'.\n\nOutput:\n  `return` (list of float or numpy float array): List of derivative values at the specified x values or a 2D array for Richardson's method.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef forward_difference_h2(f, x, h):\n    df = [(-f(xi + 2 * h) + 4 * f(xi + h) - 3 * f(xi)) / (2 * h) for xi in x]\n    return df\n\ndef backward_difference_h2(f, x, h):\n    df = [(f(xi - 2 * h) - 4 * f(xi - h) + 3 * f(xi)) / (2 * h) for xi in x]\n    return df\n\ndef central_difference_h2(f, x, h):\n    df = [(f(xi + h) - f(xi - h)) / (2 * h) for xi in x]\n    return df\n\ndef richardson(f, x, n, h):\n    N = np.zeros((n, n))\n    for i in range(n):\n        N[i, 0] = (f(x + h / np.power(2, i)) - f(x - h / np.power(2, i))) / (2 * h / np.power(2, i))\n    for i in range(1, n):\n        for j in range(i, n):\n            N[j, i] = N[j, i - 1] + (N[j, i - 1] - N[j - 1, i - 1]) / (np.power(2, i) - 1)\n    return N\n\n# main function\ndef main_solution(function_str, x_values, h, method, n=None):\n    \"\"\"\n    Compute the derivative of a given function at specified points using different numerical methods.\n\n    Input:\n        function_str (str): A string representation of the function to be evaluated.\n        x_values (list of float): List of x values at which the derivative is to be computed.\n        h (float): Step size for the numerical differentiation.\n        method (str): Method to use for differentiation. Options are 'forward', 'backward', 'central', or 'richardson'.\n        n (int, optional): Number of levels of extrapolation for Richardson's method. Required if method is 'richardson'.\n\n    Output:\n        return (list of float or numpy float array): List of derivative values at the specified x values or a 2D array for Richardson's method.\n    \"\"\"\n    def f(x):\n        return eval(function_str)\n\n    if method == 'forward':\n        return forward_difference_h2(f, x_values, h)\n    elif method == 'backward':\n        return backward_difference_h2(f, x_values, h)\n    elif method == 'central':\n        return central_difference_h2(f, x_values, h)\n    elif method == 'richardson':\n        if n is None:\n            raise ValueError(\"n must be provided for Richardson's method.\")\n        return richardson(f, x_values[0], n, h)\n    else:\n        raise ValueError(\"Invalid method specified. Choose from 'forward', 'backward', 'central', or 'richardson'.\")", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose a method\n    methods = ['forward', 'backward', 'central', 'richardson']\n    method = random.choice(methods)\n    \n    # Generate a random function string\n    func_options = [\n        'np.sin(x)',\n        'np.cos(x)',\n        'x**2',\n        'np.exp(x)',\n        'np.log(abs(x) + 1)',\n        'x**3 - 2*x + 1'\n    ]\n    function_str = random.choice(func_options)\n    \n    # Generate x_values: between -10 and 10, 1 to 5 points\n    num_points = random.randint(1, 5)\n    x_values = [random.uniform(-10, 10) for _ in range(num_points)]\n    \n    # Generate h: small positive value\n    h = random.uniform(1e-5, 0.1)\n    \n    # Generate n if method is richardson\n    n = None\n    if method == 'richardson':\n        n = random.randint(2, 5)\n    \n    return {\n        'function_str': function_str,\n        'x_values': x_values,\n        'h': h,\n        'method': method,\n        'n': n\n    }", "io_pairs": [{"input": {"function_str": "np.sin(x)", "x_values": [6.097376313912207, 3.0077758247910573, 8.556050531292104], "h": 0.040829599101799625, "method": "central", "n": null}, "output": [0.982514080027381, -0.9907845451729371, -0.6456192718333913]}, {"input": {"function_str": "np.sin(x)", "x_values": [-0.6908310707950491, -9.37815907886151, 7.988517611960933, -5.927044811691234, -0.15662156838310004], "h": 0.026062988618219093, "method": "backward", "n": null}, "output": [0.7708883905917698, -0.9991398696378206, -0.13415647445516876, 0.937463164470184, 0.9879828055207782]}, {"input": {"function_str": "np.log(abs(x) + 1)", "x_values": [-8.665811329000528, 2.0902475307541692, 3.600914926750354, 0.4231400350021115], "h": 0.0314877115409112, "method": "backward", "n": null}, "output": [-0.1034567034988568, 0.3235757513906602, 0.21734118189019125, 0.7024303096037671]}, {"input": {"function_str": "np.log(abs(x) + 1)", "x_values": [-5.893813505869849], "h": 0.059444568641034194, "method": "backward", "n": null}, "output": [-0.14505054077566748]}, {"input": {"function_str": "np.exp(x)", "x_values": [4.441498659039668, 9.198425261828842, -3.874177811721835, 2.406281739496702], "h": 0.030379890722253885, "method": "forward", "n": null}, "output": [84.87536220833657, 9878.445657096065, 0.020764870936747885, 11.089147572351875]}, {"input": {"function_str": "np.exp(x)", "x_values": [3.8032745862611765, -1.5006052764355573, 7.996476655450053, 6.689390913684342, -9.740303415618751], "h": 0.017111491147340414, "method": "forward", "n": null}, "output": [44.843368484383745, 0.2229730994641086, 2970.179854046564, 803.7530297926425, 5.885685289711508e-05]}, {"input": {"function_str": "x**2", "x_values": [0.9874465750374881], "h": 0.019795056581221614, "method": "backward", "n": null}, "output": [1.9748931500749765]}, {"input": {"function_str": "x**2", "x_values": [-7.291308751043635, 6.391042097402199, 8.193637547010468], "h": 0.00906096092101764, "method": "forward", "n": null}, "output": [-14.582617502086046, 12.782084194804048, 16.387275094020158]}, {"input": {"function_str": "np.sin(x)", "x_values": [-4.086760682271889], "h": 0.09207902125843737, "method": "central", "n": null}, "output": [-0.5847795192041002]}, {"input": {"function_str": "x**3 - 2*x + 1", "x_values": [7.268134923517962, 2.458352108332857, 7.947727972483012, 4.558056725690838], "h": 0.02393133952238081, "method": "backward", "n": null}, "output": [156.47621038136353, 16.129339847611465, 187.49799435574116, 60.326497925824285]}], "error_log": []}
{"context": "A gambler plays a game where three fair coins are tossed. Heads result in a +1 payoff, and tails result in a -1 payoff. The payoffs are added, and the net payoff is added to the gambler's equity. The gambler starts with a certain amount of money and plays a fixed number of rounds. If the gambler's balance goes below zero, they are considered ruined. Given the probability of winning each round, the initial amount of money, the number of rounds, and the number of simulations, what is the probability of the gambler being ruined if they play an infinite number of games?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p` (float): The probability that the gambler is successful/wins at each round. It should be between 0 and 1.\n  `init_bal` (int): The initial amount of money/reserves the gambler starts with. It should be a positive integer.\n  `no_rounds` (int): The number of rounds the gambler will play. It should be a positive integer.\n  `no_simulations` (int): The number of simulations to run. It should be a positive integer.\n\nOutput:\n  `return` (dict): A dictionary containing the key `probability_of_ruin` with a float value representing the probability of ruin if the gambler plays infinite games.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass GamblersRuin(object):\n    \"\"\"\n    Three fair coins tossed. Heads gets +1, tails -1, pay-offs are added and net pay-off added to equity.\n    The 3 tosses are repeated 1000 times. Initial equity is 10 dollars\n    p: probability that gambler is successful/ wins at each round.\n    i: gambler's initial amount of money/reserves\n    \"\"\"\n\n    def __init__(self, p, init_bal):\n        self.p = p\n        self.init_bal = init_bal\n        self.bal = init_bal\n        self.q = 1 - self.p\n        self.realizations = np.array(self.init_bal)\n        self.simulation_results = []\n\n    def coin_toss(self):\n        \"\"\"\n        One coin flip with payoff (1, -1) with probability (p,q)\n        \"\"\"\n        outcome = np.random.uniform(0, 1)\n\n        if outcome < self.p:\n            result = 1\n        else:\n            result = -1\n\n        return result\n\n    def play_one_round(self):\n        \"\"\"\n        Three coin tosses in one round round\n        \"\"\"\n        result_round = 0\n        for i in range(0,3):\n            result_round += self.coin_toss()\n        return result_round\n\n    def gamble(self, no_rounds):\n        \"\"\"\n        One round is played until ruin or no_rounds times\n        \"\"\"\n        self.realizations = np.array(self.init_bal)\n        self.bal = self.init_bal\n\n        round = 1\n        while round < no_rounds:\n            round_result = self.play_one_round()\n            if (self.bal + round_result) >= 0:\n                self.bal += round_result\n            else:\n                break\n            self.realizations = np.append(self.realizations, self.bal)\n            round += 1\n\n    def simulate(self, no_simulations, no_rounds):\n        # Gamble multiple times and store realization paths\n        self.simulation_results = []\n\n        for game in range(1,no_simulations+1):\n            self.gamble(no_rounds=no_rounds)\n            self.simulation_results.append(self.realizations)\n\n    def probability_ruin(self):\n        # Analytical solution for calculating probability of ruin if you play infinite games\n        if self.p > 0.5:\n            prob_ruin_analytical = 1 - ((self.q/self.p) ** self.init_bal)\n        else:\n            prob_ruin_analytical = 1\n\n        # Probability of ruin in simulation\n        # number of ruin / number of still in the game\n        no_ruin = self.simulation_results\n        return prob_ruin_analytical\n\n# main function\ndef main_solution(p, init_bal, no_rounds, no_simulations):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    gr = GamblersRuin(p=float(p), init_bal=int(init_bal))\n    gr.simulate(no_simulations=int(no_simulations), no_rounds=int(no_rounds))\n    prob_ruin = gr.probability_ruin()\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"probability_of_ruin\": float(prob_ruin)}", "input_generator": "import random\n\ndef input_generator():\n    p = random.uniform(0.3, 0.7)  # Reasonable probability between 0.3 and 0.7\n    init_bal = random.randint(5, 20)  # Initial balance between 5 and 20\n    no_rounds = random.randint(500, 1500)  # Number of rounds between 500 and 1500\n    no_simulations = random.randint(50, 200)  # Number of simulations between 50 and 200\n    return {\n        \"p\": p,\n        \"init_bal\": init_bal,\n        \"no_rounds\": no_rounds,\n        \"no_simulations\": no_simulations\n    }", "io_pairs": [{"input": {"p": 0.42671808814253365, "init_bal": 5, "no_rounds": 854, "no_simulations": 68}, "output": {"probability_of_ruin": 1.0}}, {"input": {"p": 0.3902403953317084, "init_bal": 11, "no_rounds": 920, "no_simulations": 180}, "output": {"probability_of_ruin": 1.0}}, {"input": {"p": 0.3858069747379278, "init_bal": 14, "no_rounds": 1463, "no_simulations": 195}, "output": {"probability_of_ruin": 1.0}}, {"input": {"p": 0.5698598106476225, "init_bal": 5, "no_rounds": 1375, "no_simulations": 178}, "output": {"probability_of_ruin": 0.7549752456098258}}, {"input": {"p": 0.6406664063634878, "init_bal": 18, "no_rounds": 988, "no_simulations": 187}, "output": {"probability_of_ruin": 0.9999698292827781}}, {"input": {"p": 0.6935462042281811, "init_bal": 8, "no_rounds": 1496, "no_simulations": 121}, "output": {"probability_of_ruin": 0.9985468285860064}}, {"input": {"p": 0.6432112066979286, "init_bal": 17, "no_rounds": 719, "no_simulations": 84}, "output": {"probability_of_ruin": 0.999955436505624}}, {"input": {"p": 0.6623403985609095, "init_bal": 13, "no_rounds": 906, "no_simulations": 53}, "output": {"probability_of_ruin": 0.999842901456064}}, {"input": {"p": 0.3172479452535062, "init_bal": 8, "no_rounds": 589, "no_simulations": 110}, "output": {"probability_of_ruin": 1.0}}, {"input": {"p": 0.38707439399245, "init_bal": 15, "no_rounds": 1072, "no_simulations": 175}, "output": {"probability_of_ruin": 1.0}}], "error_log": []}
{"context": "Given a set of Euler angles representing the orientation of a drone, what are the corresponding quaternion representation and the Euler angles after converting the quaternion back to Euler angles?\n\nThe input and output requirements are as follows:\n\nInput:\n  `angles` (list of float): A list of three float values representing the Euler angles [roll, pitch, yaw] in radians.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `quaternion` (list of float): A list of four float values representing the quaternion [w, x, y, z].\n    - `euler_angles` (list of float): A list of three float values representing the converted Euler angles [roll, pitch, yaw] in radians.", "reference_code": "# import necessary packages\nimport numpy as np\nimport math as mt\n\n# all class and function definitions in the code file, if any\ndef quaternion_multiply(quaternion1, quaternion0):\n    w0, x0, y0, z0 = quaternion0\n    w1, x1, y1, z1 = quaternion1\n    return np.array([-x1 * x0 - y1 * y0 - z1 * z0 + w1 * w0,\n                     x1 * w0 + y1 * z0 - z1 * y0 + w1 * x0,\n                     -x1 * z0 + y1 * w0 + z1 * x0 + w1 * y0,\n                     x1 * y0 - y1 * x0 + z1 * w0 + w1 * z0])\n\ndef rot_yaw_to_quat(psi):\n    return np.array([mt.cos(psi/2),0,0,mt.sin(psi/2)])\n\ndef rot_pitch_to_quat(theta):\n    return np.array([mt.cos(theta/2),0,mt.sin(theta/2),0])\n\ndef rot_roll_to_quat(phi):\n    return np.array([mt.cos(phi/2),mt.sin(phi/2),0,0])\n\ndef euler_to_quaternion(angles):\n    roll = angles[0]\n    pitch = angles[1]\n    yaw = angles[2]\n    q_yaw = rot_yaw_to_quat(yaw)\n    q_pitch = rot_pitch_to_quat(pitch)\n    q_roll = rot_roll_to_quat(roll)\n    return quaternion_multiply(q_yaw, quaternion_multiply(q_pitch, q_roll))\n\ndef quaternion_to_euler(quaternion):\n    a = quaternion[0]\n    b = quaternion[1]\n    c = quaternion[2]\n    d = quaternion[3]\n    return np.array([ mt.atan2(2*(a*b+c*d),1-2*(b**2 + c**2)),\n                     mt.asin(2*(a*c-d*b)),\n                     mt.atan2(2*(a*d+b*c),1-2*(c**2+d**2))])\n\n# main function\ndef main_solution(angles):\n    # Convert Euler angles to quaternion\n    quaternion = euler_to_quaternion(angles)\n    # Convert quaternion back to Euler angles\n    euler_angles = quaternion_to_euler(quaternion)\n    # Return the quaternion and the converted Euler angles\n    return {\"quaternion\": quaternion.tolist(), \"euler_angles\": euler_angles.tolist()}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate random Euler angles in radians within reasonable ranges\n    # Roll: -pi to pi, Pitch: -pi/2 to pi/2, Yaw: -pi to pi\n    roll = random.uniform(-np.pi, np.pi)\n    pitch = random.uniform(-np.pi/2, np.pi/2)\n    yaw = random.uniform(-np.pi, np.pi)\n    angles = [roll, pitch, yaw]\n    return {\"angles\": angles}", "io_pairs": [{"input": {"angles": [0.8733815820695536, -1.1266417197106877, -0.14646961530265434]}, "output": {"quaternion": [0.7806145112805182, 0.3212286375388979, -0.5087523885055331, 0.16918674414118862], "euler_angles": [0.8733815820695531, -1.1266417197106873, -0.14646961530265423]}}, {"input": {"angles": [0.9456252646636365, 1.5357749154031795, -1.2924865539645667]}, "output": {"quaternion": [0.32082300365706895, 0.6339419122416816, 0.2964318664384144, -0.6382150114088936], "euler_angles": [0.9456252646636393, 1.5357749154031697, -1.2924865539645545]}}, {"input": {"angles": [0.5706134122182078, -0.3917215144144943, -0.4218637172827844]}, "output": {"quaternion": [0.9318356299074766, 0.23085301782362477, -0.24040611090539848, -0.14350660206416552], "euler_angles": [0.5706134122182078, -0.3917215144144944, -0.42186371728278443]}}, {"input": {"angles": [-1.5313895797936958, 0.9131752799754835, 0.007533309326684723]}, "output": {"quaternion": [0.6458979967677051, -0.6232375052313249, 0.31549123963801434, 0.3079871223869091], "euler_angles": [-1.5313895797936958, 0.9131752799754838, 0.007533309326684782]}}, {"input": {"angles": [1.1764740052219098, -0.49942636294036324, -2.580330907341144]}, "output": {"quaternion": [0.35502835167448166, -0.048628659009004316, -0.5735908606203721, -0.7366027746642468], "euler_angles": [1.1764740052219096, -0.49942636294036313, -2.580330907341144]}}, {"input": {"angles": [-0.20129749606163072, 0.26616154352914956, 0.3857144325992534]}, "output": {"quaternion": [0.9653039583309216, -0.12304695904132362, 0.11048138243269294, 0.20209299353787136], "euler_angles": [-0.2012974960616307, 0.2661615435291496, 0.3857144325992534]}}, {"input": {"angles": [-1.1955705987543215, -1.2249749758473347, -2.5947196901056153]}, "output": {"quaternion": [-0.12890615890792276, -0.5819080513623165, 0.315071121292115, -0.7385772880904519], "euler_angles": [-1.1955705987543213, -1.2249749758473347, -2.5947196901056153]}}, {"input": {"angles": [0.6958799414777248, -0.19371671545841207, -1.9339470081292631]}, "output": {"quaternion": [0.558410535866289, 0.11785241245221025, -0.33097372633411815, -0.7514950929907835], "euler_angles": [0.6958799414777248, -0.19371671545841201, -1.9339470081292633]}}, {"input": {"angles": [-1.2493841175435467, 1.5123849288969362, -2.1516273522892138]}, "output": {"quaternion": [0.6334246813054756, 0.287674410500491, 0.6387663119387317, -0.32862471816411276], "euler_angles": [-1.2493841175435447, 1.5123849288969342, -2.151627352289212]}}, {"input": {"angles": [1.45850297019188, -0.1982008565311022, 2.537064216915062]}, "output": {"quaternion": [0.15794975194800487, 0.2678071907968851, 0.6110216548084378, 0.7279998089094548], "euler_angles": [1.45850297019188, -0.19820085653110228, 2.537064216915062]}}], "error_log": []}
{"context": "Given a binary tree, determine whether it is a full binary tree. A full binary tree is defined as a binary tree in which all nodes have either zero or two child nodes. What is the result of checking if the given binary tree is a full binary tree?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (dict): A dictionary representing the structure of the binary tree. Each node is represented as a dictionary with keys `'val'` (int), `'left'` (dict or None), and `'right'` (dict or None).\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is a full binary tree.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    \"\"\" \u4e8c\u53c9\u6811\u57fa\u7840\u8282\u70b9\n    \"\"\"\n\n    def __init__(self, value, left=None, right=None):\n        self.val = value\n        self.left = left\n        self.right = right\n\n    def __repr__(self):\n        return str(self.val)\n\ndef is_full1(head):\n    \"\"\" \u901a\u8fc7\u5bf9\u6bd4\u6bcf\u5c42\u7684\u8282\u70b9\u6570\u91cf\uff0c\u5224\u65ad\u662f\u4e0d\u662f\u6ee1\u4e8c\u53c9\u6811\n    \"\"\"\n    if not head:\n        return True\n    level = 0\n    node_num = 0\n    queue = [[head, 0]]\n    while queue:\n        node, cur_lv = queue.pop(0)\n        if cur_lv == level:\n            node_num += 1\n        else:\n            if node_num != 1 << level:\n                return False\n            node_num = 1\n            level = cur_lv\n        if node.left:\n            queue.append([node.left, cur_lv + 1])\n        if node.right:\n            queue.append([node.right, cur_lv + 1])\n    return node_num == 1 << level\n\ndef isFull2(head):\n    info = check_full(head)\n    return info['is_full']\n\ndef check_full(head):\n    if not head:\n        return {'is_full': True, 'hight': 0}\n    left_info = check_full(head.left)\n    right_info = check_full(head.right)\n    hight = max(left_info['hight'], right_info['hight']) + 1\n    is_full = left_info['is_full'] and right_info['is_full'] and left_info['hight'] == right_info['hight']\n    return {'is_full': is_full, \"hight\": hight}\n\ndef generate_random_BST(max_level, max_value):\n    return generate(1, max_level, max_value)\n\ndef generate(level, max_level, max_value):\n    if level > max_level or random.randint(0, 1):\n        return None\n    head = Node(random.randint(1, max_value))\n    head.left = generate(level + 1, max_level, max_value)\n    head.right = generate(level + 1, max_level, max_value)\n    return head\n\n# main function\ndef main_solution(tree_structure):\n  # Convert the JSON serializable input to the original input variables\n  def build_tree(structure):\n      if not structure:\n          return None\n      node = Node(structure['val'])\n      node.left = build_tree(structure['left'])\n      node.right = build_tree(structure['right'])\n      return node\n\n  head = build_tree(tree_structure)\n  \n  # Call the original function with the converted input\n  result = isFull2(head)\n  \n  # Return the result, which is already JSON serializable\n  return result", "input_generator": "import random\n\ndef input_generator():\n    def generate_tree(level, max_level, max_value):\n        if level > max_level or random.random() < 0.3:\n            return None\n        node = {\n            'val': random.randint(1, max_value),\n            'left': generate_tree(level + 1, max_level, max_value),\n            'right': generate_tree(level + 1, max_level, max_value)\n        }\n        return node\n\n    max_level = random.randint(1, 5)\n    max_value = random.randint(1, 100)\n    tree_structure = generate_tree(1, max_level, max_value)\n    \n    return {'tree_structure': tree_structure}", "io_pairs": [{"input": {"tree_structure": {"val": 17, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 35, "left": null, "right": {"val": 49, "left": null, "right": null}}}, "output": false}, {"input": {"tree_structure": {"val": 29, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": null}, "output": true}, {"input": {"tree_structure": {"val": 22, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 22, "left": null, "right": {"val": 23, "left": null, "right": null}}}, "output": false}, {"input": {"tree_structure": {"val": 24, "left": null, "right": {"val": 31, "left": null, "right": null}}}, "output": false}, {"input": {"tree_structure": {"val": 5, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 20, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 57, "left": null, "right": null}}, "output": true}], "error_log": []}
{"context": "In a game of Tic Tac Toe, given a partially filled 3x3 board, what is the optimal move for the current player to either win or force a draw, assuming the opponent also plays optimally?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (str): A string representation of a 3x3 Tic Tac Toe board. Each cell can be `\"X\"`, `\"O\"`, or `\"None\"`. The board is represented as a list of lists, e.g., `[[None, \"X\", \"O\"], [\"X\", None, None], [\"O\", \"X\", None]]`.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"optimal_action\"`, which contains a tuple representing the optimal move for the current player. The tuple is in the format `(row, column)`, where `row` and `column` are integers between 0 and 2.", "reference_code": "# import necessary packages\nimport math\nfrom copy import deepcopy\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function definitions from the code file\ndef getInitialState():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\ndef getPlayer(board):\n    count_x, count_o = 0, 0\n    for row in board:\n        count_x += row.count(X)\n        count_o += row.count(O)\n    if count_x > count_o:\n        return O\n    return X\n\ndef getActions(board):\n    actions = set()\n    for row_i in range(len(board)):\n        for col_i in range(len(board[0])):\n            if board[row_i][col_i] == EMPTY:\n                actions.add((row_i, col_i))\n    return actions\n\ndef getResult(board, action):\n    result_board = deepcopy(board)\n    player = getPlayer(board)\n    result_board[action[0]][action[1]] = player\n    return result_board\n\ndef getWinner(board):\n    players = [X, O]\n    num_symbols_in_line = 3\n    for player in players:\n        for row in board:\n            if row.count(player) == num_symbols_in_line:\n                return player\n        for col_i in range(len(board[0])):\n            line_count = 0\n            for row_i in range(len(board)):\n                if board[row_i][col_i] == player:\n                    line_count += 1\n            if line_count == num_symbols_in_line:\n                return player\n        line_count = 0\n        for vert_cell in range(len(board)):\n            if board[vert_cell][vert_cell] == player:\n                line_count += 1\n        if line_count == num_symbols_in_line:\n            return player\n        line_count = 0\n        col_i = len(board) - 1\n        for row_i in range(len(board)):\n            if board[row_i][col_i] == player:\n                line_count += 1\n            col_i -= 1\n        if line_count == num_symbols_in_line:\n            return player\n    return None\n\ndef isTerminal(board):\n    if getWinner(board):\n        return True\n    count_empty = 0\n    for row in board:\n        count_empty += row.count(EMPTY)\n    if count_empty == 0:\n        return True\n    return False\n\ndef getUtility(board):\n    winner = getWinner(board)\n    if winner == X:\n        return 1\n    if winner == O:\n        return -1\n    return 0\n\ndef minValue(board, cur_optimal_val, player):\n    if isTerminal(board):\n        return getUtility(board)\n    val = math.inf\n    for action in getActions(board):\n        val = min(val, maxValue(getResult(board, action), cur_optimal_val, player))        \n        if (\n            (player == X and (val <= cur_optimal_val or val == -1)) or\n            (player == O and val == -1)\n        ):\n            break\n    return val\n\ndef maxValue(board, cur_optimal_val, player):\n    if isTerminal(board):\n        return getUtility(board)\n    val = -math.inf\n    for action in getActions(board):\n        val = max(val, minValue(getResult(board, action), cur_optimal_val, player))\n        if (\n            (player == O and (val >= cur_optimal_val or val == 1)) or\n            (player == X and val == 1)\n        ):\n            break\n    return val\n\ndef minimax(board):\n    optimal_action = None\n    player = getPlayer(board)\n    if player == X:\n        optimal_val = -math.inf\n        for action in getActions(board):\n            val = minValue(getResult(board, action), optimal_val, player)\n            if val > optimal_val:\n                optimal_val = val\n                optimal_action = action\n                if val == 1:\n                    break\n    else:\n        optimal_val = math.inf\n        for action in getActions(board):\n            val = maxValue(getResult(board, action), optimal_val, player)\n            if val < optimal_val:\n                optimal_val = val\n                optimal_action = action\n                if val == -1:\n                    break\n    return optimal_action\n\n# main function\ndef main_solution(board):\n    # Convert the input board to a list of lists if it's not already\n    if isinstance(board, str):\n        board = eval(board)\n    \n    # Get the optimal action for the current player on the board\n    optimal_action = minimax(board)\n    \n    # Convert the output to a JSON serializable format\n    return {\"optimal_action\": optimal_action}", "input_generator": "import random\n\ndef input_generator():\n    board = [[None, None, None], [None, None, None], [None, None, None]]\n    players = ['X', 'O']\n    current_player = random.choice(players)\n    \n    # Randomly fill the board with some moves\n    moves = random.randint(0, 8)\n    for _ in range(moves):\n        empty_positions = []\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] is None:\n                    empty_positions.append((i, j))\n        if not empty_positions:\n            break\n        pos = random.choice(empty_positions)\n        board[pos[0]][pos[1]] = current_player\n        current_player = 'O' if current_player == 'X' else 'X'\n    \n    return {'board': board}", "io_pairs": [{"input": {"board": [[null, null, null], [null, "O", null], [null, null, null]]}, "output": {"optimal_action": [0, 0]}}, {"input": {"board": [["X", null, "O"], ["O", "X", null], ["O", null, null]]}, "output": {"optimal_action": [0, 1]}}, {"input": {"board": [[null, null, null], [null, null, null], [null, null, null]]}, "output": {"optimal_action": [0, 1]}}, {"input": {"board": [["O", null, null], ["X", null, null], ["O", "X", null]]}, "output": {"optimal_action": [1, 1]}}, {"input": {"board": [[null, "X", "O"], ["X", "X", "O"], ["O", null, "X"]]}, "output": {"optimal_action": [2, 1]}}, {"input": {"board": [["O", null, null], [null, null, null], [null, null, null]]}, "output": {"optimal_action": [1, 2]}}, {"input": {"board": [[null, "X", "O"], ["O", null, null], [null, null, null]]}, "output": {"optimal_action": [2, 1]}}, {"input": {"board": [["O", null, "X"], [null, null, null], [null, null, "O"]]}, "output": {"optimal_action": [2, 1]}}, {"input": {"board": [["O", null, null], ["X", null, "O"], ["O", null, "X"]]}, "output": {"optimal_action": [0, 1]}}, {"input": {"board": [["X", "O", "X"], [null, null, null], ["O", "O", "X"]]}, "output": {"optimal_action": [1, 1]}}], "error_log": []}
{"context": "Given a chessboard of size `n` by `n`, how can you place `n` queens on the board such that no two queens can attack each other? Each solution should be represented as a configuration of the board where 'Q' indicates a queen and '.' indicates an empty space. What are all the distinct solutions for the given `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the chessboard and the number of queens to place. It should be a positive integer.\n\nOutput:\n  `return` (List[List[str]]): A list of all distinct solutions where each solution is a list of strings representing the board configuration. Each string in the list represents a row on the chessboard, with 'Q' indicating a queen and '.' indicating an empty space.", "reference_code": "# import necessary packages\nimport copy\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        return self.solveNQueens_2(n)\n\n    def solveNQueens_2(self, n):\n        retval = []\n        board = [\".\" * n for i in range(n)]\n        is_valid_array = [True for i in range((5 * n - 2))]\n        self.solveNQueensDFS_optimized(retval, board, 0, 0, is_valid_array)\n        return retval\n\n    def solveNQueensDFS_optimized(self, results, board, row, queens_added, is_valid_array):\n        n = len(board)\n        if row == n:\n            results.append(copy.deepcopy(board))\n\n        if queens_added > n:\n            return\n\n        for col in range(n):\n            if is_valid_array[col] and is_valid_array[n + row + col] and is_valid_array[4 * n - 2 - row + col]:\n                board[row] = board[row][:col] + 'Q' + board[row][col+1:]\n                # set flag in the corresponding positions  in 'is_valid_array'\n                is_valid_array[col] = is_valid_array[n + row + col] = is_valid_array[4 * n - 2 - row + col] = False\n                self.solveNQueensDFS_optimized(results, board, row+1, queens_added+1, is_valid_array)\n                board[row] = board[row][:col] + '.' + board[row][col+1:]\n                # reset the flag\n                is_valid_array[col] = is_valid_array[n + row + col] = is_valid_array[4 * n - 2 - row + col] = True\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    Solves the n-queens puzzle for a given integer n.\n\n    :param n: int, the size of the chessboard and the number of queens to place.\n    :return: List[List[str]], a list of all distinct solutions where each solution is a list of strings representing the board configuration.\n    \"\"\"\n    solution = Solution()\n    return solution.solveNQueens(n)", "input_generator": "import random\n\ndef input_generator():\n    n = random.choice([4, 5, 6, 7, 8])\n    return {'n': n}", "io_pairs": [{"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}], "error_log": []}
{"context": "In a blockchain network, the time it takes for a transaction to be confirmed can be modeled using an exponential distribution. Given an expected value for the distribution and a number of confirmations required, what are the mean, median, and 99th percentile of the confirmation times?\n\nThe input and output requirements are as follows:\n\nInput:\n  `expectation` (float): The expected value for the exponential distribution.\n  `confirmations` (int): The number of confirmations to sum for each sample.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `mean` (float): The mean of the simulated times.\n    - `median` (float): The median of the simulated times.\n    - `99th_percentile` (float): The 99th percentile of the simulated times.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom numpy.random import exponential\nfrom numpy import mean, median, percentile\n\n# main function\ndef main_solution(expectation, confirmations):\n    # Generate random times based on exponential distribution\n    times = [sum(exponential(expectation, confirmations)) for _ in range(1000000)]\n\n    # Calculate statistical measures\n    experimental_mean = mean(times)\n    experimental_median = median(times)\n    experimental_99pc = percentile(times, 99)\n\n    # Return results as a dictionary\n    return {\n        \"mean\": experimental_mean,\n        \"median\": experimental_median,\n        \"99th_percentile\": experimental_99pc\n    }", "input_generator": "import numpy as np\nfrom numpy.random import randint, uniform\n\ndef input_generator():\n    expectation = uniform(0.1, 10.0)\n    confirmations = randint(1, 100)\n    return {\n        \"expectation\": expectation,\n        \"confirmations\": confirmations\n    }", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a sequence of digits from 0 to N, where each digit appears exactly once, determine the parity of the sequence. The parity is defined as +1 for even parity and -1 for odd parity. What is the parity of the given permutation?\n\nThe input and output requirements are as follows:\n\nInput:\n  `permutation` (list of integers): A list representing a permutation of the digits 0 to N.\n\nOutput:\n  `return` (integer): The parity of the permutation, where +1 indicates even parity and -1 indicates odd parity.", "reference_code": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(permutation):\n    \"\"\"\n    Given a permutation of the digits 0..N in order as a list, \n    returns its parity (or sign): +1 for even parity; -1 for odd.\n    \"\"\"\n    lst = permutation[:]\n    parity = 1\n    for i in range(0, len(lst) - 1):\n        if lst[i] != i:\n            parity *= -1\n            mn = min(list(range(i, len(lst))), key=lst.__getitem__)\n            lst[i], lst[mn] = lst[mn], lst[i]\n    return parity", "input_generator": "import random\nfrom itertools import permutations\n\ndef input_generator():\n    n = random.randint(2, 10)\n    elements = list(range(n))\n    random_permutation = random.choice(list(permutations(elements)))\n    return {'permutation': list(random_permutation)}", "io_pairs": [{"input": {"permutation": [1, 0]}, "output": -1}, {"input": {"permutation": [3, 1, 2, 0]}, "output": -1}, {"input": {"permutation": [1, 9, 2, 3, 6, 5, 7, 4, 8, 0]}, "output": 1}, {"input": {"permutation": [5, 2, 8, 3, 6, 9, 1, 0, 7, 4]}, "output": 1}, {"input": {"permutation": [0, 3, 1, 4, 5, 2]}, "output": 1}, {"input": {"permutation": [6, 9, 2, 1, 4, 8, 5, 0, 7, 3]}, "output": 1}, {"input": {"permutation": [2, 0, 4, 1, 3]}, "output": 1}, {"input": {"permutation": [3, 2, 0, 1]}, "output": -1}, {"input": {"permutation": [1, 0, 2]}, "output": -1}, {"input": {"permutation": [5, 2, 7, 3, 4, 0, 1, 6]}, "output": 1}], "error_log": []}
{"context": "In the game of Master Mind, the computer generates a sequence of four colored balls, each of which can be red (R), yellow (Y), green (G), or blue (B). The player attempts to guess the sequence by providing a guess of four colors. A \"hit\" occurs when the player correctly guesses both the color and the position of a ball, while a \"pseudo-hit\" occurs when the player guesses the correct color but in the wrong position. Given a specific solution and a guess, how many hits and pseudo-hits are there?\n\nThe input and output requirements are as follows:\n\nInput:\n  `solution` (str): A string of length 4 representing the solution, where each character is one of 'R', 'Y', 'G', 'B'.\n  `guess` (str): A string of length 4 representing the guess, where each character is one of 'R', 'Y', 'G', 'B'.\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `hits` (int): The number of correct colors in the correct slots.\n    - `pseudo_hits` (int): The number of correct colors in the wrong slots.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(solution, guess):\n    # Convert the solution and guess strings to lists for easier manipulation\n    solution_list = list(solution)\n    guess_list = list(guess)\n    \n    # Initialize hits and pseudo-hits counters\n    hits = 0\n    pseudo_hits = 0\n    \n    # Calculate hits\n    for i in range(len(solution_list)):\n        if guess_list[i] == solution_list[i]:\n            hits += 1\n            # Mark the slot as used by replacing it with a placeholder\n            solution_list[i] = guess_list[i] = None\n    \n    # Calculate pseudo-hits\n    for i in range(len(solution_list)):\n        if guess_list[i] is not None and guess_list[i] in solution_list:\n            pseudo_hits += 1\n            # Mark the slot as used by replacing it with a placeholder\n            solution_list[solution_list.index(guess_list[i])] = None\n    \n    return {\"hits\": hits, \"pseudo_hits\": pseudo_hits}", "input_generator": "import random\n\ndef input_generator():\n    colors = ['R', 'G', 'B', 'Y']\n    solution = ''.join(random.choices(colors, k=4))\n    guess = ''.join(random.choices(colors, k=4))\n    return {\"solution\": solution, \"guess\": guess}", "io_pairs": [{"input": {"solution": "YBRG", "guess": "GRGY"}, "output": {"hits": 0, "pseudo_hits": 3}}, {"input": {"solution": "GYYR", "guess": "BYRG"}, "output": {"hits": 1, "pseudo_hits": 2}}, {"input": {"solution": "GBBY", "guess": "GBGY"}, "output": {"hits": 3, "pseudo_hits": 0}}, {"input": {"solution": "GGRB", "guess": "GBYY"}, "output": {"hits": 1, "pseudo_hits": 1}}, {"input": {"solution": "YYYB", "guess": "BRYG"}, "output": {"hits": 1, "pseudo_hits": 1}}, {"input": {"solution": "GGBR", "guess": "YBRG"}, "output": {"hits": 0, "pseudo_hits": 3}}, {"input": {"solution": "BGGB", "guess": "BYRR"}, "output": {"hits": 1, "pseudo_hits": 0}}, {"input": {"solution": "RYRG", "guess": "BRBB"}, "output": {"hits": 0, "pseudo_hits": 1}}, {"input": {"solution": "BGYG", "guess": "GBRG"}, "output": {"hits": 1, "pseudo_hits": 2}}, {"input": {"solution": "GYRG", "guess": "GGGR"}, "output": {"hits": 1, "pseudo_hits": 2}}], "error_log": []}
{"context": "Given a system of linear equations represented by a matrix and a vector, how can we find the solution vector using the pseudo-inverse method? Specifically, what is the solution vector when the system is represented by the input `matrix` and `vector`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of floats): A 2D list representing a matrix. Each sublist represents a row of the matrix.\n  `vector` (list of floats): A 1D list representing a vector.\n\nOutput:\n  `return` (list of floats): A 1D list representing the solution vector obtained by solving the system using the pseudo-inverse of the input matrix.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom numpy.linalg import svd\nimport math as math\nimport cmath as cmath\n\n# main function\ndef main_solution(matrix, vector):\n    # Convert JSON serializable inputs to numpy arrays\n    matrix = np.array(matrix)\n    vector = np.array(vector)\n    \n    # Calculate the pseudo-inverse of the matrix\n    pseudo_inverse = np.linalg.pinv(matrix)\n    \n    # Solve the system using the pseudo-inverse\n    solution = np.matmul(pseudo_inverse, vector)\n    \n    # Convert the solution to a JSON serializable output\n    solution = solution.tolist()\n    \n    return solution", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the dimensions of the matrix (m x n)\n    m = random.randint(2, 5)\n    n = random.randint(2, 5)\n    \n    # Generate a random matrix with values between -10 and 10\n    matrix = np.random.uniform(-10, 10, (m, n)).tolist()\n    \n    # Generate a random vector with length m and values between -10 and 10\n    vector = np.random.uniform(-10, 10, m).tolist()\n    \n    return {'matrix': matrix, 'vector': vector}", "io_pairs": [{"input": {"matrix": [[-4.543872941414923, -9.274169677758037], [5.566983632441572, -4.596552865435813], [3.6185487173908655, -2.5079506144816]], "vector": [4.87585524560833, -4.651557663624648, 2.5119038631934654]}, "output": [-0.5755744985376486, -0.22776305275797598]}, {"input": {"matrix": [[4.93522610634651, 6.302094269071169, -3.2351542212871065], [-1.2809814564446143, -2.219944991111289, 6.487008506112776]], "vector": [0.15892439310847806, 0.7011181978205485]}, "output": [0.05503323910918192, 0.052384631727806046, 0.1368744555500679]}, {"input": {"matrix": [[-8.753789145074887, -1.0127420731661996], [-8.2774189616325, -8.080533888451292], [6.984210270518744, -7.414023058303416]], "vector": [-5.643269120099865, 0.7038463302988358, -0.7446578156595258]}, "output": [0.19703596071237697, 0.006807253506617648]}, {"input": {"matrix": [[8.665779763958128, 1.5959051436727556], [-8.540532152357823, 0.6837258899165573]], "vector": [-1.397624608353155, 6.774057678968518]}, "output": [-0.6017083863275962, 2.3915254392281344]}, {"input": {"matrix": [[-7.72419721095619, 4.529794268426388, -9.806668178875196], [4.925391450078651, -4.936218090743987, 2.8808522533130656]], "vector": [-1.0375667125072336, 5.78129488077038]}, "output": [0.489132211840906, -1.1585594519920184, -0.8146113209434669]}, {"input": {"matrix": [[-9.712558534652205, -3.0007829088626288, -4.638416191464636], [-4.559724178020483, -6.960504293275758, 2.8133942440195305], [-8.686624620924462, -0.7918115736408247, 8.017684681621674]], "vector": [-5.993071882714592, -6.6956911725112285, -9.511771972751212]}, "output": [0.6992024001051551, 0.34434042704406975, -0.3948035597905463]}, {"input": {"matrix": [[-7.869037502600536, -7.254653523084262, -6.071755512758554, 2.6242404902634178], [6.128186617744465, -6.696246763066314, -2.3135965087663894, -4.267681466334441]], "vector": [-9.021933214240798, -2.0171341060280206]}, "output": [0.33954054937348704, 0.5269112548545885, 0.38398679202278885, -0.07470480911340936]}, {"input": {"matrix": [[-9.762967379751641, 0.5269877580882536], [8.840765480532497, 8.54918490540891], [1.9662724459794845, -8.378087389137088]], "vector": [-6.982956885469534, -1.8006983185561118, 0.6780207627339525]}, "output": [0.4004493820566332, -0.32296430119020403]}, {"input": {"matrix": [[8.599246789673746, -6.563138516012714, 3.2835728618231457], [-4.4896120366833365, 4.122427556784373, -3.368711203689296]], "vector": [6.70630619117091, 4.651623631543735]}, "output": [2.8451104003864383, 0.3044613403919796, -4.800039164382945]}, {"input": {"matrix": [[8.957230082551714, -7.911174636969873], [-9.552424907295878, -0.8459578206049443], [-4.634939744783706, 7.2741492880965986]], "vector": [1.2913755099982644, 2.252080026773303, -8.807536143578822]}, "output": [-0.2869954669346162, -0.8938806450807096]}], "error_log": []}
{"context": "Given the continued fraction expansion of the mathematical constant e, which starts with the sequence [2; 1,2,1, 1,4,1, 1,6,1, ...], what is the sum of the digits of the numerator after considering a certain number of terms in the expansion? Specifically, for a given `expansion_index`, determine the sum of the digits of the numerator obtained by computing the continued fraction up to that index.\n\nThe input and output requirements are as follows:\n\nInput:\n  `expansion_index` (int): The number of terms in the continued fraction expansion of e to consider.\n\nOutput:\n  `return` (int): The sum of the digits of the numerator of the continued fraction expansion of e after considering `expansion_index` terms.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef e_val(n):  # computes constant for the expansion of e\n    if n == 0: return 2\n    n += 2\n    if n % 3 == 1: return (n // 3) * 2\n    else: return 1\n\n# main function\ndef main_solution(expansion_index):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    a, b = 0, 1  # begin sequence with 0 and 1\n    for i in range(expansion_index):  # indexes 0 to expansion_index-1 for constants\n        a, b = b, e_val(i) * b + a\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sum(int(d) for d in str(b))", "input_generator": "import random\n\ndef input_generator():\n    return {'expansion_index': random.randint(1, 100)}", "io_pairs": [{"input": {"expansion_index": 15}, "output": 30}, {"input": {"expansion_index": 1}, "output": 2}, {"input": {"expansion_index": 38}, "output": 93}, {"input": {"expansion_index": 14}, "output": 22}, {"input": {"expansion_index": 44}, "output": 91}, {"input": {"expansion_index": 20}, "output": 39}, {"input": {"expansion_index": 100}, "output": 272}, {"input": {"expansion_index": 18}, "output": 28}, {"input": {"expansion_index": 32}, "output": 46}, {"input": {"expansion_index": 45}, "output": 82}], "error_log": []}
{"context": "In a Tic-Tac-Toe game, given an initial board configuration and the current player, what is the optimal move that the current player should make to maximize their chances of winning or minimizing their chances of losing?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_state` (str): A string representing the initial state of the Tic-Tac-Toe board. It should be a 9-character string where each character is either 'X', 'O', or '.'. The string is read row by row from top to bottom.\n  `player` (str): A string representing the current player, either 'X' or 'O'.\n\nOutput:\n  `return` (dict): A dictionary containing the optimal action for the current player. The dictionary has one key, `optimal_action`, which is a list of two integers representing the row and column indices of the optimal move.", "reference_code": "# import necessary packages\nimport sys\n\n# all class and function definitions in the code file, if any\nclass State:\n    def __init__(self, inputStr, player):\n        self.state = inputStr\n        self.player = player\n\n    def terminal_test(self):\n        result = False\n        for x in range(3):\n            if self.state[x] == self.state[x + 3] == self.state[x + 6]:\n                if self.state[x] != \".\":\n                    result = True\n\n            if self.state[x*3] == self.state[x*3 + 1] == self.state[x*3 + 2]:\n                if self.state[x*3] != \".\":\n                    result = True\n\n        if self.state[0] == self.state[4] == self.state[8]:\n            if self.state[0] != \".\":\n                result = True\n\n        if self.state[2] == self.state[4] == self.state[6]:\n            if self.state[2] != \".\":\n                result = True\n\n        blank = '.'\n        if blank not in self.state:\n            result = True\n\n        return result\n\n    def evalUtility(self):\n        utility = 0\n\n        for x in range(3):\n            if self.state[x] == self.state[x + 3] == self.state[x + 6]:\n                if self.state[x] == 'o':\n                    utility = -10\n                else:\n                    utility = 10\n\n                break\n\n            if self.state[x*3] == self.state[x*3 + 1] == self.state[x*3 + 2]:\n                if self.state[x*3] == 'o':\n                    utility = -10\n                else:\n                    utility = 10\n\n                break\n\n        if utility == 0:\n            if self.state[0] == self.state[4] == self.state[8] or self.state[2] == self.state[4] == self.state[6]:\n                if self.state[4] == 'o':\n                    utility = -10\n                else:\n                    utility = 10\n\n        return utility\n\n    def resultState(self, action):\n        a = str()\n        nextPlayer = str()\n        if self.player == \"X\":\n            nextPlayer = \"O\"\n            a = \"x\"\n        else:\n            nextPlayer = \"X\"\n            a = \"o\"\n\n        index = action[0] * 3 + action[1]\n        tempStr = self.state[0:index] + a + self.state[(index+1):len(self.state)]\n        newState = State(tempStr, nextPlayer)\n\n        return newState\n\ndef min_value(current_state):\n    if current_state.terminal_test():\n        return current_state.evalUtility()\n\n    mValue = 20\n    for i in range(3):\n        for j in range(3):\n            if current_state.state[i*3 + j] == \".\":\n                temp = max_value(current_state.resultState([i, j]))\n                if temp < mValue:\n                    mValue = temp\n\n    return mValue\n\ndef max_value(current_state):\n    if current_state.terminal_test():\n        return current_state.evalUtility()\n\n    mValue = -20\n    for i in range(3):\n        for j in range(3):\n            if current_state.state[i*3 + j] == \".\":\n                temp = min_value(current_state.resultState([i, j]))\n                if temp > mValue:\n                    mValue = temp\n\n    return mValue\n\ndef minimax_decision(current_state):\n    selectedAction = [-1, -1]\n\n    if current_state.player == \"X\":\n        mValue = -20\n        for i in range(3):\n            for j in range(3):\n                if current_state.state[i*3 + j] == \".\":\n                    temp = min_value(current_state.resultState([i, j]))\n                    if temp > mValue:\n                        selectedAction = [i, j]\n                        mValue = temp\n\n    if current_state.player == \"O\":\n        mValue = 20\n        for i in range(3):\n            for j in range(3):\n                if current_state.state[i*3 + j] == \".\":\n                    temp = max_value(current_state.resultState([i, j]))\n                    if temp < mValue:\n                        selectedAction = [i, j]\n                        mValue = temp\n\n    return selectedAction\n\n# main function\ndef main_solution(initial_state, player):\n    # Convert JSON serializable input to original input variables\n    initial_state_obj = State(initial_state, player)\n    \n    # Get the optimal action for the initial state\n    optimal_action = minimax_decision(initial_state_obj)\n    \n    # Convert the output to JSON serializable format\n    return {\"optimal_action\": optimal_action}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random Tic-Tac-Toe board state\n    symbols = ['x', 'o', '.']\n    state = ''.join([random.choice(symbols) for _ in range(9)])\n    \n    # Ensure the board is not already terminal\n    temp_state = State(state, \"X\")\n    while temp_state.terminal_test():\n        state = ''.join([random.choice(symbols) for _ in range(9)])\n        temp_state = State(state, \"X\")\n    \n    # Randomly choose a player\n    player = random.choice([\"X\", \"O\"])\n    \n    return {\"initial_state\": state, \"player\": player}", "io_pairs": [{"input": {"initial_state": "xx..oxxox", "player": "X"}, "output": {"optimal_action": [0, 2]}}, {"input": {"initial_state": ".o.oxxo..", "player": "X"}, "output": {"optimal_action": [0, 0]}}, {"input": {"initial_state": "oxxxox.x.", "player": "O"}, "output": {"optimal_action": [2, 2]}}, {"input": {"initial_state": "oo.oxx..x", "player": "X"}, "output": {"optimal_action": [0, 2]}}, {"input": {"initial_state": "xo...xoo.", "player": "X"}, "output": {"optimal_action": [0, 2]}}, {"input": {"initial_state": "..x.x....", "player": "O"}, "output": {"optimal_action": [0, 0]}}, {"input": {"initial_state": "oo.x.x.o.", "player": "O"}, "output": {"optimal_action": [0, 2]}}, {"input": {"initial_state": ".xox.xo.o", "player": "X"}, "output": {"optimal_action": [1, 1]}}, {"input": {"initial_state": "x.oox.xoo", "player": "X"}, "output": {"optimal_action": [1, 2]}}, {"input": {"initial_state": "xx.x.oo.x", "player": "X"}, "output": {"optimal_action": [0, 2]}}], "error_log": []}
{"context": "Given two integers, what is the greatest common divisor (gcd) and the modular inverse of the first integer modulo the second integer?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): The first integer for which the greatest common divisor (gcd) and modular inverse are to be computed.\n  `b` (int): The second integer for which the greatest common divisor (gcd) and modular inverse are to be computed.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `gcd` (int): The greatest common divisor of `a` and `b`.\n    - `inverse` (int): The modular inverse of `a` modulo `b`.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef gcd(a: int, b: int):\n    \"\"\"\"\"\"\n    if a == 0 or b == 0:\n        return max(a, b)\n\n    if b > a:\n        temp = a\n        a = b\n        b = temp\n\n    q = []\n    r = []\n    while b != 0:\n        temp = b\n        q.append(a // b)\n        b = a % b\n        r.append(b)\n        a = temp\n    return a, q, r\n\n\ndef gcdEx(quotient):\n    listP = [0, 1]\n    p0 = 0\n    p1 = 1\n    listQ = [1, 0]\n    q0 = 1\n    q1 = 0\n\n    for q in quotient:\n        curP = q * p1 + p0\n        listP.append(curP)\n        p0 = p1\n        p1 = curP\n        curQ = q * q1 + q0\n        q0 = q1\n        q1 = curQ\n        listQ.append(curQ)\n    # print(listP)\n    # print(listQ)\n\n    u = listQ[-2]\n    v = listP[-2]\n    return u, v\n\n\ndef a_bigger(a, b):\n    if b > a:\n        temp = a\n        a = b\n        b = temp\n    return a, b\n\n# main function\ndef main_solution(a: int, b: int):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    a, b = a_bigger(a, b)\n    g, q, r = gcd(a, b)\n    u, v = gcdEx(q)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"gcd\": g, \"inverse\": v}", "input_generator": "import random\n\ndef input_generator():\n    a = random.randint(1, 1000)\n    b = random.randint(1, 1000)\n    return {'a': a, 'b': b}", "io_pairs": [{"input": {"a": 105, "b": 655}, "output": {"gcd": 5, "inverse": 25}}, {"input": {"a": 676, "b": 52}, "output": {"gcd": 52, "inverse": 1}}, {"input": {"a": 994, "b": 592}, "output": {"gcd": 2, "inverse": 136}}, {"input": {"a": 303, "b": 961}, "output": {"gcd": 1, "inverse": 425}}, {"input": {"a": 87, "b": 799}, "output": {"gcd": 1, "inverse": 349}}, {"input": {"a": 641, "b": 28}, "output": {"gcd": 1, "inverse": 206}}, {"input": {"a": 638, "b": 707}, "output": {"gcd": 1, "inverse": 41}}, {"input": {"a": 388, "b": 595}, "output": {"gcd": 1, "inverse": 23}}, {"input": {"a": 917, "b": 298}, "output": {"gcd": 1, "inverse": 40}}, {"input": {"a": 141, "b": 545}, "output": {"gcd": 1, "inverse": 201}}], "error_log": []}
{"context": "In the classic n-queens puzzle, you are given a chessboard of size n x n, and the goal is to place n queens on the board such that no two queens can attack each other. How many distinct solutions exist for a given size of the chessboard, denoted by `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (int): The number of distinct solutions to the n-queens puzzle.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def DFS(queens, q_dif, q_sum):\n            l = len(queens)\n            if l == n:\n                result.append(queens)\n            for q in range(n):\n                if q not in queens and q - l not in q_dif and q + l not in q_sum:\n                    DFS(queens + [q], q_dif + [q - l], q_sum + [q + l])\n        result = []\n        DFS([], [], [])\n        return len(result)\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.totalNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.choice([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    return {'n': n}", "io_pairs": [{"input": {"n": 3}, "output": 0}, {"input": {"n": 7}, "output": 40}, {"input": {"n": 5}, "output": 10}, {"input": {"n": 4}, "output": 2}, {"input": {"n": 8}, "output": 92}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 9}, "output": 352}, {"input": {"n": 6}, "output": 4}, {"input": {"n": 2}, "output": 0}, {"input": {"n": 10}, "output": 724}], "error_log": []}
{"context": "Given a number, how many iterations does it take to approximate its cube root using the Newton-Raphson method, and what is the approximate cube root value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num` (float): The number whose cube root is to be found.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `iteration` (int): The number of iterations taken to find the cube root.\n    - `cuberoot` (float): The cube root of the input number, rounded to 4 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(num):\n    # Convert input to float for precision\n    num = float(num)\n    \n    # Initial guess\n    g = num / 2\n    iteration = 0\n    epsilon = 0.01\n\n    # Newton-Raphson iteration\n    while abs(g**3 - num) >= epsilon:\n        g = g - (g**3 - num) / (3.0 * g**2)\n        iteration += 1\n\n    # Return the result as a dictionary\n    return {\"iteration\": iteration, \"cuberoot\": round(g, 4)}", "input_generator": "import random\n\ndef input_generator():\n    num = random.uniform(0.1, 1000.0)\n    return {\"num\": num}", "io_pairs": [{"input": {"num": 672.8810587716946}, "output": {"iteration": 12, "cuberoot": 8.7629}}, {"input": {"num": 879.1603774146696}, "output": {"iteration": 13, "cuberoot": 9.5798}}, {"input": {"num": 939.8709118891232}, "output": {"iteration": 13, "cuberoot": 9.7954}}, {"input": {"num": 74.47997094038635}, "output": {"iteration": 8, "cuberoot": 4.2075}}, {"input": {"num": 490.7663787997377}, "output": {"iteration": 12, "cuberoot": 7.8878}}, {"input": {"num": 376.53944379044947}, "output": {"iteration": 11, "cuberoot": 7.2211}}, {"input": {"num": 360.22046860865}, "output": {"iteration": 11, "cuberoot": 7.1152}}, {"input": {"num": 302.5936234006033}, "output": {"iteration": 11, "cuberoot": 6.7136}}, {"input": {"num": 770.2607607833825}, "output": {"iteration": 13, "cuberoot": 9.1667}}, {"input": {"num": 754.8844020735754}, "output": {"iteration": 12, "cuberoot": 9.1053}}], "error_log": []}
{"context": "Given a positive integer, how would you represent it in binary format using a specified number of bits? Ensure that the binary representation fits within the given bit length, and if not, return an appropriate error message.\n\nThe input and output requirements are as follows:\n\nInput:\n  `decimal_number` (int): A positive integer to be converted to binary.\n  `bit_length` (int): The number of bits to represent the binary number.\n\nOutput:\n  `return` (str): A string representing the binary number. Each bit is represented as '0' or '1'. If the number requires more bits than specified, an error message \"Error: The number requires more bits than specified.\" is returned.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(decimal_number, bit_length):\n    # Convert decimal number to binary representation\n    binary_representation = []\n    num = decimal_number\n    while num > 0:\n        binary_representation.append(num % 2)\n        num = num // 2\n    binary_representation.reverse()\n    \n    # Ensure the binary representation fits within the specified bit length\n    if len(binary_representation) > bit_length:\n        return \"Error: The number requires more bits than specified.\"\n    \n    # Pad with zeros if necessary\n    while len(binary_representation) < bit_length:\n        binary_representation.insert(0, 0)\n    \n    # Convert list to string for JSON serialization\n    binary_string = ''.join(map(str, binary_representation))\n    \n    return binary_string", "input_generator": "import random\n\ndef input_generator():\n    bit_length = random.randint(1, 16)\n    max_num = (1 << bit_length) - 1\n    decimal_number = random.randint(0, max_num + random.randint(-max_num // 2, max_num // 2))\n    return {\n        'decimal_number': decimal_number,\n        'bit_length': bit_length\n    }", "io_pairs": [{"input": {"decimal_number": 351, "bit_length": 11}, "output": "00101011111"}, {"input": {"decimal_number": 20389, "bit_length": 15}, "output": "100111110100101"}, {"input": {"decimal_number": 13, "bit_length": 5}, "output": "01101"}, {"input": {"decimal_number": 28, "bit_length": 6}, "output": "011100"}, {"input": {"decimal_number": 6136, "bit_length": 16}, "output": "0001011111111000"}, {"input": {"decimal_number": 50, "bit_length": 7}, "output": "0110010"}, {"input": {"decimal_number": 64338, "bit_length": 16}, "output": "1111101101010010"}, {"input": {"decimal_number": 0, "bit_length": 1}, "output": "0"}, {"input": {"decimal_number": 1, "bit_length": 1}, "output": "1"}, {"input": {"decimal_number": 41, "bit_length": 7}, "output": "0101001"}], "error_log": []}
{"context": "In a smart irrigation system, sensors are deployed to monitor soil moisture levels across different regions. Each sensor sends its data to a central system with a unique address identifier. The system needs to determine if the moisture levels in a particular region have crossed a critical threshold, prompting the opening of irrigation valves. Given the address of the sensor and the current moisture level, what action should be taken by the system?\n\nThe input and output requirements are as follows:\n\nInput:\n  `address1` (int): The first part of the address where the data is being sent from.\n  `address2` (int): The second part of the address where the data is being sent from.\n  `value` (float): The sensor value being sent from the address.\n\nOutput:\n  `return` (int): A flag indicating whether the valves should be opened (1) or not (0).", "reference_code": "# import necessary packages\nimport random\nimport numpy as np\nimport math\n\n# Constants\nMAX_NUMBER_OF_VALUES = 30\nTHRESHOLD = 2\n\n# Least-square solving code taken from the tp of the course LINFO1113 - Algorithmique num\u00e9rique\ndef choleski(a):\n    n = len(a)\n    for k in range(n):\n        try:\n            a[k,k] = math.sqrt(a[k,k] - np.dot(a[k,0:k],a[k,0:k]))\n        except ValueError:\n            raise Exception('Matrix is not positive definite')\n        for i in range(k+1,n):\n            a[i,k] = (a[i,k] - np.dot(a[i,0:k],a[k,0:k]))/a[k,k]\n    for k in range(1,n): a[0:k,k] = 0.0 #erase upper triangle\n    return a\n\ndef choleskiSol(L,b):\n    n = len(b)\n    for k in range(n):\n        b[k] = (b[k] - np.dot(L[k,0:k],b[0:k]))/L[k,k]\n    for k in range(n-1,-1,-1):\n        b[k] = (b[k] - np.dot(L[k+1:n,k],b[k+1:n]))/L[k,k]\n    return b\n\ndef polyFit(xData, yData, m):\n    a = np.zeros((m+1, m+1))\n    b = np.zeros(m+1)\n    s = np.zeros(2*m+1)\n    for i in range(len(xData)):\n        temp = yData[i]\n        for j in range(m+1):\n            b[j] += temp\n            temp *= xData[i]\n        temp = 1.0\n        for j in range(2*m+1):\n            s[j] += temp\n            temp *= xData[i]\n    for i in range(m+1):\n        for j in range(m+1):\n            a[i, j] = s[i+j]\n    return choleskiSol(choleski(a), b)\n\ndef least_square(ytable, beginIndex):\n    xtable = np.concatenate((np.arange(beginIndex, MAX_NUMBER_OF_VALUES, 1.), np.arange(0., beginIndex, 1.)))\n    ret = polyFit(xtable, ytable, 1)\n    if(ret[1] > THRESHOLD):\n        return 1\n    return 0\n\ndef add_new_data(address1, address2, value):\n    for i in valueTable:\n        if (i[0]==address1 and i[1]==address2):\n            i[3] = (i[3] + 1) % MAX_NUMBER_OF_VALUES\n            if (len(i[2]) == MAX_NUMBER_OF_VALUES):\n                i[2][i[3]] = value\n                return least_square(i[2], (i[3]+1) % MAX_NUMBER_OF_VALUES)\n            else:\n                i[2].append(value)\n                if(len(i[2]) == MAX_NUMBER_OF_VALUES):\n                    return least_square(i[2], (i[3]+1) % MAX_NUMBER_OF_VALUES)\n                return 0\n    valueTable.append([address1, address2, [value], 0])\n    return 0\n\n# main function\ndef main_solution(address1, address2, value):\n    global valueTable\n    valueTable = []\n    return add_new_data(address1, address2, value)", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    address1 = random.randint(0, 1000)\n    address2 = random.randint(0, 1000)\n    value = random.uniform(0.0, 100.0)\n    return {\n        'address1': address1,\n        'address2': address2,\n        'value': value\n    }", "io_pairs": [{"input": {"address1": 211, "address2": 170, "value": 72.06203020445052}, "output": 0}, {"input": {"address1": 545, "address2": 77, "value": 68.90591541725205}, "output": 0}, {"input": {"address1": 839, "address2": 447, "value": 20.202825612981812}, "output": 0}, {"input": {"address1": 237, "address2": 325, "value": 53.94523706728129}, "output": 0}, {"input": {"address1": 102, "address2": 888, "value": 56.658057342871736}, "output": 0}, {"input": {"address1": 764, "address2": 133, "value": 50.27680763527711}, "output": 0}, {"input": {"address1": 567, "address2": 805, "value": 67.37607745100928}, "output": 0}, {"input": {"address1": 231, "address2": 505, "value": 27.8971336577708}, "output": 0}, {"input": {"address1": 206, "address2": 851, "value": 88.28792193464471}, "output": 0}, {"input": {"address1": 340, "address2": 477, "value": 15.150839190987831}, "output": 0}], "error_log": []}
{"context": "Given a matrix of characters and a string path, determine if there is a path in the matrix that contains all the characters of the path string in the correct order. The path can start from any cell in the matrix and can move left, right, up, or down to adjacent cells. Each cell can only be visited once. What is the result of checking if the path exists in the matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (str): A string representing the matrix where each character is a cell in the matrix. The matrix is flattened into a single string.\n  `rows` (int): The number of rows in the matrix.\n  `cols` (int): The number of columns in the matrix.\n  `path` (str): The string path that needs to be checked for existence in the matrix.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the path exists in the matrix (`True` if it exists, `False` otherwise).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def hasPath(self, matrix, rows, cols, path):\n        for i in range(rows):\n            for j in range(cols):\n                if matrix[cols * i + j] == path[0]:  # \u627e\u5230\u8d77\u59cb\u4f4d\u7f6e\n                    if self.findpath(list(matrix), rows, cols, path[1:], i, j):\n                        return True\n        return False\n\n    def findpath(self, matrix, rows, cols, path, i, j):\n        if not path:\n            return True\n        matrix[cols * i + j] = '0'  # \u6807\u8bb0\u5df2\u7ecf\u8d70\u8fc7\n        if j + 1 <= cols - 1 and matrix[i * cols + j + 1] == path[0]:\n            return self.findpath(matrix, rows, cols, path[1:], i, j + 1)\n        elif j - 1 >= 0 and matrix[i * cols + j - 1] == path[0]:\n            return self.findpath(matrix, rows, cols, path[1:], i, j - 1)\n        elif i + 1 <= rows - 1 and matrix[(i + 1) * cols + j] == path[0]:\n            return self.findpath(matrix, rows, cols, path[1:], i + 1, j)\n        elif i - 1 >= 0 and matrix[(i - 1) * cols + j] == path[0]:\n            return self.findpath(matrix, rows, cols, path[1:], i - 1, j)\n        else:\n            return False\n\n# main function\ndef main_solution(matrix, rows, cols, path):\n    # Convert the matrix string to a list for easier manipulation\n    matrix_list = list(matrix)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the hasPath method to check if the path exists\n    result = solution.hasPath(matrix_list, rows, cols, path)\n    \n    # Return the result\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    rows = random.randint(2, 5)\n    cols = random.randint(2, 5)\n    matrix_size = rows * cols\n    matrix = ''.join(random.choice(string.ascii_uppercase) for _ in range(matrix_size))\n    \n    # Generate a path of reasonable length (1 to 4 characters)\n    path_length = random.randint(1, 4)\n    # Sometimes make the path exist in the matrix, sometimes not\n    if random.choice([True, False]):\n        # Ensure path exists by picking characters from the matrix\n        indices = random.sample(range(matrix_size), min(path_length, matrix_size))\n        path = ''.join(matrix[i] for i in indices)\n    else:\n        # Random path that may or may not exist\n        path = ''.join(random.choice(string.ascii_uppercase) for _ in range(path_length))\n    \n    return {\n        'matrix': matrix,\n        'rows': rows,\n        'cols': cols,\n        'path': path\n    }", "io_pairs": [{"input": {"matrix": "MKNZMUNVAL", "rows": 2, "cols": 5, "path": "XNF"}, "output": false}, {"input": {"matrix": "NJAQUQXUMENULSFRPRLS", "rows": 4, "cols": 5, "path": "L"}, "output": true}, {"input": {"matrix": "FWRT", "rows": 2, "cols": 2, "path": "S"}, "output": false}, {"input": {"matrix": "WVUPHDEGDXTTLFGD", "rows": 4, "cols": 4, "path": "IVKJ"}, "output": false}, {"input": {"matrix": "HLCNAUCZOHWY", "rows": 4, "cols": 3, "path": "XIU"}, "output": false}, {"input": {"matrix": "OYYOYCZKECNUHRWDHMOLFBKHY", "rows": 5, "cols": 5, "path": "CPXG"}, "output": false}, {"input": {"matrix": "XHERGRVVIASMGICS", "rows": 4, "cols": 4, "path": "OGJ"}, "output": false}, {"input": {"matrix": "XRCKWB", "rows": 2, "cols": 3, "path": "K"}, "output": true}, {"input": {"matrix": "HAOKEXXLIAALUYAX", "rows": 4, "cols": 4, "path": "BC"}, "output": false}, {"input": {"matrix": "UDRSAGRDSTCY", "rows": 4, "cols": 3, "path": "AU"}, "output": false}], "error_log": []}
{"context": "Given a starting point on a grid defined by its x and y coordinates, what is the path from this point to the origin (0, 0) by moving either left or down at each step?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (int): The x-coordinate of the starting point.\n  `y` (int): The y-coordinate of the starting point.\n\nOutput:\n  `return` (str): A JSON serialized string representing the path from the starting point (x, y) to the origin (0, 0). Each step in the path is represented as a tuple `(x, y)`.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef findPath(x, y, path):\n    if x >= 0 and y >= 0:\n        path.insert(0, (x, y))\n        if x == 0 and y == 0:\n            return path\n        else:\n            findPath(x-1, y, path)\n            findPath(x, y-1, path)\n    return path\n\n# main function\ndef main_solution(x, y):\n    # Convert input variables to the required format for the findPath function\n    x = int(x)\n    y = int(y)\n    \n    # Call the findPath function\n    path = findPath(x, y, [])\n    \n    # Convert the output to JSON serializable format\n    path_json = json.dumps(path)\n    \n    # Return the JSON serialized path\n    return path_json", "input_generator": "import random\n\ndef input_generator():\n    x = random.randint(0, 10)\n    y = random.randint(0, 10)\n    return {'x': x, 'y': y}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given two points \\( P1(x1, y1) \\) and \\( P2(x2, y2) \\) on a 2D plane, how many integer points (excluding \\( P1 \\) and \\( P2 \\)) lie exactly on the line segment connecting \\( P1 \\) and \\( P2 \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x1` (int): The x-coordinate of point P1.\n  `y1` (int): The y-coordinate of point P1.\n  `x2` (int): The x-coordinate of point P2.\n  `y2` (int): The y-coordinate of point P2.\n\nOutput:\n  `return` (int): The number of integer points (excluding P1 and P2) that lie on the line segment connecting P1 and P2.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef gcb(a, b):\n    if b == 0:\n        return a\n    return gcb(b, a % b)\n\n# main function\ndef main_solution(x1, y1, x2, y2):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Calculate the differences\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    # Calculate the greatest common divisor\n    m = gcb(abs(dx), abs(dy))\n    \n    # Return the number of integer points between P1 and P2\n    return m - 1", "input_generator": "import random\n\ndef input_generator():\n    x1 = random.randint(-100, 100)\n    y1 = random.randint(-100, 100)\n    x2 = x1 + random.randint(1, 100) * random.choice([-1, 1])\n    y2 = y1 + random.randint(1, 100) * random.choice([-1, 1])\n    return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2}", "io_pairs": [{"input": {"x1": -77, "y1": 61, "x2": 23, "y2": 103}, "output": 1}, {"input": {"x1": -50, "y1": -93, "x2": -148, "y2": -54}, "output": 0}, {"input": {"x1": 95, "y1": -1, "x2": 185, "y2": -56}, "output": 4}, {"input": {"x1": -73, "y1": -53, "x2": -118, "y2": -112}, "output": 0}, {"input": {"x1": 27, "y1": 14, "x2": 69, "y2": 6}, "output": 1}, {"input": {"x1": -25, "y1": -48, "x2": 32, "y2": -104}, "output": 0}, {"input": {"x1": 46, "y1": 80, "x2": 74, "y2": 122}, "output": 13}, {"input": {"x1": -54, "y1": -28, "x2": -66, "y2": -76}, "output": 11}, {"input": {"x1": 74, "y1": -94, "x2": 137, "y2": -56}, "output": 0}, {"input": {"x1": -43, "y1": -11, "x2": -79, "y2": 57}, "output": 3}], "error_log": []}
{"context": "Given a symmetric matrix with non-negative eigenvalues, what is the lower triangular matrix obtained from the Cholesky decomposition of the matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of floats): A square matrix represented as a list of lists, where each inner list represents a row of the matrix. The matrix should be symmetric and have non-negative eigenvalues.\n\nOutput:\n  `return` (dict): A dictionary with the following structure:\n  - `\"L\"` (list of lists of floats): The lower triangular matrix obtained from the Cholesky decomposition of the input matrix.\n  - `\"error\"` (string): A string indicating an error message if the input matrix does not meet the requirements for Cholesky decomposition (e.g., non-symmetric or negative eigenvalues).", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix):\n    # Convert the input matrix to a numpy array\n    a = np.array(matrix, float)\n    \n    # Check if the matrix is symmetric and has non-negative eigenvalues\n    eig_values = np.linalg.eig(a)[0]\n    if not np.all(eig_values >= 0):\n        return {\"error\": \"Matrix has negative eigenvalues\"}\n    \n    if not np.allclose(a, a.T):\n        return {\"error\": \"Matrix is not symmetric\"}\n    \n    # Perform Cholesky decomposition\n    L = np.zeros_like(a)\n    n, _ = np.shape(a)\n    for i in range(n):\n        for j in range(i, n):\n            if j == i:\n                L[j, i] = np.sqrt(a[j, i] - np.sum(L[j, :i]**2))\n            else:\n                L[j, i] = (a[j, i] - np.sum(L[j, :i] * L[i, :i])) / L[i, i]\n    \n    # Convert the output matrix L to a list of lists for JSON serialization\n    L_list = L.tolist()\n    \n    return {\"L\": L_list}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the size of the matrix (2x2 to 5x5)\n    n = random.randint(2, 5)\n    \n    # Generate a random lower triangular matrix with positive diagonal elements\n    L = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i+1):\n            if i == j:\n                L[i, j] = random.uniform(0.1, 10.0)  # Ensure positive diagonal\n            else:\n                L[i, j] = random.uniform(-5.0, 5.0)\n    \n    # Compute the symmetric positive definite matrix A = L * L^T\n    A = np.dot(L, L.T)\n    \n    # Convert to list of lists\n    matrix = A.tolist()\n    \n    return {\"matrix\": matrix}", "io_pairs": [{"input": {"matrix": [[11.487646113845887, -16.164139287017093, -16.932830823092505], [-16.164139287017093, 38.0396232646317, 31.58306906190686], [-16.932830823092505, 31.58306906190686, 40.724147353796425]]}, "output": {"L": [[3.3893430209770576, 0.0, 0.0], [-4.769106929270736, 3.9109132388501733, 0.0], [-4.9959035477652005, 1.9834423216640327, 3.439629580617003]]}}, {"input": {"matrix": [[48.04551696397374, 33.93262034450323, 31.100375722393515], [33.93262034450323, 24.03575379511622, 22.831387618219367], [31.100375722393515, 22.831387618219367, 38.37046256851423]]}, "output": {"L": [[6.931487355825857, 0.0, 0.0], [4.89543132701283, 0.2655295042318782, 0.0], [4.486825716598027, 3.263066561454365, 2.755223071351432]]}}, {"input": {"matrix": [[48.92065242258943, -13.747352939387419, -13.641906923301317], [-13.747352939387419, 22.191741429608236, 24.709144954742385], [-13.641906923301317, 24.709144954742385, 109.07767678604631]]}, "output": {"L": [[6.994330019565092, 0.0, 0.0], [-1.965499611961723, 4.2811858993725735, 0.0], [-1.9504236839184164, 4.876122749983642, 9.027566181776148]]}}, {"input": {"matrix": [[85.52970311562879, 39.10918867931105, -26.769972851081835], [39.10918867931105, 75.52305802129543, -11.390940844048673], [-26.769972851081835, -11.390940844048673, 38.00568300607925]]}, "output": {"L": [[9.2482270255238, 0.0, 0.0], [4.228830950124301, 7.592104241682027, 0.0], [-2.894605936597414, 0.11193976030810232, 5.441912252871818]]}}, {"input": {"matrix": [[33.78371402992431, -28.765841336925384, 4.061598867553298], [-28.765841336925384, 76.28162953314468, -5.4782491695683255], [4.061598867553298, -5.4782491695683255, 77.55831671084681]]}, "output": {"L": [[5.8123759367339884, 0.0, 0.0], [-4.949067584415246, 7.196412966057112, 0.0], [0.6987846126545518, -0.28068384959544984, 8.774464847074169]]}}, {"input": {"matrix": [[59.35648542762534, 28.1820539865068, -12.474831138990126], [28.1820539865068, 66.10972991638083, -25.63373948157621], [-12.474831138990126, -25.63373948157621, 79.4339208274673]]}, "output": {"L": [[7.704316025944506, 0.0, 0.0], [3.6579566429522004, 7.2614794026191865, 0.0], [-1.6192003413386438, -2.7144296284303238, 8.333305639083193]]}}, {"input": {"matrix": [[0.6305177213188581, 1.5930305373048135, -3.233351427016098], [1.5930305373048135, 31.25146787764103, -33.40401869777627], [-3.233351427016098, -33.40401869777627, 40.90514853035033]]}, "output": {"L": [[0.7940514601200971, 0.0, 0.0], [2.006205664635229, 5.2179121024435196, 0.0], [-4.071967107178502, -4.836190170648737, 0.9672109603014241]]}}, {"input": {"matrix": [[36.542616292747574, 28.876009704306227], [28.876009704306227, 59.7921427825812]]}, "output": {"L": [[6.045048907390872, 0.0], [4.776803322302568, 6.080649044519865]]}}, {"input": {"matrix": [[55.303790268348564, -18.023374542647268], [-18.023374542647268, 34.17717130080178]]}, "output": {"L": [[7.436651818415903, 0.0], [-2.4235872517272785, 5.320093620799055]]}}, {"input": {"matrix": [[0.030928743867429345, 0.8668750236347451, -0.053399649077212744], [0.8668750236347451, 29.364738196204964, 7.924821311091439], [-0.053399649077212744, 7.924821311091439, 21.8608289445355]]}, "output": {"L": [[0.17586569838211585, 0.0, 0.0], [4.929187622200347, 2.251188037759585, 0.0], [-0.3036387969255241, 4.18512969707007, 2.062358321010029]]}}], "error_log": []}
{"context": "Given a sequence of integers, determine whether this sequence could represent the post-order traversal of a Binary Search Tree (BST). What is the result of the verification?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sequence` (list of int): A list of integers representing the sequence to be verified as the post-order traversal of a Binary Search Tree (BST).\nOutput:\n  `return` (str): A string \"Yes\" if the sequence is a valid post-order traversal of a BST, otherwise \"No\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, sequence):\n        if not sequence:\n            return False\n        root = sequence[-1]\n        index = 0\n        l = len(sequence)\n        for i in range(l-1):\n            index = i\n            if sequence[i] > root:\n                break\n                \n        for i in range(index+1,l-1):\n            if sequence[i] < root:\n                return False\n        left = True\n        \n        if index > 0:\n            left = self.VerifySquenceOfBST(sequence[:index])\n        right = True\n        if index < l - 1:\n            right = self.VerifySquenceOfBST(sequence[index:l-1])\n        return left and right\n\n# main function\ndef main_solution(sequence):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  S = Solution()\n  result = S.VerifySquenceOfBST(sequence)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return \"Yes\" if result else \"No\"", "input_generator": "import random\n\ndef input_generator():\n    def generate_sequence(length):\n        if length == 0:\n            return []\n        sequence = []\n        for _ in range(length):\n            sequence.append(random.randint(1, 100))\n        # Ensure it's a possible post-order traversal by constructing a BST and then getting its post-order\n        # But for simplicity, sometimes return a random sequence that may or may not be valid\n        if random.choice([True, False]):\n            return sequence\n        else:\n            # Generate a valid BST post-order sequence\n            in_order = sorted(sequence)\n            stack = []\n            post_order = []\n            def build_post(start, end):\n                if start >= end:\n                    return\n                root_pos = random.randint(start, end-1)\n                build_post(start, root_pos)\n                build_post(root_pos+1, end)\n                post_order.append(in_order[root_pos])\n            build_post(0, len(in_order))\n            return post_order\n    \n    length = random.randint(0, 20)\n    sequence = generate_sequence(length)\n    return {\"sequence\": sequence}", "io_pairs": [{"input": {"sequence": [49, 29, 84, 72, 98, 93, 23]}, "output": "Yes"}, {"input": {"sequence": [9, 20, 32, 39, 42, 43, 48, 49, 41, 12, 9, 59, 65, 87, 56, 52]}, "output": "Yes"}, {"input": {"sequence": []}, "output": "No"}, {"input": {"sequence": [42, 27, 20, 21, 54, 46]}, "output": "No"}, {"input": {"sequence": [5, 79, 68, 65, 17, 89]}, "output": "Yes"}, {"input": {"sequence": [100]}, "output": "Yes"}, {"input": {"sequence": [43, 41, 60, 60, 63, 50, 87, 74, 64]}, "output": "Yes"}, {"input": {"sequence": [50, 51, 34, 66, 33, 73, 22, 88, 81, 96, 92]}, "output": "Yes"}, {"input": {"sequence": [15, 22, 27, 26, 23, 35, 28, 28, 40, 46, 60, 59, 68, 83, 80, 62, 39]}, "output": "Yes"}, {"input": {"sequence": [43, 21, 55]}, "output": "Yes"}], "error_log": []}
{"context": "Given two integers, `a` and `b`, what are the coefficients `x1` and `y1` such that the equation `aX + bY = gcd(a, b)` holds true, and what is the greatest common divisor (gcd) of `a` and `b`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): The first integer.\n  `b` (int): The second integer.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `x1` (int): The coefficient of `a` in the equation `aX + bY = gcd(a, b)`.\n    - `y1` (int): The coefficient of `b` in the equation `aX + bY = gcd(a, b)`.\n    - `gcd` (int): The greatest common divisor of `a` and `b`.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef extend_gcd(a, b):\n    if b == 0:\n        return 1, 0, a\n    x2, y2, remain = extend_gcd(b, a % b)\n\n    x1 = y2\n    y1 = x2 - a // b * y2\n\n    return x1, y1, remain\n\n# main function\ndef main_solution(a, b):\n    # Convert input arguments to the required types\n    a = int(a)\n    b = int(b)\n    \n    # Call the extend_gcd function\n    x1, y1, gcd_value = extend_gcd(a, b)\n    \n    # Convert the output to JSON serializable format\n    result = {\n        \"x1\": x1,\n        \"y1\": y1,\n        \"gcd\": gcd_value\n    }\n    \n    return result", "input_generator": "import random\n\ndef input_generator():\n    a = random.randint(1, 1000)\n    b = random.randint(1, 1000)\n    return {'a': a, 'b': b}", "io_pairs": [{"input": {"a": 541, "b": 30}, "output": {"x1": 1, "y1": -18, "gcd": 1}}, {"input": {"a": 610, "b": 231}, "output": {"x1": 64, "y1": -169, "gcd": 1}}, {"input": {"a": 694, "b": 777}, "output": {"x1": 337, "y1": -301, "gcd": 1}}, {"input": {"a": 624, "b": 902}, "output": {"x1": 146, "y1": -101, "gcd": 2}}, {"input": {"a": 131, "b": 768}, "output": {"x1": 299, "y1": -51, "gcd": 1}}, {"input": {"a": 833, "b": 747}, "output": {"x1": -304, "y1": 339, "gcd": 1}}, {"input": {"a": 42, "b": 479}, "output": {"x1": -57, "y1": 5, "gcd": 1}}, {"input": {"a": 78, "b": 783}, "output": {"x1": -10, "y1": 1, "gcd": 3}}, {"input": {"a": 286, "b": 387}, "output": {"x1": -23, "y1": 17, "gcd": 1}}, {"input": {"a": 230, "b": 223}, "output": {"x1": 32, "y1": -33, "gcd": 1}}], "error_log": []}
{"context": "Given a system of linear equations represented by a 3x4 matrix, what is the reduced row echelon form of the matrix after performing a series of row operations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of floats): A 3x4 matrix represented as a list of lists, where each inner list represents a row of the matrix.\n\nOutput:\n  `return` (list of lists of floats): The resulting matrix in reduced row echelon form, represented as a list of lists, where each inner list represents a row of the matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix):\n    # Convert the input matrix to a numpy array\n    A = np.asarray(matrix, dtype=np.float32)\n    \n    # Perform row operations to reduce the matrix to row echelon form\n    A[[0,1]] = A[[1,0]]  # Swap the first and second rows\n    A[2] -= 3 * A[0]     # Subtract three times the first row from the third row\n    A[1] /= 2            # Divide the second row by 2\n    A[0] -= 2 * A[1]     # Subtract two times the second row from the first row\n    A[2] += 6 * A[1]     # Add six times the second row to the third row\n    A[1] -= 0.5 * A[2]   # Subtract half of the third row from the second row\n    \n    # Convert the resulting matrix back to a list of lists\n    result = A.tolist()\n    \n    # Return the resulting matrix in row echelon form\n    return result", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a 3x3 matrix with random integers between -10 and 10\n    matrix = [[random.randint(-10, 10) for _ in range(3)] for _ in range(3)]\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[9, -10, 5], [6, 0, 9], [-3, 6, 3]]}, "output": [[-3.0, 10.0, 4.0], [1.5, 7.0, 7.0], [6.0, -24.0, -9.0]]}, {"input": {"matrix": [[-7, 4, -8], [10, 5, 7], [6, 2, -7]]}, "output": [[17.0, 1.0, 15.0], [19.0, 2.5, 22.0], [-45.0, -1.0, -52.0]]}, {"input": {"matrix": [[1, -10, -10], [-7, 4, 6], [-1, 5, 2]]}, "output": [[-8.0, 14.0, 16.0], [-11.0, 13.5, 18.0], [23.0, -37.0, -46.0]]}, {"input": {"matrix": [[-6, -7, 10], [2, -1, -3], [7, -1, -5]]}, "output": [[8.0, 6.0, -13.0], [5.5, 6.0, -12.0], [-17.0, -19.0, 34.0]]}, {"input": {"matrix": [[8, 1, 0], [8, 7, 6], [-8, -9, 5]]}, "output": [[0.0, 6.0, 6.0], [8.0, 14.0, 6.5], [-8.0, -27.0, -13.0]]}, {"input": {"matrix": [[-8, 6, -5], [-1, 4, -8], [3, 2, 1]]}, "output": [[7.0, -2.0, -3.0], [5.0, -1.0, -7.5], [-18.0, 8.0, 10.0]]}, {"input": {"matrix": [[-4, -1, -6], [1, 6, -10], [-10, -1, 7]]}, "output": [[5.0, 7.0, -4.0], [10.5, 10.5, -12.5], [-25.0, -22.0, 19.0]]}, {"input": {"matrix": [[3, 7, -4], [-9, -10, 0], [4, 7, 9]]}, "output": [[-12.0, -17.0, 4.0], [-18.5, -25.5, -0.5], [40.0, 58.0, -3.0]]}, {"input": {"matrix": [[4, -2, 10], [6, 9, -8], [-6, -9, -1]]}, "output": [[2.0, 11.0, -18.0], [8.0, 20.0, -21.5], [-12.0, -42.0, 53.0]]}, {"input": {"matrix": [[-8, 7, -2], [8, 10, 0], [4, 6, 6]]}, "output": [[16.0, 3.0, 2.0], [18.0, 5.0, -1.0], [-44.0, -3.0, 0.0]]}], "error_log": []}
{"context": "Given a scenario where random numbers are generated within a specified range, what is the probability that a duplicate number will be generated after a certain number of random numbers have been drawn? Specifically, if `n` random numbers are generated within a range of `d`, what is the probability of at least one duplicate number occurring?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): Number of random numbers to generate.\n  `d` (int): Range of the random numbers.\n\nOutput:\n  `return` (float): Probability of generating a duplicate random number.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# main function\ndef main_solution(n, d):\n    \"\"\"Calculate the probability of generating a duplicate random number after\n    generating \"n\" random numbers in the range \"d\".\n\n    Args:\n        n (int): Number of random numbers to generate.\n        d (int): Range of the random numbers.\n\n    Returns:\n        float: Probability of generating a duplicate random number.\n    \"\"\"\n    # Formula taken from: https://en.wikipedia.org/wiki/Birthday_problem\n    probability = 1 - math.e ** (-n**2 / (2 * d))\n    return probability", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 1000)\n    d = random.randint(n, 10000)\n    return {'n': n, 'd': d}", "io_pairs": [{"input": {"n": 979, "d": 3422}, "output": 1.0}, {"input": {"n": 238, "d": 6622}, "output": 0.9861151311336754}, {"input": {"n": 574, "d": 694}, "output": 1.0}, {"input": {"n": 855, "d": 5029}, "output": 1.0}, {"input": {"n": 266, "d": 1595}, "output": 0.9999999997671355}, {"input": {"n": 480, "d": 2737}, "output": 1.0}, {"input": {"n": 867, "d": 9827}, "output": 1.0}, {"input": {"n": 203, "d": 3188}, "output": 0.9984401147784959}, {"input": {"n": 953, "d": 5372}, "output": 1.0}, {"input": {"n": 691, "d": 4084}, "output": 1.0}], "error_log": []}
{"context": "In ancient Sparta, a unique method of encoding messages was used to ensure secure communication during military campaigns. This method, known as the Spartans Cipher, involves writing the message horizontally across a series of slides and then reading it column-wise to produce the encoded message. Given a message and the number of slides, what is the encoded message after applying the Spartans Cipher?\n\nThe input and output requirements are as follows:\n\nInput:\n  `message` (str): The message to be encoded using the Spartans Cipher.\n  `n_Slide` (int): The number of slides (columns) to use for encoding the message.\n\nOutput:\n  `return` (str): The encoded message after applying the Spartans Cipher.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Spartan:\n    def __init__(self, slides):\n        self.slides = slides\n\n    def encode(self, msg):\n        if msg == '':\n            return msg\n        slide_size = len(msg) // self.slides if len(msg) % self.slides == 0 else len(msg) // self.slides + 1\n        \n        slides = [[] for slide in range(slide_size)]\n        for n in range(len(msg)):\n            try:\n                slides[n].append(msg[n])\n            except IndexError:\n                slides[n % slide_size].append(msg[n])\n        \n        slides = [''.join(slide) for slide in slides]\n        ns = []\n        for slide in slides:\n            while len(slide) < self.slides:\n                slide += ' '\n            ns.append(slide)\n        \n        tr = ''.join(ns)\n        \n        while tr[0] == ' ':\n            tr = tr[1:]\n        while tr[-1] == ' ':\n            tr = tr[:-1]\n        \n        return tr\n\n# main function\ndef main_solution(message, n_Slide):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    msg = Spartan(n_Slide)\n    encoded_message = msg.encode(message)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return encoded_message", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random message length between 5 and 50 characters\n    message_length = random.randint(5, 50)\n    # Generate a random message using letters, digits, and spaces\n    message = ''.join(random.choices(string.ascii_letters + string.digits + ' ', k=message_length))\n    # Generate a random number of slides between 2 and 10\n    n_Slide = random.randint(2, 10)\n    \n    return {\n        'message': message,\n        'n_Slide': n_Slide\n    }", "io_pairs": [{"input": {"message": "6XpiOjk9PRMO7QJAaXAWh9n692qqWxbIOsTOHswxR8", "n_Slide": 4}, "output": "6OnsX76TpQ9OiJ2HOAqsjaqwkXWx9AxRPWb8RhI M9O"}, {"input": {"message": "lkdl4qVHbIWgq9qlV3F0E3XqwngKf7SeJxSr", "n_Slide": 5}, "output": "lbVwJkI3nxdWFgSlg0Kr4qEf q937 VqXS Hlqe"}, {"input": {"message": "Eu5apvbx", "n_Slide": 3}, "output": "Eabupx5v"}, {"input": {"message": "6AdsunOncVJFhGPGje", "n_Slide": 5}, "output": "6uchjAnVGedOJP snFG"}, {"input": {"message": "AtpdKKklFk4wQRuhiDYikN4k69 bzBEHBKjp1hJR1", "n_Slide": 2}, "output": "ANt4pkd6K9K kblzFBkE4HwBQKRjuph1ihDJYRi1k"}, {"input": {"message": "cy6tTef3uScvqGffjS58Pkz1Vx2k", "n_Slide": 4}, "output": "c3fkyufz6Sj1tcSVTv5xeq82fGPk"}, {"input": {"message": "jaR8qlqjQXrCn1MpPFvyh4", "n_Slide": 7}, "output": "jqQnPh alX1F4 RqrMv  8jCpy"}, {"input": {"message": " exR4925yUh31F2TNi4QXmIvT", "n_Slide": 5}, "output": "9hTXe23Nmx51iIRyF4v4U2QT"}, {"input": {"message": "6GnafGGpg0 SI8UwYciXwZJvpIDL1", "n_Slide": 3}, "output": "6 wGSZnIJa8vfUpGwIGYDpcLgi10X"}, {"input": {"message": "fJ3xllivY9v311q3p", "n_Slide": 4}, "output": "flv3Ji3p3v1 xY1 l9q"}], "error_log": []}
{"context": "In the classic Towers of Hanoi puzzle, how many moves are required to transfer a given number of disks from the first tower to the second tower, using a third tower as an auxiliary? The number of disks is denoted by `N_disks`.\n\nThe input and output requirements are as follows:\n\nInput:\n  `N_disks` (int): The number of disks to be moved in the Towers of Hanoi problem. It should be a positive integer.\n\nOutput:\n  `return` (int): The number of basic operations (moves) required to solve the Towers of Hanoi problem with `N_disks` disks.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef moveDisk(out, to):\n    disk = out[-1]  # top element\n    out.remove(disk)\n    to.append(disk)\n\n    global basicOperationCounter\n    basicOperationCounter += 1\n\ndef move(n, out, to, work):\n    if n > 1:\n        move(n - 1, out, work, to)\n    moveDisk(out, to)\n    if n > 1:\n        move(n - 1, work, to, out)\n\n# main function\ndef main_solution(N_disks):\n    # Initialize the towers\n    tower1 = [N_disks - i for i in range(N_disks)]\n    tower2 = []\n    tower3 = []\n\n    # Initialize the basic operation counter\n    global basicOperationCounter\n    basicOperationCounter = 0\n\n    # Perform the move operation\n    move(N_disks, tower1, tower2, tower3)\n\n    # Return the number of steps taken\n    return basicOperationCounter", "input_generator": "import random\n\ndef input_generator():\n    return {'N_disks': random.randint(1, 10)}", "io_pairs": [{"input": {"N_disks": 2}, "output": 3}, {"input": {"N_disks": 9}, "output": 511}, {"input": {"N_disks": 3}, "output": 7}, {"input": {"N_disks": 5}, "output": 31}, {"input": {"N_disks": 4}, "output": 15}, {"input": {"N_disks": 1}, "output": 1}, {"input": {"N_disks": 7}, "output": 127}, {"input": {"N_disks": 10}, "output": 1023}, {"input": {"N_disks": 6}, "output": 63}, {"input": {"N_disks": 8}, "output": 255}], "error_log": []}
{"context": "Given a 2D grid of characters and a word, determine if the word can be constructed from letters of sequentially adjacent cells, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. What is the result of checking if the word exists in the grid?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (List[List[str]]): A 2D list of characters representing the grid.\n  `word` (str): The word to be searched in the grid.\n\nOutput:\n  `return` (bool): True if the word exists in the grid, False otherwise.", "reference_code": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    orientation = [(0, -1), (-1, 0), (1, 0), (0, 1)]\n\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        m = len(board)\n        if m == 0: return False\n        n = len(board[0])\n        mark = [[False for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if self.DFS(board, word, 0, i, j, mark, m, n):\n                    return True\n        return False\n\n    def DFS(self, board, word, index, start1, start2, mark, m, n):\n        if index == len(word)-1:\n            return word[index] == board[start1][start2]\n        if board[start1][start2] == word[index]:\n            mark[start1][start2] = True\n            for k in self.orientation:\n                start_x = start1+k[0]\n                start_y = start2+k[1]\n                if 0 <= start_x < m and 0 <= start_y < n:\n                    if not mark[start_x][start_y] and self.DFS(board, word, index+1, start_x, start_y, mark, m, n):\n                        return True\n            mark[start1][start2] = False\n        return False\n\n# main function\ndef main_solution(board: List[List[str]], word: str) -> bool:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.exist(board, word)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Randomly decide the size of the board (between 1x1 and 10x10)\n    rows = random.randint(1, 10)\n    cols = random.randint(1, 10)\n    \n    # Generate a random board with lowercase letters\n    board = []\n    for _ in range(rows):\n        row = [random.choice(string.ascii_lowercase) for _ in range(cols)]\n        board.append(row)\n    \n    # Generate a random word with length between 1 and 8\n    word_length = random.randint(1, 8)\n    word = ''.join(random.choice(string.ascii_lowercase) for _ in range(word_length))\n    \n    # Occasionally make the word exist in the board\n    if random.random() < 0.3:\n        # Pick a random position in the board\n        i = random.randint(0, rows - 1)\n        j = random.randint(0, cols - 1)\n        # Start the word from this position, if possible\n        max_possible_length = min(8, rows - i, cols - j)\n        if max_possible_length > 0:\n            word_length = random.randint(1, max_possible_length)\n            word = board[i][j]\n            for k in range(1, word_length):\n                word += board[i + k][j + k]\n    \n    return {'board': board, 'word': word}", "io_pairs": [{"input": {"board": [["o", "o"], ["q", "j"], ["t", "l"]], "word": "ul"}, "output": false}, {"input": {"board": [["c", "g", "z", "c", "p", "w", "h"]], "word": "h"}, "output": true}, {"input": {"board": [["i"], ["x"]], "word": "b"}, "output": false}, {"input": {"board": [["y", "n", "y", "w"], ["x", "x", "r", "t"]], "word": "x"}, "output": true}, {"input": {"board": [["j", "j", "e", "l", "s", "e", "i", "v"]], "word": "e"}, "output": true}, {"input": {"board": [["m", "x", "t", "m", "j", "e", "r", "h", "x", "h"]], "word": "m"}, "output": true}, {"input": {"board": [["l", "d", "g", "k", "q"]], "word": "l"}, "output": true}, {"input": {"board": [["m", "a", "t"]], "word": "a"}, "output": true}, {"input": {"board": [["z", "o", "j"]], "word": "pfgstrb"}, "output": false}, {"input": {"board": [["d", "t", "n", "f", "x", "x"]], "word": "okeckrhs"}, "output": false}], "error_log": []}
{"context": "LL has drawn 5 cards from a deck that includes 2 jokers (represented as 0) and cards from Ace (1) to King (13). He wants to know if these cards can form a straight, where the jokers can be used as any card and Ace is considered as 1. Can you determine if the drawn cards can form a straight?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numbers` (list of integers): A list of 5 integers representing the poker cards. The numbers can be 0 (representing the jokers), 1 to 13 (representing the cards from Ace to King).\nOutput:\n  `return` (boolean): True if the cards can form a straight, False otherwise.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(numbers):\n    # Input: numbers (list of integers): A list of 5 integers representing the poker cards. The numbers can be 0 (representing the jokers), 1 to 13 (representing the cards from Ace to King).\n    # Output: return (boolean): True if the cards can form a straight, False otherwise.\n    \n    if not numbers or len(numbers) != 5:\n        return False\n    \n    numbers.sort()\n    zero_count = numbers.count(0)\n    \n    for i in range(4):\n        if numbers[i] != 0:\n            if numbers[i] == numbers[i + 1]:\n                return False\n            zero_count -= (numbers[i + 1] - numbers[i] - 1)\n            if zero_count < 0:\n                return False\n    \n    return True", "input_generator": "import random\n\ndef input_generator():\n    choices = [\n        [0, 0, 0, 0, 0],\n        [1, 2, 3, 4, 5],\n        [2, 3, 4, 5, 6],\n        [10, 11, 12, 13, 0],\n        [1, 3, 5, 7, 9],\n        [0, 0, 1, 2, 3],\n        [0, 0, 0, 1, 13],\n        [random.randint(1, 13) for _ in range(5)],\n        [0] + [random.randint(1, 13) for _ in range(4)],\n        [0, 0] + [random.randint(1, 13) for _ in range(3)],\n        [random.choice([0, random.randint(1, 13)]) for _ in range(5)]\n    ]\n    numbers = random.choice(choices)\n    return {'numbers': numbers}", "io_pairs": [{"input": {"numbers": [1, 2, 3, 4, 5]}, "output": true}, {"input": {"numbers": [0, 10, 11, 12, 13]}, "output": true}, {"input": {"numbers": [0, 0, 2, 7, 12]}, "output": false}, {"input": {"numbers": [0, 0, 0, 1, 13]}, "output": false}, {"input": {"numbers": [2, 3, 4, 5, 6]}, "output": true}, {"input": {"numbers": [0, 1, 4, 8, 12]}, "output": false}, {"input": {"numbers": [0, 0, 0, 0, 0]}, "output": true}, {"input": {"numbers": [5, 8, 10, 10, 11]}, "output": false}, {"input": {"numbers": [0, 10, 11, 12, 13]}, "output": true}, {"input": {"numbers": [0, 1, 5, 7, 8]}, "output": false}], "error_log": []}
{"context": "Given a number, determine whether it is abundant, perfect, or hyperperfect. Additionally, if the number is perfect, find its Mersenne partner. What is the type of the number and what is the total sum of its divisors?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer number to be checked for its abundance, perfectness, or hyperperfectness.\n\nOutput:\n  `return` (tuple): A tuple containing the type of number (`str`) and the total sum of its divisors (`int`). If the number is perfect, it also includes the Mersenne partner (`int`).", "reference_code": "# import necessary packages\nimport math\nfrom random import uniform\n\n# all class and function definitions in the code file, if any\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i*i != n:\n                large_divisors.append(n / i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef substitution(vz):\n    u = (1 + math.sqrt(1 + 8 * vz)) / 2\n    x = math.log2(u)\n    return x\n\ndef abundant(n):\n    abundant = list(divisorGenerator(n))\n    total = 0\n    abundant.remove(n)\n    for i in abundant:\n        total += i\n\n    if total % n == 0 and total > n:\n        return \"hyperperfect\", total\n    elif total > n:\n        return \"abundant\", total\n    elif total < n:\n        return \"not abundant\", total\n    elif total == n:\n        p = substitution(n)\n        mersenne = 2**p - 1\n        return \"perfect\", total, mersenne\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = abundant(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a mix of small, medium, and large numbers, including some edge cases\n    choices = [\n        random.randint(2, 100),  # Small numbers\n        random.randint(101, 10000),  # Medium numbers\n        random.randint(10001, 100000),  # Large numbers\n        6, 28, 496, 8128,  # Known perfect numbers\n        random.choice([12, 18, 20, 24, 30, 36, 40, 42, 48, 54, 56, 60, 66, 70, 72, 78, 80, 84, 88, 90, 96, 100])  # Known abundant numbers\n    ]\n    n = random.choice(choices)\n    return {'n': n}", "io_pairs": [{"input": {"n": 496}, "output": ["perfect", 496.0, 31.0]}, {"input": {"n": 7190}, "output": ["not abundant", 5770.0]}, {"input": {"n": 30}, "output": ["abundant", 42.0]}, {"input": {"n": 28}, "output": ["perfect", 28.0, 7.0]}, {"input": {"n": 8128}, "output": ["perfect", 8128.0, 127.0]}, {"input": {"n": 6}, "output": ["perfect", 6.0, 3.0]}, {"input": {"n": 4496}, "output": ["not abundant", 4246.0]}, {"input": {"n": 42}, "output": ["abundant", 54.0]}, {"input": {"n": 50466}, "output": ["abundant", 58398.0]}, {"input": {"n": 3253}, "output": ["not abundant", 1]}], "error_log": []}
{"context": "Given a string of unique characters, how can we generate all possible permutations of the string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string of unique characters for which permutations need to be generated.\n\nOutput:\n  `return` (list of str): A list of all possible permutations of the input string, where each permutation is represented as a string.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\ndef __permutations_4(s, current_idx, str_so_far, taken, result):\n    if current_idx == len(s):\n        result.append(''.join(str_so_far[:]))\n        return\n\n    for idx in range(len(s)):\n        if not taken[idx]:\n            char = s[idx]\n            taken[idx] = True\n            str_so_far.append(char)\n            __permutations_4(s, current_idx + 1, str_so_far, taken, result)\n            taken[idx] = False\n            str_so_far.remove(char)\n\n    return\n\ndef permutations_4(s):\n    result = []\n    str_so_far = []\n    taken = [False] * len(s)\n    __permutations_4(s, 0, str_so_far, taken, result)\n    return result\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    input_string = list(input_string)\n    \n    # Get the permutations using the fourth approach\n    result = permutations_4(input_string)\n    \n    # Convert the result to a JSON serializable format\n    result = [''.join(perm) for perm in result]\n    \n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    chars = random.choices(string.ascii_lowercase, k=length)\n    input_string = ''.join(chars)\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "rv"}, "output": ["rv", "vr"]}, {"input": {"input_string": "t"}, "output": ["t"]}, {"input": {"input_string": "jgo"}, "output": ["jgo", "jog", "gjo", "goj", "ojg", "ogj"]}, {"input": {"input_string": "mqb"}, "output": ["mqb", "mbq", "qmb", "qbm", "bmq", "bqm"]}, {"input": {"input_string": "u"}, "output": ["u"]}, {"input": {"input_string": "z"}, "output": ["z"]}, {"input": {"input_string": "n"}, "output": ["n"]}, {"input": {"input_string": "wld"}, "output": ["wld", "wdl", "lwd", "ldw", "dwl", "dlw"]}, {"input": {"input_string": "ef"}, "output": ["ef", "fe"]}, {"input": {"input_string": "v"}, "output": ["v"]}], "error_log": []}
{"context": "Given a set of data points representing a signal, how can we determine the magnitude of the Discrete Fourier Transform (DFT) coefficients for this signal?\n\nThe input and output requirements are as follows:\n\nInput:\n  `signal` (list of float): A list of floating-point numbers representing the signal to be transformed using the Discrete Fourier Transform (DFT).\n\nOutput:\n  `return` (list of float): A list of floating-point numbers representing the magnitude of the DFT coefficients for the input signal.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef getYk(Sig, n):\n    N = len(Sig)\n    Yk = 0\n    for k in range(0, N):\n        w = complex(math.cos(-2*math.pi*n*k/N), (math.sin(-2*math.pi*n*k/N)))\n        currTerm = float(Sig[k])*w\n        Yk += currTerm\n    return Yk\n\ndef DFT(Sig):\n    returnable = []\n    n = 0\n    for elem in Sig:\n        yk = getYk(Sig, n)\n        realpart = yk.real\n        imagpart = yk.imag * 1j\n        returnable = returnable + [abs(realpart + imagpart)]\n        n += 1\n    return returnable\n\n# main function\ndef main_solution(signal):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # Convert the input signal to a list of floats if necessary\n  signal = [float(x) for x in signal]\n  \n  # Compute the Discrete Fourier Transform\n  dft_result = DFT(signal)\n  \n  # Convert the result to a list of floats\n  dft_result = [float(x) for x in dft_result]\n  \n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return dft_result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    signal_length = random.randint(4, 16)  # Reasonable length for DFT\n    signal = [random.uniform(-10.0, 10.0) for _ in range(signal_length)]\n    return {'signal': signal}", "io_pairs": [{"input": {"signal": [3.247098442483317, -2.16906635838086, -9.287304635528074, 4.00394487358156, 1.7689777073931268, -3.4139315369115515, 3.4979571492350043, 2.8932621249057906, -8.656935101918247, -4.309055443401249, -5.548691697538919, 6.002704328621334, 1.4983064847838747, 1.937708644790506, -8.340877611008242]}, "output": [16.875902628892625, 1.2431114849456648, 24.299233048710484, 16.052889965748076, 22.70750738119592, 28.21834644543915, 13.794777708518021, 20.540207154938482, 20.5402071549385, 13.794777708517998, 28.218346445439106, 22.707507381195917, 16.052889965747994, 24.299233048710313, 1.2431114849456064]}, {"input": {"signal": [0.49948301284404195, -7.25098684962407, -4.75544224083804, 9.491224309040398, -7.20715403438242, 5.478742032199854, 7.9637070986583005, 9.831314481260598, 6.166715870955418, -6.143793062576086, -2.5595794037437125, 7.3734006370316365]}, "output": [18.88763185082592, 24.86175215337132, 17.02781829284411, 34.63241570973046, 20.33467620204062, 19.795428853093526, 18.67217124383874, 19.79542885309351, 20.334676202040676, 34.63241570973046, 17.02781829284408, 24.86175215337135]}, {"input": {"signal": [6.3866319023454885, 6.916130357459643, -0.3168533741169597, -1.3954655765691406, -9.388828348197912, 3.2055103693609137, 7.647255016901266, 8.910365541295107, 4.165317029866749, -0.5541196205123651]}, "output": [25.575943297832787, 21.48495434852031, 26.792320206296438, 3.6656806573882834, 12.89641284840284, 8.588898844235526, 12.89641284840284, 3.6656806573882665, 26.792320206296427, 21.48495434852031]}, {"input": {"signal": [1.9992131341295831, 9.056640845820468, 1.879522575750979, -1.3485090130264084, 4.195300616977111, 5.63751980201577, 7.779586847999081, -7.367260083943787, 2.9998769630530457]}, "output": [24.83189168877584, 5.088521469691745, 22.50762141598805, 4.018194537593987, 18.26292310576701, 18.262923105766987, 4.0181945375940185, 22.507621415988083, 5.088521469691725]}, {"input": {"signal": [5.1449676012893875, 0.13471139907125718, 3.4617703219380136, 0.9321669223965952, -1.689023211512719, -7.788081519310676, -9.029632826361162, 2.849227034998112, -2.0651361754673125, 5.493066764160599, -2.8942762599394296, 7.144973877611399, 0.6835701810838941, -4.151747593885595]}, "output": [1.7734434839276378, 21.062584500681773, 21.812331789284904, 10.349992221155055, 15.391764457366953, 9.869216126318006, 26.56244523211377, 11.002077254011018, 26.56244523211387, 9.869216126317973, 15.391764457366923, 10.349992221155095, 21.812331789284904, 21.06258450068177]}, {"input": {"signal": [-2.331255599825184, -5.054389537324, 9.583658700301985, 8.628025786434314, 0.9794119452656176, -1.2375681016275095, 8.112829048073348, 0.9993140334263231, -2.8466945796640815, 9.030325858431553, -7.116458971778421]}, "output": [18.747198581713945, 17.03879372629432, 20.0528599653475, 24.521897643918997, 18.015834657971215, 21.06514752808385, 21.065147528083852, 18.015834657971222, 24.521897643919015, 20.05285996534749, 17.038793726294276]}, {"input": {"signal": [-7.695495308158138, 4.013936320113336, -7.361566706903582, 3.4240158690594154, -7.583726141958782]}, "output": [15.20283596784775, 7.314828312639077, 18.106204356337933, 18.10620435633794, 7.31482831263908]}, {"input": {"signal": [3.799515462690808, 8.039344406190569, -3.653863036531096, 8.927895577973878, -1.922552813859964, 2.104520330424055, 6.49816916119428, -1.7174708689950346, 1.8724533443924365, 3.272077436051413, -3.3269782124639775, -2.9100612255082403]}, "output": [20.98304956155913, 9.692667625706473, 10.1640405109188, 10.050091759006971, 23.469896932870206, 19.53005503480359, 14.449561750714157, 19.53005503480359, 23.4698969328702, 10.050091759006968, 10.164040510918817, 9.692667625706422]}, {"input": {"signal": [-6.269201686318788, 4.626217880740162, -8.067303543863073, -3.891397219731056, 9.137215193345963, 2.4809970898974854, -8.812281036244503, 1.316000356254012, 8.176565554407969, -1.8081275500468852, 6.630428153148774]}, "output": [3.5191131915900584, 9.896441988574287, 18.045638195786932, 28.630209936382524, 23.484935344375472, 23.04917075224879, 23.04917075224881, 23.48493534437546, 28.63020993638253, 18.045638195786943, 9.896441988574239]}, {"input": {"signal": [2.5047698565966936, -9.821727405303335, -0.8745626271058491, 5.604390301450113, 5.573349583034879]}, "output": [2.986219708672502, 18.636974597411562, 7.946421645230807, 7.94642164523081, 18.636974597411566]}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, given a partially filled 3x3 board, determine the current state of the game. What is the result of the game based on the provided board?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists of strings): A 3x3 grid representing the Tic-Tac-Toe board. Each cell can be either an empty string `''`, `'x'`, or `'o'`.\n\nOutput:\n  `return` (string): The result of the game. It can be `'o'` if 'o' wins, `'x'` if 'x' wins, `'tie'` if the game is a tie, or `''` if the game is not yet finished.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass TicTacToe:\n    def __init__(self, board):\n        self.board = board\n        self.currPlayer = 1\n\n    def checkForWin(self):\n        numFree = 0\n        testD1 = ''\n        testD2 = ''\n        for i in range(3):\n            testD1 += self.board[i][i]\n            testD2 += self.board[2 - i][i]\n            \n            testH = ''\n            testV = ''\n            for j in range(3):\n                if self.board[i][j] == '':\n                    numFree += 1\n                \n                testH += self.board[i][j]\n                testV += self.board[j][i]\n\n            if testH == 'ooo' or testV == 'ooo':\n                return 'o'\n            if testH == 'xxx' or testV == 'xxx':\n                return 'x'\n\n        if testD1 == 'ooo' or testD2 == 'ooo':\n            return 'o'\n        if testD1 == 'xxx' or testD2 == 'xxx':\n            return 'x'\n\n        if numFree == 0:\n            return 'tie'\n\n        return ''\n\n    def getMove(self):\n        while True:\n            move = [random.randint(0, 2), random.randint(0, 2)]\n            if self.isLegal(move):\n                if self.currPlayer == 1:\n                    move.append('x')\n                    self.currPlayer = 2\n                else:\n                    move.append('o')\n                    self.currPlayer = 1\n                self.board[move[0]][move[1]] = move[2]\n                return move\n\n    def isLegal(self, move):\n        return self.board[move[0]][move[1]] == ''\n\n# main function\ndef main_solution(board):\n    game = TicTacToe(board)\n    result = game.checkForWin()\n    if result == '':\n        game.getMove()\n        result = game.checkForWin()\n    return result", "input_generator": "import random\n\ndef input_generator():\n    board = []\n    symbols = ['x', 'o', '']\n    for _ in range(3):\n        row = [random.choice(symbols) for _ in range(3)]\n        board.append(row)\n    \n    # Ensure the board is not already in a terminal state (all filled or someone won)\n    # If it is, regenerate a cell to make it non-terminal\n    game = TicTacToe([row.copy() for row in board])\n    result = game.checkForWin()\n    while result != '':\n        # Find all empty cells\n        empty_cells = []\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] == '':\n                    empty_cells.append((i, j))\n        if not empty_cells:\n            # All cells are filled, reset the board to a mostly empty state\n            board = [['' for _ in range(3)] for _ in range(3)]\n            break\n        # Randomly pick an empty cell and set it to a random symbol\n        i, j = random.choice(empty_cells)\n        board[i][j] = random.choice(['x', 'o'])\n        game = TicTacToe([row.copy() for row in board])\n        result = game.checkForWin()\n    \n    return {'board': board}", "io_pairs": [{"input": {"board": [["x", "", "o"], ["o", "x", "x"], ["x", "o", "o"]]}, "output": ""}, {"input": {"board": [["", "", ""], ["", "x", ""], ["", "", ""]]}, "output": ""}, {"input": {"board": [["o", "x", "o"], ["x", "o", "o"], ["x", "o", "x"]]}, "output": "tie"}, {"input": {"board": [["x", "o", "o"], ["o", "x", "x"], ["x", "o", ""]]}, "output": ""}, {"input": {"board": [["o", "x", ""], ["", "", "x"], ["x", "o", "x"]]}, "output": ""}, {"input": {"board": [["o", "o", "x"], ["o", "x", ""], ["x", "o", "x"]]}, "output": "x"}, {"input": {"board": [["", "", ""], ["", "", ""], ["", "x", ""]]}, "output": ""}, {"input": {"board": [["", "", ""], ["", "", ""], ["x", "", ""]]}, "output": ""}, {"input": {"board": [["o", "x", "x"], ["x", "", "o"], ["", "o", "x"]]}, "output": ""}, {"input": {"board": [["x", "x", ""], ["o", "o", ""], ["x", "x", "x"]]}, "output": "x"}], "error_log": []}
{"context": "Given a set of digits from '0' to '9', what is the 1,000,000th lexicographic permutation of these digits?\n\nThe input and output requirements are as follows:\n\nInput:\n  `digits` (str): A string of digits from '0' to '9'.\n\nOutput:\n  `return` (str): The 1,000,000th lexicographic permutation of the input digits.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(digits):\n    # Generate all permutations of the given digits\n    all_permutations = list(itertools.permutations(digits))\n    \n    # Convert each permutation tuple to a string\n    all_permutations = [''.join(perm) for perm in all_permutations]\n    \n    # Return the 1,000,000th permutation (considering 0-based index)\n    return all_permutations[999999]", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random length between 3 and 10 for the digits string\n    length = random.randint(3, 10)\n    # Generate a random string of digits with no duplicates\n    digits = ''.join(random.sample(string.digits, length))\n    return {'digits': digits}", "io_pairs": [{"input": {"digits": "8149562703"}, "output": "4709316528"}, {"input": {"digits": "5742069831"}, "output": "4832176095"}, {"input": {"digits": "6307524198"}, "output": "0197832546"}, {"input": {"digits": "7815326904"}, "output": "1905482367"}, {"input": {"digits": "8673125904"}, "output": "7903462158"}, {"input": {"digits": "9356741028"}, "output": "5026834719"}, {"input": {"digits": "7849126503"}, "output": "4509382167"}, {"input": {"digits": "6190435872"}, "output": "9870213456"}, {"input": {"digits": "3586790214"}, "output": "8216459703"}, {"input": {"digits": "7426105983"}, "output": "2986340157"}], "error_log": []}
{"context": "Given a mathematical series that approximates the value of \u03c0, how can we estimate \u03c0 using a specified number of terms in the series? Specifically, what is the approximate value of \u03c0 when using `n` terms in the series?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of terms to use in the series approximation of \u03c0. It should be a positive integer.\n\nOutput:\n  `return` (float): The approximate value of \u03c0 calculated using the series approximation. The value is returned as a float with a reasonable precision.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(n):\n  # Convert the input to an integer\n  n = int(n)\n  \n  # Calculate the sum of the series\n  s = 0.0\n  for k in range(1, n):\n      s += 1.0 / (k * k)\n  \n  # Calculate the approximate value of pi\n  pi_approx = np.sqrt(6 * s)\n  \n  # Return the approximate value of pi as a float\n  return float(pi_approx)", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(10, 1000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 808}, "output": 3.140409855652872}, {"input": {"n": 32}, "output": 3.1111323022281687}, {"input": {"n": 25}, "output": 3.1023765763598083}, {"input": {"n": 727}, "output": 3.1402779538513683}, {"input": {"n": 205}, "output": 3.1369196046842425}, {"input": {"n": 112}, "output": 3.1330166138381332}, {"input": {"n": 144}, "output": 3.13493105563775}, {"input": {"n": 611}, "output": 3.14002808800475}, {"input": {"n": 365}, "output": 3.1389717275031703}, {"input": {"n": 794}, "output": 3.1403889831384197}], "error_log": []}
{"context": "Given a positive integer, how can it be expressed as a product of its prime factors, considering that repeated factors should be represented with their exponents?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number` (int): A positive integer greater than 1 and less than 10,000.\n\nOutput:\n  `return` (str): A string expressing how the number can be made by multiplying powers of its prime factors. The format is \"factor1^exponent1 x factor2^exponent2 x ...\". If a factor is not repeated, it is expressed as \"factor\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    else:\n        for i in range(2, n):\n            if n % i == 0:\n                return False\n    return True\n\ndef express_factors(n):\n    prime_list = [i for i in range(1, n + 1) if is_prime(i) == True]\n    temp = []\n    for i in prime_list:\n        cont = True\n        while cont == True:\n            if n % i == 0:\n                n /= i\n                temp.append(i)\n            else:\n                cont = False\n    result = []\n    temp.sort()\n    for i in set(temp):\n        if temp.count(i) > 1:\n            result.append(str(i) + '^' + str(temp.count(i)))\n        else:\n            result.append(str(i))\n    return \" x \".join(result)\n\n# main function\ndef main_solution(number):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return express_factors(number)", "input_generator": "import random\n\ndef input_generator():\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    num_factors = random.randint(1, 4)\n    factors = random.choices(primes, k=num_factors)\n    exponents = [random.randint(1, 3) for _ in range(num_factors)]\n    number = 1\n    for p, e in zip(factors, exponents):\n        number *= p ** e\n    return {'number': number}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a sequence of operations that simulate a stack using two queues, what are the results of the 'pop' operations performed on the stack? The operations include pushing integers onto the stack and popping integers off the stack.\n\nThe input and output requirements are as follows:\n\nInput:\n  `operations` (list of tuples): A list of operations to be performed on the stack. Each tuple contains an operation ('push' or 'pop') and an optional integer value to be pushed onto the stack. For 'pop' operations, the value is `None`.\n\nOutput:\n  `return` (list of integers): A list of integers representing the results of 'pop' operations. Each integer is the value that was popped from the stack. If the stack is empty when a 'pop' operation is performed, the result is `None`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Queue:\n    def __init__(self):\n        self.q = []\n    \n    def enQ(self, data):\n        self.q.append(data)\n        \n    def deQ(self):\n        if self.q:\n            data = self.q[0]\n            self.q.remove(data)\n            return data\n        else:\n            return None\n       \n    def isEmpty(self):\n        return not bool(self.q)\n    \nclass Stack:\n    def __init__(self):\n        self.q1 = Queue()\n        self.q2 = Queue()\n    \n    def isEmpty(self):\n        return self.q1.isEmpty() and self.q2.isEmpty()\n    \n    def push(self, data):\n        if self.q1.isEmpty():\n            self.q2.enQ(data)\n        else:\n            self.q1.enQ(data)\n            \n    def pop(self):\n        if self.isEmpty():\n            return None\n        elif self.q1.isEmpty():\n            while not self.q2.isEmpty():\n                top = self.q2.deQ()\n                if self.q2.isEmpty():\n                    return top\n                else:\n                    self.q1.enQ(top)\n        else:\n            while not self.q1.isEmpty():\n                top = self.q1.deQ()\n                if self.q1.isEmpty():\n                    return top\n                else:\n                    self.q2.enQ(top)\n            \n# main function\ndef main_solution(operations):\n    stack = Stack()\n    results = []\n    \n    for op in operations:\n        if op[0] == 'push':\n            stack.push(op[1])\n        elif op[0] == 'pop':\n            results.append(stack.pop())\n    \n    return results", "input_generator": "import random\n\ndef input_generator():\n    operations = []\n    num_operations = random.randint(5, 20)\n    push_probability = 0.7  # 70% chance to push, 30% to pop\n    \n    for _ in range(num_operations):\n        if random.random() < push_probability or len(operations) == 0:\n            value = random.randint(1, 100)\n            operations.append(('push', value))\n        else:\n            operations.append(('pop',))\n    \n    return {'operations': operations}", "io_pairs": [{"input": {"operations": [["push", 14], ["push", 94], ["push", 3], ["push", 4], ["push", 47]]}, "output": []}, {"input": {"operations": [["push", 43], ["pop"], ["push", 100], ["push", 40], ["pop"], ["pop"], ["push", 81], ["push", 96]]}, "output": [43, 40, 100]}, {"input": {"operations": [["push", 85], ["push", 48], ["push", 7], ["push", 34], ["push", 52]]}, "output": []}, {"input": {"operations": [["push", 31], ["pop"], ["pop"], ["push", 87], ["pop"], ["pop"]]}, "output": [31, null, 87, null]}, {"input": {"operations": [["push", 4], ["push", 51], ["pop"], ["pop"], ["pop"], ["push", 88], ["push", 37]]}, "output": [51, 4, null]}, {"input": {"operations": [["push", 24], ["push", 26], ["pop"], ["pop"], ["push", 98], ["push", 81]]}, "output": [26, 24]}, {"input": {"operations": [["push", 2], ["pop"], ["pop"], ["push", 13], ["push", 50], ["push", 92]]}, "output": [2, null]}, {"input": {"operations": [["push", 21], ["push", 34], ["pop"], ["push", 13], ["pop"], ["push", 51], ["push", 30]]}, "output": [34, 13]}, {"input": {"operations": [["push", 17], ["push", 88], ["push", 83], ["push", 98], ["pop"]]}, "output": [98]}, {"input": {"operations": [["push", 45], ["pop"], ["pop"], ["push", 72], ["push", 31], ["push", 61]]}, "output": [45, null]}], "error_log": []}
{"context": "Given a list of letters and their corresponding frequencies, how can we determine the Huffman code for a specific letter?\n\nThe input and output requirements are as follows:\n\nInput:\n  `liste_freq_et_lettre` (list of tuples): A list of tuples where each tuple contains a frequency (int) and a corresponding letter (str).\n  `lettre` (str): The letter for which the Huffman code needs to be generated.\n\nOutput:\n  `return` (str): The Huffman code for the specified letter.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Arbre:\n    def __init__(self, lettre, liste_freq_et_lettre, freq=None, fils_g=None, fils_d=None):\n        self.lettre = lettre\n        self.fils_g = fils_g\n        self.fils_d = fils_d\n        self.liste = liste_freq_et_lettre\n        self.freq = freq\n        self.liste_feuille = []\n\n    def feuille(self):\n        liste_feuille = []\n        for (freq, alpha) in self.liste:\n            liste_feuille.append(Arbre(alpha, self.liste, freq=freq))\n        self.liste_feuille = liste_feuille\n\n    def constru_arbre(self):\n        somme_freq = self.liste_feuille[0].freq + self.liste_feuille[1].freq\n        self.liste.pop(1)\n        self.liste.pop(0)\n        noeud = Arbre('', self.liste, somme_freq, self.liste_feuille[0], self.liste_feuille[1])\n        self.liste.append((noeud.freq, noeud.lettre))\n        self.liste = sorted(self.liste)\n        index = self.liste.index((noeud.freq, noeud.lettre))\n        self.liste_feuille.pop(1)\n        self.liste_feuille.pop(0)\n        self.liste_feuille[index:index] = [noeud]\n        return self.liste_feuille\n\n    def tant_que(self):\n        self.feuille()\n        a = None\n        while len(self.liste_feuille) > 1:\n            a = self.constru_arbre()\n        return a\n\n    def codage(self, lettre, code=\"\"):\n        if self.lettre == lettre:\n            return code\n        else:\n            if self.fils_g != None:\n                if self.fils_g.codage(lettre, code + \"0\") != None:\n                    return self.fils_g.codage(lettre, code + \"0\")\n            if self.fils_d != None:\n                if self.fils_d.codage(lettre, code + \"1\") != None:\n                    return self.fils_d.codage(lettre, code + \"1\")\n\n# main function\ndef main_solution(liste_freq_et_lettre, lettre):\n    # Convert input to the required format\n    liste_freq_et_lettre = [(int(freq), str(lettre)) for freq, lettre in liste_freq_et_lettre]\n    lettre = str(lettre)\n\n    # Create the Arbre object and build the tree\n    arbre = Arbre('', liste_freq_et_lettre)\n    arbre_final = arbre.tant_que()\n\n    # Get the code for the specified letter\n    code = arbre_final[0].codage(lettre)\n\n    # Return the code as a string\n    return code", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random number of letters (between 2 and 10)\n    num_letters = random.randint(2, 10)\n    letters = random.sample(string.ascii_lowercase, num_letters)\n    \n    # Generate random frequencies (between 1 and 100) for each letter\n    frequencies = [random.randint(1, 100) for _ in range(num_letters)]\n    \n    # Combine into a list of (frequency, letter) tuples\n    liste_freq_et_lettre = list(zip(frequencies, letters))\n    \n    # Randomly select a letter from the generated list\n    lettre = random.choice(letters)\n    \n    return {\n        'liste_freq_et_lettre': liste_freq_et_lettre,\n        'lettre': lettre\n    }", "io_pairs": [{"input": {"liste_freq_et_lettre": [[36, "n"], [7, "h"]], "lettre": "h"}, "output": "1"}, {"input": {"liste_freq_et_lettre": [[71, "a"], [77, "r"]], "lettre": "a"}, "output": "0"}, {"input": {"liste_freq_et_lettre": [[34, "i"], [51, "r"], [81, "b"], [79, "x"]], "lettre": "r"}, "output": "01"}, {"input": {"liste_freq_et_lettre": [[54, "y"], [39, "d"]], "lettre": "d"}, "output": "1"}, {"input": {"liste_freq_et_lettre": [[7, "x"], [7, "y"], [83, "w"]], "lettre": "x"}, "output": "00"}, {"input": {"liste_freq_et_lettre": [[20, "n"], [66, "r"], [86, "v"], [35, "t"]], "lettre": "v"}, "output": "10"}, {"input": {"liste_freq_et_lettre": [[29, "m"], [76, "d"]], "lettre": "d"}, "output": "1"}, {"input": {"liste_freq_et_lettre": [[26, "c"], [85, "i"], [77, "n"]], "lettre": "n"}, "output": "0"}, {"input": {"liste_freq_et_lettre": [[29, "h"], [73, "u"], [51, "o"]], "lettre": "u"}, "output": "11"}, {"input": {"liste_freq_et_lettre": [[89, "i"], [60, "u"]], "lettre": "i"}, "output": "0"}], "error_log": []}
{"context": "Given a polynomial represented by a list of coefficients, what is the value of the polynomial when evaluated at a specific integer value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `coefficients` (list of int): A list of integers representing the coefficients of the polynomial in ascending order of powers.\n  `x_value` (int): An integer value at which the polynomial is to be evaluated.\n\nOutput:\n  `return` (int): The value of the polynomial evaluated at the given `x_value`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Polynomial:\n    str_rep = \"\"\n    list_rep = []\n\n    def derivative(self):\n        holder = []\n        for i in range(len(self.list_rep)):\n            holder.append(self.list_rep[i] * i)\n        holder = Polynomial(holder[1:])\n        return holder\n\n    def at_value(self, pos_a, pos_b=0):\n        curr_sum = 0\n        curr_pow_x = 1\n        for i in range(len(self.list_rep)):\n            curr_sum += curr_pow_x * self.list_rep[i]\n            curr_pow_x *= pos_a\n        if pos_b != 0:\n            return self.at_value(pos_b) - curr_sum\n        return curr_sum\n\n    def __gen_str_rep__(self, exponent, multiplier, prev_sign_part):\n        x_part = number_part = sign_part = \"\"\n        if exponent == 0:\n            x_part = \"\"\n        elif exponent == 1:\n            x_part = \"x\"\n        else:\n            x_part = \"x^\" + str(exponent)\n        if multiplier == 0:\n            return (exponent, multiplier, prev_sign_part)\n        elif (abs(multiplier) == 1) and (x_part != \"\"):\n            number_part = \"\"\n        else:\n            number_part = abs(multiplier)\n        self.str_rep = str(number_part) + str(x_part) + prev_sign_part + str(self.str_rep)\n        if multiplier < 0:\n            sign_part = \" - \"\n        else:\n            sign_part = \" + \"\n        return x_part, number_part, sign_part\n\n    def __add__(self, other):\n        holder = other.list_rep.copy()\n        target_list = self.list_rep.copy()\n        if len(self.list_rep) > len(other.list_rep):\n            target_list = other.list_rep.copy()\n            holder = self.list_rep.copy()\n        for (n, _) in enumerate(target_list):\n            holder[n] = holder[n] + target_list[n]\n        return Polynomial(holder)\n\n    def __pow__(self, exp):\n        poly_sum = Polynomial(0)\n        target = Polynomial(1)\n        other = self.list_rep.copy()\n        while exp > 0:\n            for (mocnina, nasobitel) in enumerate(target.list_rep):\n                for (exponent, multiplier) in enumerate(other):\n                    poly_sum = poly_sum + Polynomial(hackyway=str(\"x\" + str(exponent + mocnina) + \"=\" + str(multiplier * nasobitel)))\n            target = poly_sum\n            poly_sum = Polynomial(0)\n            exp = exp - 1\n        return target\n\n    def __eq__(self, other):\n        return str(self.str_rep) == str(other.str_rep)\n\n    def __init__(self, *args, **kwargs):\n        self.str_rep = \"\"\n        self.list_rep = []\n        x_part = sign_part = \"\";\n        if kwargs.get(\"hackyway\", False):\n            exp, mul = kwargs.get(\"hackyway\").split(\"=\")\n            exp = int(exp[1:])\n            mul = int(mul)\n            _, _, sign_part = self.__gen_str_rep__(exp, mul, sign_part)\n            if sign_part == \" - \":\n                self.str_rep = \"-\" + str(self.str_rep)\n            for iteration in range(exp + 1):\n                if iteration == exp:\n                    self.list_rep.append(mul)\n                else:\n                    self.list_rep.append(0)\n        elif kwargs != {}:\n            sorted_list = sorted([int(x[1:]) for x in list(kwargs.keys())])\n            for key in sorted_list:\n                _, _, sign_part = self.__gen_str_rep__(key, int(kwargs.get(\"x\" + str(key), 0)), sign_part)\n            if sign_part == \" - \":\n                self.str_rep = \"-\" + str(self.str_rep)\n            for iteration in range(sorted_list[-1] + 1):\n                self.list_rep.append(int(kwargs.get(\"x\" + str(iteration), 0)))\n        elif args != ():\n            holder = list(args)\n            if type(holder[0]) is list:\n                holder = holder[0]\n            for (n, arg) in enumerate(holder):\n                x_part, _, sign_part = self.__gen_str_rep__(int(n), int(arg), sign_part)\n                self.list_rep.append(int(arg))\n            if sign_part == \" - \":\n                self.str_rep = \"-\" + str(self.str_rep)\n        else:\n            self.str_rep = \"0\"\n            self.list_rep = [0]\n        if self.str_rep == \"\":\n            self.str_rep = \"0\"\n        if self.list_rep == []:\n            self.list_rep = [0]\n\n    def __str__(self):\n        return self.str_rep\n\n# main function\ndef main_solution(coefficients, x_value):\n    # Convert JSON serializable inputs to the original input variables\n    poly = Polynomial(coefficients)\n    \n    # Calculate the value of the polynomial at the given x_value\n    result = poly.at_value(x_value)\n    \n    # Convert the result to a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random degree for the polynomial (between 0 and 5)\n    degree = random.randint(0, 5)\n    \n    # Generate random coefficients for the polynomial (between -10 and 10)\n    coefficients = [random.randint(-10, 10) for _ in range(degree + 1)]\n    \n    # Generate a random x_value (between -10 and 10)\n    x_value = random.uniform(-10, 10)\n    \n    return {\n        'coefficients': coefficients,\n        'x_value': x_value\n    }", "io_pairs": [{"input": {"coefficients": [10, -6, 6], "x_value": -8.851920760664614}, "output": 533.2505314824988}, {"input": {"coefficients": [8, -4, -7], "x_value": -4.829974805423283}, "output": -135.98069712547263}, {"input": {"coefficients": [0, 2, -2, -7, 4], "x_value": 1.701834436865468}, "output": -3.3384291915337414}, {"input": {"coefficients": [8, 10, -10, 1], "x_value": 6.986741583570282}, "output": -69.22346176827551}, {"input": {"coefficients": [9, 4, 8, -1, 10, -2], "x_value": 2.955692710430977}, "output": 376.93261555979143}, {"input": {"coefficients": [-10, 6, -5, -10, -7, 7], "x_value": 2.997080953249009}, "output": 821.8015622465063}, {"input": {"coefficients": [2, 5], "x_value": 8.64181026603487}, "output": 45.20905133017435}, {"input": {"coefficients": [4, 5, 8], "x_value": 7.898894066034572}, "output": 542.6346900616622}, {"input": {"coefficients": [2], "x_value": -7.5351171410541085}, "output": 2}, {"input": {"coefficients": [9, -5, 4, 3, 7, 6], "x_value": 0.05920624403033514}, "output": 8.71870329704516}], "error_log": []}
{"context": "Given a mathematical expression involving trigonometric and exponential functions, what is the average value of the expression `tan(atan(exp(log(sqrt(a*a)))))/a` over a range of integers from 1 to `n_iterations`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n_iterations` (int): The number of iterations to perform the calculation. It should be a positive integer.\n\nOutput:\n  `return` (float): The result of the calculation after performing the specified number of iterations. It represents the average value of the expression `tan(atan(exp(log(sqrt(a*a)))))/a` over the range from 1 to `n_iterations`.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom math import tan, atan, exp, log, sqrt\n\n# main function\ndef main_solution(n_iterations):\n    # Convert the input to the required format for the original code\n    n_iterations = int(n_iterations)\n    \n    # Initialize sum\n    s = 0.0\n    \n    # Perform the calculation\n    for a in range(1, n_iterations + 1):\n        z = tan(atan(exp(log(sqrt(a * a))))) / a\n        s += z\n    \n    # Calculate the final result\n    result = s / a\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    return {'n_iterations': random.randint(1, 1000)}", "io_pairs": [{"input": {"n_iterations": 409}, "output": 0.999999999999999}, {"input": {"n_iterations": 544}, "output": 1.0000000000000004}, {"input": {"n_iterations": 86}, "output": 0.9999999999999997}, {"input": {"n_iterations": 187}, "output": 0.9999999999999992}, {"input": {"n_iterations": 916}, "output": 1.0000000000000002}, {"input": {"n_iterations": 512}, "output": 1.0000000000000004}, {"input": {"n_iterations": 696}, "output": 1.000000000000001}, {"input": {"n_iterations": 695}, "output": 1.000000000000001}, {"input": {"n_iterations": 336}, "output": 0.9999999999999987}, {"input": {"n_iterations": 496}, "output": 1.0000000000000007}], "error_log": []}
{"context": "In a distributed file system, files need to be evenly distributed across multiple servers to ensure load balancing. Given a certain number of servers and a file hash value, which server should the file be placed on to maintain an even distribution? (Note: The file hash value is a unique identifier for each file, and the number of servers can vary.)\n\nThe input and output requirements are as follows:\n\nInput:\n  `servers` (int): The number of servers available for placement.\n  `fileHash` (int): The hash value of the file to be placed, ranging from 0 to 2^32 - 1.\n\nOutput:\n  `return` (int): The index of the server where the file should be placed.", "reference_code": "# import necessary packages\nfrom fractions import Fraction\n\n# all class and function definitions in the code file, if any\nclass ServerPlacement():\n\n    MAX_HASH = pow(2, 32)\n\n    def __init__(self, servers):\n        self.servers = servers\n        self.fraction = []\n        self.ranges = []\n        self.calculateFractions()\n\n    def calculateFractions(self):\n        res = [[(0, Fraction(1, 1))]]  # server index, fraction\n        for i in range(1, self.servers):\n            rn = []\n            fraction_to_subtract = {}\n            for si in range(0, i):\n                fraction_to_subtract[si] = Fraction(1, i * (i + 1))\n            for piece in res[i - 1]:\n                si = piece[0]\n                fr = piece[1]\n                if (not fr > fraction_to_subtract[si]):\n                    rn.append([i, fr])\n                    fraction_to_subtract[si] -= fr\n                else:\n                    if si % 2:\n                        rn.append([si, fr - fraction_to_subtract[si]])\n                        rn.append([i, fraction_to_subtract[si]])\n                    else:\n                        rn.append([i, fraction_to_subtract[si]])\n                        rn.append([si, fr - fraction_to_subtract[si]])\n                    fraction_to_subtract[si] = Fraction(0, 1)\n            r = []\n            p = [-1, Fraction(1, 1)]\n            for j in rn:\n                if j[0] != p[0]:\n                    r.append(j)\n                else:\n                    r[-1] = ([j[0], j[1] + p[1]])\n                p = j\n            res.append(r)\n        ul = 0\n        f = res[-1]\n        for i in f:\n            ul += i[1]\n            self.ranges.append([i[0], ul])\n\n    def getServer(self, fileHash):\n        ff = Fraction(fileHash, self.MAX_HASH)\n        for i in self.ranges:\n            if ff < i[1]:\n                return i[0]\n\n# main function\ndef main_solution(servers, fileHash):\n    # Convert JSON serializable inputs to original input variables\n    server_placement = ServerPlacement(servers)\n    # Get the server index for the given file hash\n    server_index = server_placement.getServer(fileHash)\n    # Return the result as a JSON serializable output\n    return server_index", "input_generator": "import random\nfrom fractions import Fraction\n\ndef input_generator():\n    servers = random.randint(2, 10)  # Reasonable number of servers\n    fileHash = random.randint(0, pow(2, 32) - 1)  # Valid hash within the range\n    return {'servers': servers, 'fileHash': fileHash}", "io_pairs": [{"input": {"servers": 6, "fileHash": 2730678152}, "output": 2}, {"input": {"servers": 9, "fileHash": 3761160704}, "output": 8}, {"input": {"servers": 2, "fileHash": 218692964}, "output": 1}, {"input": {"servers": 8, "fileHash": 3301262574}, "output": 4}, {"input": {"servers": 4, "fileHash": 2756430864}, "output": 2}, {"input": {"servers": 8, "fileHash": 1043601677}, "output": 6}, {"input": {"servers": 3, "fileHash": 2452166913}, "output": 2}, {"input": {"servers": 4, "fileHash": 4137058041}, "output": 0}, {"input": {"servers": 7, "fileHash": 3453309168}, "output": 5}, {"input": {"servers": 5, "fileHash": 2367778824}, "output": 2}], "error_log": []}
{"context": "Given a square matrix, what is its inverse matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_values` (list of lists of float): A square matrix represented as a list of lists. Each inner list represents a row of the matrix.\n\nOutput:\n  `return` (list of lists of float): The inverse of the input matrix. Each inner list represents a row of the inverse matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix_values):\n    \"\"\"\n    Calculate the inverse of a given square matrix using Gauss-Jordan elimination.\n\n    Parameters:\n    matrix_values (list of lists of float): A square matrix represented as a list of lists.\n\n    Returns:\n    list of lists of float: The inverse of the input matrix.\n    \"\"\"\n    x = len(matrix_values)\n    m = np.zeros((x, 2 * x))\n    \n    # Fill the matrix with input values\n    for i in range(x):\n        for j in range(x):\n            m[i][j] = matrix_values[i][j]\n    \n    # Augment the matrix with the identity matrix\n    for i in range(x):\n        for j in range(x):\n            if i == j:\n                m[i][j + x] = 1\n    \n    # Perform Gauss-Jordan elimination\n    for i in range(x):\n        if m[i][i] == 0.0:\n            raise ValueError('Divide by zero detected!')\n        for j in range(x):\n            if i != j:\n                ratio = m[j][i] / m[i][i]\n                for k in range(2 * x):\n                    m[j][k] = m[j][k] - ratio * m[i][k]\n    \n    # Normalize the diagonal elements\n    for i in range(x):\n        divisor = m[i][i]\n        for j in range(2 * x):\n            m[i][j] = m[i][j] / divisor\n    \n    # Extract the inverse matrix\n    inverse_matrix = []\n    for i in range(x):\n        inverse_matrix.append(m[i][x:].tolist())\n    \n    return inverse_matrix", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.randint(2, 5)  # Generate matrices of size 2x2 to 5x5\n    matrix = []\n    for _ in range(size):\n        row = [round(random.uniform(-10, 10), 2) for _ in range(size)]\n        matrix.append(row)\n    \n    # Ensure the matrix is invertible by making it diagonally dominant\n    for i in range(size):\n        diagonal_element = sum(abs(matrix[i][j]) for j in range(size) if j != i) + 1.0\n        matrix[i][i] = diagonal_element\n    \n    return {'matrix_values': matrix}", "io_pairs": [{"input": {"matrix_values": [[7.19, 6.19], [4.68, 5.68]]}, "output": [[0.47851727042965453, -0.5214827295703454], [-0.39427127211457447, 0.6057287278854253]]}, {"input": {"matrix_values": [[5.87, -4.87], [4.56, 5.56]]}, "output": [[0.10137771586524788, 0.08879666839276207], [-0.08314431373121048, 0.10703007052679946]]}, {"input": {"matrix_values": [[11.18, 2.62, 7.56], [3.74, 12.600000000000001, 7.86], [7.06, -9.32, 17.38]]}, "output": [[0.12671302566711595, -0.0502939061358895, -0.03237286374081158], [-0.004123244574669329, 0.06110758070603474, -0.02584199397957037], [-0.05368369393819086, 0.05319894300918434, 0.05682997894824707]]}, {"input": {"matrix_values": [[2.5300000000000002, -1.53], [-1.52, 2.52]]}, "output": [[0.6222222222222221, 0.3777777777777777], [0.3753086419753086, 0.6246913580246913]]}, {"input": {"matrix_values": [[17.5, -9.26, -7.24], [-9.51, 19.299999999999997, 8.79], [-5.7, 4.86, 11.56]]}, "output": [[0.08425826763448005, 0.0335649353983546, 0.027248622450008537], [0.027947393704850484, 0.07521693362948431, -0.03969011385640567], [0.02979652180890683, -0.015072159659919768, 0.116627257898545]]}, {"input": {"matrix_values": [[7.83, 0.36, 6.47], [-3.48, 4.779999999999999, 0.3], [9.03, -0.83, 10.86]]}, "output": [[0.32115605392073193, -0.05713656558438139, -0.18975494467696327], [0.24937592292698021, 0.16384008849754989, -0.15309523461204666], [-0.24797947982272708, 0.06003042916021459, 0.23816004656583606]]}, {"input": {"matrix_values": [[7.93, 5.53, 1.4], [-3.25, 10.1, 5.85], [-3.37, 1.27, 5.640000000000001]]}, "output": [[0.11599890030012253, -0.06887455927700822, 0.04264498428197279], [-0.003242194378978681, 0.1157850957881682, -0.11929144294861944], [0.07004146823984322, -0.06722594617278214, 0.22964782439272957]]}, {"input": {"matrix_values": [[11.030000000000001, -1.81, 8.22], [-0.03, 1.18, -0.15], [-5.08, -1.7, 7.78]]}, "output": [[0.06099139505676544, 0.0007366473645012439, -0.06442657715449059], [0.0068020295605243815, 0.8717517712132369, 0.00962083325121788], [0.04131102019810538, 0.19096660407122992, 0.08856920367381212]]}, {"input": {"matrix_values": [[8.14, -7.14], [5.11, 6.11]]}, "output": [[0.07086457096199525, 0.0828106442992874], [-0.05926644150831354, 0.09440877375296913]]}, {"input": {"matrix_values": [[5.07, 2.91, 1.16], [-3.23, 10.34, 6.11], [3.07, 2.14, 6.21]]}, "output": [[0.15620097337252367, -0.04761753194642248, 0.017673106454189035], [0.11856807302933116, 0.08529564064392335, -0.10607010129603799], [-0.11807933406383517, -0.005852954573668114, 0.188845987110976]]}], "error_log": []}
{"context": "In a children's game, a group of kids stand in a circle. Starting from a specific child, every `m`-th child is eliminated until only one child remains. What is the index of the last remaining child who will receive the gift, given the step size `m` and the total number of children `n` in the circle?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The step size for counting out the children.\n  `n` (int): The total number of children in the circle.\n\nOutput:\n  `return` (int): The index of the last remaining child who will receive the gift.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def LastRemaining_Solution(self, m, n):\n        if n < 1 or m < 1:\n            return -1\n        last = 0\n        for i in range(2, n + 1):\n            last = (last + m) % i\n        return last\n\n# main function\ndef main_solution(m, n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.LastRemaining_Solution(m, n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    m = random.randint(1, 100)\n    n = random.randint(1, 100)\n    return {'m': m, 'n': n}", "io_pairs": [{"input": {"m": 77, "n": 55}, "output": 25}, {"input": {"m": 97, "n": 37}, "output": 15}, {"input": {"m": 65, "n": 41}, "output": 29}, {"input": {"m": 98, "n": 59}, "output": 28}, {"input": {"m": 67, "n": 96}, "output": 16}, {"input": {"m": 45, "n": 67}, "output": 3}, {"input": {"m": 30, "n": 83}, "output": 55}, {"input": {"m": 78, "n": 86}, "output": 53}, {"input": {"m": 36, "n": 54}, "output": 42}, {"input": {"m": 97, "n": 4}, "output": 3}], "error_log": []}
{"context": "Given a specific set of digits and a base prefix, what is the largest 1 to 9 pandigital 9-digit number that can be formed by concatenating the products of a number starting with the given prefix and its multiples (1, 2, ..., n) where n > 1?\n\nThe input and output requirements are as follows:\n\nInput:\n  `base_prefix` (str): A string representing the first two digits of the base number. It must be a string of length 2.\n  `digit_pool` (str): A string representing the pool of digits to be used for permutations. It must be a string of length 7.\n\nOutput:\n  `return` (int): The largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1, 2, ..., n) where n > 1.", "reference_code": "# import necessary packages\nimport time\n\n# all class and function definitions in the code file, if any\ndef get_permutations(strings, count):\n    permutations = []\n    for string in strings:\n        if count <= 1:\n            for char in string:\n                permutations.append(char)\n        else:\n            for c in range(len(string)):\n                char = string[c]\n                stringlet = string[:c] + string[(c + 1):]\n                stringlet_permutations = get_permutations([stringlet], count - 1)\n                for p in range(len(stringlet_permutations)):\n                    permutations.append(char + stringlet_permutations[p])\n    return permutations\n\ndef test_2_term_sum(n):\n    string = str(n) + str(n * 2)\n    is_pandigital = False\n    if string.find(\"1\") >= 0:\n        if string.find(\"2\") >= 0:\n            if string.find(\"3\") >= 0:\n                if string.find(\"4\") >= 0:\n                    if string.find(\"5\") >= 0:\n                        if string.find(\"6\") >= 0:\n                            if string.find(\"7\") >= 0:\n                                if string.find(\"8\") >= 0:\n                                    if string.find(\"9\") >= 0:\n                                        is_pandigital = True\n    if is_pandigital:\n        return string\n    else:\n        return None\n\n# main function\ndef main_solution(base_prefix, digit_pool):\n    solutions = []\n    permutations = get_permutations([digit_pool], 2)\n    for permutation in permutations:\n        string = test_2_term_sum(int(base_prefix + permutation))\n        if string is not None:\n            solutions.append(int(string))\n    if solutions:\n        return max(solutions)\n    else:\n        return 918273645", "input_generator": "import random\n\ndef input_generator():\n    base_prefix_options = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n    digit_pool_options = ['123456789', '987654321', '135792468', '246813579', '123456789'[:random.randint(5, 9)]]\n    \n    base_prefix = random.choice(base_prefix_options)\n    digit_pool = random.choice(digit_pool_options)\n    \n    return {'base_prefix': base_prefix, 'digit_pool': digit_pool}", "io_pairs": [{"input": {"base_prefix": "2", "digit_pool": "123456789"}, "output": 918273645}, {"input": {"base_prefix": "9", "digit_pool": "135792468"}, "output": 918273645}, {"input": {"base_prefix": "9", "digit_pool": "987654321"}, "output": 918273645}, {"input": {"base_prefix": "5", "digit_pool": "246813579"}, "output": 918273645}, {"input": {"base_prefix": "1", "digit_pool": "1234567"}, "output": 918273645}, {"input": {"base_prefix": "9", "digit_pool": "123456789"}, "output": 918273645}, {"input": {"base_prefix": "7", "digit_pool": "123456789"}, "output": 918273645}, {"input": {"base_prefix": "8", "digit_pool": "1234567"}, "output": 918273645}, {"input": {"base_prefix": "3", "digit_pool": "135792468"}, "output": 918273645}, {"input": {"base_prefix": "1", "digit_pool": "135792468"}, "output": 918273645}], "error_log": []}
{"context": "Given two vectors in three-dimensional space, what are the dot products calculated using both the algebraic and geometric methods?\n\nThe input and output requirements are as follows:\n\nInput:\n  `v1` (list of floats): A list representing the first vector.\n  `v2` (list of floats): A list representing the second vector.\n\nOutput:\n  `return` (dict): A dictionary containing the dot product calculated algebraically and geometrically.\n    - `dot_product_algebraically` (float): The dot product of the two vectors calculated using the algebraic method.\n    - `dot_product_geometrically` (float): The dot product of the two vectors calculated using the geometric method.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(v1, v2):\n    # Convert input lists to numpy arrays\n    v1 = np.array(v1)\n    v2 = np.array(v2)\n    \n    # Calculate the angle between the vectors\n    ang = np.arccos(np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2)))\n    \n    # Calculate the dot product algebraically\n    dot_product_algebraically = np.dot(v1, v2)\n    \n    # Calculate the dot product geometrically\n    dot_product_geometrically = np.linalg.norm(v1) * np.linalg.norm(v2) * np.cos(ang)\n    \n    # Return the results as a dictionary\n    return {\n        \"dot_product_algebraically\": float(dot_product_algebraically),\n        \"dot_product_geometrically\": float(dot_product_geometrically)\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    dim = random.randint(2, 5)  # Random dimension between 2 and 5\n    v1 = [round(random.uniform(-10, 10), 2) for _ in range(dim)]\n    v2 = [round(random.uniform(-10, 10), 2) for _ in range(dim)]\n    return {'v1': v1, 'v2': v2}", "io_pairs": [{"input": {"v1": [6.5, -4.67, -1.82, 2.53, 1.19], "v2": [-2.21, 4.14, 5.38, 8.12, -4.59]}, "output": {"dot_product_algebraically": -28.408900000000003, "dot_product_geometrically": -28.40890000000001}}, {"input": {"v1": [-5.01, -3.39, 7.41, 5.72, 0.3], "v2": [-7.49, -5.21, -8.59, 6.49, -2.64]}, "output": {"dot_product_algebraically": 27.865700000000004, "dot_product_geometrically": 27.865699999999997}}, {"input": {"v1": [-9.14, 9.98, -8.44, 8.3], "v2": [-5.05, -5.13, -2.0, -2.42]}, "output": {"dot_product_algebraically": -8.246400000000001, "dot_product_geometrically": -8.246400000000012}}, {"input": {"v1": [-0.36, -2.99, -2.21], "v2": [-4.03, 6.93, -1.76]}, "output": {"dot_product_algebraically": -15.3803, "dot_product_geometrically": -15.380300000000004}}, {"input": {"v1": [-9.54, 7.34, -1.67], "v2": [7.93, -5.27, -0.79]}, "output": {"dot_product_algebraically": -113.01469999999999, "dot_product_geometrically": -113.01469999999999}}, {"input": {"v1": [-5.81, 3.6, -6.92, 4.4, -4.73], "v2": [-2.28, 0.88, -3.73, -8.38, -2.97]}, "output": {"dot_product_algebraically": 19.402499999999993, "dot_product_geometrically": 19.4025}}, {"input": {"v1": [-0.27, 8.8, 4.28, 2.33], "v2": [5.55, 1.57, -6.87, -6.15]}, "output": {"dot_product_algebraically": -31.415599999999998, "dot_product_geometrically": -31.415599999999994}}, {"input": {"v1": [-5.79, -9.64, 4.27, 9.43], "v2": [-9.18, 1.15, -2.57, 1.5]}, "output": {"dot_product_algebraically": 45.237300000000005, "dot_product_geometrically": 45.23729999999998}}, {"input": {"v1": [7.11, 3.95, 9.82, -5.1], "v2": [-4.06, -8.78, -9.52, -4.24]}, "output": {"dot_product_algebraically": -135.41, "dot_product_geometrically": -135.41000000000003}}, {"input": {"v1": [3.86, 8.42, 1.53, 7.72], "v2": [-6.94, 3.3, 8.59, -5.0]}, "output": {"dot_product_algebraically": -24.459700000000005, "dot_product_geometrically": -24.45969999999999}}], "error_log": []}
{"context": "Given a pyramid of numbers represented as a multi-line string, where each line contains numbers separated by spaces, what is the maximum possible summation of the path from the top to the bottom of the pyramid, such that the number directly below the current number is not a prime number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data` (str): A multi-line string where each line represents a row in a pyramid of numbers. Each number in the row is separated by a space.\n\nOutput:\n  `return` (int): The maximum possible summation of the path from the top to the bottom of the pyramid, where the number below is not a prime number.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef primeFinder(num):\n    boolPrimes = [True for i in range(num + 1)]\n    p = 2\n    primeList = []\n    while (p * p <= num):\n        if (boolPrimes[p] == True):\n            for i in range(p * p, num + 1, p):\n                boolPrimes[i] = False\n        p += 1\n    for i in range(2, num + 1):\n        if boolPrimes[i]:\n            primeList.append(i)\n    return primeList\n\ndef data_getter(data):\n    lst = []\n    for row in data.splitlines():\n        lst.append(row.split())\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            lst[i][j] = int(lst[i][j])\n    return lst\n\ndef maxSum(pyram, m):\n    mxm = 0\n    for i in range(len(pyram)):\n        if mxm < max(pyram[i]):\n            mxm = max(pyram[i])\n    primeList = primeFinder(mxm)\n\n    j = 0\n    for i in pyram[m]:\n        if i in primeList:\n            pyram[m][j] = 0\n        j += 1\n\n    for i in range(m - 1, -1, -1):\n        for j in range(i + 1):\n            if pyram[i][j] in primeList:\n                pyram[i][j] = 0\n            elif (pyram[i + 1][j] > pyram[i + 1][j + 1]):\n                pyram[i][j] += pyram[i + 1][j]\n            else:\n                pyram[i][j] += pyram[i + 1][j + 1]\n    return pyram[0][0]\n\n# main function\ndef main_solution(data):\n    # Convert the input data string into a list of lists of integers\n    pyram = data_getter(data)\n    # Calculate the maximum sum path\n    m = len(pyram) - 1\n    result = maxSum(pyram, m)\n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    height = random.randint(3, 10)\n    data_lines = []\n    for i in range(1, height + 1):\n        line = []\n        for _ in range(i):\n            line.append(str(random.randint(1, 100)))\n        data_lines.append(' '.join(line))\n    data = '\\n'.join(data_lines)\n    return {'data': data}", "io_pairs": [{"input": {"data": "64\n99 79\n57 54 90\n94 63 6 21\n31 95 9 5 83\n69 52 39 15 52 7\n19 82 2 71 91 59 71"}, "output": 543}, {"input": {"data": "87\n89 32\n70 15 46\n44 73 29 59\n31 80 54 23 58\n52 13 39 5 15 35"}, "output": 165}, {"input": {"data": "89\n92 66\n9 62 35"}, "output": 0}, {"input": {"data": "22\n24 4\n69 97 41\n47 67 40 1\n76 31 94 46 24\n77 91 22 2 35 56\n51 19 35 91 10 30 24"}, "output": 115}, {"input": {"data": "14\n38 50\n18 17 53\n39 84 94 31\n30 95 46 84 87\n93 75 59 72 6 71\n89 85 74 62 61 88 70"}, "output": 409}, {"input": {"data": "100\n3 43\n69 89 47\n3 78 95 14\n89 26 66 95 56\n31 21 9 43 74 32"}, "output": 100}, {"input": {"data": "68\n70 75\n71 15 29\n30 61 16 64"}, "output": 174}, {"input": {"data": "87\n60 100\n47 90 24"}, "output": 277}, {"input": {"data": "71\n92 92\n25 26 21\n70 36 8 69\n4 71 22 23 12\n2 52 17 89 80 79"}, "output": 0}, {"input": {"data": "38\n15 94\n82 65 91\n44 52 3 59\n37 60 1 79 94"}, "output": 309}], "error_log": []}
{"context": "Given two mathematical functions and their respective bounds, what is the area enclosed by these two functions within the specified interval?\n\nThe input and output requirements are as follows:\n\nInput:\n  `upper_function` (str): A string representing the upper function in one variable.\n  `lower_function` (str): A string representing the lower function in one variable.\n  `variable` (str): A string representing the variable used in the functions (e.g., 'x').\n  `lower_bound` (float): The lower bound of the enclosed region.\n  `upper_bound` (float): The upper bound of the enclosed region.\n\nOutput:\n  `return` (float): The area enclosed by the two curves between the specified bounds.", "reference_code": "# import necessary packages\nfrom sympy import Integral, Symbol, sympify\n\n# main function\ndef main_solution(upper_function, lower_function, variable, lower_bound, upper_bound):\n    # Convert JSON serializable inputs to the required format\n    f = sympify(upper_function)\n    g = sympify(lower_function)\n    var = Symbol(variable)\n    a = float(lower_bound)\n    b = float(upper_bound)\n    \n    # Calculate the area enclosed by the two curves\n    area = Integral(f - g, (var, a, b)).doit()\n    \n    # Convert the result to a JSON serializable output\n    return float(area)", "input_generator": "import random\nimport sympy\nfrom sympy.abc import x, y, z\n\ndef input_generator():\n    # Choose a random variable from x, y, z\n    variable = random.choice(['x', 'y', 'z'])\n    \n    # Generate random polynomial functions for upper and lower functions\n    def random_polynomial(var):\n        degree = random.randint(1, 3)\n        coeffs = [random.randint(-5, 5) for _ in range(degree + 1)]\n        terms = []\n        for i, coeff in enumerate(coeffs):\n            if i == 0:\n                terms.append(str(coeff))\n            else:\n                if coeff > 0:\n                    terms.append(f\"+{coeff}*{var}^{i}\")\n                else:\n                    terms.append(f\"{coeff}*{var}^{i}\")\n        return ''.join(terms)\n    \n    upper_function = random_polynomial(variable)\n    lower_function = random_polynomial(variable)\n    \n    # Generate random bounds ensuring a < b\n    a = random.uniform(-10, 10)\n    b = a + random.uniform(1, 10)\n    \n    return {\n        'upper_function': upper_function,\n        'lower_function': lower_function,\n        'variable': variable,\n        'lower_bound': a,\n        'upper_bound': b\n    }", "io_pairs": [{"input": {"upper_function": "10*x^1+4*x^2", "lower_function": "3+4*x^1+4*x^2+4*x^3", "variable": "x", "lower_bound": -7.9598342901653085, "upper_bound": -4.9237529404827525}, "output": 3300.1632749476416}, {"input": {"upper_function": "1-3*x^1-2*x^2-4*x^3", "lower_function": "2-3*x^1+4*x^2", "variable": "x", "lower_bound": 7.986628121005129, "upper_bound": 14.38010023053965}, "output": -43627.06068172442}, {"input": {"upper_function": "4-5*z^1-5*z^2-3*z^3", "lower_function": "0+2*z^1-4*z^2-4*z^3", "variable": "z", "lower_bound": -1.8355442155466744, "upper_bound": 2.850297018164098}, "output": 5.9834411572863555}, {"input": {"upper_function": "0-3*z^1+2*z^2", "lower_function": "-1-2*z^1-2*z^20*z^3", "variable": "z", "lower_bound": -0.8640681620969115, "upper_bound": 2.6732614163159742}, "output": 1478471925.6086848}, {"input": {"upper_function": "-4-3*y^1", "lower_function": "-2-4*y^1+2*y^2", "variable": "y", "lower_bound": -8.011959885959312, "upper_bound": -4.289619148239426}, "output": -320.58479558594274}, {"input": {"upper_function": "-3-2*x^1-5*x^2", "lower_function": "-2+1*x^1", "variable": "x", "lower_bound": 4.511938403760006, "upper_bound": 10.512163339018672}, "output": -1924.2230475967078}, {"input": {"upper_function": "2-1*z^1+5*z^2+4*z^3", "lower_function": "5-2*z^1+2*z^2", "variable": "z", "lower_bound": 5.574476819900516, "upper_bound": 7.570483652045185}, "output": 2586.8344209059123}, {"input": {"upper_function": "3+2*z^1+2*z^2", "lower_function": "-3-5*z^1-5*z^2-1*z^3", "variable": "z", "lower_bound": 7.605056700389078, "upper_bound": 13.681909868939876}, "output": 13363.161353091651}, {"input": {"upper_function": "2+5*x^10*x^2", "lower_function": "0-4*x^1", "variable": "x", "lower_bound": -7.8360412629010785, "upper_bound": -5.178550088694419}, "output": 160800580492.19608}, {"input": {"upper_function": "1+2*z^1+1*z^2+4*z^3", "lower_function": "-30*z^1", "variable": "z", "lower_bound": -4.037941093495134, "upper_bound": 1.4312174376411075}, "output": -461.3689218037364}], "error_log": []}
{"context": "A monkey eats peaches in a peculiar way: each day, it eats half of the remaining peaches plus one more. On the last day, only one peach is left. How many peaches were there on the first day if the monkey followed this pattern for a given number of days?\n\nThe input and output requirements are as follows:\n\nInput:\n  `days` (int): The number of days to calculate backwards from the last day. For example, if the last day is day 10 and you want to calculate the number of peaches on day 1, `days` should be 10.\n\nOutput:\n  `return` (int): The number of peaches on the first day.", "reference_code": "# import necessary packages\n\n# main function\ndef main_solution(days):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    n = 1\n    for i in range(days - 1, 0, -1):\n        n = (n + 1) * 2\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return n", "input_generator": "import random\n\ndef input_generator():\n    days = random.randint(1, 20)\n    return {'days': days}", "io_pairs": [{"input": {"days": 6}, "output": 94}, {"input": {"days": 1}, "output": 1}, {"input": {"days": 16}, "output": 98302}, {"input": {"days": 17}, "output": 196606}, {"input": {"days": 4}, "output": 22}, {"input": {"days": 19}, "output": 786430}, {"input": {"days": 18}, "output": 393214}, {"input": {"days": 10}, "output": 1534}, {"input": {"days": 14}, "output": 24574}, {"input": {"days": 15}, "output": 49150}], "error_log": []}
{"context": "Given a square matrix of integers, what is the determinant of the matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of integers): A square matrix represented as a list of lists, where each inner list represents a row of the matrix. Each element in the matrix is an integer.\nOutput:\n  `return` (integer): The determinant of the input matrix.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef sub_mat(matrix, exclude_index):\n    mat = [row[1:] for i, row in enumerate(matrix) if i != exclude_index]\n    return mat\n\ndef determinant(matrix):\n    n = len(matrix)\n    if n == 1:\n        return matrix[0][0]\n    det = 0\n    sign = 1\n    for i in range(n):\n        det += sign * matrix[i][0] * determinant(sub_mat(matrix, i))\n        sign = -sign\n    return det\n\n# main function\ndef main_solution(matrix):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  det = determinant(matrix)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return det", "input_generator": "import random\n\ndef input_generator():\n    size = random.randint(2, 5)\n    matrix = []\n    for _ in range(size):\n        row = [random.randint(-10, 10) for _ in range(size)]\n        matrix.append(row)\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[4, 4], [0, -7]]}, "output": -28}, {"input": {"matrix": [[10, 5], [8, -4]]}, "output": -80}, {"input": {"matrix": [[-1, 10, -2], [6, 4, 7], [-2, 3, -1]]}, "output": -107}, {"input": {"matrix": [[9, 0, 10], [-7, 4, 4], [-8, 3, 3]]}, "output": 110}, {"input": {"matrix": [[-5, 10, -6], [-2, 8, -8], [10, 0, -5]]}, "output": -220}, {"input": {"matrix": [[3, 8], [-3, -9]]}, "output": -3}, {"input": {"matrix": [[-7, -9, 8], [-5, -10, 6], [4, -7, 2]]}, "output": 140}, {"input": {"matrix": [[8, -9, 6], [-9, -3, -3], [-4, -6, -2]]}, "output": 210}, {"input": {"matrix": [[6, 8], [-4, 9]]}, "output": 86}, {"input": {"matrix": [[4, 6], [1, 6]]}, "output": 18}], "error_log": []}
{"context": "Given a polynomial expression in string form and a value for the variable \"x\", what is the result of evaluating the polynomial for the given value of \"x\"? If the expression contains any errors, what should be returned?\n\nThe input and output requirements are as follows:\n\nInput:\n  `polynomial_string` (str): A string representing a polynomial expression in standard mathematical notation for a single variable \"x\". The string will not contain spaces and will only include the following operations: addition, subtraction, multiplication, division, exponentiation, and brackets.\n  `input_number` (float): A floating-point number representing the value of the variable \"x\" in the polynomial expression.\n\nOutput:\n  `return` (float or str): If the polynomial expression is valid and can be evaluated, the function returns a floating-point number representing the result of the evaluation. If the expression is invalid (e.g., unbalanced parentheses, invalid characters, or syntax errors), the function returns the string \"invalid\".", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(polynomial_string, input_number):\n    # Convert 'x' in the polynomial string to the input number\n    poly = polynomial_string.replace('x', str(input_number)).replace('^', '**')\n    \n    # Define allowed characters\n    allowed = '0123456789()+-/*'\n    \n    # Check if the polynomial string contains only allowed characters\n    if not poly or any(char not in allowed for char in poly):\n        return \"invalid\"\n    \n    # Convert the polynomial string to a list for manipulation\n    poly = list(poly)\n    \n    # Insert multiplication signs where necessary\n    for i in range(len(poly) - 1):\n        if (poly[i].isnumeric() and poly[i + 1].isnumeric()) or (poly[i].isnumeric() and poly[i + 1] == '('):\n            poly.insert(i + 1, '*')\n        if poly[i] in '+-/' and poly[i + 1] in '+-/*':\n            return \"invalid\"\n    \n    # Evaluate the polynomial expression\n    try:\n        result = eval(''.join(poly))\n        return result\n    except:\n        return \"invalid\"", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random polynomial string with reasonable complexity\n    terms = []\n    num_terms = random.randint(1, 5)\n    for _ in range(num_terms):\n        coeff = random.randint(-10, 10)\n        if coeff == 0:\n            coeff = 1  # Avoid zero coefficient for simplicity\n        power = random.randint(0, 3)\n        if power == 0:\n            term = f\"{coeff}\"\n        elif power == 1:\n            term = f\"{coeff}x\"\n        else:\n            term = f\"{coeff}x^{power}\"\n        terms.append(term)\n    \n    # Randomly decide to add some operations\n    operations = ['+', '-']\n    polynomial_string = terms[0]\n    for term in terms[1:]:\n        op = random.choice(operations)\n        polynomial_string += f\"{op}{term}\"\n    \n    # Randomly add parentheses sometimes\n    if random.choice([True, False]):\n        polynomial_string = f\"({polynomial_string})\"\n    \n    # Generate a random input number\n    input_number = random.randint(-10, 10)\n    \n    return {\n        'polynomial_string': polynomial_string,\n        'input_number': input_number\n    }", "io_pairs": [{"input": {"polynomial_string": "(-6x^2)", "input_number": -5}, "output": -31}, {"input": {"polynomial_string": "1+2x^3+4x+-7x+-8x^2", "input_number": 9}, "output": "invalid"}, {"input": {"polynomial_string": "-6x^2-10-9--7--8x^2", "input_number": -8}, "output": "invalid"}, {"input": {"polynomial_string": "-6x+9x^2--1x", "input_number": 10}, "output": 110}, {"input": {"polynomial_string": "-7+9x-4x", "input_number": 9}, "output": 25}, {"input": {"polynomial_string": "(9x+-8x^3+-4)", "input_number": 4}, "output": "invalid"}, {"input": {"polynomial_string": "(9x^2)", "input_number": 9}, "output": 729}, {"input": {"polynomial_string": "(2x^2--8x^3-7x^2)", "input_number": 3}, "output": "invalid"}, {"input": {"polynomial_string": "(4x^2+-6x+-9x^2)", "input_number": 0}, "output": "invalid"}, {"input": {"polynomial_string": "-3+1-5x^3--9x^3-9x^2", "input_number": 0}, "output": "invalid"}], "error_log": []}
{"context": "Given a starting point for a sequence, what is the first triangular number that is also pentagonal, starting from that point?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start_n` (int): The starting value for the variable `n` in the function. It should be a positive integer.\n\nOutput:\n  `return` (int): The first triangular number that is also pentagonal, starting from the value of `n` specified by `start_n`.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef isTriangular(t):\n    n = (math.sqrt(8*t+1)-1)/2\n    if n == int(n):\n        return True\n    return False\n\ndef isHexagonal(h):\n    n = (math.sqrt(8*h+1)+1)/4\n    if n == int(n):\n        return True\n    return False\n\ndef isPentagonal(p):\n    n = (math.sqrt(24*p+1)+1)/6\n    if n == int(n):\n        return True\n    return False\n\n# main function\ndef main_solution(start_n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    n = start_n + 1\n    while True:\n        t = n*(2*n-1)\n        if isPentagonal(t):\n            # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n            return t\n        n += 1", "input_generator": "import random\n\ndef input_generator():\n    return {'start_n': random.randint(1, 10000)}", "io_pairs": [{"input": {"start_n": 920}, "output": 1533776805}, {"input": {"start_n": 8264}, "output": 1533776805}, {"input": {"start_n": 6615}, "output": 1533776805}, {"input": {"start_n": 9283}, "output": 1533776805}, {"input": {"start_n": 4928}, "output": 1533776805}, {"input": {"start_n": 1834}, "output": 1533776805}, {"input": {"start_n": 6897}, "output": 1533776805}, {"input": {"start_n": 651}, "output": 1533776805}, {"input": {"start_n": 6616}, "output": 1533776805}, {"input": {"start_n": 7169}, "output": 1533776805}], "error_log": []}
{"context": "Given a positive integer, what are the prime factors and their respective counts in the factorization of that integer?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): A positive integer for which the prime factorization is to be computed.\nOutput:\n  `return` (dict): A dictionary where the keys are prime factors and the values are their respective counts in the factorization of `n`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef prime_factorize(n):\n    occurance, i = {}, 2\n    while(i*i <= n):\n        cnt = 0\n        while(n%i==0):\n            n /= i\n            cnt += 1\n        if cnt > 0:\n            occurance[i] = cnt\n        i += 1\n    if n > 1:\n        occurance[n] = 1\n    return occurance\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    factors = prime_factorize(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return factors", "input_generator": "import random\n\ndef input_generator():\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    n = 1\n    for _ in range(random.randint(1, 3)):\n        p = random.choice(primes)\n        e = random.randint(1, 3)\n        n *= p ** e\n    return {'n': n}", "io_pairs": [{"input": {"n": 48749}, "output": {"29": 1, "41": 2}}, {"input": {"n": 300763}, "output": {"67": 3}}, {"input": {"n": 529}, "output": {"23": 2}}, {"input": {"n": 189334919}, "output": {"23": 2, "71": 3}}, {"input": {"n": 129107}, "output": {"11": 3, "97.0": 1}}, {"input": {"n": 634933}, "output": {"13": 3, "17": 2}}, {"input": {"n": 120125}, "output": {"5": 3, "31": 2}}, {"input": {"n": 131959033}, "output": {"31": 1, "41": 1, "47": 3}}, {"input": {"n": 2305703}, "output": {"29": 1, "43": 3}}, {"input": {"n": 5869932649}, "output": {"7": 1, "23": 3, "41": 3}}], "error_log": []}
{"context": "Given a class name and a set of attributes, how would the attributes be transformed if the class is defined using a metaclass that converts all attribute names to uppercase? Specifically, what would be the resulting uppercase attributes and their corresponding values?\n\nThe input and output requirements are as follows:\n\nInput:\n  `class_name` (str): The name of the class to be created.\n  `attributes` (dict): A dictionary where keys are attribute names (str) and values are attribute values (str or int). These attributes will be converted to uppercase in the resulting class.\n\nOutput:\n  `return` (dict): A dictionary where keys are the uppercase attribute names (str) and values are the corresponding attribute values (str or int).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Meta(type):\n    def __new__(cls, class_name, bases, attrs):\n        a = {}\n        for name, val in attrs.items():\n            if name.startswith(\"__\"):\n                a[name] = val\n            else:\n                a[name.upper()] = val\n        return type(class_name, bases, a)\n\n# main function\ndef main_solution(class_name, attributes):\n    # Convert the attributes dictionary to a format suitable for the Meta class\n    attrs = {}\n    for key, value in attributes.items():\n        if isinstance(value, str):\n            attrs[key] = value\n        else:\n            attrs[key] = value\n    \n    # Create the class using the Meta metaclass\n    NewClass = Meta(class_name, (), attrs)\n    \n    # Instantiate the class\n    instance = NewClass()\n    \n    # Collect the uppercase attributes and their values\n    result = {attr: getattr(instance, attr) for attr in dir(instance) if attr.isupper()}\n    \n    # Return the result as a dictionary\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    class_name = ''.join(random.choices(string.ascii_letters, k=random.randint(3, 10)))\n    \n    num_attributes = random.randint(1, 5)\n    attributes = {}\n    for _ in range(num_attributes):\n        attr_name = ''.join(random.choices(string.ascii_letters, k=random.randint(3, 8)))\n        attr_value = ''.join(random.choices(string.ascii_letters + string.digits, k=random.randint(1, 10)))\n        if random.choice([True, False]):\n            attributes[attr_name] = attr_value\n        else:\n            attributes[attr_name] = random.randint(1, 100)\n    \n    return {\n        'class_name': class_name,\n        'attributes': attributes\n    }", "io_pairs": [{"input": {"class_name": "NdjeEusW", "attributes": {"bGYl": "cQSti", "BCk": 36}}, "output": {"BCK": 36, "BGYL": "cQSti"}}, {"input": {"class_name": "fHwwsDuxB", "attributes": {"XzrFlsh": 42}}, "output": {"XZRFLSH": 42}}, {"input": {"class_name": "BTZ", "attributes": {"bzUHUL": "VSusd9HDA", "ZpUglZ": "8PYuwOwvue", "MqUprUEf": "A"}}, "output": {"BZUHUL": "VSusd9HDA", "MQUPRUEF": "A", "ZPUGLZ": "8PYuwOwvue"}}, {"input": {"class_name": "ZNFCwIt", "attributes": {"YotOK": 37, "cOhy": 24}}, "output": {"COHY": 24, "YOTOK": 37}}, {"input": {"class_name": "xvyY", "attributes": {"ucUy": "F", "QUzF": "o", "omFWOOiE": 15}}, "output": {"OMFWOOIE": 15, "QUZF": "o", "UCUY": "F"}}, {"input": {"class_name": "mnWVmKyAM", "attributes": {"xsaRGVsd": 3}}, "output": {"XSARGVSD": 3}}, {"input": {"class_name": "iWxmjf", "attributes": {"kOoUmNfG": 30, "mrZc": "5dVB7JWx"}}, "output": {"KOOUMNFG": 30, "MRZC": "5dVB7JWx"}}, {"input": {"class_name": "rGJnKugCBs", "attributes": {"LBnOOF": "aLB", "lcejsQoa": 11, "zrVmIAtm": 42}}, "output": {"LBNOOF": "aLB", "LCEJSQOA": 11, "ZRVMIATM": 42}}, {"input": {"class_name": "sSjPcclcC", "attributes": {"KwTe": 53}}, "output": {"KWTE": 53}}, {"input": {"class_name": "TmTJzfU", "attributes": {"LkYOV": 77, "WTVblZH": 74, "kILrk": 43}}, "output": {"KILRK": 43, "LKYOV": 77, "WTVBLZH": 74}}], "error_log": []}
{"context": "In a card game, a deck of 52 cards is shuffled and dealt to multiple players. Each player receives a specific number of cards. After the dealing is complete, what are the ranks of the hands for each player? The rank of a hand is determined by the highest possible combination of cards (e.g., Straight Flush, Four of a Kind, etc.).\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_players` (int): The number of players in the game.\n  `num_cards_per_player` (int): The number of cards to be dealt to each player.\n\nOutput:\n  `return` (list of tuples): A list where each tuple contains the player's name and their hand rank. The hand rank is a tuple where the first element is the rank value (int) and the second element is the rank name (string).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Card(object):\n    suitList = [\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"]\n    rankList = [\"narf\", \"narf\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"]\n\n    def __init__(self, suit=0, rank=0):\n        self.suit = suit\n        self.rank = rank\n\n    def __str__(self):\n        return self.rankList[self.rank] + \" of \" + self.suitList[self.suit]\n\n    def __cmp__(self, other):\n        if self.suit > other.suit: return 1\n        if self.suit < other.suit: return -1\n        if self.rank > other.rank: return 1\n        if self.rank < other.rank: return -1\n        return 0\n\nclass Deck(object):\n    DECK_NORMAL = 1\n\n    def __init__(self, decktype=DECK_NORMAL):\n        self.cards = []\n        for suit in range(4):\n            for rank in range(2, 15):\n                self.cards.append(Card(suit, rank))\n\n    def shuffle(self, nshuffle=1):\n        nCards = len(self.cards)\n        for shuffle in range(nshuffle):\n            for i in range(nCards):\n                j = random.randrange(i, nCards)\n                [self.cards[i], self.cards[j]] = [self.cards[j], self.cards[i]]\n\n    def deal(self, hands, ncards=999):\n        nhands = len(hands)\n        for hand in hands:\n            for i in range(ncards):\n                if self.isempty(): break\n                card = self.popcard()\n                hand.addcard(card)\n\n    def popcard(self):\n        return self.cards.pop()\n\n    def isempty(self):\n        return (len(self.cards) == 0)\n\n    def __len__(self):\n        return len(self.cards)\n\nclass Hand(Deck):\n    def __init__(self, name=\"\"):\n        self.cards = []\n        self.name = name\n\n    def addcard(self, card):\n        self.cards.append(card)\n\nclass HandEvaluator(object):\n    RANK_NOTHING = (1, \"High card\")\n    RANK_PAIR = (2, \"Pair\")\n    RANK_DOUBLEPAIR = (3, \"Double Pair\")\n    RANK_THREEOFAKIND = (4, \"Three of a Kind\")\n    RANK_STRAIGHT = (5, \"Straight\")\n    RANK_FLUSH = (6, \"Flush\")\n    RANK_FULLHOUSE = (7, \"Full House\")\n    RANK_FOUROFAKIND = (8, \"Four of a Kind\")\n    RANK_STRAIGHTFLUSH = (9, \"Straight Flush\")\n    RANK_FIVEOFAKIND = (10, \"Five of a Kind\")\n\n    def is_straight(self, hand, numwildcards=0):\n        hand = set(hand)\n        if 14 in hand:\n            hand.add(1)\n        for low in (10, 9, 8, 7, 6, 5, 4, 3, 2, 1):\n            needed = set(range(low, low + 5))\n            if len(needed & hand) + numwildcards >= 5:\n                return low + 4\n        return -1\n\n    def is_group(self, hand, numwildcards=0):\n        result = []\n        counts = [(hand.count(v), v) for v in range(2, 15)]\n        for count, value in sorted(counts, reverse=True):\n            newcount = min(5, count + numwildcards)\n            numwildcards -= newcount - count\n            if newcount > 1:\n                result.append((newcount, value))\n        return result\n\n    def is_flush(self, hand, numwildcards=0):\n        counts = [(hand.count(v), v) for v in range(0, 4)]\n        for count, suit in sorted(counts, reverse=True):\n            newcount = min(5, count + numwildcards)\n            numwildcards -= newcount - count\n            if newcount >= 5:\n                return suit\n        return -1\n\n    def getrank(self, hand, numwildcards=0):\n        cardranks = [card.rank for card in hand.cards]\n        cardsuits = [card.suit for card in hand.cards]\n\n        result_group = self.is_group(cardranks, numwildcards)\n        rank = self.__rankgroup(result_group)\n\n        if rank[0] < self.RANK_FULLHOUSE[0]:\n            result_flush = self.is_flush(cardsuits, numwildcards)\n            if result_flush > -1:\n                return self.__rankflush(result_flush)\n\n        if rank[0] < self.RANK_STRAIGHT[0]:\n            result_straight = self.is_straight(cardranks, numwildcards)\n            if result_straight > -1:\n                return self.__rankstraight(result_straight)\n\n        return rank\n\n    def __rankgroup(self, group):\n        pair = 0\n        trips = 0\n        ranks = []\n\n        if len(group) == 0: return self.RANK_NOTHING\n\n        for count, rank in group:\n            ranks.append(Card.rankList[rank])\n            if count >= 5:\n                return self.RANK_FIVEOFAKIND\n            elif count == 4:\n                return self.RANK_FOUROFAKIND\n            elif count == 3:\n                trips += 1\n            elif count == 2:\n                pair += 1\n\n        if trips >= 2: return self.RANK_FULLHOUSE\n        if trips == 1 and pair >= 1: return self.RANK_FULLHOUSE\n        if trips >= 1: return self.RANK_THREEOFAKIND\n        if pair >= 2: return self.RANK_DOUBLEPAIR\n        elif pair == 1: return self.RANK_PAIR\n\n        return self.RANK_NOTHING\n\n    def __rankflush(self, suit):\n        ranks = [Card.suitList[suit]]\n        return self.RANK_FLUSH\n\n    def __rankstraight(self, highcard):\n        ranks = [Card.rankList[highcard]]\n        return self.RANK_STRAIGHT\n\n# main function\ndef main_solution(num_players, num_cards_per_player):\n    # all input arguments of the main_solution function should be json serializable\n    todeal = []\n    for hnd in range(num_players):\n        todeal.append(Hand(\"Player %s\" % (hnd + 1)))\n\n    d = Deck()\n    d.shuffle(3)\n    d.deal(todeal, num_cards_per_player)\n\n    ev = HandEvaluator()\n    results = []\n    for hand in todeal:\n        rank = ev.getrank(hand)\n        results.append((hand.name, rank))\n\n    # return, the returned value must be json serializable\n    return results", "input_generator": "import random\n\ndef input_generator():\n    num_players = random.randint(2, 6)\n    num_cards_per_player = random.randint(1, 5)\n    return {\n        'num_players': num_players,\n        'num_cards_per_player': num_yards_per_player\n    }", "io_pairs": [], "error_log": []}
{"context": "Given a set of encrypted messages in hexadecimal format and a guess word, what are the possible plaintext guesses that can be obtained by performing a crib dragging operation on the encrypted messages?\n\nThe input and output requirements are as follows:\n\nInput:\n  `ciphertexts` (str): A comma-separated string of hexadecimal ciphertexts.\n  `guess_word` (str): A string representing the guess word to be used in the crib dragging process.\n\nOutput:\n  `return` (list of str): A list of strings representing the possible plaintext guesses obtained from the crib dragging process.", "reference_code": "# import necessary packages\nimport string\n\n# all class and function definitions in the code file, if any\ndef createXORCiphers(ciphertexts):\n    \"\"\"\n    This takes all ciphertexts, and XOR's them with all other Ciphertexts.\n    Returns a list of all combinations of ciphertexts and the combinations reference ciphers\n    \"\"\"\n    xorCiphertexts = []\n    referenceXOR = []\n\n    #for every cipher, \n    while len(ciphertexts) > 0:\n        #convert cipher to byte array\n        original1 = ciphertexts[0]\n        message1 = []\n        conversion = bytes.fromhex(ciphertexts[0])\n        [message1.append(x) for x in conversion]\n            \n        #Remove so it doesn't compare with itself, and isn't compared with again in future iterations\n        ciphertexts.remove(ciphertexts[0])\n\n        #compare to every other cipher\n        for cipher in ciphertexts:\n            original2 = cipher\n            message2 = []\n            conversion = bytes.fromhex(cipher)\n            [message2.append(x) for x in conversion]\n            #XOR together and append to a list            \n            ciphertextxor = []\n            [ciphertextxor.append(x ^ y) for x, y in zip(message1, message2)]\n\n            referenceXOR.append([original1, original2])\n            xorCiphertexts.append(ciphertextxor)\n\n    return xorCiphertexts, referenceXOR\n\ndef convertToInt(s):\n    guessword = []\n    [guessword.append(ord(char)) for char in s]\n   \n    return guessword\n\ndef CribDragging(cipher, guessWord):\n    \"\"\"\n    Takes the guess word and the ciphertext and drags the guess words across the cipher\n    returns the xor of the guess word with all combinations of the cipher possible\n    removes guesses which contain unprintable characters\n    \"\"\"\n    guessWord = convertToInt(guessWord)\n    cipherguesses = []\n\n    #XOR the guess word with all locations of the cipher combination\n    for i in range(0, len(cipher)):    \n        cipherSection = cipher[i:i+len(guessWord)]\n        cipherGuess = []\n\n        [cipherGuess.append(x ^ y) for x, y in zip(cipherSection, guessWord)]\n\n        for i in range(0, len(cipherGuess)):\n            cipherGuess[i] = chr(cipherGuess[i])\n            #if characters are not printable, delete\n            if cipherGuess[i] not in list(string.printable):\n                del cipherGuess[i]\n                break\n        #if there are deletted characters, don't append.\n        if len(cipherGuess) >= len(guessWord):\n                cipherguesses.append(''.join(cipherGuess))\n    \n    if len(cipherguesses) > 0:\n        return cipherguesses\n\n# main function\ndef main_solution(ciphertexts, guess_word):\n    # Convert ciphertexts to a list of strings\n    ciphertexts = ciphertexts.split(',')\n    \n    # Create XOR ciphers and reference\n    xorCiphertexts, referenceXOR = createXORCiphers(ciphertexts)\n    \n    # Perform crib dragging with the guess word\n    results = []\n    for cipher in xorCiphertexts:\n        cipherguesses = CribDragging(cipher, guess_word)\n        if cipherguesses:\n            results.extend(cipherguesses)\n    \n    # Return the results as a JSON serializable list of strings\n    return results", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate random ciphertexts (hex strings)\n    num_ciphertexts = random.randint(2, 5)\n    ciphertexts = []\n    max_length = random.randint(10, 20)\n    \n    for _ in range(num_ciphertexts):\n        length = random.randint(5, max_length)\n        cipher = ''.join(random.choices('0123456789abcdef', k=length * 2))\n        ciphertexts.append(cipher)\n    \n    # Generate a random guess word (printable ASCII)\n    guess_word_length = random.randint(3, 8)\n    guess_word = ''.join(random.choices(string.ascii_letters + string.digits, k=guess_word_length))\n    \n    return {\n        'ciphertexts': ','.join(ciphertexts),\n        'guess_word': guess_word\n    }", "io_pairs": [{"input": {"ciphertexts": "7fbb7ade37fa459af511dc68c0,96f8bae8f442,ba0cbee626b66ecbbb,04411060d12d777ba796,01c10e28089f0c", "guess_word": "4ctgh"}, "output": ["\fr8L9", "%/_6&"]}, {"input": {"ciphertexts": "8c55fc5fe0f53932336b,377702ea26f4b416c4d53e53b4f9dc", "guess_word": "vprYr"}, "output": []}, {"input": {"ciphertexts": "8393f7aeb0ac2311aad9ca0b1a,393dbbae7bbb847e2c5bf54d924a", "guess_word": "7f0RDW"}, "output": []}, {"input": {"ciphertexts": "e4c2e1df27d63ca2090567,0d4149b51b2682", "guess_word": "Jeeji"}, "output": []}, {"input": {"ciphertexts": "8abc09525529ecaa,5e6b741e3c,e238344dc955a6a0e9c7a5", "guess_word": "ZDLAGgC"}, "output": []}, {"input": {"ciphertexts": "6d5a3f4ad9,ab18534aceb8,c5fb09316693,eb5632e39aa4143470", "guess_word": "hJPHrOdz"}, "output": []}, {"input": {"ciphertexts": "50b7d478e95ecc82615c119378,0b3fed4e28109e,1801a5024ff91d6b36,dc1d6a152d550a", "guess_word": "rUtZ"}, "output": []}, {"input": {"ciphertexts": "852f45920071,0f5927515fc7016ab8,ed25a69abf7a5be836,4967f3374a9951de21e0a4,9ea797e6ac0ebeba0b1317c9", "guess_word": "AQB"}, "output": ["KgU", "p-Q", "=B6"]}, {"input": {"ciphertexts": "cca9632aa76988,3d819c6f9cd7eed401a6,34908f25260f8993", "guess_word": "yq57D"}, "output": []}, {"input": {"ciphertexts": "77fd6c70636ad8fd,1f06ee1abe,35145c589e41b862fc,1212a020a1596c,de6c378539d6e63b644128", "guess_word": "ZnOY4avm"}, "output": []}], "error_log": []}
{"context": "In a family tree represented by parent-child relationships, each relationship is given as a pair of integers. Given a starting node, which represents a person in the family tree, what is the earliest ancestor of this person? The earliest ancestor is defined as the farthest ancestor from the starting node in the tree. If no ancestor is found, return `-1`.\n\nThe input and output requirements are as follows:\n\nInput:\n  `ancestors` (list of tuples): A list of tuples where each tuple contains two integers representing a parent-child relationship. The first integer is the parent, and the second integer is the child.\n  `starting_node` (int): An integer representing the starting node for which we need to find the earliest ancestor.\n\nOutput:\n  `return` (int): An integer representing the earliest ancestor of the `starting_node`. If no ancestor is found, it returns `-1`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Stack():\n    def __init__(self):\n        self.stack = []\n    def push(self, value):\n        self.stack.append(value)\n    def pop(self):\n        if self.size() > 0:\n            return self.stack.pop()\n        else:\n            return None\n    def size(self):\n        return len(self.stack)\n\ndef find_neighbors(child, arr):\n    neighbors = []\n    for neighbor in arr:\n        if neighbor[1] == child:\n            neighbors.append(neighbor[0])\n    return neighbors\n\n# main function\ndef main_solution(ancestors, starting_node):\n    # Convert input to the required format\n    ancestors = [(int(a), int(b)) for a, b in ancestors]\n    starting_node = int(starting_node)\n\n    # dfs - use a stack \n    s = Stack()\n    # keep track of the earliest_ancestor, initialized with the starting_node\n    earliest_list = [[starting_node]]\n    # get the neighbors\n    neighbors = find_neighbors(starting_node, ancestors)\n    \n    # no neighbors then return -1\n    if len(neighbors) == 0:\n        return -1\n\n    # add the neighbors to the stack\n    s.push(neighbors)\n    # keep track of the earliest_ancestor\n    earliest_list.append(neighbors)\n\n    # while stack still has items\n    while s.size() > 0:\n        # get the top item in the stack\n        curr = s.pop()\n        # iterate through the tuple\n        for el in curr:\n            # find the neighbors of each num in the tuple\n            next_node = find_neighbors(el, ancestors)\n            # if the neighbor exists\n            if len(next_node) != 0:\n                # add the neighbors to the stack\n                s.push(next_node)\n                # keep track of the ancestors\n                earliest_list.append(next_node)\n\n    # isolate and return the first number in the tuple of the last added ancestor (the earliest) \n    last = earliest_list[-1][0]\n\n    return last", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random number of ancestors (between 1 and 20)\n    num_ancestors = random.randint(1, 20)\n    \n    # Generate unique parent-child pairs\n    ancestors = set()\n    nodes = set()\n    \n    # Ensure at least one node has no parent (root)\n    root = random.randint(1, 100)\n    nodes.add(root)\n    \n    for _ in range(num_ancestors):\n        parent = random.randint(1, 100)\n        child = random.choice(list(nodes)) if nodes and random.random() > 0.3 else random.randint(1, 100)\n        ancestors.add((parent, child))\n        nodes.add(parent)\n        nodes.add(child)\n    \n    ancestors = list(ancestors)\n    \n    # Choose a starting node, ensuring it's in the nodes set or a new one\n    starting_node = random.choice(list(nodes)) if nodes and random.random() > 0.5 else random.randint(1, 100)\n    \n    return {\n        'ancestors': ancestors,\n        'starting_node': starting_node\n    }", "io_pairs": [{"input": {"ancestors": [[87, 22]], "starting_node": 69}, "output": -1}, {"input": {"ancestors": [[97, 61], [22, 98], [36, 75], [75, 80]], "starting_node": 74}, "output": -1}, {"input": {"ancestors": [[4, 53]], "starting_node": 34}, "output": -1}, {"input": {"ancestors": [[55, 10]], "starting_node": 45}, "output": -1}, {"input": {"ancestors": [[28, 45], [80, 92], [92, 5]], "starting_node": 28}, "output": -1}, {"input": {"ancestors": [[98, 41], [20, 98], [39, 82], [13, 41]], "starting_node": 39}, "output": -1}, {"input": {"ancestors": [[93, 63]], "starting_node": 63}, "output": 93}, {"input": {"ancestors": [[95, 62], [61, 47], [62, 12], [52, 84]], "starting_node": 95}, "output": -1}, {"input": {"ancestors": [[33, 3]], "starting_node": 33}, "output": -1}, {"input": {"ancestors": [[77, 7]], "starting_node": 77}, "output": -1}], "error_log": []}
{"context": "Given a 3x3 matrix of integers, what is the result of the matrix multiplication of the matrix with itself and the Frobenius norm of the matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_data` (list of lists of integers): A 3x3 matrix represented as a list of lists, where each inner list represents a row of the matrix.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `dot_product` (list of lists of integers): The result of the matrix multiplication of the input matrix with itself, represented as a list of lists.\n    - `norm` (float): The Frobenius norm of the input matrix, represented as a floating-point number.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix_data):\n    # Convert the JSON serializable input to a numpy array\n    arr = np.array(matrix_data)\n    \n    # Perform matrix multiplication\n    dot = np.dot(arr, arr)\n    \n    # Calculate the norm of the matrix\n    norm = np.linalg.norm(arr)\n    \n    # Convert the results to JSON serializable outputs\n    dot_serializable = dot.tolist()\n    norm_serializable = float(norm)\n    \n    # Return the results\n    return {\"dot_product\": dot_serializable, \"norm\": norm_serializable}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.randint(2, 5)\n    matrix_data = np.random.randint(-10, 10, size=(size, size)).tolist()\n    return {\"matrix_data\": matrix_data}", "io_pairs": [{"input": {"matrix_data": [[-5, -1], [-5, 9]]}, "output": {"dot_product": [[30, -4], [-20, 86]], "norm": 11.489125293076057}}, {"input": {"matrix_data": [[-3, 0], [8, -2]]}, "output": {"dot_product": [[9, 0], [-40, 4]], "norm": 8.774964387392123}}, {"input": {"matrix_data": [[-3, -1, -3], [0, -2, 2], [6, -7, -3]]}, "output": {"dot_product": [[-9, 26, 16], [12, -10, -10], [-36, 29, -23]], "norm": 11.0}}, {"input": {"matrix_data": [[0, -9, 2], [-5, -7, -1], [-6, -10, -9]]}, "output": {"dot_product": [[33, 43, -9], [41, 104, 6], [104, 214, 79]], "norm": 19.4164878389476}}, {"input": {"matrix_data": [[3, 7], [3, -6]]}, "output": {"dot_product": [[30, -21], [-9, 57]], "norm": 10.14889156509222}}, {"input": {"matrix_data": [[-8, 4, -9], [-10, -10, -9], [0, -7, 0]]}, "output": {"dot_product": [[24, -9, 36], [180, 123, 180], [70, 70, 63]], "norm": 22.15851980616034}}, {"input": {"matrix_data": [[3, 1, 7], [7, 6, 7], [9, -3, 9]]}, "output": {"dot_product": [[79, -12, 91], [126, 22, 154], [87, -36, 123]], "norm": 19.078784028338912}}, {"input": {"matrix_data": [[-9, -3, 8], [-1, -10, -8], [2, 2, 2]]}, "output": {"dot_product": [[100, 73, -32], [3, 87, 56], [-16, -22, 4]], "norm": 18.193405398660254}}, {"input": {"matrix_data": [[3, 4], [3, 4]]}, "output": {"dot_product": [[21, 28], [21, 28]], "norm": 7.0710678118654755}}, {"input": {"matrix_data": [[2, 9, -4], [-1, 5, 6], [5, 1, 9]]}, "output": {"dot_product": [[-25, 59, 10], [23, 22, 88], [54, 59, 67]], "norm": 16.431676725154983}}], "error_log": []}
{"context": "Given a string of length 10 where each character represents the presence ('o'), absence ('x'), or indifference ('?') of digits from 0 to 9 in a 4-digit combination, how many valid 4-digit combinations can be formed that include all digits marked with 'o' and exclude all digits marked with 'x'?\n\nThe input and output requirements are as follows:\n\nInput:\n  `s` (str): A string of length 10, where each character can be either 'o', 'x', or '?'. The string represents the presence ('o'), absence ('x'), or indifference ('?') of digits from 0 to 9 in a 4-digit combination.\n\nOutput:\n  `return` (int): The number of valid 4-digit combinations that include all digits marked with 'o' and exclude all digits marked with 'x'.", "reference_code": "# import necessary packages\nfrom itertools import product\n\n# main function\ndef main_solution(s):\n    # Convert the input string to a list of characters\n    s = list(s)\n    \n    exist = []\n    not_exist = []\n    \n    # Populate the exist and not_exist lists based on the input string\n    for i in range(10):\n        if s[i] == \"o\":\n            exist.append(i)\n        if s[i] == \"x\":\n            not_exist.append(i)\n    \n    exist = set(exist)\n    not_exist = set(not_exist)\n    \n    cnt = 0\n    \n    # Generate all possible 4-digit combinations using product\n    for prod in product(range(10), repeat=4):\n        prod = set(prod)\n        # Check if the combination contains all 'o' digits and no 'x' digits\n        if (prod >= exist) and prod.isdisjoint(not_exist):\n            cnt += 1\n    \n    # Return the count of valid combinations\n    return cnt", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random 10-character string consisting of 'o', 'x', and '?'\n    s = []\n    for _ in range(10):\n        choice = random.choice(['o', 'x', '?'])\n        s.append(choice)\n    return {'s': ''.join(s)}", "io_pairs": [{"input": {"s": "xxoxoo?x?x"}, "output": 84}, {"input": {"s": "?xxx??x?o?"}, "output": 671}, {"input": {"s": "ox???xo?oo"}, "output": 24}, {"input": {"s": "?ooxxxo?xo"}, "output": 24}, {"input": {"s": "??oxxxx??x"}, "output": 369}, {"input": {"s": "o???x?ooxo"}, "output": 24}, {"input": {"s": "o?oo?o?x?o"}, "output": 0}, {"input": {"s": "?oxox?xxxo"}, "output": 84}, {"input": {"s": "?o?xoxooxx"}, "output": 24}, {"input": {"s": "x?xxxxox?x"}, "output": 65}], "error_log": []}
{"context": "Given a function that calculates the sum of squares of two variables, how would the final coordinates change after performing gradient descent with a specified learning rate and number of steps, starting from a given initial point?\n\nThe input and output requirements are as follows:\n\nInput:\n  `init_x` (list of floats): A list containing the initial coordinates `[x1, x2]` for the gradient descent algorithm.\n  `lr` (float): The learning rate, a positive float that determines the step size at each iteration while moving toward a minimum of the function.\n  `step_num` (int): The number of steps to take during the gradient descent process.\n\nOutput:\n  `return` (list of floats): A list containing the final coordinates `[x1, x2]` after performing the gradient descent algorithm.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef function_2(x):\n    return x[0]**2 + x[1]**2\n\ndef numerical_gradient(f, x):\n    h = 1e-4\n    grad = np.zeros_like(x)\n\n    for idx in range(x.size):\n        tmp_val = x[idx]\n        x[idx] = tmp_val + h\n        fxh1 = f(x)\n        x[idx] = tmp_val - h\n        fxh2 = f(x)\n        grad[idx] = (fxh1 - fxh2) / (2 * h)\n        x[idx] = tmp_val\n    return grad\n\ndef gradient_descent(f, init_x, lr=0.01, step_num=100):\n    x = init_x\n    for i in range(step_num):\n        grad = numerical_gradient(f, x)\n        x -= lr * grad\n    return x\n\n# main function\ndef main_solution(init_x, lr, step_num):\n    # Convert JSON serializable inputs to numpy array\n    init_x = np.array(init_x)\n    \n    # Perform gradient descent\n    result = gradient_descent(function_2, init_x, lr, step_num)\n    \n    # Convert the result to a list for JSON serialization\n    return result.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    init_x = [random.uniform(-10, 10), random.uniform(-10, 10)]\n    lr = random.choice([0.001, 0.01, 0.1, 0.2])\n    step_num = random.randint(50, 200)\n    return {'init_x': init_x, 'lr': lr, 'step_num': step_num}", "io_pairs": [{"input": {"init_x": [7.111064358231442, -9.049707618776502], "lr": 0.2, "step_num": 120}, "output": [3.8381180422460484e-21, -2.0249381395298117e-21]}, {"input": {"init_x": [8.506788573159444, 1.8666234074709074], "lr": 0.1, "step_num": 160}, "output": [2.6556052620527145e-15, 5.827103537457406e-16]}, {"input": {"init_x": [7.6659243631597604, -3.496244361832086], "lr": 0.2, "step_num": 141}, "output": [4.9498487855173176e-21, -3.851352932046897e-21]}, {"input": {"init_x": [6.314549293403029, -6.2749408155765085], "lr": 0.01, "step_num": 193}, "output": [0.12793075604650908, -0.12712830091018118]}, {"input": {"init_x": [5.409868601977566, 8.874555163848626], "lr": 0.001, "step_num": 141}, "output": [4.079369442273427, 6.69195350436835]}, {"input": {"init_x": [-3.8875559885227577, -8.795548835649527], "lr": 0.2, "step_num": 140}, "output": [-6.643914680025918e-21, -5.5454188265554975e-21]}, {"input": {"init_x": [1.0353580328164895, 0.8442244930696052], "lr": 0.2, "step_num": 81}, "output": [1.1135968627331888e-18, 9.090516408610761e-19]}, {"input": {"init_x": [-7.261431244829037, 5.446540803601163], "lr": 0.2, "step_num": 158}, "output": [-4.910144116114772e-21, 3.798413372843503e-21]}, {"input": {"init_x": [5.93815986296441, 8.105851245403898], "lr": 0.01, "step_num": 154}, "output": [0.26452549870813097, 0.36108902296787987]}, {"input": {"init_x": [-8.436100932234572, 7.23335810365765], "lr": 0.01, "step_num": 165}, "output": [-0.30091529061204425, 0.25801351517077176]}], "error_log": []}
{"context": "Given a list of integers, what are all the possible ways to arrange the elements in the list?\n\nThe input and output requirements are as follows:\n\nInput:\n  `array` (list of integers): A list of integers for which all permutations need to be generated.\n\nOutput:\n  `return` (list of lists of integers): A list containing all possible permutations of the input array. Each permutation is represented as a list of integers.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(array):\n    # Convert the input list to a JSON serializable format\n    array = list(array)\n    \n    # Generate all permutations of the array\n    permutations = list(itertools.permutations(array))\n    \n    # Convert permutations to a JSON serializable format\n    permutations = [list(perm) for perm in permutations]\n    \n    return permutations", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    array = random.sample(string.ascii_letters + string.digits, length)\n    return {'array': array}", "io_pairs": [{"input": {"array": ["R"]}, "output": [["R"]]}, {"input": {"array": ["8"]}, "output": [["8"]]}, {"input": {"array": ["w", "E", "T"]}, "output": [["w", "E", "T"], ["w", "T", "E"], ["E", "w", "T"], ["E", "T", "w"], ["T", "w", "E"], ["T", "E", "w"]]}, {"input": {"array": ["x", "d", "f"]}, "output": [["x", "d", "f"], ["x", "f", "d"], ["d", "x", "f"], ["d", "f", "x"], ["f", "x", "d"], ["f", "d", "x"]]}, {"input": {"array": ["R", "u"]}, "output": [["R", "u"], ["u", "R"]]}, {"input": {"array": ["Y"]}, "output": [["Y"]]}, {"input": {"array": ["K", "w", "J"]}, "output": [["K", "w", "J"], ["K", "J", "w"], ["w", "K", "J"], ["w", "J", "K"], ["J", "K", "w"], ["J", "w", "K"]]}, {"input": {"array": ["g"]}, "output": [["g"]]}, {"input": {"array": ["p", "a"]}, "output": [["p", "a"], ["a", "p"]]}, {"input": {"array": ["5", "N", "B"]}, "output": [["5", "N", "B"], ["5", "B", "N"], ["N", "5", "B"], ["N", "B", "5"], ["B", "5", "N"], ["B", "N", "5"]]}], "error_log": []}
{"context": "Given two vectors in a 2D plane and a scalar value, what are the resulting vector after adding the two vectors and the resulting vector after multiplying the first vector by the scalar?\n\nThe input and output requirements are as follows:\n\nInput:\n  `vector1` (list of float): A list representing the first vector with two elements.\n  `vector2` (list of float): A list representing the second vector with two elements.\n  `scalar` (float): A scalar value to multiply the first vector.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `sum_vector` (list of float): A list representing the sum of `vector1` and `vector2`.\n    - `scaled_vector` (list of float): A list representing the result of multiplying `vector1` by `scalar`.", "reference_code": "# import necessary packages\nimport numpy as np\nimport sympy\n\n# main function\ndef main_solution(vector1, vector2, scalar):\n    # Convert input variables to numpy arrays\n    vec1 = np.array(vector1)\n    vec2 = np.array(vector2)\n    \n    # Perform vector addition\n    sum_vector = vec1 + vec2\n    \n    # Perform scalar multiplication\n    scaled_vector = vec1 * scalar\n    \n    # Convert output to JSON serializable format\n    sum_vector = sum_vector.tolist()\n    scaled_vector = scaled_vector.tolist()\n    \n    return {\"sum_vector\": sum_vector, \"scaled_vector\": scaled_vector}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate random vector length between 2 and 5\n    length = random.randint(2, 5)\n    \n    # Generate random integers for vector1 and vector2\n    vector1 = [random.randint(-10, 10) for _ in range(length)]\n    vector2 = [random.randint(-10, 10) for _ in range(length)]\n    \n    # Generate a random scalar between -5 and 5, excluding 0\n    scalar = random.choice([x for x in range(-5, 6) if x != 0])\n    \n    return {\"vector1\": vector1, \"vector2\": vector2, \"scalar\": scalar}", "io_pairs": [{"input": {"vector1": [6, -4, -2, 7], "vector2": [10, -4, -6, 6], "scalar": -5}, "output": {"sum_vector": [16, -8, -8, 13], "scaled_vector": [-30, 20, 10, -35]}}, {"input": {"vector1": [-9, -8], "vector2": [6, 6], "scalar": 3}, "output": {"sum_vector": [-3, -2], "scaled_vector": [-27, -24]}}, {"input": {"vector1": [-8, 7, 8, -7, -10], "vector2": [5, 0, -1, 7, -3], "scalar": 4}, "output": {"sum_vector": [-3, 7, 7, 0, -13], "scaled_vector": [-32, 28, 32, -28, -40]}}, {"input": {"vector1": [1, 5, 0], "vector2": [-4, 0, 8], "scalar": 4}, "output": {"sum_vector": [-3, 5, 8], "scaled_vector": [4, 20, 0]}}, {"input": {"vector1": [-7, 0], "vector2": [1, -7], "scalar": 5}, "output": {"sum_vector": [-6, -7], "scaled_vector": [-35, 0]}}, {"input": {"vector1": [6, -10, -9, 7], "vector2": [-2, -2, 3, 1], "scalar": -2}, "output": {"sum_vector": [4, -12, -6, 8], "scaled_vector": [-12, 20, 18, -14]}}, {"input": {"vector1": [-10, 9, 3, 7, -2], "vector2": [4, -2, -9, 6, 7], "scalar": -3}, "output": {"sum_vector": [-6, 7, -6, 13, 5], "scaled_vector": [30, -27, -9, -21, 6]}}, {"input": {"vector1": [4, 1], "vector2": [0, -3], "scalar": 4}, "output": {"sum_vector": [4, -2], "scaled_vector": [16, 4]}}, {"input": {"vector1": [3, 5, 8, 9, -7], "vector2": [-5, 10, 3, -1, 8], "scalar": 1}, "output": {"sum_vector": [-2, 15, 11, 8, 1], "scaled_vector": [3, 5, 8, 9, -7]}}, {"input": {"vector1": [-6, 5, 3], "vector2": [-8, 1, -10], "scalar": 3}, "output": {"sum_vector": [-14, 6, -7], "scaled_vector": [-18, 15, 9]}}], "error_log": []}
{"context": "In a game of cups, each cup is labeled with a unique number. The game involves moving cups around according to specific rules. Given a set of cups, a number of moves, and a specific result function, what is the final outcome of the game after performing the specified number of moves?\n\nThe input and output requirements are as follows:\n\nInput:\n  `cups` (list of int): A list of integers representing the labels of the cups.\n  `n_moves` (int): The number of moves to play the game.\n  `result_fn_name` (str): The name of the result function to use, either \"part1_result\" or \"part2_result\".\n\nOutput:\n  `return` (str or int): The result of the game, which can be either a string (for part1_result) or an integer (for part2_result).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Cup:\n    def __init__(self, label):\n        self.label = label\n        self.next = None\n\ndef play(cups, n_moves, result_fn):\n    n_cups = len(cups)\n    min_label = min(cups)\n    max_label = max(cups)\n\n    cups = [Cup(label) for label in cups]\n    for i in range(n_cups):\n        cups[i].next = cups[(i + 1) % n_cups]\n\n    # direct mapping to each cup\n    label_to_cup = {cup.label: cup for cup in cups}\n\n    current = cups[0]\n\n    for move in range(n_moves):\n        label = current.label\n        # remove next 3 cups\n        sl = [current.next, current.next.next, current.next.next.next]\n        sl_labels = {c.label for c in sl}\n        current.next = sl[-1].next\n\n        # get next destination cup which is not a part of current slice\n        # (can wrap around)\n        destination_label = label - 1\n        if destination_label < min_label:\n            destination_label = max_label\n        while destination_label in sl_labels:\n            destination_label -= 1\n            if destination_label < min_label:\n                destination_label = max_label\n        destination = label_to_cup[destination_label]\n\n        # insert slice back into cups\n        old_destination_next = destination.next\n        destination.next = sl[0]\n        sl[-1].next = old_destination_next\n\n        # update new current cup to be the next one from the current\n        current = current.next\n\n    one_cup = label_to_cup[1]\n    return result_fn(one_cup, n_cups)\n\ndef part1_result(one_cup, n_cups):\n    res = []\n    current = one_cup.next\n    while len(res) < n_cups - 1:\n        res.append(str(current.label))\n        current = current.next\n    return ''.join(res)\n\ndef part2_result(one_cup, n_cups):\n    return one_cup.next.label * one_cup.next.next.label\n\n# main function\ndef main_solution(cups, n_moves, result_fn_name):\n    # Convert result_fn_name to the actual function\n    result_fn = globals()[result_fn_name]\n    \n    # Play the game\n    result = play(cups, n_moves, result_fn)\n    \n    # Return the result\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random list of unique cup labels between 1 and 9 (for part1) or up to 1,000,000 (for part2)\n    result_fn_name = random.choice(['part1_result', 'part2_result'])\n    \n    if result_fn_name == 'part1_result':\n        # For part1, use a small number of cups (e.g., 5-9) and small n_moves (e.g., 10-100)\n        n_cups = random.randint(5, 9)\n        cups = random.sample(range(1, 10), n_cups)\n        n_moves = random.randint(10, 100)\n    else:\n        # For part2, use a larger number of cups (e.g., 100,000-1,000,000) and larger n_moves (e.g., 1,000-10,000)\n        n_cups = random.randint(100000, 1000000)\n        cups = list(range(1, n_cups + 1))\n        random.shuffle(cups)\n        n_moves = random.randint(1000, 10000)\n    \n    return {\n        'cups': cups,\n        'n_moves': n_moves,\n        'result_fn_name': result_fn_name\n    }", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a binary tree, determine whether it is symmetrical. A binary tree is symmetrical if it looks the same when reflected across its central axis. What is the result of checking the symmetry of the given binary tree structure?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (list of integers or None): A list representing the structure of the binary tree. Each element in the list corresponds to a node value, with `None` indicating a missing node. The list is constructed in a breadth-first manner, starting from the root.\n\nOutput:\n  `return` (boolean): A boolean value indicating whether the binary tree is symmetrical. `True` if the tree is symmetrical, `False` otherwise.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isSymmetrical(self, pRoot):\n        def isTrue(leftNode, rightNode):\n            if leftNode is None and rightNode is None:\n                return True\n            if leftNode is None or rightNode is None:\n                return False\n            if leftNode.val != rightNode.val:\n                return False\n            ret1 = isTrue(leftNode.left, rightNode.right)\n            ret2 = isTrue(leftNode.right, rightNode.left)\n            return ret1 and ret2\n\n        if pRoot is None:\n            return True\n        else:\n            return isTrue(pRoot.left, pRoot.right)\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(node_list):\n        if not node_list:\n            return None\n        nodes = [TreeNode(val) if val is not None else None for val in node_list]\n        kids = nodes[::-1]\n        root = kids.pop()\n        for node in nodes:\n            if node:\n                if kids: node.left = kids.pop()\n                if kids: node.right = kids.pop()\n        return root\n\n    pRoot = build_tree(tree_structure)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution()\n    result = solution.isSymmetrical(pRoot)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\nfrom random import choice, randint\n\ndef input_generator():\n    def generate_symmetric_tree(depth):\n        if depth == 0:\n            return [randint(1, 100)]\n        left = generate_symmetric_tree(depth - 1)\n        right = left.copy()\n        return [randint(1, 100)] + left + right\n    \n    def generate_asymmetric_tree(depth):\n        if depth == 0:\n            return [randint(1, 100)]\n        left = generate_asymmetric_tree(depth - 1)\n        right = generate_asymmetric_tree(depth - 1)\n        if random.random() < 0.5:\n            right[-1] = randint(1, 100) if right[-1] is not None else None\n        return [randint(1, 100)] + left + right\n    \n    def generate_random_tree(depth):\n        if depth == 0:\n            return [choice([randint(1, 100), None])]\n        left = generate_random_tree(depth - 1)\n        right = generate_random_tree(depth - 1)\n        return [choice([randint(1, 100), None])] + left + right\n    \n    options = [\n        [],  # empty tree\n        [1],  # single node\n        [1, 2, 2],  # simple symmetric\n        [1, 2, 3],  # simple asymmetric\n        generate_symmetric_tree(2),  # depth 2 symmetric\n        generate_asymmetric_tree(2),  # depth 2 asymmetric\n        generate_random_tree(3)  # random tree with depth 3\n    ]\n    \n    tree_structure = choice(options)\n    return {'tree_structure': tree_structure}", "io_pairs": [{"input": {"tree_structure": [1]}, "output": true}, {"input": {"tree_structure": [6, 46, 55, 71, 64, 29, 90]}, "output": false}, {"input": {"tree_structure": [1, 2, 2]}, "output": true}, {"input": {"tree_structure": [38, 36, 16, 16, 36, 16, 16]}, "output": false}, {"input": {"tree_structure": [1, 2, 3]}, "output": false}, {"input": {"tree_structure": []}, "output": true}, {"input": {"tree_structure": [null, null, 83, 8, 17, null, 34, null, null, null, null, 42, 14, null, 67]}, "output": true}, {"input": {"tree_structure": [50, 29, 47, 47, 29, 47, 47]}, "output": false}, {"input": {"tree_structure": [58, 97, 9, 9, 97, 9, 9]}, "output": false}, {"input": {"tree_structure": [78, 77, 40, null, null, 22, null, 52, 74, null, 99, 3, 93, 5, 50]}, "output": false}], "error_log": []}
{"context": "Given a number `z`, how can we encrypt and decrypt it using the RSA algorithm, and what are the corresponding public and private keys?\n\nThe input and output requirements are as follows:\n\nInput:\n  `z` (int): The integer to be encrypted using the RSA algorithm.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `public_key` (int): The public key used for encryption.\n    - `private_key` (int): The private key used for decryption.\n    - `encrypted` (int): The encrypted value of `z`.\n    - `decrypted` (int): The decrypted value of the encrypted `z`.", "reference_code": "# import necessary packages\nimport random\nimport math\n\n# all class and function definitions in the code file, if any\ndef isprime(x):\n    if x < 2:\n        return False\n    for n in range(2, x):\n        if x % n == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(z):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    primes = [i for i in range(10, 100) if isprime(i)]\n    p = random.choice(primes)\n    primes.remove(p)\n    q = random.choice(primes)\n    n = p * q\n    phi = (p - 1) * (q - 1)\n    \n    for i in range(2, phi):\n        if math.gcd(i, phi) == 1:\n            e = i\n            break\n    \n    d = 1\n    while True:\n        if (e * d) % phi == 1:\n            D = d\n            break\n        d += 1\n    \n    en = pow(z, e, n)\n    decrypt = pow(en, D, n)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"public_key\": e, \"private_key\": D, \"encrypted\": en, \"decrypted\": decrypt}", "input_generator": "import random\n\ndef input_generator():\n    z = random.randint(1, 1000)\n    return {\"z\": z}", "io_pairs": [{"input": {"z": 897}, "output": {"public_key": 5, "private_key": 1685, "encrypted": 1403, "decrypted": 897}}, {"input": {"z": 669}, "output": {"public_key": 7, "private_key": 823, "encrypted": 4386, "decrypted": 669}}, {"input": {"z": 357}, "output": {"public_key": 5, "private_key": 461, "encrypted": 374, "decrypted": 357}}, {"input": {"z": 998}, "output": {"public_key": 7, "private_key": 43, "encrypted": 68, "decrypted": 316}}, {"input": {"z": 495}, "output": {"public_key": 5, "private_key": 5117, "encrypted": 670, "decrypted": 495}}, {"input": {"z": 110}, "output": {"public_key": 5, "private_key": 1037, "encrypted": 819, "decrypted": 110}}, {"input": {"z": 593}, "output": {"public_key": 5, "private_key": 1325, "encrypted": 1148, "decrypted": 593}}, {"input": {"z": 991}, "output": {"public_key": 7, "private_key": 703, "encrypted": 61, "decrypted": 991}}, {"input": {"z": 840}, "output": {"public_key": 7, "private_key": 283, "encrypted": 368, "decrypted": 103}}, {"input": {"z": 652}, "output": {"public_key": 5, "private_key": 53, "encrypted": 292, "decrypted": 54}}], "error_log": []}
{"context": "Given a function \\( f(x) = \\sin(x) \\), we want to approximate the integral of \\( f(x) \\) over a specified interval using Simpson's rule. What is the computed integral value when integrating \\( f(x) \\) from `a` to `b` with `N` intervals?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The lower bound of the integral.\n  `b` (float): The upper bound of the integral.\n  `N` (int): The number of intervals for the Simpson's rule.\n\nOutput:\n  `return` (dict): A dictionary containing the key `integral_value` which holds the computed integral value as a float.", "reference_code": "# import necessary packages\nimport numpy as n\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef f(x):\n    y = n.sin(x)\n    return y\n\ndef g(x):\n    y = 2 / (n.sqrt(n.pi)) * n.exp(-(x)**2)\n    return y\n\ndef simpson(f, a, b, N):\n    h = float(b - a) / N\n    i = 1\n    n = 1\n    \n    I_1 = 0.\n    while i < N:\n        I_1 += f(a + i * h)\n        i += 1\n    \n    I_2 = 0   \n    while n < N + 1:\n        I_2 += f(a + n * h - h / 2)\n        n += 1\n    return (h / 6) * (f(a) + f(b) + 2 * I_1 + 4 * I_2)\n\n# main function\ndef main_solution(a, b, N):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    integral_value = simpson(f, a, b, N)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"integral_value\": integral_value}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    a = random.uniform(-10, 10)\n    b = random.uniform(a, a + 20)\n    N = random.randint(10, 100)\n    return {\"a\": float(a), \"b\": float(b), \"N\": int(N)}", "io_pairs": [{"input": {"a": 4.002973543717047, "b": 15.769796141014842, "N": 30}, "output": {"integral_value": 0.3467014699870034}}, {"input": {"a": 6.4536868605015165, "b": 11.877837056199397, "N": 77}, "output": {"integral_value": 0.2133211606474436}}, {"input": {"a": 4.423274694943837, "b": 11.00161724342585, "N": 37}, "output": {"integral_value": -0.2911464026918168}}, {"input": {"a": -7.589931467839104, "b": 2.9503929875926325, "N": 77}, "output": {"integral_value": 1.2427695851278935}}, {"input": {"a": -7.719827226292417, "b": 11.363844008479376, "N": 60}, "output": {"integral_value": -0.2262501469064983}}, {"input": {"a": 4.952343375763652, "b": 8.344759324639872, "N": 74}, "output": {"integral_value": 0.7089702575790635}}, {"input": {"a": 1.841895996913399, "b": 4.310367739585257, "N": 30}, "output": {"integral_value": 0.12348812834401819}}, {"input": {"a": -4.459762312377665, "b": 12.90264902664748, "N": 34}, "output": {"integral_value": -1.193965761079571}}, {"input": {"a": -0.3606289258041073, "b": 3.3190752177798877, "N": 76}, "output": {"integral_value": 1.9199663581315194}}, {"input": {"a": 7.738568941158682, "b": 20.54976005221858, "N": 21}, "output": {"integral_value": 0.24421544235318493}}], "error_log": []}
{"context": "Given a nucleic sequence composed of the characters 'a', 'c', 't', and 'g', and a specific length `k`, determine the positions where a given motif of length `k` appears in the sequence. What are the positions of the motif in the sequence?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sequence` (str): A string representing the nucleic sequence. It should only contain the characters 'a', 'c', 't', and 'g'.\n  `k` (int): An integer representing the length of the motif to be searched in the sequence.\n  `motif` (str): A string representing the motif to be searched in the sequence. It should be of length `k` and only contain the characters 'a', 'c', 't', and 'g'.\n\nOutput:\n  `return` (dict): A dictionary with a single key \"positions\" which is a list of integers representing the positions (1-based index) where the motif appears in the sequence. If the motif does not appear, the list will be empty.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef __Creation_Liste_Taille__(sequence, taille):\n    \"\"\"\n    Creation liste L de motif de 'sequence' de taille 'taille' avec chevauchement\n    \"\"\"\n    L = list()  # liste vide\n    for i in range(len(sequence)):  # Parcours de la chaine\n        if len(sequence[i:]) >= taille:  # sortie si il reste moins de 3 lettres\n            L.append(sequence[i:i + taille])\n        else:\n            break\n    return L\n\ndef __Lettre_Base_4__(motif):\n    \"\"\"\n    transformation d'un motif en base 4 \n    a==>0\n    c==>1\n    t==>2\n    g==>3\n    \"\"\"\n    ADN = [\"a\", \"c\", \"t\", \"g\"]\n    base4 = \"\"\n    for lettre in motif:\n        base4 = base4 + str(ADN.index(lettre))\n    return base4\n\ndef __Base_4_En_Base_10__(base4):\n    \"\"\"\n    tranformation d'un entier en base 4 en base 10\n    base4 : string\n    base10: int\n    \"\"\"\n    base4 = base4[::-1]  # string reverse\n    resultat = 0\n    pos = 0  # position dans base4\n    for chiffre in base4:\n        resultat = resultat + int(chiffre) * (4 ** pos)\n        pos += 1\n    return resultat\n\ndef __Creation_Liste_Taille_Base10__(L):\n    \"\"\"\n    Creation liste L1 associe a L contenant les entiers correspondant aux motifs presents dans L\n    \"\"\"\n    L1 = list()  # liste vide\n    for item in L:\n        L1.append(__Base_4_En_Base_10__(__Lettre_Base_4__(item)))\n    return L1\n\ndef __Initialisation_Table_M_(L1):\n    M = list()\n    for i in range(1, len(L1) + 1):  # de 1 a \"taille de L1\"\n        M.append(0)\n    return M\n\ndef __Initialisation_Table_H_(L):\n    k = len(L[0])\n    H = list()\n    for i in range(4 ** k):  # de 0 a 4**k-1\n        H.append(0)\n    return H\n\ndef __Remplissage_M_H__(L1, H, M):\n    for i in range(len(L1)):  # de 0 a taille L1-1 \n        n = L1[i]\n        if H[n] == 0:\n            H[n] = i + 1\n        else:\n            M[i] = H[n]\n            H[n] = i + 1\n    return H, M\n\n# main function\ndef main_solution(sequence, k, motif):\n    \"\"\"\n    Main function to process the sequence and find the positions of the motif.\n    \"\"\"\n    # Convert input variables if necessary\n    L = __Creation_Liste_Taille__(sequence, k)\n    L1 = __Creation_Liste_Taille_Base10__(L)\n    M = __Initialisation_Table_M_(L1)\n    H = __Initialisation_Table_H_(L)\n    H, M = __Remplissage_M_H__(L1, H, M)\n    \n    # Convert motif to base 10 score\n    score = __Base_4_En_Base_10__(__Lettre_Base_4__(motif))\n    res = H[score]\n    \n    positions = []\n    if res > 0:\n        positions.append(res)\n        while M[res - 1] > 0:\n            positions.append(M[res - 1])\n            res = M[res - 1]\n    \n    # Convert output to JSON serializable format\n    return {\"positions\": positions}", "input_generator": "import random\n\ndef input_generator():\n    bases = ['a', 'c', 't', 'g']\n    sequence_length = random.randint(10, 50)\n    sequence = ''.join(random.choices(bases, k=sequence_length))\n    k = random.randint(2, 4)\n    possible_motifs = [sequence[i:i+k] for i in range(len(sequence) - k + 1)]\n    if possible_motifs:\n        motif = random.choice(possible_motifs)\n    else:\n        motif = ''.join(random.choices(bases, k=k))\n    return {\"sequence\": sequence, \"k\": k, \"motif\": motif}", "io_pairs": [{"input": {"sequence": "caacaccggtgatacggcctgggcatgca", "k": 4, "motif": "gtga"}, "output": {"positions": [9]}}, {"input": {"sequence": "atcacagctt", "k": 4, "motif": "cagc"}, "output": {"positions": [5]}}, {"input": {"sequence": "tgtgcagcgtggtgttaacttggaactcgttt", "k": 4, "motif": "tgtg"}, "output": {"positions": [1]}}, {"input": {"sequence": "tcggctatgccaaaagactgcgttac", "k": 2, "motif": "ct"}, "output": {"positions": [18, 5]}}, {"input": {"sequence": "taaatcgttcgcgcttagatacgcctgta", "k": 4, "motif": "tcgc"}, "output": {"positions": [9]}}, {"input": {"sequence": "gtctgagtctacccaggtcg", "k": 4, "motif": "agtc"}, "output": {"positions": [6]}}, {"input": {"sequence": "gtaaatcgctaatat", "k": 3, "motif": "tcg"}, "output": {"positions": [6]}}, {"input": {"sequence": "atatgcgtcttatggtggaagaaatgaacttccgtgggtgctg", "k": 3, "motif": "tgc"}, "output": {"positions": [39, 4]}}, {"input": {"sequence": "gccatacacgttgataa", "k": 3, "motif": "tga"}, "output": {"positions": [12]}}, {"input": {"sequence": "attttagtgggccccgatatatcgaaagctcgacatcctccgactatag", "k": 2, "motif": "ct"}, "output": {"positions": [44, 38, 29]}}], "error_log": []}
{"context": "Given a binary search tree, how can you convert it into a sorted doubly linked list without creating any new nodes, but only by adjusting the pointers of the existing nodes? What is the sequence of node values in the resulting doubly linked list?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (str): A JSON string representing the structure of the binary search tree. Each node is represented as a list where the first element is the node value, the second element is the left subtree (another list), and the third element is the right subtree (another list). If a subtree is empty, it is represented as `null`.\n\nOutput:\n  `return` (list): A list of integers representing the values of the nodes in the converted sorted doubly linked list, in ascending order.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def Convert(self, pRootOfTree):\n        if not pRootOfTree:\n            return None\n        self.pre = None  # \u5fc5\u987b\u8981\u7528\u5168\u5c40\u53d8\u91cf\uff0c\u6216\u8005\u662f\u4f20\u5730\u5740\u6216\u5f15\u7528\n\n        self.core(pRootOfTree)\n        while pRootOfTree.left:\n            pRootOfTree = pRootOfTree.left\n        return pRootOfTree\n\n    def core(self, root):\n        if not root:\n            return None\n        # \u4e2d\u5e8f\u904d\u5386\n        if root.left:\n            self.core(root.left)\n\n        if self.pre:\n            self.pre.right = root\n        root.left = self.pre\n        self.pre = root\n\n        if root.right:\n            self.core(root.right)\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(data):\n        if not data:\n            return None\n        root = TreeNode(data[0])\n        root.left = build_tree(data[1])\n        root.right = build_tree(data[2])\n        return root\n\n    tree_structure = json.loads(tree_structure)\n    root = build_tree(tree_structure)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution()\n    converted_tree = solution.Convert(root)\n    \n    # Convert the output to JSON serializable format\n    result = []\n    while converted_tree:\n        result.append(converted_tree.val)\n        converted_tree = converted_tree.right\n    \n    return result", "input_generator": "import json\nimport random\n\ndef input_generator():\n    def generate_tree(depth):\n        if depth == 0 or random.random() < 0.3:\n            return None\n        val = random.randint(1, 100)\n        left = generate_tree(depth - 1)\n        right = generate_tree(depth - 1)\n        return [val, left, right]\n    \n    tree_structure = generate_tree(random.randint(1, 5))\n    return {'tree_structure': json.dumps(tree_structure)}", "io_pairs": [{"input": {"tree_structure": "[25, null, null]"}, "output": [25]}, {"input": {"tree_structure": "[71, null, [83, null, [92, null, [64, null, null]]]]"}, "output": [71, 83, 92, 64]}, {"input": {"tree_structure": "[46, [1, null, null], [10, null, null]]"}, "output": [1, 46, 10]}, {"input": {"tree_structure": "[20, [71, null, null], null]"}, "output": [71, 20]}, {"input": {"tree_structure": "[16, null, null]"}, "output": [16]}, {"input": {"tree_structure": "[3, [77, null, null], [44, null, null]]"}, "output": [77, 3, 44]}, {"input": {"tree_structure": "null"}, "output": []}, {"input": {"tree_structure": "[46, [77, null, null], [85, null, null]]"}, "output": [77, 46, 85]}, {"input": {"tree_structure": "[55, null, null]"}, "output": [55]}, {"input": {"tree_structure": "[70, null, null]"}, "output": [70]}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = 3x - \\cos(x) - 1 \\), we want to find an approximate root using the Newton-Raphson method. What is the final approximation of the root and the error array after performing a specified number of iterations starting from a given initial guess?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of iterations to perform.\n  `x0` (float): The initial guess for the root.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `final_approximation` (float): The final approximation of the root.\n    - `error_array` (list of float): An array of errors calculated during each iteration.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(n, x0):\n    # Convert inputs to appropriate types if necessary\n    n = int(n)\n    x0 = float(x0)\n    \n    # Define the functions f and df\n    def f(x):\n        return 3 * x - np.cos(x) - 1\n    \n    def df(x):\n        return 3 + np.sin(x)\n    \n    # Initialize arrays\n    x = np.zeros(n)\n    x[0] = x0\n    \n    # Perform the Newton-Raphson method\n    for k in range(n - 1):\n        x[k + 1] = x[k] - f(x[k]) / df(x[k])\n    \n    # Calculate the error\n    e = np.zeros(n)\n    for i in range(n - 1):\n        e[i + 1] = abs((x[i + 1] - x[i]) / x[i + 1])\n    \n    # Return the final approximation and the error array\n    return {\n        \"final_approximation\": float(x[n - 1]),\n        \"error_array\": e.tolist()\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    n = random.randint(5, 20)\n    x0 = random.uniform(-10.0, 10.0)\n    return {\n        \"n\": n,\n        \"x0\": x0\n    }", "io_pairs": [{"input": {"n": 7, "x0": -9.90615471186989}, "output": {"final_approximation": 0.6071016481031226, "error_array": [0.0, 6.6695116712682125, 2.04611607584618, 0.9514446354324874, 0.042046017035727044, 0.00012198238371770159, 1.0389327673496279e-09]}}, {"input": {"n": 8, "x0": -1.4852316870389632}, "output": {"final_approximation": 0.6071016481031226, "error_array": [0.0, 2.1600769065636345, 1.0164502845356354, 0.04567337719109183, 0.0001437889651838139, 1.4435826333824092e-09, 0.0, 0.0]}}, {"input": {"n": 13, "x0": 7.4543699348452215}, "output": {"final_approximation": 0.6071016481031226, "error_array": [0.0, 2.5404254645531146, 2.5308532127031658, 0.017789060899859314, 2.220659873092683e-05, 3.443254738160241e-11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}, {"input": {"n": 10, "x0": -4.374476224716783}, "output": {"final_approximation": 0.6071016481031226, "error_array": [0.0, 3.9877003701483074, 1.845739853300654, 0.6671886398158327, 0.024529891259793865, 4.1724928006430614e-05, 1.21560953337047e-10, 0.0, 0.0, 0.0]}}, {"input": {"n": 17, "x0": 4.7914100244984485}, "output": {"final_approximation": 0.6071016481031226, "error_array": [0.0, 3.595732639021491, 2.5015495184066636, 0.9437874966903267, 0.041601646527783066, 0.00011943271073647785, 9.959558599680753e-10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}, {"input": {"n": 12, "x0": 9.86616523582661}, "output": {"final_approximation": 0.6071016481031226, "error_array": [0.0, 7.1627017274256, 2.2461215998419637, 1.02281029111127, 0.04601250935716162, 0.0001459181201715227, 1.4866500627381495e-09, 0.0, 0.0, 0.0, 0.0, 0.0]}}, {"input": {"n": 13, "x0": 5.910431378066042}, "output": {"final_approximation": 0.6071016481031226, "error_array": [0.0, 71.44698083645291, 1.1221185876684645, 0.13036169782358653, 0.0011430498852825679, 9.120085150528275e-08, 5.486180253804418e-16, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}, {"input": {"n": 14, "x0": 2.6411156270216942}, "output": {"final_approximation": 0.6071016481031226, "error_array": [0.0, 5.612135875094519, 0.3481509812988199, 0.009333256072838234, 6.066437213092778e-06, 2.5695439582068626e-12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}, {"input": {"n": 6, "x0": -1.3689285758442882}, "output": {"final_approximation": 0.6071016481031226, "error_array": [0.0, 2.088142060962815, 0.9847292603156159, 0.04393796176927146, 0.00013313540321683082, 1.237596315100967e-09]}}, {"input": {"n": 15, "x0": 7.996317045583911}, "output": {"final_approximation": 0.6071016481031226, "error_array": [0.0, 2.636410489527358, 2.8220074468055683, 0.052499708475924556, 0.00019529918995610173, 2.663085526006329e-09, 1.8287267512681394e-16, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}], "error_log": []}
{"context": "Given a list of floating-point numbers, what is the result of applying the softmax function to this list? The softmax function is a mathematical function that converts a list of numbers into a probability distribution, where each number is transformed into a value between 0 and 1, and the sum of all values is 1.\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_array` (list of float): A list of floating-point numbers representing the input array for which the softmax function will be applied.\n\nOutput:\n  `return` (list of float): A list of floating-point numbers representing the output of the softmax function applied to the input array. The sum of the elements in this list will be approximately 1.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(input_array):\n    # Convert input_array to a numpy array\n    a = np.array(input_array)\n    \n    # Define the softmax function\n    def softmax(a):\n        c = np.max(a)\n        exp_a = np.exp(a - c) # overflow \ub300\ucc45\n        sum_exp_a = np.sum(exp_a)\n        y = exp_a / sum_exp_a\n        return y\n    \n    # Apply softmax to the input array\n    y = softmax(a)\n    \n    # Convert the result to a list for JSON serialization\n    return y.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the size of the array (between 2 and 10 elements)\n    size = random.randint(2, 10)\n    # Generate random values for the array (between -10.0 and 10.0)\n    input_array = [random.uniform(-10.0, 10.0) for _ in range(size)]\n    return {'input_array': input_array}", "io_pairs": [{"input": {"input_array": [-1.738388114299589, -7.934763866167871, 0.8809312360774175, -2.427962705549356, 2.4204705622592098, 5.290728367733642, -9.21561275574792, -5.539532016426499, 3.1993170171088465, -1.4705347726183664]}, "output": [0.0007412671941950129, 1.5098123844375918e-06, 0.010174913373725496, 0.0003719600868151069, 0.04743994255711949, 0.8369148637028263, 4.1942796036918884e-07, 1.65637611231442e-05, 0.1033696086527417, 0.0009689514311089487]}, {"input": {"input_array": [-2.1469828042903982, 9.419200888297507, -7.747996997404956, -3.0931821199233456, 1.8684439851999635, 8.598864526587843]}, "output": [6.580513441721419e-06, 0.6940480445407505, 2.4309175187587453e-08, 2.554645476602712e-06, 0.0003648694295928896, 0.30557792656156296]}, {"input": {"input_array": [3.347740296221657, -3.504096670741874, 3.059694482548254, 4.008320860428045, 1.3684958310324227, -0.880101806647339]}, "output": [0.2604534213547135, 0.00027543243470742375, 0.1952690257027192, 0.5042159278681361, 0.03598778499686677, 0.0037984076428570707]}, {"input": {"input_array": [-5.566149988574995, 6.283583477685045, 8.0968494763972, -6.71354003440088, -3.546222441892139, 5.857488601828958]}, "output": [9.173777013429012e-07, 0.12847600865122588, 0.7876140475603701, 2.91234629628363e-07, 6.914990167492501e-06, 0.08390182018590547]}, {"input": {"input_array": [3.768871560172073, -5.609766117995028, 0.03424928942378003, -0.7836798149461366, 6.712011713324792]}, "output": [0.04997539885207255, 4.22343366629836e-06, 0.001193521989057441, 0.0005267545893642445, 0.9483001011358395]}, {"input": {"input_array": [1.6546239000752667, 9.156829603037743, 2.074164497112971, -0.7068421931189768, 5.611981411667488, -4.131600609514104, 5.042159521144418, -3.6901018896869715, -6.733542910575361]}, "output": [0.000527267573952064, 0.9554272036574071, 0.0008021123996105631, 4.9711786452831785e-05, 0.027586054761186973, 1.618473855246471e-06, 0.01560339458577929, 2.516785168705082e-06, 1.1997658736809942e-07]}, {"input": {"input_array": [-5.457149639640642, -1.2347084585226042, 9.545410594170729, 0.5142273765249055, 6.136090121133133, -3.1213015049831156, -5.149646673654682, -6.394198053951294, 5.486575669822697, 6.358079999957582]}, "output": [2.794756932062205e-07, 1.906017778203348e-05, 0.9159529506059363, 0.0001095670905504481, 0.030284757294472865, 2.889282435892185e-06, 3.800938855824259e-07, 1.094936885989764e-07, 0.015817708048956866, 0.037812298436598196]}, {"input": {"input_array": [4.753379747660006, -2.441697741357629]}, "output": [0.9992502925375959, 0.0007497074624040281]}, {"input": {"input_array": [-6.859301601444107, -5.767706512597508, 0.942395145273256]}, "output": [0.0004083756876238315, 0.0012165601943322463, 0.9983750641180439]}, {"input": {"input_array": [2.9220269450927603, -4.046215564487836, -0.26275998350883256, 1.2388782659024002, -8.689802188697048]}, "output": [0.8142490360579595, 0.0007664573312095383, 0.03369937636554534, 0.1512777545335396, 7.375711746044858e-06]}], "error_log": []}
{"context": "Given a sequence of digits, determine if the sequence can be divided into ascending or ascending AND consecutive numbers. For example, the sequence \"232425\" can be divided into consecutive numbers 23, 24, and 25. What is the result of this determination for a randomly generated sequence of digits?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string consisting of digits. The string should have at least two digits and can be of any length.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input string consists of ascending or ascending AND consecutive numbers. Returns `True` if the condition is met, otherwise `False`.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef ascending(txt):\n    for i in range(2, len(txt) + 1):\n        if len(txt) % i == 0:\n            digits = int(len(txt) / i)\n            for index in range(0, len(txt) - digits, digits):\n                if int(txt[index: index + digits]) == int(txt[index + digits: index + (digits * 2)]) - 1:\n                    if index == len(txt) - (digits * 2):\n                        return True\n                else:\n                    break\n    return False\n\n# main function\ndef main_solution(input_string):\n    # input_string is a string representing the sequence of digits\n    result = ascending(input_string)\n    # result is a boolean indicating whether the string consists of ascending or ascending AND consecutive numbers\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Randomly decide whether to generate a valid ascending sequence or not\n    if random.choice([True, False]):\n        # Generate a valid ascending sequence\n        start = random.randint(1, 1000)\n        length = random.randint(2, 5)\n        step = random.randint(1, 3)\n        parts = [str(start + i * step) for i in range(length)]\n        input_string = ''.join(parts)\n    else:\n        # Generate a random string that is unlikely to be ascending\n        input_string = ''.join(random.choices(string.digits, k=random.randint(4, 12)))\n    \n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "4849"}, "output": true}, {"input": {"input_string": "2630494156"}, "output": false}, {"input": {"input_string": "258261264267270"}, "output": false}, {"input": {"input_string": "723726"}, "output": false}, {"input": {"input_string": "698513725280"}, "output": false}, {"input": {"input_string": "278393419"}, "output": false}, {"input": {"input_string": "1779581614"}, "output": false}, {"input": {"input_string": "67094645"}, "output": false}, {"input": {"input_string": "35981154968"}, "output": false}, {"input": {"input_string": "652654656658"}, "output": false}], "error_log": []}
{"context": "Given a chessboard of size `n x n`, where `n` is an integer, how can you place `n` queens on the board such that no two queens can attack each other? Provide the positions of the queens on the board.\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the chessboard and the number of queens to place on the board.\n\nOutput:\n  `return` (list of tuples): A list of tuples representing the positions of the queens on the chessboard. Each tuple contains two integers, the row and column indices of a queen. If no solution exists, the function returns `None`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_safe(board, row, col, n):\n    # Check this row on left side\n    for i in range(col):\n        if board[row][i] == 1:\n            return False\n\n    # Check upper diagonal on left side\n    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n\n    # Check lower diagonal on left side\n    for i, j in zip(range(row, n, 1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n\n    return True\n\ndef solve_n_queens_util(board, col, n):\n    if col >= n:\n        return True\n\n    for i in range(n):\n        if is_safe(board, i, col, n):\n            board[i][col] = 1\n            if solve_n_queens_util(board, col + 1, n):\n                return True\n            board[i][col] = 0\n\n    return False\n\ndef solve_n_queens(n):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    if not solve_n_queens_util(board, 0, n):\n        return None\n    return board\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = solve_n_queens(n)\n    if solution is None:\n        return None\n    # Convert the board to a list of queen positions\n    queen_positions = [(i, j) for i in range(n) for j in range(n) if solution[i][j] == 1]\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return queen_positions", "input_generator": "import random\n\ndef input_generator():\n    n = random.choice([4, 5, 6, 7, 8])\n    return {'n': n}", "io_pairs": [{"input": {"n": 4}, "output": [[0, 2], [1, 0], [2, 3], [3, 1]]}, {"input": {"n": 8}, "output": [[0, 0], [1, 6], [2, 4], [3, 7], [4, 1], [5, 3], [6, 5], [7, 2]]}, {"input": {"n": 6}, "output": [[0, 3], [1, 0], [2, 4], [3, 1], [4, 5], [5, 2]]}, {"input": {"n": 7}, "output": [[0, 0], [1, 4], [2, 1], [3, 5], [4, 2], [5, 6], [6, 3]]}, {"input": {"n": 5}, "output": [[0, 0], [1, 3], [2, 1], [3, 4], [4, 2]]}], "error_log": []}
{"context": "Given a dataset of numerical values, how can we determine the confidence interval for the mean of the dataset at a specified confidence level? Specifically, what are the lower and upper bounds of the confidence interval for the mean of the dataset at a 95% confidence level?\n\nThe input and output requirements are as follows:\n\nInput:\n  `array` (list of float): A list of numeric values for which the confidence interval is to be calculated.\n  `conf` (float): Confidence interval, in range 0 <= conf <= 1. Default is 0.95.\n  `normal_threshold` (int): The number of elements in the array is < normal_threshold, use a T-distribution. If the number of elements in the array is >= normal_threshold, use a normal distribution. Default is 30.\n  `error_only` (bool): If true, return only the size of the symmetrical confidence interval, equal to ci_upper - mean. Default is False.\n\nOutput:\n  `return` (tuple of float or float): If `error_only` is False, returns a tuple of lower and upper bounds on the confidence interval. If `error_only` is True, returns the size of the symmetrical confidence interval.", "reference_code": "# import necessary packages\nimport math\nimport numpy as np\nfrom scipy import stats\n\n# main function\ndef main_solution(array, conf=0.95, normal_threshold=30, error_only=False):\n  \"\"\"\n  Calculate the confidence interval for a given array of numbers.\n\n  Arguments:\n  array (list of float): A list of numeric values.\n  conf (float): Confidence interval, in range 0 <= conf <= 1.\n  normal_threshold (int): The number of elements in the array is < normal_threshold, use a T-distribution. If the number of elements in the array is >= normal_threshold, use a normal distribution.\n  error_only (bool): If true, return only the size of the symmetrical confidence interval, equal to ci_upper - mean.\n\n  Returns:\n  (float, float) or float: If error_only is False, returns a tuple of lower and upper bounds on the confidence interval. If error_only is True, returns the size of the symmetrical confidence interval.\n  \"\"\"\n  n = len(array)\n\n  if n < 1:\n    # We have no data.\n    array_mean, c0, c1 = 0, 0, 0\n  elif n == 1:\n    # We have only a single datapoint, so return that value.\n    array_mean, c0, c1 = array[0], array[0], array[0]\n  else:\n    scale = np.std(array) / math.sqrt(n)\n    # Check if all values are the same.\n    values_all_same = all(x == array[0] for x in array[1:])\n\n    if values_all_same:\n      # If values are all the same, return that value.\n      array_mean, c0, c1 = array[0], array[0], array[0]\n    else:\n      array_mean = np.mean(array)\n      if n < normal_threshold:\n        # We have a \"small\" number of datapoints, so use a t-distribution.\n        c0, c1 = stats.t.interval(conf, n - 1, loc=array_mean, scale=scale)\n      else:\n        # We have a \"large\" number of datapoints, so use a normal distribution.\n        c0, c1 = stats.norm.interval(conf, loc=array_mean, scale=scale)\n\n  if error_only:\n    return c1 - array_mean\n  else:\n    return c0, c1", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    array_length = random.choice([0, 1, random.randint(2, 29), random.randint(30, 100)])\n    if array_length == 0:\n        array = []\n    elif array_length == 1:\n        array = [random.uniform(0, 100)]\n    else:\n        if random.random() < 0.1:  # 10% chance all values are the same\n            val = random.uniform(0, 100)\n            array = [val] * array_length\n        else:\n            array = list(np.random.normal(loc=50, scale=20, size=array_length))\n    \n    conf = random.choice([0.9, 0.95, 0.99])\n    normal_threshold = random.choice([30, 50, 100])\n    error_only = random.choice([True, False])\n    \n    return {\n        'array': array,\n        'conf': conf,\n        'normal_threshold': normal_threshold,\n        'error_only': error_only\n    }", "io_pairs": [{"input": {"array": [47.32522689428777], "conf": 0.9, "normal_threshold": 30, "error_only": false}, "output": [47.32522689428777, 47.32522689428777]}, {"input": {"array": [81.09323898707643], "conf": 0.95, "normal_threshold": 30, "error_only": true}, "output": 0.0}, {"input": {"array": [], "conf": 0.95, "normal_threshold": 30, "error_only": false}, "output": [0, 0]}, {"input": {"array": [], "conf": 0.99, "normal_threshold": 100, "error_only": true}, "output": 0}, {"input": {"array": [29.54550709852154], "conf": 0.9, "normal_threshold": 100, "error_only": true}, "output": 0.0}, {"input": {"array": [], "conf": 0.95, "normal_threshold": 100, "error_only": true}, "output": 0}, {"input": {"array": [], "conf": 0.9, "normal_threshold": 100, "error_only": true}, "output": 0}, {"input": {"array": [39.05667213418206], "conf": 0.99, "normal_threshold": 100, "error_only": true}, "output": 0.0}, {"input": {"array": [67.18971926198496, 62.1044709688961, 49.01730194236518, 48.410366487140216], "conf": 0.9, "normal_threshold": 50, "error_only": true}, "output": 9.613260329493833}, {"input": {"array": [66.96108082160548], "conf": 0.99, "normal_threshold": 50, "error_only": false}, "output": [66.96108082160548, 66.96108082160548]}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, a player and a computer take turns marking spaces on a 3x3 grid. The player can choose to be either 'X' or 'O', and the computer will take the opposite mark. Given the player's chosen mark and a sequence of moves made by the player, what will be the final configuration of the Tic-Tac-Toe board after the game concludes?\n\nThe input and output requirements are as follows:\n\nInput:\n  `playerMark` (int): An integer (0 or 1) indicating whether the player is 'X' (0) or 'O' (1).\n  `playerMoves` (list of int): A list of integers representing the player's moves on the Tic-Tac-Toe board. Each integer should be between 0 and 8, inclusive.\n\nOutput:\n  `return` (str): A string representing the final state of the Tic-Tac-Toe board after the game ends. Each character in the string corresponds to a position on the board ('X', 'O', or '-').", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass TicTacToe:\n    def __init__(self, playerMark):\n        self.gameboard = ['-', '-', '-', '-', '-', '-', '-', '-', '-']\n        self.turn = ['X', 'O']\n        self.player = self.turn[playerMark]\n        self.computer = self.turn[(playerMark + 1) % 2]\n        self.turnNum = 0\n        self.lastindex = {}\n\n    def checkResult(self, gameboard=None):\n        gb = gameboard if gameboard else self.gameboard\n        if '-' not in gb:\n            return 0\n        elif (gb[0] == gb[1] == gb[2] and gb[0] != '-') or (gb[3] == gb[4] == gb[5] and gb[3] != '-') or (gb[6] == gb[7] == gb[8] and gb[6] != '-'):\n            return 1\n        elif (gb[2] == gb[5] == gb[8] and gb[2] != '-') or (gb[1] == gb[4] == gb[7] and gb[1] != '-') or (gb[0] == gb[3] == gb[6] and gb[0] != '-'):\n            return 1\n        elif (gb[2] == gb[4] == gb[6] and gb[2] != '-') or (gb[0] == gb[4] == gb[8] and gb[0] != '-'):\n            return 1\n        return -1\n\n    def getEarliest(self, gameboard, turnNum, turn):\n        earliest = {'win': (10, 10), 'loss': (10, 10)}\n        currOutcome = 'loss' if turn == self.player else 'win'\n        notTurn = 'X' if turn == 'O' else 'O'\n        if '-' not in gameboard:\n            self.updateEarliest(earliest, turnNum - 1, self.lastindex[turn], 'win')\n            self.updateEarliest(earliest, turnNum, self.lastindex[turn], 'loss')\n            return earliest\n        for i in range(9):\n            if gameboard[i] != '-':\n                continue\n            gameboard[i] = turn\n            self.lastindex[turn] = i\n            if self.checkResult(gameboard) >= 0:\n                self.updateEarliest(earliest, turnNum, i, currOutcome)\n            else:\n                predicted = self.getEarliest(gameboard, turnNum + 1, notTurn)\n                self.updateEarliest(earliest, predicted['win'][0], predicted['win'][1], 'win')\n                self.updateEarliest(earliest, predicted['loss'][0], predicted['loss'][1], 'loss')\n            gameboard[i] = '-'\n        return earliest\n\n    def updateEarliest(self, earliest, turnNum, position, earliestKey):\n        if turnNum < earliest[earliestKey][0]:\n            earliest[earliestKey] = (turnNum, position)\n\n    def makeCompMove(self):\n        earliest = self.getEarliest(self.gameboard, self.turnNum, self.turn[self.turnNum % 2])\n        if earliest['win'][0] == self.turnNum and self.gameboard[earliest['win'][1]] == '-':\n            self.makeMove(earliest['win'][1])\n        elif earliest['loss'][0] == self.turnNum + 1 and earliest['loss'][1] != 10:\n            self.makeMove(earliest['loss'][1])\n        else:\n            self.makeMove(earliest['win'][1])\n\n    def makeMove(self, move):\n        if self.checkResult(self.gameboard) >= 0:\n            return\n        if 0 <= move <= 8 and '-' in self.gameboard:\n            self.gameboard[move] = self.turn[self.turnNum % 2]\n            self.turnNum += 1\n\n# main function\ndef main_solution(playerMark, playerMoves):\n    game = TicTacToe(playerMark)\n    for move in playerMoves:\n        game.makeMove(move)\n        if game.checkResult() >= 0:\n            break\n        game.makeCompMove()\n        if game.checkResult() >= 0:\n            break\n    return ''.join(game.gameboard)", "input_generator": "import random\n\ndef input_generator():\n    playerMark = random.randint(0, 1)\n    num_moves = random.randint(1, 5)\n    playerMoves = random.sample(range(9), num_moves)\n    return {\n        'playerMark': playerMark,\n        'playerMoves': playerMoves\n    }", "io_pairs": [{"input": {"playerMark": 0, "playerMoves": [0, 7, 3, 5, 6]}, "output": "X-OXOXOX-"}, {"input": {"playerMark": 0, "playerMoves": [2, 0]}, "output": "XOX---O--"}, {"input": {"playerMark": 1, "playerMoves": [6, 2, 0, 7, 5]}, "output": "X-XOOOXXO"}, {"input": {"playerMark": 0, "playerMoves": [4]}, "output": "----X-O--"}, {"input": {"playerMark": 1, "playerMoves": [1, 5]}, "output": "-X---X-OO"}, {"input": {"playerMark": 0, "playerMoves": [5, 8]}, "output": "--O--XO-X"}, {"input": {"playerMark": 1, "playerMoves": [4, 5, 3, 7]}, "output": "---XXX-O-"}, {"input": {"playerMark": 0, "playerMoves": [2, 4, 5, 7, 3]}, "output": "O-XOXXO--"}, {"input": {"playerMark": 0, "playerMoves": [7, 0, 5, 3]}, "output": "X-O-OXOX-"}, {"input": {"playerMark": 0, "playerMoves": [1, 3, 6, 5]}, "output": "OX-XOXX-O"}], "error_log": []}
{"context": "Given a doubly linked list where each node has a next pointer and an arbitrary pointer, how can you clone the list such that the cloned list has the same structure, including the arbitrary pointers? Specifically, what is the structure of the cloned list when provided with the values of the nodes and the indices of the nodes that the arbitrary pointers point to?\n\nThe input and output requirements are as follows:\n\nInput:\n  `node_values` (list of int): A list of integers representing the values of the nodes in the doubly linked list.\n  `arb_pointers` (list of int or None): A list of integers or None values representing the arbitrary pointers of the nodes. Each integer in this list corresponds to the index of the node in the `node_values` list that the arbitrary pointer should point to. If the value is `None`, it means the arbitrary pointer is not set for that node.\n\nOutput:\n  `return` (list of dict): A list of dictionaries representing the cloned doubly linked list with arbitrary pointers. Each dictionary contains:\n    - `value` (int): The value of the node.\n    - `next` (int or None): The value of the next node in the list, or `None` if it is the last node.\n    - `arb` (int or None): The value of the node pointed to by the arbitrary pointer, or `None` if the arbitrary pointer is not set.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass ArbDoublyListNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n        self.arb = None\n\n    def insertNodeNext(self, node):\n        self.next = node\n\n    def insertNodeArb(self, node):\n        self.arb = node\n\n# main function\ndef main_solution(node_values, arb_pointers):\n    # Convert JSON serializable inputs to original input variables\n    nodes = [ArbDoublyListNode(value) for value in node_values]\n    \n    for i in range(len(nodes) - 1):\n        nodes[i].insertNodeNext(nodes[i + 1])\n    \n    for i, arb_index in enumerate(arb_pointers):\n        if arb_index is not None:\n            nodes[i].insertNodeArb(nodes[arb_index])\n    \n    # Clone the doubly linked list with arbitrary pointers\n    def cloneDoublyArbList(root):\n        if root is None:\n            return None\n        \n        # Create a copy of the root node\n        rootCopy = ArbDoublyListNode(root.value)\n        rootCopy.next = cloneDoublyArbList(root.next)\n        rootCopy.arb = root.arb\n        \n        return rootCopy\n    \n    cloned_root = cloneDoublyArbList(nodes[0])\n    \n    # Convert the cloned list to a JSON serializable output\n    result = []\n    current = cloned_root\n    while current:\n        result.append({\n            \"value\": current.value,\n            \"next\": current.next.value if current.next else None,\n            \"arb\": current.arb.value if current.arb else None\n        })\n        current = current.next\n    \n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random length for the linked list between 1 and 10\n    length = random.randint(1, 10)\n    \n    # Generate random node values (integers between 1 and 100)\n    node_values = [random.randint(1, 100) for _ in range(length)]\n    \n    # Generate random arb pointers (indices or None)\n    arb_pointers = []\n    for i in range(length):\n        if random.random() < 0.5:  # 50% chance to have an arb pointer\n            arb_pointers.append(random.randint(0, length - 1))\n        else:\n            arb_pointers.append(None)\n    \n    return {\n        \"node_values\": node_values,\n        \"arb_pointers\": arb_pointers\n    }", "io_pairs": [{"input": {"node_values": [14], "arb_pointers": [null]}, "output": [{"value": 14, "next": null, "arb": null}]}, {"input": {"node_values": [91], "arb_pointers": [0]}, "output": [{"value": 91, "next": null, "arb": 91}]}, {"input": {"node_values": [30, 47], "arb_pointers": [null, null]}, "output": [{"value": 30, "next": 47, "arb": null}, {"value": 47, "next": null, "arb": null}]}, {"input": {"node_values": [87], "arb_pointers": [null]}, "output": [{"value": 87, "next": null, "arb": null}]}, {"input": {"node_values": [86, 48], "arb_pointers": [0, null]}, "output": [{"value": 86, "next": 48, "arb": 86}, {"value": 48, "next": null, "arb": null}]}, {"input": {"node_values": [38], "arb_pointers": [0]}, "output": [{"value": 38, "next": null, "arb": 38}]}, {"input": {"node_values": [99, 84], "arb_pointers": [0, 0]}, "output": [{"value": 99, "next": 84, "arb": 99}, {"value": 84, "next": null, "arb": 99}]}, {"input": {"node_values": [43, 100], "arb_pointers": [0, null]}, "output": [{"value": 43, "next": 100, "arb": 43}, {"value": 100, "next": null, "arb": null}]}, {"input": {"node_values": [97], "arb_pointers": [0]}, "output": [{"value": 97, "next": null, "arb": 97}]}, {"input": {"node_values": [64], "arb_pointers": [0]}, "output": [{"value": 64, "next": null, "arb": 64}]}], "error_log": []}
{"context": "Given a grid of size `grid_size` by `grid_size`, where you can only move right or down, how many unique routes are there from the top-left corner to the bottom-right corner of the grid?\n\nThe input and output requirements are as follows:\n\nInput:\n  `grid_size` (int): The size of the grid (e.g., 20 for a 20x20 grid).\n\nOutput:\n  `return` (int): The number of unique routes from the top-left corner to the bottom-right corner of the grid, moving only right and down.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(grid_size):\n    # Calculate the number of routes through a grid of size grid_size x grid_size\n    top = math.factorial(2 * grid_size)\n    bottom = math.factorial(grid_size) ** 2\n    num_routes = top // bottom\n    return num_routes", "input_generator": "import random\n\ndef input_generator():\n    grid_size = random.randint(1, 10)  # Reasonable range to avoid large computations\n    return {'grid_size': grid_size}", "io_pairs": [{"input": {"grid_size": 9}, "output": 48620}, {"input": {"grid_size": 7}, "output": 3432}, {"input": {"grid_size": 10}, "output": 184756}, {"input": {"grid_size": 8}, "output": 12870}, {"input": {"grid_size": 5}, "output": 252}, {"input": {"grid_size": 3}, "output": 20}, {"input": {"grid_size": 4}, "output": 70}, {"input": {"grid_size": 2}, "output": 6}, {"input": {"grid_size": 1}, "output": 2}, {"input": {"grid_size": 6}, "output": 924}], "error_log": []}
{"context": "Given a set of 5 poker cards represented by numbers, where 0 represents a wildcard (joker) that can be any number, determine if these cards form a continuous sequence. What is the result indicating whether the cards form a continuous sequence?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numbers` (list of integers): A list of 5 integers representing the poker cards. The integers can be between 0 and 13, where 0 represents a wildcard (joker) that can be any number.\n\nOutput:\n  `return` (dictionary): A dictionary with a single key `\"is_continuous\"`, which is a boolean value indicating whether the given list of poker cards forms a continuous sequence.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def IsContinuous(self, numbers):\n        numZero = 0\n        numInterval = 0\n        length = len(numbers)\n        if length <= 0:\n            return False\n        numbers.sort()\n        for i in range(0, length - 1):\n            if numbers[i] == 0:\n                numZero += 1\n                continue\n            if numbers[i] == numbers[i + 1]:\n                return False\n            numInterval += numbers[i + 1] - numbers[i] - 1\n            if numInterval > 4:\n                return False\n        if numZero >= numInterval:\n            return True\n        return False\n\n# main function\ndef main_solution(numbers):\n    # Convert input to list if it's not already\n    if not isinstance(numbers, list):\n        numbers = list(numbers)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the IsContinuous method and return the result\n    result = solution.IsContinuous(numbers)\n    \n    # Convert the result to a JSON serializable format\n    return {\"is_continuous\": result}", "input_generator": "import random\n\ndef input_generator():\n    # Decide whether to generate a valid or invalid case\n    case_type = random.choice(['valid', 'invalid', 'empty', 'duplicate'])\n    \n    if case_type == 'valid':\n        # Generate a valid continuous sequence with possible zeros\n        non_zero = random.sample(range(1, 14), random.randint(4, 5))\n        num_zeros = 5 - len(non_zero)\n        numbers = non_zero + [0] * num_zeros\n        random.shuffle(numbers)\n    elif case_type == 'invalid':\n        # Generate an invalid sequence (non-continuous and not solvable with zeros)\n        non_zero = random.sample(range(1, 14), 5)\n        while max(non_zero) - min(non_zero) <= 4:\n            non_zero = random.sample(range(1, 14), 5)\n        num_zeros = random.randint(0, 2)\n        numbers = non_zero[:5 - num_zeros] + [0] * num_zeros\n        random.shuffle(numbers)\n    elif case_type == 'empty':\n        # Return an empty list\n        numbers = []\n    else:\n        # Generate a list with duplicate non-zero numbers\n        non_zero = random.choices(range(1, 14), k=4)\n        duplicate = random.choice(non_zero)\n        numbers = non_zero + [duplicate]\n        random.shuffle(numbers)\n    \n    return {'numbers': numbers}", "io_pairs": [{"input": {"numbers": [6, 7, 11, 11, 11]}, "output": {"is_continuous": false}}, {"input": {"numbers": []}, "output": {"is_continuous": false}}, {"input": {"numbers": [4, 5, 6, 7, 7]}, "output": {"is_continuous": false}}, {"input": {"numbers": [0, 1, 7, 9, 12]}, "output": {"is_continuous": false}}, {"input": {"numbers": [3, 5, 9, 11, 13]}, "output": {"is_continuous": false}}, {"input": {"numbers": [0, 2, 4, 8, 10]}, "output": {"is_continuous": false}}, {"input": {"numbers": [4, 5, 8, 12, 13]}, "output": {"is_continuous": false}}, {"input": {"numbers": [1, 3, 12, 12, 13]}, "output": {"is_continuous": false}}, {"input": {"numbers": [0, 0, 5, 9, 10]}, "output": {"is_continuous": false}}, {"input": {"numbers": [1, 2, 3, 4, 6]}, "output": {"is_continuous": false}}], "error_log": []}
{"context": "Given a string containing logical expressions, how can we obfuscate these expressions while maintaining their logical equivalence? Specifically, what is the resulting string after obfuscating the logical expressions in the given input string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `source_string` (str): A string containing logical expressions. The string should be formatted such that logical expressions are separated by spaces.\n\nOutput:\n  `obfuscated_string` (str): A string with obfuscated logical expressions. The string is formatted such that obfuscated logical expressions are separated by spaces.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef createLogicDict(logicKey):\n    \"\"\"returns a dictionary containing equivalent logical expressions of the inputted logic key\n\n       i-type:: string\n       r-type:: dictionary\n    \"\"\"\n    logicDict = {logicKey: [\"!!\" + logicKey, logicKey + \" || \" + logicKey, logicKey + \" && \" + logicKey,\n                            \"!!\" + logicKey + \" && \" + logicKey, \"!!\" + logicKey + \" || \" + logicKey, logicKey,\n                            \"!!\" + logicKey + \" && \" + \"!!\" + logicKey, \"!!\" + logicKey + \" || \" + \"!!\" + logicKey]\n                 }\n    return logicDict\n\ndef obfuscateBoolean(key):\n    \"\"\" Outputs equivalent boolean expression \"\"\"\n    logicDict = createLogicDict(key)\n    logic = random.choice(logicDict[key]) #choose a random value that conserves logic, but appearance is altered.\n    return logic\n\ndef isTarget(elem):\n    \"\"\"Boolean function that returns true if the element inputted is a 'logic Key'.\n       \n       i-type:: string\n       r-type:: boolean\n    \"\"\"\n    anti_bool = [\"for\", \"while\", \"if\", \"||\", \"&&\", \"elif\", \"else\", \"!\"]\n    if elem in anti_bool:\n        return False\n    else:\n        return True\n\ndef findAllP(source):\n    \"\"\" returns array of len=2 tuples containing the indice of all logic elements stored in the source array \n    \n        i-type:: array\n        r-type:: (indice, item) IN array\n    \"\"\"\n    reduced = []\n    for index, item in enumerate(source):\n        if isTarget(item):\n            reduced += [(index, item)]\n    return reduced\n\ndef replaceSource(source, reduced):\n    \"\"\"replaces the key logic values in source with their alternative expression. Indices for these logic values are found in reduced array\n\n       i-type:: array, (indice, item) IN array\n       r-type:: array\n    \"\"\"\n    for index, item in reduced:\n        source[index] = obfuscateBoolean(item)\n    return source\n\n# main function\ndef main_solution(source_string):\n    \"\"\"\n    Obfuscates the logical expressions in the given source string.\n\n    Input:\n    source_string (str): A string containing logical expressions.\n\n    Output:\n    obfuscated_string (str): A string with obfuscated logical expressions.\n    \"\"\"\n    words = source_string.split()\n    words = [x for x in words if x != ')' and x != '(']\n    logicKeys = findAllP(words)\n    words = replaceSource(words, logicKeys)\n    obfuscated_string = ' '.join(words)\n    return obfuscated_string", "input_generator": "import random\nimport string\n\ndef input_generator():\n    logical_operators = ['&&', '||', '!']\n    variables = [''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 5))) for _ in range(random.randint(2, 5))]\n    statements = []\n    \n    for _ in range(random.randint(3, 10)):\n        if random.random() < 0.3:\n            statements.append(random.choice(logical_operators))\n        else:\n            statements.append(random.choice(variables))\n    \n    source_string = ' '.join(statements)\n    return {'source_string': source_string}", "io_pairs": [{"input": {"source_string": "! djjcg rus djjcg zfvmp rus || &&"}, "output": "! !!djjcg && !!djjcg rus && rus djjcg !!zfvmp !!rus && rus || &&"}, {"input": {"source_string": "zzi zzi v zzi ! ims || ceux"}, "output": "zzi || zzi !!zzi && !!zzi !!v && v !!zzi && !!zzi ! !!ims && !!ims || !!ceux && ceux"}, {"input": {"source_string": "n ulhur lusr ||"}, "output": "!!n !!ulhur || ulhur !!lusr || !!lusr ||"}, {"input": {"source_string": "&& scpcw && svyjf svyjf"}, "output": "&& !!scpcw && scpcw && svyjf svyjf"}, {"input": {"source_string": "rji gjplf gmdq && || rji rji zd"}, "output": "!!rji !!gjplf gmdq && || !!rji !!rji || rji zd || zd"}, {"input": {"source_string": "w fz && anvb hwpz"}, "output": "!!w || w fz || fz && !!anvb !!hwpz && !!hwpz"}, {"input": {"source_string": "etgjz && etgjz uwd"}, "output": "etgjz || etgjz && !!etgjz uwd || uwd"}, {"input": {"source_string": "cs && yi"}, "output": "!!cs || cs && yi || yi"}, {"input": {"source_string": "zlka pz pz"}, "output": "!!zlka || !!zlka !!pz || pz pz && pz"}, {"input": {"source_string": "vfg dxilh b vfg b jabrj dd dd vfg !"}, "output": "vfg !!dxilh && dxilh b && b !!vfg && vfg !!b || !!b jabrj || jabrj !!dd && dd !!dd && dd !!vfg !"}], "error_log": []}
{"context": "In a memory system, data is stored in a spiral pattern starting from address 1. Each square in this spiral grid stores a value that is the sum of the values in all its adjacent squares, including diagonals. Given an address in this spiral grid, what is the storage value at that address?\n\nThe input and output requirements are as follows:\n\nInput:\n  `addr` (int): The address in the spiral memory grid for which the storage value is to be calculated. The address should be a positive integer.\n\nOutput:\n  `return` (int): The storage value at the given address in the spiral memory grid. This value is the sum of the values in all adjacent squares, including diagonals.", "reference_code": "# import necessary packages\nimport math\nfrom itertools import count, islice\n\n# all class and function definitions in the code file, if any\ndef nth(iterable, n, default=None):\n    \"Returns the nth item or a default value\"\n    return next(islice(iterable, n, None), default)\n\ndef to_coord(addr):\n    dist = math.ceil((math.sqrt(addr) - 1)/2)\n    width = 1 + 2 * dist\n    \n    if dist == 0:\n        return (0, 0)\n\n    start = (width - 2) ** 2 + 1\n    center = start + (width - 3)//2\n    from_start = addr - start\n    from_center = addr - center\n    side = width - 1\n\n    if from_start < side:\n        offset = from_center\n        return (dist, offset)\n    elif addr - start < 2 * side:\n        offset = -(from_center - side)\n        return (offset, dist)\n    elif addr - start < 3 * side:\n        offset = -(from_center - 2 * side)\n        return (-dist, offset)\n    else:\n        offset = from_center - 3 * side\n        return (offset, -dist)\n\ndef storage():\n    grid = {\n        (0, 0): 1\n    }\n\n    yield 1\n\n    for addr in count(start=2):\n        x, y = to_coord(addr)\n        adjacent = [\n            (x+1, y+0),\n            (x+1, y+1),\n            (x+0, y+1),\n            (x-1, y+1),\n            (x-1, y+0),\n            (x-1, y-1),\n            (x+0, y-1),\n            (x+1, y-1)\n        ]\n        value = sum(grid.get(coord, 0) for coord in adjacent)\n        grid[(x, y)] = value\n        yield value\n\ndef storage_at(addr):\n    return nth(storage(), addr - 1)\n\n# main function\ndef main_solution(addr):\n    # Convert the address to its corresponding storage value\n    result = storage_at(addr)\n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    return {'addr': random.randint(1, 1000)}", "io_pairs": [{"input": {"addr": 174}, "output": 38643664099}, {"input": {"addr": 417}, "output": 530213016121710905}, {"input": {"addr": 96}, "output": 20390510}, {"input": {"addr": 139}, "output": 1534125748}, {"input": {"addr": 189}, "output": 125195906577}, {"input": {"addr": 173}, "output": 37251041343}, {"input": {"addr": 293}, "output": 328103103838738}, {"input": {"addr": 735}, "output": 9478042420370346061182374}, {"input": {"addr": 317}, "output": 1278960370451609}, {"input": {"addr": 835}, "output": 561498848798058691580785883}], "error_log": []}
{"context": "In a series of Tic-Tac-Toe games, what is the probability of player1 winning when the game type is defined as follows:\n- Game type 1: Both players make moves randomly.\n- Game type 2: Player1 makes moves randomly, while Player2 uses a strategic approach.\n- Game type 3: Both players use a strategic approach.\nGiven the game type and the number of games to simulate, what is the estimated probability of player1 winning?\n\nThe input and output requirements are as follows:\n\nInput:\n  `gametype` (int): Type of game to simulate (1, 2, or 3).\n  - 1: Both players are naive.\n  - 2: Player1 is naive, Player2 is intelligent.\n  - 3: Both players are intelligent.\n  `n` (int): Number of games to simulate.\n\nOutput:\n  `return` (float): Winning probability for player1.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\ndef validmove(move, tiles):\n    \"\"\" Checks whether a move played by a player is valid or invalid.\n        Return True if move is valid. \n        \n        A move is valid if the corresponding tile for the move is not ticked.\n    \"\"\"\n    return tiles[move - 1] == 0\n\ndef win(tiles):\n    \"\"\" Returns True if the board state specifies a winning state for some player.\n        \n        A player wins if ticks made by the player are present either\n        i) in a row\n        ii) in a column\n        iii) in a diagonal\n    \"\"\"\n    win_conditions = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8],  # rows\n        [0, 3, 6], [1, 4, 7], [2, 5, 8],  # columns\n        [0, 4, 8], [2, 4, 6]              # diagonals\n    ]\n    for condition in win_conditions:\n        if tiles[condition[0]] == tiles[condition[1]] == tiles[condition[2]] != 0:\n            return True\n    return False\n\ndef takeNaiveMove(tiles):\n    \"\"\" Returns a tile number randomly from the set of unchecked tiles with uniform probability distribution.    \n    \"\"\"\n    move = random.randint(1, 9)\n    while not validmove(move, tiles):\n        move = random.randint(1, 9)\n    return move\n\ndef takeStrategicMove(tiles):\n    \"\"\" Returns a tile number from the set of unchecked tiles\n    using some rules.\n    \"\"\"\n    # Implementing a simple strategy to win or block the opponent\n    win_conditions = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8],  # rows\n        [0, 3, 6], [1, 4, 7], [2, 5, 8],  # columns\n        [0, 4, 8], [2, 4, 6]              # diagonals\n    ]\n    for condition in win_conditions:\n        if tiles[condition[0]] == tiles[condition[1]] == 1 and tiles[condition[2]] == 0:\n            return condition[2] + 1\n        elif tiles[condition[1]] == tiles[condition[2]] == 1 and tiles[condition[0]] == 0:\n            return condition[0] + 1\n        elif tiles[condition[0]] == tiles[condition[2]] == 1 and tiles[condition[1]] == 0:\n            return condition[1] + 1\n        elif tiles[condition[0]] == tiles[condition[1]] == 2 and tiles[condition[2]] == 0:\n            return condition[2] + 1\n        elif tiles[condition[1]] == tiles[condition[2]] == 2 and tiles[condition[0]] == 0:\n            return condition[0] + 1\n        elif tiles[condition[0]] == tiles[condition[2]] == 2 and tiles[condition[1]] == 0:\n            return condition[1] + 1\n    return takeNaiveMove(tiles)\n\ndef game(gametype, tiles):\n    \"\"\" Returns 1 if player1 wins and 2 if player2 wins\n        and 0 if it is a draw.\n    \n        gametype defines three types of games discussed above.\n        i.e., game1, game2, game3\n    \"\"\"\n    turn = 1\n    for _ in range(9):\n        if turn == 1:\n            if gametype == 1 or gametype == 2:\n                move = takeNaiveMove(tiles)\n            else:\n                move = takeStrategicMove(tiles)\n            tiles[move - 1] = 1\n            turn = 2\n        else:\n            if gametype == 1:\n                move = takeNaiveMove(tiles)\n            else:\n                move = takeStrategicMove(tiles)\n            tiles[move - 1] = 2\n            turn = 1\n        if win(tiles):\n            return 1 if turn == 2 else 2\n    return 0\n\n# main function\ndef main_solution(gametype, n):\n    \"\"\"\n    Returns the winning probability for player1 in a series of Tic-Tac-Toe games.\n    \n    Parameters:\n    gametype (int): Type of game to simulate (1, 2, or 3).\n    n (int): Number of games to simulate.\n    \n    Returns:\n    float: Winning probability for player1.\n    \"\"\"\n    wins = 0\n    for _ in range(n):\n        tiles = [0] * 9\n        result = game(gametype, tiles)\n        if result == 1:\n            wins += 1\n    return wins / n", "input_generator": "import random\n\ndef input_generator():\n    gametype = random.choice([1, 2, 3])\n    n = random.randint(1, 1000)\n    return {'gametype': gametype, 'n': n}", "io_pairs": [{"input": {"gametype": 3, "n": 828}, "output": 0.29347826086956524}, {"input": {"gametype": 3, "n": 683}, "output": 0.2796486090775988}, {"input": {"gametype": 3, "n": 509}, "output": 0.28487229862475444}, {"input": {"gametype": 1, "n": 307}, "output": 0.5798045602605864}, {"input": {"gametype": 1, "n": 775}, "output": 0.5974193548387097}, {"input": {"gametype": 3, "n": 956}, "output": 0.28661087866108786}, {"input": {"gametype": 2, "n": 127}, "output": 0.16535433070866143}, {"input": {"gametype": 3, "n": 315}, "output": 0.2920634920634921}, {"input": {"gametype": 2, "n": 249}, "output": 0.13654618473895583}, {"input": {"gametype": 3, "n": 450}, "output": 0.26}], "error_log": []}
{"context": "Given a cryptographic system that uses the Data Encryption Standard (DES) algorithm, how would you determine the output block in hexadecimal format after processing an input block with a specific key in either encryption or decryption mode?\n\nThe input and output requirements are as follows:\n\nInput:\n  `key` (str): A hexadecimal string representing the key used in the DES cipher.\n  `input_block` (str): A hexadecimal string representing the input block to be encrypted or decrypted.\n  `mode` (str): A string indicating the mode of operation, either \"encrypt\" or \"decrypt\".\n\nOutput:\n  `return` (str): A hexadecimal string representing the output block after encryption or decryption.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass DESCiphers:\n    def __init__(self, key):\n        self.key = key\n\n    def cipher_function(self, r, k):\n        assert(type(r) == int)\n        assert(type(k) == int)\n        assert(r < (2 ** 32))\n        assert(k < (2 ** 48))\n        return 0\n\n    def key_schedule(self):\n        assert(type(self.key) == int)\n        key_schedule_list = []\n        return key_schedule_list\n\n    def crypt(self, input_block, encrypt_mode):\n        assert(type(input_block) == int)\n        assert(type(self.key) == int)\n        assert(input_block < (2 ** 64))\n        assert(type(encrypt_mode) == bool)\n        output_block = 0\n        return output_block\n\n    def encrypt(self, input_block):\n        return self.crypt(input_block, True)\n\n    def decrypt(self, input_block):\n        return self.crypt(input_block, False)\n\n# main function\ndef main_solution(key, input_block, mode):\n    # Convert JSON serializable inputs to original input variables\n    key = int(key, 16)\n    input_block = int(input_block, 16)\n    mode = mode == \"encrypt\"\n\n    # Create an instance of DESCiphers\n    des = DESCiphers(key)\n\n    # Perform encryption or decryption based on the mode\n    if mode:\n        output_block = des.encrypt(input_block)\n    else:\n        output_block = des.decrypt(input_block)\n\n    # Convert the output to a JSON serializable format\n    output_block_hex = hex(output_block)\n\n    return output_block_hex", "input_generator": "import random\n\ndef input_generator():\n    key = random.getrandbits(64)\n    input_block = random.getrandbits(64)\n    mode = random.choice([\"encrypt\", \"decrypt\"])\n    return {\n        \"key\": hex(key),\n        \"input_block\": hex(input_block),\n        \"mode\": mode\n    }", "io_pairs": [{"input": {"key": "0xdc3c8ae6863fa51a", "input_block": "0x944c2a5f83477332", "mode": "encrypt"}, "output": "0x0"}, {"input": {"key": "0xacbd74b9533543ce", "input_block": "0x17a293098e684ecc", "mode": "encrypt"}, "output": "0x0"}, {"input": {"key": "0xe4ef8885c969541d", "input_block": "0xa6c85dd78e2075a7", "mode": "decrypt"}, "output": "0x0"}, {"input": {"key": "0xc683b8b2a081bc1d", "input_block": "0x987e7578805f5a4", "mode": "decrypt"}, "output": "0x0"}, {"input": {"key": "0x2edd666b5fcdbc7d", "input_block": "0x3b3de086d339ba11", "mode": "encrypt"}, "output": "0x0"}, {"input": {"key": "0x10b9f10b3f12938a", "input_block": "0xa4c5d1fa5abf5278", "mode": "encrypt"}, "output": "0x0"}, {"input": {"key": "0x5220b5b312ae0cf9", "input_block": "0x61bdf0f0647417c8", "mode": "decrypt"}, "output": "0x0"}, {"input": {"key": "0x4c647921ecaff5f9", "input_block": "0xea64951386ba61e0", "mode": "decrypt"}, "output": "0x0"}, {"input": {"key": "0x78d02d1636831d49", "input_block": "0xb7a42482be4f2de9", "mode": "encrypt"}, "output": "0x0"}, {"input": {"key": "0x7a8a8dde68e1e115", "input_block": "0x810f770470ef184f", "mode": "encrypt"}, "output": "0x0"}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = \\frac{1}{1 + x^5} \\), how can we estimate the area under the curve between two points \\( a \\) and \\( b \\) using different numerical integration methods? Specifically, what is the estimated area when using the midpoint rule, trapezoid rule, or left Riemann sum with a specified number of subdivisions \\( n \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `method` (str): The method to use for estimating the area under the curve. Possible values are \"mid_rule\", \"trap_rule\", and \"left_riemann_sum\".\n  `a` (float): The lower bound of the integral.\n  `b` (float): The upper bound of the integral.\n  `n` (int): The number of subdivisions (rectangles) to use in the Riemann sum.\n\nOutput:\n  `return` (float): The estimated area under the curve using the specified method.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef mid_rule(f, a, b, n):\n    delta_x = ((b-a)/n)                     #range of integral divided by number of rectangles\n    \n    reimannSum = 0\n    for i in range(0, n):\n        reimannSum = reimannSum + (delta_x * ( f((i * delta_x) + (delta_x/2))))         #delta_x times f(midpoint), for every i starting at 0 and going to n\n    return (reimannSum)\n\ndef trap_rule(f, a, b, n):\n    tempA = a\n    delta_x = ((b-a)/n)                  #range of integral divided by number of rectangles\n    \n    reimannSum = 0\n    for i in range(0, n):\n        reimannSum = reimannSum + (.5 * (delta_x) * (f(tempA) + f(tempA + delta_x)))        #area of each trapezoid\n        tempA += delta_x     #increases starting a by delta_x every time function runs --> this could also be achieved by replacing tempA with i, as done in mid_rule()\n        \n    return (float(reimannSum))\n    \ndef left_riemann_sum(f, a, b, n):       #define funtion left_riemann_sum, uses parameters f, a, b, and n\n    delta_x = ((b-a)/n)                 #compute delta x as upper bound- lower bound over number of rectangles\n\n    riemannSum = 0\n    for i in range(0, n):        \n        riemannSum = riemannSum + f(a + i * delta_x) * delta_x      #increases a by (i * delta_x), this achieves the left hand behavhiour by starting at a\n        \n    return (float(riemannSum))\n\ndef f(x):\n    return (1 / (1 + x ** 5))\n\n# main function\ndef main_solution(method, a, b, n):\n    # Convert JSON serializable inputs to the original input variables\n    methods = {\n        \"mid_rule\": mid_rule,\n        \"trap_rule\": trap_rule,\n        \"left_riemann_sum\": left_riemann_sum\n    }\n    \n    if method not in methods:\n        raise ValueError(\"Invalid method specified\")\n    \n    # Call the appropriate function\n    result = methods[method](f, a, b, n)\n    \n    # Convert the result to a JSON serializable output\n    return float(result)", "input_generator": "import random\nimport math\n\ndef input_generator():\n    methods = [\"mid_rule\", \"trap_rule\", \"left_riemann_sum\"]\n    method = random.choice(methods)\n    \n    a = random.uniform(-10.0, 10.0)\n    b = random.uniform(a + 0.1, a + 20.0)  # Ensure b > a with some reasonable range\n    n = random.randint(1, 1000)\n    \n    return {\n        \"method\": method,\n        \"a\": a,\n        \"b\": b,\n        \"n\": n\n    }", "io_pairs": [{"input": {"method": "left_riemann_sum", "a": 8.835106462948897, "b": 26.312406190751076, "n": 327}, "output": 4.100406871087371e-05}, {"input": {"method": "mid_rule", "a": 5.531933596614721, "b": 6.675203568933851, "n": 361}, "output": 0.9479184289930804}, {"input": {"method": "left_riemann_sum", "a": 5.318298814727051, "b": 18.824756323994535, "n": 474}, "output": 0.00031383266910531976}, {"input": {"method": "left_riemann_sum", "a": -5.135028909654624, "b": -0.9411088933500595, "n": 295}, "output": 0.9839915427681052}, {"input": {"method": "trap_rule", "a": -5.9684486354815665, "b": 1.7123368454360683, "n": 495}, "output": 1.0368587026246707}, {"input": {"method": "trap_rule", "a": -2.504736155739071, "b": -1.781264679482208, "n": 153}, "output": -0.019091037075203227}, {"input": {"method": "trap_rule", "a": 0.9838755471467984, "b": 14.842520843232524, "n": 395}, "output": 0.18899631197883673}, {"input": {"method": "mid_rule", "a": 0.72417125977009, "b": 3.8905796183994887, "n": 822}, "output": 1.0664758206396685}, {"input": {"method": "trap_rule", "a": -0.7165732542939374, "b": 16.68474023197387, "n": 448}, "output": 1.811023200596635}, {"input": {"method": "left_riemann_sum", "a": 4.810956423090287, "b": 7.16889490139106, "n": 767}, "output": 0.0003724595302250186}], "error_log": []}
{"context": "Given an initial point in a 2D space, how does the Newton's method optimization algorithm traverse the space to minimize the Rosenbrock function, and what are the points it visits during this process?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_x1` (float): The initial value for the first variable in the optimization process.\n  `initial_x2` (float): The initial value for the second variable in the optimization process.\n\nOutput:\n  `return` (list of lists): A list of points visited during the optimization process. Each point is represented as a list `[x1, x2]`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef gradient(x1, x2):\n    partial_x1 = 400 * x1**3 - 400 * x1 * x2 + 2 * x1 - 2\n    partial_x2 = 200 * x2 - 200 * x1**2\n    return np.array([partial_x1, partial_x2])\n\ndef Hessian_inv(x1, x2):\n    second_deri_x1 = 1200 * x1**2 - 400 * x2 + 2\n    second_deri_x1x2 = -400 * x1\n    second_deri_x2x1 = -400 * x1\n    second_deri_x2 = 200\n    Hession = np.array([[second_deri_x1, second_deri_x1x2], [second_deri_x2x1, second_deri_x2]])\n    return np.linalg.inv(Hession)\n\ndef optimize_step(x1, x2):\n    H_inv = Hessian_inv(x1, x2)\n    p = np.dot(H_inv, gradient(x1, x2))\n    x0 = [x1, x2]\n    return x0 - p\n\ndef func_z(x1, x2):\n    return (100 * (x2 - x1**2)**2) + (1 - x1)**2\n\ndef optimizer(x1, x2):\n    n_iters = 0\n    optimized = 1\n    x_new = []\n    x0 = [x1, x2]\n    while (optimized > 1 * np.e**(-10)) and (n_iters < 100):\n        x_new.append(x0)\n        optimized = func_z(x1, x2)\n        x0 = optimize_step(x1, x2)\n        x1 = x0[0]\n        x2 = x0[1]\n        n_iters += 1\n    x_new.append(x0)\n    return np.array(x_new)\n\n# main function\ndef main_solution(initial_x1, initial_x2):\n    # Convert JSON serializable inputs to the original input variables\n    x1 = initial_x1\n    x2 = initial_x2\n    \n    # Perform the optimization\n    result = optimizer(x1, x2)\n    \n    # Convert the result to JSON serializable output\n    final_points = result.tolist()\n    \n    return final_points", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    initial_x1 = random.uniform(-2.0, 2.0)\n    initial_x2 = random.uniform(-1.0, 3.0)\n    return {'initial_x1': initial_x1, 'initial_x2': initial_x2}", "io_pairs": [{"input": {"initial_x1": 1.5419553673250492, "initial_x2": -0.2771037332245685}, "output": [[1.5419553673250492, -0.2771037332245685], [1.5409365508485946, 2.3744844157541496], [1.0001122737151082, 0.7077336612986451], [1.0001103867041845, 1.0002207855900331], [1.000000000000072, 0.9999999878149193]]}, {"input": {"initial_x1": -1.460661930668306, "initial_x2": -0.398283300896495}, "output": [[-1.460661930668306, -0.398283300896495], [-1.4558120295099692, 2.119365143724689], [0.9885011971236197, -4.997532533181078], [0.988510812042467, 0.9771536254324102], [0.999999999787566, 0.99986799814009], [0.999999999994527, 0.9999999999890541]]}, {"input": {"initial_x1": -1.0702114772540638, "initial_x2": -0.8024767466608584}, "output": [[-1.0702114772540638, -0.8024767466608584], [-1.0649109335214941, 1.1340072005697588], [0.9884617849967645, -3.239282820756075], [0.9884754515295624, 0.9770837180897987], [0.9999999995695393, 0.9998671839315529], [0.9999999999888528, 0.9999999999777056]]}, {"input": {"initial_x1": -1.3735440749321879, "initial_x2": -0.5898871630705371}, "output": [[-1.3735440749321879, -0.5898871630705371], [-1.3687616166560792, 1.8734854913238008], [0.9892137213951213, -4.581503908261288], [0.9892234124878094, 0.9785629597201098], [0.9999999997976055, 0.9998838647611653], [0.9999999999953946, 0.999999999990789]]}, {"input": {"initial_x1": 0.05468548684306018, "initial_x2": 0.4357132937377872}, "output": [[0.05468548684306018, 0.4357132937377872], [0.04363493573310201, 0.0017818929365981395], [0.9771996097457594, 0.0833760767229052], [0.977329668340943, 0.9551732637041792], [0.999999923305476, 0.9994859061508011], [0.999999992851513, 0.9999999857030212]]}, {"input": {"initial_x1": 1.3266555287445883, "initial_x2": 1.8563948801503858}, "output": [[1.3266555287445883, 1.8563948801503858], [1.3445290005611539, 1.807438772355198], [1.0206907386589308, 0.9369383641122607], [1.0197491481913328, 1.03988743864434], [1.0000035012689064, 0.9996171119776867], [1.0000002532726222, 1.0000005065347592]]}, {"input": {"initial_x1": -0.6667312962469607, "initial_x2": -0.09900350135256941}, "output": [[-0.6667312962469607, -0.09900350135256941], [-0.6515387017744604, 0.4242718649831434], [0.9271242072409537, -1.6326172846488425], [0.9272701236197428, 0.8598298608661836], [0.9999996902943568, 0.9947097907201323], [0.9999998407890047, 0.999999681578012], [0.9999999999999716, 0.9999999999999177]]}, {"input": {"initial_x1": -1.7939276844463015, "initial_x2": 0.660118963761323}, "output": [[-1.7939276844463015, 0.660118963761323], [-1.788477304178622, 3.198621360916969], [0.9835305890806472, -6.716695340634367], [0.9835412987642594, 0.9673534862601905], [0.9999999996224576, 0.9997291104109755], [0.9999999999805786, 0.9999999999611571]]}, {"input": {"initial_x1": 1.4825820437717896, "initial_x2": 1.3023653462783358}, "output": [[1.4825820437717896, 1.3023653462783358], [1.4799030689451016, 2.190105916567008], [1.0006878565186181, 0.7717289663628673], [1.000673199270193, 1.0013468515228088], [1.0000000000288887, 0.9999995468605588]]}, {"input": {"initial_x1": 0.03131632429446807, "initial_x2": 1.2008371387890566}, "output": [[0.03131632429446807, 1.2008371387890566], [0.027262767506711034, 0.0007268271694935713], [0.9968137988393122, 0.05360854719835019], [0.9968306565255757, 0.993671357505029], [0.999999999819898, 0.9999899549028786]]}], "error_log": []}
{"context": "Given a scenario where you roll a certain number of dice, what is the probability that the sum of the dice rolls equals a specified target value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `dice_count` (int): The number of dice to roll. Must be either 2 or 3.\n  `target_sum` (int): The target sum of the dice rolls to calculate the probability for.\n\nOutput:\n  `return` (float): The probability that the sum of the dice rolls equals the target sum.", "reference_code": "# import necessary packages\nfrom collections import defaultdict\n\n# main function\ndef main_solution(dice_count, target_sum):\n    # Generate all possible outcomes for the given number of dice\n    if dice_count == 2:\n        outcomes = {(i, j): i + j for i in range(1, 7) for j in range(1, 7)}\n    elif dice_count == 3:\n        outcomes = {(i, j, k): i + j + k for i in range(1, 7) for j in range(1, 7) for k in range(1, 7)}\n    else:\n        raise ValueError(\"Only 2 or 3 dice are supported.\")\n    \n    # Collect all outcomes that sum to the target value\n    dinv = defaultdict(list)\n    for outcome, total in outcomes.items():\n        dinv[total].append(outcome)\n    \n    # Calculate the probability of the target sum\n    total_outcomes = len(outcomes)\n    probability = len(dinv[target_sum]) / total_outcomes if target_sum in dinv else 0\n    \n    return probability", "input_generator": "import random\n\ndef input_generator():\n    dice_count = random.choice([2, 3])\n    min_target = dice_count * 1\n    max_target = dice_count * 6\n    target_sum = random.randint(min_target, max_target)\n    return {'dice_count': dice_count, 'target_sum': target_sum}", "io_pairs": [{"input": {"dice_count": 2, "target_sum": 3}, "output": 0.05555555555555555}, {"input": {"dice_count": 2, "target_sum": 11}, "output": 0.05555555555555555}, {"input": {"dice_count": 2, "target_sum": 2}, "output": 0.027777777777777776}, {"input": {"dice_count": 3, "target_sum": 18}, "output": 0.004629629629629629}, {"input": {"dice_count": 3, "target_sum": 9}, "output": 0.11574074074074074}, {"input": {"dice_count": 3, "target_sum": 10}, "output": 0.125}, {"input": {"dice_count": 3, "target_sum": 4}, "output": 0.013888888888888888}, {"input": {"dice_count": 2, "target_sum": 5}, "output": 0.1111111111111111}, {"input": {"dice_count": 2, "target_sum": 6}, "output": 0.1388888888888889}, {"input": {"dice_count": 3, "target_sum": 8}, "output": 0.09722222222222222}], "error_log": []}
{"context": "Given two 2x2 matrices, what is the resulting matrix when the first matrix is multiplied by the second matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `arr1` (list of lists of integers): A 2x2 matrix represented as a list of lists, where each inner list represents a row.\n  `arr2` (list of lists of integers): A 2x2 matrix represented as a list of lists, where each inner list represents a row.\n\nOutput:\n  `return` (list of lists of integers): A 2x2 matrix representing the product of `arr1` and `arr2`, returned as a list of lists, where each inner list represents a row.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(arr1, arr2):\n  # Convert JSON serializable inputs to numpy arrays\n  arr1 = np.array(arr1)\n  arr2 = np.array(arr2)\n  \n  # Calculate the product of the two matrices\n  product_matrix = arr1.dot(arr2)\n  \n  # Convert the result back to a JSON serializable format\n  product_matrix = product_matrix.tolist()\n  \n  # Return the result\n  return product_matrix", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the dimensions of the matrices\n    m = random.randint(1, 5)\n    n = random.randint(1, 5)\n    p = random.randint(1, 5)\n    \n    # Generate random matrices with integers between -10 and 10\n    arr1 = np.random.randint(-10, 11, size=(m, n)).tolist()\n    arr2 = np.random.randint(-10, 11, size=(n, p)).tolist()\n    \n    return {'arr1': arr1, 'arr2': arr2}", "io_pairs": [{"input": {"arr1": [[-6], [-5], [-5], [-2], [-2]], "arr2": [[0]]}, "output": [[0], [0], [0], [0], [0]]}, {"input": {"arr1": [[1], [-10], [-3]], "arr2": [[3, -5, 9]]}, "output": [[3, -5, 9], [-30, 50, -90], [-9, 15, -27]]}, {"input": {"arr1": [[-2, 6]], "arr2": [[-2, 8], [-10, -2]]}, "output": [[-56, -28]]}, {"input": {"arr1": [[-5], [7]], "arr2": [[1, -2, 7, -10]]}, "output": [[-5, 10, -35, 50], [7, -14, 49, -70]]}, {"input": {"arr1": [[5]], "arr2": [[8]]}, "output": [[40]]}, {"input": {"arr1": [[-1], [9]], "arr2": [[9, -8, -9, 9]]}, "output": [[-9, 8, 9, -9], [81, -72, -81, 81]]}, {"input": {"arr1": [[3], [-10], [10], [9]], "arr2": [[9]]}, "output": [[27], [-90], [90], [81]]}, {"input": {"arr1": [[-1, 7, -1]], "arr2": [[8], [9], [-10]]}, "output": [[65]]}, {"input": {"arr1": [[4], [-10]], "arr2": [[4, 8, 3, 1]]}, "output": [[16, 32, 12, 4], [-40, -80, -30, -10]]}, {"input": {"arr1": [[-5]], "arr2": [[-2, -1, -2, -4]]}, "output": [[10, 5, 10, 20]]}], "error_log": []}
{"context": "Given a plaintext message and a choice of encryption method (either shift cipher or keyword cipher), what will be the encrypted message after applying the chosen encryption method with the provided key?\n\nThe input and output requirements are as follows:\n\nInput:\n  `message` (str): The plaintext message to be encrypted. It should only contain lowercase alphabetic characters and spaces.\n  `choice` (str): The type of encryption to be performed. It should be either \"shift\" for shift cipher or \"keyword\" for keyword cipher.\n  `shift_key` (str): The key for the encryption. For \"shift\" encryption, it should be a string representation of an integer (e.g., \"3\"). For \"keyword\" encryption, it should be a string of alphabetic characters (e.g., \"key\").\n\nOutput:\n  `return` (str): The encrypted message. It will be a string of characters, including spaces, that represents the encrypted form of the input message.", "reference_code": "# import necessary packages\nimport collections\nfrom collections import Counter\nimport itertools\nimport random\n\n# all class and function definitions in the code file, if any\ndef factors(n):    \n    result = set()\n    for i in range(1, int(n ** 0.5) + 1):\n        div, mod = divmod(n, i)\n        if mod == 0:\n            result |= {i, div}\n    return result\n\n# main function\ndef main_solution(message, choice, shift_key):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n    \n    if choice == \"shift\":\n        # -------------------- SHIFT -------------------- #\n        secret_message = ''\n        shifted_alphabet = []\n\n        if shift_key != '':\n            shift = int(shift_key)\n        else:\n            shift = random.randint(0, 25)\n        \n        for i in range(0,26):\n            shifted_alphabet.append(alphabet[(i+shift)%26])\n\n        for i in message:\n            if alphabet.count(i):\n                secret_message += shifted_alphabet[alphabet.index(i)]\n            else:\n                secret_message += i\n        \n        return secret_message\n    \n    else:\n        # -------------------- KEYWORD -------------------- #\n        keyword = shift_key.lower()\n        keyword = \"\".join(keyword.split())\n        keyword = ''.join(sorted(set(keyword), key=keyword.index))\n\n        while (len(keyword) < 3):\n            keyword = ''.join(random.sample(alphabet, random.randint(3, 5)))\n            \n        keyword_sorted = sorted(list(keyword))\n\n        remainder = (len(message))%(len(keyword_sorted))\n\n        rows = 0\n\n        if remainder == 0:\n            rows = round((len(message) / (len(keyword_sorted))))\n        else:\n            rows = (round((len(message) / (len(keyword_sorted)))))\n            if remainder == 1 or remainder == 2:\n                rows = rows + 1\n            boxes = (rows * (len(keyword_sorted)))\n            remaining_char = boxes - (len(message))\n            message = message + (\" \" * remaining_char)\n\n        keyword_table = [ [ 0 for i in range(len(keyword_sorted)) ] for j in range(rows) ]\n\n        for i in range(round(rows)):\n            for j in range(len(keyword_sorted)):\n                keyword_table[i][j]= message[i*len(keyword_sorted) + j]\n\n        encrypted_keyword =[]\n        keyword_order = []\n        keyword_copy = keyword\n        counter = 0\n\n        while len(keyword_copy) > 0:\n            minimum = keyword_copy[0]\n            minimum_index = 0\n            for i in range(len(keyword_copy)):\n                if (ord(keyword_copy[i]) < ord(minimum)):\n                    minimum = keyword_copy[i]\n                    minimum_index = i\n                    \n            keyword_order.append(keyword.find(minimum))\n            keyword_copy = keyword_copy[:minimum_index] + keyword_copy[minimum_index+1:]\n\n        for i in range(len(keyword_order)):\n            for b in range(len(keyword_table)):\n                encrypted_keyword.append(keyword_table[b][keyword_order[counter]])\n                \n                if b == len(keyword_table) - 1:\n                    if counter == keyword_order:\n                        counter = 0\n                    else:\n                        counter = counter + 1\n\n        return ''.join(encrypted_keyword)", "input_generator": "import random\nimport string\n\ndef input_generator():\n    choice = random.choice([\"shift\", \"keyword\"])\n    message_length = random.randint(5, 20)\n    message = ''.join(random.choices(string.ascii_lowercase + ' ', k=message_length))\n    \n    if choice == \"shift\":\n        shift_key = str(random.randint(0, 25))\n    else:\n        keyword_length = random.randint(3, 5)\n        shift_key = ''.join(random.choices(string.ascii_lowercase, k=keyword_length))\n    \n    return {\n        \"message\": message,\n        \"choice\": choice,\n        \"shift_key\": shift_key\n    }", "io_pairs": [{"input": {"message": "ocjofxebrtknisqqu", "choice": "shift", "shift_key": "23"}, "output": "lzglcubyoqhkfpnnr"}, {"input": {"message": "rxgbgxjyajvfpfdztc", "choice": "keyword", "shift_key": "fqxm"}, "output": "rgaptbyfz xxjfcgjvd "}, {"input": {"message": "aej e", "choice": "keyword", "shift_key": "vnib"}, "output": "  j e ae"}, {"input": {"message": "vqoero", "choice": "keyword", "shift_key": "jstdl"}, "output": "e vor q o "}, {"input": {"message": "quwmrjctjllfamfe", "choice": "keyword", "shift_key": "lngst"}, "output": "wta qjleucf mjm rlf "}, {"input": {"message": "rzdcipkhksop", "choice": "keyword", "shift_key": "quua"}, "output": "dpkprcksziho"}, {"input": {"message": "cswvhaf", "choice": "keyword", "shift_key": "blpc"}, "output": "chv sawf"}, {"input": {"message": "pjzslirn", "choice": "shift", "shift_key": "12"}, "output": "bvlexudz"}, {"input": {"message": "qdswrzpz dkfoipni", "choice": "shift", "shift_key": "14"}, "output": "ergkfndn rytcwdbw"}, {"input": {"message": "akeklsvuochdxmgkki", "choice": "keyword", "shift_key": "yqum"}, "output": "kudk kscmievhg aloxk"}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, given the current state of the board, what is the optimal move for the player whose turn it is? The board is represented as a string of 9 characters, where 'x' and 'o' represent the players' moves, and '-' represents an empty cell. The board is read row by row from top to bottom.\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_str` (str): A string representing the Tic-Tac-Toe board. The string should be exactly 9 characters long, with each character representing a cell on the 3x3 board. Valid characters are 'x', 'o', and '-'. The board is read row by row from top to bottom.\n\nOutput:\n  `return` (tuple): A tuple representing the best move for the current player. The tuple contains two integers, each ranging from 0 to 2, representing the row and column indices of the best move on the 3x3 board.", "reference_code": "# import necessary packages\nimport copy\nimport random\n\n# all class and function definitions in the code file, if any\ndef curr_player(board):\n    X_count = sum(row.count('x') for row in board)\n    O_count = sum(row.count('o') for row in board)\n    return 'x' if X_count <= O_count else 'o'\n\ndef EvaluateBoard(b):\n    for a in range(3):\n        if b[a][0] == b[a][1] == b[a][2] != '-':\n            return b[a][0]\n        if b[0][a] == b[1][a] == b[2][a] != '-':\n            return b[0][a]\n    if b[0][0] == b[1][1] == b[2][2] != '-' or b[0][2] == b[1][1] == b[2][0] != '-':\n        return b[1][1]\n    return None\n\ndef utility(board):\n    winner = EvaluateBoard(board)\n    return 1 if winner == 'x' else -1 if winner == 'o' else 0\n\ndef status(board):\n    if EvaluateBoard(board):\n        return True\n    return all(cell != '-' for row in board for cell in row)\n\ndef result(board, action):\n    x, y = action\n    board_copy = copy.deepcopy(board)\n    if board_copy[x][y] != '-':\n        raise Exception(\"Invalid move\")\n    board_copy[x][y] = curr_player(board)\n    return board_copy\n\ndef minvalue(board):\n    if status(board):\n        return utility(board), None\n    best = 1000\n    bestMove = None\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == '-':\n                val, _ = maxvalue(result(board, (i, j)))\n                if val < best:\n                    best = val\n                    bestMove = (i, j)\n    return best, bestMove\n\ndef maxvalue(board):\n    if status(board):\n        return utility(board), None\n    best = -1000\n    bestMove = None\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == '-':\n                val, _ = minvalue(result(board, (i, j)))\n                if val > best:\n                    best = val\n                    bestMove = (i, j)\n    return best, bestMove\n\n# main function\ndef main_solution(board_str):\n    board = [list(board_str[i:i+3]) for i in range(0, 9, 3)]\n    if curr_player(board) == 'x':\n        _, bestMove = maxvalue(board)\n    else:\n        _, bestMove = minvalue(board)\n    return bestMove", "input_generator": "import random\n\ndef input_generator():\n    symbols = ['x', 'o', '-']\n    board_str = ''.join([random.choice(symbols) for _ in range(9)])\n    # Ensure the board is not already full or a terminal state\n    while board_str.count('-') == 0 or EvaluateBoard([list(board_str[i:i+3]) for i in range(0, 9, 3)]):\n        board_str = ''.join([random.choice(symbols) for _ in range(9)])\n    return {'board_str': board_str}\n\ndef EvaluateBoard(b):\n    for a in range(3):\n        if b[a][0] == b[a][1] == b[a][2] != '-':\n            return b[a][0]\n        if b[0][a] == b[1][a] == b[2][a] != '-':\n            return b[0][a]\n    if b[0][0] == b[1][1] == b[2][2] != '-' or b[0][2] == b[1][1] == b[2][0] != '-':\n        return b[1][1]\n    return None", "io_pairs": [{"input": {"board_str": "---xxoxx-"}, "output": [0, 0]}, {"input": {"board_str": "x--oxoxxo"}, "output": [0, 2]}, {"input": {"board_str": "-----oxo-"}, "output": [0, 0]}, {"input": {"board_str": "x-o--x-ox"}, "output": [1, 1]}, {"input": {"board_str": "x--xox-ox"}, "output": [0, 1]}, {"input": {"board_str": "--oxx-oox"}, "output": [0, 0]}, {"input": {"board_str": "--ooxxoxx"}, "output": [0, 0]}, {"input": {"board_str": "xoo--xoox"}, "output": [1, 0]}, {"input": {"board_str": "oxx--ox--"}, "output": [1, 1]}, {"input": {"board_str": "-oox--x--"}, "output": [0, 0]}], "error_log": []}
{"context": "Given a dataset with `m` samples and `n` features, we want to perform linear regression using gradient descent. What are the final values of the parameters (`theta`) and the final cost after running `iterations` iterations of gradient descent with a learning rate of `alpha`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): Number of samples.\n  `n` (int): Number of features.\n  `alpha` (float): Learning rate for gradient descent.\n  `iterations` (int): Number of iterations for gradient descent.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `final_theta` (list of float): The final values of the parameters after gradient descent.\n    - `final_cost` (float): The final cost after the last iteration of gradient descent.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef create_X_y(m, n):\n    ones = np.ones(m)\n    x = np.random.random((m, n))\n    count = 0\n    while count < n:\n        x[:, count] += np.arange(m) * np.random.random() * np.random.randint(10)\n        count += 1\n    X = np.c_[ones, x]\n    y = np.linspace(0, 5, m) + np.random.random(m)\n    return X, y\n\ndef scale_std(matrix):\n    m, n = matrix.shape\n    count = 1\n    while count < n:\n        array = matrix[:, count]\n        matrix[:, count] = (array - array.mean()) / array.std()\n        count += 1\n    return matrix\n\n# main function\ndef main_solution(m, n, alpha, iterations):\n    # Convert JSON serializable inputs to numpy arrays\n    m = int(m)\n    n = int(n)\n    alpha = float(alpha)\n    iterations = int(iterations)\n    \n    # Create X and y\n    X, y = create_X_y(m, n)\n    X = scale_std(X)\n    \n    # Initialize theta\n    theta = np.random.random(n + 1)\n    J = []\n    \n    # Gradient Descent\n    for i in range(iterations):\n        hypothesis = np.dot(X, theta)\n        diff = hypothesis - y\n        J.append(np.sum(diff ** 2) / (2 * m))\n        gradients = np.dot(diff, X) / m\n        theta = theta - alpha * gradients\n    \n    # Convert output to JSON serializable\n    final_theta = theta.tolist()\n    final_cost = J[-1]\n    \n    return {\"final_theta\": final_theta, \"final_cost\": final_cost}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    m = random.randint(10, 100)\n    n = random.randint(2, 10)\n    alpha = random.uniform(0.001, 0.1)\n    iterations = random.randint(50, 200)\n    return {\"m\": m, \"n\": n, \"alpha\": alpha, \"iterations\": iterations}", "io_pairs": [{"input": {"m": 96, "n": 2, "alpha": 0.015757534467364928, "iterations": 183}, "output": {"final_theta": [2.8491112762011053, 0.8602623632902129, 0.5744068892333325], "final_cost": 0.05534559083573664}}, {"input": {"m": 66, "n": 4, "alpha": 0.05595589103541199, "iterations": 163}, "output": {"final_theta": [2.985945468737458, 0.37706665394797695, 0.2854162810775071, 0.4707785338265356, 0.325803365097932], "final_cost": 0.045088394442360395}}, {"input": {"m": 42, "n": 2, "alpha": 0.0187344322452711, "iterations": 112}, "output": {"final_theta": [2.8189583772277045, 0.03525797778988412, 1.3809771399000512], "final_cost": 0.08249669850975187}}, {"input": {"m": 71, "n": 5, "alpha": 0.04371039961187384, "iterations": 58}, "output": {"final_theta": [2.8393739723515625, 0.007177816433902473, 0.05972191526337653, 0.3241551467395686, 0.6135959842378799, 0.4924114060004178], "final_cost": 0.06457807104034043}}, {"input": {"m": 12, "n": 6, "alpha": 0.08347234868208221, "iterations": 129}, "output": {"final_theta": [3.044945894108825, 0.21830809795951003, 0.5909005167184102, 0.010402972345591578, 0.5474059094943575, 0.07982783174597785, 0.21468414689375565], "final_cost": 0.033266177330912465}}, {"input": {"m": 76, "n": 4, "alpha": 0.09214668809719982, "iterations": 95}, "output": {"final_theta": [2.9523052882155065, -0.013806990020778329, 0.5804273781000776, 0.6429764500194511, 0.2456539452669213], "final_cost": 0.050070214088375656}}, {"input": {"m": 78, "n": 3, "alpha": 0.0023070496062259334, "iterations": 70}, "output": {"final_theta": [0.9396068261283604, 0.18299158654634395, 0.4021072519419183, 0.9432703815100164], "final_cost": 2.3388588529109393}}, {"input": {"m": 30, "n": 4, "alpha": 0.0995508311149327, "iterations": 109}, "output": {"final_theta": [3.063732834072336, 0.547954657993197, 0.46662867742059994, 0.37572583405148924, 0.005986823357068923], "final_cost": 0.03124453093422092}}, {"input": {"m": 67, "n": 8, "alpha": 0.0867617592828888, "iterations": 83}, "output": {"final_theta": [2.9905690382167256, 0.15721845656472055, 0.15905202177644925, -0.014894184323248884, 0.049182444976407294, 0.47925080223394706, 0.5205454411387755, 0.2868931420015896, -0.18206807184121276], "final_cost": 0.04481097393923131}}, {"input": {"m": 27, "n": 2, "alpha": 0.057921776478654624, "iterations": 191}, "output": {"final_theta": [2.9866271381275333, 0.511795058177242, 1.0540736163688007], "final_cost": 0.04177654703987685}}], "error_log": []}
{"context": "Given a mathematical function defined by `4.4294 * sqrt(x) * tanh(1.3842 * sqrt(x)) - 5`, what is the estimated root and the error percentage when using the bisection method within a specified interval and a maximum number of iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `lower` (float): The lower bound of the interval in which to search for the root.\n  `upper` (float): The upper bound of the interval in which to search for the root.\n  `max_iterations` (int): The maximum number of iterations to perform.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `estimated_root` (float or None): The estimated root of the function within the given interval. If no valid root is found, it will be `None`.\n    - `error_percentage` (float or str): The error percentage of the estimated root. If no previous root is available for comparison, it will be 'N/A'.", "reference_code": "# import necessary packages\nimport math\n\n# Function definitions from the code file\ndef fantion(x):\n    return 4.4294 * (math.sqrt(x)) * math.tanh(1.3842 * math.sqrt(x)) - 5\n\ndef Xm(xl, xu):\n    return (xl + xu) / 2.0\n\ndef Ea(xnew, xold):\n    return math.fabs((xnew - xold) / xnew) * 100\n\n# main function\ndef main_solution(lower, upper, max_iterations):\n    # Convert inputs to appropriate types if necessary\n    lower = float(lower)\n    upper = float(upper)\n    max_iterations = int(max_iterations)\n    \n    xm = None\n    old_xm = None\n    ea = None\n    c = 0\n    \n    if fantion(lower) * fantion(upper) < 0:  # checking the boundary is valid\n        while c < max_iterations:\n            xm = Xm(lower, upper)  # Xm, estimate root\n            fm = fantion(xm)\n            fl = fantion(lower)\n            \n            if fm * fl > 0:\n                lower = xm\n            elif fm * fl < 0:\n                upper = xm\n            elif fm * fl == 0:\n                break\n            \n            if xm and old_xm:\n                ea = Ea(xm, old_xm)  # error percentage\n            else:\n                ea = 'N/A'\n            \n            c += 1\n            old_xm = xm\n    else:\n        return {\"error\": \"Boundary is not valid\"}\n    \n    return {\"estimated_root\": xm, \"error_percentage\": ea}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random lower bound between 0.1 and 10\n    lower = random.uniform(0.1, 10)\n    # Generate a random upper bound greater than lower, ensuring fantion(lower)*fantion(upper) < 0\n    # To ensure valid boundary, we need to find an upper where fantion(upper) has opposite sign of fantion(lower)\n    max_attempts = 100\n    upper = lower\n    for _ in range(max_attempts):\n        upper = random.uniform(lower + 0.1, 20)\n        if math.copysign(1, fantion(lower)) != math.copysign(1, fantion(upper)):\n            break\n    else:\n        # Fallback if no valid upper found, adjust upper to ensure validity\n        upper = lower + 1.0\n        while fantion(lower) * fantion(upper) >= 0 and upper < 100:\n            upper += 1.0\n    \n    # Generate max_iterations between 10 and 100\n    max_iterations = random.randint(10, 100)\n    \n    return {\"lower\": lower, \"upper\": upper, \"max_iterations\": max_iterations}", "io_pairs": [{"input": {"lower": 0.41043319378742404, "upper": 10.335175786898137, "max_iterations": 43}, "output": {"estimated_root": 1.465920604530916, "error_percentage": 7.696246537070149e-11}}, {"input": {"lower": 8.826818988820081, "upper": 100.82681898882008, "max_iterations": 96}, "output": {"error": "Boundary is not valid"}}, {"input": {"lower": 8.986157275950294, "upper": 100.98615727595029, "max_iterations": 86}, "output": {"error": "Boundary is not valid"}}, {"input": {"lower": 9.612108217640218, "upper": 100.61210821764021, "max_iterations": 53}, "output": {"error": "Boundary is not valid"}}, {"input": {"lower": 9.916316118858848, "upper": 100.91631611885884, "max_iterations": 74}, "output": {"error": "Boundary is not valid"}}, {"input": {"lower": 8.099962389921483, "upper": 100.09996238992149, "max_iterations": 64}, "output": {"error": "Boundary is not valid"}}, {"input": {"lower": 8.93957574602664, "upper": 100.93957574602663, "max_iterations": 14}, "output": {"error": "Boundary is not valid"}}, {"input": {"lower": 7.6534114405391165, "upper": 100.65341144053912, "max_iterations": 16}, "output": {"error": "Boundary is not valid"}}, {"input": {"lower": 1.3291341838482047, "upper": 11.894877031377897, "max_iterations": 14}, "output": {"estimated_root": 1.4664939999202158, "error_percentage": 0.043974388277842814}}, {"input": {"lower": 0.35337418636973916, "upper": 14.74748496483454, "max_iterations": 91}, "output": {"estimated_root": 1.4659206045319562, "error_percentage": 6.05884395753961e-14}}], "error_log": []}
{"context": "Given a set of pendulum lengths, how can we estimate the period of oscillation for each length, assuming a simple pendulum model with no friction, air resistance, and a massless string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `length_values` (list of float): A list of pendulum lengths in meters.\n\nOutput:\n  `return` (list of float): A list of estimated periods in seconds corresponding to the input lengths.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(length_values):\n    # Convert the input list to a numpy array\n    length = np.array(length_values)\n    \n    # Function to estimate the period for a given length\n    def estimatedPeriod(length):\n        period = (2 * np.pi * (np.sqrt(length / 9.81)))\n        return period\n    \n    # Calculate the period for the given lengths\n    period = estimatedPeriod(length)\n    \n    # Convert the period array to a list for JSON serialization\n    period_values = period.tolist()\n    \n    return period_values", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random number of lengths between 1 and 10\n    num_lengths = random.randint(1, 10)\n    \n    # Generate random lengths between 0.1 and 10.0 meters\n    length_values = [round(random.uniform(0.1, 10.0), 2) for _ in range(num_lengths)]\n    \n    return {'length_values': length_values}", "io_pairs": [{"input": {"length_values": [8.62, 8.02]}, "output": [5.8897789777446725, 5.68110150324817]}, {"input": {"length_values": [7.34, 8.18, 6.87, 2.58, 6.4, 8.51, 9.6, 7.12]}, "output": [5.434922988556284, 5.737490989500708, 5.258038154448156, 3.2222202129649955, 5.07499187937553, 5.8520785212318165, 6.215570276619142, 5.352853548855688]}, {"input": {"length_values": [0.65, 8.36, 8.43, 5.8, 1.66, 7.77, 7.83]}, "output": [1.6173426640162967, 5.800273915044371, 5.824506737610162, 4.8312483334282375, 2.584636116666975, 5.5918546483563265, 5.6134033010279705]}, {"input": {"length_values": [5.68, 3.5, 4.54, 6.99, 9.82]}, "output": [4.781008683945076, 3.7530071071210376, 4.274381594413015, 5.303761085958479, 6.286386930473816]}, {"input": {"length_values": [7.61, 8.79, 1.51, 2.93, 7.89, 5.11, 3.98, 0.68]}, "output": [5.53398137365415, 5.947573287177792, 2.465096007554417, 3.433833038377126, 5.634869548768557, 4.534775741457067, 4.002090458657898, 1.6542449633204435]}, {"input": {"length_values": [6.15, 7.96, 0.39, 7.63, 1.43, 9.86, 2.58, 7.15]}, "output": [4.974883585960904, 5.65981060447796, 1.2527882405691713, 5.541248588044054, 2.398906843598586, 6.299177151083331, 3.2222202129649955, 5.364118773975894]}, {"input": {"length_values": [2.62, 8.27, 8.93, 5.38, 4.44, 8.09, 1.61, 2.42, 9.35, 2.15]}, "output": [3.2471025918406826, 5.768967860204542, 5.994750245022297, 4.653036962857806, 4.227044790620394, 5.7058404759623835, 2.5454132629509236, 3.120707377574352, 6.1341044971313465, 2.9414711598167136]}, {"input": {"length_values": [6.68, 2.63, 7.19]}, "output": [5.1848189518454415, 3.2532934508299514, 5.379102375156933]}, {"input": {"length_values": [0.11, 2.26, 9.49, 6.47, 2.49, 3.57, 6.06, 2.88, 7.92]}, "output": [0.6653370484350903, 3.015779496590193, 6.179857642014988, 5.102670263954903, 3.1655198283013504, 3.7903513812076897, 4.938347838740407, 3.4044080482629293, 5.645572064677137]}, {"input": {"length_values": [4.94, 0.68, 4.8, 6.98]}, "output": [4.458706025927222, 1.6542449633204435, 4.395071891538941, 5.299965907593453]}], "error_log": []}
{"context": "Given a GPS satellite system, how can we generate the first 30 bits of the C/A (Coarse/Acquisition) code for a specific satellite identified by its ID? Specifically, what is the C/A code for satellite ID `satellite_id`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `satellite_id` (int): The ID of the GPS satellite (1-32). Only satellite IDs 1 and 26 are supported in this implementation.\n\nOutput:\n  `return` (str): The first 30 bits of the C/A code as a binary string. Each bit is represented as '0' or '1', and the bits are concatenated without any separators.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef shift(register, feedback, output):\n    \"\"\"GPS Shift Register\n\n    :param list feedback: which positions to use as feedback (1 indexed)\n    :param list output: which positions are output (1 indexed)\n    :returns output of shift register:\n\n    \"\"\"\n\n    # calculate output\n    out = [register[i-1] for i in output]\n    if len(out) > 1:\n        out = sum(out) % 2\n    else:\n        out = out[0]\n\n    # modulo 2 add feedback\n    fb = sum([register[i-1] for i in feedback]) % 2\n\n    # shift to the right\n    for i in reversed(range(len(register[1:]))):\n        register[i+1] = register[i]\n\n    # put feedback in position 1\n    register[0] = fb\n\n    return out\n\n# main function\ndef main_solution(satellite_id):\n    \"\"\"\n    Generates the C/A (Coarse/Acquisition) code for a given GPS satellite ID.\n\n    :param int satellite_id: The ID of the GPS satellite (1-32).\n    :return str: The first 30 bits of the C/A code as a binary string.\n    \"\"\"\n    # Initialize registers\n    G1 = [1 for _ in range(10)]\n    G2 = [1 for _ in range(10)]\n\n    # Define feedback and output positions based on satellite ID\n    feedback_G1 = [3, 10]\n    output_G1 = [10]\n    if satellite_id == 1:\n        feedback_G2 = [2, 3, 6, 8, 9, 10]\n        output_G2 = [2, 6]\n    elif satellite_id == 26:\n        feedback_G2 = [2, 3, 6, 8, 9, 10]\n        output_G2 = [6, 8]\n    else:\n        raise ValueError(\"Unsupported satellite ID\")\n\n    ca = []\n    for _ in range(30):\n        g1 = shift(G1, feedback_G1, output_G1)\n        g2 = shift(G2, feedback_G2, output_G2)\n        ca.append((g1 + g2) % 2)\n\n    # Convert list of bits to binary string\n    ca_binary_string = ''.join(map(str, ca))\n    return ca_binary_string", "input_generator": "import random\n\ndef input_generator():\n    satellite_id = random.choice([1, 26])\n    return {'satellite_id': satellite_id}", "io_pairs": [{"input": {"satellite_id": 26}, "output": "111111000101111010010111001101"}, {"input": {"satellite_id": 1}, "output": "110010000011100101001001111001"}], "error_log": []}
{"context": "Given two linked lists represented by their values, determine if they intersect. An intersection is defined as two linked lists sharing at least one common node beyond the head node. How can we determine if the two linked lists intersect?\n\nThe input and output requirements are as follows:\n\nInput:\n  `list1` (list of int or str): A list of values representing the first linked list.\n  `list2` (list of int or str): A list of values representing the second linked list.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the two linked lists intersect.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass LNode(object):\n    def __init__(self, x):\n        self.data = x\n        self.Next = None\n\n# Create a linked list from a list of values\ndef create_List(values):\n    if type(values) != list:\n        return None\n    head = LNode(None)\n    if not values:\n        return head\n    cur = head\n    for v in values:\n        tmp = LNode(v)\n        cur.Next = tmp\n        cur = tmp\n    return head\n\n# Check if two linked lists intersect\ndef Is_Intersect(head1, head2):\n    if head1 is None or head1.data is not None or head1.Next is None:\n        return False\n    if head2 is None or head2.data is not None or head2.Next is None:\n        return False\n    entry = Loop_Entry(head1)\n    if entry == False:\n        return False\n    cur = head2.Next\n    while cur is not None:\n        if cur is entry:\n            break\n        cur = cur.Next\n    if cur is None:\n        return False\n    return True\n\n# Find the loop entry of a linked list\ndef Loop_Entry(head):\n    if head is None or head.data is not None or head.Next is None:\n        return False\n    lowP = head.Next\n    FastP = head.Next\n    while FastP is not None and FastP.Next is not None:\n        lowP = lowP.Next\n        FastP = FastP.Next.Next\n        if lowP is FastP:\n            break\n    if FastP is None or FastP.Next is None:\n        return False\n    lowP = head.Next\n    while FastP != lowP:\n        lowP = lowP.Next\n        FastP = FastP.Next\n    return FastP\n\n# main function\ndef main_solution(list1, list2):\n    # Convert JSON serializable inputs to original input variables\n    head1 = create_List(list1)\n    head2 = create_List(list2)\n    \n    # Call the original function with the converted inputs\n    result = Is_Intersect(head1, head2)\n    \n    # Convert the result to a JSON serializable output\n    return result", "input_generator": "import random\nimport json\n\ndef input_generator():\n    # Randomly decide whether to create intersecting lists or not\n    intersect = random.choice([True, False])\n    \n    # Generate a random shared segment if intersecting\n    shared_segment = []\n    if intersect:\n        shared_length = random.randint(1, 5)\n        shared_segment = [random.randint(1, 100) for _ in range(shared_length)]\n    \n    # Generate the first list\n    list1_length = random.randint(0, 5)\n    list1 = [random.randint(1, 100) for _ in range(list1_length)]\n    \n    # Generate the second list\n    list2_length = random.randint(0, 5)\n    list2 = [random.randint(1, 100) for _ in range(list2_length)]\n    \n    # If intersecting, append the shared segment to both lists\n    if intersect:\n        list1 += shared_segment\n        list2 += shared_segment\n    \n    return {'list1': list1, 'list2': list2}", "io_pairs": [{"input": {"list1": [], "list2": [25, 2, 59]}, "output": false}, {"input": {"list1": [42, 32, 8], "list2": [41, 70, 46]}, "output": false}, {"input": {"list1": [2, 4, 24, 28, 77, 17, 38, 86, 20], "list2": [33, 17, 38, 86, 20]}, "output": false}, {"input": {"list1": [81, 46, 58, 32, 71], "list2": [56, 68, 29]}, "output": false}, {"input": {"list1": [], "list2": []}, "output": false}, {"input": {"list1": [23, 28], "list2": [13, 28, 93, 95, 9, 28]}, "output": false}, {"input": {"list1": [42, 11, 76, 56, 10, 18], "list2": [65, 9, 10, 18]}, "output": false}, {"input": {"list1": [57, 21, 15, 11, 74, 64, 64], "list2": [11, 74, 64, 64]}, "output": false}, {"input": {"list1": [40, 88, 38, 47, 54, 5], "list2": [90, 91, 14, 73, 38, 47, 54, 5]}, "output": false}, {"input": {"list1": [66, 8, 57, 30], "list2": []}, "output": false}], "error_log": []}
{"context": "In the context of the Nim Game, where players take turns removing objects from distinct heaps, the nim sum is a crucial concept. Given a list of heaps represented by their sizes, what is the nim sum of these heaps?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numbers` (list of strings): A list of strings where each string represents a non-negative integer.\n\nOutput:\n  `return` (int): The nim sum of the list of integers.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef nim_sum(array):\n    max_len, base_2 = len(bin(max(array))) - 2, [bin(i)[2:] for i in array]\n    result = '0' * max_len\n\n    for i in range(len(base_2)):\n        if len(base_2[i]) < max_len:\n            base_2[i] = ('0' * (max_len - len(base_2[i]))) + base_2[i]\n        for j in range(max_len):\n            result = result[:j] + str((int(result[j]) + int(base_2[i][j])) % 2) + result[j + 1:]\n    return int('0b' + result, 2)\n\n# main function\ndef main_solution(numbers):\n    # Convert the input list of strings to integers\n    numbers = [int(num) for num in numbers]\n    \n    # Calculate the nim sum\n    result = nim_sum(numbers)\n    \n    # Return the result as an integer\n    return result", "input_generator": "import random\n\ndef input_generator():\n    length = random.randint(1, 10)\n    numbers = [random.randint(0, 100) for _ in range(length)]\n    return {'numbers': numbers}", "io_pairs": [{"input": {"numbers": [4, 69, 14, 62, 78, 63, 7, 30]}, "output": 25}, {"input": {"numbers": [10]}, "output": 10}, {"input": {"numbers": [71, 51, 80, 33]}, "output": 5}, {"input": {"numbers": [45, 95, 51, 46, 22, 29, 46, 47, 70]}, "output": 35}, {"input": {"numbers": [4, 54, 12, 10, 39, 19]}, "output": 0}, {"input": {"numbers": [74, 20]}, "output": 94}, {"input": {"numbers": [85, 87, 31, 69, 29]}, "output": 69}, {"input": {"numbers": [44, 61, 84, 31, 41]}, "output": 115}, {"input": {"numbers": [30, 77, 29, 32, 30, 55, 37, 7]}, "output": 101}, {"input": {"numbers": [44, 57]}, "output": 21}], "error_log": []}
{"context": "Given an alphanumeric string with possible formatting characters, how can we determine the final checksum character and the sum of the processed digits and characters after applying the checksum algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data` (str): A string containing alphanumeric characters and possibly other symbols. The function will process only digits and uppercase letters, ignoring other characters.\n\nOutput:\n  `return` (dict): A dictionary with the following keys:\n    - `final_char` (str): A string representing the final checksum character.\n    - `sum_of_digits` (int): An integer representing the sum of the processed digits and characters.", "reference_code": "# import necessary packages\nimport string\n\n# all class and function definitions in the code file, if any\ndef map_point(char):\n    val = ord(char) - 48\n    doubled = 2 * val\n    if doubled <= 9:\n        reduced = doubled\n    else:\n        reduced = (doubled % 10) + ((doubled // 10) % 10) + (doubled // 100)\n    return reduced\n\n# main function\ndef main_solution(data):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    trans_map = dict((ord(char), None) for char in data if char not in string.digits + string.ascii_letters)\n    input_str = data.translate(trans_map)\n    char_sum = 0\n    for i, char in enumerate(input_str[::-1]):\n        if i % 2 == 0:\n            char_sum += map_point(char)\n        else:\n            char_sum += ord(char) - 48\n    if char_sum % 10 == 0:\n        final_char = 0\n    else:\n        final_char = 10 - (char_sum % 10)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"final_char\": str(final_char), \"sum_of_digits\": char_sum}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(5, 20)\n    chars = []\n    for _ in range(length):\n        choice = random.random()\n        if choice < 0.7:\n            chars.append(random.choice(string.digits))\n        elif choice < 0.9:\n            chars.append(random.choice(string.ascii_letters))\n        else:\n            chars.append(random.choice(string.punctuation))\n    data = ''.join(chars)\n    return {\"data\": data}", "io_pairs": [{"input": {"data": "9{1M897q4"}, "output": {"final_char": "6", "sum_of_digits": 134}}, {"input": {"data": "<L870k2116zt91@95Y^3"}, "output": {"final_char": "6", "sum_of_digits": 194}}, {"input": {"data": "597598"}, "output": {"final_char": "2", "sum_of_digits": 38}}, {"input": {"data": "329502216J"}, "output": {"final_char": "2", "sum_of_digits": 38}}, {"input": {"data": "e69317965|5645147"}, "output": {"final_char": "5", "sum_of_digits": 125}}, {"input": {"data": "1f1M1518"}, "output": {"final_char": "6", "sum_of_digits": 34}}, {"input": {"data": "!b943O8085T"}, "output": {"final_char": "2", "sum_of_digits": 128}}, {"input": {"data": "08E2e775+97N`/z0"}, "output": {"final_char": "4", "sum_of_digits": 136}}, {"input": {"data": "79\\T841449!.6"}, "output": {"final_char": "1", "sum_of_digits": 89}}, {"input": {"data": "+<tX13n378Wf1ls7"}, "output": {"final_char": "1", "sum_of_digits": 289}}], "error_log": []}
{"context": "Given a certain number of apples and an equal number of baskets, how many different ways can the apples be distributed among the baskets? Each basket can contain any number of apples, including zero.\n\nThe input and output requirements are as follows:\n\nInput:\n  `num` (int): The number of apples and baskets. It should be a positive integer.\n\nOutput:\n  `return` (int): The number of ways to distribute `num` apples into `num` baskets.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef fun(a, t=2):\n    count = 0\n    if a < t:\n        return count\n    else:\n        for i in range(t, int(a / 2) + 1):\n            if a % i == 0:\n                temp = a // i\n                if temp >= i:\n                    count += 1\n                    count += fun(temp, i)\n        return count\n\ndef fun1(x, y):\n    return x + y, y\n\ndef fun2(x, y):\n    return x, x + y\n\ndef fac(n):\n    if n == 1:\n        return 1\n    else:\n        return n * fac(n - 1)\n\ndef gcd(x, y):\n    i = x\n    while i > 1:\n        if x % i == 0 and y % i == 0:\n            return i\n        i -= 1\n    else:\n        return 1\n\ndef F(n):\n    if n == 0:\n        return 1\n    else:\n        return n - M(F(n - 1))\n\ndef M(n):\n    if n == 0:\n        return 0\n    else:\n        return n - F(M(n - 1))\n\ndef fun_apple(m, n):\n    if m == 0 or n == 1:\n        return 1\n    if n > m:\n        return fun_apple(m, m)\n    else:\n        return fun_apple(m, n - 1) + fun_apple(m - n, n)\n\n# main function\ndef main_solution(num):\n    # Convert input to appropriate types if necessary\n    num = int(num)\n    \n    # Calculate the number of ways to distribute 'num' apples into 'num' baskets\n    result = fun_apple(num, num)\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    num = random.randint(1, 20)\n    return {'num': str(num)}", "io_pairs": [{"input": {"num": "11"}, "output": 56}, {"input": {"num": "4"}, "output": 5}, {"input": {"num": "6"}, "output": 11}, {"input": {"num": "16"}, "output": 231}, {"input": {"num": "8"}, "output": 22}, {"input": {"num": "3"}, "output": 3}, {"input": {"num": "14"}, "output": 135}, {"input": {"num": "19"}, "output": 490}, {"input": {"num": "13"}, "output": 101}, {"input": {"num": "2"}, "output": 2}], "error_log": []}
{"context": "Given a number, a circular prime is defined as a prime number where all rotations of its digits are also prime numbers. For example, 197 is a circular prime because 197, 971, and 719 are all prime numbers. How many circular primes are there below a given limit?\n\nThe input and output requirements are as follows:\n\nInput:\n  `limit` (int): The upper limit for finding circular primes. It should be a positive integer less than 1,000,000.\n\nOutput:\n  `return` (int): The number of circular primes below the given limit.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef primes(n):\n    \"\"\" Returns  a list of primes < n \"\"\"\n    sieve = [True] * n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if sieve[i]:\n            sieve[i*i::2*i] = [False] * ((n - i*i - 1) // (2*i) + 1)\n    return [2] + [i for i in range(3, n, 2) if sieve[i]]\n\ndef get_circular(number):\n    length = len(str(number))\n    i = 0\n    circular_list = [number]\n    number = str(number)\n    while i < length - 1:\n        temp = number[1:length] + number[0]\n        number = temp\n        circular_list.append(int(number))\n        i = i + 1\n    return set(circular_list)\n\ndef check_number(number):\n    all_odd = True\n    number = set(str(number))\n    for y in number:\n        if int(y) % 2 == 0:\n            all_odd = False\n    return all_odd\n\n# main function\ndef main_solution(limit):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    prime_list = primes(limit)\n    counter = 1\n    limit = len(prime_list)\n    i = 0\n    while i < limit:\n        if prime_list[i] != 0 and check_number(prime_list[i]):\n            circ = get_circular(prime_list[i])\n            all_primes = True\n            for x in circ:\n                if x not in prime_list:\n                    all_primes = False\n            if all_primes:\n                counter = counter + len(circ)\n                for y in circ:\n                    index = prime_list.index(y)\n                    prime_list[index] = 0\n        i = i + 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return counter", "input_generator": "import random\n\ndef input_generator():\n    limits = [100, 200, 500, 1000, 2000, 5000, 10000]\n    limit = random.choice(limits)\n    return {'limit': limit}", "io_pairs": [{"input": {"limit": 100}, "output": 13}, {"input": {"limit": 10000}, "output": 33}, {"input": {"limit": 2000}, "output": 25}, {"input": {"limit": 5000}, "output": 25}, {"input": {"limit": 500}, "output": 16}, {"input": {"limit": 200}, "output": 13}, {"input": {"limit": 1000}, "output": 25}], "error_log": []}
{"context": "Given a linked list with nodes containing integer values, determine the value of the node where a cycle starts, if a cycle exists. If there is no cycle, return `None`. The linked list is represented by a list of integers, and the position of the node where the cycle starts is indicated by an integer index. What is the value of the node where the cycle starts?\n\nThe input and output requirements are as follows:\n\nInput:\n  `values` (list of int): A list of integers representing the values of the nodes in the linked list.\n  `cycle_position` (int): An integer representing the index of the node where the cycle starts. If there is no cycle, this value should be `-1`.\n\nOutput:\n  `return` (int or None): The value of the node where the cycle starts. If there is no cycle, it returns `None`.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef create_linked_list(values, cycle_position):\n    nodes = [Node(val) for val in values]\n    for i in range(len(nodes) - 1):\n        nodes[i].next = nodes[i + 1]\n    if cycle_position != -1:\n        nodes[-1].next = nodes[cycle_position]\n    return nodes[0]\n\ndef find_cycle_start(head):\n    fast = slow = head\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n        if fast == slow:\n            break\n    else:\n        return None\n\n    fast = head\n    while fast != slow:\n        fast = fast.next\n        slow = slow.next\n    return fast\n\n# main function\ndef main_solution(values, cycle_position):\n    # Convert JSON serializable inputs to the original input variables\n    head = create_linked_list(values, cycle_position)\n    \n    # Find the cycle start node\n    cycle_start_node = find_cycle_start(head)\n    \n    # Convert the output to JSON serializable\n    if cycle_start_node:\n        return cycle_start_node.val\n    else:\n        return None", "input_generator": "import random\n\ndef input_generator():\n    length = random.randint(1, 20)\n    values = [random.randint(1, 100) for _ in range(length)]\n    cycle_position = random.randint(-1, length - 1)\n    return {'values': values, 'cycle_position': cycle_position}", "io_pairs": [{"input": {"values": [39, 72, 32, 36, 16, 31, 46, 7, 65, 61, 60, 20], "cycle_position": 0}, "output": 39}, {"input": {"values": [89, 31, 71, 63, 10, 68], "cycle_position": 1}, "output": 31}, {"input": {"values": [45, 3, 4, 18, 88, 15, 91], "cycle_position": 6}, "output": 91}, {"input": {"values": [96, 33], "cycle_position": 1}, "output": 33}, {"input": {"values": [75, 67, 58, 93, 58, 81, 92, 78, 24, 97, 56, 76, 34, 39, 81], "cycle_position": 8}, "output": 24}, {"input": {"values": [36, 34, 70, 4, 100], "cycle_position": 2}, "output": 70}, {"input": {"values": [14, 12, 91, 32, 64, 61, 27, 48, 68, 69, 32, 95, 82, 74, 50], "cycle_position": 0}, "output": 14}, {"input": {"values": [9, 81, 85, 74, 74, 21, 76, 49, 94, 66], "cycle_position": 7}, "output": 49}, {"input": {"values": [29, 20, 54], "cycle_position": 1}, "output": 20}, {"input": {"values": [58, 63, 89, 6, 96, 78, 38, 47, 22], "cycle_position": 1}, "output": 63}], "error_log": []}
{"context": "Given a cryptarithmetic problem where words are represented by letters and each letter corresponds to a unique digit, how can you determine the numeric values assigned to each letter such that the arithmetic operation holds true? Specifically, what are the numeric values for each letter in the problem \"SEND + MORE = MONEY\"?\n\nThe input and output requirements are as follows:\n\nInput:\n  `problem_str` (str): A string representing the cryptarithmetic problem in the format \"WORD1 OPERATOR WORD2 = WORD3\". The words are composed of uppercase letters, and the operator can be '+', '-', '*', or '/'.\n\nOutput:\n  `return` (dict): A dictionary where the keys are the unique characters in the problem and the values are their corresponding numeric values. If the problem is not solved, the dictionary will contain a single key \"solved\" with the value `False`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass CSP_crypt:\n    def __init__(self, str):\n        p = str.split()\n        self.p1 = p[0]\n        self.p2 = p[2]\n        self.p3 = p[4]\n        self.opr = p[1]\n        self.state = []\n        self.solved = False\n        \n        for q in self.p1:\n            if q not in self.state:\n                self.state.append(q)\n        for q in self.p2:\n            if q not in self.state:\n                self.state.append(q)\n        for q in self.p3:\n            if q not in self.state:\n                self.state.append(q)\n\n        for i in range(10 - len(self.state)):\n            self.state.append('x')\n    \n    def get_number(self, p):\n        num = 0\n        for q in p:\n            num = num * 10\n            num = num + self.state.index(q)\n        return num\n    \n    def solve(self):\n        num1 = self.get_number(self.p1)\n        num2 = self.get_number(self.p2)\n        num3 = self.get_number(self.p3)\n        \n        if self.opr == '+':\n            ans = num1 + num2\n        elif self.opr == '-':\n            ans = num1 - num2\n        elif self.opr == '*':\n            ans = num1 * num2\n        elif self.opr == '/':\n            ans = num1 / num2\n        \n        if ans == num3:\n            self.solved = True\n    \n    def expand(self, l, r, depth):\n        self.solve()\n        if self.solved:\n            return\n        elif l == r:\n            return\n        else:\n            for i in range(l, r + 1):\n                self.state[l], self.state[i] = self.state[i], self.state[l]\n                if self.apply_constraints(depth):\n                    depth += 1\n                    self.expand(l + 1, r, depth)\n                    depth -= 1\n                if self.solved:\n                    return\n                self.state[i], self.state[l] = self.state[l], self.state[i]\n    \n    def apply_constraints(self, depth):\n        if (len(self.p3) > len(self.p1)) and (len(self.p3) > len(self.p2)):\n            if self.state[0] == self.p3[0]:\n                return True\n            if self.state[1] == self.p3[0]:\n                return True\n            elif depth < 2:\n                return True\n        else:\n            return True\n        return False\n\n# main function\ndef main_solution(problem_str):\n    # Convert the input string to a CSP_crypt object\n    csp_crypt = CSP_crypt(problem_str)\n    \n    # Solve the problem\n    csp_crypt.expand(0, 9, 0)\n    \n    # Check if the problem is solved\n    if csp_crypt.solved:\n        # Convert the state to a JSON serializable format\n        result = {char: csp_crypt.state.index(char) for char in csp_crypt.state if char != 'x'}\n        return result\n    else:\n        return {\"solved\": False}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    operators = ['+', '-', '*', '/']\n    operator = random.choice(operators)\n    \n    # Generate random lengths for p1, p2, p3 (1 to 4 characters)\n    len_p1 = random.randint(1, 4)\n    len_p2 = random.randint(1, 4)\n    len_p3 = random.randint(1, 4)\n    \n    # Generate unique characters for p1, p2, p3\n    chars = random.sample(string.ascii_uppercase, random.randint(3, 10))\n    p1_chars = random.sample(chars, min(len_p1, len(chars)))\n    p1 = ''.join(p1_chars)\n    \n    remaining_chars = [c for c in chars if c not in p1_chars]\n    p2_chars = random.sample(remaining_chars, min(len_p2, len(remaining_chars)))\n    p2 = ''.join(p2_chars)\n    \n    remaining_chars = [c for c in chars if c not in p1_chars + p2_chars]\n    p3_chars = random.sample(remaining_chars, min(len_p3, len(remaining_chars)))\n    p3 = ''.join(p3_chars)\n    \n    problem_str = f\"{p1} {operator} {p2} = {p3}\"\n    \n    return {\"problem_str\": problem_str}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a square matrix, what is the determinant of the matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of ints or floats): A square matrix represented as a list of lists. Each inner list represents a row in the matrix.\n\nOutput:\n  `return` (float): The determinant of the input matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix):\n    # Convert the input list of lists to a NumPy array\n    np_matrix = np.array(matrix)\n    \n    # Compute the determinant of the matrix\n    determinant = np.linalg.det(np_matrix)\n    \n    # Return the determinant as a float\n    return determinant", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.randint(2, 5)  # Generate matrices of size 2x2 to 5x5\n    matrix = np.random.randint(-10, 10, size=(size, size)).tolist()\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[-7, 1], [4, -1]]}, "output": 2.9999999999999996}, {"input": {"matrix": [[1, 9], [4, -8]]}, "output": -44.000000000000014}, {"input": {"matrix": [[-1, 2], [-1, -10]]}, "output": 12.0}, {"input": {"matrix": [[9, -5, 4, 7], [-5, -8, 7, 4], [-5, -4, 4, 1], [3, -2, 4, -2]]}, "output": 171.00000000000114}, {"input": {"matrix": [[-10, -1, -4], [-1, 5, 1], [9, 9, 6]]}, "output": -9.000000000000005}, {"input": {"matrix": [[-6, 3], [0, -4]]}, "output": 23.999999999999993}, {"input": {"matrix": [[7, -2], [2, -10]]}, "output": -65.99999999999997}, {"input": {"matrix": [[7, -4, -7, 6], [9, 6, 1, 6], [-10, 2, -5, 8], [6, -5, 7, 1]]}, "output": -13994.000000000013}, {"input": {"matrix": [[-5, -10, 6], [-8, -2, -8], [6, 6, -7]]}, "output": 513.9999999999998}, {"input": {"matrix": [[-1, -3], [-3, 3]]}, "output": -12.0}], "error_log": []}
{"context": "Given a list of courses and their prerequisites, determine the order in which these courses can be taken such that no course is taken before its prerequisites are fulfilled. Additionally, ensure that the courses can be completed within a maximum of 8 semesters. What is the schedule of courses for each semester, and is the input valid?\n\nThe input and output requirements are as follows:\n\nInput:\n  `course_data` (list of strings): A list of strings where each string represents a line of course prerequisites. Each line contains course names separated by spaces.\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `status` (string): Either \"valid\" or \"invalid\", indicating whether the input course data forms a valid Directed Acyclic Graph (DAG) and can be scheduled within 8 semesters.\n    - `semesters` (list of lists of strings): A list of semesters, where each semester is a list of course names that can be taken in that semester. If the status is \"invalid\", this list will be empty.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\ndef toGraph(theString):\n    return [line.replace(',', ' ').replace(', ', ' ').replace('.', '').replace('\\n', '') for line in theString]\n\ndef nodeList(theList):\n    theString = ' '.join(theList)\n    toSet = theString.split()\n    result = list(set(toSet))\n    result.sort()\n    return result\n\ndef graphInList(theList, listOfNode):\n    result = []\n    for every in theList:\n        tmpEvery = every.split()\n        tmp = []\n        for inside in tmpEvery:\n            for i in range(len(listOfNode)):\n                if inside == listOfNode[i]:\n                    tmp.append(i)\n        result.append(tmp)\n    return result\n\ndef topSort(graphRepre):\n    theOrder = []\n    deg0 = []\n\n    for i in range(len(graphRepre)):\n        if len(graphRepre[i]) == 1:\n            deg0 += graphRepre[i]\n\n    if len(deg0) > 0:\n        for j in range(len(deg0)):\n            graphRepre.remove([deg0[j]])\n            for every in graphRepre:\n                if (len(every) > 1 and deg0[j] in every):\n                    every.remove(deg0[j])\n        theOrder.append(deg0)\n    else:\n        return None\n\n    if (len(graphRepre) > 0):\n        if (len(deg0) != 0):\n            nextOrder = topSort(graphRepre)\n            if (nextOrder != None):\n                theOrder += nextOrder\n            else:\n                return None\n\n    if (len(theOrder) > 8):\n        return None\n\n    return theOrder\n\n# main function\ndef main_solution(course_data):\n    # Convert the input string to a list of strings\n    listFromFile = toGraph(course_data)\n    \n    # Get the list of unique nodes (courses)\n    listOfNode = nodeList(listFromFile)\n    \n    # Represent the graph in a 2D list\n    graphRepre = graphInList(listFromFile, listOfNode)\n    \n    # Perform topological sort\n    result = topSort(graphRepre)\n    \n    # Convert the result to a JSON serializable format\n    if result is None:\n        return {\"status\": \"invalid\", \"semesters\": []}\n    else:\n        return {\"status\": \"valid\", \"semesters\": [[listOfNode[course] for course in semester] for semester in result]}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    courses = ['CS101', 'CS102', 'CS201', 'CS202', 'CS301', 'CS302', 'MATH101', 'MATH102', 'PHYS101', 'PHYS201']\n    num_courses = random.randint(3, len(courses))\n    selected_courses = random.sample(courses, num_courses)\n    \n    # Generate random prerequisites\n    lines = []\n    for i in range(1, num_courses):\n        prereq = random.sample(selected_courses[:i], min(i, random.randint(1, 2)))\n        lines.append(f\"{selected_courses[i]} {' '.join(prereq)}\")\n    \n    # Ensure at least one line\n    if not lines:\n        lines.append(f\"{selected_courses[0]}\")\n    \n    course_data = '\\n'.join(lines)\n    return {'course_data': course_data}", "io_pairs": [{"input": {"course_data": "PHYS101 CS102\nCS101 CS102 PHYS101"}, "output": {"status": "invalid", "semesters": []}}, {"input": {"course_data": "CS102 CS301\nMATH101 CS102\nMATH102 CS301 MATH101\nCS302 CS301 CS102\nCS201 CS302 MATH102"}, "output": {"status": "invalid", "semesters": []}}, {"input": {"course_data": "CS302 MATH101\nMATH102 MATH101\nPHYS101 MATH102 CS302"}, "output": {"status": "invalid", "semesters": []}}, {"input": {"course_data": "CS302 CS301\nMATH101 CS302"}, "output": {"status": "invalid", "semesters": []}}, {"input": {"course_data": "CS302 PHYS101\nCS102 PHYS101\nMATH101 CS102 CS302"}, "output": {"status": "invalid", "semesters": []}}, {"input": {"course_data": "CS201 PHYS201\nPHYS101 CS201\nCS102 CS201\nMATH101 PHYS101"}, "output": {"status": "invalid", "semesters": []}}, {"input": {"course_data": "CS201 CS101\nPHYS201 CS101 CS201"}, "output": {"status": "invalid", "semesters": []}}, {"input": {"course_data": "CS301 PHYS201\nPHYS101 PHYS201\nCS201 PHYS101 PHYS201\nMATH101 PHYS101 PHYS201\nMATH102 PHYS201"}, "output": {"status": "invalid", "semesters": []}}, {"input": {"course_data": "CS301 CS302\nPHYS201 CS302 CS301\nCS202 PHYS201\nMATH102 CS301\nCS102 CS302\nCS101 PHYS201\nMATH101 CS102"}, "output": {"status": "invalid", "semesters": []}}, {"input": {"course_data": "MATH102 PHYS101\nCS302 PHYS101 MATH102\nCS202 CS302\nCS101 MATH102\nCS201 PHYS101 CS302"}, "output": {"status": "invalid", "semesters": []}}], "error_log": []}
{"context": "Given a mathematical function that calculates a Fibonacci-like sequence value based on the input integer `n`, what is the resulting value when `n` is provided?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The integer value for which the Fibonacci-like sequence value needs to be calculated.\n\nOutput:\n  `return` (float): The calculated Fibonacci-like sequence value for the given `n`.", "reference_code": "# import necessary packages\nfrom math import sqrt\n\n# main function\ndef main_solution(n):\n    # Calculate the Fibonacci-like sequence value for the given n\n    result = ((1 + sqrt(5))**n - (1 - sqrt(5))**n) / (2**n * sqrt(5))\n    # Return the result as a float\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(0, 20)\n    return {'n': n}", "io_pairs": [{"input": {"n": 0}, "output": 0.0}, {"input": {"n": 12}, "output": 144.00000000000006}, {"input": {"n": 18}, "output": 2584.000000000002}, {"input": {"n": 14}, "output": 377.00000000000017}, {"input": {"n": 15}, "output": 610.0000000000003}, {"input": {"n": 11}, "output": 89.00000000000003}, {"input": {"n": 20}, "output": 6765.000000000005}, {"input": {"n": 9}, "output": 34.00000000000001}, {"input": {"n": 2}, "output": 1.0}, {"input": {"n": 7}, "output": 13.000000000000002}], "error_log": []}
{"context": "Given a range of numbers, how many possible passwords within that range meet the criteria where two adjacent digits are the same and the digits never decrease from left to right?\n\nThe input and output requirements are as follows:\n\nInput:\n  `min_num` (int): The minimum value of the range within which to search for possible passwords.\n  `max_num` (int): The maximum value of the range within which to search for possible passwords.\n\nOutput:\n  `return` (int): The count of possible passwords that meet the criteria within the specified range.", "reference_code": "# import necessary packages\nfrom datetime import datetime\n\n# main function\ndef main_solution(min_num, max_num):\n    \"\"\"\n    Counts the number of possible passwords within a given range that meet the following criteria:\n    1. The value is within the range [min_num, max_num].\n    2. Two adjacent digits are the same (like 22 in 122345).\n    3. Going from left to right, the digits never decrease; they only ever increase or stay the same (like 111123 or 135679).\n    \n    Parameters:\n    min_num (int): The minimum value of the range.\n    max_num (int): The maximum value of the range.\n    \n    Returns:\n    int: The count of possible passwords that meet the criteria.\n    \"\"\"\n    possible_count = 0\n\n    for i in range(min_num, max_num + 1):\n        possible_password = f\"{i:0{len(str(max_num))}}\"\n        is_valid = True\n\n        runs = []\n\n        for j in range(len(possible_password)):\n            try:\n                if int(possible_password[j]) > int(possible_password[j + 1]):\n                    is_valid = False\n                    break\n            except IndexError:\n                pass\n\n            if not runs or runs[-1][0] != possible_password[j]:\n                runs.append([possible_password[j], 1])\n            else:\n                runs[-1][1] += 1\n\n        has_repeat = any([True for x in runs if x[1] == 2])\n        if has_repeat and is_valid:\n            possible_count += 1\n\n    return possible_count", "input_generator": "import random\n\ndef input_generator():\n    min_num = random.randint(100000, 500000)\n    max_num = random.randint(min_num, 999999)\n    return {'min_num': min_num, 'max_num': max_num}", "io_pairs": [{"input": {"min_num": 360060, "max_num": 770251}, "output": 305}, {"input": {"min_num": 110335, "max_num": 453683}, "output": 1851}, {"input": {"min_num": 194969, "max_num": 668710}, "output": 1121}, {"input": {"min_num": 428885, "max_num": 875681}, "output": 288}, {"input": {"min_num": 364033, "max_num": 436415}, "output": 28}, {"input": {"min_num": 344509, "max_num": 803416}, "output": 433}, {"input": {"min_num": 249827, "max_num": 945391}, "output": 672}, {"input": {"min_num": 173876, "max_num": 264863}, "output": 527}, {"input": {"min_num": 215153, "max_num": 826684}, "output": 1146}, {"input": {"min_num": 132352, "max_num": 401828}, "output": 1145}], "error_log": []}
{"context": "Given a polynomial function `f(x) = x^3 - 2x - 5`, what is the approximate root of the function when using Newton's method starting from a random initial guess within the range of 1 to 1000?\n\nThe input and output requirements are as follows:\n\nInput:\n  `startingInt` (int): The initial guess for the root of the function.\n\nOutput:\n  `return` (float): The approximate root of the function `f(x) = x^3 - 2x - 5` found using Newton's method.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef newton(function, function1, startingInt):\n    x_n = startingInt\n    while True:\n        x_n1 = x_n - function(x_n) / function1(x_n)\n        if abs(x_n - x_n1) < 10**-5:\n            return x_n1\n        x_n = x_n1\n\ndef f(x):\n    return (x**3) - (2 * x) - 5\n\ndef f1(x):\n    return 3 * (x**2) - 2\n\n# main function\ndef main_solution(startingInt):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = newton(f, f1, startingInt)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    startingInt = random.uniform(-10.0, 10.0)\n    return {'startingInt': startingInt}", "io_pairs": [{"input": {"startingInt": 8.295265510124938}, "output": 2.0945514815423265}, {"input": {"startingInt": 9.888834371143183}, "output": 2.094551481544415}, {"input": {"startingInt": -9.734159406411582}, "output": 2.094551481542436}, {"input": {"startingInt": -6.718808074843039}, "output": 2.0945514815423265}, {"input": {"startingInt": -2.184125568329476}, "output": 2.0945514815625352}, {"input": {"startingInt": 0.022066083630623012}, "output": 2.094551481542583}, {"input": {"startingInt": -2.8749567311521957}, "output": 2.094551481584224}, {"input": {"startingInt": 2.2275023322692427}, "output": 2.0945514815423265}, {"input": {"startingInt": 9.2142785262177}, "output": 2.0945514815423842}, {"input": {"startingInt": 7.889458270022779}, "output": 2.0945514815423265}], "error_log": []}
{"context": "Given a scenario where muffins need to be distributed among two groups of students, one group being the \"majors\" and the other being the \"minors\", how can we maximize the size of the smallest piece of muffin each student receives? The problem involves determining the optimal way to cut the muffins into pieces such that the smallest piece is as large as possible, given the constraints on the number of muffins, students, and the value of the pieces each student should receive. What is the maximum size of the smallest piece that can be achieved?\n\nThe input and output requirements are as follows:\n\nInput:\n  `muffins` (tuple of 3 floats): Represents the number of muffins (Nm), the value of each muffin (Vm), and the number of pieces each muffin is cut into (Pm).\n  `majors` (tuple of 3 floats): Represents the number of major students (Ns1), the value of muffins each major student receives (Vs1), and the number of pieces each major student receives (Ps1).\n  `minors` (tuple of 3 floats): Represents the number of minor students (Ns2), the value of muffins each minor student receives (Vs2), and the number of pieces each minor student receives (Ps2).\n\nOutput:\n  `return` (float): The maximum size of the smallest piece that can be achieved in the muffin distribution problem.", "reference_code": "# import necessary packages\nfrom fractions import Fraction\nimport math\n\n# all class and function definitions in the code file, if any\ndef scott(muffins, majors, minors):\n    (Nm, Vm, Pm), (Ns1, Vs1, Ps1), (Ns2, Vs2, Ps2) = muffins, majors, minors\n\n    if Ns2 * Ps2 >= Nm + Ns2 or Ns2 == 0:\n        return Vs1 / Ps1\n\n    L = Fraction(math.ceil(1/(Nm/Ns2 + 1 - Ps2)))\n\n    a = L*Nm - L*Ps2*Ns2 + L*Ns2 - Ns2\n    if L == 1:\n        a = 0\n    b = (Ns2 - a*(L - 1)) / L\n\n    newPs1 = (L*Ps2 - 2*(L-1))*(Pm-1) + (L - 1) * (Pm - 2)\n    newPs2 = ((L-1)*Ps2 - 2*(L-2))*(Pm-1) + (L - 2) * (Pm - 2)\n    newMajors = (b, (L*Ps2 - (L-1))*Vm - L*Vs2, newPs1)\n    newMinors = (a, ((L-1)*Ps2 - (L-2))*Vm - (L-1)*Vs2, newPs2)\n\n    return scott(majors, newMajors, newMinors)\n\n# main function\ndef main_solution(muffins, majors, minors):\n    # Convert input to Fraction objects\n    muffins = tuple(Fraction(m) for m in muffins)\n    majors = tuple(Fraction(m) for m in majors)\n    minors = tuple(Fraction(m) for m in minors)\n    \n    # Call the scott function\n    result = scott(muffins, majors, minors)\n    \n    # Convert the result to a JSON serializable format\n    return float(result)", "input_generator": "import random\nfrom fractions import Fraction\n\ndef input_generator():\n    # Generate random integers for muffins (Nm, Vm, Pm)\n    Nm = random.randint(1, 100)\n    Vm = random.randint(1, 100)\n    Pm = random.randint(1, 100)\n    \n    # Generate random integers for majors (Ns1, Vs1, Ps1)\n    Ns1 = random.randint(1, 100)\n    Vs1 = random.randint(1, 100)\n    Ps1 = random.randint(1, 100)\n    \n    # Generate random integers for minors (Ns2, Vs2, Ps2)\n    Ns2 = random.randint(0, 100)\n    Vs2 = random.randint(1, 100)\n    Ps2 = random.randint(1, 100)\n    \n    # Ensure Ns2 * Ps2 is not >= Nm + Ns2 if Ns2 > 0 to avoid trivial cases\n    if Ns2 > 0 and Ns2 * Ps2 >= Nm + Ns2:\n        Ps2 = random.randint(1, (Nm + Ns2 - 1) // Ns2 if Ns2 != 0 else 1)\n    \n    return {\n        'muffins': (Nm, Vm, Pm),\n        'majors': (Ns1, Vs1, Ps1),\n        'minors': (Ns2, Vs2, Ps2)\n    }", "io_pairs": [{"input": {"muffins": [14, 32, 75], "majors": [88, 1, 24], "minors": [53, 60, 1]}, "output": -2.9295774647887325}, {"input": {"muffins": [58, 8, 42], "majors": [100, 36, 71], "minors": [8, 49, 8]}, "output": 0.03035413153456998}, {"input": {"muffins": [73, 23, 60], "majors": [8, 21, 60], "minors": [81, 47, 1]}, "output": -1.2241379310344827}, {"input": {"muffins": [44, 16, 34], "majors": [17, 36, 96], "minors": [77, 3, 1]}, "output": 0.3125}, {"input": {"muffins": [5, 1, 83], "majors": [78, 81, 61], "minors": [12, 16, 1]}, "output": -0.5875}, {"input": {"muffins": [23, 82, 82], "majors": [62, 33, 45], "minors": [98, 82, 1]}, "output": -4.259740259740259}, {"input": {"muffins": [82, 74, 18], "majors": [48, 45, 16], "minors": [77, 69, 1]}, "output": 0.29411764705882354}, {"input": {"muffins": [60, 53, 82], "majors": [23, 61, 68], "minors": [85, 82, 1]}, "output": -1.3875}, {"input": {"muffins": [59, 79, 27], "majors": [72, 9, 63], "minors": [84, 67, 1]}, "output": -2.2}, {"input": {"muffins": [83, 51, 90], "majors": [31, 76, 83], "minors": [70, 51, 1]}, "output": 0.0}], "error_log": []}
{"context": "In a game of Tic Tac Toe, a computer player is programmed to always make the optimal move. Given a partially filled Tic Tac Toe board, what will be the state of the board after the computer makes its move, and who will be the winner if the game is finished?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of strings): A list representing the Tic Tac Toe board. Each element can be either \" \", \"X\", or \"O\". The list should have exactly 9 elements.\n  `comp_letter` (string): A string representing the computer's letter, either \"X\" or \"O\".\n  `player_letter` (string): A string representing the player's letter, either \"X\" or \"O\".\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `board` (list of strings): The updated board after the computer's move.\n    - `winner` (string or None): The winner of the game, either \"X\", \"O\", or None if there is no winner yet.\n    - `finished` (boolean): A boolean indicating if the game is finished.", "reference_code": "# import necessary packages\nfrom random import randint\n\n# all class and function definitions in the code file, if any\ndef check_status(board): #returns winner and if the game is finished\n    #check horizontals\n    if board[1] == board[2] and board[2] == board[3] and board[1] != \" \":\n        return board[1], True\n    elif board[4] == board[5] and board[5] == board[6] and board[4] != \" \":\n        return board[4], True\n    elif board[7] == board[8] and board[8] == board[9] and board[7] != \" \":\n        return board[7], True\n\n    #check verticals\n    elif board[1] == board[4] and board[4] == board[7] and board[1] != \" \":\n        return board[1], True\n    elif board[2] == board[5] and board[5] == board[8] and board[2] != \" \":\n        return board[2], True\n    elif board[3] == board[6] and board[6] == board[9] and board[3] != \" \":\n        return board[3], True\n\n    #check diagonals\n    elif board[1] == board[5] and board[5] == board[9] and board[1] != \" \":\n        return board[1], True\n    elif board[3] == board[5] and board[5] == board[7] and board[3] != \" \":\n        return board[3], True\n    else:\n        for x in range (1, 10):\n            if board[x] == \" \":\n                return None, False #game is not finished\n        return None, True #tie and no winner found\n\ndef insert_letter(board, letter, position):\n    board[position] = letter\n    return board\n\ndef is_space_free(board, position):\n    if board[position] != \" \":\n        return False\n    else:\n        return True\n\ndef comp_move_unbeatable(board, comp_letter, player_letter):\n    possible_moves = get_possible_moves(board)\n    best_move = None\n    if comp_letter == \"X\":\n        best_score = -float('inf')\n        for move in possible_moves:\n            insert_letter(board, comp_letter, move)\n            score = minimax(board, player_letter)\n            if score > best_score:\n                best_score = score\n                best_move = move\n            board[move] = \" \"\n    else:\n        best_score = float('inf')\n        for move in possible_moves:\n            insert_letter(board, comp_letter, move)\n            score = minimax(board, player_letter)\n            if score < best_score:\n                best_score = score\n                best_move = move\n            board[move] = \" \"\n    insert_letter(board, comp_letter, best_move)\n\ndef minimax(board, letter):\n    winner, finished = check_status(board)\n    if finished:\n        if winner is None:\n            return 0\n        elif winner == \"X\":\n            return 1\n        else:\n            return -1\n    scores = []\n    possible_moves = get_possible_moves(board)\n    for move in possible_moves:\n        insert_letter(board, letter, move)\n        scores.append(minimax(board, \"X\")) if letter == \"O\" else scores.append(minimax(board, \"O\"))\n        board[move] = \" \"\n        if letter == \"X\" and max(scores) == 1 or letter == \"O\" and min(scores) == -1:\n            break\n    return max(scores) if letter == \"X\" else min(scores)\n\ndef get_possible_moves(board):\n    possible_moves = []\n    for x in range (1, 10):\n        if board[x] == \" \":\n            possible_moves.append(x)\n    return possible_moves\n\n# main function\ndef main_solution(board, comp_letter, player_letter):\n    # Convert JSON serializable inputs to original input variables\n    board = [None] + board  # Adjusting board to have 1-based indexing\n    \n    # Core logic\n    comp_move_unbeatable(board, comp_letter, player_letter)\n    winner, finished = check_status(board)\n    \n    # Convert output to JSON serializable\n    board = board[1:]  # Removing the placeholder at index 0\n    return {\"board\": board, \"winner\": winner, \"finished\": finished}", "input_generator": "import random\nfrom random import choice, randint\n\ndef input_generator():\n    # Generate a random board state\n    board = [\" \"] * 9\n    letters = [\"X\", \"O\", \" \"]\n    for i in range(9):\n        board[i] = choice(letters)\n    \n    # Ensure at least one move is possible\n    if \" \" not in board:\n        board[randint(0, 8)] = \" \"\n    \n    # Randomly assign computer and player letters, ensuring they are different\n    comp_letter = choice([\"X\", \"O\"])\n    player_letter = \"O\" if comp_letter == \"X\" else \"X\"\n    \n    return {\n        \"board\": board,\n        \"comp_letter\": comp_letter,\n        \"player_letter\": player_letter\n    }", "io_pairs": [{"input": {"board": ["X", "X", "O", " ", " ", "X", " ", "X", "X"], "comp_letter": "O", "player_letter": "X"}, "output": {"board": ["X", "X", "O", "O", " ", "X", " ", "X", "X"], "winner": null, "finished": false}}, {"input": {"board": ["X", "O", "X", " ", "O", " ", " ", " ", "X"], "comp_letter": "X", "player_letter": "O"}, "output": {"board": ["X", "O", "X", " ", "O", "X", " ", " ", "X"], "winner": "X", "finished": true}}, {"input": {"board": ["X", "O", "X", "O", "O", "X", "O", " ", " "], "comp_letter": "O", "player_letter": "X"}, "output": {"board": ["X", "O", "X", "O", "O", "X", "O", "O", " "], "winner": "O", "finished": true}}, {"input": {"board": [" ", " ", " ", " ", "O", "O", " ", "X", " "], "comp_letter": "O", "player_letter": "X"}, "output": {"board": ["O", " ", " ", " ", "O", "O", " ", "X", " "], "winner": null, "finished": false}}, {"input": {"board": [" ", " ", "O", " ", "X", "O", " ", " ", " "], "comp_letter": "O", "player_letter": "X"}, "output": {"board": ["O", " ", "O", " ", "X", "O", " ", " ", " "], "winner": null, "finished": false}}, {"input": {"board": ["X", "O", "X", "X", " ", "O", "X", "X", "X"], "comp_letter": "X", "player_letter": "O"}, "output": {"board": ["X", "O", "X", "X", "X", "O", "X", "X", "X"], "winner": "X", "finished": true}}, {"input": {"board": ["X", "O", "X", "X", " ", "O", " ", "O", " "], "comp_letter": "X", "player_letter": "O"}, "output": {"board": ["X", "O", "X", "X", "X", "O", " ", "O", " "], "winner": null, "finished": false}}, {"input": {"board": [" ", "O", "O", " ", " ", "O", " ", " ", " "], "comp_letter": "O", "player_letter": "X"}, "output": {"board": ["O", "O", "O", " ", " ", "O", " ", " ", " "], "winner": "O", "finished": true}}, {"input": {"board": [" ", "X", " ", "O", "X", "X", "X", " ", "X"], "comp_letter": "O", "player_letter": "X"}, "output": {"board": ["O", "X", " ", "O", "X", "X", "X", " ", "X"], "winner": null, "finished": false}}, {"input": {"board": ["O", "X", " ", " ", "X", "O", "O", "O", "X"], "comp_letter": "O", "player_letter": "X"}, "output": {"board": ["O", "X", " ", "O", "X", "O", "O", "O", "X"], "winner": "O", "finished": true}}], "error_log": []}
{"context": "In a block-chain system, each block is represented by a unique character from the alphabet. Given a specific length for the block-chain sequence and an initial prefix, how many valid block-chain sequences can be formed that adhere to the rule that no three characters in the sequence can form an increasing subsequence (i.e., a < b < c)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `length` (int): The length of the block-chain sequence.\n  `prefix` (str): The initial prefix of the block-chain sequence.\n\nOutput:\n  `return` (int): The number of valid block-chain sequences of the given length that can be formed starting with the given prefix.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_valid_to_add(prefix, new_char, available):\n    smallest = None\n    for c in prefix:\n        if smallest is None or c < smallest:\n            smallest = c\n        elif smallest < c and c < new_char:\n            return False\n\n    if smallest < new_char:\n        for c in available:\n            if new_char < c:\n                return False\n\n    return True\n\ndef count(prefix, available, target_length):\n    if len(prefix) == target_length:\n        return 1\n\n    total = 0\n\n    for c in list(available):\n        available.remove(c)\n        if is_valid_to_add(prefix, c, available):\n            prefix.append(c)\n            total += count(prefix, available, target_length)\n            prefix.pop()\n        available.add(c)\n\n    return total\n\n# main function\ndef main_solution(length, prefix):\n    # Convert input variables to the required types\n    length = int(length)\n    prefix = list(prefix)\n    chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[:length]\n    available = set(chars) - set(prefix)\n\n    # Call the core function and get the result\n    result = count(prefix, available, length)\n\n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 10)\n    prefix_length = random.randint(0, length - 1)\n    prefix = random.sample(string.ascii_uppercase[:length], prefix_length)\n    return {\n        'length': length,\n        'prefix': ''.join(prefix)\n    }", "io_pairs": [{"input": {"length": 4, "prefix": "BDC"}, "output": 1}, {"input": {"length": 7, "prefix": "EDGACF"}, "output": 1}, {"input": {"length": 7, "prefix": "ECDF"}, "output": 0}, {"input": {"length": 6, "prefix": "FA"}, "output": 1}, {"input": {"length": 7, "prefix": "BA"}, "output": 1}, {"input": {"length": 10, "prefix": "JADHB"}, "output": 0}, {"input": {"length": 9, "prefix": "DGBIHEF"}, "output": 2}, {"input": {"length": 4, "prefix": "DAC"}, "output": 1}, {"input": {"length": 10, "prefix": "F"}, "output": 1001}, {"input": {"length": 6, "prefix": "FEA"}, "output": 1}], "error_log": []}
{"context": "Given a 3x3 matrix with elements drawn from a normal distribution, what is the determinant of the matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of floats): A 2D list representing a square matrix. Each sublist represents a row in the matrix. The matrix must be square (i.e., the number of rows must equal the number of columns).\n\nOutput:\n  `return` (float): The determinant of the input matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix):\n    # Convert the input list to a numpy array\n    A = np.array(matrix)\n    \n    # Function to find the determinant using recursion\n    def findDet(A, total=0):\n        dim = A.shape[0]\n        if dim == 2:\n            det = A[0, 0] * A[1, 1] - A[1, 0] * A[0, 1]\n            return det\n        else:\n            A1 = A.copy()\n            A1 = np.delete(A1, 0, 0)\n            cols = A.shape[1]\n            for i in range(cols):\n                A2 = np.delete(A1, i, 1)\n                total += (-1) ** i * A[0, i] * findDet(A2)\n            return total\n    \n    # Calculate the determinant using the recursive function\n    determinant = findDet(A)\n    \n    # Return the determinant as a float\n    return float(determinant)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.choice([2, 3, 4, 5])\n    matrix = np.random.randint(-10, 10, size=(size, size)).tolist()\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[0, -10], [6, 2]]}, "output": 60.0}, {"input": {"matrix": [[-2, 6, 8], [-8, 7, -6], [6, -6, -1]]}, "output": -130.0}, {"input": {"matrix": [[6, 8, 5], [1, 7, -4], [0, 5, -10]]}, "output": -195.0}, {"input": {"matrix": [[1, 5, 7], [-5, -9, -6], [2, 4, -9]]}, "output": -194.0}, {"input": {"matrix": [[5, -3, -4, 4], [-2, -7, -3, 6], [-2, -3, -4, -10], [-2, -4, -10, 2]]}, "output": 4214.0}, {"input": {"matrix": [[-5, 1, -2], [8, 4, -1], [-4, 4, 5]]}, "output": -252.0}, {"input": {"matrix": [[2, -2], [0, 9]]}, "output": 18.0}, {"input": {"matrix": [[-1, 1, -2], [-4, -6, 8], [-9, -5, 0]]}, "output": -44.0}, {"input": {"matrix": [[-8, -1], [-2, -1]]}, "output": 6.0}, {"input": {"matrix": [[-6, 2, 2], [-1, 5, -10], [-10, 6, 3]]}, "output": -156.0}], "error_log": []}
{"context": "Given the function \\( f(x) = e^{3x} \\cos(\\pi x) \\), consider its integral over the interval \\( (0, 2\\pi) \\). The interval is divided into different numbers of subintervals, and the integral is calculated using both the composite trapezoidal and composite Simpson methods. What are the results of these integration methods for a given number of subintervals \\( n \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of intervals to divide the integration range (0, 2\u03c0) into. It should be a positive integer.\n\nOutput:\n  `return` (dict): A dictionary containing the results of the composite trapezoidal and composite Simpson integration methods.\n    - `\"trapezoidal_result\"` (float): The result of the composite trapezoidal integration.\n    - `\"simpson_result\"` (float): The result of the composite Simpson integration.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef f(x):\n    return (np.exp(3*x))*(np.cos(np.pi*x))\n\ndef composite_trapezoidal(n):\n    a = 0\n    b = 2*np.pi\n    h = (b-a)/n\n    temp = 0\n    for i in range(1, n):\n        temp += f(h*i)\n    return ((b-a)/(2*n))*(f(a)+f(b)+2*temp)\n\ndef composite_simpson(n):\n    a = 0\n    b = np.pi*2\n    h = (b-a)/n\n    temp1 = 0\n    temp2 = 0\n    for i in range(1, n):\n        temp1 += f(h*i)\n    for i in range(0, n):\n        temp2 += f((0.5+i)*h)\n    return ((b-a)/(6*n))*(f(a)+2*temp1+4*temp2+f(b))\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    n = int(n)  # Ensure n is an integer\n    trapezoidal_result = composite_trapezoidal(n)\n    simpson_result = composite_simpson(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"trapezoidal_result\": trapezoidal_result, \"simpson_result\": simpson_result}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    n = random.choice([10, 20, 50, 100, 200, 500, 1000])\n    return {\"n\": n}", "io_pairs": [{"input": {"n": 200}, "output": {"trapezoidal_result": 35225534.978363276, "simpson_result": 35232479.16807642}}, {"input": {"n": 500}, "output": {"trapezoidal_result": 35231369.36592426, "simpson_result": 35232483.25445204}}, {"input": {"n": 1000}, "output": {"trapezoidal_result": 35232204.782320105, "simpson_result": 35232483.355091184}}, {"input": {"n": 100}, "output": {"trapezoidal_result": 35204891.19998546, "simpson_result": 35232416.237822525}}, {"input": {"n": 10}, "output": {"trapezoidal_result": 35146385.827616386, "simpson_result": 34557866.87588305}}, {"input": {"n": 20}, "output": {"trapezoidal_result": 34704996.61381638, "simpson_result": 35190150.197714895}}, {"input": {"n": 50}, "output": {"trapezoidal_result": 35125341.19493705, "simpson_result": 35231407.86833493}}], "error_log": []}
{"context": "Given a sequence of digits from 1 to 9 in numerical order, what is the fewest number of plus and minus signs needed to create an equation that sums up to a specified target value? Additionally, what is the equation that achieves this with the minimum number of operators?\n\nThe input and output requirements are as follows:\n\nInput:\n- `digits` (list of int): A list of digits from 1 to 9 in numerical order.\n- `target` (int): The target sum to achieve.\n\nOutput:\n- `return` (dict): A dictionary containing the minimum number of operators needed and the corresponding equation.\n  - `min_operators` (int): The minimum number of plus and minus signs used.\n  - `equation` (str): The equation that achieves the target sum with the minimum number of operators.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(digits, target):\n    \"\"\"\n    Finds the fewest number of plus and minus signs needed to make a sum of the given digits equal to the target.\n\n    Args:\n    digits (list of int): A list of digits from 1 to 9 in numerical order.\n    target (int): The target sum to achieve.\n\n    Returns:\n    dict: A dictionary containing the minimum number of operators needed and the corresponding equation.\n          Keys:\n          - \"min_operators\" (int): The minimum number of plus and minus signs used.\n          - \"equation\" (str): The equation that achieves the target sum with the minimum number of operators.\n    \"\"\"\n    min_operators = float('inf')\n    best_equation = \"\"\n\n    # Generate all combinations of operators ('', '+', '-') for the given number of digits\n    for operators in itertools.product(['', '+', '-'], repeat=len(digits) - 1):\n        equation = \"\"\n        operator_count = 0\n\n        # Interweave digits and operators\n        for i in range(len(digits) - 1):\n            equation += str(digits[i])\n            if operators[i] != '':\n                equation += operators[i]\n                operator_count += 1\n\n        equation += str(digits[-1])\n\n        # Evaluate the equation\n        if eval(equation) == target:\n            if operator_count < min_operators:\n                min_operators = operator_count\n                best_equation = equation\n\n    return {\"min_operators\": min_operators, \"equation\": best_equation}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random length for digits between 2 and 5\n    length = random.randint(2, 5)\n    # Generate a list of digits from 1 to 9 in numerical order\n    digits = sorted(random.sample(range(1, 10), length))\n    # Generate a target sum between -20 and 20\n    target = random.randint(-20, 20)\n    return {\"digits\": digits, \"target\": target}", "io_pairs": [{"input": {"digits": [3, 4, 9], "target": 3}, "output": {"min_operators": Infinity, "equation": ""}}, {"input": {"digits": [3, 7], "target": 2}, "output": {"min_operators": Infinity, "equation": ""}}, {"input": {"digits": [2, 4, 5], "target": 6}, "output": {"min_operators": Infinity, "equation": ""}}, {"input": {"digits": [2, 3, 5, 6, 9], "target": 10}, "output": {"min_operators": Infinity, "equation": ""}}, {"input": {"digits": [1, 2, 7], "target": -14}, "output": {"min_operators": Infinity, "equation": ""}}, {"input": {"digits": [2, 7, 8, 9], "target": -17}, "output": {"min_operators": Infinity, "equation": ""}}, {"input": {"digits": [2, 4, 5, 9], "target": 11}, "output": {"min_operators": Infinity, "equation": ""}}, {"input": {"digits": [1, 4, 5, 6, 7], "target": -11}, "output": {"min_operators": 4, "equation": "1-4+5-6-7"}}, {"input": {"digits": [2, 3, 8, 9], "target": -12}, "output": {"min_operators": 3, "equation": "2+3-8-9"}}, {"input": {"digits": [2, 5, 9], "target": -6}, "output": {"min_operators": Infinity, "equation": ""}}], "error_log": []}
{"context": "Given a number, determine if it is a prime number. The number should be tested using a primality test for 20 random values less than the number. What is the result of the primality test for the given number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number to be checked for primality.\n  `disp` (bool): A boolean flag indicating whether to display intermediate results (True) or not (False).\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"is_prime\"` whose value is a boolean indicating whether the number `n` is prime (True) or not (False).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef get_RandomNumberlessThan(n):\n    return random.randint(1, n-1)\n\ndef PrimalityTesting(a, n, disp):\n    # Simplified Miller-Rabin primality test for demonstration purposes\n    # This is a placeholder implementation and should be replaced with a proper implementation in a real scenario\n    if a % n == 0:\n        return (a, True)\n    else:\n        return (a, False)\n\n# main function\ndef main_solution(n, disp):\n    # Convert JSON serializable input to original input variables\n    disp = bool(disp)  # Ensure disp is a boolean\n\n    # Check if the number passes Primality Testing for 20 values of a\n    testCounter = 0\n    prime = False\n    while testCounter < 20:\n        a = 0\n        # Get a random number less than n and not 0\n        while a == 0:\n            a = get_RandomNumberlessThan(n)\n\n        if disp:\n            print(\"a = \", a)\n\n        # Check if it's prime or not\n        (a, prime) = PrimalityTesting(a, n-1, disp)\n\n        # If it's prime, keep testing for the rest of the values of a\n        if prime:\n            testCounter += 1\n        else:\n            break\n\n        if disp:\n            print('')\n\n    if prime and testCounter == 20:\n        return {\"is_prime\": True}\n    else:\n        return {\"is_prime\": False}", "input_generator": "import random\n\ndef input_generator():\n    n = random.choice([\n        random.randint(2, 100),  # Small numbers\n        random.randint(101, 1000),  # Medium numbers\n        random.randint(1001, 10000),  # Large numbers\n        random.choice([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31])  # Known primes\n    ])\n    disp = random.choice([True, False])\n    return {\"n\": n, \"disp\": disp}", "io_pairs": [{"input": {"n": 3, "disp": false}, "output": {"is_prime": false}}, {"input": {"n": 965, "disp": false}, "output": {"is_prime": false}}, {"input": {"n": 1222, "disp": true}, "output": {"is_prime": false}}, {"input": {"n": 78, "disp": false}, "output": {"is_prime": false}}, {"input": {"n": 2925, "disp": true}, "output": {"is_prime": false}}, {"input": {"n": 5001, "disp": true}, "output": {"is_prime": false}}, {"input": {"n": 1896, "disp": true}, "output": {"is_prime": false}}, {"input": {"n": 3, "disp": true}, "output": {"is_prime": false}}, {"input": {"n": 17, "disp": false}, "output": {"is_prime": false}}, {"input": {"n": 16, "disp": true}, "output": {"is_prime": false}}], "error_log": []}
{"context": "In a game where robots draw pearls from a box, they start with a set of black and white pearls. Each robot has a certain number of moves, after which the initial set is restored for the next game. Each turn, the robot takes a pearl out of the box and puts one of the opposite color back. The goal is to determine the probability of drawing a white pearl on the Nth move. Given the initial set of pearls and the number of moves, what is the probability of drawing a white pearl on the Nth move?\n\nThe input and output requirements are as follows:\n\nInput:\n  `marbles` (str): A string representing the initial set of pearls, where 'w' represents white pearls and 'b' represents black pearls. The length of the string is between 1 and 20.\n  `step` (int): The number of moves (N), an integer between 1 and 20.\n\nOutput:\n  `return` (float): The probability of drawing a white pearl on the Nth move, rounded to two decimal places. The value is between 0 and 1.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(marbles, step):\n    \"\"\"\n    Calculate the probability of drawing a white pearl on the Nth move.\n\n    Args:\n    marbles (str): A string representing the initial set of pearls, where 'w' represents white pearls and 'b' represents black pearls.\n    step (int): The number of moves (N).\n\n    Returns:\n    float: The probability of drawing a white pearl on the Nth move, rounded to two decimal places.\n    \"\"\"\n    n = len(marbles)\n\n    def move(w, b, step):\n        if step == 1:\n            return w / n\n        p1 = 0 if b == 0 else move(w + 1, b - 1, step - 1)\n        p2 = 0 if w == 0 else move(w - 1, b + 1, step - 1)\n        return w / n * p2 + b / n * p1\n\n    return round(move(marbles.count(\"w\"), marbles.count(\"b\"), step), 2)", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 10)\n    marbles = ''.join(random.choices(['w', 'b'], k=length))\n    step = random.randint(1, 5)\n    return {'marbles': marbles, 'step': step}", "io_pairs": [{"input": {"marbles": "bbb", "step": 4}, "output": 0.48}, {"input": {"marbles": "wbwbwbw", "step": 1}, "output": 0.57}, {"input": {"marbles": "wwbw", "step": 3}, "output": 0.56}, {"input": {"marbles": "bbbbbww", "step": 1}, "output": 0.29}, {"input": {"marbles": "bwwbbw", "step": 5}, "output": 0.5}, {"input": {"marbles": "bwwwwbbwbw", "step": 2}, "output": 0.58}, {"input": {"marbles": "bwwbwbw", "step": 1}, "output": 0.57}, {"input": {"marbles": "wwbwwbbww", "step": 2}, "output": 0.63}, {"input": {"marbles": "wbb", "step": 4}, "output": 0.49}, {"input": {"marbles": "w", "step": 4}, "output": 0.0}], "error_log": []}
{"context": "Given a graph represented by a list of edges, determine if there exists an Eulerian tour. An Eulerian tour is a path that visits every edge exactly once and returns to the starting vertex. What is the Eulerian tour for the given graph, or is it not possible to form one?\n\nThe input and output requirements are as follows:\n\nInput:\n  `graph` (list of tuples): A list of tuples representing the edges of the graph. Each tuple contains two integers representing the vertices connected by the edge.\n\nOutput:\n  `return` (list or string): If an Eulerian tour exists, it returns a list of integers representing the tour. If no Eulerian tour exists, it returns the string \"No es euleriano\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef find_eulerian_tour(graph):\n    tour = []\n    tour.append(graph[0][0])\n    final = graph[0][1]\n    graph.pop(0)\n    while len(graph) > 0:\n        l = len(graph)\n        for i in range(l):\n            if(graph[i][0] == final):\n                tour.append(final)\n                final = graph[i][1]\n                graph.pop(i)\n                break\n            if(graph[i][1] == final):\n                tour.append(final)\n                final = graph[i][0]\n                graph.pop(i)\n                break\n        if(len(graph) == l):\n            subtour = find_eulerian_tour(graph)\n            try:\n                dato = tour.index(subtour[0])\n                tour.pop(dato)\n                for i in range(len(subtour)):\n                    tour.insert(dato + i, subtour[i])\n            except ValueError:\n                return \"No es euleriano\"                  \n    \n    tour.append(final)\n    if (tour[0] == tour[len(tour)-1]):\n        return tour\n    else:\n        return \"No es euleriano\"\n\n# main function\ndef main_solution(graph):\n    # Convert input to the required format\n    graph = [(int(edge[0]), int(edge[1])) for edge in graph]\n    \n    # Call the original function\n    result = find_eulerian_tour(graph)\n    \n    # Convert the result to JSON serializable output\n    if result == \"No es euleriano\":\n        return result\n    else:\n        return [int(node) for node in result]", "input_generator": "import random\n\ndef input_generator():\n    # Generate a small random graph that may or may not be Eulerian\n    nodes = random.randint(3, 6)\n    edges = []\n    for i in range(nodes):\n        for j in range(i+1, nodes):\n            if random.random() < 0.5:\n                edges.append((i, j))\n    \n    # Ensure the graph is connected and has at least one edge\n    if not edges:\n        edges = [(0, 1), (1, 2), (2, 0)]\n    \n    # Randomly shuffle the edges\n    random.shuffle(edges)\n    \n    # Convert edges to strings to match the input format\n    graph = [[str(edge[0]), str(edge[1])] for edge in edges]\n    \n    return {'graph': graph}", "io_pairs": [{"input": {"graph": [["1", "4"], ["2", "3"], ["0", "3"]]}, "output": "No es euleriano"}, {"input": {"graph": [["1", "2"]]}, "output": "No es euleriano"}, {"input": {"graph": [["0", "1"], ["1", "2"], ["2", "0"]]}, "output": [0, 1, 2, 0]}, {"input": {"graph": [["0", "2"]]}, "output": "No es euleriano"}, {"input": {"graph": [["0", "1"], ["0", "3"], ["1", "2"]]}, "output": "No es euleriano"}, {"input": {"graph": [["0", "2"], ["0", "1"]]}, "output": "No es euleriano"}, {"input": {"graph": [["0", "4"], ["1", "4"]]}, "output": "No es euleriano"}, {"input": {"graph": [["1", "2"], ["0", "1"], ["0", "2"]]}, "output": [1, 2, 0, 1]}, {"input": {"graph": [["0", "1"], ["1", "2"]]}, "output": "No es euleriano"}, {"input": {"graph": [["2", "3"], ["1", "4"], ["2", "4"]]}, "output": "No es euleriano"}], "error_log": []}
{"context": "Given a grid representing a terrain with varying altitudes, water flows from higher altitudes to lower altitudes. Each cell in the grid can be part of a basin where water collects. The goal is to determine the label of the sink for each cell in the grid after the water has drained to its lowest point. What is the resulting grid of sink labels?\n\nThe input and output requirements are as follows:\n\nInput:\n  `height` (int): The height of the grid.\n  `width` (int): The width of the grid.\n  `altitudes` (list of int): A list of integers representing the altitudes of each cell in the grid. The size of the list is `height * width`.\n\nOutput:\n  `return` (list of list of str): A 2D list where each element is a string representing the label of the sink for the corresponding cell in the grid.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Plane(object):\n    def __init__(self, height, width, grid):\n        self.height = height\n        self.width = width\n        self.grid = grid\n    \n    def at(self, x, y):\n        if (x < 0 or x >= self.width or\n            y < 0 or y >= self.height):\n            return None\n        else:\n            return self.grid[y][x]\n    \n    def neighbors(self, cell):\n        return [cell for cell in\n                [\n                 self.at(cell.x, cell.y - 1), #n\n                 self.at(cell.x - 1, cell.y), #w\n                 self.at(cell.x + 1, cell.y), #e\n                 self.at(cell.x, cell.y + 1)  #s\n                ] if cell]\n        \nclass Cell(object):\n    def __init__(self, x, y, altitude):\n        self.x = x\n        self.y = y\n        self.altitude = altitude\n        self.water = 1\n        self.sink_for = [self]\n        self.sink = self\n        self.label = None\n        \n    def drain_to(self, neighbor):\n        # move the water\n        my_water = self.water\n        neighbor.water += my_water\n        self.water -= my_water\n        \n        # now track the sink\n        neighbor.sink_for = neighbor.sink_for + self.sink_for\n        for cell in neighbor.sink_for:\n            cell.sink = neighbor\n        self.sink_for = []\n        \n        return my_water != self.water\n\n# main function\ndef main_solution(height, width, altitudes):\n    # Convert the altitudes list to a grid of Cell objects\n    grid = []\n    for y in range(height):\n        row = []\n        for x in range(width):\n            row.append(Cell(x, y, altitudes[y * width + x]))\n        grid.append(row)\n    \n    plane = Plane(height, width, grid)\n    \n    # Simulate the water drainage process\n    while True:\n        drained_this_time = False\n        for y in range(height):\n            for x in range(width):\n                cell = plane.at(x, y)\n                \n                neighbors = plane.neighbors(cell)\n                lowest_neighbor = cell\n                for neighbor in neighbors:\n                    if neighbor.altitude < lowest_neighbor.altitude:\n                        lowest_neighbor = neighbor\n                \n                drained_this_time = drained_this_time or cell.drain_to(lowest_neighbor)\n\n        if not drained_this_time:\n            break\n    \n    # Assign labels to the sinks\n    labels = \"abcdefghijklmnopqrstuvwxyz\"\n    label_i = 0\n    for y in range(height):\n        for x in range(width):\n            cell = plane.at(x, y)\n            \n            if not cell.sink.label:\n                cell.sink.label = labels[label_i]\n                label_i += 1\n    \n    # Prepare the output grid with labels\n    output_grid = []\n    for y in range(height):\n        row = []\n        for x in range(width):\n            cell = plane.at(x, y)\n            row.append(cell.sink.label)\n        output_grid.append(row)\n    \n    return output_grid", "input_generator": "import random\n\ndef input_generator():\n    height = random.randint(2, 10)\n    width = random.randint(2, 10)\n    size = height * width\n    altitudes = [random.randint(1, 100) for _ in range(size)]\n    return {\n        'height': height,\n        'width': width,\n        'altitudes': altitudes\n    }", "io_pairs": [{"input": {"height": 4, "width": 3, "altitudes": [54, 40, 16, 38, 96, 61, 83, 98, 74, 3, 21, 80]}, "output": [["a", "b", "b"], ["a", "a", "b"], ["c", "c", "b"], ["c", "c", "c"]]}, {"input": {"height": 5, "width": 3, "altitudes": [83, 83, 4, 91, 84, 93, 15, 69, 15, 24, 50, 47, 1, 14, 93]}, "output": [["a", "b", "b"], ["c", "c", "b"], ["c", "c", "d"], ["e", "e", "d"], ["e", "e", "e"]]}, {"input": {"height": 2, "width": 5, "altitudes": [8, 98, 82, 81, 4, 7, 50, 32, 63, 66]}, "output": [["a", "a", "b", "c", "c"], ["a", "a", "b", "b", "c"]]}, {"input": {"height": 3, "width": 4, "altitudes": [9, 63, 33, 90, 50, 51, 82, 77, 96, 36, 91, 14]}, "output": [["a", "a", "b", "b"], ["a", "c", "b", "d"], ["c", "c", "d", "d"]]}, {"input": {"height": 2, "width": 3, "altitudes": [86, 88, 61, 97, 32, 6]}, "output": [["a", "b", "b"], ["b", "b", "b"]]}, {"input": {"height": 3, "width": 2, "altitudes": [22, 4, 87, 50, 43, 38]}, "output": [["a", "a"], ["a", "a"], ["b", "b"]]}, {"input": {"height": 2, "width": 6, "altitudes": [5, 95, 69, 13, 8, 74, 69, 2, 58, 46, 87, 24]}, "output": [["a", "b", "c", "c", "c", "c"], ["b", "b", "b", "c", "c", "d"]]}, {"input": {"height": 2, "width": 2, "altitudes": [57, 97, 86, 48]}, "output": [["a", "b"], ["b", "b"]]}, {"input": {"height": 2, "width": 6, "altitudes": [64, 33, 44, 81, 57, 13, 94, 1, 44, 8, 99, 71]}, "output": [["a", "a", "a", "b", "c", "c"], ["a", "a", "a", "b", "b", "c"]]}, {"input": {"height": 4, "width": 2, "altitudes": [60, 69, 30, 82, 54, 73, 7, 47]}, "output": [["a", "a"], ["a", "a"], ["b", "b"], ["b", "b"]]}], "error_log": []}
{"context": "Given a temperature in Celsius, what is the equivalent temperature in Fahrenheit?\n\nThe input and output requirements are as follows:\n\nInput:\n  `celsius_value` (float): The temperature value in Celsius that the user wants to convert to Fahrenheit.\n\nOutput:\n  `return` (float): The converted temperature value in Fahrenheit.", "reference_code": "# import necessary packages\nfrom operator import add, sub, mul, truediv\n\n# all class and function definitions in the code file, if any\ndef inform_all_except(source, message, constraints):\n    for c in constraints:\n        if c != source:\n            c[message]()\n\ndef connector(name=None):\n    informant = None\n    constraints = []\n    \n    def set_value(source, value):\n        nonlocal informant\n        val = connector['val']\n        if val is None:\n            informant, connector['val'] = source, value\n            if name is not None:\n                print(name, \"=\", value)\n            inform_all_except(source, 'new_val', constraints)\n        else:\n            if val != value:\n                print('contradiction detected: ', val, ' vs ', value)\n\n    def forget_value(source):\n        nonlocal informant\n        if informant == source:\n            informant, connector['val'] = None, None\n            if name is not None:\n                print(name, ' is forgotten.')\n            inform_all_except(source, 'forget', constraints)\n\n    connector = {\n        'val': None,\n        'set_val': set_value,\n        'forget': forget_value,\n        'has_val': lambda: connector['val'] is not None,\n        'connect': lambda source: constraints.append(source)\n    }\n    return connector\n\ndef make_trenary_constaint(a, b, c, ab, ca, cb):\n    def new_value():\n        av, bv, cv = [connector['has_val']() for connector in (a, b, c)]\n        if av and bv:\n            c['set_val'](constraint, ab(a['val'], b['val']))\n        elif av and cv:\n            b['set_val'](constraint, ca(c['val'], a['val']))\n        elif bv and cv:\n            a['set_val'](constraint, cb(c['val'], b['val']))\n\n    def forget_value():\n        for connector in (a, b, c):\n            connector['forget'](constraint)\n\n    constraint = {'new_val': new_value, 'forget': forget_value}\n    for connector in (a, b, c):\n        connector['connect'](constraint)\n    return constraint\n\ndef adder(a, b, c):\n    return make_trenary_constaint(a, b, c, add, sub, sub)\n    \ndef multiplier(a, b, c):\n    return make_trenary_constaint(a, b, c, mul, truediv, truediv)\n    \ndef constant(connector, value):\n    constraint = {}\n    connector['set_val'](constraint, value)\n    return constraint\n\ndef converter(c, f):\n    u, v, w, x, y = [connector() for _ in range(5)]\n    multiplier(c, w, u)\n    multiplier(v, x, u)\n    adder(v, y, f)\n    constant(w, 9)\n    constant(x, 5)\n    constant(y, 32)\n\n# main function\ndef main_solution(celsius_value):\n    celsius = connector('Celsius')\n    fahrenheit = connector('Fahrenheit')\n    converter(celsius, fahrenheit)\n    \n    celsius['set_val']('user', celsius_value)\n    fahrenheit_value = fahrenheit['val']\n    \n    return fahrenheit_value", "input_generator": "import random\n\ndef input_generator():\n    celsius_value = random.uniform(-100.0, 100.0)\n    return {'celsius_value': celsius_value}", "io_pairs": [{"input": {"celsius_value": -24.364188800263236}, "output": -11.855539840473824}, {"input": {"celsius_value": 90.31869657479956}, "output": 194.5736538346392}, {"input": {"celsius_value": 60.34020425024255}, "output": 140.6123676504366}, {"input": {"celsius_value": -95.52494577944152}, "output": -139.94490240299473}, {"input": {"celsius_value": -1.6779928979447476}, "output": 28.979612783699455}, {"input": {"celsius_value": -52.804199607107826}, "output": -63.04755929279409}, {"input": {"celsius_value": -87.85788022719308}, "output": -126.14418440894752}, {"input": {"celsius_value": -30.900107263892522}, "output": -23.620193075006547}, {"input": {"celsius_value": 20.42918217820005}, "output": 68.7725279207601}, {"input": {"celsius_value": 6.919926861614826}, "output": 44.455868350906684}], "error_log": []}
{"context": "Given a rectangular grid of capital letters and a target word, how many times does the target word appear in the grid, considering all possible directions (horizontal, vertical, and diagonal), and what does the grid look like with each occurrence of the target word converted to lower case?\n\nThe input and output requirements are as follows:\n\nInput:\n  `grid` (list of strings): A rectangular grid of capital letters represented as a list of strings, where each string is a row in the grid.\n  `word` (string): The target word to search for in the grid.\n\nOutput:\n  `return` (dictionary): A dictionary containing:\n    - `count` (int): The total number of occurrences of the target word in the grid.\n    - `modified_grid` (list of strings): The input grid with each occurrence of the target word in lower case, represented as a list of strings.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\ndef count_word(grid, word):\n    lst, count = [[False for j in i] for i in grid], []\n    maxr, maxc = len(grid), len(grid[0])\n    \n    def helper(row, col, word, move=(0,0)):\n        valid = False\n        if len(word) == 1:\n            count.append(1)\n            valid = True\n        else:\n            for direction in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\n                r, c = row + direction[0], col + direction[1]\n                if 0 <= r < maxr and 0 <= c < maxc:\n                    if grid[r][c] == word[1] and (move == (0,0) or move == direction):\n                        if helper(r, c, word[1:], direction):\n                            valid = True\n        if valid:\n            lst[row][col] = True\n            return True\n        return False\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] == word[0]:\n                helper(i, j, word)\n    \n    return len(count), [[j.lower() if lst[index_r][index_c] else j for index_c, j in enumerate(i)] for index_r, i in enumerate(grid)]\n\n# main function\ndef main_solution(grid, word):\n    # Convert the grid to a list of lists of strings\n    grid = [list(row) for row in grid]\n    \n    # Call the count_word function\n    count, modified_grid = count_word(grid, word)\n    \n    # Convert the modified grid back to a list of strings\n    modified_grid = [''.join(row) for row in modified_grid]\n    \n    # Return the result as a dictionary\n    return {\"count\": count, \"modified_grid\": modified_grid}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    rows = random.randint(3, 10)\n    cols = random.randint(3, 10)\n    grid = []\n    for _ in range(rows):\n        row = ''.join(random.choices(string.ascii_uppercase, k=cols))\n        grid.append(row)\n    \n    word_length = random.randint(2, min(rows, cols))\n    word = ''.join(random.choices(string.ascii_uppercase, k=word_length))\n    \n    return {\"grid\": grid, \"word\": word}", "io_pairs": [{"input": {"grid": ["UTXZDMDI", "PETWCQRP", "SKGNLIJS", "AGDJTSBO", "KZZFBDPH"], "word": "EGVX"}, "output": {"count": 0, "modified_grid": ["UTXZDMDI", "PETWCQRP", "SKGNLIJS", "AGDJTSBO", "KZZFBDPH"]}}, {"input": {"grid": ["PBMN", "DBNE", "ROKG", "JYGT"], "word": "UL"}, "output": {"count": 0, "modified_grid": ["PBMN", "DBNE", "ROKG", "JYGT"]}}, {"input": {"grid": ["YUC", "ZAG", "UZG", "WAA", "CHP", "JHX", "VHW"], "word": "WMD"}, "output": {"count": 0, "modified_grid": ["YUC", "ZAG", "UZG", "WAA", "CHP", "JHX", "VHW"]}}, {"input": {"grid": ["ZBEIHFR", "NZAEZYF", "PHEJPXZ", "DMDGUEY", "IFBDJOZ"], "word": "TXH"}, "output": {"count": 0, "modified_grid": ["ZBEIHFR", "NZAEZYF", "PHEJPXZ", "DMDGUEY", "IFBDJOZ"]}}, {"input": {"grid": ["AJZU", "QMKQ", "XBGP"], "word": "JW"}, "output": {"count": 0, "modified_grid": ["AJZU", "QMKQ", "XBGP"]}}, {"input": {"grid": ["OGNQERNEFA", "JJYESCHUMW", "AZFHGRILBT", "PRVACRPDML", "ASOIUQCFDH"], "word": "ZU"}, "output": {"count": 0, "modified_grid": ["OGNQERNEFA", "JJYESCHUMW", "AZFHGRILBT", "PRVACRPDML", "ASOIUQCFDH"]}}, {"input": {"grid": ["ITNPEWH", "MTEQGOL", "HGEJTFX", "WDUCURA"], "word": "TIOP"}, "output": {"count": 0, "modified_grid": ["ITNPEWH", "MTEQGOL", "HGEJTFX", "WDUCURA"]}}, {"input": {"grid": ["NSCIYYE", "QHEGYMD", "PUATUDP", "ZTRSDQW"], "word": "HO"}, "output": {"count": 0, "modified_grid": ["NSCIYYE", "QHEGYMD", "PUATUDP", "ZTRSDQW"]}}, {"input": {"grid": ["RGPFEUE", "PFWVMLH", "JSXBNMI", "QQHYOYL"], "word": "OG"}, "output": {"count": 0, "modified_grid": ["RGPFEUE", "PFWVMLH", "JSXBNMI", "QQHYOYL"]}}, {"input": {"grid": ["SLTXRPAVV", "ORPUXYDCS", "VZLAULJTA", "YVMUQQWPE", "ISAAENORK", "OXGAIWKIR", "NLFLIDNOM", "QFMEWJKAN"], "word": "GSHXEM"}, "output": {"count": 0, "modified_grid": ["SLTXRPAVV", "ORPUXYDCS", "VZLAULJTA", "YVMUQQWPE", "ISAAENORK", "OXGAIWKIR", "NLFLIDNOM", "QFMEWJKAN"]}}], "error_log": []}
{"context": "Given a mathematical equation and an initial guess, what is the root of the equation found using fixed-point iteration to eight correct decimal places? The equation can be one of the following: (a) \\( x^3 = 2x + 2 \\), (b) \\( e^x + x = 7 \\), or (c) \\( e^x + \\sin x = 4 \\). The initial guess for the iteration is provided.\n\nThe input and output requirements are as follows:\n\nInput:\n  `op` (str): A string representing the operation to be performed. It can be one of 'A', 'B', or 'C'.\n  `x0` (float): The initial guess for the fixed-point iteration.\nOutput:\n  `return` (dict): A dictionary containing the key \"root\" with the value being the root of the equation found using fixed-point iteration.", "reference_code": "# import necessary packages\nfrom math import pow, log, sin, e\n\n# all class and function definitions in the code file, if any\ndef psi(x, op):\n    if op == 'A':\n        return pow(2 * x + 2, 1/3)\n    if op == 'B':\n        return log(7 - x)\n    return log(4 - sin(x))\n\ndef equal(xk1, xk):\n    m = abs(xk1 - xk)\n    e = 10**(-8) / 2.0\n\n    if m < e:\n        return True\n    return False\n\ndef fixed_point(x, x0, k, op):\n    b = x\n    a = psi(x, op)\n    if k and equal(a, b):\n        return a\n    else:\n        return fixed_point(a, b, k+1, op)\n\n# main function\ndef main_solution(op, x0):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  root = fixed_point(x0, x0, 0, op)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return {\"root\": root}", "input_generator": "import random\nfrom math import sin\n\ndef input_generator():\n    op = random.choice(['A', 'B', 'C'])\n    if op == 'A':\n        x0 = random.uniform(-1.0, 3.0)  # 2x + 2 >= 0 for cube root, so x >= -1\n    elif op == 'B':\n        x0 = random.uniform(-10.0, 6.9)  # 7 - x > 0 for log, so x < 7\n    else:  # op == 'C'\n        x0 = random.uniform(0.0, 3.0)    # 4 - sin(x) > 0, but sin(x) is in [-1,1], so x can be any real, but keeping it reasonable\n    return {\"op\": op, \"x0\": x0}", "io_pairs": [{"input": {"op": "C", "x0": 0.4458094018631269}, "output": {"root": 1.1299804989555438}}, {"input": {"op": "C", "x0": 2.413030675335561}, "output": {"root": 1.12998049882217}}, {"input": {"op": "B", "x0": -8.991922405156469}, "output": {"root": 1.672821698194332}}, {"input": {"op": "C", "x0": 2.4764133662396786}, "output": {"root": 1.1299804988525188}}, {"input": {"op": "B", "x0": 6.656822696329286}, "output": {"root": 1.6728216984745221}}, {"input": {"op": "A", "x0": 1.434152728209939}, "output": {"root": 1.769292353583007}}, {"input": {"op": "B", "x0": -9.539155373496694}, "output": {"root": 1.6728216981795814}}, {"input": {"op": "A", "x0": 2.404221401625406}, "output": {"root": 1.7692923553149897}}, {"input": {"op": "A", "x0": 1.3786165675389204}, "output": {"root": 1.7692923534670784}}, {"input": {"op": "B", "x0": 3.1112619733061972}, "output": {"root": 1.6728216980408275}}], "error_log": []}
{"context": "Given the polynomial function \\( f(x) = x^3 - 7x^2 + 7x + 15 \\), what are the values of the first, second, and third derivatives, as well as the integral, evaluated at a specific point \\( x \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x_value` (float): The value at which to evaluate the function and its derivatives and integral.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `first_derivative` (float): The value of the first derivative at `x_value`.\n    - `second_derivative` (float): The value of the second derivative at `x_value`.\n    - `third_derivative` (float): The value of the third derivative at `x_value`.\n    - `integral` (float): The value of the integral at `x_value`.", "reference_code": "# import necessary packages\nfrom sympy import symbols, diff, integrate\n\n# main function\ndef main_solution(x_value):\n    # Define the symbolic variable\n    x = symbols(\"x\")\n    \n    # Define the function and its derivatives\n    y = x**3 - 7*x**2 + 7*x + 15\n    y_1 = diff(y, x, 1)\n    y_2 = diff(y, x, 2)\n    y_3 = diff(y, x, 3)\n    Y = integrate(y, x)\n    \n    # Evaluate the derivatives and integral at the given x_value\n    y_1_value = y_1.subs(x, x_value)\n    y_2_value = y_2.subs(x, x_value)\n    y_3_value = y_3.subs(x, x_value)\n    Y_value = Y.subs(x, x_value)\n    \n    # Return the results as a dictionary\n    return {\n        \"first_derivative\": float(y_1_value),\n        \"second_derivative\": float(y_2_value),\n        \"third_derivative\": float(y_3_value),\n        \"integral\": float(Y_value)\n    }", "input_generator": "import random\n\ndef input_generator():\n    x_value = random.uniform(-10.0, 10.0)\n    return {\"x_value\": x_value}", "io_pairs": [{"input": {"x_value": 6.719895771728751}, "output": {"first_derivative": 48.39245674449133, "second_derivative": 26.319374630372508, "third_derivative": 6.0, "integral": 60.58581247986825}}, {"input": {"x_value": -0.04961161767954181}, "output": {"first_derivative": 7.701946585339928, "second_derivative": -14.29766970607725, "third_derivative": 6.0, "integral": -0.7352732339138017}}, {"input": {"x_value": -9.709072186934836}, "output": {"first_derivative": 425.72525881042253, "second_derivative": -72.25443312160903, "third_derivative": 6.0, "integral": 4541.3699331592425}}, {"input": {"x_value": -1.705267701758304}, "output": {"first_derivative": 39.5975616285964, "second_derivative": -24.231606210549824, "third_derivative": 6.0, "integral": -1.7166441734874223}}, {"input": {"x_value": 5.827175378847002}, "output": {"first_derivative": 27.287463383664075, "second_derivative": 20.963052273082013, "third_derivative": 6.0, "integral": 32.8149381225567}}, {"input": {"x_value": -0.8921150133198541}, "output": {"first_derivative": 21.877217777450007, "second_derivative": -19.352690079919125, "third_derivative": 6.0, "integral": -8.781148394010959}}, {"input": {"x_value": -5.010060366360689}, "output": {"first_derivative": 152.44295975278425, "second_derivative": -44.06036219816413, "third_derivative": 6.0, "integral": 463.64368340541034}}, {"input": {"x_value": 0.43647965532291977}, "output": {"first_derivative": 1.4608282940115678, "second_derivative": -11.381122068062481, "third_derivative": 6.0, "integral": 7.029039522140067}}, {"input": {"x_value": -9.490288976382065}, "output": {"first_derivative": 410.0608002350657, "second_derivative": -70.9417338582924, "third_derivative": 6.0, "integral": 4195.240602750514}}, {"input": {"x_value": 7.0926150081482255}, "output": {"first_derivative": 58.6189528473532, "second_derivative": 28.555690048889353, "third_derivative": 6.0, "integral": 82.58792393585153}}], "error_log": []}
{"context": "Given a set of numerical data points, what is the standard deviation of the data set, rounded to three decimal places?\n\nThe input and output requirements are as follows:\n\nInput:\n  `vector` (list of float): A list of numerical values representing the data points.\n\nOutput:\n  `return` (float): The standard deviation of the input vector, rounded to 3 decimal places.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(vector):\n    # Convert the input list to a numpy array\n    x = np.array(vector)\n    \n    # Calculate the mean of the vector\n    m = np.sum(x) / np.size(x)\n    \n    # Calculate the sum of squared differences from the mean\n    d = 0\n    for i in range(np.size(x)):\n        d += (x[i] - m) ** 2\n    \n    # Calculate the standard deviation\n    t = np.sqrt(d / (np.size(x) - 1))\n    \n    # Return the standard deviation rounded to 3 decimal places\n    return round(t, 3)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    vector_length = random.randint(5, 20)\n    vector = [round(random.uniform(0, 100), 2) for _ in range(vector_length)]\n    return {'vector': vector}", "io_pairs": [{"input": {"vector": [78.27, 36.67, 45.32, 5.39, 85.94, 96.23, 91.83]}, "output": 34.204}, {"input": {"vector": [73.03, 70.64, 4.11, 77.76, 97.96, 90.8, 19.17, 45.2, 67.06, 4.82, 15.01, 81.98, 21.72]}, "output": 34.305}, {"input": {"vector": [60.83, 65.28, 31.81, 54.64, 66.52, 10.79]}, "output": 22.345}, {"input": {"vector": [15.72, 15.07, 55.04, 48.79, 31.97, 8.99, 92.88, 73.87, 7.0, 57.0, 78.13, 11.35, 79.21, 3.38, 59.68, 22.13, 0.47, 7.6, 56.04]}, "output": 30.299}, {"input": {"vector": [10.0, 31.57, 87.19, 85.28, 17.97, 58.83, 22.39, 71.95, 88.98]}, "output": 32.346}, {"input": {"vector": [22.94, 58.01, 77.0, 9.72, 19.74, 6.4, 15.86, 68.92, 97.75]}, "output": 33.847}, {"input": {"vector": [6.85, 5.01, 19.47, 32.48, 68.22, 17.04, 62.46, 22.6, 77.24, 14.75, 10.02, 27.63, 3.37]}, "output": 25.087}, {"input": {"vector": [17.01, 41.85, 27.61, 74.84, 92.02, 10.22, 4.68, 48.68, 56.91, 61.16, 42.95, 87.41, 53.42, 29.97, 64.43, 21.83, 84.3, 26.89, 38.79]}, "output": 26.169}, {"input": {"vector": [89.46, 43.55, 76.09, 83.78, 17.35, 67.5, 48.77, 14.51, 42.1, 50.84, 11.58, 10.34]}, "output": 28.61}, {"input": {"vector": [89.37, 41.43, 65.94, 66.96, 69.22, 56.64, 59.87, 92.86, 20.74, 60.91]}, "output": 20.955}], "error_log": []}
{"context": "Imagine you are playing a guessing game where you need to guess a secret number. The game is designed to find the most significant digit of the secret number first and then work towards the right. Given a secret number, what is the most significant digit of the number that the game would guess?\n\nThe input and output requirements are as follows:\n\nInput:\n  `target_number` (str): A string representing the target number to be guessed. The number should be a positive integer.\n\nOutput:\n  `return` (dict): A dictionary containing the key `\"guessed_number\"` with the value being the guessed number as an integer.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass target_num:\n    def __init__(self, target):\n        self.target = target\n\n    def try_num(self, n):\n        if n >= self.target:\n            return n\n\ndef try_digit(n, looking_for):\n    if n >= looking_for:\n        return n\n\ndef get_num_digits(n=9, looking_for=500000000):\n    if try_digit(n, looking_for):\n        return len(str(n))\n    else:\n        return get_num_digits((n * 10) + 9, looking_for)\n\ndef guess_number(N, looking_for):\n    msd = 0  # The digits found so far\n    digits_remaining = N - 1  # The # digits remaining to the right of the one we're working on\n\n    while digits_remaining >= 0:\n        for d in range(10 * msd, 10 * msd + 10):\n            try_num = (d * 10 ** digits_remaining) + (10 ** digits_remaining - 1)\n            if next_digit := try_digit(try_num, looking_for):\n                msd = next_digit // 10 ** digits_remaining\n                break\n        digits_remaining -= 1\n\n    return msd\n\n# main function\ndef main_solution(target_number):\n    # Convert the input to the required format\n    looking_for = int(target_number)\n    \n    # Get the number of digits in the target number\n    N = get_num_digits(looking_for=looking_for)\n    \n    # Guess the number\n    ans = guess_number(N, looking_for)\n    \n    # Return the result as a JSON serializable output\n    return {\"guessed_number\": ans}", "input_generator": "import random\n\ndef input_generator():\n    target = random.randint(1, 10**9)\n    return {'target_number': str(target)}", "io_pairs": [{"input": {"target_number": "846186765"}, "output": {"guessed_number": 846186765}}, {"input": {"target_number": "918793744"}, "output": {"guessed_number": 918793744}}, {"input": {"target_number": "460484869"}, "output": {"guessed_number": 460484869}}, {"input": {"target_number": "127667088"}, "output": {"guessed_number": 127667088}}, {"input": {"target_number": "161930152"}, "output": {"guessed_number": 161930152}}, {"input": {"target_number": "720947285"}, "output": {"guessed_number": 720947285}}, {"input": {"target_number": "243228125"}, "output": {"guessed_number": 243228125}}, {"input": {"target_number": "715977134"}, "output": {"guessed_number": 715977134}}, {"input": {"target_number": "358832015"}, "output": {"guessed_number": 358832015}}, {"input": {"target_number": "346929560"}, "output": {"guessed_number": 346929560}}], "error_log": []}
{"context": "In a dice game, a Player and the House roll dice in rounds to collect successes (1's). The Player rolls fewer dice than the House in normal rounds, but if the Player rolls a 1, the House gets to roll all dice for a set number of penalty rounds. Given the number of rounds to simulate and a parameter `k`, what are the scores of the Player and the House at specific rounds, and what are the calculated bounds for both the Player and the House?\n\nThe input and output requirements are as follows:\n\nInput:\n  `rounds` (int): The number of rounds to simulate in the dice game.\n  `k` (float): A parameter used in the bounds calculation for the player and house.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `player_scores` (list of float): The scores of the player at specific rounds.\n    - `house_scores` (list of float): The scores of the house at specific rounds.\n    - `player_bounds` (list of float): The calculated bounds for the player at specific rounds.\n    - `house_bounds` (list of float): The calculated bounds for the house at specific rounds.", "reference_code": "import random\nimport numpy as np\n\n# Fixed environmental parameters\nN = 3   # Total number of dice rolled in each round\nf = 1   # Number of dice rolled by the House in a normal round\nD = 2   # Number of penalty rounds that begin when Player rolls a 1\nassert N >= 2*f + 1\n\n# Protocol parameters\np = 1/24.   # Probability of success on a dice roll\n\nclass DiceGame():\n    def __init__(self):\n        self.penalty = 0  # Number of penalty rounds\n        self.house = 0    # House's score\n        self.player = 0   # Player's score\n\n    def roll(self, hand):\n        assert hand in ('player','house')\n        if random.random() <= p:  # Pr[success] = p\n            if hand == 'player': \n                self.player += 1\n                self.penalty = D\n            else:\n                self.house += 1\n\n    def round(self):\n        # Player gets to roll (N-f) dice, \n        for _ in range(N-f):\n            if not self.penalty: self.roll('player')\n            else: self.roll('house')\n\n        for _ in range(f):\n            self.roll('house')\n\n        if self.penalty: self.penalty -= 1\n\ndef simulate(rounds):\n    game = DiceGame()\n    \n    global X_C, X_A, R_C, R_A\n    X_C = [0]\n    X_A = [0]\n    R_C = [0]\n    R_A = [0]\n\n    for r in range(rounds):\n        game.round()\n        X_C.append(game.player)\n        X_A.append(game.house)\n        if len(R_C) == game.player: R_C.append(r)\n        if len(R_A) == game.house: R_A.append(r)\n\ndef player_bound(k, r):\n    r = float(r)\n    A = 1 + 1./((N-f)*D*p)\n    B = -np.sqrt(2*k)\n    C = -r/D\n    sqrt_mu = (-B + np.sqrt(B**2 - 4*A*C)) / (2*A)\n    x = (r - sqrt_mu**2 / ((N-f)*p) ) / D\n    return x\n\ndef house_bound(k, r):\n    e = np.sqrt(float(k)/(2*N*r))/2\n    return (N*r*p + np.sqrt(N*r*k/2))/2\n\n# main function\ndef main_solution(rounds, k):\n    simulate(rounds)\n    r = np.array(range(2, rounds))[::1000]\n    xc = np.array(X_C)[r].astype('f')\n    xa = np.array(X_A)[r].astype('f')\n\n    player_bounds = np.array([player_bound(k, r_i) for r_i in r])\n    house_bounds = np.array([house_bound(k, r_i) for r_i in r])\n\n    result = {\n        \"player_scores\": xc.tolist(),\n        \"house_scores\": xa.tolist(),\n        \"player_bounds\": player_bounds.tolist(),\n        \"house_bounds\": house_bounds.tolist()\n    }\n    return result", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    rounds = random.randint(1000, 10000)\n    k = random.uniform(0.1, 10.0)\n    return {\n        \"rounds\": rounds,\n        \"k\": k\n    }", "io_pairs": [{"input": {"rounds": 1523, "k": 6.418634942384598}, "output": {"player_scores": [0.0, 72.0], "house_scores": [0.0, 55.0], "player_bounds": [-2.0449104380052, 44.792377106211745], "house_bounds": [2.319077529803459, 111.7351016044664]}}, {"input": {"rounds": 1316, "k": 8.912813630145404}, "output": {"player_scores": [0.0, 78.0], "house_scores": [0.0, 57.0], "player_bounds": [-2.698361709856772, 39.844828258394614], "house_bounds": [2.7104613171751484, 120.49545637911572]}}, {"input": {"rounds": 1926, "k": 0.13576171091927552}, "output": {"player_scores": [1.0, 83.0], "house_scores": [1.0, 38.0], "player_bounds": [-0.04339703981140142, 67.77620481760204], "house_bounds": [0.44409447376828176, 69.76730095122838]}}, {"input": {"rounds": 1413, "k": 9.532058382227506}, "output": {"player_scores": [0.0, 83.0], "house_scores": [0.0, 55.0], "player_bounds": [-2.85824560979294, 38.72123742974787], "house_bounds": [2.798769583690904, 122.4720628946984]}}, {"input": {"rounds": 1108, "k": 9.624883854929902}, "output": {"player_scores": [0.0, 77.0], "house_scores": [0.0, 50.0], "player_bounds": [-2.8821509493476745, 38.555766088751], "house_bounds": [2.8117569468036043, 122.76275942359268]}}, {"input": {"rounds": 1324, "k": 7.118727334157733}, "output": {"player_scores": [0.0, 68.0], "house_scores": [1.0, 49.0], "player_bounds": [-2.2302023546918504, 43.32440853064526], "house_bounds": [2.4356374662889677, 114.34406607634914]}}, {"input": {"rounds": 1401, "k": 0.386061855290716}, "output": {"player_scores": [0.0, 78.0], "house_scores": [0.0, 61.0], "player_bounds": [-0.19298799605300765, 65.15211633298617], "house_bounds": [0.6630951509426907, 74.66919952198927]}}, {"input": {"rounds": 1601, "k": 4.143411529766532}, "output": {"player_scores": [0.0, 80.0], "house_scores": [0.0, 50.0], "player_bounds": [-1.426179480952468, 50.18335903032812], "house_bounds": [1.8878268909126896, 102.08240592474085]}}, {"input": {"rounds": 1009, "k": 5.904892640193847}, "output": {"player_scores": [0.0, 69.0], "house_scores": [0.0, 34.0], "player_bounds": [-1.907710997601784, 45.918121664076864], "house_bounds": [2.229440419718597, 109.72875154436043]}}, {"input": {"rounds": 1330, "k": 4.336835686372191}, "output": {"player_scores": [0.0, 67.0], "house_scores": [0.0, 54.0], "player_bounds": [-1.4801367232502285, 49.67755875995522], "house_bounds": [1.9285040240540479, 102.99288338709809]}}], "error_log": []}
{"context": "Given a set of prime numbers and their corresponding exponents, what are all the factors of the number formed by the product of these primes raised to their respective exponents?\n\nThe input and output requirements are as follows:\n\nInput:\n  `primes` (str): A JSON-formatted string representing a list of prime numbers.\n  `exponents` (str): A JSON-formatted string representing a list of exponents corresponding to the primes.\n\nOutput:\n  `return` (str): A JSON-formatted string representing a list of all factors of the number formed by the product of primes raised to their respective exponents.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef nextCounter(counter, exponents):\n    carry = 1\n    i = 0\n    while i < len(exponents) and counter[i] + carry >= exponents[i] + 1:\n        counter[i] += carry\n        carry = counter[i] // (exponents[i] + 1)\n        counter[i] %= (exponents[i] + 1)\n        i += 1\n\n    counter[i] += carry\n    return counter\n\ndef findFactors(primes, exponents):\n    counter = [0] * len(exponents)\n    factors = []\n    while counter[len(exponents) - 1] == 0:\n        number = 1\n        for j in range(len(exponents)):\n            number *= primes[j] ** counter[j]\n        factors.append(number)\n        counter = nextCounter(counter, exponents)\n    return factors\n\n# main function\ndef main_solution(primes, exponents):\n    # Convert input to JSON serializable format if necessary\n    primes = json.loads(primes)\n    exponents = json.loads(exponents)\n    \n    # Find all factors\n    factors = findFactors(primes, exponents)\n    \n    # Convert output to JSON serializable format\n    return json.dumps(factors)", "input_generator": "import random\nimport json\n\ndef input_generator():\n    # Generate a random number of primes (between 1 and 5)\n    num_primes = random.randint(1, 5)\n    \n    # Generate random primes (small primes for simplicity)\n    primes_list = random.sample([2, 3, 5, 7, 11, 13, 17, 19], num_primes)\n    \n    # Generate random exponents (between 1 and 5)\n    exponents_list = [random.randint(1, 5) for _ in range(num_primes)]\n    \n    # Convert to JSON strings\n    primes = json.dumps(primes_list)\n    exponents = json.dumps(exponents_list)\n    \n    return {'primes': primes, 'exponents': exponents}", "io_pairs": [{"input": {"primes": "[2]", "exponents": "[2]"}, "output": "[1]"}, {"input": {"primes": "[5, 7]", "exponents": "[5, 4]"}, "output": "[1, 5, 25, 125, 625, 3125]"}, {"input": {"primes": "[19, 2]", "exponents": "[4, 2]"}, "output": "[1, 19, 361, 6859, 130321]"}, {"input": {"primes": "[19]", "exponents": "[2]"}, "output": "[1]"}, {"input": {"primes": "[7, 19]", "exponents": "[3, 4]"}, "output": "[1, 7, 49, 343]"}, {"input": {"primes": "[19]", "exponents": "[3]"}, "output": "[1]"}, {"input": {"primes": "[19, 3, 13]", "exponents": "[4, 1, 5]"}, "output": "[1, 19, 361, 6859, 130321, 3, 57, 1083, 20577, 390963]"}, {"input": {"primes": "[3, 11]", "exponents": "[3, 1]"}, "output": "[1, 3, 9, 27]"}, {"input": {"primes": "[13]", "exponents": "[4]"}, "output": "[1]"}, {"input": {"primes": "[13]", "exponents": "[1]"}, "output": "[1]"}], "error_log": []}
{"context": "Given a logical chain represented as a string, where each part of the chain is separated by commas, and a name for the node, determine if the tree formed by this chain ends in an axiom. What is the result of this determination?\n\nThe input and output requirements are as follows:\n\nInput:\n  `chain` (str): A string representing the logical chain, where each part of the chain is separated by commas.\n  `name` (str): A string representing the name of the node.\n\nOutput:\n  `return` (dict): A dictionary with a single key `is_axiom` which is a boolean indicating whether the tree ends in an axiom.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    '''\n    Represents a node in a dchain-tree.\n    Each node has 0-2 children, depending on its chain.\n    '''\n\n    def __init__(self, chain, name, edge='', parent=None):\n        ''' Constructor '''\n        self.tools = Tools()\n\n        self.name = name\n        self.chain = chain\n        self.parent = parent\n        self.edge = edge\n        self.children = []\n        self.axiom = 'reducible' # undef, no, id, true\n        self.status = ''\n\n    def traverse_tree(self):\n        '''\n        Traverses tree and its child nodes.\n        Returns if it ends in an axiom (True) or if not (False).\n        '''\n        \n        if self.is_axiom():\n            return True\n        \n        self.calculate_children()\n        \n        if len(self.children) == 0:\n            # not an axiom and no children ==> irreducible\n            return False\n        elif len(self.children) == 1:\n            return self.children[0].traverse_tree()\n        elif len(self.children) == 2:\n            children_status = []\n            children_status.append(self.children[0].traverse_tree())\n            children_status.append(self.children[1].traverse_tree())\n            return (children_status[0] and children_status[1])\n\n    def calculate_children(self):\n        '''\n        Calculates the children from a given chain.\n        The rules from PSC apply, an OR leads to 1 child whereas an AND leads to 2 children.\n        '''\n        self.children = []\n\n        for i in range(len(self.chain.split(','))-1, -1, -1):\n            part = self.chain.split(',')[i]\n            part = formula.Formula(part).formula_nnf.replace(' ', '')\n\n            current_level = 0\n            min_level = 1000\n            pos = 0\n            for j in range(len(part)):\n                if part[j] == ')': current_level -= 1\n                if part[j] == '(': current_level += 1\n\n                if part[j] in [self.tools.OR, self.tools.AND] and current_level < min_level:\n                    pos = j\n                    min_level = current_level\n\n            if min_level != 1000:\n                first_part = ','.join(self.chain.split(',')[:i])\n                if first_part != '': first_part = first_part + ','\n                last_part = ','.join(self.chain.split(',')[i+1:])\n                if last_part != '': last_part = ',' + last_part\n\n                if part[pos] == self.tools.OR:\n                    self.children.append(Node(first_part + part[:pos] + ',' + part[pos+1:] + last_part, self.name + '0', self.tools.OR, self))\n                    break\n\n                elif part[pos] == self.tools.AND:\n                    chain1 = first_part + part[:pos] + last_part\n                    chain2 = first_part + part[pos+1:] + last_part\n                    self.children.append(Node(chain1, self.name + '0', self.tools.AND, self))\n                    self.children.append(Node(chain2, self.name + '1', self.tools.AND, self))\n                    break\n\n                if len(self.children) > 0:\n                    break\n\n    def is_axiom(self):\n        '''\n        Checks if current node is an axiom or not.\n        There are two kinds of axioms in PSC:\n\n            1. (True): a TOP is isolated\n            2. (Id): an atomic proposition and also its negation are isolated\n        '''\n\n        # break up chain\n        formulas = self.chain.split(',')\n        for i in range(len(formulas)):\n            formulas[i] = formulas[i].strip()\n\n        # check for TOPs\n        for i in range(len(formulas)):\n            if formulas[i] == self.tools.TOP:\n                self.axiom = 'true'\n                return True\n\n        # check for propositions\n        for i in range(len(formulas)):\n            for j in range(i+1, len(formulas)):\n                if formulas[i] == self.tools.negated(formulas[j]):\n                    self.axiom = 'id'\n                    return True\n\n        # not an axiom. check other two cases\n        if len(self.children) > 0:\n            self.axiom = 'reducible'\n        else:\n            self.axiom = 'no'\n        return False\n\nclass Tools:\n    OR = '|'\n    AND = '&'\n    TOP = 'True'\n\n    def negated(self, formula):\n        return '~' + formula if formula[0] != '~' else formula[1:]\n\nclass formula:\n    class Formula:\n        def __init__(self, formula_str):\n            self.formula_nnf = formula_str\n\n# main function\ndef main_solution(chain, name):\n    # Convert JSON serializable inputs to original input variables\n    node = Node(chain, name)\n    \n    # Traverse the tree and determine if it ends in an axiom\n    result = node.traverse_tree()\n    \n    # Convert the result to a JSON serializable output\n    return {\"is_axiom\": result}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Define possible operators and variables\n    operators = ['&', '|']\n    variables = ['p', 'q', 'r', 's']\n    constants = ['True']\n    \n    # Randomly decide the complexity of the chain (1 to 4 parts)\n    num_parts = random.randint(1, 4)\n    chain_parts = []\n    \n    for _ in range(num_parts):\n        # Randomly choose between a variable, its negation, or a constant\n        choice = random.choice(['var', 'neg_var', 'const'])\n        if choice == 'var':\n            chain_parts.append(random.choice(variables))\n        elif choice == 'neg_var':\n            chain_parts.append('~' + random.choice(variables))\n        else:\n            chain_parts.append(random.choice(constants))\n    \n    # Randomly decide whether to combine parts with operators\n    if len(chain_parts) > 1:\n        for i in range(len(chain_parts) - 1):\n            if random.choice([True, False]):\n                chain_parts[i] = f\"({chain_parts[i]}{random.choice(operators)}{chain_parts[i+1]})\"\n                chain_parts.pop(i+1)\n                break\n    \n    # Join the parts with commas to form the chain\n    chain = ','.join(chain_parts)\n    \n    # Generate a random name for the node\n    name = ''.join(random.choice(string.ascii_lowercase) for _ in range(3))\n    \n    return {\"chain\": chain, \"name\": name}", "io_pairs": [{"input": {"chain": "(r&~r),~r", "name": "ijh"}, "output": {"is_axiom": false}}, {"input": {"chain": "~r,(True&~r),True", "name": "imj"}, "output": {"is_axiom": true}}, {"input": {"chain": "p,~p,r", "name": "vjz"}, "output": {"is_axiom": true}}, {"input": {"chain": "(p&True),s", "name": "dzg"}, "output": {"is_axiom": false}}, {"input": {"chain": "(p&True)", "name": "lue"}, "output": {"is_axiom": false}}, {"input": {"chain": "~q,True,s", "name": "suc"}, "output": {"is_axiom": true}}, {"input": {"chain": "q", "name": "hmv"}, "output": {"is_axiom": false}}, {"input": {"chain": "~p,(p&~r),s", "name": "lvo"}, "output": {"is_axiom": false}}, {"input": {"chain": "q", "name": "hja"}, "output": {"is_axiom": false}}, {"input": {"chain": "True,(q|r)", "name": "yfb"}, "output": {"is_axiom": true}}], "error_log": []}
{"context": "In a Tic-Tac-Toe game, a 3x3 board is represented by a list of 3 strings, where each string represents a row of the board. Each character in the string can be either \" \", \"X\", or \"O\". Given a specific board configuration, can you determine if it is a valid state during a game of Tic-Tac-Toe? Specifically, consider the rules that players take turns, the first player places \"X\" and the second player places \"O\", and the game ends when a player has three of their marks in a row, column, or diagonal, or when the board is full. What is the validity of the given board configuration?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (List[str]): A list of 3 strings, each representing a row of the Tic-Tac-Toe board. Each string contains exactly 3 characters, which can be \" \", \"X\", or \"O\".\n\nOutput:\n  `return` (bool): True if the board configuration is valid according to the rules of Tic-Tac-Toe, False otherwise.", "reference_code": "# import necessary packages\nfrom collections import defaultdict\n\n# main function\ndef main_solution(board):\n    \"\"\"\n    Determines if a given Tic-Tac-Toe board configuration is valid.\n\n    :param board: List[str] - A list of 3 strings, each representing a row of the Tic-Tac-Toe board.\n    :return: bool - True if the board configuration is valid, False otherwise.\n    \"\"\"\n    countX, countO = 0, 0\n    X, O = defaultdict(list), defaultdict(list)\n    \n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == \"X\":\n                countX += 1\n                X[i].append(j)\n                X[j + 3].append(i)\n            elif board[i][j] == \"O\":\n                countO += 1\n                O[i].append(j)\n                O[j + 3].append(i)\n\n    if countX - countO > 1 or countO > countX:\n        return False\n\n    Xwin = any(len(v) == 3 for v in X.values()) or \\\n           (board[0][0] == \"X\" and board[1][1] == \"X\" and board[2][2] == \"X\") or \\\n           (board[2][0] == \"X\" and board[1][1] == \"X\" and board[0][2] == \"X\")\n\n    Owin = any(len(v) == 3 for v in O.values()) or \\\n           (board[0][0] == \"O\" and board[1][1] == \"O\" and board[2][2] == \"O\") or \\\n           (board[2][0] == \"O\" and board[1][1] == \"O\" and board[0][2] == \"O\")\n\n    if Owin and Xwin:\n        return False\n    if (Xwin and countX == countO) or (Owin and countX - countO == 1):\n        return False\n    return True", "input_generator": "import random\n\ndef input_generator():\n    choices = ['X', 'O', ' ']\n    board = []\n    for _ in range(3):\n        row = ''.join(random.choices(choices, k=3))\n        board.append(row)\n    return {'board': board}", "io_pairs": [{"input": {"board": ["OXX", "XO ", "OX "]}, "output": true}, {"input": {"board": ["XOO", " O ", "XO "]}, "output": false}, {"input": {"board": ["OOX", "XO ", "XXO"]}, "output": true}, {"input": {"board": ["XX ", " OO", "XO "]}, "output": true}, {"input": {"board": [" O ", "XOO", "O O"]}, "output": false}, {"input": {"board": [" OX", "O  ", " OO"]}, "output": false}, {"input": {"board": ["  O", "O  ", "X X"]}, "output": true}, {"input": {"board": ["OO ", "XXO", "XO "]}, "output": false}, {"input": {"board": ["XXX", "  O", "OX "]}, "output": false}, {"input": {"board": ["X O", "XOO", " XX"]}, "output": true}], "error_log": []}
{"context": "In a game of poker, how can we determine the winner among a group of players and a dealer, given that each player and the dealer are dealt 5 cards from a shuffled deck? The winner is determined by the highest hand value, where the hand value is calculated based on the sum of the card values, with special rules for aces. If the dealer's hand value exceeds 21, any player with a hand value less than or equal to 21 wins. Otherwise, the player with the highest hand value wins. Who will be the winner among the players and the dealer?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number_of_players` (int): The number of players in the game. Must be a positive integer.\n\nOutput:\n  `return` (str): The name of the player or dealer who wins the game.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nranks = [i for i in range(2, 11)] + ['JACK', 'QUEEN', 'KING', 'ACE']\nsuits = ['SPADE', 'HEART', 'DIAMOND', 'CLUB']\n\ndef get_deck():\n    return [[rank, suit] for rank in ranks for suit in suits]\n\ndef card_value(card):\n    rank = card[0]\n    if rank in ranks[:-4]:\n        return int(rank)\n    elif rank == 'ACE':\n        return 11\n    else:\n        return 10\n\ndef hand_value(hand):\n    tmp_value = sum(card_value(card) for card in hand)\n    num_aces = len([card for card in hand if card[0] == 'ACE'])\n    \n    while num_aces > 0:\n        if tmp_value > 21 and 'ACE' in [card[0] for card in hand]:\n            tmp_value -= 10\n            num_aces -= 1\n        else:\n            break\n    \n    if tmp_value <= 21:\n        return [str(tmp_value), tmp_value]\n    elif tmp_value == 21:\n        return ['Blackjack!', 21]\n    else:\n        return ['Bust!', 100]\n\n# main function\ndef main_solution(number_of_players):\n    # Convert input to integer\n    number_of_players = int(number_of_players)\n    \n    # Initialize players and dealer\n    players = []\n    for i in range(number_of_players):\n        players.append({'name': f'Player {i+1}', 'hand': []})\n    dealer = {'name': 'Dealer', 'hand': []}\n    \n    # Get and shuffle the deck\n    deck = get_deck()\n    random.shuffle(deck)\n    \n    # Deal 5 cards to each player and the dealer\n    for _ in range(5):\n        for player in players:\n            player['hand'].append(deck.pop())\n        dealer['hand'].append(deck.pop())\n    \n    # Determine the winner\n    player_scores = [(player['name'], hand_value(player['hand'])[1]) for player in players]\n    dealer_score = hand_value(dealer['hand'])[1]\n    \n    # Find the highest score among players\n    max_player_score = max(score for _, score in player_scores)\n    \n    # Compare dealer's score with the highest player score\n    if dealer_score > 21 or any(score > dealer_score for _, score in player_scores):\n        winner = max(player_scores, key=lambda x: x[1])[0]\n    else:\n        winner = dealer['name']\n    \n    # Return the winner's name\n    return winner", "input_generator": "import random\n\ndef input_generator():\n    return {'number_of_players': random.randint(1, 10)}", "io_pairs": [{"input": {"number_of_players": 6}, "output": "Player 1"}, {"input": {"number_of_players": 2}, "output": "Player 1"}, {"input": {"number_of_players": 8}, "output": "Player 1"}, {"input": {"number_of_players": 9}, "output": "Player 1"}, {"input": {"number_of_players": 7}, "output": "Player 1"}, {"input": {"number_of_players": 3}, "output": "Player 1"}, {"input": {"number_of_players": 4}, "output": "Player 1"}, {"input": {"number_of_players": 5}, "output": "Player 1"}, {"input": {"number_of_players": 1}, "output": "Player 1"}], "error_log": []}
{"context": "Given a list of stones' positions in ascending order, determine if a frog can cross a river by landing on the last stone. The frog starts on the first stone and can jump either k - 1, k, or k + 1 units forward, where k is the length of its last jump. The first jump must be 1 unit. Can the frog successfully cross the river?\n\nThe input and output requirements are as follows:\n\nInput:\n  `stones` (List[int]): A list of integers representing the positions of stones in ascending order. The first stone's position is always 0.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the frog can cross the river by landing on the last stone.", "reference_code": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        dp = {} # dp[pos] contains a set of last jump size\n        for pos in stones:\n            dp[pos] = set()\n        dp[0].add(0)\n        \n        for pos in stones:\n            for k in dp[pos]:\n                for nxt in range(pos+k-1, pos+k+2):\n                    if nxt > pos and nxt in dp:\n                        dp[nxt].add(nxt - pos)\n        \n        return len(dp[stones[-1]]) > 0\n\n# main function\ndef main_solution(stones: List[int]) -> bool:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    obj = Solution()\n    result = obj.canCross(stones)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random number of stones between 2 and 20\n    num_stones = random.randint(2, 20)\n    \n    # Start with 0\n    stones = [0]\n    \n    # Generate subsequent stones with increasing values and random gaps\n    for _ in range(1, num_stones):\n        # Ensure the next stone is at least 1 unit away from the previous\n        next_stone = stones[-1] + random.randint(1, 5)\n        stones.append(next_stone)\n    \n    return {'stones': stones}", "io_pairs": [{"input": {"stones": [0, 4, 8, 11, 14, 19]}, "output": false}, {"input": {"stones": [0, 2, 3, 7, 11, 16, 19, 21, 26]}, "output": false}, {"input": {"stones": [0, 1, 4, 5, 9]}, "output": false}, {"input": {"stones": [0, 1, 4, 8, 13, 18, 21, 23, 27, 28, 33, 38, 41, 45, 46]}, "output": false}, {"input": {"stones": [0, 3, 6]}, "output": false}, {"input": {"stones": [0, 2, 4, 8, 9, 10, 14]}, "output": false}, {"input": {"stones": [0, 4, 7, 9, 14]}, "output": false}, {"input": {"stones": [0, 3, 5, 9, 12, 15, 19]}, "output": false}, {"input": {"stones": [0, 4, 8, 12, 14, 18, 23, 25, 29, 32, 35]}, "output": false}, {"input": {"stones": [0, 5, 10, 14, 17, 21, 25, 28]}, "output": false}], "error_log": []}
{"context": "Given a deck of cards and a series of shuffle operations, what is the final order of the deck after performing all the specified shuffle operations?\n\nThe input and output requirements are as follows:\n\nInput:\n- `deck_size` (int): The size of the deck, which is an integer greater than 0.\n- `shuffle_operations` (list of str): A list of strings where each string represents a shuffle operation. Each operation is one of the following formats:\n  - \"cut X\" where X is an integer representing the position to cut the deck.\n  - \"deal with increment X\" where X is an integer representing the increment for dealing.\n  - \"deal into new stack\" which reverses the deck.\n\nOutput:\n- `return` (list of int): The final order of the deck after performing all shuffle operations, represented as a list of integers.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef deal_into_new_stack(deck):\n    return deck[::-1]\n\ndef cut(deck, pos):\n    if pos == 0:\n        return deck\n    return deck[pos:] + deck[:pos]\n\ndef deal_with_increment(deck, n):\n    result = [0] * len(deck)\n    for i in range(len(deck)):\n        result[(i * n) % len(deck)] = deck[i]\n    return result\n\ndef make_deck(n):\n    deck = [0] * n\n    for i in range(n):\n        deck[i] = i\n    return deck\n\ndef do_line(deck, line):\n    if line[:3] == 'cut':\n        return cut(deck, int(line[4:]))\n    if line[:19] == 'deal with increment':\n        return deal_with_increment(deck, int(line[20:]))\n    if line[:19] == 'deal into new stack':\n        return deal_into_new_stack(deck)\n    assert False\n\ndef do_lines(deck, lines):\n    for line in lines:\n        deck = do_line(deck, line)\n    return deck\n\n# main function\ndef main_solution(deck_size, shuffle_operations):\n    \"\"\"\n    Shuffles a deck of cards based on a series of shuffle operations.\n\n    Args:\n        deck_size (int): The size of the deck.\n        shuffle_operations (list of str): A list of shuffle operations to perform on the deck.\n\n    Returns:\n        list of int: The final order of the deck after performing all shuffle operations.\n    \"\"\"\n    deck = make_deck(deck_size)\n    for operation in shuffle_operations:\n        deck = do_line(deck, operation)\n    return deck", "input_generator": "import random\n\ndef input_generator():\n    deck_size = random.choice([10, 20, 30, 40, 50, 100])\n    operations = []\n    num_operations = random.randint(1, 5)\n    for _ in range(num_operations):\n        op_type = random.randint(0, 2)\n        if op_type == 0:\n            operations.append(\"deal into new stack\")\n        elif op_type == 1:\n            cut_pos = random.randint(-deck_size + 1, deck_size - 1)\n            operations.append(f\"cut {cut_pos}\")\n        else:\n            increment = random.randint(2, deck_size - 1)\n            operations.append(f\"deal with increment {increment}\")\n    return {\n        \"deck_size\": deck_size,\n        \"shuffle_operations\": operations\n    }", "io_pairs": [{"input": {"deck_size": 10, "shuffle_operations": ["deal into new stack", "deal with increment 2", "deal with increment 2", "deal into new stack", "deal into new stack"]}, "output": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"input": {"deck_size": 10, "shuffle_operations": ["deal with increment 3", "deal with increment 2"]}, "output": [5, 0, 2, 0, 9, 0, 6, 0, 3, 0]}, {"input": {"deck_size": 10, "shuffle_operations": ["deal with increment 3", "deal into new stack", "cut 8", "cut 4", "cut 1"]}, "output": [2, 5, 8, 1, 4, 7, 0, 3, 6, 9]}, {"input": {"deck_size": 10, "shuffle_operations": ["deal with increment 8", "deal into new stack"]}, "output": [0, 6, 0, 7, 0, 8, 0, 9, 0, 5]}, {"input": {"deck_size": 10, "shuffle_operations": ["deal with increment 3", "deal with increment 6"]}, "output": [5, 0, 9, 0, 3, 0, 2, 0, 6, 0]}, {"input": {"deck_size": 10, "shuffle_operations": ["deal with increment 6", "cut 1", "deal into new stack", "deal with increment 8", "deal with increment 4"]}, "output": [0, 0, 9, 0, 0, 0, 0, 0, 0, 0]}, {"input": {"deck_size": 10, "shuffle_operations": ["deal into new stack", "deal with increment 9"]}, "output": [9, 0, 1, 2, 3, 4, 5, 6, 7, 8]}, {"input": {"deck_size": 10, "shuffle_operations": ["cut 4", "cut 1", "cut 7", "cut -7"]}, "output": [5, 6, 7, 8, 9, 0, 1, 2, 3, 4]}, {"input": {"deck_size": 10, "shuffle_operations": ["deal into new stack", "deal with increment 4", "deal into new stack", "cut -5"]}, "output": [3, 0, 1, 0, 4, 0, 2, 0, 0, 0]}, {"input": {"deck_size": 10, "shuffle_operations": ["deal with increment 9", "deal into new stack", "cut -2", "deal with increment 9"]}, "output": [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]}], "error_log": []}
{"context": "Given a mathematical function and an initial guess for its roots, how can we determine the roots of the function using Newton's method within specified error margins?\n\nThe input and output requirements are as follows:\n\nInput:\n  `function_str` (str): A string representation of the mathematical function for which roots are to be found. The function should be in a format that can be evaluated using Python's `eval` function.\n  `initial_x` (float): The initial guess for the root finding process.\n  `error_margin_x` (float): The acceptable error margin in the x-axis for considering two roots as the same.\n  `error_margin_y` (float): The acceptable error margin in the y-axis for considering a point as a root.\n  `seed` (int): The seed for the random number generator used to initialize the search for roots.\n\nOutput:\n  `return` (list of floats): A list of roots found by Newton's method, where each root is a float.", "reference_code": "# import necessary packages\nimport random as r\n\n# all class and function definitions in the code file, if any\ndef grad_function(f, x, delta_x=0.001):\n    g = (f(x + delta_x) - f(x)) / delta_x\n    return g\n\ndef newtons_method(f, x, error_margin_y=0.001, iteration_cap=1000, delta_x=0.001, return_lists=True):\n    if return_lists:\n        y = f(x)\n        x_list = [x]\n        y_list = [y]\n\n        i = 0\n        while abs(y) > error_margin_y and i < iteration_cap:\n            g = grad_function(f, x, delta_x=delta_x)\n            x = x - y / g\n            y = f(x)\n\n            x_list.append(x)\n            y_list.append(y)\n            i += 1\n        if i >= iteration_cap:\n            raise RuntimeError('Did not find a root')\n        return x_list, y_list\n    else:\n        y = f(x)\n\n        i = 0\n        while abs(y) > error_margin_y and i < iteration_cap:\n            g = grad_function(f, x, delta_x=delta_x)\n            x = x - y / g\n            y = f(x)\n\n            i += 1\n        if i >= iteration_cap:\n            raise RuntimeError('Did not find a root')\n        return x\n\ndef find_roots_newton(f, iter_for_new_roots=10, error_margin_x=0.001, error_margin_y=0.001, seed=None):\n    roots = []\n    rndgen = r.Random()\n    rndgen.seed(seed)\n    searching = True\n    iter_since_last_root = 0\n\n    while searching:\n        x = rndgen.gauss(0, 5)\n        try:\n            root = newtons_method(f, x, return_lists=False, error_margin_y=error_margin_y)\n        except RuntimeError:\n            iter_since_last_root += 1\n            continue\n        if not x_in_list(root, roots, error_margin_x=error_margin_x):\n            roots.append(root)\n            iter_since_last_root = 0\n        else:\n            iter_since_last_root += 1\n\n        if iter_since_last_root > iter_for_new_roots:\n            searching = False\n\n    return roots\n\ndef x_in_list(x, roots_list, error_margin_x=0.001):\n    for root in roots_list:\n        if abs(x - root) < error_margin_x:\n            return True\n    return False\n\n# main function\ndef main_solution(function_str, initial_x, error_margin_x, error_margin_y, seed):\n    # Convert the function string to a callable function\n    def f(x):\n        return eval(function_str)\n    \n    # Find roots using Newton's method\n    roots = find_roots_newton(f, error_margin_x=error_margin_x, error_margin_y=error_margin_y, seed=seed)\n    \n    # Return the roots as a list of floats\n    return roots", "input_generator": "import random as r\nimport math\n\ndef input_generator():\n    # List of possible function strings\n    function_strings = [\n        \"x**2 - 4\",\n        \"math.sin(x)\",\n        \"math.cos(x)\",\n        \"x**3 - 2*x + 2\",\n        \"math.exp(x) - 2\",\n        \"math.log(abs(x) + 1) - 1\",\n        \"x**4 - 3*x**2 + 2\"\n    ]\n    \n    # Randomly select a function string\n    function_str = r.choice(function_strings)\n    \n    # Generate initial_x as a random float between -10 and 10\n    initial_x = r.uniform(-10, 10)\n    \n    # Generate error margins as small positive floats\n    error_margin_x = 10 ** r.uniform(-5, -2)\n    error_margin_y = 10 ** r.uniform(-5, -2)\n    \n    # Generate seed as either None or a random integer\n    seed = r.choice([None, r.randint(0, 1000)])\n    \n    return {\n        \"function_str\": function_str,\n        \"initial_x\": initial_x,\n        \"error_margin_x\": error_margin_x,\n        \"error_margin_y\": error_margin_y,\n        \"seed\": seed\n    }", "io_pairs": [{"input": {"function_str": "x**4 - 3*x**2 + 2", "initial_x": 1.5262138695018983, "error_margin_x": 0.008481347801030529, "error_margin_y": 0.00044839584941746245, "seed": null}, "output": [-1.414212766946326, 1.4142163225043778, -0.9999042907826478]}, {"input": {"function_str": "math.sin(x)", "initial_x": -3.277366665997585, "error_margin_x": 0.006269299627734445, "error_margin_y": 1.2205291357604991e-05, "seed": 804}, "output": [-6.283185321904516, -2.9924905700119686e-09, 9.42477789526938, -3.141592654369762, 3.141592653553429, -28.274333883595663, -2934.2475384529102, -9.424777960979647, -37.69911845741121, -106.81415471008384, 6.283185307142986, -12.566372193085417, 12.566370614311696]}, {"input": {"function_str": "x**3 - 2*x + 2", "initial_x": -2.434042785275345, "error_margin_x": 0.00010936925206035537, "error_margin_y": 7.723237803691158e-05, "seed": 525}, "output": [-1.7692923458644092]}, {"input": {"function_str": "math.cos(x)", "initial_x": -7.886607379151895, "error_margin_x": 4.996609800268032e-05, "error_margin_y": 5.886739628376666e-05, "seed": 678}, "output": [7.853978376185439, 14.137166925731293, -4.712388980493157, 1.570796173842036, -7.853981633959136, -1.5708339736252528, 10.995574286762093, -23.561944572640005, 4.71238898032205, -14.137155763495375]}, {"input": {"function_str": "math.cos(x)", "initial_x": 6.512020307437311, "error_margin_x": 0.0018109703016456484, "error_margin_y": 0.00044538777391479986, "seed": 280}, "output": [-1.5707967166228485, 7.853981632698008, 4.7123879166203135, -4.712354902599085, 108.38483324299693, -7.853981635345552, 1.5707964490348016]}, {"input": {"function_str": "math.cos(x)", "initial_x": -8.165067218676754, "error_margin_x": 0.0006172569314066283, "error_margin_y": 1.000183520747816e-05, "seed": null}, "output": [-4.712388980388735, -1.5707963268170093, 1.5707963268070064, 10.995574287146399, 4.712388980281854, -10.995574287591802, -7.853981633971241, -36.128315516303054, 7.8539816318019975]}, {"input": {"function_str": "math.cos(x)", "initial_x": 2.734637812405685, "error_margin_x": 0.0011410642375324872, "error_margin_y": 0.0016289687169560813, "seed": null}, "output": [14.13716695754892, 1.5709156954945995, 4.7123889832029775, -1.5707953367911947, -4.713475711703148, -871.7907461648791, -1.5694122210148422, 7.853814956329103, 10.996922659689517, 17.278740655431566, -4.711982815913199]}, {"input": {"function_str": "x**2 - 4", "initial_x": 1.6363940653877087, "error_margin_x": 0.0031405220438381035, "error_margin_y": 0.0049590097429801664, "seed": 330}, "output": [2.0001888960200582, -2.0000007006682923]}, {"input": {"function_str": "x**4 - 3*x**2 + 2", "initial_x": 4.284406700834555, "error_margin_x": 0.00016831653529004645, "error_margin_y": 0.00171739641235694, "seed": 254}, "output": [-1.4142909688488319, 1.414348236957689, -1.4145914192854776, 1.4146276469751442]}, {"input": {"function_str": "x**4 - 3*x**2 + 2", "initial_x": -8.038040064554917, "error_margin_x": 4.2473678500838194e-05, "error_margin_y": 1.0126728492313015e-05, "seed": 259}, "output": [1.4142146621249752, -1.4142133596734456, -0.9999995261698931, 1.0000000812734378]}], "error_log": []}
{"context": "Given a string, how can we generate all unique permutations of its characters?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string for which all unique permutations need to be generated.\n\nOutput:\n  `return` (list of str): A list of all unique permutations of the input string.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef insertCharAt(word, char, i):\n    return word[0:i] + char + word[i:len(word)]\n\ndef getPerms(hash, prefix, remaining, result):\n    if remaining == 0:\n        result.append(prefix)\n        return\n\n    for c in hash:\n        count = hash[c]\n        if count > 0:\n            hash[c] = count - 1\n            getPerms(hash, prefix + c, remaining - 1, result)\n            hash[c] = count\n\ndef buildFreqTable(string):\n    map = {}\n    for c in string:\n        if c not in map:\n            map[c] = 1\n        else:\n            map[c] += 1\n    return map\n\n# main function\ndef main_solution(input_string):\n    # input_string is a string\n    result = []\n    hash = buildFreqTable(input_string)\n    getPerms(hash, \"\", len(input_string), result)\n    # Convert the result to a JSON serializable format\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 8)\n    chars = random.choices(string.ascii_lowercase, k=length)\n    input_string = ''.join(chars)\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "d"}, "output": ["d"]}, {"input": {"input_string": "z"}, "output": ["z"]}, {"input": {"input_string": "l"}, "output": ["l"]}, {"input": {"input_string": "kqg"}, "output": ["kqg", "kgq", "qkg", "qgk", "gkq", "gqk"]}, {"input": {"input_string": "fv"}, "output": ["fv", "vf"]}, {"input": {"input_string": "x"}, "output": ["x"]}, {"input": {"input_string": "hk"}, "output": ["hk", "kh"]}, {"input": {"input_string": "h"}, "output": ["h"]}, {"input": {"input_string": "mh"}, "output": ["mh", "hm"]}, {"input": {"input_string": "fr"}, "output": ["fr", "rf"]}], "error_log": []}
{"context": "Given a polygon defined by a set of vertices, what is the area of the polygon? The vertices are provided as a list of coordinates, where each coordinate is a pair of integers representing the x and y coordinates of the vertex.\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of vertices in the polygon.\n  `shape` (list of list of int): A list of vertices, where each vertex is represented as a list of two integers [x, y].\n\nOutput:\n  `return` (float): The area of the polygon.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(n, shape):\n    \"\"\"\n    Calculate the area of a polygon defined by a list of vertices.\n\n    Parameters:\n    n (int): The number of vertices in the polygon.\n    shape (list of list of int): A list of vertices, where each vertex is represented as a list of two integers [x, y].\n\n    Returns:\n    float: The area of the polygon.\n    \"\"\"\n    otvet = 0\n\n    def area(x, y):\n        nonlocal otvet\n        len1 = (shape[x][0]**2 + shape[x][1]**2)**0.5\n        len2 = (shape[y][0]**2 + shape[y][1]**2)**0.5\n        len3 = ((shape[x][0] - shape[y][0])**2 + (shape[x][1] - shape[y][1])**2)**0.5\n        cos_val = (len1**2 + len2**2 - len3**2) / (2 * len1 * len2)\n        sin_val = (1 - cos_val**2)**0.5\n        _area_ = 0.5 * len1 * len2 * sin_val\n        otvet += _area_\n\n    for i in range(n - 1):\n        area(i, i + 1)\n    area(n - 1, 0)\n\n    return otvet", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(3, 10)  # Generate a polygon with 3 to 10 vertices\n    shape = []\n    for _ in range(n):\n        x = random.randint(-100, 100)\n        y = random.randint(-100, 100)\n        shape.append([x, y])\n    return {'n': n, 'shape': shape}", "io_pairs": [{"input": {"n": 3, "shape": [[-65, 100], [-61, -69], [69, 85]]}, "output": 11717.000000000025}, {"input": {"n": 3, "shape": [[-70, -8], [-81, 55], [-64, 43]]}, "output": 4028.4999999999745}, {"input": {"n": 4, "shape": [[-50, -9], [-60, -60], [-56, -81], [-100, 47]]}, "output": 8971.0}, {"input": {"n": 4, "shape": [[-80, 33], [-84, -78], [56, -42], [87, -50]]}, "output": 9445.5}, {"input": {"n": 4, "shape": [[-21, 27], [-22, 6], [-94, 44], [-87, 68]]}, "output": 2178.5}, {"input": {"n": 4, "shape": [[48, 100], [26, 91], [-81, 34], [-85, 26]]}, "output": 10277.5}, {"input": {"n": 3, "shape": [[52, 51], [-1, 18], [-71, -39]]}, "output": 1948.4999999999995}, {"input": {"n": 4, "shape": [[-100, -33], [-10, -80], [-40, 31], [47, 52]]}, "output": 9183.0}, {"input": {"n": 4, "shape": [[60, 81], [2, -44], [24, 55], [5, -85]]}, "output": 5893.999999999998}, {"input": {"n": 4, "shape": [[-1, -94], [-27, -79], [-1, 97], [-54, 58]]}, "output": 7735.499999999997}], "error_log": []}
{"context": "In the context of Conway's Game of Life, given a grid of cells with a certain percentage chance of being alive initially, how would the positions of the alive cells change after a specified number of simulation steps? Specifically, what are the coordinates of the cells that remain alive after the simulation?\n\nThe input and output requirements are as follows:\n\nInput:\n- `rows` (int): Number of rows in the board.\n- `columns` (int): Number of columns in the board.\n- `randomChance` (int): Percentage chance for a cell to be alive initially (0-100).\n- `steps` (int): Number of steps to simulate.\n\nOutput:\n- `return` (list): List of lists where each sublist contains the coordinates of alive cells after the simulation. Each sublist is of the form `[x, y]` where `x` is the column index and `y` is the row index.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Cell():\n    isPointed = False\n    isAlive = False\n    neighbours = []\n    isAliveNext = False\n\n    def DetermineNextState(self):\n        \"\"\" Determines if in the next frame of the simulation\n            The cell will be alive or not. The rules are:\n            Alive cells with more than 3 neighbours die\n            Alive cells with less than 2 neighbours die\n            Dead cells with 3 neighbours become alive \"\"\"\n        \n        aliveNeighbours = sum(neighbour.isAlive for neighbour in self.neighbours)\n\n        if self.isAlive:\n            self.isAliveNext = aliveNeighbours == 2 or aliveNeighbours == 3\n        else:\n            self.isAliveNext = aliveNeighbours == 3\n\n    def Advance(self):\n        self.isAlive = self.isAliveNext\n\nclass Board():\n    rows = 0\n    columns = 0\n    cells = []\n\n    def __init__(self, rows, columns):\n        self.rows = rows\n        self.columns = columns\n        self.cells = [[Cell() for _ in range(rows)] for _ in range(columns)]\n        self.ConnectCells()\n    \n    def RandomizeCells(self, randomChance):\n        for x in range(self.columns):\n            for y in range(self.rows):\n                self.cells[x][y].isAlive = random.randint(0, 100) < randomChance\n                \n    def ConnectCells(self):\n        for x in range(self.columns):\n            for y in range(self.rows):\n                xL = x - 1 if x > 0 else self.columns - 1\n                xR = x + 1 if x < self.columns - 1 else 0\n                yT = y - 1 if y > 0 else self.rows - 1\n                yB = y + 1 if y < self.rows - 1 else 0\n                self.cells[x][y].neighbours = [\n                    self.cells[xL][y], self.cells[xR][y],\n                    self.cells[x][yT], self.cells[x][yB],\n                    self.cells[xL][yT], self.cells[xR][yT],\n                    self.cells[xR][yB], self.cells[xL][yB]\n                ]\n    \n    def Advance(self):\n        for x in range(self.columns):\n            for y in range(self.rows):\n                self.cells[x][y].DetermineNextState()\n\n        for x in range(self.columns):\n            for y in range(self.rows):\n                self.cells[x][y].Advance()\n\n    def GetAliveCells(self):\n        return [[x, y] for x in range(self.columns) for y in range(self.rows) if self.cells[x][y].isAlive]\n\n# main function\ndef main_solution(rows, columns, randomChance, steps):\n    \"\"\"\n    Simulates the Conway's Game of Life for a given number of steps and returns the positions of alive cells after the simulation.\n\n    Parameters:\n    rows (int): Number of rows in the board.\n    columns (int): Number of columns in the board.\n    randomChance (int): Percentage chance for a cell to be alive initially.\n    steps (int): Number of steps to simulate.\n\n    Returns:\n    list: List of lists where each sublist contains the coordinates of alive cells after the simulation.\n    \"\"\"\n    board = Board(rows, columns)\n    board.RandomizeCells(randomChance)\n    \n    for _ in range(steps):\n        board.Advance()\n    \n    return board.GetAliveCells()", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(5, 20)\n    columns = random.randint(5, 20)\n    randomChance = random.randint(10, 50)\n    steps = random.randint(1, 10)\n    return {\n        'rows': rows,\n        'columns': columns,\n        'randomChance': randomChance,\n        'steps': steps\n    }", "io_pairs": [{"input": {"rows": 9, "columns": 20, "randomChance": 11, "steps": 6}, "output": [[10, 7], [11, 7], [12, 6], [17, 0], [17, 1], [18, 0], [18, 1]]}, {"input": {"rows": 16, "columns": 14, "randomChance": 14, "steps": 7}, "output": [[0, 0], [12, 0], [13, 0]]}, {"input": {"rows": 5, "columns": 10, "randomChance": 16, "steps": 1}, "output": [[2, 0], [2, 1], [2, 3], [3, 0], [3, 2], [3, 3], [3, 4], [4, 0], [4, 4]]}, {"input": {"rows": 10, "columns": 13, "randomChance": 13, "steps": 7}, "output": []}, {"input": {"rows": 10, "columns": 5, "randomChance": 40, "steps": 10}, "output": []}, {"input": {"rows": 17, "columns": 8, "randomChance": 12, "steps": 6}, "output": []}, {"input": {"rows": 6, "columns": 6, "randomChance": 21, "steps": 2}, "output": [[2, 2], [3, 1], [3, 2], [3, 3], [4, 3]]}, {"input": {"rows": 17, "columns": 6, "randomChance": 12, "steps": 8}, "output": [[3, 9], [3, 10]]}, {"input": {"rows": 5, "columns": 12, "randomChance": 12, "steps": 10}, "output": []}, {"input": {"rows": 14, "columns": 20, "randomChance": 10, "steps": 1}, "output": [[0, 10], [1, 8], [1, 9], [1, 10], [2, 8], [2, 9], [3, 9], [4, 9]]}], "error_log": []}
{"context": "Given two integers `a` and `mod`, what is the modular inverse of `a` under the modulus `mod`? The modular inverse exists only when `a` and `mod` are coprime.\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): The integer for which the modular inverse is to be found.\n  `mod` (int): The modulus under which the inverse is to be computed.\n\nOutput:\n  `return` (int): The modular inverse of `a` under modulus `mod`, such that `(a * return) % mod = 1`.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef extended_euclidian(a, b):\n    if a % b == 0:\n        return 0, 1\n    y, x = extended_euclidian(b, a % b)\n    y = y - x * int(a / b)\n    return x, y\n\ndef inverse(a, mod):\n    x, _ = extended_euclidian(a, mod)\n    if x < 0:\n        x += mod\n    return x\n\n# main function\ndef main_solution(a, mod):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = inverse(a, mod)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "input_generator": "import random\n\ndef input_generator():\n    mod = random.choice([10, 17, 23, 31, 47, 53, 101, 257, 1009])\n    a = random.randint(1, mod - 1)\n    while True:\n        if a < mod and (a % mod != 0):\n            break\n        a = random.randint(1, mod - 1)\n    return {'a': a, 'mod': mod}", "io_pairs": [{"input": {"a": 493, "mod": 1009}, "output": 307}, {"input": {"a": 19, "mod": 23}, "output": 17}, {"input": {"a": 846, "mod": 1009}, "output": 879}, {"input": {"a": 60, "mod": 101}, "output": 32}, {"input": {"a": 28, "mod": 53}, "output": 36}, {"input": {"a": 24, "mod": 47}, "output": 2}, {"input": {"a": 4, "mod": 31}, "output": 8}, {"input": {"a": 20, "mod": 257}, "output": 90}, {"input": {"a": 57, "mod": 101}, "output": 39}, {"input": {"a": 242, "mod": 257}, "output": 137}], "error_log": []}
{"context": "Given a graph with `n` nodes and a set of `colors`, determine if it is possible to color each node such that no two adjacent nodes share the same color. If a valid coloring exists, what is the color assignment for each node?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of nodes in the graph.\n  `graph` (list of lists): A 2D list representing the adjacency matrix of the graph. Each inner list corresponds to the neighbors of a node.\n  `colors` (list of int): A list of integers representing the possible colors that can be assigned to the nodes.\n\nOutput:\n  `return` (list of int): A list representing the color assignment for each node. Each element in the list corresponds to the color assigned to the node at that index. If no valid assignment is found, the function returns `False`.", "reference_code": "# import necessary packages\nimport copy\n\n# all class and function definitions in the code file, if any\ndef consistentAssignment(assignment, graph, var):\n    neighbours = graph[var]\n    for neighbour in neighbours:\n        if assignment[neighbour] != -1 and assignment[neighbour] == assignment[var]:\n            return False\n    return True\n\ndef completeAssignment(assignment):\n    for i in assignment:\n        if i == -1:\n            return False\n    return True\n\ndef forwardChecking(assignment, domain, graph, var):\n    neighbours = graph[var]\n    value = assignment[var]\n    for n in neighbours:\n        if assignment[n] == -1:\n            if value in domain[n]:\n                domain[n].remove(value)\n                if len(domain[n]) == 0:\n                    return False\n    return domain\n\ndef backtrackingWFwdChkUtility(graph, assignment, domain, var):\n    if completeAssignment(assignment):\n        return assignment\n    for i in range(len(domain[var])):\n        assignment[var] = domain[var][i]\n        oldDomain = domain\n        if consistentAssignment(assignment, graph, var):\n            oldDomain = copy.deepcopy(domain)\n            domain = forwardChecking(assignment, domain, graph, var)\n            if domain != False:\n                result = backtrackingWFwdChkUtility(graph, assignment, domain, var + 1)\n                if result != False:\n                    return result\n        assignment[var] = -1\n        domain = oldDomain\n    return False\n\n# main function\ndef main_solution(n, graph, colors):\n    # Convert input variables to JSON serializable if necessary\n    assignment = []\n    domain = []\n    for i in range(n):\n        assignment.append(-1)\n        domain.append(copy.deepcopy(colors))\n    # Call the core function\n    result = backtrackingWFwdChkUtility(graph, assignment, domain, 0)\n    # Convert output to JSON serializable\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(3, 10)  # Reasonable number of nodes\n    graph = []\n    for i in range(n):\n        neighbours = random.sample(range(n), random.randint(1, min(3, n-1)))\n        # Ensure no self-loops and no duplicates\n        neighbours = [x for x in neighbours if x != i]\n        neighbours = list(set(neighbours))\n        graph.append(neighbours)\n    colors = random.sample(['Red', 'Green', 'Blue', 'Yellow', 'Black'], random.randint(2, 4))\n    return {'n': n, 'graph': graph, 'colors': colors}", "io_pairs": [{"input": {"n": 3, "graph": [[2], [0], []], "colors": ["Red", "Yellow"]}, "output": ["Red", "Yellow", "Yellow"]}, {"input": {"n": 3, "graph": [[], [0], [0]], "colors": ["Blue", "Red", "Black"]}, "output": ["Blue", "Red", "Red"]}, {"input": {"n": 3, "graph": [[], [0, 2], [1]], "colors": ["Yellow", "Green"]}, "output": ["Yellow", "Green", "Yellow"]}, {"input": {"n": 3, "graph": [[2], [], [0, 1]], "colors": ["Blue", "Green"]}, "output": ["Blue", "Blue", "Green"]}, {"input": {"n": 3, "graph": [[1], [0], []], "colors": ["Black", "Blue", "Green"]}, "output": ["Black", "Blue", "Black"]}, {"input": {"n": 3, "graph": [[2], [2], []], "colors": ["Blue", "Green"]}, "output": ["Blue", "Blue", "Green"]}, {"input": {"n": 3, "graph": [[1], [2], [1]], "colors": ["Yellow", "Black"]}, "output": ["Yellow", "Black", "Yellow"]}, {"input": {"n": 3, "graph": [[1], [0], [0]], "colors": ["Red", "Yellow"]}, "output": ["Red", "Yellow", "Yellow"]}, {"input": {"n": 3, "graph": [[1], [], [0]], "colors": ["Green", "Yellow", "Red"]}, "output": ["Green", "Yellow", "Yellow"]}, {"input": {"n": 3, "graph": [[1], [0], [0, 1]], "colors": ["Green", "Blue"]}, "output": false}], "error_log": []}
{"context": "Given a function \\( f(x) = 2x + \\frac{6}{x} \\), we want to find the minimum value of this function within a specified interval \\([xl, xu]\\) with a certain error tolerance \\(ea\\). What is the x-value at which the function reaches its minimum within the given interval and error tolerance?\n\nThe input and output requirements are as follows:\n\nInput:\n  `xl` (float): The lower bound of the interval in which to search for the minimum.\n  `xu` (float): The upper bound of the interval in which to search for the minimum.\n  `ea` (float): The acceptable error tolerance for the search.\n\nOutput:\n  `return` (float): The x-value at which the function reaches its minimum within the given interval and error tolerance.", "reference_code": "# import necessary packages\nimport math\n\n# golden section constant\nphi = (math.sqrt(5) - 1) / 2\n\ndef function(x):\n    return 2*x + (6/x)\n\ndef absError(xl, xu, ea):\n    numIter = 1\n    while True:\n        err = (xu - xl) / (1.618**numIter)\n        if err < ea:\n            break\n        else:\n            numIter += 1\n    return numIter\n\ndef goldenSectionMin(xl, xu, itter, itMax):\n    if itter < itMax:\n        x1 = xu - ((xu - xl) * phi)\n        x2 = xl + ((xu - xl) * phi)\n        if function(x1) > function(x2):\n            return goldenSectionMin(x1, xu, itter + 1, itMax)\n        else:\n            return goldenSectionMin(x2, xl, itter + 1, itMax)\n    return xl\n\n# main function\ndef main_solution(xl, xu, ea):\n    # Convert JSON serializable inputs to original input variables\n    maxIter = absError(xl, xu, ea)\n    # Find the minimum using the golden section method\n    result = goldenSectionMin(xl, xu, 0, maxIter)\n    # Convert the result to a JSON serializable output\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    xl = random.uniform(0.1, 5.0)  # Avoid x=0 due to division in function(x)\n    xu = random.uniform(xl + 0.5, 10.0)  # Ensure xu > xl\n    ea = random.uniform(0.001, 0.1)  # Reasonable error tolerance\n    return {'xl': xl, 'xu': xu, 'ea': ea}", "io_pairs": [{"input": {"xl": 2.798681358487318, "xu": 3.5746475873504977, "ea": 0.040115109186980615}, "output": 2.825407073855702}, {"input": {"xl": 3.8191462543111068, "xu": 5.8146287280902795, "ea": 0.039942624340864465}, "output": 3.845398058456965}, {"input": {"xl": 2.2993262145549713, "xu": 5.3211225694275655, "ea": 0.02312953582535742}, "output": 2.3145107374326814}, {"input": {"xl": 4.864186183341496, "xu": 8.682797309124565, "ea": 0.015155225442628376}, "output": 4.876045338483771}, {"input": {"xl": 3.563587409751322, "xu": 7.397145492149892, "ea": 0.07062070683573529}, "output": 3.6140202335336853}, {"input": {"xl": 1.958946203250896, "xu": 3.1185539464627934, "ea": 0.0774509560290373}, "output": 2.023568927930281}, {"input": {"xl": 2.0625214346007543, "xu": 3.4185346823095477, "ea": 0.08500634655452909}, "output": 2.138089462911403}, {"input": {"xl": 4.47484713390841, "xu": 8.803340708027939, "ea": 0.08575523316125663}, "output": 4.531791139705259}, {"input": {"xl": 2.993725121813242, "xu": 8.589065259600838, "ea": 0.01317714933246722}, "output": 3.0044646986356462}, {"input": {"xl": 2.318424042434456, "xu": 7.780830799186481, "ea": 0.02524218701983603}, "output": 2.3353882021890717}], "error_log": []}
{"context": "Given a 3x3 Tic Tac Toe game board, determine which player, if any, has won the game. The board is represented as a list of lists where each element can be 0 (empty), 1 (player 1), or 2 (player 2). A win is defined as having three of the same non-zero elements in a row, column, or diagonal. Who has won the game based on the provided game board?\n\nThe input and output requirements are as follows:\n\nInput:\n  `game_board` (list of lists of int): A 3x3 list representing the Tic Tac Toe game board.\n                                       Each element can be 0 (empty), 1 (player 1), or 2 (player 2).\n\nOutput:\n  `winner` (int or None): The winner player number (1 or 2) if there is a winner, otherwise None.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef check_winner(input_list, size):\n    \"\"\"\n    Check the winner number in row, column, or diagonal direction.\n\n    Arguments:\n    input_list -- a two dimensional list for checking.\n    size -- the length for winning.\n    \n    Returns:\n    winner -- the winner player number, if no winner return None.\n    \n    \"\"\"\n    # Check row\n    winner = check_row_winner(input_list, size)\n    if winner is None:\n        # Transpose matrix\n        input_list = transpose(input_list)\n        # Check column\n        winner = check_row_winner(input_list, size)\n    if winner is None:\n        # Check diagonal\n        winner = check_diagonal_winner(input_list, size)\n    if winner is None:\n        winner = check_diagonal_winner(list(zip(*reversed(input_list))), size)\n    return winner\n\ndef transpose(input_list):\n    \"\"\"\n    Transpose a two dimensional list.\n\n    Arguments:\n    input_list -- a two dimensional list for transposing.\n    \n    Returns:\n    result -- transposed two dimensional list.\n    \n    \"\"\"\n    result = []\n    for i in range(len(input_list[0])):\n        new_line = [new_list[i] for new_list in input_list]\n        result.append(new_line)\n    return result\n    \ndef check_row_winner(input_list, size):\n    \"\"\"\n    Check the winner number in row direction.\n\n    Arguments:\n    input_list -- a two dimensional list for checking.\n    size -- the length for winning.\n    \n    Returns:\n    winner -- the winner player number, if no winner return None.\n    \n    \"\"\"\n    for line in input_list:\n        count = 1\n        for idx, value in enumerate(line[:-1]):\n            if line[idx] == line[idx+1]:\n                count += 1\n            else:\n                count = 1\n            if count == size and value != 0:\n                return value\n    return None\n\ndef check_diagonal_winner(input_list, size):\n    \"\"\"\n    Check the winner number in diagonal direction.\n\n    Arguments:\n    input_list -- a two dimensional list for checking.\n    size -- the length for winning.\n    \n    Returns:\n    winner -- the winner player number, if no winner return None.\n    \n    \"\"\"\n    for row_idx, line in enumerate(input_list):\n        winner = 0\n        try:\n            list_for_check = []\n            for i in range(size):\n                list_for_check.append(input_list[row_idx+i][i])\n            if list_for_check.count(list_for_check[0]) == size:\n                if list_for_check[0] != 0:\n                    return list_for_check[0] \n        except IndexError:\n            winner = 0\n    return None\n\n# main function\ndef main_solution(game_board):\n    \"\"\"\n    Determines the winner of a Tic Tac Toe game based on the provided game board.\n\n    Arguments:\n    game_board (list of lists of int): A 3x3 list representing the Tic Tac Toe game board.\n                                       Each element can be 0 (empty), 1 (player 1), or 2 (player 2).\n\n    Returns:\n    winner (int or None): The winner player number (1 or 2) if there is a winner, otherwise None.\n    \"\"\"\n    size = 3\n    winner = check_winner(game_board, size)\n    return winner", "input_generator": "import random\n\ndef input_generator():\n    # Generate a 3x3 game board with 0, 1, or 2\n    game_board = [[random.randint(0, 2) for _ in range(3)] for _ in range(3)]\n    \n    # Occasionally force a winning condition for player 1 or 2\n    if random.random() < 0.3:\n        player = random.choice([1, 2])\n        direction = random.choice(['row', 'column', 'diagonal'])\n        if direction == 'row':\n            row = random.randint(0, 2)\n            game_board[row] = [player] * 3\n        elif direction == 'column':\n            col = random.randint(0, 2)\n            for row in range(3):\n                game_board[row][col] = player\n        else:  # diagonal\n            if random.choice([True, False]):\n                for i in range(3):\n                    game_board[i][i] = player\n            else:\n                for i in range(3):\n                    game_board[i][2 - i] = player\n    \n    return {'game_board': game_board}", "io_pairs": [{"input": {"game_board": [[1, 1, 1], [2, 2, 0], [1, 1, 0]]}, "output": 1}, {"input": {"game_board": [[0, 2, 1], [0, 1, 0], [1, 2, 1]]}, "output": 1}, {"input": {"game_board": [[1, 2, 1], [2, 1, 0], [1, 2, 1]]}, "output": 1}, {"input": {"game_board": [[2, 2, 2], [1, 1, 1], [0, 2, 0]]}, "output": 2}, {"input": {"game_board": [[2, 1, 2], [2, 1, 0], [2, 1, 1]]}, "output": 2}, {"input": {"game_board": [[1, 2, 2], [2, 1, 0], [0, 1, 1]]}, "output": 1}, {"input": {"game_board": [[2, 2, 1], [2, 0, 1], [1, 2, 1]]}, "output": 1}, {"input": {"game_board": [[1, 0, 2], [1, 2, 2], [2, 2, 1]]}, "output": 2}, {"input": {"game_board": [[1, 2, 0], [2, 2, 0], [0, 2, 2]]}, "output": 2}, {"input": {"game_board": [[2, 2, 2], [0, 2, 2], [2, 0, 0]]}, "output": 2}], "error_log": []}
{"context": "In a game of Tic Tac Toe, given a partially filled 3x3 grid, determine the current state of the game. Specifically, identify if there is a winner, the utility value of the board, the next player who will make a move, and the possible actions (moves) that can be taken on the board. What are the details of the current game state based on the provided board configuration?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists of strings/None): A 3x3 grid representing the Tic Tac Toe board. Each cell can be `\"X\"`, `\"O\"`, or `None` (representing an empty cell).\n\nOutput:\n  `return` (dict): A dictionary with the following keys:\n  - `winner` (string/None): The winner of the game if there is one (`\"X\"`, `\"O\"`, or `None` if no winner).\n  - `utility` (int): The utility value of the board (`1` if `\"X\"` wins, `-1` if `\"O\"` wins, `0` otherwise).\n  - `next_player` (string): The player who has the next turn (`\"X\"` or `\"O\"`).\n  - `possible_actions` (list of tuples): A list of tuples representing the possible actions (moves) that can be taken on the board. Each tuple is of the form `(row, column)`.", "reference_code": "# import necessary packages\nimport math\nfrom copy import deepcopy\nfrom collections import deque\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    X_count = sum(row.count(X) for row in board)\n    O_count = sum(row.count(O) for row in board)\n    return O if O_count < X_count else X\n\n# Function to get all possible actions\ndef actions(board):\n    return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}\n\n# Function to get the result of an action\ndef result(board, action):\n    current_player = player(board)\n    new_board = deepcopy(board)\n    if new_board[action[0]][action[1]] != EMPTY:\n        raise ValueError(\"Invalid move\")\n    new_board[action[0]][action[1]] = current_player\n    return new_board\n\n# Function to determine the winner\ndef winner(board):\n    for row in board:\n        if row.count(X) == 3:\n            return X\n        if row.count(O) == 3:\n            return O\n    for col in range(3):\n        if [board[row][col] for row in range(3)].count(X) == 3:\n            return X\n        if [board[row][col] for row in range(3)].count(O) == 3:\n            return O\n    if [board[i][i] for i in range(3)].count(X) == 3 or [board[i][2 - i] for i in range(3)].count(X) == 3:\n        return X\n    if [board[i][i] for i in range(3)].count(O) == 3 or [board[i][2 - i] for i in range(3)].count(O) == 3:\n        return O\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or all(cell is not EMPTY for row in board for cell in row)\n\n# Function to get the utility of the board\ndef utility(board):\n    win = winner(board)\n    if win == X:\n        return 1\n    elif win == O:\n        return -1\n    else:\n        return 0\n\n# Main function to solve the problem\ndef main_solution(board):\n    if terminal(board):\n        return {\"winner\": winner(board), \"utility\": utility(board)}\n    else:\n        return {\"next_player\": player(board), \"possible_actions\": list(actions(board))}", "input_generator": "import random\n\ndef input_generator():\n    board = [[None for _ in range(3)] for _ in range(3)]\n    moves = random.randint(0, 9)\n    current_player = 'X'\n    \n    for _ in range(moves):\n        empty_positions = [(i, j) for i in range(3) for j in range(3) if board[i][j] is None]\n        if not empty_positions:\n            break\n        move = random.choice(empty_positions)\n        board[move[0]][move[1]] = current_player\n        current_player = 'O' if current_player == 'X' else 'X'\n    \n    return {'board': board}", "io_pairs": [{"input": {"board": [[null, "X", null], ["X", null, "O"], [null, null, null]]}, "output": {"next_player": "O", "possible_actions": [[2, 1], [0, 0], [1, 1], [2, 0], [0, 2], [2, 2]]}}, {"input": {"board": [["O", "X", "X"], [null, "O", "O"], ["X", null, "X"]]}, "output": {"next_player": "O", "possible_actions": [[1, 0], [2, 1]]}}, {"input": {"board": [["X", "X", null], [null, null, "O"], ["O", null, null]]}, "output": {"next_player": "X", "possible_actions": [[2, 1], [1, 1], [0, 2], [2, 2], [1, 0]]}}, {"input": {"board": [["X", "O", null], ["O", "X", "X"], ["X", "O", "O"]]}, "output": {"next_player": "X", "possible_actions": [[0, 2]]}}, {"input": {"board": [["O", "O", "O"], ["X", "X", "X"], ["X", null, null]]}, "output": {"winner": "O", "utility": -1}}, {"input": {"board": [[null, null, null], [null, "X", "O"], [null, null, null]]}, "output": {"next_player": "X", "possible_actions": [[0, 1], [2, 1], [0, 0], [2, 0], [0, 2], [2, 2], [1, 0]]}}, {"input": {"board": [[null, null, null], ["O", "X", "X"], ["O", "X", null]]}, "output": {"next_player": "O", "possible_actions": [[0, 1], [0, 2], [2, 2], [0, 0]]}}, {"input": {"board": [["O", "X", "O"], ["O", "X", null], ["X", "O", "X"]]}, "output": {"next_player": "X", "possible_actions": [[1, 2]]}}, {"input": {"board": [["X", "O", "X"], [null, "X", null], ["O", null, null]]}, "output": {"next_player": "O", "possible_actions": [[1, 0], [1, 2], [2, 1], [2, 2]]}}, {"input": {"board": [["X", "O", "X"], ["O", "X", "O"], ["X", "O", "X"]]}, "output": {"winner": "X", "utility": 1}}], "error_log": []}
{"context": "Given a set of numbered cups arranged in a specific order, and a number of rounds, what will be the final order of the cups after performing a series of operations where three cups are picked up and placed in a new position each round? The operations start with the first cup in the initial order and continue for the specified number of rounds. The final order should be determined starting from the cup labeled '1'.\n\nThe input and output requirements are as follows:\n\nInput:\n  `data` (str): A comma-separated string of integers representing the initial configuration of the cups.\n  `rounds` (int): The number of rounds to perform the cups operation.\n\nOutput:\n  `return` (str): A string representing the order of the cups after the specified number of rounds, starting from the cup labeled '1'.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef pick_up(data, index):\n    pickup = []\n    while len(pickup) < 3:\n        if index >= len(data):\n            index = 0\n        pickup.append(data.pop(index))\n    return pickup\n\ndef find_destination(data, curr):\n    drop = curr - 1\n    found = False\n    while not found:\n        try:\n            dest = data.index(drop)\n            found = True\n        except:\n            drop -= 1\n            if drop < min(data):\n                drop = max(data)\n    return dest\n\ndef get_order(data):\n    index = data.index(1)\n    order = data[index:] + data[:index]\n    return \"\".join([str(x) for x in order[1:]])\n\ndef cups(data, rounds=10):\n    turn = 0\n    curr = data[0]\n    while turn < rounds:\n        pickup = pick_up(data, data.index(curr) + 1)\n        drop = find_destination(data, curr)\n        data = data[:drop + 1] + pickup + data[drop + 1:]\n        curr = data[data.index(curr) + 1 if data.index(curr) < len(data) - 1 else 0]\n        turn += 1\n    return data\n\n# main function\ndef main_solution(data, rounds):\n    # Convert input to list of integers\n    data = [int(x) for x in data.split(\",\")]\n    \n    # Perform the cups operation\n    result = cups(data, rounds)\n    \n    # Get the order after the cups operation\n    final_order = get_order(result)\n    \n    # Return the final order as a string\n    return final_order", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random list of digits from 1 to 9, shuffled\n    digits = list(range(1, 10))\n    random.shuffle(digits)\n    data = \",\".join(map(str, digits))\n    \n    # Generate a random number of rounds between 5 and 20\n    rounds = random.randint(5, 20)\n    \n    return {\"data\": data, \"rounds\": rounds}", "io_pairs": [{"input": {"data": "8,7,5,3,2,1,9,6,4", "rounds": 13}, "output": "86427953"}, {"input": {"data": "1,7,8,5,2,3,6,9,4", "rounds": 14}, "output": "24756983"}, {"input": {"data": "5,1,4,8,2,3,6,7,9", "rounds": 11}, "output": "92386745"}, {"input": {"data": "6,3,9,8,2,5,1,7,4", "rounds": 20}, "output": "37842965"}, {"input": {"data": "3,5,7,1,9,8,2,6,4", "rounds": 18}, "output": "68792543"}, {"input": {"data": "7,2,5,9,3,8,6,1,4", "rounds": 9}, "output": "58432967"}, {"input": {"data": "2,7,3,4,5,6,1,9,8", "rounds": 16}, "output": "93687425"}, {"input": {"data": "4,5,1,9,8,3,7,2,6", "rounds": 15}, "output": "57986243"}, {"input": {"data": "4,2,1,3,6,7,9,8,5", "rounds": 10}, "output": "74296853"}, {"input": {"data": "3,6,7,1,9,4,5,2,8", "rounds": 9}, "output": "39486257"}], "error_log": []}
{"context": "Given the Collatz sequence defined for positive integers, where even numbers are divided by 2 and odd numbers are multiplied by 3 and incremented by 1, what is the starting number within a specified range that produces the longest chain before reaching 1?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start_range` (int): The starting number of the range within which to find the number that produces the longest chain.\n  `end_range` (int): The ending number of the range within which to find the number that produces the longest chain.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `longest_chain_length` (int): The length of the longest chain generated by any starting number in the given range.\n    - `starting_number` (int): The starting number that produces the longest chain.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef doSeq(x, DICT):\n    if x == 1:\n        return 1\n    if x in DICT:\n        return DICT[x]\n    if x % 2 == 0:\n        DICT[x] = 1 + doSeq(x / 2, DICT)\n    else:\n        DICT[x] = 1 + doSeq(3 * x + 1, DICT)\n    return DICT[x]\n\n# main function\ndef main_solution(start_range, end_range):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    DICT = {}\n    MX = 0\n    MX_NUM = 0\n    for x in range(start_range, end_range + 1):\n        c = doSeq(x, DICT)\n        DICT[x] = c\n        if c > MX:\n            MX = c\n            MX_NUM = x\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"longest_chain_length\": MX, \"starting_number\": MX_NUM}", "input_generator": "import random\n\ndef input_generator():\n    start_range = random.randint(1, 1000)\n    end_range = random.randint(start_range, start_range + 1000)\n    return {\"start_range\": start_range, \"end_range\": end_range}", "io_pairs": [{"input": {"start_range": 592, "end_range": 691}, "output": {"longest_chain_length": 145, "starting_number": 649}}, {"input": {"start_range": 928, "end_range": 1361}, "output": {"longest_chain_length": 182, "starting_number": 1161}}, {"input": {"start_range": 398, "end_range": 1245}, "output": {"longest_chain_length": 182, "starting_number": 1161}}, {"input": {"start_range": 636, "end_range": 1283}, "output": {"longest_chain_length": 182, "starting_number": 1161}}, {"input": {"start_range": 349, "end_range": 1203}, "output": {"longest_chain_length": 182, "starting_number": 1161}}, {"input": {"start_range": 479, "end_range": 962}, "output": {"longest_chain_length": 179, "starting_number": 871}}, {"input": {"start_range": 159, "end_range": 598}, "output": {"longest_chain_length": 144, "starting_number": 327}}, {"input": {"start_range": 407, "end_range": 814}, "output": {"longest_chain_length": 171, "starting_number": 703}}, {"input": {"start_range": 420, "end_range": 876}, "output": {"longest_chain_length": 179, "starting_number": 871}}, {"input": {"start_range": 930, "end_range": 1610}, "output": {"longest_chain_length": 182, "starting_number": 1161}}], "error_log": []}
{"context": "Given an angle in radians, how can we approximate the sine of this angle using a Taylor series expansion? Specifically, what is the computed sine value for a given angle `x`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): The angle in radians for which the sine function is to be computed.\n\nOutput:\n  `return` (float): The computed sine value of the input angle `x`.", "reference_code": "# import necessary packages\nfrom math import pi, sin, factorial\n\n# main function\ndef main_solution(x):\n    # Convert input to float if necessary\n    x = float(x)\n    \n    # Function to compute sine using Taylor series expansion\n    def compsin(x):\n        n = 0\n        oldsum, newsum, term = 0., x, x\n        while newsum != oldsum:\n            oldsum = newsum\n            n += 1\n            term *= -x**2/((2*n+1)*2*n)\n            newsum += term\n        return newsum\n    \n    # Compute sine using the compsin function\n    result = compsin(x)\n    \n    # Return the result as a float\n    return float(result)", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random float between -2*pi and 2*pi with some variations\n    x = random.uniform(-2 * math.pi, 2 * math.pi)\n    # Occasionally pick common angles like 0, pi/2, pi, etc.\n    if random.random() < 0.3:\n        common_angles = [0, math.pi/6, math.pi/4, math.pi/3, math.pi/2, math.pi, 3*math.pi/2, 2*math.pi]\n        x = random.choice(common_angles)\n    return {'x': x}", "io_pairs": [{"input": {"x": -2.5905688793155073}, "output": -0.5235597475342617}, {"input": {"x": -2.723472908438859}, "output": -0.40604289337408855}, {"input": {"x": 0.5235987755982988}, "output": 0.49999999999999994}, {"input": {"x": -0.8897690082760228}, "output": -0.7769263378278294}, {"input": {"x": 2.065495364808262}, "output": 0.8801116364505723}, {"input": {"x": 1.5707963267948966}, "output": 1.0000000000000002}, {"input": {"x": 1.0410613092022167}, "output": 0.8629409976636355}, {"input": {"x": -4.937714289270718}, "output": 0.9747214770088753}, {"input": {"x": 0.4698915383150064}, "output": 0.4527895817165706}, {"input": {"x": -2.4860722463291833}, "output": -0.6095718687231988}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = x^2 \\), we want to numerically integrate it over a specified interval using a specific integration method. What is the result of the numerical integration when integrating \\( f(x) \\) from `xo` to `xn` with `n` subdivisions and using the step size `stp`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `xo` (float): The lower bound of the integration interval.\n  `xn` (float): The upper bound of the integration interval.\n  `n` (int): The number of subdivisions for the integration.\n  `stp` (int): The step size for the integration method, must be one of [3, 4, 5, 6].\n\nOutput:\n  `return` (float): The result of the numerical integration.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Integrator(object):  \n    def __init__(self): \n        self.stop ={\n            3:(1 ,4 ,1 ,         1/3  ),\n            4:(1 ,3 ,3 ,1 ,      3/8  ),\n            5:(7 ,32,12,32,7 ,   2/45 ),\n            6:(19,75,50,50,75,19,5/288),\n        }\n                \n    def integrate(self, xo, xn, n, fun, stp):\n        x=xo\n        val=0\n        h = (xn-xo)/n/(stp-1)\n        for i in range(n):\n            for j, el in enumerate(self.stop[stp][0:-1]):\n                if j==(len(self.stop[stp])-2):\n                    val+=el*fun(x)*h*self.stop[stp][-1]\n                else:\t\t\t\n                    val+=el*fun(x)*h*self.stop[stp][-1]\n                    x+=h\n        return val\n\ndef fun(x):\n    return x*x\n\n# main function\ndef main_solution(xo, xn, n, stp):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    integrator = Integrator()\n    result = integrator.integrate(xo, xn, n, fun, stp)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    xo = random.uniform(-10, 10)\n    xn = xo + random.uniform(1, 20)\n    n = random.randint(1, 100)\n    stp = random.choice([3, 4, 5, 6])\n    return {'xo': xo, 'xn': xn, 'n': n, 'stp': stp}", "io_pairs": [{"input": {"xo": -6.873609974209556, "xn": 4.352732132875342, "n": 34, "stp": 5}, "output": 135.7407263986248}, {"input": {"xo": -2.732368761210761, "xn": 0.41892292485067584, "n": 19, "stp": 4}, "output": 6.824314953734422}, {"input": {"xo": 4.411057352916561, "xn": 9.084763665460816, "n": 64, "stp": 6}, "output": 221.32144838271736}, {"input": {"xo": -0.6729300376182898, "xn": 7.114854111512217, "n": 16, "stp": 4}, "output": 120.15560548499116}, {"input": {"xo": 7.30324662429507, "xn": 10.273961215980648, "n": 46, "stp": 4}, "output": 231.64143354043125}, {"input": {"xo": 2.671756503058681, "xn": 21.039260838362093, "n": 8, "stp": 5}, "output": 3097.9891683978644}, {"input": {"xo": -0.1318994930958084, "xn": 13.288735207904955, "n": 35, "stp": 4}, "output": 782.2221563999515}, {"input": {"xo": 9.886740891237164, "xn": 12.941717572880933, "n": 66, "stp": 5}, "output": 400.3924816627886}, {"input": {"xo": 5.978784171446437, "xn": 9.048369137260801, "n": 48, "stp": 4}, "output": 175.70006634293148}, {"input": {"xo": -3.175744594311767, "xn": 9.07568716287535, "n": 14, "stp": 4}, "output": 259.85853083312514}], "error_log": []}
{"context": "In a factory, there are several balls with different weights. The factory manager wants to find the heaviest ball among them. Given a list of ball weights, what is the weight of the heaviest ball?\n\nThe input and output requirements are as follows:\n\nInput:\n  `balls` (list of integers): A list of integers representing the weights of the balls. The list should contain at least two elements.\n\nOutput:\n  `return` (integer): The weight of the heaviest ball found in the list.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(balls):\n    # Convert the input list to a JSON serializable format\n    balls = list(balls)\n    \n    def ball(l, t):\n        c = t\n        if len(l) == 2:\n            if l[0] > l[1]:\n                return l[0]\n            elif l[1] > l[0]:\n                return l[1]\n            else:\n                return c\n        else:\n            if math.fmod(len(l), 2) == 0:\n                if sum(l[0:len(l)//2]) > sum(l[len(l)//2:len(l)]):\n                    return ball(l[0:len(l)//2], c)\n                else:\n                    return ball(l[len(l)//2:len(l)], c)\n            else:\n                if l[0] > c:\n                    c = l[0]\n                if len(l[1:len(l)]) == 2:\n                    if l[0] > l[1]:\n                        return l[0]\n                    elif l[1] > l[0]:\n                        return l[1]\n                    else:\n                        return c\n                elif sum(l[1:len(l)//2 + 1]) > sum(l[len(l)//2 + 1:len(l)]):\n                    return ball(l[1:len(l)//2 + 1], c)\n                else:\n                    return ball(l[len(l)//2 + 1:len(l)], c)\n    \n    result = ball(balls, 0)\n    \n    # Convert the result to a JSON serializable format\n    return result", "input_generator": "import random\n\ndef input_generator():\n    size = random.randint(2, 20)\n    balls = [random.randint(1, 100) for _ in range(size)]\n    return {'balls': balls}", "io_pairs": [{"input": {"balls": [26, 51, 95, 39, 75, 80, 37, 27, 53, 67, 59, 17, 49, 86, 12]}, "output": 95}, {"input": {"balls": [52, 20, 100, 69, 82, 100, 48, 26, 50, 17]}, "output": 82}, {"input": {"balls": [88, 99, 3]}, "output": 99}, {"input": {"balls": [93, 22, 68, 99, 26, 72, 32, 64, 14, 98]}, "output": 99}, {"input": {"balls": [34, 40, 58, 82, 37, 62, 79]}, "output": 58}, {"input": {"balls": [93, 43, 81, 66, 43, 49, 48, 50, 5, 78]}, "output": 81}, {"input": {"balls": [50, 47, 59, 32, 86, 62, 56]}, "output": 86}, {"input": {"balls": [11, 89, 41, 98, 32]}, "output": 98}, {"input": {"balls": [50, 73]}, "output": 73}, {"input": {"balls": [43, 28, 18, 89, 15, 77, 11, 9]}, "output": 89}], "error_log": []}
{"context": "Given a dataset of diabetes patients, where each patient's data includes a single feature and the target value representing the progression of the disease, how can we determine the optimal parameters for a linear regression model to predict the progression based on the feature? Specifically, what are the final values of the intercept (`theta0`) and slope (`theta1`) terms, along with the cost, after applying gradient descent with a specified learning rate and maximum number of iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `theta0` (float): Initial value for the intercept term in the linear regression model.\n  `theta1` (float): Initial value for the slope term in the linear regression model.\n  `alpha` (float): Learning rate for the gradient descent algorithm.\n  `maxIter` (int): Maximum number of iterations for the gradient descent algorithm.\n\nOutput:\n  `return` (dict): A dictionary containing the final values of `theta0`, `theta1`, and the cost after training.\n    - `theta0` (float): The final intercept term of the linear regression model.\n    - `theta1` (float): The final slope term of the linear regression model.\n    - `cost` (float): The final cost (mean squared error) of the model after training.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom sklearn import datasets\n\n# all class and function definitions in the code file, if any\ndef hypothesis(theta0, theta1, train_X):\n    hyp_Y = []\n    for i in train_X:\n        hyp_Y.append(theta0 + theta1 * i)\n    return hyp_Y\n\ndef compute_cost(hyp_Y, train_Y, trainingSize):\n    cost = 0.0\n    for hyp, actual in zip(hyp_Y, train_Y):\n        cost += (hyp - actual) * (hyp - actual)\n    cost = cost / float(2 * trainingSize)\n    return cost\n\ndef gradient_descent(hyp_Y, theta0, theta1, train_X, train_Y, alpha, trainingSize):\n    costThetaZero = 0.0\n    costThetaOne = 0.0\n    for hyp, actual, x in zip(hyp_Y, train_Y, train_X):\n        costThetaZero += hyp - actual\n        costThetaOne += (hyp - actual) * x\n    theta0 = theta0 - alpha * float(1.0 / trainingSize) * costThetaZero\n    theta1 = theta1 - alpha * float(1.0 / trainingSize) * costThetaOne\n    return (theta0, theta1)\n\n# main function\ndef main_solution(theta0, theta1, alpha, maxIter):\n    # Load the diabetes dataset\n    diabetes = datasets.load_diabetes()\n\n    # Use only one feature\n    diabetes_X = diabetes.data[:, np.newaxis, 2]\n    diabetes_X3 = diabetes_X.tolist()\n    diabetes_Y2 = diabetes.target.tolist()\n\n    diabetes_X2 = [i[0] for i in diabetes_X3]\n\n    diabetes_train_X = diabetes_X2[:-20]\n    diabetes_train_Y = diabetes_Y2[:-20]\n\n    trainingSize = len(diabetes_train_X)\n    prevcost = 1e9\n    currIter = 0\n\n    while True:\n        currIter += 1\n        hyp_Y = hypothesis(theta0, theta1, diabetes_train_X)\n        cost = compute_cost(hyp_Y, diabetes_train_Y, trainingSize)\n\n        if currIter < maxIter:\n            tupleTheta = gradient_descent(hyp_Y, theta0, theta1, diabetes_train_X, diabetes_train_Y, alpha, trainingSize)\n            theta0 = tupleTheta[0]\n            theta1 = tupleTheta[1]\n            prevcost = cost\n        else:\n            break\n\n    return {\"theta0\": theta0, \"theta1\": theta1, \"cost\": cost}", "input_generator": "import random\n\ndef input_generator():\n    theta0 = random.uniform(-10.0, 10.0)\n    theta1 = random.uniform(-10.0, 10.0)\n    alpha = random.uniform(0.001, 0.1)\n    maxIter = random.randint(100, 1000)\n    return {\"theta0\": theta0, \"theta1\": theta1, \"alpha\": alpha, \"maxIter\": maxIter}", "io_pairs": [{"input": {"theta0": 7.675205740567293, "theta1": -5.115838191431643, "alpha": 0.03150951478873491, "maxIter": 140}, "output": {"theta0": 151.6606158139676, "theta1": 4.2627235664426015, "cost": 2966.694257855519}}, {"input": {"theta0": -0.7901544942676413, "theta1": -9.590427622628724, "alpha": 0.0039618792553468085, "maxIter": 377}, "output": {"theta0": 118.71461926020494, "theta1": -6.341830962811278, "cost": 3588.150519919717}}, {"input": {"theta0": 4.45779107449593, "theta1": 9.646997180323677, "alpha": 0.07041725939808458, "maxIter": 281}, "output": {"theta0": 153.33973981264677, "theta1": 50.26881379486587, "cost": 2870.3371540057133}}, {"input": {"theta0": 7.146685845765596, "theta1": -6.837984242279522, "alpha": 0.005422815463670017, "maxIter": 751}, "output": {"theta0": 150.8859536270043, "theta1": 1.894311857415033, "cost": 2973.329800957758}}, {"input": {"theta0": 9.00257345305645, "theta1": -8.406293352827905, "alpha": 0.03610224678894218, "maxIter": 195}, "output": {"theta0": 153.24525357293905, "theta1": 6.558121415338967, "cost": 2960.4068033280423}}, {"input": {"theta0": 8.957494329345941, "theta1": -8.595944724870641, "alpha": 0.017979953606699125, "maxIter": 370}, "output": {"theta0": 153.18226423970847, "theta1": 5.591587919807953, "cost": 2962.4564394677423}}, {"input": {"theta0": 9.977898012492034, "theta1": 6.598493220875138, "alpha": 0.07795393588061514, "maxIter": 348}, "output": {"theta0": 153.33416761640802, "theta1": 62.02545139705614, "cost": 2846.851743530951}}, {"input": {"theta0": -7.137432678341533, "theta1": -9.734282334774706, "alpha": 0.029120823095100674, "maxIter": 831}, "output": {"theta0": 153.34421180058715, "theta1": 40.83421813414434, "cost": 2889.4103710345644}}, {"input": {"theta0": -1.6713066153897937, "theta1": -6.118157975255709, "alpha": 0.04140363672391107, "maxIter": 865}, "output": {"theta0": 153.33160078187854, "theta1": 67.44096063129267, "cost": 2836.1388622779978}}, {"input": {"theta0": 7.540359599271117, "theta1": 7.114810410540471, "alpha": 0.0019062298757663372, "maxIter": 719}, "output": {"theta0": 116.30421030549383, "theta1": 10.047767555579728, "cost": 3639.535692008024}}], "error_log": []}
{"context": "In the classic Tower of Hanoi puzzle, you have three towers and a number of disks of different sizes that can slide onto any tower. The puzzle starts with the disks neatly stacked in ascending order of size on one tower, the smallest at the top, making a conical shape. The objective of the puzzle is to move the entire stack to another tower, obeying the following simple rules:\n1. Only one disk can be moved at a time.\n2. Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty tower.\n3. No disk may be placed on top of a smaller disk.\n\nGiven the number of disks `n`, what is the sequence of moves required to solve the Tower of Hanoi puzzle, moving all disks from the first tower to the third tower?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of disks to be moved in the Tower of Hanoi problem. It should be a positive integer.\n\nOutput:\n  `return` (list of lists): A list of moves required to solve the Tower of Hanoi problem with `n` disks. Each move is represented as a list of two integers, where the first integer is the source tower and the second integer is the destination tower.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef hanoi(n, t1, t2, t3, answer):\n    if n == 1:\n        answer.append([t1, t3])\n        return\n    hanoi(n-1, t1, t3, t2, answer)\n    answer.append([t1, t3])\n    hanoi(n-1, t2, t1, t3, answer)\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    answer = []\n    hanoi(n, 1, 2, 3, answer)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return answer", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)\n    return {'n': n}", "io_pairs": [{"input": {"n": 3}, "output": [[1, 3], [1, 2], [3, 2], [1, 3], [2, 1], [2, 3], [1, 3]]}, {"input": {"n": 2}, "output": [[1, 2], [1, 3], [2, 3]]}, {"input": {"n": 1}, "output": [[1, 3]]}], "error_log": []}
{"context": "Given a non-negative integer `m`, what is the fractional representation of the Bernoulli number B(m)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The non-negative integer for which the Bernoulli number B(m) is to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing the numerator and denominator of the Bernoulli number B(m) in its fractional form.\n    - `numerator` (int): The numerator of the Bernoulli number.\n    - `denominator` (int): The denominator of the Bernoulli number.", "reference_code": "# import necessary packages\nfrom math import factorial\nfrom fractions import Fraction\n\n# all class and function definitions in the code file, if any\nbinoDict = {}\nbernDict = {}\n\ndef binomial(n, r):\n    if (n, r) in binoDict:\n        return binoDict[(n, r)]\n    b = Fraction(factorial(n) // (factorial(r) * factorial(n-r)))\n    binoDict[(n, r)] = b\n    return b\n\ndef B(m):\n    if m == 0:\n        return Fraction(1, 1)\n    if m == 1:\n        return Fraction(1, 2)\n    if m % 2 == 1:\n        return 0\n    if m in bernDict:\n        return bernDict[m]\n    sigma = Fraction(0, 1)\n    for k in range(m):\n        sigma += binomial(m, k) * B(k) / (m - k + 1)\n    ans = Fraction(1, 1) - sigma\n    bernDict[m] = ans\n    return ans\n\n# main function\ndef main_solution(m):\n    # Convert input to Fraction if necessary\n    m = int(m)\n    \n    # Calculate the Bernoulli number\n    result = B(m)\n    \n    # Convert the result to a JSON serializable format\n    return {\"numerator\": result.numerator, \"denominator\": result.denominator}", "input_generator": "import random\nfrom fractions import Fraction\n\ndef input_generator():\n    m = random.choice([0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20])\n    return {\"m\": m}", "io_pairs": [{"input": {"m": 14}, "output": {"numerator": 7, "denominator": 6}}, {"input": {"m": 4}, "output": {"numerator": -1, "denominator": 30}}, {"input": {"m": 8}, "output": {"numerator": -1, "denominator": 30}}, {"input": {"m": 12}, "output": {"numerator": -691, "denominator": 2730}}, {"input": {"m": 16}, "output": {"numerator": -3617, "denominator": 510}}, {"input": {"m": 18}, "output": {"numerator": 43867, "denominator": 798}}, {"input": {"m": 20}, "output": {"numerator": -174611, "denominator": 330}}, {"input": {"m": 6}, "output": {"numerator": 1, "denominator": 42}}, {"input": {"m": 0}, "output": {"numerator": 1, "denominator": 1}}, {"input": {"m": 2}, "output": {"numerator": 1, "denominator": 6}}], "error_log": []}
{"context": "Given a mathematical function and a point in its domain, how would you approximate the derivative of the function at that point using numerical differentiation? Specifically, you are given two functions: `function_1` which is a single-variable function, and `function_2` which is a two-variable function. For each function, you need to determine the numerical derivative at a specified point `x`. What is the numerical derivative of the function at the given point `x`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `function_type` (str): A string indicating which function to use. It can be either \"function_1\" or \"function_2\".\n  `x` (list of float): A list of floats representing the input to the function. If `function_type` is \"function_1\", `x` should contain a single float. If `function_type` is \"function_2\", `x` should contain two floats.\n\nOutput:\n  `return` (list of float): A list of floats representing the numerical derivative of the function at the given input `x`. The length of the list depends on the function type and the input size.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef function_1(x):\n    return 0.01 * x**2 + 0.1 * x\n\ndef function_2(x):\n    return x[0]**2 + x[1]**2\n\ndef numerical_differential_1(f, x):\n    h = 10e-5\n    return (f(x + h) - f(x)) / h\n\ndef numerical_differential_2(f, x):\n    h = 1e-1\n    grad = np.zeros_like(x)\n\n    for index in range(x.size):\n        tmp_val = x[index]\n        x[index] = tmp_val + h\n        fxh1 = f(x)\n\n        x[index] = tmp_val - h\n        fxh2 = f(x)\n\n        grad[index] = (fxh1 - fxh2) / (2 * h)\n        x[index] = tmp_val\n    return grad\n\n# main function\ndef main_solution(function_type, x):\n    # Convert JSON serializable input to the required format\n    x = np.array(x)\n\n    if function_type == \"function_1\":\n        f = function_1\n    elif function_type == \"function_2\":\n        f = function_2\n    else:\n        raise ValueError(\"Invalid function type\")\n\n    if x.size == 1:\n        result = numerical_differential_1(f, x)\n    else:\n        result = numerical_differential_2(f, x)\n\n    # Convert the result to JSON serializable output\n    return result.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    function_types = [\"function_1\", \"function_2\"]\n    function_type = random.choice(function_types)\n    \n    if function_type == \"function_1\":\n        x = random.uniform(-10.0, 10.0)\n    else:\n        x = [random.uniform(-5.0, 5.0) for _ in range(2)]\n    \n    return {\n        \"function_type\": function_type,\n        \"x\": x\n    }", "io_pairs": [{"input": {"function_type": "function_2", "x": [1.358077154296451, -2.00437739228882]}, "output": [2.7161543085929063, -4.008754784577642]}, {"input": {"function_type": "function_2", "x": [-1.6499164666101338, -4.781163554950761]}, "output": [-3.2998329332202836, -9.562327109901503]}, {"input": {"function_type": "function_2", "x": [1.4433872147376947, -0.29037431283523496]}, "output": [2.8867744294753916, -0.5807486256704708]}, {"input": {"function_type": "function_1", "x": -7.318737255167084}, "output": -0.04637374510396697}, {"input": {"function_type": "function_1", "x": -2.938015313631963}, "output": 0.04124069372751782}, {"input": {"function_type": "function_2", "x": [-4.41866810111125, -3.5152663441593415]}, "output": [-8.837336202222481, -7.030532688318694]}, {"input": {"function_type": "function_1", "x": -4.264063901897437}, "output": 0.014719721961597987}, {"input": {"function_type": "function_2", "x": [1.0167968414355508, 3.9470450407164517]}, "output": [2.0335936828711, 7.894090081432887]}, {"input": {"function_type": "function_1", "x": -8.057286258299294}, "output": -0.06114472516527414}, {"input": {"function_type": "function_1", "x": -0.9872217084085122}, "output": 0.08025656583185437}], "error_log": []}
{"context": "Given a positive integer `n`, what is the result of performing a specific mathematical operation on `n`? The possible operations are calculating the factorial of `n`, finding the `n`-th Fibonacci number, summing the digits of `n`, and finding the greatest common divisor (GCD) of `n` and another randomly generated positive integer.\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): A positive integer.\n  `operation` (str): A string indicating the operation to perform. Possible values are \"factorial\", \"fibonacci\", \"sum_of_digits\", and \"gcd\".\n\nOutput:\n  `return` (dict): A dictionary containing the result of the operation. The key is \"result\" and the value is the result of the operation.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef factorial(n):\n    assert 0 <= n == int(n), \"n must be a positive integer only.\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)\n\ndef fibonacci(n):\n    if n in [0, 1]:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\ndef sum_of_digits(n):\n    assert n > 0, \"N should be a positive integer\"\n    if n < 10:\n        return int(n)\n    else:\n        return int(n % 10) + sum_of_digits(n/10)\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\n# main function\ndef main_solution(n, operation):\n    # Convert JSON serializable inputs to original input variables\n    if operation == \"factorial\":\n        result = factorial(n)\n    elif operation == \"fibonacci\":\n        result = fibonacci(n)\n    elif operation == \"sum_of_digits\":\n        result = sum_of_digits(n)\n    elif operation == \"gcd\":\n        a = n\n        b = random.randint(1, n)  # Generate a random b for gcd\n        result = gcd(a, b)\n    else:\n        raise ValueError(\"Invalid operation\")\n    \n    # Convert the result to JSON serializable output\n    return {\"result\": result}", "input_generator": "import random\n\ndef input_generator():\n    operations = [\"factorial\", \"fibonacci\", \"sum_of_digits\", \"gcd\"]\n    operation = random.choice(operations)\n    \n    if operation == \"factorial\":\n        n = random.randint(0, 20)\n    elif operation == \"fibonacci\":\n        n = random.randint(0, 20)\n    elif operation == \"sum_of_digits\":\n        n = random.randint(1, 10000)\n    else:  # gcd\n        n = random.randint(1, 1000)\n    \n    return {\"n\": n, \"operation\": operation}", "io_pairs": [{"input": {"n": 0, "operation": "factorial"}, "output": {"result": 1}}, {"input": {"n": 17, "operation": "fibonacci"}, "output": {"result": 1597}}, {"input": {"n": 2402, "operation": "sum_of_digits"}, "output": {"result": 8}}, {"input": {"n": 0, "operation": "fibonacci"}, "output": {"result": 0}}, {"input": {"n": 1, "operation": "fibonacci"}, "output": {"result": 1}}, {"input": {"n": 948, "operation": "sum_of_digits"}, "output": {"result": 21}}, {"input": {"n": 15, "operation": "factorial"}, "output": {"result": 1307674368000}}, {"input": {"n": 9, "operation": "fibonacci"}, "output": {"result": 34}}, {"input": {"n": 14, "operation": "fibonacci"}, "output": {"result": 377}}, {"input": {"n": 18, "operation": "factorial"}, "output": {"result": 6402373705728000}}], "error_log": []}
{"context": "Given a set of courses and constraints that prevent certain courses from having exams on the same day, how can we schedule the exams for all courses such that no student has more than one exam on the same day?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_assignment` (dict): A dictionary where keys are course names (str) and values are exam days (str). This represents the initial assignment of exams to days. Default is an empty dictionary.\n\nOutput:\n  `return` (dict): A dictionary where keys are course names (str) and values are exam days (str). This represents the final assignment of exams to days that satisfies all constraints.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nVARIABLES = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]\nCONSTRAINTS = [\n    (\"A\", \"B\"),\n    (\"A\", \"C\"),\n    (\"B\", \"C\"),\n    (\"B\", \"D\"),\n    (\"B\", \"E\"),\n    (\"C\", \"E\"),\n    (\"C\", \"F\"),\n    (\"D\", \"E\"),\n    (\"E\", \"F\"),\n    (\"E\", \"G\"),\n    (\"F\", \"G\")\n]\n\ndef backtrack(assignment):\n    \"\"\"Runs backtracking search to find an assignment.\"\"\"\n    if len(assignment) == len(VARIABLES):\n        return assignment\n    var = selectUnassignedVariable(assignment)\n    for value in [\"Monday\", \"Tuesday\", \"Wednesday\"]:\n        new_assignment = assignment.copy()\n        new_assignment[var] = value\n        if consistent(new_assignment):\n            result = backtrack(new_assignment)\n            if result is not None:\n                return result\n    return None\n\ndef selectUnassignedVariable(assignment):\n    \"\"\"Chooses a variable not yet assigned, in order.\"\"\"\n    for variable in VARIABLES:\n        if variable not in assignment:\n            return variable\n    return None\n\ndef consistent(assignment):\n    \"\"\"Checks to see if an assignment is consistent.\"\"\"\n    for (x, y) in CONSTRAINTS:\n        if x not in assignment or y not in assignment:\n            continue\n        if assignment[x] == assignment[y]:\n            return False\n    return True\n\n# main function\ndef main_solution(initial_assignment=None):\n    \"\"\"\n    Solves the exam scheduling problem using backtracking search.\n    \n    Parameters:\n    initial_assignment (dict): A dictionary where keys are course names (str) and values are exam days (str).\n    \n    Returns:\n    dict: A dictionary where keys are course names (str) and values are exam days (str).\n    \"\"\"\n    if initial_assignment is None:\n        initial_assignment = {}\n    solution = backtrack(initial_assignment)\n    return solution", "input_generator": "import random\n\ndef input_generator():\n    variables = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\"]\n    initial_assignment = {}\n    num_assigned = random.randint(0, 3)  # Assign 0 to 3 variables initially\n    assigned_vars = random.sample(variables, num_assigned)\n    for var in assigned_vars:\n        initial_assignment[var] = random.choice(days)\n    return {\"initial_assignment\": initial_assignment}", "io_pairs": [{"input": {"initial_assignment": {}}, "output": {"A": "Monday", "B": "Tuesday", "C": "Wednesday", "D": "Wednesday", "E": "Monday", "F": "Tuesday", "G": "Wednesday"}}, {"input": {"initial_assignment": {"F": "Wednesday", "G": "Tuesday", "C": "Tuesday"}}, "output": {"F": "Wednesday", "G": "Tuesday", "C": "Tuesday", "A": "Monday", "B": "Wednesday", "D": "Tuesday", "E": "Monday"}}, {"input": {"initial_assignment": {"F": "Tuesday"}}, "output": {"F": "Tuesday", "A": "Monday", "B": "Tuesday", "C": "Wednesday", "D": "Wednesday", "E": "Monday", "G": "Wednesday"}}, {"input": {"initial_assignment": {"F": "Wednesday", "C": "Monday"}}, "output": {"F": "Wednesday", "C": "Monday", "A": "Tuesday", "B": "Wednesday", "D": "Monday", "E": "Tuesday", "G": "Monday"}}, {"input": {"initial_assignment": {"E": "Tuesday"}}, "output": {"E": "Tuesday", "A": "Tuesday", "B": "Monday", "C": "Wednesday", "D": "Wednesday", "F": "Monday", "G": "Wednesday"}}, {"input": {"initial_assignment": {"E": "Wednesday"}}, "output": {"E": "Wednesday", "A": "Wednesday", "B": "Monday", "C": "Tuesday", "D": "Tuesday", "F": "Monday", "G": "Tuesday"}}, {"input": {"initial_assignment": {"B": "Monday", "G": "Tuesday", "A": "Wednesday"}}, "output": {"B": "Monday", "G": "Tuesday", "A": "Wednesday", "C": "Tuesday", "D": "Tuesday", "E": "Wednesday", "F": "Monday"}}, {"input": {"initial_assignment": {"G": "Tuesday", "F": "Wednesday"}}, "output": {"G": "Tuesday", "F": "Wednesday", "A": "Monday", "B": "Wednesday", "C": "Tuesday", "D": "Tuesday", "E": "Monday"}}, {"input": {"initial_assignment": {"F": "Wednesday"}}, "output": {"F": "Wednesday", "A": "Monday", "B": "Wednesday", "C": "Tuesday", "D": "Tuesday", "E": "Monday", "G": "Tuesday"}}, {"input": {"initial_assignment": {"D": "Wednesday"}}, "output": {"D": "Wednesday", "A": "Monday", "B": "Tuesday", "C": "Wednesday", "E": "Monday", "F": "Tuesday", "G": "Wednesday"}}], "error_log": []}
{"context": "In aviation, each aircraft is assigned a unique identifier known as the tail number. This identifier can be derived from the ICAO number, which is a unique number assigned to each aircraft by the International Civil Aviation Organization. Given an ICAO number, what is the corresponding tail number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `icao_number` (int): An integer representing the ICAO (International Civil Aviation Organization) number. This number should be within the range of 0xA00001 to 0xadf7c7.\n\nOutput:\n  `return` (str): A string representing the tail number corresponding to the given ICAO number. The tail number will start with 'N' followed by up to three digits and an optional two-character suffix.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nbase9 = '123456789'  # The first digit (after the \"N\") is always one of these.\nbase10 = '0123456789' # The possible second and third digits are one of these.\n# Note that \"I\" and \"O\" are never used as letters, to prevent confusion with \"1\" and \"0\"\nbase34 = 'ABCDEFGHJKLMNPQRSTUVWXYZ0123456789'\nicaooffset = 0xA00001 # The lowest possible number, N1, is this.\nb1 = 101711 # basis between N1... and N2...\nb2 = 10111 # basis between N10.... and N11....\n\ndef suffix(rem):\n    \"\"\" Produces the alpha(numeric) suffix from a number 0 - 950 \"\"\"\n    if rem == 0:\n        suf = ''\n    else:\n        if rem <= 600: #Class A suffix -- only letters.\n            rem = rem - 1\n            suf = base34[rem // 25]\n            if rem % 25 > 0:\n                suf = suf + base34[rem % 25 - 1]# second class A letter, if present.\n        else:  #rems > 600 : First digit of suffix is a number.  Second digit may be blank, letter, or number.\n            rem = rem - 601\n            suf = base10[rem // 35]\n            if rem % 35 > 0:\n                suf = suf + base34[rem % 35 - 1]\n    return suf\n\ndef enc_suffix(suf):\n    \"\"\" Produces a remainder from a 0 - 2 digit suffix.\n    No error checking.  Using illegal strings will have strange results.\"\"\"\n    if len(suf) == 0:\n        return 0\n    r0 = base34.find(suf[0])\n    if len(suf) == 1:\n        r1 = 0\n    else:\n        r1 = base34.find(suf[1]) + 1\n    if r0 < 24: # first char is a letter, use base 25\n        return r0 * 25 + r1 + 1\n    else:  # first is a number -- base 35.\n        return r0 * 35 + r1 - 239\n\ndef icao_to_tail(icao):\n    if (icao < 0) or (icao > 0xadf7c7):\n        return \"Undefined\"\n    icao = icao - icaooffset\n    d1 = icao // b1\n    nnum = 'N' + base9[d1]\n    r1 = icao % b1\n    if r1 < 601:\n        nnum = nnum + suffix(r1) # of the form N1ZZ\n    else:\n        d2 = (r1 - 601) // b2  # find second digit.\n        nnum = nnum + base10[d2]\n        r2 = (r1 - 601) % b2  # and residue after that\n        if r2 < 601:  # No third digit. (form N12ZZ)\n            nnum = nnum + suffix(r2)\n        else:\n            d3 = (r2 - 601) // 951 # Three-digits have extended suffix.\n            r3 = (r2 - 601) % 951\n            nnum = nnum + base10[d3] + suffix(r3)\n    return nnum\n\ndef tail_to_icao(tail):\n    if tail[0] != 'N':\n        return -1\n    icao = icaooffset\n    icao = icao + base9.find(tail[1]) * b1\n    if len(tail) == 2: # simple 'N3' etc.\n        return icao\n    d2 = base10.find(tail[2])\n    if d2 == -1: # Form N1A\n        icao = icao + enc_suffix(tail[2:4])\n        return icao\n    else: # Form N11... or N111..\n        icao = icao + d2 * b2 + 601\n        d3 = base10.find(tail[3])\n        if d3 > -1: #Form N111 Suffix is base 35.\n            icao = icao + d3 * 951 + 601\n            icao = icao + enc_suffix(tail[4:6])\n            return icao\n        else:  #Form N11A\n            icao = icao + enc_suffix(tail[3:5])\n            return icao\n\n# main function\ndef main_solution(icao_number):\n    # Convert ICAO number to tail number\n    tail_number = icao_to_tail(icao_number)\n    return tail_number", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random ICAO number within the valid range\n    icao_min = 0xA00001\n    icao_max = 0xADF7C7\n    icao_number = random.randint(icao_min, icao_max)\n    \n    return {'icao_number': icao_number}", "io_pairs": [{"input": {"icao_number": 10488814}, "output": "N1018U"}, {"input": {"icao_number": 10652006}, "output": "N2624Y"}, {"input": {"icao_number": 11324939}, "output": "N924LL"}, {"input": {"icao_number": 11347928}, "output": "N947H"}, {"input": {"icao_number": 10573617}, "output": "N186CJ"}, {"input": {"icao_number": 10707732}, "output": "N317ZC"}, {"input": {"icao_number": 11199899}, "output": "N801AG"}, {"input": {"icao_number": 10957676}, "output": "N563PZ"}, {"input": {"icao_number": 10672294}, "output": "N2826U"}, {"input": {"icao_number": 10653912}, "output": "N26442"}], "error_log": []}
{"context": "Given a dataset of discrete 1D data, what is the information entropy of the dataset after removing a random outlier, considering a specified number of neighbors to explore?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data` (list or numpy array): Input data to calculate information entropy. The data should be a 1D array-like structure containing numerical or categorical values.\n  `size` (int): Number of neighbors to explore. This should be an integer value less than or equal to the length of the data.\n\nOutput:\n  `return` (float): The information entropy of the dataset after removing a random outlier. The value is a float representing the entropy in base e.", "reference_code": "# import necessary packages\nimport random\nimport numpy as np\nfrom math import log, e\nimport pandas as pd\n\n# all class and function definitions in the code file, if any\nclass EntropyProblem:\n    \"\"\"\n    Calculate the information entropy for discrete 1D data. Works with\n    categorical or numerical datasets and takes array or dataframe as \n    input\n    \n    Parameters:\n    ----------\n    data : array-like\n        Input data to calculate information entropy\n        \n    size : int\n        Number of neighbors to explore\n        \n    \n    Attributes:\n    ----------\n    name : str, float, or int\n        Identifier for each neighbor successor. Set as None when\n        instantiating the initial problem. Is set automatically when\n        getting successors\n        \n    initial_state : int\n        Random seed to initialize successor selection from neighbors\n    \n    base : float\n        Information entropy of input data\n        \n    \"\"\"\n    \n    def __init__(self, data, size=20, name=None):\n        self.data = data\n        self.size = size\n        self.initial_state= np.random.choice(len(data))\n        self.name = name\n        self.__base = None\n        \n        \n    @property\n    def base(self):\n        \"\"\"Calculate information entropy of dataset in base e and set as \n           attribute\"\"\"\n        \n        self.__base = self.calc_entropy()\n        return self.__base\n    \n    \n    def calc_entropy(self):\n        \"\"\"Calculate information entropy of dataset in base e\"\"\"\n        n_labels = len(self.data)\n        \n        if n_labels <= 1:\n            return 0\n        \n        value, counts = np.unique(self.data, return_counts=True)\n        probs = counts/n_labels\n        n_classes = np.count_nonzero(probs)\n        \n        if n_classes <= 1:\n            return 0\n        \n        ent = 0.\n        \n        for i in probs:\n            ent -= i * log(i, e)\n        \n        return ent\n    \n    \n    def neighbors(self):\n        \"\"\"Gets range of neighbors surrounding initial state to create\n           successors\"\"\"\n        \n        \n        if self.size > len(self.data):\n            raise Exception('Size is too larget for data set.'\n                            'Set a value <= {}'.format(len(self.data)))\n        \n        # Set initial bounds of successor set\n        min_neighbor = self.initial_state - self.size\n        max_neighbor = self.initial_state + self.size\n        \n        # Ensure successor bounds fall within range of the actual data\n        if min_neighbor < 0:\n            min_value = 0\n        else:\n            min_value = min_neighbor\n            \n        if max_neighbor > len(self.data):\n            max_value = len(self.data)\n        else:\n            max_value = max_neighbor\n            \n        return range(min_value, max_value)\n    \n    \n    def get_successors(self):\n        \"\"\"\n        Generates set of successor EntropyProblem instances from the \n        neighborhood of the initial state, each with a unique neighbor \n        designated as an outlier and removed. The new information entropy is \n        recalculated as a property in each successor instance.\n\n        Returns\n        -------\n        Generator object of EntropyProblem successors\n\n        \"\"\"\n    \n        exists = set()\n        \n        for i in self.neighbors():\n            if isinstance(self.data, (pd.DataFrame, pd.Series)):\n                new_data = self.data.drop(index=i)\n                new_data = new_data.reset_index(drop=True)\n                value = self.data.loc[self.data.index==i].values.item()\n                \n            elif isinstance(self.data, np.ndarray):\n                new_data = np.delete(self.data, i)\n                value = self.data[i]\n                \n            if self.size <= len(new_data):\n                size = self.size\n            else:\n                size = len(new_data)\n                \n            if value not in exists:\n                yield EntropyProblem(new_data, size=size, name=value)\n                exists.add(value)\n                \n                \n    def select_successor(self):\n        \"\"\"Returns a single successor at random from neighbors\"\"\"\n        \n        all_successors = self.get_successors()\n        successor = np.random.choice(list(all_successors))\n        \n        return successor\n\n# main function\ndef main_solution(data, size):\n    \"\"\"\n    Calculate the information entropy of a dataset after removing a random outlier.\n    \n    Parameters:\n    ----------\n    data : list or numpy array\n        Input data to calculate information entropy.\n    size : int\n        Number of neighbors to explore.\n        \n    Returns:\n    -------\n    float\n        The information entropy of the dataset after removing a random outlier.\n    \"\"\"\n    # Convert data to numpy array if it's a list\n    if isinstance(data, list):\n        data = np.array(data)\n    \n    # Create an instance of EntropyProblem\n    problem = EntropyProblem(data, size)\n    \n    # Select a random successor\n    successor = problem.select_successor()\n    \n    # Return the entropy of the successor\n    return successor.base", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    data_type = random.choice(['list', 'array', 'categorical'])\n    size_options = [5, 10, 20, 30, 50]\n    size = random.choice(size_options)\n    \n    if data_type == 'list':\n        data_length = random.randint(size + 1, 100)\n        data = [random.choice(['A', 'B', 'C', 'D']) for _ in range(data_length)]\n    elif data_type == 'array':\n        data_length = random.randint(size + 1, 100)\n        data = np.random.randint(0, 10, size=data_length)\n    else:  # categorical\n        data_length = random.randint(size + 1, 100)\n        categories = ['cat', 'dog', 'bird', 'fish', 'rabbit']\n        data = np.random.choice(categories, size=data_length)\n    \n    return {'data': data, 'size': size}", "io_pairs": [{"input": {"data": ["D", "B", "D", "C", "D", "D", "B", "D", "D", "B", "B", "D", "C", "D", "C", "B"], "size": 5}, "output": 1.0437570363314084}], "error_log": []}
{"context": "Given a function \\( f(x) = e^{-x^2} \\), what is the value of the nth derivative of this function evaluated at a specific point `x`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The degree of the derivative.\n  `x` (float): The value at which the derivative is evaluated.\n\nOutput:\n  `return` (float): The value of the nth derivative of the function \\( e^{-x^2} \\) evaluated at `x`.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy.special import comb\n\n# all class and function definitions in the code file, if any\ndef coefficient_n_i(n, i):\n    first_coef = 2 ** ((n - i) // 2)\n\n    multiplication = 1\n    for j in np.arange(1, (i - 1) + 1, 2):\n        multiplication *= (i - j)\n\n    return first_coef * multiplication\n\ndef exponent_n_derivative(n, x):\n    first_coef = 2 ** ((n + 1) // 2)\n\n    polynomial = 0\n    for i in np.arange(0, n + 1, 2):\n        sign = (-1) ** ((n + (i/2) % 2) % 2)\n        coef = comb(n, i, exact=True) * coefficient_n_i(n, i)\n        x_exp = x ** (n - i)\n\n        polynomial += sign * coef * x_exp\n\n    result = first_coef * polynomial * np.exp(-(x ** 2))\n    return result\n\n# main function\ndef main_solution(n, x):\n    # Convert input to appropriate types if necessary\n    n = int(n)\n    x = float(x)\n    \n    # Calculate the result using the provided functions\n    result = exponent_n_derivative(n, x)\n    \n    # Convert the result to a JSON serializable output\n    result = float(result)\n    \n    return result", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    n = random.choice([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    x = random.uniform(-5.0, 5.0)\n    return {'n': n, 'x': x}", "io_pairs": [{"input": {"n": 10, "x": -1.3486777582120557}, "output": -12233.75164613276}, {"input": {"n": 1, "x": 1.3576090677061545}, "output": -0.4298882077705666}, {"input": {"n": 1, "x": -1.41005455644853}, "output": 0.3861697360607928}, {"input": {"n": 7, "x": -4.425072664975991}, "output": 0.007067905172165954}, {"input": {"n": 0, "x": 0.041819088904027524}, "output": 0.9982526921261999}, {"input": {"n": 3, "x": -4.434552858432795}, "output": 1.8563844682196466e-06}, {"input": {"n": 0, "x": 1.096361860346608}, "output": 0.3005896213150549}, {"input": {"n": 2, "x": 0.012676608162282221}, "output": -1.9990359507399735}, {"input": {"n": 7, "x": 0.8678591356765253}, "output": -58.41570623870507}, {"input": {"n": 2, "x": 0.7103829057263154}, "output": 0.01121440542468704}], "error_log": []}
{"context": "Given a mathematical function `cos(x) - x^3 = 0`, how can we find an approximate root of this function using Newton's method, starting from a given initial guess `x0` and aiming for a specified level of accuracy?\n\nThe input and output requirements are as follows:\n\nInput:\n  `accuracy` (int): The number of decimal places to which the solution should be accurate.\n  `x0` (float): The initial guess for the root of the function.\n\nOutput:\n  `return` (float): The approximate root of the function `cos(x) - x^3 = 0` found using Newton's method.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(accuracy, x0):\n    # Convert accuracy to the required format for the newton function\n    eps = 10 ** (accuracy * -1)\n    \n    # Newton's method implementation\n    while abs((x0 - (f(x0) / ((f(x0 + 0.1) - f(x0)) / 0.1))) - x0) > eps:\n        x0 = x0 - (f(x0) / ((f(x0 + 0.1) - f(x0)) / 0.1))\n    \n    # Return the final value of x0, which is JSON serializable\n    return x0\n\n# Helper function f(x)\ndef f(x):\n    return math.cos(x) - x**3", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random accuracy between 1 and 10\n    accuracy = random.randint(1, 10)\n    \n    # Generate a random initial guess x0 within a reasonable range\n    # The function f(x) = cos(x) - x^3, so we want x0 to be in a range where the function behaves meaningfully\n    x0 = random.uniform(-2.0, 2.0)\n    \n    return {\n        'accuracy': accuracy,\n        'x0': x0\n    }", "io_pairs": [{"input": {"accuracy": 5, "x0": 0.5356264426114024}, "output": 0.8654756490347577}, {"input": {"accuracy": 10, "x0": -0.2432406308402375}, "output": 0.8654740331126964}, {"input": {"accuracy": 1, "x0": -0.9040251817428091}, "output": 0.9651952021927428}, {"input": {"accuracy": 2, "x0": -0.5491560907023656}, "output": 0.8713122064404755}, {"input": {"accuracy": 6, "x0": 0.9576605559079185}, "output": 0.8654741349191537}, {"input": {"accuracy": 9, "x0": -1.9972526958361332}, "output": 0.8654740332670507}, {"input": {"accuracy": 6, "x0": -1.8785541711743643}, "output": 0.8654741623235779}, {"input": {"accuracy": 3, "x0": 0.6139407385195348}, "output": 0.8660950333072147}, {"input": {"accuracy": 1, "x0": 1.351297841691613}, "output": 0.8965152711151886}, {"input": {"accuracy": 8, "x0": 1.3469945582417804}, "output": 0.8654740351277879}], "error_log": []}
{"context": "Given the preorder and inorder traversal sequences of a binary tree, what is the level order traversal sequence of the reconstructed binary tree? The level order traversal should represent each node's value as an integer, and the absence of a node should be represented by `None`.\n\nThe input and output requirements are as follows:\n\nInput:\n  `preorder` (list of int): The preorder traversal sequence of the binary tree.\n  `inorder` (list of int): The inorder traversal sequence of the binary tree.\n\nOutput:\n  `return` (list of int or None): The level order traversal sequence of the reconstructed binary tree. Each node's value is represented by an integer, and `None` represents the absence of a node.", "reference_code": "# import necessary packages\nimport queue\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# main function\ndef main_solution(preorder, inorder):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    def build_tree(preorder, inorder):\n        if not preorder or not inorder:\n            return None\n        root_val = preorder[0]\n        root = TreeNode(root_val)\n        root_index = inorder.index(root_val)\n        root.left = build_tree(preorder[1:root_index + 1], inorder[:root_index])\n        root.right = build_tree(preorder[root_index + 1:], inorder[root_index + 1:])\n        return root\n\n    root = build_tree(preorder, inorder)\n    \n    # Convert the tree to a list of values in level order traversal\n    def level_order_traversal(root):\n        if not root:\n            return []\n        result = []\n        q = queue.Queue()\n        q.put(root)\n        while not q.empty():\n            node = q.get()\n            if node:\n                result.append(node.val)\n                q.put(node.left)\n                q.put(node.right)\n            else:\n                result.append(None)\n        # Remove trailing None values\n        while result and result[-1] is None:\n            result.pop()\n        return result\n\n    return level_order_traversal(root)", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random size for the tree (between 1 and 10 nodes)\n    size = random.randint(1, 10)\n    \n    # Generate a random list of unique integers for the inorder traversal\n    inorder = random.sample(range(1, 100), size)\n    \n    # Generate a random permutation of the inorder list for the preorder traversal\n    preorder = inorder.copy()\n    random.shuffle(preorder)\n    \n    return {\n        'preorder': preorder,\n        'inorder': inorder\n    }", "io_pairs": [{"input": {"preorder": [11, 32], "inorder": [11, 32]}, "output": [11, null, 32]}, {"input": {"preorder": [93, 60], "inorder": [93, 60]}, "output": [93, null, 60]}, {"input": {"preorder": [63, 53], "inorder": [53, 63]}, "output": [63, 53]}, {"input": {"preorder": [23, 81, 79], "inorder": [23, 81, 79]}, "output": [23, null, 81, null, 79]}, {"input": {"preorder": [68, 5, 46], "inorder": [68, 46, 5]}, "output": [68, null, 5, 46]}, {"input": {"preorder": [9, 29, 98, 44], "inorder": [9, 29, 44, 98]}, "output": [9, null, 29, null, 98, 44]}, {"input": {"preorder": [88, 65, 76], "inorder": [88, 76, 65]}, "output": [88, null, 65, 76]}, {"input": {"preorder": [19], "inorder": [19]}, "output": [19]}, {"input": {"preorder": [95, 86, 66, 5], "inorder": [86, 95, 5, 66]}, "output": [95, 86, 66, null, null, 5]}, {"input": {"preorder": [25], "inorder": [25]}, "output": [25]}], "error_log": []}
{"context": "In the context of a 2-4 tree, a data structure that maintains balance by allowing each node to have between 2 and 4 children, we are interested in understanding how the tree grows when nodes are added randomly. Given a certain number of nodes to be added to the tree, what will be the final size of the tree and the proportion of the tree's size that each of its two main subtrees occupies?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_additions` (int): The number of nodes to add to the tree. This should be a positive integer.\n\nOutput:\n  `return` (dict): A dictionary with the following keys:\n    - `final_size` (int): The total number of nodes in the tree after all additions.\n    - `child_sizes` (list of float): A list containing two floats representing the proportion of the tree's size that each child subtree occupies.", "reference_code": "# import necessary packages\nimport random\nfrom math import log\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    def __init__(self, children):\n        self.size = sum([size(x) for x in children])\n        self.children = children\n\ndef split(n):\n    \"\"\"Split the 5-node n into a 2-node and 3-node.\n\n    n becomes a 2-node and we return a new 3-node.\n    \"\"\"\n    a = n.children\n    n.children = a[:2]\n    n.size = sum([size(x) for x in n.children])\n    return Node(a[2:])\n\ndef add(n):\n    \"\"\"Add a new node to the subtree rooted at n.\n\n    The position of the node is chosen uniformly at random from each \n    of the size(n) possible positions. (We exclude the leftmost position)\n    \"\"\"\n    if n is None: \n        return None\n    # Pick a random child (weighted by size).\n    i = random.randrange(size(n))\n    c = -1\n    while i >= 0:\n        c += 1\n        i -= size(n.children[c])\n\n    # Recursively add to this child.\n    child = add(n.children[c])\n    n.size += 1\n\n    # If return value is a new node, add it to our list of children.\n    if child is None or child is not n.children[c]:\n        n.children.insert(c+1, child)\n\n    # Split this node if it's too big.\n    if len(n.children) == 5:\n        return split(n)\n    return n\n\ndef size(n):\n    \"\"\"Return the size of the subtree rooted at n\"\"\"\n    if n is None:\n        return 1\n    return n.size\n\n# main function\ndef main_solution(num_additions):\n    \"\"\"Simulate the growth of a 2-4 tree by adding a specified number of nodes.\n\n    Args:\n        num_additions (int): The number of nodes to add to the tree.\n\n    Returns:\n        dict: A dictionary containing the final size of the tree and the sizes of its children.\n    \"\"\"\n    root = Node([None, None])\n    for _ in range(num_additions):\n        r = add(root)\n        if r is not root:\n            root = Node([root, r])\n    \n    n = size(root)\n    a = size(root.children[0]) / n\n    b = size(root.children[1]) / n\n    \n    return {\n        \"final_size\": n,\n        \"child_sizes\": [a, b]\n    }", "input_generator": "import random\n\ndef input_generator():\n    return {\n        \"num_additions\": random.randint(1, 1000)\n    }", "io_pairs": [{"input": {"num_additions": 165}, "output": {"final_size": 167, "child_sizes": [0.5508982035928144, 0.4491017964071856]}}, {"input": {"num_additions": 478}, "output": {"final_size": 480, "child_sizes": [0.3729166666666667, 0.3125]}}, {"input": {"num_additions": 822}, "output": {"final_size": 824, "child_sizes": [0.375, 0.23179611650485438]}}, {"input": {"num_additions": 429}, "output": {"final_size": 431, "child_sizes": [0.3851508120649652, 0.6148491879350348]}}, {"input": {"num_additions": 720}, "output": {"final_size": 722, "child_sizes": [0.3476454293628809, 0.22853185595567868]}}, {"input": {"num_additions": 948}, "output": {"final_size": 950, "child_sizes": [0.2831578947368421, 0.3094736842105263]}}, {"input": {"num_additions": 258}, "output": {"final_size": 260, "child_sizes": [0.3269230769230769, 0.27692307692307694]}}, {"input": {"num_additions": 965}, "output": {"final_size": 967, "child_sizes": [0.15822130299896586, 0.29472595656670114]}}, {"input": {"num_additions": 199}, "output": {"final_size": 201, "child_sizes": [0.21393034825870647, 0.34328358208955223]}}, {"input": {"num_additions": 20}, "output": {"final_size": 22, "child_sizes": [0.36363636363636365, 0.22727272727272727]}}], "error_log": []}
{"context": "Given a number, what is the sequence of numbers obtained by repeatedly rotating its binary representation, where each rotation moves the last binary digit to the first position and shifts the other digits one step forward, until the number consists only of binary 1's?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num` (int): The number to generate the binary rotation sequence for.\n\nOutput:\n  `return` (list): A list of integers representing the binary rotation sequence.", "reference_code": "import math\n\ndef main_solution(num):\n    \"\"\"\n    Generates the binary rotation sequence for a given number.\n    \n    Args:\n    num (int): The number to generate the binary rotation sequence for.\n    \n    Returns:\n    list: A list of integers representing the binary rotation sequence.\n    \"\"\"\n    def rotate(num, numBits, mask):\n        if num & 1:\n            num = num >> 1\n            num = num | mask\n        else:\n            num = num >> 1\n        return num\n\n    def oneMask(numBits):\n        mask = 1\n        for i in range(0, numBits - 1):\n            mask = (mask << 1) | 1\n        return mask\n\n    sequence = []\n    while True:\n        sequence.append(num)\n        numBits = int(math.floor(math.log(num, 2)) + 1)\n        mask = 1 << (numBits - 1)\n        if num ^ oneMask(numBits) == 0:\n            break\n        num = rotate(num, numBits, mask)\n    \n    return sequence", "input_generator": "import random\nimport math\n\ndef input_generator():\n    num_bits = random.randint(2, 10)\n    num = random.randint(2 ** (num_bits - 1), 2 ** num_bits - 1)\n    return {'num': num}", "io_pairs": [{"input": {"num": 28}, "output": [28, 14, 7]}, {"input": {"num": 11}, "output": [11, 13, 14, 7]}, {"input": {"num": 7}, "output": [7]}, {"input": {"num": 97}, "output": [97, 112, 56, 28, 14, 7]}, {"input": {"num": 725}, "output": [725, 874, 437, 474, 237, 246, 123, 125, 126, 63]}, {"input": {"num": 140}, "output": [140, 70, 35, 49, 56, 28, 14, 7]}, {"input": {"num": 14}, "output": [14, 7]}, {"input": {"num": 908}, "output": [908, 454, 227, 241, 248, 124, 62, 31]}, {"input": {"num": 135}, "output": [135, 195, 225, 240, 120, 60, 30, 15]}, {"input": {"num": 549}, "output": [549, 786, 393, 452, 226, 113, 120, 60, 30, 15]}], "error_log": []}
{"context": "Given a network represented by an undirected or directed connection matrix, what are the density, average clustering coefficient, and assortativity coefficient of the network? The assortativity coefficient should be calculated based on the specified type of correlation (undirected or directed).\n\nThe input and output requirements are as follows:\n\nInput:\n  `CIJ` (list of lists of ints): A square matrix representing the undirected or directed connection matrix of the network.\n  `flag` (int): An integer flag to specify the type of assortativity calculation:\n    - 0: undirected graph; degree/degree correlation\n    - 1: directed graph; out-degree/in-degree correlation\n    - 2: directed graph; in-degree/out-degree correlation\n    - 3: directed graph; out-degree/out-degree correlation\n    - 4: directed graph; in-degree/in-degree correlation\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `density` (float): The density of the network.\n    - `clustering_coefficient` (float): The average clustering coefficient of the network.\n    - `assortativity` (float): The assortativity coefficient of the network.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef density_und(CIJ):  # \u65e0\u5411\u7f51\u7edc\u7684\u5bc6\u5ea6\n    '''\n    Density is the fraction of present connections to possible connections.\n\n    Parameters\n    ----------\n    CIJ : NxN np.ndarray\n        undirected (weighted/binary) connection matrix\n\n    Returns\n    -------\n    kden : float\n        density\n    '''\n    n = len(CIJ)\n    k = np.size(np.where(np.triu(CIJ).flatten()))\n    kden = k / ((n * n - n) / 2)\n    return kden   # \u8fd4\u56de\u7684\u662f\u65e0\u5411\u7f51\u7edc\u7684\u5bc6\u5ea6\n\ndef clustering_coef_bu(G): # \u805a\u7c7b\u7cfb\u6570\n    '''\n    The clustering coefficient is the fraction of triangles around a node\n    (equiv. the fraction of nodes neighbors that are neighbors of each other).\n\n    Parameters\n    ----------\n    A : NxN np.ndarray\n        binary undirected connection matrix\n\n    Returns\n    -------\n    average : float\n        average clustering coefficient\n    '''\n    n = len(G)\n    C = np.zeros((n,))\n\n    for u in range(n):\n        V, = np.where(G[u, :])\n        k = len(V)\n        if k >= 2:  # degree must be at least 2\n            S = G[np.ix_(V, V)]\n            C[u] = np.sum(S) / (k * k - k)\n    average = np.average(C)\n    return average\n\ndef binarize(W, copy=True):\n    '''\n    Binarizes an input weighted connection matrix.  If copy is not set, this\n    function will *modify W in place.*\n\n    Parameters\n    ----------\n    W : NxN np.ndarray\n        weighted connectivity matrix\n    copy : bool\n        if True, returns a copy of the matrix. Otherwise, modifies the matrix\n        in place. Default value=True.\n\n    Returns\n    -------\n    W : NxN np.ndarray\n        binary connectivity matrix\n    '''\n    if copy:\n        W = W.copy()\n    W[W != 0] = 1\n    return W\n\ndef assortativity_bin(CIJ, flag=0):   # \u540c\u914d\u7cfb\u6570\n    '''\n    The assortativity coefficient is a correlation coefficient between the\n    degrees of all nodes on two opposite ends of a link. A positive\n    assortativity coefficient indicates that nodes tend to link to other\n    nodes with the same or similar degree.\n\n    Parameters\n    ----------\n    CIJ : NxN np.ndarray\n        binary directed/undirected connection matrix\n    flag : int\n        0 : undirected graph; degree/degree correlation\n        1 : directed graph; out-degree/in-degree correlation\n        2 : directed graph; in-degree/out-degree correlation\n        3 : directed graph; out-degree/out-degree correlation\n        4 : directed graph; in-degree/in-degreen correlation\n\n    Returns\n    -------\n    r : float\n        assortativity coefficient\n    '''\n    if flag == 0:  # undirected version\n        deg = degrees_und(CIJ)\n        i, j = np.where(np.triu(CIJ, 1) > 0)\n        K = len(i)\n        degi = deg[i]\n        degj = deg[j]\n    else:  # directed version\n        id, od, deg = degrees_dir(CIJ)\n        i, j = np.where(CIJ > 0)\n        K = len(i)\n\n        if flag == 1:\n            degi = od[i]\n            degj = id[j]\n        elif flag == 2:\n            degi = id[i]\n            degj = od[j]\n        elif flag == 3:\n            degi = od[i]\n            degj = od[j]\n        elif flag == 4:\n            degi = id[i]\n            degj = id[j]\n        else:\n            raise ValueError('Flag must be 0-4')\n\n    # compute assortativity\n    term1 = np.sum(degi * degj) / K\n    term2 = np.square(np.sum(.5 * (degi + degj)) / K)\n    term3 = np.sum(.5 * (degi * degi + degj * degj)) / K\n    r = (term1 - term2) / (term3 - term2)\n    return r\n\ndef degrees_und(CIJ):\n    '''\n    Node degree is the number of links connected to the node.\n\n    Parameters\n    ----------\n    CIJ : NxN np.ndarray\n        undirected binary/weighted connection matrix\n\n    Returns\n    -------\n    deg : Nx1 np.ndarray\n        node degree\n    '''\n    CIJ = binarize(CIJ, copy=True)  # ensure CIJ is binary\n    return np.sum(CIJ, axis=0)\n\ndef degrees_dir(CIJ):\n    '''\n    Node degree is the number of links connected to the node. The indegree\n    is the number of inward links and the outdegree is the number of\n    outward links.\n\n    Parameters\n    ----------\n    CIJ : NxN np.ndarray\n        directed binary/weighted connection matrix\n\n    Returns\n    -------\n    id : Nx1 np.ndarray\n        node in-degree\n    od : Nx1 np.ndarray\n        node out-degree\n    deg : Nx1 np.ndarray\n        node degree (in-degree + out-degree)\n    '''\n    CIJ = binarize(CIJ, copy=True)  # ensure CIJ is binary\n    id = np.sum(CIJ, axis=0)  # indegree = column sum of CIJ\n    od = np.sum(CIJ, axis=1)  # outdegree = row sum of CIJ\n    deg = id + od  # degree = indegree+outdegree\n    return id, od, deg\n\n# main function\ndef main_solution(CIJ, flag=0):\n    # Convert input to numpy array if it's not already\n    CIJ = np.array(CIJ)\n    \n    # Calculate density\n    density = density_und(CIJ)\n    \n    # Calculate clustering coefficient\n    clustering_coefficient = clustering_coef_bu(CIJ)\n    \n    # Calculate assortativity coefficient\n    assortativity = assortativity_bin(CIJ, flag)\n    \n    # Return results as a dictionary\n    return {\n        \"density\": density,\n        \"clustering_coefficient\": clustering_coefficient,\n        \"assortativity\": assortativity\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the size of the matrix (between 5 and 20)\n    n = random.randint(5, 20)\n    \n    # Generate a random undirected adjacency matrix\n    CIJ = np.random.randint(0, 2, size=(n, n))\n    CIJ = np.triu(CIJ) + np.triu(CIJ, 1).T  # Make it symmetric\n    \n    # Randomly choose flag (0 for undirected, others for directed)\n    flag = random.choice([0, 1, 2, 3, 4])\n    \n    return {\n        \"CIJ\": CIJ.tolist(),\n        \"flag\": flag\n    }", "io_pairs": [{"input": {"CIJ": [[1, 0, 0, 0, 1], [0, 1, 1, 1, 0], [0, 1, 0, 1, 1], [0, 1, 1, 0, 1], [1, 0, 1, 1, 1]], "flag": 3}, "output": {"density": 0.9, "clustering_coefficient": 1.2, "assortativity": -0.0465116279069748}}, {"input": {"CIJ": [[0, 1, 1, 1, 1], [1, 0, 1, 0, 1], [1, 1, 1, 1, 0], [1, 0, 1, 1, 0], [1, 1, 0, 0, 1]], "flag": 0}, "output": {"density": 1.0, "clustering_coefficient": 1.05, "assortativity": -0.4285714285714306}}, {"input": {"CIJ": [[1, 0, 1, 0, 0], [0, 1, 0, 1, 1], [1, 0, 1, 0, 1], [0, 1, 0, 0, 0], [0, 1, 1, 0, 0]], "flag": 1}, "output": {"density": 0.7, "clustering_coefficient": 0.9666666666666668, "assortativity": -0.48076923076923134}}, {"input": {"CIJ": [[0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 1, 0, 0, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 1]], "flag": 2}, "output": {"density": 0.6, "clustering_coefficient": 0.4, "assortativity": -9.992007221626425e-16}}, {"input": {"CIJ": [[0, 1, 1, 0, 1], [1, 1, 0, 1, 1], [1, 0, 1, 0, 1], [0, 1, 0, 1, 1], [1, 1, 1, 1, 1]], "flag": 2}, "output": {"density": 1.1, "clustering_coefficient": 1.1966666666666668, "assortativity": -0.1440677966101694}}, {"input": {"CIJ": [[1, 0, 1, 1, 0], [0, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 0, 1], [0, 1, 1, 1, 0]], "flag": 2}, "output": {"density": 1.0, "clustering_coefficient": 1.08, "assortativity": -0.22033898305084704}}, {"input": {"CIJ": [[0, 1, 1, 0, 0], [1, 0, 1, 0, 0], [1, 1, 1, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 1, 1]], "flag": 3}, "output": {"density": 0.6, "clustering_coefficient": 1.1333333333333333, "assortativity": 0.16666666666666585}}, {"input": {"CIJ": [[1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 1, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0]], "flag": 1}, "output": {"density": 0.5, "clustering_coefficient": 0.33333333333333337, "assortativity": -0.4318181818181823}}, {"input": {"CIJ": [[0, 0, 1, 0, 0], [0, 1, 0, 1, 1], [1, 0, 0, 0, 0], [0, 1, 0, 1, 1], [0, 1, 0, 1, 0]], "flag": 1}, "output": {"density": 0.6, "clustering_coefficient": 0.9333333333333332, "assortativity": 0.6875}}, {"input": {"CIJ": [[1, 0, 1, 0, 1], [0, 1, 1, 1, 1], [1, 1, 1, 0, 0], [0, 1, 0, 1, 0], [1, 1, 0, 0, 0]], "flag": 0}, "output": {"density": 0.9, "clustering_coefficient": 1.1833333333333333, "assortativity": -0.6666666666666676}}], "error_log": []}
{"context": "Given a set of points in a 2D plane, how can we identify and list all the line segments that contain more than 3 collinear points?\n\nThe input and output requirements are as follows:\n\nInput:\n  `points` (list of tuples): A list of tuples where each tuple represents a point with two float values (x, y).\n\nOutput:\n  `return` (list of lists of tuples): A list where each element is a list of tuples representing the points that form a line segment with more than 3 collinear points. Each tuple contains two float values (x, y).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass MergeSort:\n    def __init__(self, arr: list):\n        self.arr = arr\n    \n    def msort(self, how='low_to_high'):\n        if how == 'low_to_high':\n            return self.order(self.arr)\n        elif how == 'high_to_low':\n            sort_obj = HighToLow(self.arr)\n            return sort_obj.order(sort_obj.arr)\n            \n    def order(self, arr):\n        mid = len(arr) // 2 + 1\n        if mid < 2:\n            return arr\n        elif len(arr) == 2:\n            return self.merge([arr[0]], [arr[1]])\n        else:\n            arr1 = self.order(arr[0:mid])\n            arr2 = self.order(arr[mid:])\n            return self.merge(arr1, arr2)            \n    \n    def comparator(self, obj1, obj2):\n        return obj1 < obj2\n    \n    def merge(self, arr1, arr2):\n        new_arr = []\n        i = 0\n        j = 0\n        for x in range(0, (len(arr1) + len(arr2))):\n            if self.comparator(arr1[i], arr2[j]):\n                new_arr.append(arr1[i])\n                if (i + 1) < len(arr1):\n                    i += 1\n                else:\n                    new_arr += arr2[j:]\n                    break\n            else:\n                new_arr.append(arr2[j])\n                if (j + 1) < len(arr2):\n                    j += 1\n                else:\n                    new_arr += arr1[i:]\n                    break\n        return new_arr\n\nclass HighToLow(MergeSort):\n    def comparator(self, obj1, obj2):\n        return obj1 > obj2\n\nclass MergeSortCoords(MergeSort):\n    def comparator(self, obj1, obj2):\n        if obj1[0] == obj2[0]:\n            return obj1[1] > obj2[1]\n        else:\n            return obj1[0] > obj2[0]\n\nclass MergeSortSlopes(MergeSort):\n    def __init__(self, arr: list, pt):\n        self.arr = arr\n        if type(pt) == tuple:\n            self.pt = Point(pt)\n        else:\n            self.pt = pt\n    \n    def comparator(self, obj1, obj2):\n        slope1 = self.pt.calcSlope(Point(obj1))\n        slope2 = self.pt.calcSlope(Point(obj2))\n        return slope1 < slope2\n\nclass Point:\n    def __init__(self, coords: tuple):\n        self.x = coords[0]\n        self.y = coords[1]\n    \n    def calcSlope(self, point):\n        if self.x == point.x and self.y != point.y:\n            return float('inf')\n        elif self.y == point.y and self.x == point.x:\n            return -float('inf')\n        return (self.y - point.y) / (self.x - point.x)\n\nclass LineSegment:\n    def __init__(self, pt1, pt2, pt3, pt4):\n        self.pts = [pt1, pt2, pt3, pt4]\n        self.slope = Point(pt1).calcSlope(Point(pt2))\n        \n    def addPoint(self, pt):\n        self.pts.append(pt)\n\ndef detectLines(pts):\n    lines = []\n    for i in pts:\n        line = None \n        pt = Point(i)\n        pts = MergeSortSlopes(pts, pt).msort()\n        for x in range(2, len(pts)):\n            if pts[x] == i:\n                pass\n            elif line:\n                if pt.calcSlope(Point(pts[x])) == line.slope:\n                    line.addPoint(pts[x])\n                else:\n                    if compareLineSlopes(lines, line):\n                        lines.append(line)\n                    line = None\n            else:\n                if pt.calcSlope(Point(pts[x])) == pt.calcSlope(Point(pts[x - 1])) \\\n                and pt.calcSlope(Point(pts[x])) == pt.calcSlope(Point(pts[x - 2])):\n                    line = LineSegment(i, pts[x-1], pts[x-2], pts[x])\n                if x == len(pts) - 1 and line:\n                    if compareLineSlopes(lines, line):\n                        lines.append(line)\n    return lines\n\ndef compareLineSlopes(lines, targetLine):\n    for line in lines:\n        if line.slope == targetLine.slope:\n            return False\n    targetLine.pts = MergeSortCoords(targetLine.pts).msort()\n    return True\n\n# main function\ndef main_solution(points):\n    # Convert input to JSON serializable format\n    points = [(float(p[0]), float(p[1])) for p in points]\n    \n    # Detect lines with more than 3 collinear points\n    lines = detectLines(points)\n    \n    # Convert output to JSON serializable format\n    result = []\n    for line in lines:\n        result.append([(float(p[0]), float(p[1])) for p in line.pts])\n    \n    return result", "input_generator": "import random\n\ndef input_generator():\n    num_points = random.randint(5, 20)\n    points = []\n    \n    # Generate some collinear points\n    num_collinear = random.randint(0, 2)\n    for _ in range(num_collinear):\n        x_start = random.uniform(-10, 10)\n        y_start = random.uniform(-10, 10)\n        x_step = random.uniform(-1, 1)\n        y_step = random.uniform(-1, 1)\n        collinear_count = random.randint(3, 5)\n        for i in range(collinear_count):\n            points.append((x_start + i * x_step, y_start + i * y_step))\n    \n    # Generate some random points\n    remaining_points = num_points - len(points)\n    for _ in range(remaining_points):\n        x = random.uniform(-10, 10)\n        y = random.uniform(-10, 10)\n        points.append((x, y))\n    \n    # Shuffle the points to mix collinear and random points\n    random.shuffle(points)\n    \n    return {'points': points}", "io_pairs": [{"input": {"points": [[2.3242480644675823, -2.0673761442781835], [-3.167095207038704, 5.8181962123960655], [-3.2656479444312296, 6.206315894405082], [6.634239286667814, 9.918339913823988], [-5.842562678260384, 5.7107415883076165], [-3.3642006818237546, 6.594435576414098]]}, "output": []}, {"input": {"points": [[-1.4438453433454796, -6.434750286796904], [-0.3617364066694524, 4.427245610509409], [4.623676552504142, 8.28565308463071], [-1.5470418739950844, 0.7551695545391564], [-8.519846586643219, -6.9083761815173155]]}, "output": []}, {"input": {"points": [[-4.476531926553397, 1.487359604466361], [7.94525059891874, 3.367615099645306], [8.040853858831955, -0.5742443738252483], [-3.9309624525309372, 5.570907579321908], [-2.7787831614846192, 4.633725020567962]]}, "output": []}, {"input": {"points": [[5.980122029845244, -2.2899692631771256], [7.816152007410853, 3.6543863916961055], [6.03496540851467, -1.4350982440095357], [6.14465216585352, 0.2746437943256441], [6.089808787184095, -0.5802272248419458]]}, "output": []}, {"input": {"points": [[-3.873878146201144, -4.579091030384868], [0.2602662266173752, -7.5205075587099435], [-6.6016061900502425, 2.9262421936195544], [5.708055189933372, 0.2699557823853773], [-9.179201226371722, -8.125008331542578]]}, "output": []}, {"input": {"points": [[-6.041520091843144, -3.670902635329849], [-5.278067675310464, -3.09668448553254], [-7.568424924908506, -4.819338934924467], [-6.9627965090015405, -6.900799893489136], [-6.804972508375824, -4.245120785127158]]}, "output": []}, {"input": {"points": [[1.1396262367627126, 4.2570568104874384], [1.4613943216938114, 4.514829919294401], [1.2468822650730789, 4.34298118008976], [1.3541382933834452, 4.428905549692081], [2.387289873732932, 3.7194364509631974]]}, "output": []}, {"input": {"points": [[-1.2785235014287615, -7.335207080855901], [1.1712329119469387, -6.591232540434191], [-0.7305565457599381, -8.257711218540917], [0.22033818309350028, -7.424471879487555], [-1.6814512746133765, -9.090950557594281], [9.468519769472778, -4.300833128692243]]}, "output": []}, {"input": {"points": [[-3.496206223839775, -0.49243907426592415], [-0.34161494671047343, -8.722872600001462], [-0.7087222136970226, 6.930898490993581], [9.215978357723166, -3.0507246173931746], [-2.8440831854305326, -8.270804906076783]]}, "output": []}, {"input": {"points": [[1.3042393612382508, 1.213027661322453], [0.7908345322983106, -2.440106227817804], [-8.433079164926411, 3.152120012799564], [8.458594353799977, 7.275301782518891], [8.098983486882897, -1.5285738179833874]]}, "output": []}], "error_log": []}
{"context": "Given the coordinates of two points on the Earth's surface, what is the great circle distance between them in kilometers? The coordinates are provided in decimal degrees for both latitude and longitude.\n\nThe input and output requirements are as follows:\n\nInput:\n  `lat1` (float): Latitude of the first point in decimal degrees.\n  `long1` (float): Longitude of the first point in decimal degrees.\n  `lat2` (float): Latitude of the second point in decimal degrees.\n  `long2` (float): Longitude of the second point in decimal degrees.\n\nOutput:\n  `return` (float): The distance between the two points in kilometers.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(lat1, long1, lat2, long2):\n    \"\"\"\n    Calculate the great circle distance between two points on the Earth's surface.\n\n    Parameters:\n    lat1 (float): Latitude of the first point in decimal degrees.\n    long1 (float): Longitude of the first point in decimal degrees.\n    lat2 (float): Latitude of the second point in decimal degrees.\n    long2 (float): Longitude of the second point in decimal degrees.\n\n    Returns:\n    float: The distance between the two points in kilometers.\n    \"\"\"\n    # Convert decimal degrees to radians\n    lat1, long1, lat2, long2 = map(math.radians, [lat1, long1, lat2, long2])\n\n    # Haversine formula\n    dlat = lat2 - lat1\n    dlong = long2 - long1\n\n    a = math.sin(dlat / 2) ** 2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlong / 2) ** 2\n    c = 2 * math.asin(math.sqrt(a))\n    # Radius in Kilometers, for Miles use 3956\n    r = 6371\n    return c * r", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random latitudes within -90 to 90 degrees\n    lat1 = random.uniform(-90, 90)\n    lat2 = random.uniform(-90, 90)\n    # Generate random longitudes within -180 to 180 degrees\n    long1 = random.uniform(-180, 180)\n    long2 = random.uniform(-180, 180)\n    \n    return {\n        'lat1': lat1,\n        'long1': long1,\n        'lat2': lat2,\n        'long2': long2\n    }", "io_pairs": [{"input": {"lat1": 43.77889752176725, "long1": -72.67172445085573, "lat2": 50.972933691111194, "long2": 43.946002137917105}, "output": 7839.375027266216}, {"input": {"lat1": 84.16993307651038, "long1": -121.6012111526681, "lat2": 31.551141102853165, "long2": 178.74031850685424}, "output": 6187.739905459113}, {"input": {"lat1": 42.65237174226252, "long1": -53.20685784750552, "lat2": 24.033900472833963, "long2": 149.93844458282825}, "output": 12229.27040126187}, {"input": {"lat1": 11.776143415958344, "long1": -162.3821363648706, "lat2": -74.27806461905645, "long2": 108.58553095952038}, "output": 11238.244829355239}, {"input": {"lat1": 74.06753724418206, "long1": 97.55821733749718, "lat2": 8.873299881668586, "long2": 35.33047686771792}, "output": 8234.62799719192}, {"input": {"lat1": -48.99237134522992, "long1": -24.870559276201448, "lat2": -29.841407886566913, "long2": -2.583168306625822}, "output": 2842.0884538279192}, {"input": {"lat1": 35.51437255493832, "long1": 42.969821879808535, "lat2": -19.313319962854933, "long2": -105.39061303064112}, "output": 16433.64684402105}, {"input": {"lat1": 38.60964917943366, "long1": -96.23504046430854, "lat2": 23.937265614731558, "long2": 95.46297726261662}, "output": 12954.13891237037}, {"input": {"lat1": 29.833575858755154, "long1": 13.45446464300349, "lat2": -38.667357604222275, "long2": 140.72244070924546}, "output": 15137.46115524494}, {"input": {"lat1": 79.20077940894606, "long1": -101.72958351102368, "lat2": -20.03537629026839, "long2": -0.8394501860979062}, "output": 12420.764405956796}], "error_log": []}
{"context": "Given two very large integers `a` and `b`, and a fixed prime number `m` (which is `1000000007`), what is the result of the modular division `(a / b) % m`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): The numerator in the division operation.\n  `b` (int): The denominator in the division operation.\n\nOutput:\n  `return` (int): The result of the modular division `(a / b) % m`, where `m` is a fixed prime number `1000000007`.", "reference_code": "# import necessary packages\n\n# main function\ndef main_solution(a, b):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    m = 1000000007\n    a = a % m\n    inv = pow(b, m - 2, m)\n    result = (inv * a) % m\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    m = 1000000007\n    b = random.randint(1, m - 1)\n    a = random.randint(0, m - 1)\n    return {'a': a, 'b': b}", "io_pairs": [{"input": {"a": 267968086, "b": 13940089}, "output": 738236918}, {"input": {"a": 857989429, "b": 142627792}, "output": 954037561}, {"input": {"a": 526803835, "b": 696497588}, "output": 825310286}, {"input": {"a": 524283291, "b": 775582819}, "output": 14987553}, {"input": {"a": 158457850, "b": 956729980}, "output": 233502510}, {"input": {"a": 509355145, "b": 453758927}, "output": 726671193}, {"input": {"a": 147401703, "b": 250227459}, "output": 568575626}, {"input": {"a": 366248206, "b": 745317557}, "output": 995798334}, {"input": {"a": 950633158, "b": 202565313}, "output": 842881062}, {"input": {"a": 281015461, "b": 100322703}, "output": 441068694}], "error_log": []}
{"context": "Given a chessboard of size `n` by `n`, how can you place `n` queens on the board such that no two queens threaten each other? Each solution should be represented as a configuration of the chessboard where 'Q' indicates the position of a queen and '.' indicates an empty space. What are the different possible configurations for the given `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (List[List[str]]): A list of solutions where each solution is a list of strings representing the chessboard configuration. Each string in the list represents a row on the chessboard, with 'Q' indicating the position of a queen and '.' indicating an empty space.", "reference_code": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        res = []\n        if n == 0:\n            return res\n        columns = [-1 for _ in range(n)]\n        self.dfs(n, 0, res, columns)\n        return res\n\n    def check(self, row, column, columns):\n        for i in range(row):\n            if column == columns[i] or row - i == abs(columns[i] - column):\n                return False\n        return True\n\n    def dfs(self, n, row, res, columns):\n        if row == n:\n            path = [\".\" * i + \"Q\" + \".\" * (len(columns) - 1 - i) for i in columns]\n            res.append(path)\n            return\n        for column in range(n):\n            if self.check(row, column, columns):\n                columns[row] = column\n                self.dfs(n, row + 1, res, columns)\n                columns[row] = -1\n\n# main function\ndef main_solution(n: int) -> List[List[str]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.solveNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.choice([1, 4, 5, 6, 7, 8])\n    return {'n': n}", "io_pairs": [{"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}, {"input": {"n": 1}, "output": [["Q"]]}], "error_log": []}
{"context": "Given a starting index, what is the first hexagonal number that is also both pentagonal and triangular, starting from that index?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start_index` (int): The starting index from which to begin generating hexagonal numbers. This index should be a positive integer.\n\nOutput:\n  `return` (int): The first hexagonal number that is also pentagonal and triangular, starting from the given `start_index`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef istriangular(number):\n    x = 0.5 * ((8 * number + 1) ** 0.5 - 1)\n    if x % 1 == 0:\n        return True\n    return False\n\ndef ispentagonal(number):\n    x = ((24 * number + 1) ** 0.5 + 1) / 6\n    if x % 1 == 0:\n        return True\n    return False\n\ndef ishexagonal(number):\n    x = 0.25 * ((8 * number + 1) ** 0.5 + 1)\n    if x % 1 == 0:\n        return True\n    return False\n\ndef generate_hexagonal(index):\n    number = index * (index * 2 - 1)\n    return number\n\n# main function\ndef main_solution(start_index):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    s = start_index\n    while True:\n        s += 1\n        number = generate_hexagonal(s)\n        if ispentagonal(number) and istriangular(number):\n            # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n            return number", "input_generator": "import random\n\ndef input_generator():\n    start_index = random.randint(1, 1000)\n    return {'start_index': start_index}", "io_pairs": [{"input": {"start_index": 842}, "output": 1533776805}, {"input": {"start_index": 553}, "output": 1533776805}, {"input": {"start_index": 794}, "output": 1533776805}, {"input": {"start_index": 703}, "output": 1533776805}, {"input": {"start_index": 778}, "output": 1533776805}, {"input": {"start_index": 320}, "output": 1533776805}, {"input": {"start_index": 350}, "output": 1533776805}, {"input": {"start_index": 222}, "output": 1533776805}, {"input": {"start_index": 126}, "output": 40755}, {"input": {"start_index": 346}, "output": 1533776805}], "error_log": []}
{"context": "Given an n x n grid representing an 8-puzzle, where the goal is to arrange the tiles in ascending order with the empty space (represented by 0) in the bottom-right corner, what is the minimum number of moves required to solve the puzzle starting from a randomly generated initial state? If no solution exists, return -1.\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_size` (int): The size of the board (n), where the board is an n x n grid.\n\nOutput:\n  `return` (int): The length of the shortest path to solve the 8-puzzle, or -1 if no solution is found.", "reference_code": "# import necessary packages\nimport random\nimport math\n\n# all class and function definitions in the code file, if any\ndef create(n):\n    s = list(range(n*n))\n    m = \"<>v^\"\n    for i in range(n*n*n):\n        if_legal(s, m[random.randrange(4)])\n    return [s, \"\"]\n\ndef if_legal(x, m):\n    n = int(math.sqrt(len(x)))\n    z = x.index(0)\n    if z % n > 0 and m == \"<\":\n        x[z], x[z-1] = x[z-1], x[z]\n    elif z % n < n-1 and m == \">\":\n        x[z], x[z+1] = x[z+1], x[z]\n    elif z >= n and m == \"^\":\n        x[z], x[z-n] = x[z-n], x[z]\n    elif z < n*n-n and m == \"v\":\n        x[z], x[z+n] = x[z+n], x[z]\n\ndef get_next(x):\n    ns = []\n    for i in \"<>v^\":\n        s = x[0][:]\n        if_legal(s, i)\n        if s.index(0) != x[0].index(0) and (x[1] == \"\" or x[1][-1] != \"><^v\"[\"<>v^\".index(i)]):\n            ns.append([s, x[1]+i])\n    return ns\n\ndef is_target(x):\n    n = len(x[0])\n    return x[0] == list(range(n))\n\n# main function\ndef main_solution(board_size):\n    # Generate a random board\n    initial_state = create(board_size)\n    \n    # Check if the initial state is already the target state\n    if is_target(initial_state):\n        return 0\n    \n    # Initialize the queue with the initial state\n    queue = [initial_state]\n    visited = set()\n    visited.add(tuple(initial_state[0]))\n    \n    # Perform a breadth-first search to find the shortest path to the target state\n    while queue:\n        current_state = queue.pop(0)\n        for next_state in get_next(current_state):\n            if tuple(next_state[0]) not in visited:\n                if is_target(next_state):\n                    return len(next_state[1])\n                queue.append(next_state)\n                visited.add(tuple(next_state[0]))\n    \n    # If no solution is found, return -1\n    return -1", "input_generator": "import random\n\ndef input_generator():\n    board_size = random.randint(2, 4)  # Reasonable size for the puzzle\n    return {'board_size': board_size}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a mathematical function \\( J_1(x) \\), which represents the Bessel function of the first kind of order 1, we need to find the minimum value of this function within a specified interval. What is the x-value of the minimum point within the given bounds?\n\nThe input and output requirements are as follows:\n\nInput:\n  `bounds` (list of float): A list containing two float values representing the lower and upper bounds of the interval within which the minimization is to be performed.\n\nOutput:\n  `return` (float): The x-value of the minimum point found within the specified bounds.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\nfrom scipy.special import j1\n\n# main function\ndef main_solution(bounds):\n  # Convert the JSON serializable input to the original input variables\n  bounds_tuple = tuple(bounds)\n  \n  # Perform the bounded minimization\n  res = minimize_scalar(j1, bounds=bounds_tuple, method='bounded')\n  \n  # Convert the result to a JSON serializable output\n  result = float(res.x)\n  \n  return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate random bounds within a reasonable range for the Bessel function j1\n    # The first zero of j1 is around 3.83, so we can generate bounds around that\n    lower = random.uniform(0, 5)\n    upper = random.uniform(lower + 0.1, 10)  # Ensure upper is greater than lower\n    return {'bounds': [lower, upper]}", "io_pairs": [{"input": {"bounds": [0.7187739585723668, 6.80866415080625]}, "output": 5.331441621237333}, {"input": {"bounds": [1.2811685486501878, 3.1849710127941737]}, "output": 3.1849673797319094}, {"input": {"bounds": [4.750734747221718, 5.873627296263936]}, "output": 5.331442761461343}, {"input": {"bounds": [1.8454373248212175, 9.587446338791736]}, "output": 5.331442366039128}, {"input": {"bounds": [2.283868611501039, 8.323821747117982]}, "output": 5.331443435087181}, {"input": {"bounds": [1.8722175213284498, 9.531714678166248]}, "output": 5.33144240716782}, {"input": {"bounds": [1.8970345807980626, 4.46405302789654]}, "output": 4.464047183190101}, {"input": {"bounds": [2.7799240357511437, 7.2358769310351825]}, "output": 5.331442759547945}, {"input": {"bounds": [2.6863724131798588, 5.185366800169368]}, "output": 5.185361110343258}, {"input": {"bounds": [3.6571575833319665, 4.287112411923549]}, "output": 4.287106336087544}], "error_log": []}
{"context": "Given a puzzle represented by a list of integers, where each integer represents a tile and 0 represents the empty space, determine whether the puzzle is solvable. The puzzle is considered solvable if it can be rearranged into a final state where the tiles are in ascending order with the empty space at the end. What is the solvability status of the given puzzle?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tiles` (list of integers): A list representing the initial state of the puzzle. The list should contain integers from 0 to n^2-1, where 0 represents the empty tile. The length of the list should be a perfect square (e.g., 9 for a 3x3 puzzle).\n\nOutput:\n  `return` (dictionary): A dictionary with a single key `\"is_solveable\"` which is a boolean indicating whether the puzzle is solvable.", "reference_code": "# import necessary packages\nimport math\nimport functools\nimport copy\n\n# all class and function definitions in the code file, if any\nclass Puzzle:\n    def __init__(self, tiles):\n        self._tiles = tiles\n        self.tiles = copy.deepcopy(self._tiles)\n        self.length = len(tiles)\n        self.n = int(math.sqrt(self.length))\n        self._solveable = self._solveable()\n        self.fs_tiles = list(range(1, self.length))\n        self.fs_tiles.append(0)\n\n    def solveable(self):\n        return self._solveable\n\n    def _solveable(self):\n        perms = self._permutations()\n        if perms == 0:\n            return False\n        else:\n            if self.n % 2 == 1:\n                if perms % 2 == 0:\n                    return True\n                else:\n                    return False\n            else:\n                zindex = self.tiles.index(0)\n                row = (self.n) - (zindex // self.n)\n                if perms % 2 == 0:\n                    if row % 2 == 0:\n                        return False\n                    else:\n                        return True\n                else:\n                    if row % 2 == 0:\n                        return True\n                    else:\n                        return False\n\n    def _permutations(self):\n        i = 0\n        perms = 0\n        zindex = self.tiles.index(0)\n        self.tiles.remove(0)\n\n        while i < self.length - 1:\n            num = self.tiles[i]\n            for x in self.tiles[i:]:\n                if num > x:\n                    perms += 1\n            i += 1\n\n        self.tiles.insert(zindex, 0)\n        return perms\n\n    @classmethod\n    def equal_tiles(cls, tiles1, tiles2):\n        if functools.reduce(lambda x, y: x and y, map(lambda n1, n2: n1 == n2, tiles1, tiles2), True):\n            return True\n        else:\n            return False\n\n    def final_state(self):\n        if Puzzle.equal_tiles(self.tiles, self.fs_tiles):\n            self._solveable = True\n            return True\n        else:\n            return False\n\n    def _move(self, zindex, index):\n        self.tiles[zindex] = self.tiles[index]\n        self.tiles[index] = 0\n\n    def move_down(self):\n        zindex = self.tiles.index(0)\n        index = zindex + self.n\n        if index <= self.length - 1:\n            self._move(zindex, index)\n\n    def move_up(self):\n        zindex = self.tiles.index(0)\n        index = zindex - self.n\n        if index >= 0:\n            self._move(zindex, index)\n\n    def move_right(self):\n        zindex = self.tiles.index(0)\n        index = zindex + 1\n        if (index % self.n) != 0:\n            self._move(zindex, index)\n\n    def move_left(self):\n        zindex = self.tiles.index(0)\n        index = zindex - 1\n        if zindex != 0:\n            if (zindex % self.n) != 0:\n                self._move(zindex, index)\n\n# main function\ndef main_solution(tiles):\n    puzzle = Puzzle(tiles)\n    is_solveable = puzzle.solveable()\n    return {\"is_solveable\": is_solveable}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.choice([2, 3, 4])  # Choose a reasonable puzzle size (2x2, 3x3, or 4x4)\n    length = n * n\n    tiles = list(range(length))\n    random.shuffle(tiles)\n    \n    # Ensure the puzzle is solvable by checking permutations and zero position\n    puzzle = Puzzle(tiles.copy())\n    while not puzzle.solveable():\n        random.shuffle(tiles)\n        puzzle = Puzzle(tiles.copy())\n    \n    return {\"tiles\": tiles}", "io_pairs": [{"input": {"tiles": [1, 4, 2, 6, 0, 8, 7, 5, 3]}, "output": {"is_solveable": true}}, {"input": {"tiles": [8, 14, 4, 15, 2, 5, 1, 11, 6, 13, 7, 10, 0, 3, 9, 12]}, "output": {"is_solveable": true}}, {"input": {"tiles": [0, 2, 1, 3]}, "output": {"is_solveable": true}}, {"input": {"tiles": [8, 3, 7, 5, 1, 2, 6, 0, 4]}, "output": {"is_solveable": true}}, {"input": {"tiles": [14, 5, 4, 6, 7, 10, 3, 8, 11, 15, 12, 1, 0, 9, 13, 2]}, "output": {"is_solveable": true}}, {"input": {"tiles": [1, 0, 3, 2]}, "output": {"is_solveable": true}}, {"input": {"tiles": [3, 2, 4, 1, 8, 7, 0, 6, 5]}, "output": {"is_solveable": true}}, {"input": {"tiles": [4, 7, 0, 6, 8, 3, 2, 5, 1]}, "output": {"is_solveable": true}}, {"input": {"tiles": [11, 0, 8, 2, 3, 12, 6, 1, 14, 7, 15, 10, 13, 5, 4, 9]}, "output": {"is_solveable": true}}, {"input": {"tiles": [3, 0, 2, 1]}, "output": {"is_solveable": true}}], "error_log": []}
{"context": "Given a random variable with four possible outcomes, each associated with a specific probability and expected value, what is the expected value of this random variable?\n\nThe input and output requirements are as follows:\n\nInput:\n  `probabilities` (list of float): A list of probabilities corresponding to each possible outcome. The sum of probabilities should be 1.\n  `expected_values` (list of float): A list of expected values corresponding to each possible outcome.\n\nOutput:\n  `return` (float): The expected value of the random variable.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(probabilities, expected_values):\n    \"\"\"\n    Calculate the expected value of a random variable based on given probabilities and expected values.\n\n    Parameters:\n    probabilities (list of float): A list of probabilities corresponding to each possible outcome.\n    expected_values (list of float): A list of expected values corresponding to each possible outcome.\n\n    Returns:\n    float: The expected value of the random variable.\n    \"\"\"\n    # Calculate the expected value\n    expected_value = sum(p * v for p, v in zip(probabilities, expected_values))\n    \n    return expected_value", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Random number of outcomes between 1 and 10\n    probabilities = [random.random() for _ in range(n)]\n    # Normalize probabilities to sum to 1\n    total = sum(probabilities)\n    probabilities = [p / total for p in probabilities]\n    expected_values = [random.uniform(-100, 100) for _ in range(n)]\n    return {\n        'probabilities': probabilities,\n        'expected_values': expected_values\n    }", "io_pairs": [{"input": {"probabilities": [0.05387306998770981, 0.17005654026523034, 0.11558560399448295, 0.2184272509177717, 0.01753715323800726, 0.14009389578845188, 0.284426485808346], "expected_values": [-49.74332859606554, 54.18078835638727, 69.55972665220543, 94.163117238539, 75.17661639807989, -6.29036965008703, -22.43243170456512]}, "output": 29.19862918249332}, {"input": {"probabilities": [0.08222450355751858, 0.38435512666356547, 0.0413647305178008, 0.15611084776417283, 0.33594479149694234], "expected_values": [-70.53067163174653, 69.97709159984294, 69.18444871680623, 71.61525694700418, -75.30020101246282]}, "output": 9.84170866813636}, {"input": {"probabilities": [0.23090512258142096, 0.15884135506224717, 0.18110732940594937, 0.14080844406338947, 0.17322190884566968, 0.11511584004132337], "expected_values": [56.63717269524503, 58.6175009226919, -21.2941213322365, -15.615579690227264, 33.6570047827916, -40.64779745229412]}, "output": 17.484294919879787}, {"input": {"probabilities": [0.18918766334378434, 0.1426999350799255, 0.0022317245284858415, 0.2096101424189949, 0.21295479649088478, 0.24331573813792465], "expected_values": [-67.67872728013317, -76.53154380430844, 80.68503221998992, -88.4203651599072, -78.10364695007522, -67.48582199319651]}, "output": -75.13167400663994}, {"input": {"probabilities": [0.14221100813781654, 0.3083407730485872, 0.10340249569127427, 0.16118617626309995, 0.07103695860026438, 0.08760771437237494, 0.1262148738865827], "expected_values": [73.67602648339613, 70.54412122114599, -69.12970603073809, 65.12270354331179, -88.68690237844254, -86.82960802309042, -18.73038250247008]}, "output": 19.30682213844103}, {"input": {"probabilities": [0.33610428254776914, 0.014430528465918148, 0.045366047345581556, 0.3585415415283705, 0.1305721585499025, 0.11498544156245817], "expected_values": [-64.21144999647498, -24.11896526544585, -91.50507352150672, 76.68958858764361, 83.64338699910132, 77.42165601243951]}, "output": 21.239247958388603}, {"input": {"probabilities": [0.25542747549244776, 0.12087256031183155, 0.0044678432451886255, 0.1992919112721256, 0.08310804890997855, 0.046836640424607445, 0.05470430440168177, 0.23529121594213862], "expected_values": [-11.396568629083077, -19.021685726420998, -51.18354676267622, 48.738479546942415, -97.10620532916339, 2.7434248151950698, -42.45129614814418, -0.7133284935968192]}, "output": -6.1576149473793915}, {"input": {"probabilities": [0.8046324562475089, 0.1953675437524911], "expected_values": [90.17049457949156, -74.00674949896813]}, "output": 58.09558966382967}, {"input": {"probabilities": [0.2612169989677858, 0.34818498027720174, 0.09086423221579054, 0.08996775145374464, 0.20976603708547734], "expected_values": [-25.976258101897628, 47.53481503598255, -79.01076469623052, -14.6362218554289, 90.88338231546072]}, "output": 20.333674954215667}, {"input": {"probabilities": [0.2917737007557966, 0.1771737214915392, 0.18151191102385386, 0.34954066672881023], "expected_values": [60.20478474832973, -15.184403839222142, -7.421200867010285, 17.28281751878859]}, "output": 19.569906719407708}], "error_log": []}
{"context": "Given a string of characters, what are all the possible unique permutations of the characters in the string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string of characters for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the characters in the input string.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all permutations of the characters\n    permutations = [''.join(p) for p in itertools.permutations(char_list)]\n    \n    # Convert the list of permutations to a JSON serializable format\n    return permutations", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    input_string = ''.join(random.choices(string.ascii_letters, k=length))\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "c"}, "output": ["c"]}, {"input": {"input_string": "IAl"}, "output": ["IAl", "IlA", "AIl", "AlI", "lIA", "lAI"]}, {"input": {"input_string": "HA"}, "output": ["HA", "AH"]}, {"input": {"input_string": "C"}, "output": ["C"]}, {"input": {"input_string": "dD"}, "output": ["dD", "Dd"]}, {"input": {"input_string": "yCQ"}, "output": ["yCQ", "yQC", "CyQ", "CQy", "QyC", "QCy"]}, {"input": {"input_string": "k"}, "output": ["k"]}, {"input": {"input_string": "dDh"}, "output": ["dDh", "dhD", "Ddh", "Dhd", "hdD", "hDd"]}, {"input": {"input_string": "mxx"}, "output": ["mxx", "mxx", "xmx", "xxm", "xmx", "xxm"]}, {"input": {"input_string": "SW"}, "output": ["SW", "WS"]}], "error_log": []}
{"context": "In a tragic event, a group of people decide to commit suicide in a peculiar manner. They form a circle and proceed around the circle, with every \"mth\" person committing suicide one after another. Given the number of people and the step count, what is the order in which they will commit suicide?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of people. It should be a positive integer.\n  `m` (int): The step count for each suicide. It should be a positive integer.\n\nOutput:\n  `return` (str): A string representing the order in which people commit suicide, with each number separated by a space.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(n, m):\n    \"\"\"\n    This function calculates the order in which people commit suicide based on the Josephus problem.\n    \n    Parameters:\n    n (int): The number of people.\n    m (int): The step count for each suicide.\n    \n    Returns:\n    str: A string representing the order in which people commit suicide, with each number separated by a space.\n    \"\"\"\n    a = list(range(1, n + 1))  # List of people, starting from 1 to n\n    s = \"\"\n    i = 0\n\n    while len(a) > 0:\n        i = (i + m - 1) % len(a)\n        s += str(a[i]) + \" \"\n        a.remove(a[i])\n    \n    return s.strip()  # Remove trailing space", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 100)\n    m = random.randint(1, n) if n > 1 else 1\n    return {'n': n, 'm': m}", "io_pairs": [{"input": {"n": 4, "m": 2}, "output": "2 4 3 1"}, {"input": {"n": 15, "m": 2}, "output": "2 4 6 8 10 12 14 1 5 9 13 3 11 7 15"}, {"input": {"n": 21, "m": 7}, "output": "7 14 21 8 16 3 12 1 11 2 15 6 20 18 17 19 5 13 4 9 10"}, {"input": {"n": 24, "m": 7}, "output": "7 14 21 4 12 20 5 15 24 10 22 9 23 13 3 19 17 16 18 2 11 1 6 8"}, {"input": {"n": 5, "m": 4}, "output": "4 3 5 2 1"}, {"input": {"n": 9, "m": 3}, "output": "3 6 9 4 8 5 2 7 1"}, {"input": {"n": 2, "m": 1}, "output": "1 2"}, {"input": {"n": 28, "m": 23}, "output": "23 18 14 11 9 8 10 13 17 22 28 6 21 4 25 16 12 15 24 3 1 5 27 19 2 20 26 7"}, {"input": {"n": 36, "m": 31}, "output": "31 26 22 19 17 16 18 21 25 30 36 6 13 29 5 23 4 28 12 8 3 7 11 27 9 35 1 15 10 24 32 33 14 20 34 2"}, {"input": {"n": 31, "m": 26}, "output": "26 21 17 14 12 11 13 16 20 25 31 6 19 1 15 3 27 22 18 24 2 10 8 23 5 9 28 30 7 4 29"}], "error_log": []}
{"context": "Given a number `n` and a number of iterations `k`, determine the results of the Fermat and Miller-Rabin primality tests for `n`. What are the outcomes of these tests?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number to be tested for primality.\n  `k` (int): The number of iterations to run the primality test.\n\nOutput:\n  `return` (dict): A dictionary containing the results of the Fermat and Miller-Rabin primality tests.\n    - `fermat_result` (str): The result of the Fermat primality test, either 'prime' or 'composite'.\n    - `miller_rabin_result` (str): The result of the Miller-Rabin primality test, either 'prime' or 'composite'.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef mod_exp(x, y, n):  # O(n^3)\n    if y == 0:  # If you raise anything to the 0 power the answer is 1\n        return 1  # O(1)\n\n    z = mod_exp(x, y // 2, n)  # Recursively set z and floor y\n\n    if y % 2 == 0:  # Check if y is even\n        return (z ** 2) % n  # O(n^2)\n    else:  # y is odd\n        return (x * (z ** 2)) % n  # O(n^2)\n\ndef fprobability(k):\n    return 1 - (1 / (2 ** k))  # Probability of error algorithm\n\ndef mprobability(k):\n    return 1 - (0.25 ** k)  # Probability we are wrong, subtracted from 100%\n\ndef run_fermat(n, k):  # O(n^4)\n    if n == 1 or n == 0:  # O(1)\n        return 'composite'\n\n    for i in range(0, k):  # Here we assume k is equal to n bits\n        a = random.randint(1, n - 1)  # O(1)\n        mod = mod_exp(a, n - 1, n)  # O(n^3) for one loop\n        if mod != 1:  # O(1)\n            return 'composite'  # Number is not prime\n    return 'prime'  # Number is prime\n\ndef run_miller_rabin(n, k):  # O(n^5)\n    if n == 1 or n == 0:  # O(1)\n        return 'composite'\n    elif n == 2:  # O(1)\n        return 'prime'\n\n    for i in range(0, k):  # Here we assume k is equal to n bits\n        a = random.randint(1, n - 1)  # O(1)\n        exp = n - 1  # O(n)\n        mod = 1  # O(1)\n\n        while mod == 1:\n            if exp == 1 or exp == 0:  # If the exponent is 0 or 1 break out of the loop\n                break\n            mod = mod_exp(a, exp, n)  # O(n^4)\n            exp = exp // 2  # Cut the exponent in half and floor it\n\n            if mod != -1 and mod != 1:  # Check the result of modular exponentiation\n                mod = mod - n  # Adjust accordingly\n\n            if exp % 2 != 0:  # Check to see if the exponent is even or odd and break accordingly\n                break\n        if mod != -1 and mod != 1:  # Finally, if our result is not 1 or -1, the number is not prime\n            return 'composite'  # Number is not prime\n    return 'prime'  # Number is prime\n\n# main function\ndef main_solution(n, k):\n    # Convert JSON serializable inputs to the original input variables\n    n = int(n)\n    k = int(k)\n    \n    # Run the prime test algorithms\n    fermat_result = run_fermat(n, k)\n    miller_rabin_result = run_miller_rabin(n, k)\n    \n    # Convert the results to JSON serializable outputs\n    result = {\n        \"fermat_result\": fermat_result,\n        \"miller_rabin_result\": miller_rabin_result\n    }\n    \n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random number n, which could be prime or composite\n    # We'll sometimes pick known primes and sometimes random numbers\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    composites = [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38, 39, 40, 42, 44, 45, 46, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 60, 62, 63, 64, 65, 66, 68, 69, 70, 72, 74, 75, 76, 77, 78, 80, 81, 82, 84, 85, 86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 98, 99, 100]\n    \n    if random.random() < 0.5:\n        n = random.choice(primes + composites)\n    else:\n        n = random.randint(2, 100)\n    \n    # Generate a reasonable k (number of iterations)\n    k = random.randint(1, 10)\n    \n    return {\"n\": n, \"k\": k}", "io_pairs": [{"input": {"n": 67, "k": 7}, "output": {"fermat_result": "prime", "miller_rabin_result": "prime"}}, {"input": {"n": 13, "k": 3}, "output": {"fermat_result": "prime", "miller_rabin_result": "prime"}}, {"input": {"n": 100, "k": 7}, "output": {"fermat_result": "composite", "miller_rabin_result": "composite"}}, {"input": {"n": 37, "k": 3}, "output": {"fermat_result": "prime", "miller_rabin_result": "prime"}}, {"input": {"n": 50, "k": 4}, "output": {"fermat_result": "composite", "miller_rabin_result": "composite"}}, {"input": {"n": 87, "k": 6}, "output": {"fermat_result": "composite", "miller_rabin_result": "composite"}}, {"input": {"n": 29, "k": 2}, "output": {"fermat_result": "prime", "miller_rabin_result": "prime"}}, {"input": {"n": 96, "k": 5}, "output": {"fermat_result": "composite", "miller_rabin_result": "composite"}}, {"input": {"n": 5, "k": 4}, "output": {"fermat_result": "prime", "miller_rabin_result": "prime"}}, {"input": {"n": 13, "k": 7}, "output": {"fermat_result": "prime", "miller_rabin_result": "prime"}}], "error_log": []}
{"context": "Imagine you are on a ferry waiting area with a seating layout that consists of empty seats (`L`), occupied seats (`#`), and floor spaces (`.`). The seating arrangement follows specific rules where empty seats become occupied if no adjacent seats are occupied, and occupied seats become empty if four or more adjacent seats are occupied. The process continues until no seats change state. Given an initial seating layout, how many seats will be occupied when the seating system reaches equilibrium?\n\nThe input and output requirements are as follows:\n\nInput:\n  `seat_layout` (str): A string representing the initial layout of seats. Each line in the string represents a row of seats, and each character in the line represents a seat ('L' for empty, '#' for occupied, and '.' for floor).\n\nOutput:\n  `return` (int): The number of occupied seats after the seating system reaches equilibrium.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef parse_input(seat_layout):\n    \"\"\"\n    Parse input string, returning 2D array of seats\n    \"\"\"\n    lines = seat_layout.splitlines()\n    seat_list = [['.' for _ in range(len(lines[0]) + 2)]]\n    \n    for line in lines:\n        row_seats = ['.']\n        for letter in line:\n            row_seats.append(letter)\n        row_seats.append('.')\n        seat_list.append(row_seats)\n    \n    seat_list.append(['.' for _ in range(len(lines[0]) + 2)])\n    \n    return np.array(seat_list)\n\ndef count_occupied_seats(all_seats, x, y):\n    \"\"\"\n    Count occupied seats adjacent to the one supplied\n    \"\"\"\n    seat = all_seats[y][x]\n    \n    y_min = max(0, y - 1)\n    y_max = min(len(all_seats), y + 2)\n    x_min = max(0, x - 1)\n    x_max = min(len(all_seats[0]), x + 2)\n    \n    section = all_seats[y_min:y_max, x_min:x_max].copy()\n    \n    # Make center seat empty so it's not counted\n    section[1, 1] = '.'\n    \n    count = (section == '#').sum()\n    \n    return count\n\n# main function\ndef main_solution(seat_layout):\n    \"\"\"\n    Simulate the seating system until equilibrium is reached and return the number of occupied seats.\n    \n    Input:\n    seat_layout (str): A string representing the initial layout of seats.\n    \n    Output:\n    int: The number of occupied seats after the seating system reaches equilibrium.\n    \"\"\"\n    cur_seats = parse_input(seat_layout)\n    \n    while True:\n        seats = cur_seats.copy()\n        \n        for y in range(1, len(seats) - 1):\n            for x in range(1, len(seats[0]) - 1):\n                seat = cur_seats[y][x]\n                \n                if seat == '.':\n                    continue\n                \n                occupied = count_occupied_seats(cur_seats, x, y)\n                \n                if seat == 'L' and occupied == 0:\n                    seats[y][x] = '#'\n                elif seat == '#' and occupied >= 4:\n                    seats[y][x] = 'L'\n        \n        if np.array_equal(cur_seats, seats):\n            break\n        \n        cur_seats = seats.copy()\n    \n    count = 0\n    for y in range(len(cur_seats)):\n        count += ''.join(cur_seats[y]).count('#')\n    \n    return count", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    rows = random.randint(5, 15)\n    cols = random.randint(5, 15)\n    seat_chars = ['L', '.']\n    seat_layout = []\n    for _ in range(rows):\n        row = ''.join([random.choice(seat_chars) for _ in range(cols)])\n        seat_layout.append(row)\n    seat_layout_str = '\\n'.join(seat_layout)\n    return {'seat_layout': seat_layout_str}", "io_pairs": [{"input": {"seat_layout": ".L..L.L.LL.L.\nLL.L...LLL...\n..L.L..LLLLLL\nLL.L..LL..L..\n....L..L.L..."}, "output": 20}, {"input": {"seat_layout": "LLLL..\n..LLLL\nLLLLL.\nLLLLL.\nL..LLL\nLL.LLL\n.LL.L.\n...LLL\nL.LL.L\n.LLLLL\n.LLLLL\n.LL..L\nLL...."}, "output": 23}, {"input": {"seat_layout": "LLLLL...\n..L..L..\n.LLL.L.L\n....L...\nLLLLLLL.\nLLLL....\n..LLL..L"}, "output": 21}, {"input": {"seat_layout": "....L.LL..\nLL.L.LL.L.\nLL.LLLL...\nLLL..L..L.\n.LL..L.LLL"}, "output": 17}, {"input": {"seat_layout": ".LLL.L\n..LL..\nL.L...\nLL.L..\nL.....\nL.....\n.L.LLL"}, "output": 12}, {"input": {"seat_layout": "LLL.LL\n.L.L.L\nLL.LLL\n..LL.L\n...L..\nL.LLLL\nL.LL..\nL.LLL.\n...L..\n...LLL\nL.....\n.L.LLL\n..L...\nLL.LL."}, "output": 33}, {"input": {"seat_layout": ".L....L.L..\nLL....LL..L\nL..LLLLL..L\nLL..L....L.\nL.L.LLL.LL.\n...L.LLLLL."}, "output": 19}, {"input": {"seat_layout": "..L.LL\n.....L\n.LLL.L\n..LLLL\n.LLL.."}, "output": 11}, {"input": {"seat_layout": "LLLLL.LLLL.L...\n.LLL..L.L....LL\n...LLLL.LL..LL.\nL.LL..L.L.LLL.L\n..L.LL..LL.LLLL\nL.LL..L...LLLL."}, "output": 31}, {"input": {"seat_layout": ".L..LLL.\n.L....L.\n..LL.L.L\nL.L.LLLL\n.L.L.LLL"}, "output": 15}], "error_log": []}
{"context": "Given a value \\( x \\) and six different epsilon values \\( \\epsilon \\), where \\( \\epsilon > 0 \\), how can we approximate the sine of \\( x \\) using a series expansion that includes all terms whose absolute value is greater than \\( \\epsilon \\)? Specifically, what are the approximate values of the sine function for each of the six epsilon values provided?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): The value for which the sine function is to be approximated.\n  `eps_values` (list of strings): A list of strings representing the epsilon values (\u03b5 > 0) for which the sine function approximation is to be calculated.\n\nOutput:\n  `return` (list of floats): A list of floats representing the approximate values of the sine function for each epsilon value provided in `eps_values`.", "reference_code": "# import necessary packages\nimport math\nfrom math import factorial\n\n# main function\ndef main_solution(x, eps_values):\n    # Convert eps_values to a list of floats\n    eps_values = [float(eps) for eps in eps_values]\n    \n    # Function to approximate sin(x) using the given series\n    def Sin1(x, e):\n        result = 0\n        n = 0\n        while True:\n            term = ((-1) ** n) * (x ** (2 * n + 1)) / factorial(2 * n + 1)\n            if abs(term) <= e:\n                break\n            result += term\n            n += 1\n        return result\n    \n    # Calculate the approximate sin(x) for each epsilon value\n    results = [Sin1(x, e) for e in eps_values]\n    \n    # Return the results as a list of floats\n    return results", "input_generator": "import random\nimport math\n\ndef input_generator():\n    x = random.uniform(-2 * math.pi, 2 * math.pi)\n    eps_values = [10 ** -random.randint(1, 10) for _ in range(random.randint(1, 5))]\n    return {'x': x, 'eps_values': eps_values}", "io_pairs": [{"input": {"x": 4.00011456978576, "eps_values": [1e-05, 1e-10]}, "output": [-0.7568752007310686, -0.7568773782214022]}, {"input": {"x": 0.447869645797101, "eps_values": [0.1, 1e-09, 0.0001, 1e-08, 1e-05]}, "output": [0.447869645797101, 0.43304627727148615, 0.4330469924579144, 0.43304627527345785, 0.4330469924579144]}, {"input": {"x": -0.5658272015609249, "eps_values": [1e-07, 1e-09, 0.01, 1e-09]}, "output": [-0.5361142614223292, -0.5361142778052512, -0.5356346222866436, -0.5361142778052512]}, {"input": {"x": 0.005840484889701791, "eps_values": [0.0001, 1e-10]}, "output": [0.005840484889701791, 0.005840451685315044]}, {"input": {"x": -0.18009446814386187, "eps_values": [0.1, 1e-09, 1e-07, 0.01, 1e-10]}, "output": [-0.18009446814386187, -0.17912251451379424, -0.17912251573298615, -0.18009446814386187, -0.17912251451379424]}, {"input": {"x": 2.6350679882603547, "eps_values": [0.1, 0.1, 1e-09, 0.0001]}, "output": [0.4692811828234749, 0.4692811828234749, 0.48514122645450297, 0.4850953288755014]}, {"input": {"x": 2.745175548047989, "eps_values": [1e-08, 1e-07, 1e-10, 1e-07]}, "output": [0.386115787271105, 0.3861157069881117, 0.3861157855020648, 0.3861157069881117]}, {"input": {"x": -2.0355324929378433, "eps_values": [1e-06, 0.1, 1e-10]}, "output": [-0.8939398757568403, -0.9210759266181938, -0.8939398436199064]}, {"input": {"x": 2.3226271949186845, "eps_values": [0.1]}, "output": [0.797623779311251]}, {"input": {"x": 4.216318873437496, "eps_values": [1e-06, 1e-08]}, "output": [-0.8794601227186015, -0.8794598625478295]}], "error_log": []}
{"context": "Given an initial point \\((x, y)\\) and a number of iterations, what are the final coordinates of the point after applying a specific iterative method to solve a system of nonlinear equations? The method involves updating the coordinates based on the values of certain functions and their derivatives.\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): Initial value for the x-coordinate.\n  `y` (float): Initial value for the y-coordinate.\n  `numIt` (int): Number of iterations to perform.\n\nOutput:\n  `return` (dict): A dictionary containing the final values of `x` and `y` after the specified number of iterations. The dictionary has the following keys:\n    - `x` (float): The final value of the x-coordinate.\n    - `y` (float): The final value of the y-coordinate.", "reference_code": "# import necessary packages\nfrom math import log\n\n# all class and function definitions in the code file, if any\ndef J(x, y):\n    return -(2 * y) / (x - 1) - 2 * (x - 3)\n\ndef hn(x, y):\n    return -y**2 + 2 * y * (y - log(x - 1)) - (x - 3)**2 + 4\n\ndef kn(x, y):\n    return -((y**2 + (x - 3)**2 - 4) / (x - 1)) - 2 * (x - 3) * (y - log(x - 1))\n\n# main function\ndef main_solution(x, y, numIt):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    for i in range(numIt):\n        x0 = x - (hn(x, y) / J(x, y))\n        y0 = y - (kn(x, y) / J(x, y))\n        \n        x = x0\n        y = y0\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"x\": x, \"y\": y}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    x = random.uniform(1.1, 3.9)  # x must be >1 to avoid division by zero in log(x-1)\n    y = random.uniform(-5.0, 5.0)\n    numIt = random.randint(1, 10)\n    return {\"x\": x, \"y\": y, \"numIt\": numIt}", "io_pairs": [{"input": {"x": 1.4680806957371437, "y": 1.558331516529103, "numIt": 2}, "output": {"x": 5.8408651115778145, "y": 1.9564444426251475}}, {"input": {"x": 1.5726763217550888, "y": -0.22742412149719193, "numIt": 4}, "output": {"x": 1.3313830135293627, "y": -1.1029246008434965}}, {"input": {"x": 3.6512858594355433, "y": -0.6965920270854831, "numIt": 8}, "output": {"x": 4.547991443576652, "y": 1.2663816528256686}}, {"input": {"x": 1.814233154501784, "y": 4.688755018020272, "numIt": 8}, "output": {"x": 4.547991443576652, "y": 1.2663816528256688}}, {"input": {"x": 2.334326764803315, "y": 3.867638684841621, "numIt": 8}, "output": {"x": 4.547991443576652, "y": 1.2663816528256688}}, {"input": {"x": 2.0741732764230663, "y": -2.3318148069007982, "numIt": 1}, "output": {"x": 0.634882028901145, "y": -1.268354706847845}}, {"input": {"x": 2.7607826499280406, "y": 2.3777544932645203, "numIt": 2}, "output": {"x": 4.946151763440083, "y": 1.3933259664415902}}, {"input": {"x": 3.7423631061505738, "y": 0.8400050130131111, "numIt": 8}, "output": {"x": 4.547991443576652, "y": 1.2663816528256688}}, {"input": {"x": 1.1686791659554285, "y": -4.237551322694743, "numIt": 2}, "output": {"x": 1.207006063034942, "y": -1.267066064409566}}, {"input": {"x": 2.341082397654562, "y": 3.3599659796001067, "numIt": 3}, "output": {"x": 4.6170369644412474, "y": 1.2943098963966178}}], "error_log": []}
{"context": "Given a set of sensor readings from either an IR or a sonar sensor, how can we determine the range and variance of the measurements using specific calibration coefficients? Specifically, what are the calculated ranges and their variance for the provided sensor data and type, given the coefficients `a` and `b`?\n\nThe input and output requirements are as follows:\n\nInput:\n- `sensor_data` (list of float): List of sensor readings.\n- `sensor_type` (str): Type of sensor ('ir' or 'sonar').\n- `a` (float): Coefficient a for IR sensor range calculation.\n- `b` (float): Coefficient b for IR sensor range calculation.\n\nOutput:\n- `return` (dict): A dictionary containing the calculated range and variance.\n  - `range` (list of float): List of calculated ranges.\n  - `variance` (float): Variance of the calculated ranges.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass IterRegistry(type):\n    \"\"\"A Metaclass that allows a class to be iterable\"\"\"\n    def __iter__(cls):\n        return iter(cls._registry)\n\nclass Sensor(object):\n    \"\"\"Creates sensor class for IR and sonar sensors\"\"\"\n    __metaclass__ = IterRegistry\n    _registry = []\n    \n    def __init__(self, min_range, max_range, var, type_, data_readings, a=0, b=0):\n        self._registry.append(self)\n        self.min_ = min_range\n        self.max_ = max_range\n        self.var = var\n        self.type_ = type_.lower()\n        self.within_range = False\n        self.data = data_readings\n        self.a = a\n        self.b = b\n    \n    def __str__(self):\n        return('Type:{}\\nRange:{}-{}m\\nVariance:{}'.format(self.type_, self.min_, self.max_, self.var))\n    \n    def within_sensor_range(self, estimate):\n        if estimate < self.min_ or estimate > self.max_:\n            self.within_range = False\n        else:\n            self.within_range = True\n    \n    def is_ir(self):\n        if self.type_ == 'ir':\n            return True\n        else:\n            return False\n    \n    def ir_range(self, type_):\n        if self.type_ == 'ir':\n            distance = self.a / (self.data - self.b)\n        else:\n            distance = self.data\n        return distance\n\ndef var(sample):\n    \"\"\"Find variance of a desired data set\"\"\"\n    sample_mean = sum(sample) / len(sample)\n    vari = sum((sample - sample_mean) ** 2) / (len(sample) - 1)\n    return vari\n\ndef ir_voltage_to_range(voltage, a, b):\n    \"\"\"This function uses derived coefficients a and b to map the inverse\n    relationship between voltage and actual sensed range\"\"\"\n    distance = a / (voltage - b)\n    return distance\n\n# main function\ndef main_solution(sensor_data, sensor_type, a, b):\n    \"\"\"\n    Main function to process sensor data and determine the range based on sensor type.\n    \n    Parameters:\n    sensor_data (list of float): List of sensor readings.\n    sensor_type (str): Type of sensor ('ir' or 'sonar').\n    a (float): Coefficient a for IR sensor range calculation.\n    b (float): Coefficient b for IR sensor range calculation.\n    \n    Returns:\n    dict: A dictionary containing the calculated range and variance.\n    \"\"\"\n    # Convert input to appropriate types\n    sensor_data = np.array(sensor_data)\n    \n    # Create a sensor object\n    sensor = Sensor(0, 10, 0, sensor_type, sensor_data, a, b)\n    \n    # Calculate the range based on sensor type\n    if sensor.is_ir():\n        range_data = sensor.ir_range(sensor_type)\n    else:\n        range_data = sensor_data\n    \n    # Calculate variance\n    variance = var(range_data)\n    \n    # Return the result as a dictionary\n    return {\n        \"range\": range_data.tolist(),\n        \"variance\": variance\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    sensor_type = random.choice(['ir', 'sonar'])\n    if sensor_type == 'ir':\n        sensor_data = [random.uniform(0.1, 5.0) for _ in range(random.randint(5, 20))]\n        a = random.uniform(1.0, 10.0)\n        b = random.uniform(0.1, 1.0)\n    else:\n        sensor_data = [random.uniform(0.1, 10.0) for _ in range(random.randint(5, 20))]\n        a = 0.0\n        b = 0.0\n    return {\n        \"sensor_data\": sensor_data,\n        \"sensor_type\": sensor_type,\n        \"a\": a,\n        \"b\": b\n    }", "io_pairs": [{"input": {"sensor_data": [4.407261932274441, 6.83027213944511, 9.094416052845641, 3.223144287573066, 2.752873805988081, 2.877713392140877, 5.479098364638616, 0.6156732737619054, 8.972904671757085, 9.05376894943041, 5.807932221842506], "sensor_type": "sonar", "a": 0.0, "b": 0.0}, "output": {"range": [4.407261932274441, 6.83027213944511, 9.094416052845641, 3.223144287573066, 2.752873805988081, 2.877713392140877, 5.479098364638616, 0.6156732737619054, 8.972904671757085, 9.05376894943041, 5.807932221842506], "variance": 8.395856661982844}}, {"input": {"sensor_data": [0.17231080581326963, 8.933876437397247, 9.669494242874332, 2.0936790204873574, 0.9329903397907104, 6.835684311279148, 5.447061308641254], "sensor_type": "sonar", "a": 0.0, "b": 0.0}, "output": {"range": [0.17231080581326963, 8.933876437397247, 9.669494242874332, 2.0936790204873574, 0.9329903397907104, 6.835684311279148, 5.447061308641254], "variance": 14.837239137908204}}, {"input": {"sensor_data": [6.477461157962737, 8.86917720044483, 1.4147682601550429, 3.8276464781496147, 4.805260659215715, 5.038432565088888, 6.482766177229489, 7.033083511243173, 7.7668093551976325], "sensor_type": "sonar", "a": 0.0, "b": 0.0}, "output": {"range": [6.477461157962737, 8.86917720044483, 1.4147682601550429, 3.8276464781496147, 4.805260659215715, 5.038432565088888, 6.482766177229489, 7.033083511243173, 7.7668093551976325], "variance": 5.049705080962046}}, {"input": {"sensor_data": [6.619609388585419, 2.0467362571313195, 8.69546458491557, 4.894053995705069, 3.259536611149723, 6.758041319384215], "sensor_type": "sonar", "a": 0.0, "b": 0.0}, "output": {"range": [6.619609388585419, 2.0467362571313195, 8.69546458491557, 4.894053995705069, 3.259536611149723, 6.758041319384215], "variance": 6.0542166485090245}}, {"input": {"sensor_data": [4.918906749120845, 4.212005923701845, 4.529183996759602, 3.1192471670653035, 2.108027212805507, 3.5983345943091383, 2.3009238473124034, 3.625376106515344, 0.1166280180499619, 1.2465085543772072, 1.046598351115204, 3.4231418365152115], "sensor_type": "ir", "a": 8.554825022822008, "b": 0.7402311658782954}, "output": {"range": [2.0472575227253405, 2.4641071554379916, 2.2578336032840416, 3.595951022840362, 6.254459531478132, 2.993182450195227, 5.481428294365453, 2.965128338035273, -13.718380115003837, 16.897505630631965, 27.923437740914412, 3.1886358038119527], "variance": 95.89515835393212}}, {"input": {"sensor_data": [7.081224510857404, 5.4046208704883005, 8.280131848523004, 2.127187595879507, 6.998946246881516, 2.7634743484244577, 0.965831721196897, 8.930366510156432], "sensor_type": "sonar", "a": 0.0, "b": 0.0}, "output": {"range": [7.081224510857404, 5.4046208704883005, 8.280131848523004, 2.127187595879507, 6.998946246881516, 2.7634743484244577, 0.965831721196897, 8.930366510156432], "variance": 9.05910104060609}}, {"input": {"sensor_data": [0.8510575480080516, 3.3205616413232395, 2.2900997049586373, 2.1770227762971848, 2.390978524994482, 2.7403045214229453, 2.8374864444098096], "sensor_type": "ir", "a": 2.949173353488944, "b": 0.7243857012162177}, "output": {"range": [23.281995393463138, 1.135968216918061, 1.8835964591488201, 2.0302203517176256, 1.7695824147394286, 1.4629425172917, 1.3956615002802806], "variance": 67.17279253370849}}, {"input": {"sensor_data": [4.793712284195374, 4.298424459692608, 4.09128877819332, 0.924597449531391, 1.94572187987162, 3.783286707394438, 0.4478657597875867, 1.1775516792228833, 1.4056693495378783, 3.446996529707513, 1.9841053221459648], "sensor_type": "ir", "a": 7.590803696323411, "b": 0.927319663856032}, "output": {"range": [1.963278032445962, 2.2517258157320708, 2.3991396319029334, -2788.466590456417, 7.453640199273901, 2.6578751017094264, -15.832186643827539, 30.335061983155732, 15.868733530165018, 3.0126099894790404, 7.182917024637409], "variance": 709898.7470245765}}, {"input": {"sensor_data": [1.4665389977915846, 2.2410678277503013, 0.6483282246794089, 1.7041095591804094, 0.9632847374739762, 4.01094401090813], "sensor_type": "ir", "a": 8.954679318857817, "b": 0.3014390080658653}, "output": {"range": [7.685760362049161, 4.6166973948730465, 25.814233738011794, 6.384021758881687, 13.529858879449131, 2.4139822731056144], "variance": 73.49511399183045}}, {"input": {"sensor_data": [0.5884236027024179, 2.6118290025621067, 0.9892104194363727, 8.518745502241439, 3.675872834624779, 4.390291720523332, 5.53196794850954], "sensor_type": "sonar", "a": 0.0, "b": 0.0}, "output": {"range": [0.5884236027024179, 2.6118290025621067, 0.9892104194363727, 8.518745502241439, 3.675872834624779, 4.390291720523332, 5.53196794850954], "variance": 7.5407193215138335}}], "error_log": []}
{"context": "In a radioactive decay process, nuclei of type A decay into nuclei of type B, and nuclei of type B decay back into nuclei of type A. Given the initial number of nuclei of type A (`number_of_A`), the initial number of nuclei of type B (`number_of_B`), the time constant (`time_constant`), the total duration of the simulation (`time_of_duration`), and the time step (`time_step`), what will be the final number of nuclei of type A and type B after the simulation?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number_of_A` (int): The initial number of nuclei of type A.\n  `number_of_B` (int): The initial number of nuclei of type B.\n  `time_constant` (float): The time constant for the decay process.\n  `time_of_duration` (float): The total duration of the simulation in seconds.\n  `time_step` (float): The time step for the simulation in seconds.\n\nOutput:\n  `return` (dict): A dictionary containing the final number of nuclei of type A and B after the simulation.\n    - `final_number_of_A` (float): The final number of nuclei of type A.\n    - `final_number_of_B` (float): The final number of nuclei of type B.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass uranium_decay:\n    \"\"\"\n    Simulation of radioactive decay\n    Nuclei of type A decay into ones of type B, while nuclei of type B decay \n    into ones of type A\n    \"\"\"\n    def __init__(self, number_of_A, number_of_B, time_constant, time_of_duration, time_step):\n        # unit of time is second\n        self.na = [number_of_A]\n        self.nb = [number_of_B]\n        self.t = [0]\n        self.tau = time_constant\n        self.dt = time_step\n        self.time = time_of_duration\n        self.nsteps = int(time_of_duration // time_step + 1)\n\n    def calculation(self):\n        for i in range(self.nsteps):\n            temp_A = self.na[i] + (self.nb[i] - self.na[i]) / self.tau * self.dt\n            temp_B = self.nb[i] + (self.na[i] - self.nb[i]) / self.tau * self.dt\n            self.na.append(temp_A)\n            self.nb.append(temp_B)\n            self.t.append(self.t[i] + self.dt)\n\n# main function\ndef main_solution(number_of_A, number_of_B, time_constant, time_of_duration, time_step):\n    # Convert JSON serializable inputs to the original input variables\n    number_of_A = int(number_of_A)\n    number_of_B = int(number_of_B)\n    time_constant = float(time_constant)\n    time_of_duration = float(time_of_duration)\n    time_step = float(time_step)\n\n    # Initialize the uranium_decay class\n    decay_sim = uranium_decay(number_of_A, number_of_B, time_constant, time_of_duration, time_step)\n    decay_sim.calculation()\n\n    # Extract the final number of nuclei A and B\n    final_na = decay_sim.na[-1]\n    final_nb = decay_sim.nb[-1]\n\n    # Return the final number of nuclei A and B as JSON serializable outputs\n    return {\"final_number_of_A\": final_na, \"final_number_of_B\": final_nb}", "input_generator": "import random\n\ndef input_generator():\n    number_of_A = random.randint(100, 10000)\n    number_of_B = random.randint(100, 10000)\n    time_constant = random.uniform(0.1, 10.0)\n    time_of_duration = random.uniform(1.0, 100.0)\n    time_step = random.uniform(0.01, 1.0)\n    \n    return {\n        \"number_of_A\": number_of_A,\n        \"number_of_B\": number_of_B,\n        \"time_constant\": time_constant,\n        \"time_of_duration\": time_of_duration,\n        \"time_step\": time_step\n    }", "io_pairs": [{"input": {"number_of_A": 6371, "number_of_B": 8813, "time_constant": 3.546497130481655, "time_of_duration": 33.16693388586966, "time_step": 0.16373756296661773}, "output": {"final_number_of_A": 7591.9999964896115, "final_number_of_B": 7592.0000035103885}}, {"input": {"number_of_A": 610, "number_of_B": 4982, "time_constant": 3.560815764768096, "time_of_duration": 41.26523544690443, "time_step": 0.6371264031043974}, "output": {"final_number_of_A": 2795.999999999315, "final_number_of_B": 2796.000000000685}}, {"input": {"number_of_A": 9421, "number_of_B": 3399, "time_constant": 5.368075814207777, "time_of_duration": 92.65895527492172, "time_step": 0.9440905740554832}, "output": {"final_number_of_A": 6410.000000000001, "final_number_of_B": 6409.999999999999}}, {"input": {"number_of_A": 7551, "number_of_B": 1352, "time_constant": 5.824942581584153, "time_of_duration": 7.452622659786315, "time_step": 0.9510032883485375}, "output": {"final_number_of_A": 4582.674144034999, "final_number_of_B": 4320.325855965001}}, {"input": {"number_of_A": 7160, "number_of_B": 7358, "time_constant": 9.27212435294257, "time_of_duration": 52.26676140114996, "time_step": 0.11399726055353539}, "output": {"final_number_of_A": 7258.998921757732, "final_number_of_B": 7259.001078242268}}, {"input": {"number_of_A": 4215, "number_of_B": 8476, "time_constant": 4.0331379428045535, "time_of_duration": 61.771274438649996, "time_step": 0.7270796465596737}, "output": {"final_number_of_A": 6345.499999999999, "final_number_of_B": 6345.500000000001}}, {"input": {"number_of_A": 4045, "number_of_B": 6978, "time_constant": 3.010013693318866, "time_of_duration": 9.661312176270917, "time_step": 0.13147318456453022}, "output": {"final_number_of_A": 5509.807441770091, "final_number_of_B": 5513.192558229909}}, {"input": {"number_of_A": 8256, "number_of_B": 8753, "time_constant": 7.382047328603227, "time_of_duration": 48.24148400807887, "time_step": 0.603926049846474}, "output": {"final_number_of_A": 8504.499845968696, "final_number_of_B": 8504.500154031304}}, {"input": {"number_of_A": 8964, "number_of_B": 3798, "time_constant": 1.6670878494271024, "time_of_duration": 36.40816346059829, "time_step": 0.5561259278392561}, "output": {"final_number_of_A": 6381.0, "final_number_of_B": 6381.0}}, {"input": {"number_of_A": 8194, "number_of_B": 4434, "time_constant": 8.195275895797403, "time_of_duration": 49.21424720925237, "time_step": 0.26749673574091143}, "output": {"final_number_of_A": 6314.007577033419, "final_number_of_B": 6313.992422966581}}], "error_log": []}
{"context": "In a maze, each cell has four walls (top, bottom, left, right). Given a specific cell in the maze, determine if there is a wall between this cell and its adjacent cell in a specified direction. What is the result of checking for a wall between the given cell and its neighbour in the specified direction?\n\nThe input and output requirements are as follows:\n\nInput:\n  `maze_size` (int): The size of the maze, which is a positive integer.\n  `cell_coordinate` (list of int): The coordinate of the cell in the maze, represented as a list of two integers [x, y].\n  `direction` (int): The direction to check for a wall, where 0: Up, 1: Down, 2: Left, 3: Right.\n\nOutput:\n  `return` (dict): A dictionary with a single key \"has_wall\" which is a boolean indicating whether there is a wall between the cell and its neighbour in the specified direction. If the direction is invalid, the value will be `None`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Cell:\n    def __init__(self, coordinate):\n        self.walls = [1] * 4\n        self.coordinate = coordinate\n\n    def __validateDirection(self, direction):\n        assert direction in range(0, 4), \"{} is not a valid direction for a wall\".format(direction)\n\n    def removeWall(self, direction):\n        self.__validateDirection(direction)\n        self.walls[direction] = 0\n\n    def hasWall(self, direction):\n        self.__validateDirection(direction)\n        return self.walls[direction]\n\n    def isAdjacent(self, cell):\n        return abs(cell.coordinate[0] - self.coordinate[0]) <= 1 and \\\n               abs(cell.coordinate[1] - self.coordinate[1]) <= 1 and \\\n               (cell.coordinate[0] == self.coordinate[0] or cell.coordinate[1] == self.coordinate[1])\n\n    def directionOfCell(self, cell):\n        assert self.isAdjacent(cell), \"Can't check direction between {} and non adjacent cell {}\".format(self, cell)\n        if cell.coordinate[0] - self.coordinate[0] == 1:\n            return 3  # right\n        elif cell.coordinate[0] - self.coordinate[0] == -1:\n            return 2  # left\n        elif cell.coordinate[1] - self.coordinate[1] == 1:\n            return 1  # bottom\n        elif cell.coordinate[1] - self.coordinate[1] == -1:\n            return 0  # top\n        else:\n            raise Exception(\"All possible directions exhausted\")\n\n    def removeWallsBetweenCell(self, cell):\n        assert self.isAdjacent(cell), \"Can't remove walls between {} and non adjacent cell {}\".format(self, cell)\n        self.removeWall(self.directionOfCell(cell))\n        cell.removeWall(cell.directionOfCell(self))\n\n    def hasWallBetween(self, cell):\n        assert self.isAdjacent(cell), \"Can't check for walls between {} and non adjacent cell {}\".format(self, cell)\n        return self.hasWall(self.directionOfCell(cell)) or cell.hasWall(cell.directionOfCell(self))\n\nclass Maze:\n    def __init__(self, size, safe=True):\n        self.size = size\n        self.cells = []\n        self.safe = safe\n\n        for y in range(self.size):\n            self.cells.append([])\n            for x in range(self.size):\n                self.cells[y].append(Cell((x, y)))\n\n    def __validateCoordinate(self, coordinate):\n        if not self.safe:\n            return True\n        assert isinstance(coordinate, tuple) and len(coordinate) == 2 and \\\n               all(isinstance(x, int) for x in coordinate), \\\n            \"{} is not a valid coordinate, must be tuple of form (Integer, Integer)\".format(coordinate)\n\n        inRange = lambda x: x >= 0 and x < self.size\n        assert inRange(coordinate[0]) and inRange(coordinate[1]), \\\n            \"{} is not a valid coordinate in the maze\".format(coordinate)\n\n    def getCell(self, coordinate):\n        self.__validateCoordinate(coordinate)\n        return self.cells[coordinate[1]][coordinate[0]]\n\n    def getNeighbours(self, coordinate):\n        self.__validateCoordinate(coordinate)\n        neighbours = []\n\n        if coordinate[0] != 0:\n            neighbours.append(self.getCell((coordinate[0] - 1, coordinate[1])))\n        if coordinate[0] != self.size - 1:\n            neighbours.append(self.getCell((coordinate[0] + 1, coordinate[1])))\n        if coordinate[1] != 0:\n            neighbours.append(self.getCell((coordinate[0], coordinate[1] - 1)))\n        if coordinate[1] != self.size - 1:\n            neighbours.append(self.getCell((coordinate[0], coordinate[1] + 1)))\n\n        return neighbours\n\n    def getNeighbourInDirection(self, coordinate, direction):\n        self.__validateCoordinate(coordinate)\n        cell = self.getCell(coordinate)\n        assert direction in range(4)\n\n        if direction == 0:\n            if coordinate[1] > 0:\n                return self.getCell((coordinate[0], coordinate[1] - 1))\n            else:\n                raise Exception(\"Invalid direction {} for cell {}\".format(direction, cell))\n        elif direction == 1:\n            if coordinate[1] < self.size - 1:\n                return self.getCell((coordinate[0], coordinate[1] + 1))\n            else:\n                raise Exception(\"Invalid direction {} for cell {}\".format(direction, cell))\n        elif direction == 2:\n            if coordinate[0] > 0:\n                return self.getCell((coordinate[0] - 1, coordinate[1]))\n            else:\n                raise Exception(\"Invalid direction {} for cell {}\".format(direction, cell))\n        elif direction == 3:\n            if coordinate[0] < self.size - 1:\n                return self.getCell((coordinate[0] + 1, coordinate[1]))\n            else:\n                raise Exception(\"Invalid direction {} for cell {}\".format(direction, cell))\n\n# main function\ndef main_solution(maze_size, cell_coordinate, direction):\n    # Convert JSON serializable inputs to original input variables\n    maze_size = int(maze_size)\n    cell_coordinate = tuple(cell_coordinate)\n    direction = int(direction)\n\n    # Create the maze\n    maze = Maze(maze_size)\n\n    # Get the cell at the specified coordinate\n    cell = maze.getCell(cell_coordinate)\n\n    # Get the neighbour in the specified direction\n    try:\n        neighbour = maze.getNeighbourInDirection(cell_coordinate, direction)\n    except Exception:\n        return {\"has_wall\": None}\n\n    # Check if there is a wall between the cell and its neighbour\n    has_wall = cell.hasWallBetween(neighbour)\n\n    # Return the result as a JSON serializable output\n    return {\"has_wall\": has_wall}", "input_generator": "import random\n\ndef input_generator():\n    maze_size = random.randint(2, 10)\n    x = random.randint(0, maze_size - 1)\n    y = random.randint(0, maze_size - 1)\n    cell_coordinate = (x, y)\n    direction = random.randint(0, 3)\n    return {\n        \"maze_size\": maze_size,\n        \"cell_coordinate\": cell_coordinate,\n        \"direction\": direction\n    }", "io_pairs": [{"input": {"maze_size": 5, "cell_coordinate": [0, 4], "direction": 2}, "output": {"has_wall": null}}, {"input": {"maze_size": 10, "cell_coordinate": [1, 9], "direction": 1}, "output": {"has_wall": null}}, {"input": {"maze_size": 8, "cell_coordinate": [2, 2], "direction": 1}, "output": {"has_wall": 1}}, {"input": {"maze_size": 2, "cell_coordinate": [0, 0], "direction": 1}, "output": {"has_wall": 1}}, {"input": {"maze_size": 5, "cell_coordinate": [2, 4], "direction": 3}, "output": {"has_wall": 1}}, {"input": {"maze_size": 7, "cell_coordinate": [1, 5], "direction": 0}, "output": {"has_wall": 1}}, {"input": {"maze_size": 5, "cell_coordinate": [0, 0], "direction": 0}, "output": {"has_wall": null}}, {"input": {"maze_size": 9, "cell_coordinate": [8, 8], "direction": 0}, "output": {"has_wall": 1}}, {"input": {"maze_size": 6, "cell_coordinate": [0, 0], "direction": 3}, "output": {"has_wall": 1}}, {"input": {"maze_size": 7, "cell_coordinate": [3, 5], "direction": 1}, "output": {"has_wall": 1}}], "error_log": []}
{"context": "Given a bucket containing 3 red balls and 3 green balls, what is the probability of drawing 3 balls of the same color without replacement? Use a Monte Carlo simulation to estimate this probability by running a specified number of trials.\n\nThe input and output requirements are as follows:\n\nInput:\n  `numTrials` (int): The number of trials to run the Monte Carlo simulation. It should be a positive integer.\n\nOutput:\n  `return` (float): The fraction of times 3 balls of the same color were drawn out of the total number of trials. The value is a decimal between 0 and 1.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(numTrials):\n    '''\n    Runs numTrials trials of a Monte Carlo simulation\n    of drawing 3 balls out of a bucket containing\n    3 red and 3 green balls. Balls are not replaced once\n    drawn. Returns the a decimal - the fraction of times 3\n    balls of the same color were drawn.\n    '''\n\n    def drawBalls():\n        draw = []\n        bucket = ['R', 'R', 'R', 'G', 'G', 'G']\n        for i in range(3):\n            pick = random.randrange(0, len(bucket))\n            draw.append(bucket.pop(pick))\n        if draw == ['R', 'R', 'R'] or draw == ['G', 'G', 'G']:\n            return 1\n        else:\n            return 0\n\n    sameColour = 0\n    for i in range(numTrials):\n        sameColour += drawBalls()\n    return float(sameColour) / numTrials", "input_generator": "import random\n\ndef input_generator():\n    return {'numTrials': random.randint(100, 10000)}", "io_pairs": [{"input": {"numTrials": 3163}, "output": 0.09674359785014228}, {"input": {"numTrials": 9169}, "output": 0.09968371687206892}, {"input": {"numTrials": 2800}, "output": 0.1}, {"input": {"numTrials": 8331}, "output": 0.09770735806025688}, {"input": {"numTrials": 2786}, "output": 0.10660445082555635}, {"input": {"numTrials": 7287}, "output": 0.09825717030327981}, {"input": {"numTrials": 7601}, "output": 0.09459281673464018}, {"input": {"numTrials": 2013}, "output": 0.09090909090909091}, {"input": {"numTrials": 4383}, "output": 0.09833447410449464}, {"input": {"numTrials": 2891}, "output": 0.10100311310965064}], "error_log": []}
{"context": "Given a plaintext message, how can we ensure that the message remains confidential during transmission by encrypting it using the RSA algorithm and then decrypting it to retrieve the original message? Specifically, what is the decrypted message when the original message is encrypted and then decrypted using RSA?\n\nThe input and output requirements are as follows:\n\nInput:\n  `message` (str): The plaintext message to be encrypted and then decrypted. The message should be a string of reasonable length, typically less than 1KB.\n\nOutput:\n  `return` (str): The decrypted message, which should be identical to the input `message`.", "reference_code": "# import necessary packages\nfrom random import randrange, getrandbits\nfrom itertools import repeat\nfrom functools import reduce\n\n# all class and function definitions in the code file, if any\ndef get_prime(n):\n    \"\"\"Retorna um primo rand\u00f4mico\"\"\"\n    def is_prime(n, t=7):\n        \"\"\"Teste de primalidade Miller-Rabin\"\"\"\n        def is_composite(a):\n            \"\"\"Checa se n \u00e9 composto\"\"\"\n            if pow(a, d, n) == 1:\n                return False\n            for i in range(s):\n                if pow(a, 2 ** i * d, n) == n - 1:\n                    return False\n            return True\n\n        assert n > 0\n        if n < 3:\n            return [False, False, True][n]\n        elif not n & 1:\n            return False\n        else:\n            s, d = 0, n - 1\n            while not d & 1:\n                s += 1\n                d >>= 1\n        for _ in repeat(None, t):\n            if is_composite(randrange(2, n)):\n                return False\n        return True\n\n    p = getrandbits(n)\n    while not is_prime(p):\n        p = getrandbits(n)\n    return p\n\ndef inv(p, q):\n    \"\"\"Inverso multiplicativo\"\"\"\n    def xgcd(x, y):\n        \"\"\"Algoritmo euclidiano extendido\"\"\"\n        s1, s0 = 0, 1\n        t1, t0 = 1, 0\n        while y:\n            q = x // y\n            x, y = y, x % y\n            s1, s0 = s0 - q * s1, s1\n            t1, t0 = t0 - q * t1, t1\n        return x, s0, t0\n\n    s, t = xgcd(p, q)[0:2]\n    assert s == 1\n    if t < 0:\n        t += q\n    return t\n\ndef get_keys(p, q):\n    \"\"\"Gera chaves p\u00fablicas e privadas\"\"\"\n    phi, mod = (p - 1) * (q - 1), p * q\n    if mod < 65537:\n        return (3, inv(3, phi), mod)\n    else:\n        return (65537, inv(65537, phi), mod)\n\ndef str_2_int(text):\n    \"\"\"Transforma texto em n\u00fameros inteiros\"\"\"\n    return reduce(lambda x, y: (x << 8) + y, map(ord, text))\n\ndef int_2_str(number, size):\n    \"\"\"Transforma inteiro em string\"\"\"\n    text = \"\".join([chr((number >> j) & 0xff)\n                    for j in reversed(range(0, size << 3, 8))])\n    return text.lstrip(\"\\x00\")\n\ndef int_2_list(number, size):\n    \"\"\"Converte inteiro em lista de inteiros\"\"\"\n    return [(number >> j) & 0xff\n            for j in reversed(range(0, size << 3, 8))]\n\ndef list_2_int(listInt):\n    \"\"\"Converte lisa em inteiro\"\"\"\n    return reduce(lambda x, y: (x << 8) + y, listInt)\n\ndef mod_size(mod):\n    \"\"\"Retorna o tamanho em bytes do modulo\"\"\"\n    mod_size = len(\"{:02x}\".format(mod)) // 2\n    return mod_size\n\ndef encrypt(ptext, pk, mod):\n    \"\"\"Encripta com chave p\u00fablica\"\"\"\n    size = mod_size(mod)\n    output = []\n    while ptext:\n        nbytes = min(len(ptext), size - 1)\n        aux1 = str_2_int(ptext[:nbytes])\n        assert aux1 < mod\n        aux2 = pow(aux1, pk, mod)\n        output += int_2_list(aux2, size + 2)\n        ptext = ptext[size:]\n    return output\n\ndef decrypt(ctext, sk, p, q):\n    \"\"\"Sesencripta com chave private usando o teorema chine da lembran\u00e7a\"\"\"\n    mod = p * q\n    size = mod_size(mod)\n    output = \"\"\n    while ctext:\n        aux3 = list_2_int(ctext[:size + 2])\n        assert aux3 < mod\n        m1 = pow(aux3, sk % (p - 1), p)\n        m2 = pow(aux3, sk % (q - 1), q)\n        h = (inv(q, p) * (m1 - m2)) % p\n        aux4 = m2 + h * q\n        output += int_2_str(aux4, size)\n        ctext = ctext[size + 2:]\n    return output\n\n# main function\ndef main_solution(message):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    n = 512\n    p = get_prime(n)\n    q = get_prime(n)\n    pk, sk, mod = get_keys(p, q)\n    cipher_msg = encrypt(message, pk, mod)\n    decrypted_msg = decrypt(cipher_msg, sk, p, q)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return decrypted_msg", "input_generator": "import random\nimport string\n\ndef input_generator():\n    message_length = random.randint(10, 100)\n    message = ''.join(random.choices(string.ascii_letters + string.digits + string.punctuation + ' ', k=message_length))\n    return {'message': message}", "io_pairs": [{"input": {"message": "c].>U(H2W{XN1x{r:3|J-!4IN $)pVqSe%{YR=pUHg\"&fUME8=&/MQ]8\"|Jg=1=j+w@klq|="}, "output": "c].>U(H2W{XN1x{r:3|J-!4IN $)pVqSe%{YR=pUHg\"&fUME8=&/MQ]8\"|Jg=1=j+w@klq|="}, {"input": {"message": "l+aR079Q)qU<_:<jMc(!X={`"}, "output": "l+aR079Q)qU<_:<jMc(!X={`"}, {"input": {"message": "4YN3w9@F}))e5BgfSNI_#te([;C\"0Fv/u@\">TixWkM`3a~7IX.v{=v4uS%sWH^u,#!dFs# ObUFNOG`!<e9jRAmV"}, "output": "4YN3w9@F}))e5BgfSNI_#te([;C\"0Fv/u@\">TixWkM`3a~7IX.v{=v4uS%sWH^u,#!dFs# ObUFNOG`!<e9jRAmV"}, {"input": {"message": "0''yT#-U>@84a[%TES:0[U@/Lh|c-Ho;sbBq|9A:7gfz==gs@VZgZfOC)Jlb!!#^<"}, "output": "0''yT#-U>@84a[%TES:0[U@/Lh|c-Ho;sbBq|9A:7gfz==gs@VZgZfOC)Jlb!!#^<"}, {"input": {"message": " u3{s\"Z'_qq"}, "output": " u3{s\"Z'_qq"}, {"input": {"message": "Kv?=4hdig~j5_e(OXvR!c0xp&idP5JD1Qi9(};~R)&AyE:F@K}g}Pc:ZS8"}, "output": "Kv?=4hdig~j5_e(OXvR!c0xp&idP5JD1Qi9(};~R)&AyE:F@K}g}Pc:ZS8"}, {"input": {"message": "U>rv=4`b9Jqtw6>u:BGSVyIX9C\"=3ZB0hZZHlQ;A#JA80sjwh.^?Hf]dI9a'2a4>9TgN1(Nk.b%GYIF5F7CfE"}, "output": "U>rv=4`b9Jqtw6>u:BGSVyIX9C\"=3ZB0hZZHlQ;A#JA80sjwh.^?Hf]dI9a'2a4>9TgN1(Nk.b%GYIF5F7CfE"}, {"input": {"message": "lc<!rodbK7A1R%[cRpsNX{^b\"-J\"eCy}[d<<?eeTu&f-3J }_+?Vc&ESw ,s1JXmwQ](8xd`N<)8tF\".YR=}mlc"}, "output": "lc<!rodbK7A1R%[cRpsNX{^b\"-J\"eCy}[d<<?eeTu&f-3J }_+?Vc&ESw ,s1JXmwQ](8xd`N<)8tF\".YR=}mlc"}, {"input": {"message": "uX62OvP[FD"}, "output": "uX62OvP[FD"}, {"input": {"message": "qt; 2\"1/H9GzLn%R!jMIEGNb,vy 0LLFA<+wL%2L6.#zDmu0ran;I1@n*|/-~fjO\"TO:exg@+mbF#Irdo"}, "output": "qt; 2\"1/H9GzLn%R!jMIEGNb,vy 0LLFA<+wL%2L6.#zDmu0ran;I1@n*|/-~fjO\"TO:exg@+mbF#Irdo"}], "error_log": []}
{"context": "Given an integer `n`, what are the prime numbers less than or equal to `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer representing the upper limit for generating prime numbers.\n\nOutput:\n  `return` (list of int): A list of prime numbers less than or equal to `n`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\ndef eratosthenes2(n):\n    multiples = set()\n    primes = []\n    for i in range(2, n+1):\n        if i not in multiples:\n            primes.append(i)\n            multiples.update(range(i*i, n+1, i))\n    return primes\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    primes = eratosthenes2(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return primes", "input_generator": "import random\n\ndef input_generator():\n    n = random.choice([10, 20, 50, 100, 200, 500, 1000])\n    return {'n': n}", "io_pairs": [{"input": {"n": 50}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]}, {"input": {"n": 20}, "output": [2, 3, 5, 7, 11, 13, 17, 19]}, {"input": {"n": 10}, "output": [2, 3, 5, 7]}], "error_log": []}
{"context": "Given a circular arrangement of cups labeled with digits from 1 to 9, and a sequence of moves where three cups are picked up and placed after a different cup, what is the final arrangement of cups after a certain number of moves, starting from the cup immediately clockwise of the cup labeled '1'?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start` (str): A string of digits representing the initial arrangement of cups. Each digit should be unique and within the range of 1 to 9.\n  `iterations` (int): The number of iterations to perform the move operation. This should be a positive integer.\n\nOutput:\n  `return` (str): A string of digits representing the order of cups after the specified number of iterations, starting from the cup immediately clockwise of the cup labeled '1'.", "reference_code": "# import necessary packages\nfrom typing import Dict, NamedTuple\nimport random\n\n# all class and function definitions in the code file, if any\nclass Cup(NamedTuple):\n    prev: int\n    next: int\n\n    def __repr__(self) -> str:\n        return f'<{self.prev} {self.next}>'\n\ndef move(cups: Dict[int, Cup], current: int) -> int:\n    i1 = cups[current].next   # pickup #1\n    i2 = cups[i1].next   # pickup #2\n    i3 = cups[i2].next   # pickup #3\n    i4 = cups[i3].next   # after pickup #3\n\n    iX = current - 1  # destination\n    while iX in {i1, i2, i3} or iX not in cups:\n        iX -= 1\n        if iX <= 0:\n            iX = len(cups)\n    iY = cups[iX].next\n\n    # remove pickup from after cur\n    cups[current], cups[i4] = Cup(cups[current].prev, i4), Cup(current, cups[i4].next)\n\n    # insert pickup to after dest\n    cups[iX], cups[i1] = Cup(cups[iX].prev, i1), Cup(iX, cups[i1].next)\n    cups[i3], cups[iY] = Cup(cups[i3].prev, iY), Cup(i3, cups[iY].next)\n\n    return i4\n\n# main function\ndef main_solution(start: str, iterations: int) -> str:\n    # Convert start string to list of integers\n    start_list = [int(c) for c in start]\n    \n    # Initialize cups dictionary\n    cups: Dict[int, Cup] = {}\n    for p, cur, n in zip([start_list[-1]] + start_list, start_list, start_list[1:] + [start_list[0]]):\n        cups[cur] = Cup(p, n)\n    \n    current = start_list[0]\n    for _ in range(iterations):\n        current = move(cups, current)\n\n    # Find the result after cup 1\n    i = cups[1].next\n    result = []\n    while i != 1:\n        result.append(str(i))\n        i = cups[i].next\n    \n    return ''.join(result)", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random start string of digits between 3 and 9 characters long\n    length = random.randint(3, 9)\n    digits = random.sample(range(1, 10), length)\n    start = ''.join(map(str, digits))\n    \n    # Generate a random number of iterations between 1 and 100\n    iterations = random.randint(1, 100)\n    \n    return {'start': start, 'iterations': iterations}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Imagine a robot navigating a grid where some cells are blocked and others are available. The robot can only move right or down. Given a grid with some cells marked as \"off limits\" (represented by '0') and others as available (represented by '1'), what is the path the robot should take to move from the top-left corner to the bottom-right corner of the grid?\n\nThe input and output requirements are as follows:\n\nInput:\n  `maze` (list of lists of strings): A 2D grid representing the maze. Each cell in the grid is either '0' (off limits) or '1' (available). The grid is represented as a list of lists, where each inner list represents a row in the grid.\n\nOutput:\n  `return` (list of tuples of integers): A list of coordinates representing the path from the top-left corner to the bottom-right corner of the maze. Each coordinate is a tuple of two integers (row, col). If no path exists, the function returns `None`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef get_path_exponential(maze):\n    if len(maze) == 0 or len(maze[0]) == 0:\n        return False\n    path = []\n    if path_finder_exponential(maze, len(maze) - 1, len(maze[0])-1, path):\n        return path\n    return None \n\ndef path_finder_exponential(maze, row, col, path):\n    # if out of bounds or not available, return.\n    if ((col < 0) or (row < 0) or (not maze[row][col])):\n        return False\n\n    is_at_origin = (row == 0) and (col == 0)\n\n    if is_at_origin or path_finder_exponential(maze, row, col-1, path) or path_finder_exponential(maze, row-1, col, path):\n        path.append((row, col))\n        return True\n    return False\n\n# main function\ndef main_solution(maze):\n    # Convert the maze to a list of lists of integers\n    maze = [[int(cell) for cell in row] for row in maze]\n    \n    # Find the path using the get_path_exponential function\n    path = get_path_exponential(maze)\n    \n    # Convert the path to a list of tuples of integers\n    if path:\n        path = [(int(row), int(col)) for row, col in path]\n    \n    # Return the path as a list of tuples\n    return path", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(3, 10)\n    cols = random.randint(3, 10)\n    maze = [[1 for _ in range(cols)] for _ in range(rows)]\n    \n    # Randomly block some cells (0 means blocked)\n    for i in range(rows):\n        for j in range(cols):\n            if random.random() < 0.2:  # 20% chance to block a cell\n                maze[i][j] = 0\n    \n    # Ensure start (0,0) and end (rows-1, cols-1) are unblocked\n    maze[0][0] = 1\n    maze[rows-1][cols-1] = 1\n    \n    # Convert to list of strings (each row is a string of 0s and 1s)\n    maze = [''.join(map(str, row)) for row in maze]\n    \n    return {'maze': maze}", "io_pairs": [{"input": {"maze": ["1111", "1111", "0011", "1111"]}, "output": [[0, 0], [1, 0], [1, 1], [1, 2], [2, 2], [3, 2], [3, 3]]}, {"input": {"maze": ["111", "001", "011"]}, "output": [[0, 0], [0, 1], [0, 2], [1, 2], [2, 2]]}, {"input": {"maze": ["11111", "11011", "11111", "11101", "11111"]}, "output": [[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4]]}, {"input": {"maze": ["111", "111", "101", "111", "110", "110", "111", "111"]}, "output": [[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [5, 0], [6, 0], [7, 0], [7, 1], [7, 2]]}, {"input": {"maze": ["111", "101", "111", "111"]}, "output": [[0, 0], [1, 0], [2, 0], [3, 0], [3, 1], [3, 2]]}, {"input": {"maze": ["111", "111", "111", "111"]}, "output": [[0, 0], [1, 0], [2, 0], [3, 0], [3, 1], [3, 2]]}, {"input": {"maze": ["1111", "1111", "1101"]}, "output": [[0, 0], [1, 0], [1, 1], [1, 2], [1, 3], [2, 3]]}, {"input": {"maze": ["111", "100", "111", "111"]}, "output": [[0, 0], [1, 0], [2, 0], [3, 0], [3, 1], [3, 2]]}, {"input": {"maze": ["1011", "1110", "1111"]}, "output": [[0, 0], [1, 0], [2, 0], [2, 1], [2, 2], [2, 3]]}, {"input": {"maze": ["111011", "010000", "111011", "111111", "110111"]}, "output": [[0, 0], [0, 1], [1, 1], [2, 1], [3, 1], [3, 2], [3, 3], [4, 3], [4, 4], [4, 5]]}], "error_log": []}
{"context": "In a minesweeper game, you are given a grid with a certain number of mines. Your task is to determine if it is possible to reveal all the cells except the mines by clicking on a single cell. If it is possible, what would the grid look like after the click? If it is not possible, indicate that the configuration is \"Impossible\". Given the number of rows, columns, and mines, what is the resulting grid configuration?\n\nThe input and output requirements are as follows:\n\nInput:\n  `rows` (int): The number of rows in the grid.\n  `cols` (int): The number of columns in the grid.\n  `mines` (int): The number of mines to be placed in the grid.\n\nOutput:\n  `return` (str): A string representing the grid configuration. If the configuration is impossible, it returns \"Impossible\". Otherwise, it returns the grid with rows separated by newline characters and cells within each row concatenated without separators.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef iterbox():\n    c = 0\n    while True:\n        x, y = (c, 0)\n        while y < x:\n            yield (x, y)\n            y += 1\n        yield (x, y)\n        x -= 1\n        while x >= 0:\n            yield (x, y)\n            x -= 1\n        c += 1\n\ndef sweep(rows, cols, mines):\n    # Create an empty grid (fill with mines first)\n    grid = []\n    for i in range(rows):\n        grid.append(['*' for j in range(cols)])\n\n    # Handle special cases\n    # No spaces loses\n    if rows*cols == mines:\n        return False\n    # Single empty space wins\n    if rows*cols-1 == mines:\n        grid[0][0] = 'c'\n        return grid\n\n    # Single row or column wins\n    if rows == 1:\n        for j in range(mines, cols):\n            grid[0][j] = '.'\n        grid[0][cols-1] = 'c'\n        return grid\n    if cols == 1:\n        for i in range(mines, rows):\n            grid[i][0] = '.'\n        grid[rows-1][0] = 'c'\n        return grid\n\n    # Otherwise, grow a ring of blank spaces around the corder of the board\n    blanks = rows*cols - mines\n    # SPECIAL CASE blanks = 2 or 3\n    if blanks in (2,3):\n        return False\n\n    # Try and find a rectangle that could enclose all blanks\n    # such that the number of remaining tiles is not 1\n    for nrows in range(2, rows+1):\n        for ncols in range(2, cols+1):\n            remain = blanks - (nrows*ncols)\n            if remain < 0:\n                break\n\n            if remain > cols and remain > rows:\n                continue\n            if remain > nrows or remain > ncols:\n                continue\n            if remain >= rows and nrows == rows:\n                continue\n            if remain >= cols and ncols == cols:\n                continue\n            if remain == 1 and (nrows < 3 or ncols < 3):\n                continue\n\n            for i in range(nrows):\n                for j in range(ncols):\n                    grid[i][j] = '.'\n\n            if remain:\n                if i+1 == rows:\n                    for i in range(remain):\n                        grid[i][j+1] = '.'\n                    if remain == 1:\n                        grid[nrows-1][j] = '*'\n                        grid[i+1][j+1] = '.'\n                else:\n                    for j in range(remain):\n                        grid[i+1][j] = '.'\n                    if remain == 1:\n                        grid[i][ncols-1] = '*'\n                        grid[i+1][j+1] = '.'\n\n            grid[0][0] = 'c'\n            return grid\n    return False\n\n# main function\ndef main_solution(rows, cols, mines):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = sweep(rows, cols, mines)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if result is False:\n        return \"Impossible\"\n    else:\n        return \"\\n\".join([\"\".join(row) for row in result])", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(1, 20)\n    cols = random.randint(1, 20)\n    max_mines = rows * cols - 1\n    mines = random.randint(0, max_mines) if max_mines > 0 else 0\n    return {'rows': rows, 'cols': cols, 'mines': mines}", "io_pairs": [{"input": {"rows": 1, "cols": 11, "mines": 5}, "output": "*****.....c"}, {"input": {"rows": 2, "cols": 14, "mines": 1}, "output": "Impossible"}, {"input": {"rows": 1, "cols": 18, "mines": 12}, "output": "************.....c"}, {"input": {"rows": 3, "cols": 18, "mines": 51}, "output": "Impossible"}, {"input": {"rows": 10, "cols": 9, "mines": 12}, "output": "c........\n.........\n.........\n.........\n.........\n.........\n.........\n.........\n......***\n*********"}, {"input": {"rows": 5, "cols": 6, "mines": 5}, "output": "c.....\n......\n......\n.....*\n..****"}, {"input": {"rows": 8, "cols": 2, "mines": 1}, "output": "Impossible"}, {"input": {"rows": 5, "cols": 15, "mines": 13}, "output": "c..............\n...............\n...............\n...............\n..*************"}, {"input": {"rows": 3, "cols": 20, "mines": 46}, "output": "c.....**************\n......**************\n..******************"}, {"input": {"rows": 12, "cols": 3, "mines": 33}, "output": "Impossible"}], "error_log": []}
{"context": "Given a range of integers and a limit for generating prime numbers, consider the following mathematical problem: For each combination of three integers `a`, `b`, and `c` within their respective ranges, determine the product of `b` and `c` when certain conditions are met. After calculating these products, reduce the resulting fraction by dividing out common prime factors. What is the final reduced denominator?\n\nThe input and output requirements are as follows:\n\nInput:\n  `limit` (int): The upper limit for generating prime numbers.\n  `a_range` (int): The upper limit for the variable `a` in the nested loops.\n  `b_range` (int): The upper limit for the variable `b` in the nested loops.\n  `c_range` (int): The upper limit for the variable `c` in the nested loops.\n\nOutput:\n  `return` (dict): A dictionary containing the key `\"denominator\"` with the value being the reduced denominator after the calculations.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef generate_primes(limit):\n    is_prime = [True for i in range(limit)]\n    for i in range(2, limit):\n        if is_prime[i]:\n            j = 2\n            while i * j < limit:\n                is_prime[i * j] = False\n                j += 1\n    return [x for x in range(2, limit) if is_prime[x]]\n\n# main function\ndef main_solution(limit, a_range, b_range, c_range):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    numerator = 1\n    denominator = 1\n    \n    primes = generate_primes(limit)\n    \n    for a in range(1, a_range + 1):\n        for b in range(1, b_range + 1):\n            for c in range(b + 1, c_range + 1):\n                if (10 * a + b) * c == (10 * c + a) * b or (10 * b + a) * c == (10 * a + c) * b:\n                    numerator *= b\n                    denominator *= c\n    \n    for p in primes:\n        while numerator % p == 0 and denominator % p == 0:\n            numerator //= p\n            denominator //= p\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"denominator\": denominator}", "input_generator": "import random\n\ndef input_generator():\n    limit = random.randint(10, 100)\n    a_range = random.randint(1, 9)\n    b_range = random.randint(1, 9)\n    c_range = random.randint(b_range + 1, 10)\n    return {\n        \"limit\": limit,\n        \"a_range\": a_range,\n        \"b_range\": b_range,\n        \"c_range\": c_range\n    }", "io_pairs": [{"input": {"limit": 53, "a_range": 5, "b_range": 9, "c_range": 10}, "output": {"denominator": 1}}, {"input": {"limit": 22, "a_range": 1, "b_range": 6, "c_range": 9}, "output": {"denominator": 1}}, {"input": {"limit": 92, "a_range": 6, "b_range": 7, "c_range": 10}, "output": {"denominator": 10}}, {"input": {"limit": 91, "a_range": 8, "b_range": 2, "c_range": 3}, "output": {"denominator": 1}}, {"input": {"limit": 91, "a_range": 3, "b_range": 4, "c_range": 6}, "output": {"denominator": 1}}, {"input": {"limit": 36, "a_range": 3, "b_range": 6, "c_range": 9}, "output": {"denominator": 1}}, {"input": {"limit": 79, "a_range": 6, "b_range": 6, "c_range": 8}, "output": {"denominator": 10}}, {"input": {"limit": 90, "a_range": 5, "b_range": 3, "c_range": 10}, "output": {"denominator": 1}}, {"input": {"limit": 52, "a_range": 5, "b_range": 1, "c_range": 5}, "output": {"denominator": 1}}, {"input": {"limit": 49, "a_range": 8, "b_range": 2, "c_range": 10}, "output": {"denominator": 10}}], "error_log": []}
{"context": "Given a word, how can we generate all possible transformations of that word, including its reverse, various capitalizations, and digit replacements for similar-looking letters?\n\nThe input and output requirements are as follows:\n\nInput:\n  `word` (str): A string representing a word to be transformed.\n\nOutput:\n  `return` (list of str): A list of strings containing all possible transformations of the input word, including the original word, its reverse, and various capitalizations and digit replacements.", "reference_code": "# import necessary packages\nimport re\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\ndef transform_reverse(str):\n   rev_str = ''                                  #instantiate reverse string to empty string\n   for i in range((len(str)-1),-1,-1):           #traverse string starting from last character\n     rev_str+=str[i]                             #and adds character to reverse string\n   return [str,rev_str] \n\ndef transform_capitalize(str):\n  def helper(x,l,str1):               #helper recursive function           \n    if (not str1 in l):               #doesn't add the instance of str that is already on the list\n      l.append(str1)                  #to account for '-' and characters\n    for i in range(x,len(str1)):                              #recursively capitalizes the elements of the string\n      mod_str = str1[:i] + str1[i].upper() + str[i+1:]\n      helper(i+1,l,mod_str)\n    return l\n  return helper(0,[],str.lower())\n\ndef transform_digits(str):\n   d = {'O':['0'],'Z':['2'],'A':['4'],'B':['6','8'],'I':['1'],'L':['1'],'E':['3'],'S':['5'],'T':['7'],'G':['9'],'Q':['9']}\n   def helper(x,l,str1):                                 \n     l.append(str1)\n     for i in range(x,len(str1)):                           #for every element of the string\n       if (str1[i].upper() in d):                           #checks to see if it is a key in the dictionary\n          valList = d[str1[i].upper()]                      #and gets the list of values\n          for j in range(0,len(valList)):                   #recursively replaces the letters with the possible digits\n            mod_str = str1[:i] + valList[j] + str1[i+1:]\n            helper(i+1,l,mod_str)\n     return l\n   return helper(0,[],str)\n\n# main function\ndef main_solution(word):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  transformed_wordList = transform_reverse(word) + transform_capitalize(word)[1:] + transform_digits(word)[1:]  #list of all transformations of words.   \n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return transformed_wordList", "input_generator": "import random\nimport string\n\ndef input_generator():\n    word_length = random.randint(3, 10)\n    word = ''.join(random.choices(string.ascii_letters, k=word_length))\n    return {'word': word}", "io_pairs": [{"input": {"word": "fPkHU"}, "output": ["fPkHU", "UHkPf", "FPkHU", "FPKHU", "fPkHU", "fPKHU", "fpKHU", "fpkHU", "fpkhU"]}, {"input": {"word": "CiW"}, "output": ["CiW", "WiC", "CiW", "CIW", "cIW", "ciW", "C1W"]}, {"input": {"word": "cev"}, "output": ["cev", "vec", "Cev", "CEv", "CEV", "CeV", "cEv", "cEV", "ceV", "c3v"]}, {"input": {"word": "SQHx"}, "output": ["SQHx", "xHQS", "SQHx", "SQHX", "sQHx", "sQHX", "sqHx", "sqHX", "sqhX", "5QHx", "59Hx", "S9Hx"]}, {"input": {"word": "IlJNT"}, "output": ["IlJNT", "TNJlI", "IlJNT", "ILJNT", "iLJNT", "ilJNT", "iljNT", "iljnT", "1lJNT", "11JNT", "11JN7", "1lJN7", "I1JNT", "I1JN7", "IlJN7"]}, {"input": {"word": "YUt"}, "output": ["YUt", "tUY", "YUt", "YUT", "yUt", "yUT", "yuT", "YU7"]}, {"input": {"word": "uBU"}, "output": ["uBU", "UBu", "UBU", "uBU", "ubU", "u6U", "u8U"]}, {"input": {"word": "UUvi"}, "output": ["UUvi", "ivUU", "UUvi", "UUVi", "UUVI", "UUvI", "uUvi", "uUVi", "uUVI", "uUvI", "uuVi", "uuVI", "uuvI", "UUv1"]}, {"input": {"word": "YNNy"}, "output": ["YNNy", "yNNY", "YNNy", "YNNY", "yNNy", "yNNY", "ynNy", "ynNY", "ynnY"]}, {"input": {"word": "LzS"}, "output": ["LzS", "SzL", "LzS", "LZS", "lZS", "lzS", "1zS", "12S", "125", "1z5", "L2S", "L25", "Lz5"]}], "error_log": []}
{"context": "Given a natural number `n`, what are the two prime numbers `p1` and `p2` such that their sum equals `n`? If the Goldbach Hypothesis cannot be applied to `n`, what should be returned?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): A natural number for which we want to determine the prime numbers `p1` and `p2` such that `n = p1 + p2`.\n\nOutput:\n  `return` (dict): A dictionary containing the prime numbers `p1` and `p2` such that `n = p1 + p2`. The dictionary has the following keys:\n    - `p1` (int): The first prime number.\n    - `p2` (int): The second prime number.\n  If the Goldbach Hypothesis cannot be applied, the function returns `None`.", "reference_code": "# import necessary packages\nimport math\n\n# Function that verifies if a number is prime\ndef prime(x):\n    if x <= 1:\n        return False\n    if x == 2:\n        return True\n    if x % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return False\n    return True\n\n# Function that verifies if the Goldbach Conjecture can be applied\ndef Goldbach(x):\n    if x % 2 == 0:\n        return True\n    if x % 2 == 1:\n        if not prime(x - 2):\n            return False\n        else:\n            return True\n\n# Function that finds the 2 prime numbers such as p1 + p2 = n\ndef GoldbachNumbers(n):\n    for i in range(int(n / 2) + 1):\n        if prime(i) and prime(n - i):\n            return i, n - i\n\n# main function\ndef main_solution(n):\n    # Input argument n should be an integer\n    if not Goldbach(n):\n        return None  # Return None if the Goldbach Hypothesis cannot be applied\n    else:\n        p1, p2 = GoldbachNumbers(n)\n        return {\"p1\": p1, \"p2\": p2}  # Return the prime numbers as a dictionary", "input_generator": "import random\nimport math\n\ndef input_generator():\n    def prime(x):\n        if x <= 1:\n            return False\n        if x == 2:\n            return True\n        if x % 2 == 0:\n            return False\n        for i in range(3, int(math.sqrt(x)) + 1, 2):\n            if x % i == 0:\n                return False\n        return True\n\n    # Generate even numbers greater than 2 or primes + 2 (for odd numbers)\n    if random.choice([True, False]):\n        # Generate even number >=4\n        n = random.randint(2, 100) * 2\n    else:\n        # Generate odd number that is 2 + a prime\n        p = random.choice([3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])\n        n = p + 2\n    \n    return {\"n\": n}", "io_pairs": [{"input": {"n": 61}, "output": {"p1": 2, "p2": 59}}, {"input": {"n": 58}, "output": {"p1": 5, "p2": 53}}, {"input": {"n": 9}, "output": {"p1": 2, "p2": 7}}, {"input": {"n": 73}, "output": {"p1": 2, "p2": 71}}, {"input": {"n": 69}, "output": {"p1": 2, "p2": 67}}, {"input": {"n": 75}, "output": {"p1": 2, "p2": 73}}, {"input": {"n": 130}, "output": {"p1": 3, "p2": 127}}, {"input": {"n": 91}, "output": {"p1": 2, "p2": 89}}, {"input": {"n": 172}, "output": {"p1": 5, "p2": 167}}, {"input": {"n": 60}, "output": {"p1": 7, "p2": 53}}], "error_log": []}
{"context": "Given a string of characters, how can you list all possible unique permutations of the characters in lexicographical order?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string of characters for which all unique permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string, sorted in lexicographical order.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all permutations of the list of characters\n    permutations = list(set(itertools.permutations(char_list)))\n    \n    # Convert each permutation tuple back to a string\n    result = [''.join(perm) for perm in permutations]\n    \n    # Sort the result in lexicographical order\n    result.sort()\n    \n    # Return the sorted list of permutations\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    chars = random.choices(string.ascii_lowercase, k=length)\n    input_string = ''.join(chars)\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "kz"}, "output": ["kz", "zk"]}, {"input": {"input_string": "sr"}, "output": ["rs", "sr"]}, {"input": {"input_string": "o"}, "output": ["o"]}, {"input": {"input_string": "qu"}, "output": ["qu", "uq"]}, {"input": {"input_string": "n"}, "output": ["n"]}, {"input": {"input_string": "wpf"}, "output": ["fpw", "fwp", "pfw", "pwf", "wfp", "wpf"]}, {"input": {"input_string": "fro"}, "output": ["for", "fro", "ofr", "orf", "rfo", "rof"]}, {"input": {"input_string": "unl"}, "output": ["lnu", "lun", "nlu", "nul", "uln", "unl"]}, {"input": {"input_string": "e"}, "output": ["e"]}, {"input": {"input_string": "er"}, "output": ["er", "re"]}], "error_log": []}
{"context": "Given a polynomial function `poly(x) = x * (x - 1) * (x + 1) * (x - 4)`, what is the x-value that minimizes the function when starting the optimization process from a given initial guess `start_value`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start_value` (float): The initial guess for the optimization process. It should be a floating-point number representing the starting point for the optimization algorithm.\n\nOutput:\n  `return` (float): The optimized x-value that minimizes the polynomial function `poly(x)`. It is a floating-point number representing the x-coordinate of the minimum point found by the optimization algorithm.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy import optimize\n\n# Define Univariate Function\ndef poly(x):\n    return x * (x - 1) * (x + 1) * (x - 4)\n\n# main function\ndef main_solution(start_value):\n  # Convert JSON serializable input to the required format\n  start_value = float(start_value)\n  \n  # Perform multivariate optimisation using the start value\n  x_opt = optimize.fmin(poly, start_value)\n  \n  # Convert the result to JSON serializable output\n  result = float(x_opt[0])\n  \n  return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random start value within a reasonable range\n    start_value = random.uniform(-5.0, 5.0)\n    return {'start_value': start_value}", "io_pairs": [{"input": {"start_value": -3.6541101117236687}, "output": -0.6009298269670665}, {"input": {"start_value": 4.579184053014174}, "output": 3.0565718164412568}, {"input": {"start_value": 3.792051685477979}, "output": 3.0565084569349468}, {"input": {"start_value": 0.3917328860346183}, "output": -0.6009886366800661}, {"input": {"start_value": -1.8266729882800101}, "output": -0.6009825485854825}, {"input": {"start_value": -2.9735643399404488}, "output": -0.6009561915533945}, {"input": {"start_value": -1.8612648817511923}, "output": -0.6009122752997489}, {"input": {"start_value": -3.8566284822412245}, "output": 3.056585215307517}, {"input": {"start_value": 2.837488331200703}, "output": 3.0565346716122415}, {"input": {"start_value": -2.111602411725287}, "output": -0.6009509109736744}], "error_log": []}
{"context": "Given a set of `n` distinct items, how many ways can you choose `k` items from the set, considering that the result should be computed modulo a prime number `p`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The total number of items.\n  `k` (int): The number of items to choose.\n  `p` (int): The prime number used for the modulo operation.\n\nOutput:\n  `return` (int): The result of the combination calculation (nCk) modulo p.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef comb(n, k, p):\n    \"\"\"Calculate (nCk) mod p using Fermat's Little Theorem\"\"\"\n    if n < 0 or k < 0 or n < k:\n        return 0\n    if n == 0 or k == 0:\n        return 1\n    a = math.factorial(n) % p\n    b = math.factorial(k) % p\n    c = math.factorial(n - k) % p\n    return (a * power_func(b, p - 2, p) * power_func(c, p - 2, p)) % p\n\ndef power_func(a, b, p):\n    \"\"\"Calculate a^b mod p using exponentiation by squaring\"\"\"\n    if b == 0:\n        return 1\n    if b % 2 == 0:\n        d = power_func(a, b // 2, p)\n        return d * d % p\n    if b % 2 == 1:\n        return (a * power_func(a, b - 1, p)) % p\n\n# main function\ndef main_solution(n, k, p):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return comb(n, k, p)", "input_generator": "import random\nimport math\n\ndef input_generator():\n    p = random.choice([10**9 + 7, 998244353, 1000000009])\n    max_n = random.choice([100, 500, 1000])\n    n = random.randint(0, max_n)\n    k = random.randint(0, n)\n    return {'n': n, 'k': k, 'p': p}", "io_pairs": [{"input": {"n": 11, "k": 6, "p": 998244353}, "output": 462}, {"input": {"n": 416, "k": 158, "p": 1000000009}, "output": 561492590}, {"input": {"n": 328, "k": 47, "p": 998244353}, "output": 293436051}, {"input": {"n": 322, "k": 301, "p": 998244353}, "output": 929117721}, {"input": {"n": 85, "k": 41, "p": 1000000009}, "output": 71715335}, {"input": {"n": 51, "k": 25, "p": 1000000007}, "output": 264738339}, {"input": {"n": 918, "k": 54, "p": 1000000007}, "output": 666133986}, {"input": {"n": 81, "k": 51, "p": 1000000007}, "output": 75656074}, {"input": {"n": 489, "k": 50, "p": 998244353}, "output": 778920079}, {"input": {"n": 977, "k": 726, "p": 998244353}, "output": 146271669}], "error_log": []}
{"context": "Given two non-negative integers `m` and `n`, what is the result of the Ackermann function applied to these integers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (int): The first integer input for the Ackermann function.\n  `n` (int): The second integer input for the Ackermann function.\n\nOutput:\n  `return` (int or None): The result of the Ackermann function for the given inputs `m` and `n`. Returns `None` if the inputs are invalid (e.g., non-integer or negative integers).", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef ack(m, n):\n    if not isinstance(n, int):\n        return None\n    elif n < 0:\n        return None    \n    elif m == 0:\n        return n + 1\n    elif m > 0 and n == 0:\n        return ack(m - 1, 1)\n    elif m > 0 and n > 0:\n        return ack(m - 1, ack(m, n - 1))\n\n# main function\ndef main_solution(m, n):\n    # Convert input variables to integers if they are not already\n    m = int(m)\n    n = int(n)\n    \n    # Call the ack function with the converted inputs\n    result = ack(m, n)\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate m and n with reasonable bounds to avoid excessive recursion depth\n    m = random.randint(0, 3)  # Keeping m small due to Ackermann's function growth\n    n = random.randint(0, 5)  # n can be slightly larger but still reasonable\n    return {'m': m, 'n': n}", "io_pairs": [{"input": {"m": 2, "n": 5}, "output": 13}, {"input": {"m": 2, "n": 1}, "output": 5}, {"input": {"m": 1, "n": 1}, "output": 3}, {"input": {"m": 1, "n": 0}, "output": 2}, {"input": {"m": 2, "n": 0}, "output": 3}, {"input": {"m": 3, "n": 2}, "output": 29}, {"input": {"m": 0, "n": 3}, "output": 4}, {"input": {"m": 3, "n": 0}, "output": 5}, {"input": {"m": 0, "n": 5}, "output": 6}, {"input": {"m": 2, "n": 4}, "output": 11}], "error_log": []}
{"context": "Given an initial configuration of an 8-puzzle, how many states need to be visited before reaching the goal state where the tiles are in the correct order? The goal state is defined as `[0, 1, 2, 3, 4, 5, 6, 7, 8]`, where `0` represents the empty space.\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_state` (tuple): A tuple of integers representing the initial state of the 8-puzzle. The tuple should contain exactly 9 integers, where each integer is between 0 and 8, and each integer should appear exactly once. The 0 represents the empty space.\n\nOutput:\n  `return` (int): The number of states visited before reaching the goal state. If the goal state is not reached, it returns -1.", "reference_code": "# import necessary packages\nimport heapq\nimport random\n\n# all class and function definitions in the code file, if any\ndef swap(state, start, dest):\n    s = state[:]\n    tmp = s[start]\n    s[start] = s[dest]\n    s[dest] = tmp\n    return s\n\ndef succ(state):\n    v = []\n    i = state.index(0)\n    if (i - 3) >= 0:\n        v.append(swap(state, i, i - 3))\n    if (i % 3) != 2:\n        v.append(swap(state, i, i + 1))\n    if (i + 3) <= 8:\n        v.append(swap(state, i, i + 3))\n    if (i % 3) != 0:\n        v.append(swap(state, i, i - 1))\n    return v\n\ndef manhattan_distance(p1, p2):\n    return abs(p1 // 3 - p2 // 3) + abs(p1 % 3 - p2 % 3)\n\ndef distance(state):\n    tot = 0\n    for i in range(1, 9):\n        tot += manhattan_distance(i - 1, state.index(i))\n    return tot\n\ndef solve(state):\n    pq = []\n    visited = []\n    searched = []\n    heapq.heappush(pq, (distance(state), state, (0, distance(state), -1, 0)))\n    ct = 1\n    while pq:\n        head = heapq.heappop(pq)\n        visited.append(head)\n        if distance(head[1]) == 0:\n            return len(visited)\n        successors = succ(head[1])\n        for suc in successors:\n            if suc not in searched:\n                heapq.heappush(pq, (distance(suc) + head[2][0] + 1, suc, (head[2][0] + 1, distance(suc), head[2][3], ct)))\n                searched.append(suc)\n                ct += 1\n    return -1\n\n# main function\ndef main_solution(initial_state):\n    # Convert input to the required format\n    initial_state = list(initial_state)\n    \n    # Call the solve function\n    result = solve(initial_state)\n    \n    # Return the result\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random permutation of numbers 0-8 (0 represents the empty tile)\n    state = list(range(9))\n    random.shuffle(state)\n    \n    # Ensure the state is solvable (permutation inversion count must be even)\n    inversion_count = 0\n    for i in range(9):\n        for j in range(i + 1, 9):\n            if state[i] != 0 and state[j] != 0 and state[i] > state[j]:\n                inversion_count += 1\n    if inversion_count % 2 != 0:\n        # Swap two non-zero tiles to make inversion count even\n        non_zero = [i for i in range(9) if state[i] != 0]\n        if len(non_zero) >= 2:\n            i, j = random.sample(non_zero, 2)\n            state[i], state[j] = state[j], state[i]\n    \n    return {'initial_state': tuple(state)}", "io_pairs": [{"input": {"initial_state": [4, 6, 2, 8, 7, 0, 5, 3, 1]}, "output": 577}, {"input": {"initial_state": [0, 6, 1, 5, 4, 7, 3, 8, 2]}, "output": 667}, {"input": {"initial_state": [8, 0, 3, 2, 1, 4, 5, 6, 7]}, "output": 250}, {"input": {"initial_state": [1, 8, 2, 6, 3, 5, 0, 4, 7]}, "output": 35}, {"input": {"initial_state": [6, 7, 2, 4, 1, 8, 0, 5, 3]}, "output": 320}, {"input": {"initial_state": [0, 7, 6, 3, 1, 8, 5, 2, 4]}, "output": 22}, {"input": {"initial_state": [0, 3, 6, 1, 8, 4, 5, 2, 7]}, "output": 682}, {"input": {"initial_state": [3, 4, 7, 6, 1, 5, 0, 2, 8]}, "output": 950}, {"input": {"initial_state": [3, 7, 6, 8, 5, 2, 0, 4, 1]}, "output": 1320}, {"input": {"initial_state": [4, 5, 3, 6, 1, 8, 2, 7, 0]}, "output": 254}], "error_log": []}
{"context": "A child is running up a staircase with `n` steps and can hop either 1 step, 2 steps, or 3 steps at a time. How many possible ways can the child run up the stairs?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of steps in the staircase. It should be a positive integer.\n\nOutput:\n  `return` (int): The number of possible ways the child can run up the stairs.", "reference_code": "# import necessary packages\nimport copy\nfrom collections import Counter\nfrom typing import Union, TypeVar\n\n# all class and function definitions in the code file, if any\nclass InvalidInputException(Exception):\n    pass\n\nclass Error(Exception):\n    pass\n\n# main function\ndef main_solution(n: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # Convert the input to the required format for the count_ways_memo function\n    memo = {}\n    \n    # Call the count_ways_memo function to get the number of ways to climb the stairs\n    result = count_ways_memo(n, memo)\n    \n    # Return the result, which is JSON serializable\n    return result\n\n# Function to count the number of ways to climb the stairs using memoization\ndef count_ways_memo(n: int, memo: dict = None) -> int:\n    if not memo:\n        memo = {}\n    if n <= 1:\n        memo[n] = 1\n        return 1\n    if n == 2:\n        memo[2] = 2\n        return 2\n    if n in memo:\n        return memo[n]\n    \n    memo[n] = (count_ways_memo(n - 1, memo) + count_ways_memo(n - 2, memo) + count_ways_memo(n - 3, memo))\n    return memo[n]", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(0, 20)  # Reasonable range to avoid excessive computation\n    return {'n': n}", "io_pairs": [{"input": {"n": 14}, "output": 3136}, {"input": {"n": 6}, "output": 24}, {"input": {"n": 5}, "output": 13}, {"input": {"n": 15}, "output": 5768}, {"input": {"n": 20}, "output": 121415}, {"input": {"n": 7}, "output": 44}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 17}, "output": 19513}, {"input": {"n": 12}, "output": 927}, {"input": {"n": 4}, "output": 7}], "error_log": []}
{"context": "Given a graph represented by its adjacency list, determine whether the graph is bipartite. If it is bipartite, also identify the two sets of vertices that form the bipartition. What is the result of checking if the graph is bipartite and, if so, what are the two sets of vertices in the bipartition?\n\nThe input and output requirements are as follows:\n\nInput:\n  `graph` (dict): A dictionary representing the adjacency list of the graph. The keys are integers representing the vertices, and the values are lists of integers representing the adjacent vertices.\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `is_bipartite` (bool): A boolean indicating whether the graph is bipartite.\n    - `partition_vertexes` (list of lists of int): A list of two lists, each containing integers representing the vertices in each partition. If the graph is not bipartite, this value is an empty list.", "reference_code": "# import necessary packages\nimport queue\n\n# all class and function definitions in the code file, if any\nclass BiPartitionDetection:\n    def __init__(self, graph):\n        \"\"\"\n        \u68c0\u67e5\u56fe\u7247\u662f\u5426\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\u3002\n        \u4e0d\u8bf4\u5b9a\u4e49\u4e86\uff0c\u8054\u60f3\u4e00\u4e0b\u5168\u8fde\u63a5\u5c42\u5c31\u5b8c\u4e8b\u4e86\u3002\n        :param graph:\n        \"\"\"\n        self.graph = graph\n\n        self.colors = [-1 for _ in range(self.graph.V)]\n        self.bipartite_flag = True\n        for v in range(self.graph.V):  # \u8003\u8651\u8fde\u901a\u5206\u91cf\u4e0d\u53ea\u4e00\u4e2a\u7684\u60c5\u5f62\n            if self.colors[v] == -1:  # \u6ca1\u88ab\u67d3\u8fc7\u8272\n                # \u521d\u59cb\u67d3\u62100\uff0c\u67d3\u62101\u4e5f\u4e00\u6837\uff0c\u65e0\u6240\u8c13\u8fd9\u4e2a\n                self.bipartite_flag = self._bfs(v)\n                if not self.bipartite_flag:  # \u63d0\u524d\u7ed3\u675f\n                    break\n\n    def is_bipartite(self):\n        \"\"\"\u8fd4\u56de\u662f\u5426\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\"\"\"\n        return self.bipartite_flag\n\n    def get_patrition_vertexes(self):\n        \"\"\"\u8fd4\u56de\u4e8c\u5206\u56fe\u7684\u9876\u70b9\u5212\u5206\u6570\u7ec4\"\"\"\n        if not self.bipartite_flag:\n            return []  # \u8fd4\u56de\u7a7a\u6570\u7ec4\u8868\u660e\u4f20\u5165\u7684\u56fe\u4e0d\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\n\n        res = [[] for _ in range(2)]\n        for i in range(len(self.colors)):\n            res[self.colors[i]].append(i)\n        return res\n\n    # private\n    def _bfs(self, v):\n        \"\"\"bfs\uff0cO(V+E)\"\"\"\n        q = queue.Queue()\n        q.put(v)\n        self.colors[v] = 0  # 1\u4e5f\u4e00\u6837\uff0c\u65e0\u6240\u8c13\u7684\n\n        while not q.empty():\n            head = q.get()\n            for w in self.graph.adjacent(head):\n                if self.colors[w] == -1:  # \u6ca1\u88ab\u904d\u5386\u8fc7\n                    q.put(w)\n                    self.colors[w] = 1 - self.colors[head]  # \u548chead\u53cd\u8272\n                # \u88ab\u904d\u5386\u8fc7\u5e76\u4e14\u4e0d\u548chead\u53cd\u8272\uff0c\u90a3\u5c31\u8fd4\u56deFalse\n                elif self.colors[w] != 1 - self.colors[head]:\n                    return False\n        return True\n\n# main function\ndef main_solution(graph):\n    # graph is a dictionary representing the adjacency list of the graph\n    # Convert the input graph to a Graph object\n    class Graph:\n        def __init__(self, V):\n            self.V = V\n            self.adj = {i: [] for i in range(V)}\n        \n        def add_edge(self, v, w):\n            self.adj[v].append(w)\n            self.adj[w].append(v)\n        \n        def adjacent(self, v):\n            return self.adj[v]\n\n    V = len(graph)\n    g = Graph(V)\n    for v in graph:\n        for w in graph[v]:\n            g.add_edge(v, w)\n\n    # Create an instance of BiPartitionDetection\n    bpd = BiPartitionDetection(g)\n\n    # Check if the graph is bipartite\n    is_bipartite = bpd.is_bipartite()\n\n    # Get the partition of vertexes if the graph is bipartite\n    partition_vertexes = bpd.get_patrition_vertexes()\n\n    # Convert the partition_vertexes to a JSON serializable format\n    if partition_vertexes:\n        partition_vertexes = [sorted(part) for part in partition_vertexes]\n\n    return {\"is_bipartite\": is_bipartite, \"partition_vertexes\": partition_vertexes}", "input_generator": "import random\n\ndef input_generator():\n    # Randomly decide the number of vertices (between 2 and 10)\n    V = random.randint(2, 10)\n    graph = {i: [] for i in range(V)}\n    \n    # Randomly decide if the graph should be bipartite (50% chance)\n    is_bipartite = random.choice([True, False])\n    \n    if is_bipartite:\n        # Create a bipartite graph\n        # Split vertices into two partitions\n        partition1 = list(range(0, V, 2))\n        partition2 = list(range(1, V, 2))\n        # Add edges only between partitions\n        for v in partition1:\n            for w in partition2:\n                if random.choice([True, False]):  # Randomly add edges\n                    graph[v].append(w)\n                    graph[w].append(v)\n    else:\n        # Create a non-bipartite graph (ensure there's an odd-length cycle)\n        # Start by making a cycle of length 3 (triangle)\n        if V >= 3:\n            for i in range(3):\n                graph[i].append((i + 1) % 3)\n                graph[(i + 1) % 3].append(i)\n        # Add random edges to the remaining vertices\n        for v in range(V):\n            for w in range(v + 1, V):\n                if random.choice([True, False]):\n                    graph[v].append(w)\n                    graph[w].append(v)\n    \n    # Ensure no duplicate edges and vertices are not connected to themselves\n    for v in graph:\n        graph[v] = list(set(graph[v]))\n        if v in graph[v]:\n            graph[v].remove(v)\n    \n    return {\"graph\": graph}", "io_pairs": [{"input": {"graph": {"0": [], "1": [], "2": []}}, "output": {"is_bipartite": true, "partition_vertexes": [[0, 1, 2], []]}}, {"input": {"graph": {"0": [], "1": []}}, "output": {"is_bipartite": true, "partition_vertexes": [[0, 1], []]}}, {"input": {"graph": {"0": [3], "1": [2], "2": [1], "3": [0]}}, "output": {"is_bipartite": true, "partition_vertexes": [[0, 1], [2, 3]]}}, {"input": {"graph": {"0": [1, 2, 3, 4], "1": [0, 2, 3, 4], "2": [0, 1], "3": [0, 1], "4": [0, 1]}}, "output": {"is_bipartite": false, "partition_vertexes": []}}, {"input": {"graph": {"0": [1], "1": [0]}}, "output": {"is_bipartite": true, "partition_vertexes": [[0], [1]]}}, {"input": {"graph": {"0": [1], "1": [0, 2], "2": [1, 3], "3": [2]}}, "output": {"is_bipartite": true, "partition_vertexes": [[0, 2], [1, 3]]}}, {"input": {"graph": {"0": [1, 2, 3], "1": [0, 2], "2": [0, 1], "3": [0]}}, "output": {"is_bipartite": false, "partition_vertexes": []}}, {"input": {"graph": {"0": [1, 2, 3, 4], "1": [0, 2, 4], "2": [0, 1], "3": [0], "4": [0, 1]}}, "output": {"is_bipartite": false, "partition_vertexes": []}}, {"input": {"graph": {"0": [1, 2, 3], "1": [0, 2, 4], "2": [0, 1], "3": [0], "4": [1]}}, "output": {"is_bipartite": false, "partition_vertexes": []}}, {"input": {"graph": {"0": [1], "1": [0, 2], "2": [1, 3], "3": [2, 4], "4": [3]}}, "output": {"is_bipartite": true, "partition_vertexes": [[0, 2, 4], [1, 3]]}}], "error_log": []}
{"context": "In an experiment to study the relationship between current and voltage across a resistor, you have collected a set of data points. Given this data, how would you determine the voltage at a specific current value using both Newton's polynomial interpolation and polynomial regression? Specifically, what are the voltage values calculated using these two methods for a given target current?\n\nThe input and output requirements are as follows:\n\nInput:\n  `currents` (list of float): A list of current values measured in the experiment.\n  `voltages` (list of float): A list of voltage values corresponding to the current values.\n  `target_current` (float): The current value for which the voltage needs to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing the calculated voltage values.\n    - `voltage_newton` (float): The voltage calculated using Newton's polynomial interpolation.\n    - `voltage_regression` (float): The voltage calculated using polynomial regression.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef coef(x, y):\n    x.astype(float)\n    y.astype(float)\n    n = len(x)\n    a = []\n    for i in range(n):\n        a.append(y[i])\n\n    for j in range(1, n):\n        for i in range(n-1, j-1, -1):\n            a[i] = float(a[i]-a[i-1])/float(x[i]-x[i-j])\n    \n    return np.array(a)\n\ndef puntoa(x, y, a):\n    func = (lambda x1: a[0] + a[1]*(x1-x[0]) + a[2]*(x1-x[0])*(x1-x[1]) + a[3]*(x1-x[0])*(x1-x[1])*(x1-x[2]))\n    return func(0.10)\n\ndef b(i, V, punto):\n    C = np.polyfit(i, V, 3)\n    func = (lambda th: C[0]*th**3 + C[1]*th**2 + C[2]*th**1 + C[3])\n    return func(punto)\n\n# main function\ndef main_solution(currents, voltages, target_current):\n    # Convert inputs to numpy arrays\n    currents = np.array(currents)\n    voltages = np.array(voltages)\n    \n    # Calculate coefficients for Newton's polynomial interpolation\n    coefficients = coef(currents, voltages)\n    \n    # Calculate voltage using Newton's polynomial interpolation\n    voltage_newton = puntoa(currents, voltages, coefficients)\n    \n    # Calculate voltage using polynomial regression\n    voltage_regression = b(currents, voltages, target_current)\n    \n    # Return the results as a dictionary\n    return {\n        \"voltage_newton\": voltage_newton,\n        \"voltage_regression\": voltage_regression\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random number of points (between 4 and 10)\n    n = random.randint(4, 10)\n    \n    # Generate random currents (sorted to avoid division issues in coef)\n    currents = np.sort(np.random.uniform(0.1, 10.0, n))\n    \n    # Generate corresponding voltages (random but somewhat correlated with currents)\n    voltages = currents * np.random.uniform(0.5, 2.0, n) + np.random.normal(0, 0.5, n)\n    \n    # Generate a target current within the range of currents\n    target_current = random.uniform(min(currents), max(currents))\n    \n    return {\n        \"currents\": currents.tolist(),\n        \"voltages\": voltages.tolist(),\n        \"target_current\": target_current\n    }", "io_pairs": [{"input": {"currents": [3.870568127854471, 5.077734943736838, 5.376329708161343, 6.0670721629039, 6.884009578798516, 9.73631902137692], "voltages": [4.185840388976556, 3.27949773974931, 9.325584546443032, 4.643392108889211, 10.768781909818953, 13.376843148683301], "target_current": 9.626003099474655}, "output": {"voltage_newton": 2129.1904365131777, "voltage_regression": 13.578406877480674}}, {"input": {"currents": [0.8308358338939436, 7.745357723632029, 8.607193451639768, 9.115950477829319], "voltages": [1.4036983836307924, 10.46014390942112, 16.416230216294107, 12.357068216543906], "target_current": 1.5441130407906378}, "output": {"voltage_newton": 70.93067952056732, "voltage_regression": -44.52829948653266}}, {"input": {"currents": [1.7149408998640339, 6.007323021880718, 7.3576316328081655, 7.805725036149016, 9.095586135322089], "voltages": [2.5333189238066396, 8.067088449274374, 4.75697530828819, 15.194943380326388, 17.50276597705329], "target_current": 6.249222383569791}, "output": {"voltage_newton": -176.1448079074331, "voltage_regression": 7.413990757167507}}, {"input": {"currents": [1.343497072745868, 2.46431335289614, 2.7398575447861746, 4.521324696250949, 7.06167043287448], "voltages": [1.5232380203067588, 5.39984874788841, 3.360649923276018, 4.495701454823847, 4.573030988165552], "target_current": 1.4776472317679141}, "output": {"voltage_newton": -54.178802431352636, "voltage_regression": 2.095910856272483}}, {"input": {"currents": [0.4711602636343557, 1.9397265714407088, 4.274548337327014, 4.687269787154863, 4.721687106636137, 6.1954526514660015, 8.860133207836247], "voltages": [1.0600157939035597, 3.713137164714358, 7.935481975197113, 9.138929087212986, 2.2240169235977594, 5.67818224568788, 5.33755210585402], "target_current": 5.117525775969012}, "output": {"voltage_newton": 0.11760593710247091, "voltage_regression": 6.1911233090777795}}, {"input": {"currents": [2.4558588064084055, 3.270682185791806, 3.619638692016875, 4.479055269816414], "voltages": [4.132947727747661, 3.9729840580422553, 2.490858985117135, 5.712388034382133], "target_current": 3.906462796304331}, "output": {"voltage_newton": -152.62353069549374, "voltage_regression": 1.9581397142416677}}, {"input": {"currents": [2.158908853652617, 3.4453071830456676, 4.6605656876368675, 7.392691493048918], "voltages": [1.253268898388558, 4.656804693691379, 2.5587006080850156, 9.302133465208431], "target_current": 6.2978128891954945}, "output": {"voltage_newton": -33.09924608230392, "voltage_regression": 1.9491438861597175}}, {"input": {"currents": [0.931540040969587, 1.9280075419754086, 2.7540918611387264, 6.864455617984182, 8.667342489632498], "voltages": [1.0945519474264378, 2.909212802754926, 4.987090298899902, 6.607101260291146, 14.462858619432236], "target_current": 4.18009486066894}, "output": {"voltage_newton": 0.710476436845802, "voltage_regression": 4.792161683049272}}, {"input": {"currents": [0.7904786884288834, 1.2620239048877129, 7.284604531184889, 7.993388920789181, 9.777309641357798], "voltages": [1.3828319860249578, 0.7128162555815128, 7.772838034768297, 6.884899521021877, 18.167392524798043], "target_current": 7.9659252145778465}, "output": {"voltage_newton": 3.2922040390652523, "voltage_regression": 8.45746687158498}}, {"input": {"currents": [0.506033419325731, 3.2327377714602106, 4.85977546441182, 5.995396171156739], "voltages": [0.3908433266371976, 5.135386519946624, 6.421749737042405, 5.33560368827863], "target_current": 4.455351197700067}, "output": {"voltage_newton": -0.13608809138937727, "voltage_regression": 6.357215189252223}}], "error_log": []}
{"context": "In a laboratory, a centrifuge is used to separate fluids based on density. The centrifuge has `n` holes arranged in a circle, and `k` test tubes need to be placed in these holes. The centrifuge is balanced if the center of mass of the test tubes is at the center of the circle. Given the total number of holes `n` and the number of test tubes `k`, determine if the configuration is balanced.\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The total number of holes in the centrifuge.\n  `k` (int): The number of test tubes to be placed in the centrifuge.\n\nOutput:\n  `return` (bool): `True` if the configuration is balanced, `False` otherwise.", "reference_code": "# import necessary packages\nimport math\nfrom itertools import combinations\n\n# main function\ndef main_solution(n, k):\n    # Convert inputs to integers\n    n = int(n)\n    k = int(k)\n    \n    # Check for trivial cases\n    if n == 1 or k == 1:\n        return False\n    \n    # Generate all combinations of k items from n\n    clist = list(combinations([i for i in range(n)], k))\n    \n    # Calculate the angle increment\n    angle = 2 * math.pi / n\n    \n    # Generate the list of sine and cosine values for each position\n    alist = [[math.sin(a), math.cos(a)] for a in [i * angle for i in range(n)]]\n    \n    # Check each combination for balance\n    for i in clist:\n        x, y = 0, 0\n        for j in i:\n            y += alist[j][0]\n            x += alist[j][1]\n        if abs(x / k) < 0.001 and abs(y / k) < 0.001:\n            return True\n    \n    return False", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(2, 20)\n    k = random.randint(2, n)\n    return {'n': n, 'k': k}", "io_pairs": [{"input": {"n": 8, "k": 2}, "output": true}, {"input": {"n": 7, "k": 7}, "output": true}, {"input": {"n": 17, "k": 4}, "output": false}, {"input": {"n": 19, "k": 18}, "output": false}, {"input": {"n": 17, "k": 12}, "output": false}, {"input": {"n": 3, "k": 3}, "output": true}, {"input": {"n": 12, "k": 4}, "output": true}, {"input": {"n": 17, "k": 9}, "output": false}, {"input": {"n": 6, "k": 3}, "output": true}, {"input": {"n": 11, "k": 9}, "output": false}], "error_log": []}
{"context": "In a series of trials, we have collected data on the outcomes of each trial. We want to determine whether the data points follow a Bernoulli distribution with a specific probability parameter `p`. Given the collected data and the probability parameter `p`, what is the conclusion of the hypothesis test regarding the null hypothesis that the data points are Bernoulli random variables with the given probability parameter `p`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data` (list of floats): A list of numerical data points representing the outcomes of a series of trials.\n  `p` (float): The probability parameter for the Bernoulli distribution, a value between 0 and 1.\n\nOutput:\n  `return` (string): A string indicating the result of the hypothesis test. It can either be \"Reject the null hypothesis\" or \"Insufficient evidence to reject the null hypothesis\".", "reference_code": "# import necessary packages\nimport numpy as np\nimport scipy.stats\n\n# all class and function definitions in the code file, if any\ndef statistic(data):\n    return np.sum(data)\n\ndef criticalRange(p, n):\n    alpha = 0.05\n    lower = scipy.stats.binom.ppf(alpha/2, n, p)\n    upper = scipy.stats.binom.ppf(1 - alpha/2, n, p)\n    return lower, upper\n\ndef hypothesisTest(data, p):\n    l, u = criticalRange(p, len(data))\n    sum_data = statistic(data)\n    if sum_data < l or sum_data > u:\n        return \"Reject the null hypothesis\"\n    else:\n        return \"Insufficient evidence to reject the null hypothesis\"\n\n# main function\ndef main_solution(data, p):\n    # Convert input data to a list if it's a numpy array\n    if isinstance(data, np.ndarray):\n        data = data.tolist()\n    \n    # Perform the hypothesis test\n    result = hypothesisTest(data, p)\n    \n    # Return the result as a string\n    return result", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the size of the data array between 10 and 100\n    n = random.randint(10, 100)\n    \n    # Generate random binary data (0s and 1s)\n    data = np.random.randint(0, 2, size=n)\n    \n    # Randomly choose p between 0.1 and 0.9, ensuring it's not too extreme\n    p = round(random.uniform(0.1, 0.9), 2)\n    \n    return {'data': data, 'p': p}", "io_pairs": [], "error_log": []}
{"context": "Given the position of a Fibonacci number, what is the value of the Fibonacci number at that position using the Binet-Cauchy formula?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The position of the Fibonacci number to be calculated. It should be a positive integer.\n\nOutput:\n  `return` (str): The nth Fibonacci number as a string.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(n):\n    # Convert JSON serializable input to the required format\n    n = int(n)\n    \n    # Binet-Cauchy formula constants\n    a = 0.44721359549995793928183473374625\n    b = 1.6180339887498948482045868343656\n    c = 0.61803398874989484820458683436564\n    \n    # Calculate the nth Fibonacci number using Binet-Cayne formula\n    fib_n = round(a * (pow(b, n) + pow(c, n)))\n    \n    # Convert the result to a JSON serializable output\n    return str(fib_n)", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 20)\n    return {'n': n}", "io_pairs": [{"input": {"n": 12}, "output": "144"}, {"input": {"n": 20}, "output": "6765"}, {"input": {"n": 8}, "output": "21"}, {"input": {"n": 7}, "output": "13"}, {"input": {"n": 3}, "output": "2"}, {"input": {"n": 14}, "output": "377"}, {"input": {"n": 10}, "output": "55"}, {"input": {"n": 19}, "output": "4181"}, {"input": {"n": 1}, "output": "1"}, {"input": {"n": 13}, "output": "233"}], "error_log": []}
{"context": "A cashier has a number of coins of different denominations at her disposal and wishes to make a selection, using the fewest number of coins, to meet a given total. Given a list of coin denominations and a total amount, what is the minimum set of coins that can be used to make the total amount?\n\nThe input and output requirements are as follows:\n\nInput:\n  `coins` (list of int): A list of coin denominations available. Each denomination is a non-negative integer.\n  `total` (int): The total amount of money to be made using the fewest number of coins. This is a non-negative integer.\n\nOutput:\n  `return` (list of int): A list of integers representing the coins used to make the total amount, such that the number of coins is minimized. Each element in the list is a coin denomination.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef _get_change_making_matrix(c: int, n: int) -> list:\n    m = [[0 for _ in range(n + 1)] for _ in range(c + 1)]\n    for i in range(n + 1):\n        m[0][i] = i\n    return m\n\ndef _get_sets_of_coins_matrix(c: int, n: int) -> list:\n    m = [[[] for _ in range(n + 1)] for _ in range(c + 1)]\n    for i in range(n + 1):\n        for _ in range(i):\n            m[0][i].append(1)\n    for j in range(c + 1):\n        m[j][0] = []\n    return m\n\ndef _pre_conditions(coins: list, n: int) -> None:\n    assert isinstance(coins, list) or isinstance(coins, tuple)\n    assert isinstance(n, int)\n    assert all(isinstance(c, int) for c in coins)\n    if n < 0:\n        raise ValueError(\"n must be non-negative.\")\n    for c in coins:\n        if c < 0:\n            raise ValueError(\"All denominations must be non-negative.\")\n    if len(coins) == 0:\n        raise ValueError(\"No coins available.\")\n\ndef change_making(coins: list, n: int) -> int:\n    _pre_conditions(coins, n)\n    m = _get_change_making_matrix(len(coins), n)\n    for c in range(1, len(coins) + 1):\n        for z in range(1, n + 1):\n            if coins[c - 1] == z:\n                m[c][z] = 1\n            elif coins[c - 1] > z:\n                m[c][z] = m[c - 1][z]\n            else:\n                m[c][z] = min(m[c - 1][z], 1 + m[c][z - coins[c - 1]])\n    return m[-1][-1]\n\ndef extended_change_making(coins: list, n: int) -> list:\n    _pre_conditions(coins, n)\n    m = _get_change_making_matrix(len(coins), n)\n    p = _get_sets_of_coins_matrix(len(coins), n)\n    for c in range(1, len(coins) + 1):\n        for z in range(1, n + 1):\n            if coins[c - 1] == z:\n                m[c][z] = 1\n                p[c][z].append(coins[c - 1])\n            elif coins[c - 1] > z:\n                m[c][z] = m[c - 1][z]\n                p[c][z] = p[c - 1][z]\n            else:\n                if m[c - 1][z] < 1 + m[c][z - coins[c - 1]]:\n                    p[c][z] = p[c - 1][z]\n                    m[c][z] = m[c - 1][z]\n                else:\n                    p[c][z] = [coins[c - 1]] + p[c][z - coins[c - 1]]\n                    m[c][z] = 1 + m[c][z - coins[c - 1]]\n    assert sum(p[-1][-1]) == n\n    return p[-1][-1]\n\n# main function\ndef main_solution(coins: list, total: int) -> list:\n    # Convert input to JSON serializable format\n    coins = list(coins)\n    total = int(total)\n    \n    # Call the extended_change_making function\n    result = extended_change_making(coins, total)\n    \n    # Convert output to JSON serializable format\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random set of coin denominations\n    coin_types = random.choice([\n        [1, 5, 10, 25],  # US coins\n        [1, 2, 5, 10, 20, 50],  # Euro coins\n        [1, 2, 5, 10, 25, 50],  # Another common set\n        [1, 5, 10, 20, 50, 100],  # Including a larger coin\n    ])\n    \n    # Randomly shuffle the coin denominations to ensure variety\n    random.shuffle(coin_types)\n    \n    # Generate a random total amount between 1 and 100\n    total = random.randint(1, 100)\n    \n    return {\n        'coins': coin_types,\n        'total': total\n    }", "io_pairs": [{"input": {"coins": [50, 10, 1, 2, 5, 25], "total": 31}, "output": [25, 5, 1]}, {"input": {"coins": [20, 5, 50, 2, 10, 1], "total": 86}, "output": [1, 10, 50, 5, 20]}, {"input": {"coins": [1, 20, 5, 50, 100, 10], "total": 52}, "output": [50, 1, 1]}, {"input": {"coins": [20, 50, 1, 10, 2, 5], "total": 8}, "output": [5, 2, 1]}, {"input": {"coins": [25, 1, 10, 5], "total": 69}, "output": [5, 10, 1, 1, 1, 1, 25, 25]}, {"input": {"coins": [100, 20, 1, 5, 50, 10], "total": 11}, "output": [10, 1]}, {"input": {"coins": [10, 50, 5, 20, 2, 1], "total": 83}, "output": [1, 2, 20, 50, 10]}, {"input": {"coins": [20, 5, 10, 1, 2, 50], "total": 2}, "output": [2]}, {"input": {"coins": [50, 1, 2, 20, 10, 5], "total": 61}, "output": [10, 1, 50]}, {"input": {"coins": [5, 1, 10, 25], "total": 15}, "output": [10, 5]}], "error_log": []}
{"context": "In aviation, each aircraft is assigned a unique identifier known as the tail number. This identifier can be derived from the ICAO number, which is a unique number assigned to each aircraft by the International Civil Aviation Organization. Given an ICAO number, what is the corresponding tail number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `icao_number` (int): An integer representing the ICAO (International Civil Aviation Organization) number. This number should be within the range of 0xA00001 to 0xadf7c7.\n\nOutput:\n  `return` (str): A string representing the tail number corresponding to the given ICAO number. The tail number will start with 'N' followed by up to three digits and an optional two-character suffix.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nbase9 = '123456789'  # The first digit (after the \"N\") is always one of these.\nbase10 = '0123456789' # The possible second and third digits are one of these.\n# Note that \"I\" and \"O\" are never used as letters, to prevent confusion with \"1\" and \"0\"\nbase34 = 'ABCDEFGHJKLMNPQRSTUVWXYZ0123456789'\nicaooffset = 0xA00001 # The lowest possible number, N1, is this.\nb1 = 101711 # basis between N1... and N2...\nb2 = 10111 # basis between N10.... and N11....\n\ndef suffix(rem):\n    \"\"\" Produces the alpha(numeric) suffix from a number 0 - 950 \"\"\"\n    if rem == 0:\n        suf = ''\n    else:\n        if rem <= 600: #Class A suffix -- only letters.\n            rem = rem - 1\n            suf = base34[rem // 25]\n            if rem % 25 > 0:\n                suf = suf + base34[rem % 25 - 1]# second class A letter, if present.\n        else:  #rems > 600 : First digit of suffix is a number.  Second digit may be blank, letter, or number.\n            rem = rem - 601\n            suf = base10[rem // 35]\n            if rem % 35 > 0:\n                suf = suf + base34[rem % 35 - 1]\n    return suf\n\ndef enc_suffix(suf):\n    \"\"\" Produces a remainder from a 0 - 2 digit suffix.\n    No error checking.  Using illegal strings will have strange results.\"\"\"\n    if len(suf) == 0:\n        return 0\n    r0 = base34.find(suf[0])\n    if len(suf) == 1:\n        r1 = 0\n    else:\n        r1 = base34.find(suf[1]) + 1\n    if r0 < 24: # first char is a letter, use base 25\n        return r0 * 25 + r1 + 1\n    else:  # first is a number -- base 35.\n        return r0 * 35 + r1 - 239\n\ndef icao_to_tail(icao):\n    if (icao < 0) or (icao > 0xadf7c7):\n        return \"Undefined\"\n    icao = icao - icaooffset\n    d1 = icao // b1\n    nnum = 'N' + base9[d1]\n    r1 = icao % b1\n    if r1 < 601:\n        nnum = nnum + suffix(r1) # of the form N1ZZ\n    else:\n        d2 = (r1 - 601) // b2  # find second digit.\n        nnum = nnum + base10[d2]\n        r2 = (r1 - 601) % b2  # and residue after that\n        if r2 < 601:  # No third digit. (form N12ZZ)\n            nnum = nnum + suffix(r2)\n        else:\n            d3 = (r2 - 601) // 951 # Three-digits have extended suffix.\n            r3 = (r2 - 601) % 951\n            nnum = nnum + base10[d3] + suffix(r3)\n    return nnum\n\ndef tail_to_icao(tail):\n    if tail[0] != 'N':\n        return -1\n    icao = icaooffset\n    icao = icao + base9.find(tail[1]) * b1\n    if len(tail) == 2: # simple 'N3' etc.\n        return icao\n    d2 = base10.find(tail[2])\n    if d2 == -1: # Form N1A\n        icao = icao + enc_suffix(tail[2:4])\n        return icao\n    else: # Form N11... or N111..\n        icao = icao + d2 * b2 + 601\n        d3 = base10.find(tail[3])\n        if d3 > -1: #Form N111 Suffix is base 35.\n            icao = icao + d3 * 951 + 601\n            icao = icao + enc_suffix(tail[4:6])\n            return icao\n        else:  #Form N11A\n            icao = icao + enc_suffix(tail[3:5])\n            return icao\n\n# main function\ndef main_solution(icao_number):\n    # Convert ICAO number to tail number\n    tail_number = icao_to_tail(icao_number)\n    return tail_number", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random ICAO number within the valid range\n    icao_min = 0xA00001\n    icao_max = 0xADF7C7\n    icao_number = random.randint(icao_min, icao_max)\n    \n    return {'icao_number': icao_number}", "io_pairs": [{"input": {"icao_number": 10828723}, "output": "N436ZM"}, {"input": {"icao_number": 11324647}, "output": "N9239E"}, {"input": {"icao_number": 10520724}, "output": "N133YZ"}, {"input": {"icao_number": 10622575}, "output": "N2333J"}, {"input": {"icao_number": 10918324}, "output": "N524VQ"}, {"input": {"icao_number": 11143649}, "output": "N746LU"}, {"input": {"icao_number": 11311197}, "output": "N910TJ"}, {"input": {"icao_number": 10911529}, "output": "N518AB"}, {"input": {"icao_number": 11042306}, "output": "N6461B"}, {"input": {"icao_number": 10617593}, "output": "N229FM"}], "error_log": []}
{"context": "Given two integers `a` and `b`, and a result `d`, find the coefficients `x` and `y` such that the equation `ax + by = d` holds true. Additionally, verify if the calculated coefficients satisfy the equation. What are the values of `x` and `y`, and does the equation hold true with these coefficients?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): The first integer in the equation `ax + by = d`.\n  `b` (int): The second integer in the equation `ax + by = d`.\n  `d` (int): The result of the equation `ax + by = d`.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `x` (int): The coefficient `x` in the equation `ax + by = d`.\n    - `y` (int): The coefficient `y` in the equation `ax + by = d`.\n    - `verification` (bool): A boolean indicating whether the equation `ax + by = d` holds true with the calculated `x` and `y`.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef euclidean(a, b):\n    '''\n    find x, y such that ax+by=gcd\n    '''\n    q = a // b\n    r = a % b\n\n    if r == 0:\n        return (1, 1-q)\n    (m, n) = euclidean(b, r)\n    return (n, m-q*n)\n\ndef verify_euc(a, b, d, e):\n    (x, y) = e\n    return a * x + b * y == d\n\n# main function\ndef main_solution(a, b, d):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = euclidean(a, b)\n    verification = verify_euc(a, b, d, result)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"x\": result[0], \"y\": result[1], \"verification\": verification}", "input_generator": "import random\n\ndef input_generator():\n    a = random.randint(1, 1000)\n    b = random.randint(1, a)  # Ensure b <= a to avoid trivial cases\n    d = random.randint(1, 100)\n    return {\"a\": a, \"b\": b, \"d\": d}", "io_pairs": [{"input": {"a": 833, "b": 342, "d": 6}, "output": {"x": -241, "y": 587, "verification": false}}, {"input": {"a": 369, "b": 244, "d": 15}, "output": {"x": -203, "y": 307, "verification": false}}, {"input": {"a": 899, "b": 362, "d": 91}, "output": {"x": 211, "y": -524, "verification": false}}, {"input": {"a": 842, "b": 463, "d": 86}, "output": {"x": 237, "y": -431, "verification": false}}, {"input": {"a": 176, "b": 100, "d": 10}, "output": {"x": -21, "y": 37, "verification": false}}, {"input": {"a": 554, "b": 90, "d": 70}, "output": {"x": -32, "y": 197, "verification": false}}, {"input": {"a": 835, "b": 368, "d": 36}, "output": {"x": -197, "y": 447, "verification": false}}, {"input": {"a": 759, "b": 151, "d": 5}, "output": {"x": -113, "y": 568, "verification": false}}, {"input": {"a": 670, "b": 399, "d": 71}, "output": {"x": 346, "y": -581, "verification": false}}, {"input": {"a": 303, "b": 122, "d": 13}, "output": {"x": 91, "y": -226, "verification": false}}], "error_log": []}
{"context": "Given a square matrix of floating-point numbers, what is the determinant of the matrix, rounded to two decimal places?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of floats): A square matrix represented as a list of lists, where each inner list represents a row of the matrix. The matrix must be square (i.e., the number of rows must equal the number of columns).\n\nOutput:\n  `return` (float): The determinant of the input matrix, rounded to 2 decimal places.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix):\n    # Convert the input matrix to a numpy array\n    a = np.array(matrix, dtype=float)\n    \n    # Compute the determinant of the matrix\n    determinant = np.linalg.det(a)\n    \n    # Round the determinant to 2 decimal places\n    rounded_determinant = round(determinant, 2)\n    \n    # Return the rounded determinant\n    return rounded_determinant", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.choice([2, 3, 4])\n    matrix = np.random.randint(-10, 10, size=(size, size)).tolist()\n    return {'matrix': matrix}", "io_pairs": [{"input": {"matrix": [[6, -6, 7], [-10, -7, 1], [9, 8, -5]]}, "output": 289.0}, {"input": {"matrix": [[2, 3, 8], [-6, 5, -2], [0, -1, 0]]}, "output": 44.0}, {"input": {"matrix": [[2, 1], [3, -8]]}, "output": -19.0}, {"input": {"matrix": [[6, 4, -6, -1], [-1, 0, 9, 5], [9, -6, 6, 5], [2, 5, 5, -8]]}, "output": -7945.0}, {"input": {"matrix": [[-9, -8], [-10, -5]]}, "output": -35.0}, {"input": {"matrix": [[-3, -10, -6], [-10, 4, -8], [-3, -1, -5]]}, "output": 212.0}, {"input": {"matrix": [[-6, -6, -4], [-7, -9, -1], [-8, -5, 0]]}, "output": 130.0}, {"input": {"matrix": [[-3, 2], [1, -10]]}, "output": 28.0}, {"input": {"matrix": [[7, 9, 4], [4, 0, -1], [5, 3, -4]]}, "output": 168.0}, {"input": {"matrix": [[9, -6], [-7, -3]]}, "output": -69.0}], "error_log": []}
{"context": "Given a range of natural numbers from 1 to `n`, what is the difference between the sum of the squares of these numbers and the square of their sum?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The upper limit of the range for which the difference between the sum of the squares and the square of the sum is to be calculated.\n\nOutput:\n  `return` (int): The difference between the sum of the squares of the first `n` natural numbers and the square of their sum.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef square_diff(n):\n    s2 = (n**4 + 2 * n**3 + n**2) // 4\n    s1 = n * (n + 1) * (2*n + 1) // 6\n    return s2 - s1\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = square_diff(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 1000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 796}, "output": 100451210050}, {"input": {"n": 34}, "output": 340340}, {"input": {"n": 406}, "output": 6803839350}, {"input": {"n": 830}, "output": 118740927970}, {"input": {"n": 769}, "output": 87502602880}, {"input": {"n": 761}, "output": 83918590100}, {"input": {"n": 589}, "output": 30122514310}, {"input": {"n": 563}, "output": 25146999662}, {"input": {"n": 167}, "output": 195218324}, {"input": {"n": 23}, "output": 71852}], "error_log": []}
{"context": "Given a number, determine if it is a multiple of 9 using bitwise operations. What is the result of this check for a randomly generated number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): An integer number to be checked if it is a multiple of 9.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input number `n` is a multiple of 9 (`True` if it is, `False` otherwise).", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(n):\n    # Convert the input to an integer if it's not already\n    n = int(n)\n    \n    # Function to check if a number is a multiple of 9 using bitwise operators\n    def is_div_of_9(n):\n        if n == 0 or n == 9:\n            return True\n        if n < 9:\n            return False\n        return is_div_of_9((n >> 3) - (n & 7))\n    \n    # Return the result of the check\n    return is_div_of_9(n)", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random integer between 0 and 1000 with a higher chance of being around multiples of 9\n    if random.random() < 0.7:\n        # Generate a multiple of 9\n        n = random.randint(0, 100) * 9\n    else:\n        # Generate any random number\n        n = random.randint(0, 1000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 729}, "output": true}, {"input": {"n": 243}, "output": true}, {"input": {"n": 80}, "output": false}, {"input": {"n": 522}, "output": true}, {"input": {"n": 792}, "output": true}, {"input": {"n": 513}, "output": true}, {"input": {"n": 135}, "output": true}, {"input": {"n": 856}, "output": false}, {"input": {"n": 595}, "output": false}, {"input": {"n": 117}, "output": true}], "error_log": []}
{"context": "Given the average rate of events (lambda) and the number of events (x), what is the probability of observing exactly x events?\n\nThe input and output requirements are as follows:\n\nInput:\n  `lam` (float): The average rate of events (lambda).\n  `x` (int): The number of events (x).\n\nOutput:\n  `return` (float): The probability of x events occurring given the average rate of lam.", "reference_code": "# import necessary packages\nimport math\nfrom scipy.special import factorial\n\n# main function\ndef main_solution(lam, x):\n    \"\"\"\n    Calculate the Poisson distribution probability for a given lambda and x values.\n    \n    Parameters:\n    lam (float): The average rate of events (lambda).\n    x (int): The number of events (x).\n    \n    Returns:\n    float: The probability of x events occurring given the average rate of lam.\n    \"\"\"\n    return math.exp(-lam) * lam**x / factorial(x)", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    lam = random.uniform(0.1, 10.0)\n    x = random.randint(0, 20)\n    return {'lam': lam, 'x': x}", "io_pairs": [{"input": {"lam": 3.540702880497127, "x": 15}, "output": 3.820629548700805e-06}, {"input": {"lam": 4.882041188686312, "x": 19}, "output": 7.552472868842912e-07}, {"input": {"lam": 3.7485893133360455, "x": 14}, "output": 2.9224700734429402e-05}, {"input": {"lam": 5.251512559924758, "x": 19}, "output": 2.087402571464219e-06}, {"input": {"lam": 0.41548677467374096, "x": 15}, "output": 9.58108825295048e-19}, {"input": {"lam": 1.3606169060934479, "x": 12}, "output": 2.1556833952461946e-08}, {"input": {"lam": 7.905785181406143, "x": 15}, "output": 0.008303030822279504}, {"input": {"lam": 1.642097228043007, "x": 15}, "output": 2.5195886521558833e-10}, {"input": {"lam": 5.573707554735709, "x": 7}, "output": 0.1258775482646944}, {"input": {"lam": 3.3820303128748366, "x": 13}, "output": 4.132663331875429e-05}], "error_log": []}
{"context": "Imagine you are navigating a spiral grid where you start at the origin (0,0) and move in a spiral pattern. Each move increases the number of steps you take in a particular direction before changing direction. Given a target number in this spiral sequence, what are the final coordinates and the Manhattan distance from the origin after reaching or exceeding this number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `end` (int): The target number in the spiral sequence. The function will stop when it reaches or exceeds this number.\n\nOutput:\n  `return` (dict): A dictionary containing the final position and the Manhattan distance from the origin (0, 0).\n  - `final_position` (tuple): A tuple representing the final (x, y) coordinates after reaching or exceeding the target number.\n  - `manhattan_distance` (int): The Manhattan distance from the origin (0, 0) to the final position.", "reference_code": "# import necessary packages\nfrom itertools import cycle\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\ndef move_right(x, y):\n    return x + 1, y\n\ndef move_down(x, y):\n    return x, y - 1\n\ndef move_left(x, y):\n    return x - 1, y\n\ndef move_up(x, y):\n    return x, y + 1\n\ndef move_upright(x, y):\n    return move_up(*move_right(x, y))\n\ndef move_upleft(x, y):\n    return move_up(*move_left(x, y))\n\ndef move_downright(x, y):\n    return move_down(*move_right(x, y))\n\ndef move_downleft(x, y):\n    return move_down(*move_left(x, y))\n\ndef manhattan_distance(start, end):\n    sx, sy = start\n    ex, ey = end\n    return abs(ex - sx) + abs(ey - sy)\n\ndef neigh(points, pos):\n    sum = 0\n    for move in diags:\n        v = move(*pos)\n        sum += points[v]\n    return sum\n\nmoves = [move_right, move_up, move_left, move_down]\ndiags = moves + [move_upright, move_upleft, move_downleft, move_downright]\n\n# main function\ndef main_solution(end):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    def get_pos2(end):\n        _moves = cycle(moves)\n        points = defaultdict(int)\n        n = 1\n        pos = 0, 0\n        m = 1  # number of times to keep going in that direction\n        points[pos] = n\n\n        while True:\n            for _ in range(2):\n                move = next(_moves)\n                for _ in range(m):\n                    if n >= end:\n                        return points, pos\n                    pos = move(*pos)\n                    n = neigh(points, pos)\n                    points[pos] = n\n            m += 1\n        return points, (0, 0)\n\n    points, final_pos = get_pos2(end)\n    distance = manhattan_distance((0, 0), final_pos)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"final_position\": final_pos, \"manhattan_distance\": distance}", "input_generator": "import random\n\ndef input_generator():\n    end = random.randint(1, 1000)\n    return {\"end\": end}", "io_pairs": [{"input": {"end": 344}, "output": {"final_position": [-2, -1], "manhattan_distance": 3}}, {"input": {"end": 439}, "output": {"final_position": [-1, -2], "manhattan_distance": 3}}, {"input": {"end": 401}, "output": {"final_position": [-1, -2], "manhattan_distance": 3}}, {"input": {"end": 351}, "output": {"final_position": [-2, -1], "manhattan_distance": 3}}, {"input": {"end": 800}, "output": {"final_position": [0, -2], "manhattan_distance": 2}}, {"input": {"end": 786}, "output": {"final_position": [0, -2], "manhattan_distance": 2}}, {"input": {"end": 773}, "output": {"final_position": [0, -2], "manhattan_distance": 2}}, {"input": {"end": 555}, "output": {"final_position": [-1, -2], "manhattan_distance": 3}}, {"input": {"end": 189}, "output": {"final_position": [-2, 1], "manhattan_distance": 3}}, {"input": {"end": 128}, "output": {"final_position": [0, 2], "manhattan_distance": 2}}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = e^{-x} \\cdot (x^4 - 10x^2) + 1 \\), which describes the behavior of a certain physical phenomenon, we need to determine the approximate root of this function using the Newton-Raphson method. What is the approximate root of the function after a specified number of iterations starting from a given initial guess?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_guess` (float): The initial guess for the root of the function.\n  `iterations` (int): The number of iterations to perform the Newton-Raphson method.\n\nOutput:\n  `return` (dict): A dictionary containing the key `root` with the value being the approximate root of the function as a float.", "reference_code": "# import necessary packages\nimport numpy as n\nimport sympy as s\n\n# main function\ndef main_solution(initial_guess, iterations):\n    # Define the symbolic variable and the function\n    x1 = s.Symbol('x1')\n    f = s.exp(-x1) * (x1**4 - 10 * x1**2) + 1\n    \n    # Convert the symbolic function and its derivative to numerical functions\n    f1 = s.lambdify(x1, f, 'numpy')\n    f2 = s.lambdify(x1, f.diff(x1), 'numpy')\n    \n    # Newton-Raphson method to find the root\n    p = initial_guess\n    for _ in range(iterations):\n        p = p - f1(p) / f2(p)\n    \n    # Return the approximate root\n    return {\"root\": float(p)}", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    initial_guess = random.uniform(-5.0, 5.0)\n    iterations = random.randint(5, 20)\n    return {\"initial_guess\": initial_guess, \"iterations\": iterations}", "io_pairs": [{"input": {"initial_guess": -3.5538240756578454, "iterations": 20}, "output": {"root": -3.1616075728927417}}, {"input": {"initial_guess": -0.44991664843180423, "iterations": 13}, "output": {"root": -0.27646067805858765}}, {"input": {"initial_guess": -4.068991637132662, "iterations": 15}, "output": {"root": -3.1616075728927417}}, {"input": {"initial_guess": 1.922314660811618, "iterations": 8}, "output": {"root": 2.810054644447182}}, {"input": {"initial_guess": 3.314818065386378, "iterations": 12}, "output": {"root": 2.810054644447182}}, {"input": {"initial_guess": -2.243010945283003, "iterations": 17}, "output": {"root": -0.27646067805858765}}, {"input": {"initial_guess": 0.9056700558071364, "iterations": 11}, "output": {"root": 0.38655191951925266}}, {"input": {"initial_guess": -4.777692421258539, "iterations": 11}, "output": {"root": -3.1616075728927417}}, {"input": {"initial_guess": -0.84877359236547, "iterations": 18}, "output": {"root": -0.27646067805858765}}, {"input": {"initial_guess": -1.920383343154508, "iterations": 15}, "output": {"root": -0.27646067805858765}}], "error_log": []}
{"context": "Given a mathematical function in terms of 'x', what is the integrated form of this function?\n\nThe input and output requirements are as follows:\n\nInput:\n  `function_expr` (str): A string representing a mathematical function in terms of 'x'. For example, \"x**2 + 3*x + 2\".\n\nOutput:\n  `return` (str): A string representing the integrated function in terms of 'x'. For example, \"x**3/3 + 3*x**2/2 + 2*x\".", "reference_code": "# import necessary packages\nfrom sympy import Symbol, integrate\nfrom sympy.parsing.sympy_parser import parse_expr\n\n# main function\ndef main_solution(function_expr):\n    # Convert the input string to a SymPy expression\n    x = Symbol('x')\n    F = parse_expr(function_expr, evaluate=False)\n    \n    # Integrate the function\n    G = integrate(F, x)\n    \n    # Return the integrated function as a string\n    return str(G)", "input_generator": "import random\nimport sympy\nfrom sympy.abc import x\n\ndef input_generator():\n    # Generate a random polynomial or trigonometric/exponential function\n    choices = ['polynomial', 'trig', 'exp']\n    choice = random.choice(choices)\n    \n    if choice == 'polynomial':\n        # Generate coefficients and exponents for a polynomial\n        degree = random.randint(1, 5)\n        terms = []\n        for _ in range(degree + 1):\n            coeff = random.randint(-10, 10)\n            if coeff == 0:\n                continue\n            terms.append(f\"{coeff}*x**{_}\")\n        if not terms:\n            terms.append(\"0\")\n        function_expr = \"+\".join(terms).replace(\"+-\", \"-\")\n    elif choice == 'trig':\n        # Generate a trigonometric function\n        trig_funcs = ['sin', 'cos', 'tan']\n        func = random.choice(trig_funcs)\n        coeff = random.randint(1, 5)\n        function_expr = f\"{func}({coeff}*x)\"\n    else:\n        # Generate an exponential function\n        coeff = random.randint(1, 5)\n        function_expr = f\"exp({coeff}*x)\"\n    \n    return {'function_expr': function_expr}", "io_pairs": [{"input": {"function_expr": "exp(5*x)"}, "output": "exp(5*x)/5"}, {"input": {"function_expr": "exp(3*x)"}, "output": "exp(3*x)/3"}, {"input": {"function_expr": "cos(5*x)"}, "output": "sin(5*x)/5"}, {"input": {"function_expr": "tan(1*x)"}, "output": "-log(cos(x))"}, {"input": {"function_expr": "sin(3*x)"}, "output": "-cos(3*x)/3"}, {"input": {"function_expr": "cos(4*x)"}, "output": "sin(4*x)/4"}, {"input": {"function_expr": "tan(3*x)"}, "output": "-log(cos(3*x))/3"}, {"input": {"function_expr": "exp(4*x)"}, "output": "exp(4*x)/4"}, {"input": {"function_expr": "3*x**0-10*x**1-7*x**2"}, "output": "-7*x**3/3 - 5*x**2 + 3*x"}, {"input": {"function_expr": "1*x**0+1*x**1-6*x**2+4*x**3+10*x**4+8*x**5"}, "output": "4*x**6/3 + 2*x**5 + x**4 - 2*x**3 + x**2/2 + x"}], "error_log": []}
{"context": "Given a set of x-values and a degree of a polynomial, what are the coefficients of the polynomial that best fits the function \\( \\cos(x) \\) over these x-values?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x_values` (list of floats): A list of x-values over which the function will be evaluated.\n  `degree` (int): The degree of the polynomial to fit.\n\nOutput:\n  `return` (list of floats): A list of polynomial coefficients in descending order of power.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(x_values, degree):\n    # Convert input to numpy arrays\n    x = np.array(x_values)\n    g = degree\n    \n    # Define the function to fit\n    f = lambda x : np.cos(x)\n    y = f(x)\n    \n    # Construct the Vandermonde matrix\n    n = len(x)\n    A = np.ones((n, g + 1))\n    for j in range(1, g + 1):\n        A[:, j] = A[:, j - 1] * x\n    \n    # Solve the linear system to find the polynomial coefficients\n    M = np.dot(A.T, A)\n    b = np.dot(A.T, y)\n    a = np.linalg.solve(M, b)\n    a = a[::-1]\n    \n    # Return the polynomial coefficients\n    return a.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random number of x_values between 5 and 20\n    n = random.randint(5, 20)\n    # Generate x_values as random floats between -5 and 5\n    x_values = [random.uniform(-5, 5) for _ in range(n)]\n    # Generate a random degree between 2 and 5\n    degree = random.randint(2, 5)\n    return {'x_values': x_values, 'degree': degree}", "io_pairs": [{"input": {"x_values": [-2.976781085524779, -4.553725004913169, 1.746952095496555, -0.3369519742391338, -2.712201376617643, -2.52965773662389, -1.317379197273726, 1.0031469330415108, -4.63150755633817, 3.5180674763745454, 0.5740037319789373, -2.8587893685847887], "degree": 4}, "output": [0.01578727935930494, 0.0074754713725883465, -0.357185267800592, -0.04753400309407709, 0.9005330731078546]}, {"input": {"x_values": [3.1172476864190273, -4.606242743577579, -4.806117400688118, 0.8948269250319534, -4.9724646083831825, -0.08122777996902197, -2.476745274041614, -0.3103963292649512, 3.083764882156583, 2.745628404711711, 2.1533186268679803, 4.274345493561743, -4.096114528337965, 2.391302797019833, 1.504937531134125, 0.7581847166024227, -1.1478092256849717, -3.7453942304450702], "degree": 3}, "output": [-0.006535347305945421, -0.057338558296670394, -0.022892331606052432, 0.26546850205779]}, {"input": {"x_values": [2.3598521531730254, -1.0911122734611887, -1.5867367631687976, 1.404345081993604, -1.3667322214146105, -4.201526597459521, -4.115277524300847, 1.65015997979922, -3.7059763951824443, -3.2453169910433246, -4.470756392792131], "degree": 3}, "output": [-0.053259982884626224, -0.2460010877504573, 0.19889050608833025, 0.6869509993167835]}, {"input": {"x_values": [1.2680543346375739, 1.439487881228228, -3.190916051881474, -2.2357823445383374, 2.8115348455354088, -0.13843011580418896, -1.2306396830901898], "degree": 4}, "output": [0.02592209846862577, 0.0034300716421831927, -0.4516586012338355, -0.016923309442452406, 0.9744711722133371]}, {"input": {"x_values": [-1.322440926105041, -4.876274495403152, -1.2586603134085896, -2.8340874422088813, -0.5509236368781405, 1.0494422380864084], "degree": 2}, "output": [0.04088878336737168, 0.31278636750959793, 0.446959152105416]}, {"input": {"x_values": [2.2308091666172922, 4.30310627147022, 0.49174853085959747, 4.7925891488889345, 3.407493597627088, -4.608013671271834, -2.3344223481150914, 3.9002781439508407, -1.740608203516234, 3.035115851018542], "degree": 5}, "output": [-0.002106494478526353, 0.01643224618404899, 0.053716434037051446, -0.399514205401386, -0.19264250245859096, 0.9670431920846125]}, {"input": {"x_values": [-0.4931492995657303, -4.487102410091452, 2.1721150576006467, 4.476886496303873, 1.8195211782788405, 4.378307980273128, -1.7692024604950554, -2.9121557990892057, 1.461059933605596, -0.475501794559535, -3.1010926218974797, -0.5314602425746129, -2.8585750877648985], "degree": 2}, "output": [-0.04553252953013665, 0.060805845019640765, 0.20719655801772865]}, {"input": {"x_values": [4.778892232729429, -3.985222255931232, 1.9992070650746419, -3.4224024395346397, 3.5535450334084917, 3.8472365250293556, 2.3738505114506223, 0.8027971476860154, -4.123522922324648, -1.697080906113626, -1.8423728736828338, -2.018483484334493], "degree": 3}, "output": [0.008184168545644388, -0.029148465267350657, -0.09040240188195536, -0.16634602339169655]}, {"input": {"x_values": [2.760570921295182, -0.8390736342639116, -0.6266548983562199, 0.8873309005005297, -2.3645853428599475, 3.343049336735282, 3.630471199867726, 4.414911801695423, -4.969853706644791, -1.2047341893229992, 1.1993458849755712, 2.1503704907756642, -1.2675831266475077], "degree": 2}, "output": [-0.03258436947629084, -0.12396607291912436, 0.2264261467841329]}, {"input": {"x_values": [2.7347279959421487, -1.2044102986444294, -2.8715994873574466, -2.245128938802412, -3.9195612839596263], "degree": 2}, "output": [-0.07914433544668657, -0.07092676477749098, -0.08376442438029832]}], "error_log": []}
{"context": "Given a dataset represented by a matrix `xTr` where each column is an input vector, and a corresponding label vector `yTr`, what is the total loss and gradient obtained when applying a logistic regression model with a given weight vector `w`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `xTr` (list of lists of floats): A dxn matrix where each column is an input vector.\n  `yTr` (list of floats): A 1xn matrix where each entry is a label.\n  `w` (list of floats): A weight vector.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `loss` (float): The total loss obtained with the weight vector `w` on `xTr` and `yTr`.\n    - `gradient` (list of floats): The gradient at the weight vector `w`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(xTr, yTr, w):\n    # Convert JSON serializable inputs to numpy arrays\n    xTr = np.array(xTr)\n    yTr = np.array(yTr)\n    w = np.array(w)\n    \n    # Calculate the logistic loss and gradient\n    multiplier = yTr * np.dot(w.transpose(), xTr)\n    loss = np.sum(np.log(1 + np.exp(-multiplier)))\n    gradient = np.sum(-xTr * yTr / (1 + np.exp(multiplier)), axis=1).reshape(w.shape[0], 1)\n    \n    # Convert outputs to JSON serializable format\n    loss = float(loss)\n    gradient = gradient.tolist()\n    \n    return {\"loss\": loss, \"gradient\": gradient}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly determine the number of features and samples\n    n_features = random.randint(2, 10)\n    n_samples = random.randint(5, 20)\n    \n    # Generate random training data\n    xTr = np.random.rand(n_features, n_samples).tolist()\n    yTr = np.random.choice([-1, 1], size=n_samples).tolist()\n    w = np.random.rand(n_features, 1).tolist()\n    \n    return {\"xTr\": xTr, \"yTr\": yTr, \"w\": w}", "io_pairs": [], "error_log": []}
{"context": "Given a scenario where items need to be distributed into bins or categories, and a parameter `p` that affects the distribution, what is the total number of ways to distribute `n` items into `k` bins, considering the constraints imposed by `p`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of items to be distributed.\n  `k` (int): The number of bins or categories.\n  `p` (int): A parameter that affects the distribution calculation.\n\nOutput:\n  `return` (int): The result of the distribution calculation, which is the sum of the results of the `fun` function for each `i` from 1 to `n`.", "reference_code": "# import necessary packages\nfrom math import factorial\n\n# all class and function definitions in the code file, if any\ndef binomial(n, k):\n    return factorial(n) / factorial(k) / factorial(n - k)\n\ndef multinomial(l):\n    \"\"\"\n    Calculate multinomial coefficient using list of xi\n    \"\"\"\n    r = factorial(sum(l))\n    for v in l:\n        r /= factorial(v)\n    return r\n\ndef fun(n, k, p):\n    if n < p:\n        return binomial(n + k - 1, n)\n    lim = (n // p) * p\n    res = 0\n    for d in range(lim, n + 1):\n        t = n - d + 1\n        if t > k:\n            continue\n        v = binomial(k, k - t) * factorial(t)\n        res += v\n    return res\n\n# main function\ndef main_solution(n, k, p):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    res = 1\n    for i in range(1, n + 1):\n        v = fun(i, k, p)\n        res += v\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return res", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 20)\n    k = random.randint(1, 20)\n    p = random.randint(1, 10)\n    return {'n': n, 'k': k, 'p': p}", "io_pairs": [{"input": {"n": 9, "k": 1, "p": 9}, "output": 10.0}, {"input": {"n": 12, "k": 4, "p": 8}, "output": 518.0}, {"input": {"n": 20, "k": 2, "p": 10}, "output": 95.0}, {"input": {"n": 4, "k": 16, "p": 4}, "output": 985.0}, {"input": {"n": 5, "k": 2, "p": 2}, "output": 15.0}, {"input": {"n": 3, "k": 16, "p": 8}, "output": 969.0}, {"input": {"n": 5, "k": 15, "p": 2}, "output": 496.0}, {"input": {"n": 14, "k": 19, "p": 6}, "output": 22678971.0}, {"input": {"n": 16, "k": 4, "p": 3}, "output": 275.0}, {"input": {"n": 20, "k": 9, "p": 5}, "output": 69763.0}], "error_log": []}
{"context": "Given a set of data points with x-coordinates and their corresponding function values, how can we estimate the function value at a specific x-coordinate using Lagrange interpolation? Specifically, what is the interpolated value at `input_x` for the given data points `x` and `fx`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (list of floats): List of x-coordinates for the interpolation points.\n  `fx` (list of floats): List of corresponding function values at the x-coordinates.\n  `input_x` (float or string): The x-coordinate at which the interpolated value is to be calculated. If provided as a string, it should be convertible to a float.\n\nOutput:\n  `return` (float): The interpolated value at the given `input_x`, rounded to 4 decimal places.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef lagrange(x, fx, input_x):\n    lagrange_sum = 0\n    for i in range(len(x)):\n        li = 1\n        for j in range(len(x)):\n            if j != i:\n                li *= ((input_x - x[j]) / (x[i] - x[j]))\n        li *= fx[i]\n        lagrange_sum += li\n    return lagrange_sum\n\n# main function\ndef main_solution(x, fx, input_x):\n    # Convert input_x to float if it's a string representation of a number\n    if isinstance(input_x, str):\n        input_x = float(input_x)\n    \n    # Calculate the Lagrange interpolation result\n    result = lagrange(x, fx, input_x)\n    \n    # Convert the result to a JSON serializable format\n    result_serializable = round(result, 4)  # Round to 4 decimal places for readability\n    \n    return result_serializable", "input_generator": "import random\nimport json\n\ndef input_generator():\n    # Generate a random number of points (between 3 and 10)\n    n = random.randint(3, 10)\n    \n    # Generate random x values, ensuring they are unique\n    x = sorted(random.sample(range(-100, 101), n))\n    \n    # Generate corresponding fx values\n    fx = [round(random.uniform(-100.0, 100.0), 4) for _ in range(n)]\n    \n    # Generate a random input_x within the range of x values or slightly outside\n    min_x = min(x)\n    max_x = max(x)\n    input_x = random.uniform(min_x - 10.0, max_x + 10.0)\n    \n    # Occasionally make input_x a string representation\n    if random.random() < 0.3:\n        input_x = str(round(input_x, 4))\n    \n    return {\n        'x': x,\n        'fx': fx,\n        'input_x': input_x\n    }", "io_pairs": [{"input": {"x": [-57, 16, 35, 96], "fx": [44.2329, 80.9683, -67.4597, 82.1122], "input_x": 85.40536831466588}, "output": -65.3574}, {"input": {"x": [-83, 38, 91], "fx": [-68.2591, 72.6175, 50.9601], "input_x": 66.31086143242143}, "output": 67.3673}, {"input": {"x": [-97, -90, 8, 82, 94], "fx": [-11.6495, -14.9547, -8.1795, -2.5193, -95.4492], "input_x": 67.7285895775617}, "output": 54.2166}, {"input": {"x": [-26, -4, 9, 99], "fx": [-44.973, -19.3381, 19.7102, -21.1108], "input_x": 2.945847362049996}, "output": 0.1547}, {"input": {"x": [-55, -28, 31, 99], "fx": [-19.0439, -73.798, 25.3009, -1.7046], "input_x": "19.2931"}, "output": -2.3487}, {"input": {"x": [-63, -1, 1, 35, 62, 77], "fx": [6.9529, -14.0939, 0.4595, 3.9558, -89.9829, -42.5225], "input_x": 18.89539457200334}, "output": 52.5886}, {"input": {"x": [-87, -35, -4, 47, 53, 90], "fx": [51.4049, 6.3541, -12.1383, 74.9985, -90.1499, -98.1356], "input_x": -52.45233133654588}, "output": 488.8989}, {"input": {"x": [-95, -81, -66, 21, 95], "fx": [-16.2038, -45.1782, -55.3905, -38.9004, -69.3322], "input_x": -37.96505130413574}, "output": -45.8034}, {"input": {"x": [-79, 6, 31], "fx": [-36.0327, -77.6974, -94.9302], "input_x": -53.35831792464377}, "output": -45.8461}, {"input": {"x": [-95, -83, -75, -62, -38, 60], "fx": [16.801, 40.802, 81.743, 15.6756, -93.9499, -93.8673], "input_x": "-56.1498"}, "output": -55.2944}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = x^3 - 2x - 5 \\), what is the approximate root of this function between two randomly chosen starting points `x0` and `x1`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x0` (float): The first starting point for the intersection calculation.\n  `x1` (float): The second starting point for the intersection calculation.\n\nOutput:\n  `return` (float): The approximate root of the function \\( f(x) = x^3 - 2x - 5 \\) found between `x0` and `x1`, rounded to 5 decimal places.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef intersection(function, x0, x1):\n    x_n = x0\n    x_n1 = x1\n    while True:\n        x_n2 = x_n1 - (function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n)))\n        if abs(x_n2 - x_n1) < 0.00001:\n            return x_n2\n        x_n = x_n1\n        x_n1 = x_n2\n\ndef f(x):\n    return math.pow(x, 3) - 2 * x - 5\n\n# main function\ndef main_solution(x0, x1):\n    # Convert JSON serializable inputs to the required format\n    x0 = float(x0)\n    x1 = float(x1)\n    \n    # Find the intersection point\n    result = intersection(f, x0, x1)\n    \n    # Convert the result to a JSON serializable output\n    return round(result, 5)", "input_generator": "import random\n\ndef input_generator():\n    x0 = random.uniform(-10.0, 10.0)\n    x1 = random.uniform(-10.0, 10.0)\n    while abs(x0 - x1) < 0.1:  # Ensure x0 and x1 are not too close\n        x1 = random.uniform(-10.0, 10.0)\n    return {'x0': x0, 'x1': x1}", "io_pairs": [{"input": {"x0": -1.5882858203536188, "x1": -8.326523187131134}, "output": 2.09455}, {"input": {"x0": -7.6553596896145155, "x1": 2.5476361067089677}, "output": 2.09455}, {"input": {"x0": -0.9234873724323407, "x1": 5.854188771999993}, "output": 2.09455}, {"input": {"x0": -4.726023612297925, "x1": -3.7587947051795485}, "output": 2.09455}, {"input": {"x0": 2.3981161191565707, "x1": -8.984926948164704}, "output": 2.09455}, {"input": {"x0": 9.426189871154588, "x1": -2.3996729476172067}, "output": 2.09455}, {"input": {"x0": -6.374068180228676, "x1": -4.425144582557968}, "output": 2.09455}, {"input": {"x0": 1.3767252982950353, "x1": -3.754212526287038}, "output": 2.09455}, {"input": {"x0": -5.784901759167691, "x1": 1.5118201467133936}, "output": 2.09455}, {"input": {"x0": -6.4149711102308205, "x1": 5.62491023686589}, "output": 2.09455}], "error_log": []}
{"context": "A horizontal spring with a given spring constant is attached to a frictionless surface. A block of a certain mass is attached to the end of the spring, and the spring is oscillating with a specific maximum amplitude. At a particular time, what is the displacement of the spring?\n\nThe input and output requirements are as follows:\n\nInput:\n  `mass` (float): The mass of the object attached to the spring in kilograms.\n  `spring_constant` (float): The spring constant of the spring in Newtons per meter (N/m).\n  `amplitude` (float): The maximum amplitude of the spring's oscillation in meters.\n  `time` (float): The time at which the displacement is to be calculated in seconds.\n\nOutput:\n  `return` (float): The displacement of the spring at the specified time in meters.", "reference_code": "# import necessary packages\nimport math\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef time_period(mass, k):\n    return 2 * math.pi * np.sqrt(mass / k)\n\ndef object_displacement(A, freq, time):\n    return A * np.cos(2 * math.pi * freq * time)\n\ndef inv_freq_time(x):\n    if x != 0:\n        return 1 / x\n    else:\n        return -1\n\n# main function\ndef main_solution(mass, spring_constant, amplitude, time):\n    # Calculate the time period of the spring\n    period = time_period(mass, spring_constant)\n    \n    # Calculate the frequency of the spring\n    frequency = inv_freq_time(period)\n    \n    # Calculate the displacement of the spring at the given time\n    displacement = object_displacement(amplitude, frequency, time)\n    \n    # Return the displacement as the final output\n    return displacement", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    mass = random.uniform(0.1, 10.0)  # Reasonable mass range in kg\n    spring_constant = random.uniform(1.0, 100.0)  # Reasonable spring constant in N/m\n    amplitude = random.uniform(0.01, 1.0)  # Reasonable amplitude in meters\n    time = random.uniform(0.0, 10.0)  # Reasonable time in seconds\n    return {\n        'mass': mass,\n        'spring_constant': spring_constant,\n        'amplitude': amplitude,\n        'time': time\n    }", "io_pairs": [{"input": {"mass": 4.466777293402353, "spring_constant": 33.29991362004588, "amplitude": 0.907778116933081, "time": 1.3745215265868582}, "output": -0.7433377012811528}, {"input": {"mass": 1.9736293598079264, "spring_constant": 42.18777984155891, "amplitude": 0.20498886040038486, "time": 0.8773417516084359}, "output": -0.12504892851869048}, {"input": {"mass": 8.593223183657658, "spring_constant": 19.731016990323663, "amplitude": 0.2883880489236981, "time": 7.683233983422464}, "output": 0.1737879879602971}, {"input": {"mass": 9.33721251137502, "spring_constant": 74.95594885321813, "amplitude": 0.3447833411407843, "time": 0.11958869892570112}, "output": 0.32518016558289575}, {"input": {"mass": 7.405778979065348, "spring_constant": 63.940279266261086, "amplitude": 0.20905212604412982, "time": 6.367526281691358}, "output": 0.20701825208845592}, {"input": {"mass": 3.3352467412256845, "spring_constant": 87.12196600351837, "amplitude": 0.2858592585114651, "time": 6.984795082015097}, "output": -0.11904259219910718}, {"input": {"mass": 6.098506222888455, "spring_constant": 7.439605938581124, "amplitude": 0.316336537789208, "time": 0.10157945297103121}, "output": 0.314347688114105}, {"input": {"mass": 4.916049787056416, "spring_constant": 85.76819899284202, "amplitude": 0.39986987896862464, "time": 3.5338236993812924}, "output": -0.23340886274086922}, {"input": {"mass": 1.7745797735737732, "spring_constant": 71.50068076559263, "amplitude": 0.11003094091324182, "time": 8.151752484015836}, "output": 0.01016116433445265}, {"input": {"mass": 7.911912048854581, "spring_constant": 6.524912694858913, "amplitude": 0.22720240432829095, "time": 6.965172290960257}, "output": 0.22700131293608516}], "error_log": []}
{"context": "In a simplified version of Yahtzee, you are given a hand of dice and need to decide which dice to hold to maximize your expected score. Given a hand of dice and the number of sides on each die, what is the optimal strategy to hold the dice that will yield the highest expected score when the remaining dice are rolled?\n\nThe input and output requirements are as follows:\n\nInput:\n  `hand` (list of integers): A list of integers representing the dice in the hand. Each integer should be between 1 and `num_die_sides`.\n  `num_die_sides` (integer): An integer representing the number of sides on each die. This should be a positive integer.\n\nOutput:\n  `return` (dictionary): A dictionary with the following keys:\n    - `expected_score` (float): The expected score when holding the optimal dice.\n    - `dice_to_hold` (list of integers): A list of integers representing the dice to hold to maximize the expected score.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef gen_all_sequences(outcomes, length):\n    \"\"\"\n    Iterative function that enumerates the set of all sequences of\n    outcomes of given length.\n    \"\"\"\n    answer_set = set([()])\n    for dummy_idx in range(length):\n        temp_set = set()\n        for partial_sequence in answer_set:\n            for item in outcomes:\n                new_sequence = list(partial_sequence)\n                new_sequence.append(item)\n                temp_set.add(tuple(new_sequence))\n        answer_set = temp_set\n    return answer_set\n\ndef score(hand):\n    \"\"\"\n    Compute the maximal score for a Yahtzee hand according to the\n    upper section of the Yahtzee score card.\n\n    hand: full yahtzee hand\n\n    Returns an integer score \n    \"\"\"\n    max_score = 0\n    for ele in hand:\n        if hand.count(ele) * ele > max_score:\n            max_score = hand.count(ele) * ele\n    return max_score\n\ndef expected_value(held_dice, num_die_sides, num_free_dice):\n    \"\"\"\n    Compute the expected value based on held_dice given that there\n    are num_free_dice to be rolled, each with num_die_sides.\n\n    held_dice: dice that you will hold\n    num_die_sides: number of sides on each die\n    num_free_dice: number of dice to be rolled\n\n    Returns a floating point expected value\n    \"\"\"\n    rolling_possible = gen_all_sequences(range(1, num_die_sides + 1), num_free_dice)\n    total_value = 0.0\n    for ele in rolling_possible:\n        temp = list(held_dice)\n        temp.extend(ele)\n        total_value += score(temp)\n    \n    expect = total_value / len(rolling_possible)\n    return expect\n\ndef gen_all_holds(hand):\n    \"\"\"\n    Generate all possible choices of dice from hand to hold.\n\n    hand: full yahtzee hand\n\n    Returns a set of tuples, where each tuple is dice to hold\n    \"\"\"\n    possible_hold = set([()])\n    for num in range(1, len(hand) + 1):\n        update_set = gen_all_sequences(hand, num)\n        for ele in update_set:\n            temp = list(ele)\n            for each in ele:\n                if temp.count(each) > hand.count(each):\n                    temp = []  \n            temp.sort()        \n            possible_hold.add(tuple(temp))    \n                \n    return possible_hold\n\ndef strategy(hand, num_die_sides):\n    \"\"\"\n    Compute the hold that maximizes the expected value when the\n    discarded dice are rolled.\n\n    hand: full yahtzee hand\n    num_die_sides: number of sides on each die\n\n    Returns a tuple where the first element is the expected score and\n    the second element is a tuple of the dice to hold\n    \"\"\"\n    expect_value = 0 \n    dice_hold = ()\n    for ele in gen_all_holds(hand):\n        temp = expected_value(ele, num_die_sides, len(hand) - len(ele))\n        if temp > expect_value:\n            expect_value = temp\n            dice_hold = ele\n    return expect_value, dice_hold\n\n# main function\ndef main_solution(hand, num_die_sides):\n    \"\"\"\n    Compute the best strategy for a given Yahtzee hand and the number of sides on each die.\n\n    hand: list of integers representing the dice in the hand\n    num_die_sides: integer representing the number of sides on each die\n\n    Returns a dictionary with keys 'expected_score' and 'dice_to_hold'\n    \"\"\"\n    expected_score, dice_to_hold = strategy(hand, num_die_sides)\n    return {\n        'expected_score': expected_score,\n        'dice_to_hold': list(dice_to_hold)\n    }", "input_generator": "import random\n\ndef input_generator():\n    num_die_sides = random.randint(4, 10)  # Reasonable number of sides for a die\n    num_dice = random.randint(1, 5)        # Typical Yahtzee hand size is 5, but can vary\n    hand = [random.randint(1, num_die_sides) for _ in range(num_dice)]\n    return {\n        'hand': hand,\n        'num_die_sides': num_die_sides\n    }", "io_pairs": [{"input": {"hand": [8, 7, 3], "num_die_sides": 9}, "output": {"expected_score": 10.222222222222221, "dice_to_hold": [8]}}, {"input": {"hand": [4, 5, 4, 4], "num_die_sides": 5}, "output": {"expected_score": 12.8, "dice_to_hold": [4, 4, 4]}}, {"input": {"hand": [4], "num_die_sides": 4}, "output": {"expected_score": 4.0, "dice_to_hold": [4]}}, {"input": {"hand": [1, 2], "num_die_sides": 4}, "output": {"expected_score": 3.75, "dice_to_hold": []}}, {"input": {"hand": [3, 3, 1, 5], "num_die_sides": 6}, "output": {"expected_score": 8.449074074074074, "dice_to_hold": [5]}}, {"input": {"hand": [5, 3], "num_die_sides": 9}, "output": {"expected_score": 7.037037037037037, "dice_to_hold": []}}, {"input": {"hand": [3, 6], "num_die_sides": 8}, "output": {"expected_score": 7.125, "dice_to_hold": [6]}}, {"input": {"hand": [5], "num_die_sides": 9}, "output": {"expected_score": 5.0, "dice_to_hold": []}}, {"input": {"hand": [4, 5, 7, 3], "num_die_sides": 10}, "output": {"expected_score": 11.139, "dice_to_hold": [7]}}, {"input": {"hand": [7, 8, 9, 6], "num_die_sides": 10}, "output": {"expected_score": 12.6, "dice_to_hold": [9]}}], "error_log": []}
{"context": "Given a list of words, find the largest square number that can be formed by any pair of anagram words from the list. An anagram pair is defined as two words that can be rearranged to form each other, and each word in the pair must map to a unique square number when each letter is replaced by a digit. What is the largest square number that can be formed in this manner?\n\nThe input and output requirements are as follows:\n\nInput:\n  `words` (list of strings): A list of words from which to find anagram pairs that can be mapped to square numbers. Each word is a string of letters.\n\nOutput:\n  `return` (int): The largest square number formed by any member of an anagram word pair. If no such pair is found, the function returns 0.", "reference_code": "# import necessary packages\nimport math\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef length(number):\n    return int(math.log10(number)) + 1\n\ndef getsquares(digits):\n    squares = []\n    for i in range(int((10**(digits-1))**0.5), int((10**digits)**0.5)):\n        number = i**2\n        if length(number) == digits:\n            squares.append(number)\n    squares.reverse()\n    return squares\n\ndef testmatch(match1, match2, squares):\n    for square in squares:\n        firstsquare = square\n        charmap = [None] * 10\n        mapped = True\n        matched = False\n        for i in range(len(match1) - 1, -1, -1):\n            char = match1[i]\n            index = square % 10\n            square //= 10\n            if charmap[index] is None:\n                charmap[index] = char\n            else: \n                mapped = False\n                break\n        if mapped: \n            secondsquare = 0\n            for l in match2:\n                secondsquare *= 10\n                secondsquare += charmap.index(l)\n            \n            if secondsquare in squares: \n                return firstsquare, secondsquare\n    return None\n\n# main function\ndef main_solution(words):\n    # Convert the input list of words into a list of sorted words\n    sortwords = [''.join(sorted(word)) for word in words]\n    \n    # Find all anagram pairs\n    matchwords = []\n    for i in range(len(sortwords)):\n        word = sortwords[i]\n        if sortwords.count(word) > 1:\n            match = []\n            for j, k in enumerate(sortwords):\n                if k == word:\n                    match.append(words[j])\n            if match not in matchwords: \n                matchwords.append(match)\n    \n    # Find the largest square number formed by any member of such a pair\n    max_square = 0\n    for match in matchwords:\n        match1, match2 = match[0], match[1]\n        digits = len(match1)\n        squares = getsquares(digits)\n        matchtest = testmatch(match1, match2, squares)\n        if matchtest:\n            max_square = max(max_square, matchtest[0], matchtest[1])\n    \n    return max_square", "input_generator": "import random\nimport math\nfrom itertools import permutations\n\ndef input_generator():\n    # List of possible words that can form anagrams\n    word_pool = [\n        ['listen', 'silent', 'enlist', 'tinsel'],\n        ['triangle', 'integral', 'relating'],\n        ['evil', 'vile', 'live', 'veil'],\n        ['state', 'taste', 'teats'],\n        ['dear', 'dare', 'read'],\n        ['earth', 'heart', 'hater'],\n        ['race', 'care', 'acre'],\n        ['part', 'trap', 'prat'],\n        ['post', 'stop', 'pots', 'tops'],\n        ['angel', 'angle', 'glean']\n    ]\n    \n    # Randomly select a group of anagrams\n    selected_group = random.choice(word_pool)\n    \n    # Randomly decide how many words to pick (at least 2)\n    num_words = random.randint(2, len(selected_group))\n    words = random.sample(selected_group, num_words)\n    \n    return {'words': words}", "io_pairs": [{"input": {"words": ["heart", "hater", "earth"]}, "output": 0}, {"input": {"words": ["vile", "veil"]}, "output": 1936}, {"input": {"words": ["veil", "evil", "live"]}, "output": 9216}, {"input": {"words": ["glean", "angle"]}, "output": 38416}, {"input": {"words": ["hater", "earth", "heart"]}, "output": 0}, {"input": {"words": ["integral", "triangle"]}, "output": 0}, {"input": {"words": ["veil", "live"]}, "output": 9604}, {"input": {"words": ["vile", "live", "evil"]}, "output": 9216}, {"input": {"words": ["integral", "relating"]}, "output": 0}, {"input": {"words": ["care", "race", "acre"]}, "output": 9216}], "error_log": []}
{"context": "Given a set of points in a 2D plane, each with a specific mass, what are the coordinates of the center of mass, the total mass, and the moment of inertia of the body formed by these points?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (list of floats): List of x-coordinates of the center of mass for each point.\n  `y` (list of floats): List of y-coordinates of the center of mass for each point.\n  `m` (list of floats): List of masses corresponding to each point.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `cmx` (float): The x-coordinate of the center of mass.\n    - `cmy` (float): The y-coordinate of the center of mass.\n    - `mass` (float): The total mass of the body.\n    - `moment` (float): The moment of inertia of the body.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\nclass BodyT:\n    def __init__(self, x, y, m):\n        if len(x) != len(y) or len(x) != len(m) or len(y) != len(m):\n            raise ValueError(\"lengths not equal\")\n        for i in m:\n            if i <= 0:\n                raise ValueError(\"not all masses are more than 0\")\n        self.__cmx = cmm(x, m)\n        self.__cmy = cmm(y, m)\n        self.__m = summ(m)\n        self.__moment = mmomm(x, y, m) - summ(m) * (cmm(x, m)**2 + cmm(y, m)**2)\n\n    def cm_x(self):\n        return self.__cmx\n\n    def cm_y(self):\n        return self.__cmy\n\n    def mass(self):\n        return self.__m\n\n    def m_inert(self):\n        return self.__moment\n\ndef summ(m):\n    summation = 0\n    for i in m:\n        summation += i\n    return summation\n\ndef cmm(z, m):\n    total = 0\n    for i in range(len(m)):\n        total += z[i] * m[i]\n    return total / summ(m)\n\ndef mmomm(x, y, m):\n    mom = 0\n    for i in range(len(m)):\n        mom += m[i] * ((x[i]**2) + (y[i]**2))\n    return mom\n\n# main function\ndef main_solution(x, y, m):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    body = BodyT(x, y, m)\n    cmx = body.cm_x()\n    cmy = body.cm_y()\n    mass = body.mass()\n    moment = body.m_inert()\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"cmx\": cmx, \"cmy\": cmy, \"mass\": mass, \"moment\": moment}", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Random number of bodies between 1 and 10\n    x = [round(random.uniform(-10.0, 10.0), 2) for _ in range(n)]\n    y = [round(random.uniform(-10.0, 10.0), 2) for _ in range(n)]\n    m = [round(random.uniform(0.1, 10.0), 2) for _ in range(n)]\n    return {\"x\": x, \"y\": y, \"m\": m}", "io_pairs": [{"input": {"x": [-5.85, 5.65, -9.04, -8.34], "y": [8.85, 7.47, 8.47, 6.19], "m": [7.12, 8.26, 2.6, 7.93]}, "output": {"cmx": -3.2660439984561944, "cmy": 7.557811655731378, "mass": 25.91, "moment": 1023.9650744307219}}, {"input": {"x": [-7.19, 4.68], "y": [4.93, 3.39], "m": [2.68, 5.05]}, "output": {"cmx": 0.5646571798188869, "cmy": 3.9239197930142296, "mass": 7.73, "moment": 250.84034657179825}}, {"input": {"x": [-0.66], "y": [-8.95], "m": [9.28]}, "output": {"cmx": -0.66, "cmy": -8.95, "mass": 9.28, "moment": 0.0}}, {"input": {"x": [-8.8, -9.88, 1.61, -7.35], "y": [-4.35, 5.07, -6.95, 4.55], "m": [9.64, 9.08, 0.58, 3.63]}, "output": {"cmx": -8.734805931094638, "cmy": 0.7233798517226345, "mass": 22.929999999999996, "moment": 587.9591694478852}}, {"input": {"x": [2.66, 5.11], "y": [8.15, -3.18], "m": [9.81, 5.01]}, "output": {"cmx": 3.4882388663967614, "cmy": 4.319817813765183, "mass": 14.82, "moment": 445.6207155425099}}, {"input": {"x": [-6.04, -1.17, 4.5, -8.97], "y": [9.65, 2.0, 0.15, 0.62], "m": [6.79, 6.83, 0.46, 7.57]}, "output": {"cmx": -5.304184757505773, "cmy": 3.8774087759815234, "mass": 21.650000000000002, "moment": 603.4038884933028}}, {"input": {"x": [-1.49], "y": [5.66], "m": [7.35]}, "output": {"cmx": -1.49, "cmy": 5.66, "mass": 7.35, "moment": 0.0}}, {"input": {"x": [-1.54, 5.92], "y": [-9.03, 9.98], "m": [0.52, 5.64]}, "output": {"cmx": 5.2902597402597396, "cmy": 8.37525974025974, "mass": 6.16, "moment": 198.55041716883136}}, {"input": {"x": [-2.16, 0.29, -5.89], "y": [9.88, 0.86, -5.84], "m": [8.05, 7.83, 0.84]}, "output": {"cmx": -1.200053827751196, "cmy": 4.866160287081341, "mass": 16.720000000000002, "moment": 467.5931724419856}}, {"input": {"x": [5.82, 0.37], "y": [-6.5, -5.75], "m": [9.2, 4.58]}, "output": {"cmx": 4.008606676342525, "cmy": -6.250725689404934, "mass": 13.78, "moment": 92.54325399129175}}], "error_log": []}
{"context": "Given a number, we are interested in finding out how many circular prime numbers exist below that number. A circular prime number is a prime number that remains prime under cyclic permutations of its digits. For example, 197 is a circular prime because 197, 971, and 719 are all prime numbers. How many circular prime numbers are there below a given number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `limit` (int): An integer representing the upper limit below which to find circular prime numbers.\n\nOutput:\n  `return` (int): An integer representing the count of circular prime numbers below the given limit.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef check_prime(number):\n    for i in range(2, number // 2 + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef rotations(num):\n    l = [num]\n    no_of_digits = len(str(num))\n    powTen = 10 ** (no_of_digits - 1)\n\n    for i in range(no_of_digits - 1):\n        first_digit = num // powTen\n        left = (num * 10 + first_digit - (first_digit * powTen * 10))\n        l.append(left)\n        num = left\n\n    return l\n\n# main function\ndef main_solution(limit):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    res = []\n    for i in range(2, limit):\n        if check_prime(i):\n            l = [x for x in rotations(i) if not check_prime(x)]\n            if len(l) == 0:\n                res.append(i)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return len(res)", "input_generator": "import random\n\ndef input_generator():\n    limit_options = [10, 20, 50, 100, 200, 500, 1000]\n    limit = random.choice(limit_options)\n    return {'limit': limit}", "io_pairs": [{"input": {"limit": 20}, "output": 7}, {"input": {"limit": 100}, "output": 13}, {"input": {"limit": 1000}, "output": 25}, {"input": {"limit": 50}, "output": 9}, {"input": {"limit": 200}, "output": 17}, {"input": {"limit": 500}, "output": 20}, {"input": {"limit": 10}, "output": 4}], "error_log": []}
{"context": "Given a board game where players take turns placing their pieces on a grid, determine if the second player has won the game after a series of moves. The board is a square grid of a given size, and each move is specified by the coordinates where the piece is placed. The second player wins if they manage to connect the left and right sides of the board with their pieces. What is the result of the game after the specified moves?\n\nThe input and output requirements are as follows:\n\nInput:\n  `size` (int): The size of the board (size x size).\n  `moves` (list of tuples): A list of moves, where each move is represented as a tuple `(x, y)` indicating the position on the board.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"has_won\"` which is a boolean indicating whether the second player has won the game.", "reference_code": "# import necessary packages\nimport numpy as np\nimport random\n\n# all class and function definitions in the code file, if any\ndef flip_move(move):\n    return move[1], move[0]\n\ndef new_board(size):\n    return np.zeros((2, size, size))\n\ndef make_move(board, move):\n    board[0, move[0], move[1]] = 1\n    return flip(board)\n\ndef flip(board):\n    return np.flip(np.transpose(board, (0, 2, 1)), 0)\n\ndef symmetry(board):\n    return np.flip(np.flip(board, 1), 2)\n\ndef symmetry_probs(probs):\n    return np.flip(np.flip(probs, 0), 1)\n\ndef dfs(board, x, y, visited):\n    size = board.shape[1]\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            if dx == 0 and dy == 0 or dx * dy == 1:\n                continue\n            nx, ny = x + dx, y + dy\n            if nx < 0 or nx >= size or ny < 0 or ny >= size:\n                continue\n            if board[1, nx, ny] == 0:\n                continue\n            if nx == size - 1:\n                return True\n            if (nx, ny) in visited:\n                continue\n            visited.add((nx, ny))\n            if dfs(board, nx, ny, visited):\n                return True\n    return False\n\ndef winner(board):\n    size = board.shape[1]\n    visited = set()\n    for y in range(size):\n        if board[1, 0, y] == 0:\n            continue\n        if (0, y) in visited:\n            continue\n        visited.add((0, y))\n        if dfs(board, 0, y, visited):\n            return True\n    return False\n\ndef normalize(probabilities):\n    return np.copy(probabilities) / np.sum(probabilities, (0, 1))\n\ndef fix_probabilities(board, probabilities):\n    size = board.shape[1]\n    result = np.copy(probabilities)\n    for x in range(size):\n        for y in range(size):\n            if board[0, x, y] != 0 or board[1, x, y] != 0:\n                result[x, y] = 0\n    return normalize(result)\n\ndef best_move(probabilities):\n    size = probabilities.shape[0]\n    max_probability = max(probabilities[x, y] for x in range(size) for y in range(size))\n    return random.choice(list((x, y) for x in range(size) for y in range(size) if probabilities[x, y] == max_probability))\n\ndef sample_move(probabilities):\n    size = probabilities.shape[0]\n    r = random.random()\n    for x in range(size):\n        for y in range(size):\n            prob = probabilities[x, y]\n            if r < prob:\n                return x, y\n            r -= prob\n    raise Exception('Failed to select move from probability distribution')\n\n# main function\ndef main_solution(size, moves):\n    # Convert moves from JSON serializable format to original format\n    moves = [(move[0], move[1]) for move in moves]\n    \n    # Initialize the board\n    board = new_board(size)\n    \n    # Apply each move to the board\n    for move in moves:\n        board = make_move(board, move)\n    \n    # Check if the second player has won\n    has_won = winner(board)\n    \n    # Return the result in JSON serializable format\n    return {\"has_won\": has_won}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.choice([5, 6, 7, 8, 9, 10])\n    num_moves = random.randint(1, size * size // 2)\n    moves = []\n    board = np.zeros((size, size), dtype=int)\n    \n    for _ in range(num_moves):\n        available = [(x, y) for x in range(size) for y in range(size) if board[x, y] == 0]\n        if not available:\n            break\n        move = random.choice(available)\n        moves.append(move)\n        board[move[0], move[1]] = 1\n    \n    return {\"size\": size, \"moves\": moves}", "io_pairs": [{"input": {"size": 9, "moves": [[8, 6], [6, 5]]}, "output": {"has_won": false}}, {"input": {"size": 5, "moves": [[2, 1], [2, 3]]}, "output": {"has_won": false}}, {"input": {"size": 6, "moves": [[3, 4]]}, "output": {"has_won": false}}, {"input": {"size": 5, "moves": [[2, 4], [3, 2], [2, 3], [4, 2]]}, "output": {"has_won": false}}, {"input": {"size": 6, "moves": [[2, 0], [0, 5], [0, 1], [2, 2], [4, 1], [4, 2]]}, "output": {"has_won": false}}, {"input": {"size": 5, "moves": [[1, 1], [4, 4], [4, 3], [4, 2]]}, "output": {"has_won": false}}, {"input": {"size": 5, "moves": [[1, 1], [4, 2], [3, 1], [1, 2], [1, 0]]}, "output": {"has_won": false}}, {"input": {"size": 5, "moves": [[2, 4], [4, 3], [2, 0], [3, 3]]}, "output": {"has_won": false}}, {"input": {"size": 6, "moves": [[0, 3], [3, 4], [2, 2], [3, 2], [1, 3]]}, "output": {"has_won": false}}, {"input": {"size": 5, "moves": [[3, 4], [2, 1]]}, "output": {"has_won": false}}], "error_log": []}
{"context": "Given a phone number consisting of digits, each digit can represent multiple letters on a telephone keypad. What are all the possible letter combinations that can be formed from the given phone number, sorted alphabetically?\n\nThe input and output requirements are as follows:\n\nInput:\n  `phone_number` (str): A string representing a phone number consisting of digits (0-9). The length of the string should be reasonable (e.g., less than 10 characters).\n\nOutput:\n  `return` (str): A string containing all possible letter combinations that the phone number could represent, sorted alphabetically and separated by commas.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef concat(i, val):\n    return i + val\n\ndef convert(digit):\n    if digit == \"0\": return \"0\"\n    if digit == \"1\": return \"1\"\n    if digit == \"2\": return [\"a\", \"b\", \"c\"]\n    if digit == \"3\": return [\"d\", \"e\", \"f\"]\n    if digit == \"4\": return [\"g\", \"h\", \"i\"]\n    if digit == \"5\": return [\"j\", \"k\", \"l\"]\n    if digit == \"6\": return [\"m\", \"n\", \"o\"]\n    if digit == \"7\": return [\"p\", \"q\", \"r\", \"s\"]\n    if digit == \"8\": return [\"t\", \"u\", \"v\"]\n    if digit == \"9\": return [\"w\", \"x\", \"y\", \"z\"]\n\n# main function\ndef main_solution(phone_number):\n    # Convert the phone number string to a list of characters\n    number = list(phone_number.rstrip())\n    number.reverse()\n\n    # Initialize the result with the first digit's possible characters\n    digit = number.pop()\n    result = []\n    result.append(convert(digit))\n    result = [item for sublist in result for item in sublist]\n\n    # Process each digit in the phone number\n    while number:\n        digit = number.pop()\n        values = convert(digit)\n        new_result = []\n        for val in values:\n            concatted = [concat(i, val) for i in result]\n            new_result.append(concatted)\n        new_result = [item for sublist in new_result for item in sublist]\n        result = new_result[:]\n\n    # Sort the result and return as a comma-separated string\n    result.sort()\n    return \",\".join(result)", "input_generator": "import random\n\ndef input_generator():\n    digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n    length = random.randint(1, 4)  # Keep the length reasonable to avoid too many combinations\n    phone_number = ''.join(random.choices(digits, k=length))\n    return {'phone_number': phone_number}", "io_pairs": [{"input": {"phone_number": "08"}, "output": "0t,0u,0v"}, {"input": {"phone_number": "4"}, "output": "g,h,i"}, {"input": {"phone_number": "9"}, "output": "w,x,y,z"}, {"input": {"phone_number": "903"}, "output": "w0d,w0e,w0f,x0d,x0e,x0f,y0d,y0e,y0f,z0d,z0e,z0f"}, {"input": {"phone_number": "96"}, "output": "wm,wn,wo,xm,xn,xo,ym,yn,yo,zm,zn,zo"}, {"input": {"phone_number": "3"}, "output": "d,e,f"}, {"input": {"phone_number": "53"}, "output": "jd,je,jf,kd,ke,kf,ld,le,lf"}, {"input": {"phone_number": "84"}, "output": "tg,th,ti,ug,uh,ui,vg,vh,vi"}, {"input": {"phone_number": "40"}, "output": "g0,h0,i0"}, {"input": {"phone_number": "152"}, "output": "1ja,1jb,1jc,1ka,1kb,1kc,1la,1lb,1lc"}], "error_log": []}
{"context": "Given two positive integers `a` and `m`, determine if there exists an integer `x` such that `x**2` is congruent to `a` modulo `m`. If such an integer exists, what is the value of `x`? If no such integer exists, what is the result?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): A positive integer representing the value for which we want to find a quadratic residue.\n  `m` (int): A positive integer representing the modulus.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"quadratic_residue\"` whose value is an integer. If a quadratic residue is found, the value is the integer `x` such that `x**2 \u2261 a (mod m)`. If no such integer is found, the value is `0`.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(a, m):\n    # Convert inputs to integers if they are not already\n    a = int(a)\n    m = int(m)\n    \n    # Ensure a is within the totient set of m\n    if a > m:\n        a = a % m\n    \n    found = 0\n    # Only need to find squares up to floor(m / 2), because x**2 = (-x)**2\n    for x in range(1, math.floor(m / 2)):\n        if (x**2) % m == a:\n            found = x\n            break\n    \n    # Return the result as a dictionary for JSON serialization\n    return {\"quadratic_residue\": found}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    m = random.randint(2, 1000)\n    a = random.randint(0, m - 1)\n    return {\"a\": a, \"m\": m}", "io_pairs": [{"input": {"a": 58, "m": 137}, "output": {"quadratic_residue": 0}}, {"input": {"a": 384, "m": 717}, "output": {"quadratic_residue": 63}}, {"input": {"a": 11, "m": 375}, "output": {"quadratic_residue": 0}}, {"input": {"a": 477, "m": 507}, "output": {"quadratic_residue": 81}}, {"input": {"a": 545, "m": 677}, "output": {"quadratic_residue": 280}}, {"input": {"a": 265, "m": 537}, "output": {"quadratic_residue": 0}}, {"input": {"a": 456, "m": 603}, "output": {"quadratic_residue": 0}}, {"input": {"a": 152, "m": 308}, "output": {"quadratic_residue": 0}}, {"input": {"a": 134, "m": 651}, "output": {"quadratic_residue": 0}}, {"input": {"a": 729, "m": 869}, "output": {"quadratic_residue": 27}}], "error_log": []}
{"context": "Given a specific probability distribution, what is the result of sampling from this distribution using the provided parameters? The distribution types include Bernoulli, Binomial, Geometric, Negative Binomial, Poisson, and Exponential. The parameters for each distribution are provided in a dictionary format.\n\nThe input and output requirements are as follows:\n\nInput:\n  `distribution_type` (str): The type of distribution to sample from. Possible values are \"bernoulli\", \"binomial\", \"geometric\", \"negbinomial\", \"poisson\", and \"exponential\".\n  `parameters` (dict): A dictionary containing the parameters required for the specified distribution. The keys and their corresponding values are:\n    - For \"bernoulli\": {\"p\": float} where `p` is the probability of success.\n    - For \"binomial\": {\"n\": int, \"p\": float} where `n` is the number of trials and `p` is the probability of success.\n    - For \"geometric\": {\"p\": float} where `p` is the probability of success.\n    - For \"negbinomial\": {\"n\": int, \"p\": float} where `n` is the number of successes and `p` is the probability of success.\n    - For \"poisson\": {\"lambd\": float} where `lambd` is the rate parameter.\n    - For \"exponential\": {\"lambd\": float} where `lambd` is the rate parameter.\n\nOutput:\n  `return` (dict): A dictionary containing the result of the sampling. The key is \"result\" and the value is an integer or float depending on the distribution type.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef sampling_bernoulli(p):\n    res = np.random.rand()\n    if res < p:\n        return 1\n    else:\n        return 0\n    \ndef sampling_binomial(n, p):\n    res = 0\n    for _ in range(n):\n        if sampling_bernoulli(p) == 1:\n            res += 1\n    return res\n    \ndef sampling_geometric(p):\n    res = 1\n    while sampling_bernoulli(p) != 1:\n        res += 1\n    return res\n        \ndef sampling_negbinomial(n, p):\n    cnt = 0\n    res = 0\n    while cnt < n:\n        if sampling_bernoulli(p) == 1:\n            cnt += 1\n        res += 1\n    return res\n        \ndef sampling_poisson(lambd):\n    return sampling_binomial(300, lambd / 300)\n        \ndef sampling_exponential(lambd):\n    return 0.001 * sampling_geometric(lambd * 0.001)\n\n# main function\ndef main_solution(distribution_type, parameters):\n    # Convert parameters to appropriate types\n    parameters = {k: float(v) for k, v in parameters.items()}\n    \n    if distribution_type == \"bernoulli\":\n        result = sampling_bernoulli(parameters[\"p\"])\n    elif distribution_type == \"binomial\":\n        result = sampling_binomial(int(parameters[\"n\"]), parameters[\"p\"])\n    elif distribution_type == \"geometric\":\n        result = sampling_geometric(parameters[\"p\"])\n    elif distribution_type == \"negbinomial\":\n        result = sampling_negbinomial(int(parameters[\"n\"]), parameters[\"p\"])\n    elif distribution_type == \"poisson\":\n        result = sampling_poisson(parameters[\"lambd\"])\n    elif distribution_type == \"exponential\":\n        result = sampling_exponential(parameters[\"lambd\"])\n    else:\n        raise ValueError(\"Invalid distribution type\")\n    \n    return {\"result\": result}", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    distribution_types = [\n        \"bernoulli\",\n        \"binomial\",\n        \"geometric\",\n        \"negbinomial\",\n        \"poisson\",\n        \"exponential\"\n    ]\n    distribution_type = random.choice(distribution_types)\n    \n    if distribution_type == \"bernoulli\":\n        parameters = {\"p\": round(random.uniform(0.1, 0.9), 2)}\n    elif distribution_type == \"binomial\":\n        parameters = {\n            \"n\": random.randint(5, 20),\n            \"p\": round(random.uniform(0.1, 0.9), 2)\n        }\n    elif distribution_type == \"geometric\":\n        parameters = {\"p\": round(random.uniform(0.1, 0.9), 2)}\n    elif distribution_type == \"negbinomial\":\n        parameters = {\n            \"n\": random.randint(3, 10),\n            \"p\": round(random.uniform(0.1, 0.9), 2)\n        }\n    elif distribution_type == \"poisson\":\n        parameters = {\"lambd\": round(random.uniform(0.5, 10), 2)}\n    elif distribution_type == \"exponential\":\n        parameters = {\"lambd\": round(random.uniform(0.1, 5), 2)}\n    \n    return {\n        \"distribution_type\": distribution_type,\n        \"parameters\": parameters\n    }", "io_pairs": [{"input": {"distribution_type": "geometric", "parameters": {"p": 0.58}}, "output": {"result": 1}}, {"input": {"distribution_type": "geometric", "parameters": {"p": 0.77}}, "output": {"result": 1}}, {"input": {"distribution_type": "poisson", "parameters": {"lambd": 8.73}}, "output": {"result": 8}}, {"input": {"distribution_type": "geometric", "parameters": {"p": 0.18}}, "output": {"result": 1}}, {"input": {"distribution_type": "negbinomial", "parameters": {"n": 10, "p": 0.33}}, "output": {"result": 25}}, {"input": {"distribution_type": "poisson", "parameters": {"lambd": 5.96}}, "output": {"result": 5}}, {"input": {"distribution_type": "binomial", "parameters": {"n": 8, "p": 0.77}}, "output": {"result": 4}}, {"input": {"distribution_type": "binomial", "parameters": {"n": 9, "p": 0.14}}, "output": {"result": 1}}, {"input": {"distribution_type": "exponential", "parameters": {"lambd": 0.56}}, "output": {"result": 5.312}}, {"input": {"distribution_type": "exponential", "parameters": {"lambd": 4.69}}, "output": {"result": 0.332}}], "error_log": []}
{"context": "Given a piece of text, how can we ensure that the text remains confidential during transmission by using RSA encryption, and what would be the decrypted message after the encryption process?\n\nThe input and output requirements are as follows:\n\nInput:\n  `text` (str): A string representing the text to be encrypted and decrypted using RSA encryption. The string should be a coherent piece of text, not excessively long (less than 1KB).\n\nOutput:\n  `return` (str): A string representing the decrypted message, which should be identical to the input `text` if the RSA encryption and decryption process is successful.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef string_to_bytes(s):\n    val = 0\n    for ch in s:\n        val = val << 8\n        val += ord(ch)\n    return val\n\ndef bytes_to_string(val):\n    s = ''\n    while val != 0:\n        ch_code = val & 255\n        s = chr(ch_code) + s\n        val = val >> 8\n    return s\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, x, y = egcd(b % a, a)\n        return (g, y - (b // a) * x, x)\n\ndef mulinv(b, n):\n    g, x, _ = egcd(b, n)\n    if g == 1:\n        return x % n\n\n# main function\ndef main_solution(text):\n    # Convert the input text to bytes\n    m = string_to_bytes(text)\n    \n    # Define the RSA parameters\n    p = 2 ** 2203 - 1\n    q = 2 ** 2281 - 1\n    n = p * q\n    e = 65537\n    d = mulinv(e, (p - 1) * (q - 1))\n    \n    # Ensure the message is smaller than n\n    while m > n:\n        text = text[:-1]\n        m = string_to_bytes(text)\n    \n    # Encrypt the message\n    ciphertext = pow(m, e, n)\n    \n    # Decrypt the message\n    decrypted_text = pow(ciphertext, d, n)\n    \n    # Convert the decrypted bytes back to string\n    decrypted_message = bytes_to_string(decrypted_text)\n    \n    # Return the decrypted message\n    return decrypted_message", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random length for the text between 1 and 100 characters\n    length = random.randint(1, 100)\n    # Generate random text using printable characters\n    text = ''.join(random.choices(string.printable, k=length))\n    return {'text': text}", "io_pairs": [{"input": {"text": "z(g(58}'5\u000bs~)j#=yG)z"}, "output": "z(g(58}'5\u000bs~)j#=yG)z"}, {"input": {"text": "0:%jYEzcgJF'DbtwJIE90/eK2l&9W\f&NZ#\fOa]$vz+or90Tf?uZs\nCF~\nNT"}, "output": "0:%jYEzcgJF'DbtwJIE90/eK2l&9W\f&NZ#\fOa]$vz+or90Tf?uZs\nCF~\nNT"}, {"input": {"text": "*Y{G5\t=f4rJYQ\"unZv\u000b"}, "output": "*Y{G5\t=f4rJYQ\"unZv\u000b"}, {"input": {"text": "W`m!Wr*}|K;\"\n&?#x9s-eZPylYiueHTK&\rz]y8NY D\u000bC[J4>rf\u000b J\"b-nd/\n7ol>\fp8kPDq "}, "output": "W`m!Wr*}|K;\"\n&?#x9s-eZPylYiueHTK&\rz]y8NY D\u000bC[J4>rf\u000b J\"b-nd/\n7ol>\fp8kPDq "}, {"input": {"text": "xl`>3^KwS\tYkn?Z@-CxUAov\"`cEwifv7`Q"}, "output": "xl`>3^KwS\tYkn?Z@-CxUAov\"`cEwifv7`Q"}, {"input": {"text": "]oaLkOWoIZ@3V*R\nbl)vLr;5hD6EE)M(<Q.%\f}}7331!\tpu"}, "output": "]oaLkOWoIZ@3V*R\nbl)vLr;5hD6EE)M(<Q.%\f}}7331!\tpu"}, {"input": {"text": "'2B*\\oJ4Z[]l0SnaMG<^'"}, "output": "'2B*\\oJ4Z[]l0SnaMG<^'"}, {"input": {"text": "$*"}, "output": "$*"}, {"input": {"text": "Ao(9$<sw;c0&pTfkDm Bt0P3@;z"}, "output": "Ao(9$<sw;c0&pTfkDm Bt0P3@;z"}, {"input": {"text": "\\B`5P5-s /LQgZr0\t`TtcxS&lXE}"}, "output": "\\B`5P5-s /LQgZr0\t`TtcxS&lXE}"}], "error_log": []}
{"context": "Given a function \\( g(t) = -e^t \\), we want to approximate its derivative at a specific point \\( t \\) using two different backward difference methods. For a given number of iterations \\( k \\), what are the differences between the computed derivatives using `Backward1` and `Backward2` methods and the exact derivative at \\( t \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n- `k` (int): The number of iterations to perform.\n- `t` (float): The point at which the derivative is evaluated.\n- `exact_derivative` (float): The exact value of the derivative at point `t`.\n\nOutput:\n- `return` (dict): A dictionary containing two lists of differences.\n  - `differences_backward1` (list of float): List of differences between the computed derivative using `Backward1` and the exact derivative for each iteration.\n  - `differences_backward2` (list of float): List of differences between the computed derivative using `Backward2` and the exact derivative for each iteration.", "reference_code": "# import necessary packages\nfrom math import exp\n\n# all class and function definitions in the code file, if any\nclass Diff:\n    def __init__(self, f, h=1E-5):\n        self.f = f\n        self.h = float(h)\n\nclass Forward1(Diff):\n    def __call__(self, x):\n        f, h = self.f, self.h\n        return (f(x + h) - f(x)) / h\n\nclass Backward1(Diff):\n    def __call__(self, x):\n        f, h = self.f, self.h\n        return (f(x) - f(x - h)) / h\n\nclass Backward2(Diff):\n    def __call__(self, x):\n        f, h = self.f, self.h\n        return (f(x - 2 * h) - 4 * f(x - h) + 3 * f(x)) / (2 * h)\n\n# main function\ndef main_solution(k, t, exact_derivative):\n    # Convert JSON serializable inputs to the original input variables\n    neg_e = lambda t: -exp(t)\n    \n    # Initialize lists to store differences\n    differences_backward1 = []\n    differences_backward2 = []\n    \n    # Calculate differences for each k value\n    for i in range(k + 1):\n        h = 2 ** (-i)\n        gt2 = Backward2(neg_e, h)\n        gt = Backward1(neg_e, h)\n        dif2 = gt2(t) - exact_derivative\n        dif = gt(t) - exact_derivative\n        differences_backward1.append(dif)\n        differences_backward2.append(dif2)\n    \n    # Return the differences as JSON serializable outputs\n    return {\n        \"differences_backward1\": differences_backward1,\n        \"differences_backward2\": differences_backward2\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    k = random.randint(1, 10)\n    t = random.uniform(-5.0, 5.0)\n    exact_derivative = -math.exp(t)\n    return {\n        \"k\": k,\n        \"t\": t,\n        \"exact_derivative\": exact_derivative\n    }", "io_pairs": [{"input": {"k": 4, "t": -0.6795592242735662, "exact_derivative": -0.5068403460592504}, "output": {"differences_backward1": [0.18645614327141746, 0.10798807286934275, 0.05838959543475297, 0.03039786160279012, 0.015513878694642158], "differences_backward2": [0.08519542261837404, 0.02952000246726827, 0.0087911180001633, 0.002406127770827715, 0.0006298957864950827]}}, {"input": {"k": 5, "t": -4.283342013117279, "exact_derivative": -0.013796476946866644}, "output": {"differences_backward1": [0.005075440229347987, 0.002939495581719685, 0.0015893973587853775, 0.0008274467494501937, 0.00042229643206440244, 0.0002133418660099657], "differences_backward2": [0.0023190669276268536, 0.0008035509340913825, 0.00023929913585106662, 6.549614011500289e-05, 1.7146114678625105e-05, 4.387299955501203e-06]}}, {"input": {"k": 7, "t": 0.33880784749618087, "exact_derivative": -1.4032736767542893}, "output": {"differences_backward1": [0.5162355360149631, 0.29898334108401436, 0.16166152301605208, 0.08416164843323126, 0.04295281101005055, 0.021699527051318723, 0.01090619859670805, 0.005467290798841118], "differences_backward2": [0.23587801340176928, 0.08173114615306587, 0.024339704948090235, 0.006661773850411334, 0.0017439735868698403, 0.00044624309259044814, 0.00011287014209737656, 2.83830010026076e-05]}}, {"input": {"k": 7, "t": -4.941380212747197, "exact_derivative": -0.007144730316015127}, "output": {"differences_backward1": [0.0026283993959763073, 0.0015222656680678867, 0.0008230953117409666, 0.00042850677737896973, 0.0002186930860781167, 0.00011048256041213626, 5.552861785777189e-05, 2.783656457326037e-05], "differences_backward2": [0.0012009665834614904, 0.0004161319401594652, 0.00012392495541404484, 3.3918243016969364e-05, 8.879394777263662e-06, 2.272034746155817e-06, 5.746753033242583e-07, 1.445112885823177e-07]}}, {"input": {"k": 5, "t": -0.6179123718798802, "exact_derivative": -0.5390686385781618}, "output": {"differences_backward1": [0.19831226951318437, 0.1148546753962455, 0.062102395681148836, 0.03233076055864803, 0.016500354661998617, 0.008335889640861627], "differences_backward2": [0.09061271629431256, 0.031397081279306516, 0.009350115966052286, 0.002559125436147003, 0.0006699487653496483, 0.00017142461972641243]}}, {"input": {"k": 6, "t": 2.7738154180399235, "exact_derivative": -16.019639175986903}, "output": {"differences_backward1": [5.893295907830208, 3.413165459552463, 1.8455126111591085, 0.9607813947419359, 0.49034521588607305, 0.24771974234969463, 0.12450412859224258], "differences_backward2": [2.6927610250517002, 0.9330350112747183, 0.2778597627657504, 0.07605017832475625, 0.019909037030210186, 0.005094268813344627, 0.001288514834676846]}}, {"input": {"k": 2, "t": -3.064043923640536, "exact_derivative": -0.04669846782927209}, "output": {"differences_backward1": [0.017179406248595187, 0.009949637170843087, 0.005379809766871385], "differences_backward2": [0.007849603397359142, 0.0027198680930909935, 0.0008099823628996694]}}, {"input": {"k": 5, "t": 1.9016056908907188, "exact_derivative": -6.696638545627573}, "output": {"differences_backward1": [2.463555645892612, 1.4267946442455113, 0.7714737362409121, 0.40163237456653356, 0.20497744283086128, 0.10355349186759533], "differences_backward2": [1.1256462818185735, 0.390033642598409, 0.11615282823631112, 0.03179101289215147, 0.008322511095181895, 0.0021295409043009528]}}, {"input": {"k": 3, "t": -1.082249934753421, "exact_derivative": -0.33883231677672276}, "output": {"differences_backward1": [0.1246494433466459, 0.0721920604763685, 0.039034544212271816, 0.02032154297110289], "differences_backward2": [0.0569547445245826, 0.019734677606091044, 0.005877027948174907, 0.0016085417299335214]}}, {"input": {"k": 7, "t": 2.7800538008923636, "exact_derivative": -16.119888189067538}, "output": {"differences_backward1": [5.930175458740301, 3.434524646550507, 1.857061611474549, 0.9667938514240859, 0.49341373843030567, 0.2492699432886667, 0.1252832607488159, 0.0628046530298576], "differences_backward2": [2.7096120060418407, 0.938873834360713, 0.279598576398584, 0.07652609137362276, 0.020033625436511215, 0.005126148147056142, 0.0012965782089082722, 0.000326045311126677]}}], "error_log": []}
{"context": "Given a chessboard with 8 queens, each placed in a different row, how can you determine the positions of the queens such that no two queens can attack each other? Specifically, what are the row and column positions of each queen on the chessboard?\n\nThe input and output requirements are as follows:\n\nInput:\n  `seed` (int): A seed value for the random number generator to ensure reproducibility.\n\nOutput:\n  `return` (list of tuples): A list of tuples where each tuple represents the position of a queen on the chessboard. Each tuple contains two integers: the row and the column of the queen.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Queen:\n    \"\"\"Represents one of eight queens on the chessboard\"\"\"\n\n    def __init__(self, row, neighbor):\n        self.row = row\n        # Prevent generating the same solution over and over\n        self.column = random.randint(1, 8)\n        self.neighbor = neighbor\n\n    def find_solution(self):\n        while self.neighbor is not None and \\\n            self.neighbor._can_attack(self.row, self.column):\n            if not self._advance():\n                return False\n        return True\n\n    def _advance(self):\n        if self.column < 8:\n            self.column += 1\n            return self.find_solution()\n        if self.neighbor is not None:\n            if not self.neighbor._advance():\n                return False\n            if not self.neighbor.find_solution():\n                return False\n        else:\n            self.column = 1\n            return self.find_solution()\n        self.column = 1\n        return self.find_solution()\n\n    def _can_attack(self, test_row, test_column):\n        # Horizontal\n        if self.column == test_column:\n            return True\n        # Diagonally\n        row_difference = test_row - self.row\n        if self.column + row_difference == test_column or \\\n            self.column - row_difference == test_column:\n            return True\n        if self.neighbor is not None:\n            return self.neighbor._can_attack(test_row, test_column)\n        return False\n\n    def print(self):\n        if self.neighbor is not None:\n            self.neighbor.print()\n        row = list('........')\n        row[self.column-1] = 'Q'\n        print(' '.join(row))\n\n# main function\ndef main_solution(seed):\n    # Set the random seed for reproducibility\n    random.seed(seed)\n    \n    # Initialize the first queen\n    q = None\n    for i in range(1, 9):\n        q = Queen(i, q)\n        q.find_solution()\n    \n    # Collect the positions of the queens\n    positions = []\n    current = q\n    while current is not None:\n        positions.append((current.row, current.column))\n        current = current.neighbor\n    \n    # Return the positions in a JSON serializable format\n    return positions", "input_generator": "import random\n\ndef input_generator():\n    seed = random.randint(0, 1000000)\n    return {'seed': seed}", "io_pairs": [{"input": {"seed": 199080}, "output": [[8, 5], [7, 2], [6, 4], [5, 6], [4, 8], [3, 3], [2, 1], [1, 7]]}, {"input": {"seed": 360839}, "output": [[8, 5], [7, 3], [6, 1], [5, 7], [4, 2], [3, 8], [2, 6], [1, 4]]}, {"input": {"seed": 814808}, "output": [[8, 6], [7, 4], [6, 7], [5, 1], [4, 3], [3, 5], [2, 2], [1, 8]]}, {"input": {"seed": 377953}, "output": [[8, 4], [7, 2], [6, 7], [5, 3], [4, 6], [3, 8], [2, 5], [1, 1]]}, {"input": {"seed": 46384}, "output": [[8, 2], [7, 5], [6, 7], [5, 1], [4, 3], [3, 8], [2, 6], [1, 4]]}, {"input": {"seed": 476796}, "output": [[8, 6], [7, 4], [6, 7], [5, 1], [4, 3], [3, 5], [2, 2], [1, 8]]}, {"input": {"seed": 289473}, "output": [[8, 3], [7, 5], [6, 7], [5, 1], [4, 4], [3, 2], [2, 8], [1, 6]]}, {"input": {"seed": 234682}, "output": [[8, 4], [7, 7], [6, 5], [5, 2], [4, 6], [3, 1], [2, 3], [1, 8]]}, {"input": {"seed": 481792}, "output": [[8, 5], [7, 7], [6, 1], [5, 3], [4, 8], [3, 6], [2, 4], [1, 2]]}, {"input": {"seed": 470221}, "output": [[8, 6], [7, 8], [6, 2], [5, 4], [4, 1], [3, 7], [2, 5], [1, 3]]}], "error_log": []}
{"context": "In the ancient tale of Josephus, a group of soldiers found themselves trapped and decided to form a circle to eliminate every k-th person until only one remained. Given a list of items representing the soldiers and a step count k, what is the order in which the items are removed from the circle?\n\nThe input and output requirements are as follows:\n\nInput:\n  `items` (list of any JSON serializable types): The initial sequence of items to be permuted.\n  `k` (int): The step count for elimination, always greater than or equal to 1.\n\nOutput:\n  `return` (list of any JSON serializable types): The Josephus permutation of the input list, where every k-th item is removed until none remain.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef josephus(items, k):\n    if items:\n        out = []\n        k -= 1  # fix the indexes (k=3 (position) => idx=2)\n        idx = k\n        while len(items) > 1:\n            out.append(items.pop(idx))\n            idx = (idx + k) % len(items)\n\n        out.append(items.pop(0))\n        return out\n    else:\n        return items\n\n# main function\ndef main_solution(items, k):\n    # Convert input to JSON serializable format if necessary\n    items = list(items)  # Ensure items is a list\n    k = int(k)  # Ensure k is an integer\n    \n    # Call the josephus function\n    result = josephus(items, k)\n    \n    # Convert output to JSON serializable format if necessary\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Randomly choose between generating a list of integers or strings\n    if random.choice([True, False]):\n        items = random.sample(range(1, 100), random.randint(5, 20))\n    else:\n        items = random.choices(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'], k=random.randint(5, 20))\n    \n    k = random.randint(2, 10)\n    \n    return {'items': items, 'k': k}", "io_pairs": [{"input": {"items": ["d", "h", "j", "b", "b", "c", "c", "j", "j", "i", "g", "j", "b"], "k": 5}, "output": ["b", "i", "h", "j", "d", "j", "b", "b", "j", "j", "c", "g", "c"]}, {"input": {"items": [96, 11, 50, 19, 53, 21, 8, 97, 51, 48, 92, 20, 24, 1, 29], "k": 2}, "output": [11, 19, 21, 97, 48, 20, 1, 96, 53, 51, 24, 50, 92, 8, 29]}, {"input": {"items": ["b", "f", "j", "g", "i", "b", "a", "e", "b", "j", "f"], "k": 7}, "output": ["a", "j", "f", "b", "e", "j", "f", "b", "b", "g", "i"]}, {"input": {"items": [86, 74, 25, 90, 18, 43, 95, 67], "k": 4}, "output": [90, 67, 18, 74, 86, 25, 95, 43]}, {"input": {"items": ["g", "j", "j", "d", "d", "f", "h", "j", "e", "f", "f", "b", "i", "d", "f"], "k": 8}, "output": ["j", "g", "f", "d", "d", "f", "h", "f", "e", "i", "j", "j", "b", "d", "f"]}, {"input": {"items": ["e", "e", "c", "b", "g", "a", "i", "a", "b", "a", "a", "c", "d", "d"], "k": 10}, "output": ["a", "a", "c", "e", "d", "e", "g", "b", "b", "d", "a", "a", "i", "c"]}, {"input": {"items": ["a", "i", "a", "a", "e", "i", "a", "f", "i", "j"], "k": 5}, "output": ["e", "j", "i", "i", "i", "f", "a", "a", "a", "a"]}, {"input": {"items": ["g", "h", "f", "h", "e", "j", "f", "e", "e", "g", "j", "f", "f", "h", "d", "d", "f"], "k": 10}, "output": ["g", "f", "h", "e", "h", "f", "d", "f", "d", "h", "f", "g", "f", "j", "e", "e", "j"]}, {"input": {"items": ["a", "j", "a", "a", "e", "g", "h", "c", "c", "e", "j"], "k": 5}, "output": ["e", "e", "a", "j", "h", "a", "j", "g", "c", "a", "c"]}, {"input": {"items": [66, 97, 14, 69, 86, 95, 17, 11, 64, 98, 55, 73, 50, 46, 80], "k": 8}, "output": [11, 66, 98, 69, 46, 55, 17, 95, 64, 50, 14, 97, 73, 86, 80]}], "error_log": []}
{"context": "In a family, the ratio of boys to girls is given by `boy_ratio` and `girl_ratio`. If the family has `trials` children, what is the probability that there are at least `min_boys` boys in the family?\n\nThe input and output requirements are as follows:\n\nInput:\n  `trials` (int): The total number of children in the family.\n  `boy_ratio` (float): The ratio of boys to girls.\n  `girl_ratio` (float): The ratio of girls to boys.\n  `min_boys` (int): The minimum number of boys required.\n\nOutput:\n  `return` (float): The probability of having at least `min_boys` boys in the family, rounded to three decimal places.", "reference_code": "# import necessary packages\nfrom math import factorial\n\n# main function\ndef main_solution(trials, boy_ratio, girl_ratio, min_boys):\n    # Convert JSON serializable inputs to original input variables\n    prob_boy = boy_ratio / (boy_ratio + girl_ratio)\n    \n    # Function to calculate binomial probability\n    def bi(x, n, p):\n        c = factorial(n) / (factorial(x) * factorial(n - x))\n        b = c * (p ** x) * ((1 - p) ** (n - x))\n        return b\n    \n    # Calculate the probability of having at least min_boys boys\n    b = [bi(boys, trials, prob_boy) for boys in range(min_boys, trials + 1)]\n    b = sum(b)\n    \n    # Convert the output to JSON serializable format\n    return round(b, 3)", "input_generator": "import random\nfrom math import gcd\n\ndef input_generator():\n    trials = random.randint(1, 20)\n    boy_num = random.randint(1, 10)\n    girl_num = random.randint(1, 10)\n    common_divisor = gcd(boy_num, girl_num)\n    boy_ratio = boy_num // common_divisor\n    girl_ratio = girl_num // common_divisor\n    min_boys = random.randint(1, trials)\n    \n    return {\n        'trials': trials,\n        'boy_ratio': boy_ratio,\n        'girl_ratio': girl_ratio,\n        'min_boys': min_boys\n    }", "io_pairs": [{"input": {"trials": 5, "boy_ratio": 1, "girl_ratio": 1, "min_boys": 5}, "output": 0.031}, {"input": {"trials": 2, "boy_ratio": 2, "girl_ratio": 7, "min_boys": 2}, "output": 0.049}, {"input": {"trials": 6, "boy_ratio": 4, "girl_ratio": 9, "min_boys": 6}, "output": 0.001}, {"input": {"trials": 3, "boy_ratio": 7, "girl_ratio": 1, "min_boys": 3}, "output": 0.67}, {"input": {"trials": 10, "boy_ratio": 1, "girl_ratio": 9, "min_boys": 5}, "output": 0.002}, {"input": {"trials": 7, "boy_ratio": 2, "girl_ratio": 3, "min_boys": 6}, "output": 0.019}, {"input": {"trials": 20, "boy_ratio": 1, "girl_ratio": 5, "min_boys": 12}, "output": 0.0}, {"input": {"trials": 9, "boy_ratio": 3, "girl_ratio": 10, "min_boys": 4}, "output": 0.132}, {"input": {"trials": 18, "boy_ratio": 1, "girl_ratio": 3, "min_boys": 7}, "output": 0.139}, {"input": {"trials": 1, "boy_ratio": 5, "girl_ratio": 2, "min_boys": 1}, "output": 0.714}], "error_log": []}
{"context": "Given a 2D matrix and an integer power, what is the resulting matrix when the input matrix is raised to the specified power?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_str` (str): A string representing a 2D matrix. Rows are separated by semicolons (`;`) and elements within each row are separated by commas (`,`). For example, `\"1,2;3,4\"` represents the matrix `[[1, 2], [3, 4]]`.\n  `power` (int): An integer representing the power to which the matrix should be raised.\n\nOutput:\n  `return` (str): A string representing the resulting matrix after raising the input matrix to the specified power. Rows are separated by semicolons (`;`) and elements within each row are separated by commas (`,`).", "reference_code": "# import necessary packages\nimport numpy as np\nfrom functools import reduce\nimport math\n\n# all class and function definitions in the code file, if any\ndef matrix_power(a, n):\n    if n == 0:\n        return np.eye(a.shape[0], dtype=int)\n    else:\n        gen = (a for i in range(abs(n)))\n        fun = lambda x,y : x@y\n        mul = reduce(fun, gen)\n        \n        if n > 0:\n            return mul\n        else:\n            return np.linalg.inv(mul)\n\n# main function\ndef main_solution(matrix_str, power):\n    # Convert the JSON serializable input to the original input variables\n    matrix = np.array([list(map(int, row.split(','))) for row in matrix_str.split(';')])\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    result_matrix = matrix_power(matrix, power)\n    \n    # Convert the result to a JSON serializable output\n    result_str = ';'.join(','.join(map(str, row)) for row in result_matrix)\n    \n    return result_str", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose matrix size (2x2, 3x3, or 4x4)\n    size = random.choice([2, 3, 4])\n    # Generate a random matrix with integers between -10 and 10\n    matrix = np.random.randint(-10, 11, size=(size, size))\n    # Convert matrix to string format\n    matrix_str = ';'.join(','.join(map(str, row)) for row in matrix)\n    # Randomly choose power between -3 and 3 (excluding 0)\n    power = random.choice([-3, -2, -1, 1, 2, 3])\n    return {'matrix_str': matrix_str, 'power': power}", "io_pairs": [{"input": {"matrix_str": "1,2;-1,-6", "power": 3}, "output": "9,58;-29,-194"}, {"input": {"matrix_str": "-1,4;-1,-7", "power": 1}, "output": "-1,4;-1,-7"}, {"input": {"matrix_str": "10,-1,-4;-2,4,2;-7,7,-9", "power": 1}, "output": "10,-1,-4;-2,4,2;-7,7,-9"}, {"input": {"matrix_str": "-7,-10;1,6", "power": 2}, "output": "39,10;-1,26"}, {"input": {"matrix_str": "6,-9,-7;-4,-4,-2;-2,-8,-3", "power": 3}, "output": "370,-902,-669;-380,-572,-234;-218,-842,-447"}, {"input": {"matrix_str": "-2,5,-5;-8,3,9;-1,0,-3", "power": 2}, "output": "-31,5,70;-17,-31,40;5,-5,14"}, {"input": {"matrix_str": "8,6;9,-8", "power": -2}, "output": "0.00847457627118644,0.0;0.0,0.00847457627118644"}, {"input": {"matrix_str": "-6,9;6,-4", "power": -1}, "output": "0.13333333333333333,0.3;0.2,0.2"}, {"input": {"matrix_str": "7,5,2,1;-6,5,9,-7;5,2,0,8;-7,10,-1,-8", "power": 2}, "output": "22,74,58,-20;22,-57,40,87;-33,115,20,-73;-58,-67,84,-21"}, {"input": {"matrix_str": "7,-2,-7,3;1,7,-5,8;-9,10,-10,-5;-5,-3,3,10", "power": 1}, "output": "7,-2,-7,3;1,7,-5,8;-9,10,-10,-5;-5,-3,3,10"}], "error_log": []}
{"context": "In a game of N-Queens, how can you arrange N queens on an NxN chessboard such that no two queens threaten each other? Given the dimension of the chessboard, what is the configuration of the board that satisfies this condition?\n\nThe input and output requirements are as follows:\n\nInput:\n  `dimension` (int): The size of the NxN chessboard and the number of queens to be placed.\n\nOutput:\n  `return` (list of lists of int): A 2D list representing the chessboard with queens placed. Each element is either 0 (no queen) or 1 (queen).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass N_Queens_Game:\n\n    def __init__(self, dimension):\n        self.board = []\n        self.dimension = dimension\n\n    def generate_board(self):\n        self.board = [[0 for x in range(self.dimension)] for y in range(self.dimension)]\n\n    def place_queens(self, queen):\n        if (queen == self.dimension):\n            return True\n        for row in range(self.dimension):\n            if (N_Queens_Game.is_legal_move(self, row, queen)):\n                self.board[row][queen] = 1\n                result = N_Queens_Game.place_queens(self, queen + 1)\n                if (result):\n                    return True\n                self.board[row][queen] = 0\n        return False\n\n    def is_legal_move(self, row, column):\n        for i in range(column):\n            if (self.board[row][i] == 1):\n                return False\n        first = [x for x in range(row, -1, -1)]\n        second = [x for x in range(column, -1, -1)]\n        for i, j in zip(first, second):\n            if (self.board[i][j] == 1):\n                return False\n        first = [x for x in range(row, self.dimension)]\n        second = [x for x in range(column, -1, -1)]\n        for i, j in zip(first, second):\n            if (self.board[i][j] == 1):\n                return False\n        return True\n\n# main function\ndef main_solution(dimension):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    game = N_Queens_Game(dimension)\n    game.generate_board()\n    game.place_queens(0)\n    # Convert the board to a list of lists of integers for JSON serialization\n    board_solution = game.board\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return board_solution", "input_generator": "import random\n\ndef input_generator():\n    dimension = random.randint(4, 12)  # Reasonable range for N-Queens problem\n    return {'dimension': dimension}", "io_pairs": [{"input": {"dimension": 6}, "output": [[0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0]]}, {"input": {"dimension": 5}, "output": [[1, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 1, 0, 0]]}, {"input": {"dimension": 4}, "output": [[0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]}], "error_log": []}
{"context": "Given a string of digits, how many unique prime numbers can be formed by permuting the digits in the string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numbers` (str): A string of digits from which permutations will be generated to check for prime numbers. The string should contain only numeric characters.\n\nOutput:\n  `return` (int): The number of unique prime numbers that can be formed by permuting the digits in the input string.", "reference_code": "# import necessary packages\nimport math\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef is_Prime(number):\n    if number <= 1:\n        return False\n    else:\n        for i in range(2, int(number**0.5) + 1):\n            if number % i == 0:\n                return False\n        return True\n\n# main function\ndef main_solution(numbers):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    nums = list(numbers)\n    p = []\n    for i in range(1, len(nums) + 1):\n        temp = list(map(''.join, itertools.permutations(numbers, i)))\n        p += temp\n    p = list(set(map(int, p)))\n    answer = 0\n    for number in p:\n        if is_Prime(number):\n            answer += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return answer", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    digits = random.sample(string.digits, length)\n    # Ensure no leading zeros in permutations by not including '0' as the first digit\n    if '0' in digits and digits[0] == '0':\n        random.shuffle(digits)\n    numbers = ''.join(digits)\n    return {'numbers': numbers}", "io_pairs": [{"input": {"numbers": "1974"}, "output": 18}, {"input": {"numbers": "79850"}, "output": 35}, {"input": {"numbers": "4792"}, "output": 11}, {"input": {"numbers": "5"}, "output": 1}, {"input": {"numbers": "59870"}, "output": 35}, {"input": {"numbers": "63"}, "output": 1}, {"input": {"numbers": "54"}, "output": 1}, {"input": {"numbers": "20"}, "output": 1}, {"input": {"numbers": "218"}, "output": 3}, {"input": {"numbers": "0"}, "output": 0}], "error_log": []}
{"context": "Given two very large integers, what is the product of these two numbers using a recursive multiplication algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (int): The first large integer to be multiplied.\n  `y` (int): The second large integer to be multiplied.\n\nOutput:\n  `return` (int): The result of the multiplication of `x` and `y`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef num_len(x, cnt=1):\n    if x > 10:\n        cnt += 1\n        return num_len(x/10, cnt)\n    return cnt\n\ndef multiply(v1, v2, n):\n    if n < 2:\n        return v1 * v2\n\n    div = 10 ** n\n    a = v1 // div\n    c = v2 // div\n    b = v1 % div\n    d = v2 % div\n    ac = multiply(a, c, n // 2)\n    bd = multiply(b, d, n // 2)\n    abc = multiply(a + b, c + d, n // 2)\n    return 10 ** (2 * n) * ac + 10 ** n * (abc - ac - bd) + bd\n\n# main function\ndef main_solution(x, y):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    n = max(num_len(x), num_len(y))\n    result = multiply(x, y, n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate random integers with lengths between 1 and 5 digits\n    len_x = random.randint(1, 5)\n    len_y = random.randint(1, 5)\n    \n    x = random.randint(10 ** (len_x - 1), (10 ** len_x) - 1)\n    y = random.randint(10 ** (len_y - 1), (10 ** len_y) - 1)\n    \n    return {'x': x, 'y': y}", "io_pairs": [{"input": {"x": 437, "y": 233}, "output": 101821}, {"input": {"x": 48, "y": 3774}, "output": 181152}, {"input": {"x": 882, "y": 452}, "output": 398664}, {"input": {"x": 6113, "y": 2}, "output": 12226}, {"input": {"x": 45, "y": 920}, "output": 41400}, {"input": {"x": 46661, "y": 1116}, "output": 52073676}, {"input": {"x": 71, "y": 252}, "output": 17892}, {"input": {"x": 8832, "y": 468}, "output": 4133376}, {"input": {"x": 25, "y": 2332}, "output": 58300}, {"input": {"x": 10, "y": 1141}, "output": 11410}], "error_log": []}
{"context": "Given a large number of random points generated within a square of side length 2 centered at the origin, how can we estimate the value of \u03c0 to three decimal places using the Monte Carlo method? Specifically, what is the estimated value of \u03c0 when the number of points inside a unit circle inscribed within the square is considered?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_samples` (int): The number of random points to generate for the Monte Carlo simulation. This should be a positive integer.\n\nOutput:\n  `return` (float): The estimated value of \u03c0 to 3 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(num_samples):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    num_inside = 0\n    for _ in range(num_samples):\n        x = (random.random() * 2) - 1\n        y = (random.random() * 2) - 1\n        if x*x + y*y <= 1:\n            num_inside += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return round(4 * num_inside / num_samples, 3)", "input_generator": "import random\n\ndef input_generator():\n    return {'num_samples': random.randint(100, 10000)}", "io_pairs": [{"input": {"num_samples": 2804}, "output": 3.134}, {"input": {"num_samples": 7976}, "output": 3.127}, {"input": {"num_samples": 5130}, "output": 3.101}, {"input": {"num_samples": 616}, "output": 3.123}, {"input": {"num_samples": 4676}, "output": 3.146}, {"input": {"num_samples": 5438}, "output": 3.144}, {"input": {"num_samples": 842}, "output": 3.135}, {"input": {"num_samples": 477}, "output": 3.153}, {"input": {"num_samples": 6954}, "output": 3.138}, {"input": {"num_samples": 8413}, "output": 3.135}], "error_log": []}
{"context": "Given a string consisting of lowercase letters, what are all the possible unique permutations of the string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of all possible permutations of the input string. Each permutation is represented as a string.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all permutations of the list of characters\n    permutations = [''.join(p) for p in itertools.permutations(char_list)]\n    \n    # Return the list of permutations as a JSON serializable output\n    return permutations", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    input_string = ''.join(random.choices(string.ascii_letters, k=length))\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "xeh"}, "output": ["xeh", "xhe", "exh", "ehx", "hxe", "hex"]}, {"input": {"input_string": "Uw"}, "output": ["Uw", "wU"]}, {"input": {"input_string": "fHb"}, "output": ["fHb", "fbH", "Hfb", "Hbf", "bfH", "bHf"]}, {"input": {"input_string": "qfL"}, "output": ["qfL", "qLf", "fqL", "fLq", "Lqf", "Lfq"]}, {"input": {"input_string": "yPQ"}, "output": ["yPQ", "yQP", "PyQ", "PQy", "QyP", "QPy"]}, {"input": {"input_string": "tz"}, "output": ["tz", "zt"]}, {"input": {"input_string": "sSH"}, "output": ["sSH", "sHS", "SsH", "SHs", "HsS", "HSs"]}, {"input": {"input_string": "uZ"}, "output": ["uZ", "Zu"]}, {"input": {"input_string": "u"}, "output": ["u"]}, {"input": {"input_string": "G"}, "output": ["G"]}], "error_log": []}
{"context": "Given a set of tabulated points with x and y coordinates, how can we estimate the y-value for a specific x-value using Lagrange interpolation? Specifically, what is the interpolated y-value for the given x-value `x` using the provided tabulated points `vectorx` and `vectory`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `vectorx` (list of float): A list of x-coordinates representing the tabulated points.\n  `vectory` (list of float): A list of y-coordinates representing the tabulated points corresponding to `vectorx`.\n  `x` (float): The x-value for which the interpolated y-value is to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing the result. If the interpolation is not possible, it will contain a key \"error\" with the value \"No se puede resolver por Interpolacion de Lagrange\". Otherwise, it will contain a key \"resultado\" with the interpolated y-value.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef obtenerOperandos(x, vectorx, pos):\n    j = 0\n    lista = [1, 1]\n    for i in vectorx:\n        if j != pos:\n            lista[0] = float(float(lista[0]) * (float(x) - float(i)))\n            lista[1] = float(float(lista[1]) * (float(vectorx[pos]) - float(i)))\n        j = j + 1\n    return lista\n\ndef obtenerDivision(x, vectorx, pos):\n    div = obtenerOperandos(x, vectorx, pos)\n    if div[1] != 0:\n        division = float(float(div[0]) / float(div[1]))\n        return division\n    else:\n        return \"NO\"\n\ndef obtenerResultado(vectorx, vectory, x):\n    res = 0\n    pos = 0\n    for coefy in vectory:\n        div = obtenerDivision(x, vectorx, pos)\n        if div == \"NO\":\n            return \"No se puede resolver por Interpolacion de Lagrange\"\n        else:\n            res = res + div * coefy\n        pos = pos + 1\n    return res\n\n# main function\ndef main_solution(vectorx, vectory, x):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert inputs to appropriate types if necessary\n    vectorx = [float(val) for val in vectorx]\n    vectory = [float(val) for val in vectory]\n    x = float(x)\n    \n    # Call the function to get the result\n    result = obtenerResultado(vectorx, vectory, x)\n    \n    # Convert the result to a JSON serializable output\n    if result == \"No se puede resolver por Interpolacion de Lagrange\":\n        return {\"error\": result}\n    else:\n        return {\"resultado\": result}", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(2, 5)  # Reasonable size for interpolation\n    vectorx = sorted([round(random.uniform(-10, 10), 2) for _ in range(n)])\n    vectory = [round(random.uniform(-10, 10), 2) for _ in range(n)]\n    x = round(random.uniform(min(vectorx) - 2, max(vectorx) + 2), 2)\n    \n    return {\n        \"vectorx\": vectorx,\n        \"vectory\": vectory,\n        \"x\": x\n    }", "io_pairs": [{"input": {"vectorx": [-6.81, -6.43, -2.72, -0.15, 4.83], "vectory": [-3.3, -3.09, 5.07, 5.68, -3.36], "x": 6.02}, "output": {"resultado": 0.33177161293992796}}, {"input": {"vectorx": [-4.65, 1.35], "vectory": [-9.02, -2.29], "x": -5.09}, "output": {"resultado": -9.513533333333331}}, {"input": {"vectorx": [-6.01, 2.84, 9.47, 9.87], "vectory": [-5.47, -2.32, -4.53, 9.56], "x": 10.84}, "output": {"resultado": 53.86598834592119}}, {"input": {"vectorx": [5.12, 7.79, 9.75], "vectory": [-3.25, 9.21, -9.4], "x": 6.05}, "output": {"resultado": 6.039512716533697}}, {"input": {"vectorx": [-1.95, 0.27, 2.09], "vectory": [-2.06, -2.86, -7.35], "x": -0.76}, "output": {"resultado": -1.849683132294518}}, {"input": {"vectorx": [-2.19, 1.35], "vectory": [2.76, -3.44], "x": 2.39}, "output": {"resultado": -5.261468926553672}}, {"input": {"vectorx": [-2.21, 6.02, 6.14, 7.93, 9.54], "vectory": [-6.03, -4.42, 2.84, 7.59, -1.84], "x": -2.16}, "output": {"resultado": -55.322762857892855}}, {"input": {"vectorx": [4.66, 7.97], "vectory": [-2.46, -3.46], "x": 8.11}, "output": {"resultado": -3.5022960725075523}}, {"input": {"vectorx": [-9.9, 0.3, 5.57, 7.91], "vectory": [-8.62, 0.89, -7.66, 0.4], "x": 0.61}, "output": {"resultado": -0.11299849886283848}}, {"input": {"vectorx": [-2.86, 0.88, 2.29, 3.23, 8.71], "vectory": [-1.27, -7.78, 6.23, -7.79, -3.51], "x": 5.33}, "output": {"resultado": -90.68412089695532}}], "error_log": []}
{"context": "Given a number, how can we encrypt and decrypt it using the RSA algorithm, and what are the resulting encrypted and decrypted values?\n\nThe input and output requirements are as follows:\n\nInput:\n  `valor` (int): The number to be encrypted and decrypted using RSA algorithm.\n\nOutput:\n  `return` (dict): A dictionary containing the encrypted and decrypted values.\n    - `encrypted_value` (int): The encrypted value of the input number.\n    - `decrypted_value` (int): The decrypted value of the encrypted number, which should match the original input number.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef lcm(x, y):\n    if x > y:\n       greater = x\n    else:\n       greater = y\n    l = 0\n    while(True):\n        if(greater % x == 0) and (greater % y == 0):\n            l = greater\n            break\n        greater += 1\n    return l\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return g, x - (b // a) * y, y\n\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('El inverso del modulo no existe')\n    else:\n        return x % m\n\ndef esprimo(n):\n    if n == 2 or n == 3: return True\n    if n < 2 or n%2 == 0: return False\n    if n < 9: return True\n    if n%3 == 0: return False\n    r = n**0.5\n    f = 5\n    while f <= r:\n        if n%f == 0: return False\n        if n%(f+2) == 0: return False\n        f +=6\n    return True\n\ndef sieveOfEratosthenes(n):\n    if n <= 2:\n        return []\n    sieve = list(range(3, n, 2))\n    top = len(sieve)\n    for si in sieve:\n        if si:\n            bottom = (si*si - 3) // 2\n            if bottom >= top:\n                break\n            sieve[bottom::si] = [0] * -((bottom - top) // si)\n    return [2] + [el for el in sieve if el]\n\ndef selec2prime(fin=100):\n    if fin < 47:\n        primoshasta = 100\n    else:\n        primoshasta = fin\n    primos = sieveOfEratosthenes(primoshasta)\n    while 1:\n        x, y = random.sample(primos, 2)\n        if x*y > fin:\n            return x, y\n        else:\n            continue\n\ndef seleccoprime(inicio=1, fin=100):\n    while 1:\n        x = random.randint(inicio,fin)\n        if esprimo(x):\n            if x % fin == 0:\n                continue\n            else:\n                return x\n        else:\n            continue\n\n# main function\ndef main_solution(valor):\n    p, q = selec2prime(valor)\n    n = p * q\n    phy = lcm((p - 1), (q - 1))\n    e = seleccoprime(1, phy)\n    d = modinv(e, phy)\n    c = valor ** e % n\n    desc = c ** d % n\n    return {\"encrypted_value\": c, \"decrypted_value\": desc}", "input_generator": "import random\n\ndef input_generator():\n    valor = random.randint(10, 1000)\n    return {\"valor\": valor}", "io_pairs": [{"input": {"valor": 143}, "output": {"encrypted_value": 143, "decrypted_value": 143}}, {"input": {"valor": 664}, "output": {"encrypted_value": 58915, "decrypted_value": 664}}, {"input": {"valor": 479}, "output": {"encrypted_value": 37228, "decrypted_value": 479}}, {"input": {"valor": 182}, "output": {"encrypted_value": 196, "decrypted_value": 182}}, {"input": {"valor": 247}, "output": {"encrypted_value": 5364, "decrypted_value": 247}}, {"input": {"valor": 669}, "output": {"encrypted_value": 9981, "decrypted_value": 669}}, {"input": {"valor": 546}, "output": {"encrypted_value": 4883, "decrypted_value": 546}}, {"input": {"valor": 476}, "output": {"encrypted_value": 7233, "decrypted_value": 476}}, {"input": {"valor": 94}, "output": {"encrypted_value": 313, "decrypted_value": 94}}, {"input": {"valor": 596}, "output": {"encrypted_value": 9585, "decrypted_value": 596}}], "error_log": []}
{"context": "You have a stack of pancakes, each of which can be either happy side up ('+') or unhappy side down ('-'). You also have a pancake flipper that can flip a specific number of consecutive pancakes at once. Given the initial state of the pancakes and the size of the flipper, how many flips are required to make all the pancakes happy side up? If it's impossible to achieve this, what should be returned?\n\nThe input and output requirements are as follows:\n\nInput:\n  `pancakes` (str): A string representing the state of pancakes, where '+' indicates a happy side up and '-' indicates an unhappy side up.\n  `flipper_size` (int): An integer representing the size of the pancake flipper, which determines how many consecutive pancakes can be flipped at once.\n\nOutput:\n  `return` (int or str): An integer representing the minimum number of flips needed to make all pancakes happy side up. If it's impossible, it returns the string \"IMPOSSIBLE\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef flipped(s):\n    return s.replace(\"-\", \"H\").replace(\"+\", \"-\").replace(\"H\", \"+\")\n\ndef compute_next(p, flipper_size):\n    states = set()\n    for i, c in enumerate(p):\n        if c == \"+\": continue\n        for j in range(flipper_size):\n            k = i - j\n            if k < 0: continue\n            if k + flipper_size > len(p): continue\n            new_state = (\n                p[:k] +\n                flipped(p[k:k+flipper_size]) +\n                p[k+flipper_size:])\n            states.add(new_state)\n    for s in states:\n        yield s\n\ndef how_many_flips(initial, size):\n    states = [(0, initial)]\n    seen = set()\n    while len(states) > 0:\n        (n, p) = states.pop(0)\n        seen.add(p)\n        if p.count(\"+\") == len(initial):\n            return n\n        else:\n            for next in compute_next(p, size):\n                if next in seen: continue\n                states.append((n + 1, next))\n    return \"IMPOSSIBLE\"\n\n# main function\ndef main_solution(pancakes, flipper_size):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    result = how_many_flips(pancakes, flipper_size)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    length = random.randint(5, 20)\n    flipper_size = random.randint(2, min(5, length))\n    pancakes = ''.join(random.choice(['+', '-']) for _ in range(length))\n    return {\n        'pancakes': pancakes,\n        'flipper_size': flipper_size\n    }", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "In a game of Tic Tac Toe, given a specific board configuration, what is the optimal move for the current player to make? The board is represented by a 3x3 grid where each cell can be either 'X', 'O', or empty (`None`). The optimal move should be determined based on the current state of the board.\n\nThe input and output requirements are as follows:\n\nInput:\n- `board_state` (list of lists): A 3x3 matrix representing the Tic Tac Toe board. Each cell can be 'X', 'O', or `None`.\n\nOutput:\n- `return` (tuple): A tuple representing the optimal move `(i, j)` where `i` and `j` are integers between 0 and 2.", "reference_code": "# import necessary packages\nimport math\nimport copy\nfrom itertools import chain\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function definitions from the code file\ndef initial_state():\n    \"\"\"\n    Returns starting state of the board.\n    \"\"\"\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\ndef player(board):\n    \"\"\"\n    Returns player who has the next turn on a board.\n    \"\"\"\n    x_num = sum(row.count(X) for row in board)\n    o_num = sum(row.count(O) for row in board)\n    return O if x_num > o_num else X\n\ndef actions(board):\n    \"\"\"\n    Returns set of all possible actions (i, j) available on the board.\n    \"\"\"\n    return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}\n\ndef result(board, action):\n    \"\"\"\n    Returns the board that results from making move (i, j) on the board.\n    \"\"\"\n    if board[action[0]][action[1]] is not EMPTY:\n        raise Exception(\"Move not valid\")\n    new_board = copy.deepcopy(board)\n    new_board[action[0]][action[1]] = player(board)\n    return new_board\n\ndef winner(board):\n    \"\"\"\n    Returns the winner of the game, if there is one.\n    \"\"\"\n    win_conditions = [\n        [board[i][0] for i in range(3)],  # Vertical\n        [board[i][1] for i in range(3)],  # Vertical\n        [board[i][2] for i in range(3)],  # Vertical\n        board[0], board[1], board[2],     # Horizontal\n        [board[i][i] for i in range(3)],  # Diagonal\n        [board[i][2-i] for i in range(3)] # Diagonal\n    ]\n    if [X, X, X] in win_conditions:\n        return X\n    if [O, O, O] in win_conditions:\n        return O\n    return None\n\ndef terminal(board):\n    \"\"\"\n    Returns True if game is over, False otherwise.\n    \"\"\"\n    return winner(board) is not None or all(cell is not EMPTY for row in board for cell in row)\n\ndef utility(board):\n    \"\"\"\n    Returns 1 if X has won the game, -1 if O has won, 0 otherwise.\n    \"\"\"\n    win = winner(board)\n    return 1 if win == X else -1 if win == O else 0\n\ndef minimax(board):\n    \"\"\"\n    Returns the optimal action for the current player on the board.\n    \"\"\"\n    def max_value(board, alpha, beta):\n        if terminal(board):\n            return utility(board)\n        v = float('-inf')\n        for action in actions(board):\n            v = max(v, min_value(result(board, action), alpha, beta))\n            alpha = max(alpha, v)\n            if alpha >= beta:\n                break\n        return v\n\n    def min_value(board, alpha, beta):\n        if terminal(board):\n            return utility(board)\n        v = float('inf')\n        for action in actions(board):\n            v = min(v, max_value(result(board, action), alpha, beta))\n            beta = min(beta, v)\n            if beta <= alpha:\n                break\n        return v\n\n    if terminal(board):\n        return None\n\n    current_player = player(board)\n    if current_player == X:\n        best_value = float('-inf')\n        best_action = None\n        for action in actions(board):\n            action_value = min_value(result(board, action), float('-inf'), float('inf'))\n            if action_value > best_value:\n                best_value = action_value\n                best_action = action\n        return best_action\n    else:\n        best_value = float('inf')\n        best_action = None\n        for action in actions(board):\n            action_value = max_value(result(board, action), float('-inf'), float('inf'))\n            if action_value < best_value:\n                best_value = action_value\n                best_action = action\n        return best_action\n\n# main function\ndef main_solution(board_state):\n    \"\"\"\n    Determines the optimal next move for the current player on the given Tic Tac Toe board.\n    \n    Input:\n    - board_state (list of lists): A 3x3 matrix representing the Tic Tac Toe board. Each cell can be 'X', 'O', or None.\n    \n    Output:\n    - return (tuple): A tuple representing the optimal move (i, j) where i and j are integers between 0 and 2.\n    \"\"\"\n    board = copy.deepcopy(board_state)\n    action = minimax(board)\n    return action", "input_generator": "import random\nfrom itertools import chain\n\ndef input_generator():\n    EMPTY = None\n    X = \"X\"\n    O = \"O\"\n    \n    # Generate a random board state\n    board = [[EMPTY for _ in range(3)] for _ in range(3)]\n    moves = random.randint(0, 8)  # Random number of moves made so far\n    \n    current_player = X\n    for _ in range(moves):\n        empty_cells = [(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY]\n        if not empty_cells:\n            break\n        move = random.choice(empty_cells)\n        board[move[0]][move[1]] = current_player\n        current_player = O if current_player == X else X\n    \n    return {'board_state': board}", "io_pairs": [{"input": {"board_state": [[null, null, null], [null, null, null], [null, null, "X"]]}, "output": [1, 1]}, {"input": {"board_state": [[null, "O", "X"], ["X", "X", "O"], [null, null, "O"]]}, "output": [2, 0]}, {"input": {"board_state": [["O", null, null], [null, "X", "O"], ["X", "X", null]]}, "output": [0, 1]}, {"input": {"board_state": [[null, null, null], [null, null, "O"], [null, null, "X"]]}, "output": [2, 1]}, {"input": {"board_state": [[null, null, null], [null, null, null], ["X", null, null]]}, "output": [1, 1]}, {"input": {"board_state": [[null, null, null], [null, "X", null], [null, null, null]]}, "output": [0, 0]}, {"input": {"board_state": [[null, "O", null], [null, null, null], [null, "X", null]]}, "output": [1, 2]}, {"input": {"board_state": [[null, null, "O"], [null, "X", null], ["O", "X", "X"]]}, "output": [0, 1]}, {"input": {"board_state": [[null, null, null], [null, null, "O"], [null, "X", "X"]]}, "output": [0, 1]}, {"input": {"board_state": [[null, "O", "X"], [null, "X", null], [null, null, null]]}, "output": [1, 2]}], "error_log": []}
{"context": "Given a \"magic\" 5-gon ring filled with numbers from 1 to 10, where each line adds up to 14, what is the maximum 16-digit string that can be formed by concatenating the groups of the ring, starting from the group with the numerically lowest external node and working clockwise? The ring is defined such that the sum of the numbers on each line is equal, and each number from 1 to 10 is used exactly once.\n\nThe input and output requirements are as follows:\n\nInput:\n  `o0` (int): The fixed external node value for the 5-gon ring.\n  `candidates_of_o` (list of int): List of candidate values for the remaining external nodes.\n  `candidates_of_i` (list of int): List of candidate values for the internal nodes.\n\nOutput:\n  `return` (str): The maximum 16-digit string formed by concatenating the groups of the \"magic\" 5-gon ring, or `None` if no valid solution is found.", "reference_code": "# import necessary packages\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\ndef repr_pentagon(i, o):\n    return ''.join(map(str, [\n    o[0], i[0], i[1],\n    o[1], i[1], i[2],\n    o[2], i[2], i[3],\n    o[3], i[3], i[4],\n    o[4], i[4], i[0]]))\n    \ndef sum_of_line(i, o):\n    return sum(i) + sum(o) * 2 / 5\n\ndef validate(i, o):\n    s = 14\n    sum_is_14 = all((\n    s == o[0] + i[0] + i[1],\n    s == o[1] + i[1] + i[2],\n    s == o[2] + i[2] + i[3],\n    s == o[3] + i[3] + i[4],\n    s == o[4] + i[4] + i[0]))\n    appears_each_number = set(i + o) == set(range(1, 11))\n    return sum_is_14 and appears_each_number\n\n# main function\ndef main_solution(o0, candidates_of_o, candidates_of_i):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    o = [o0] + candidates_of_o\n    i = [0, 0, 0, 0, 0]\n    res = []\n    for o[1:] in product(candidates_of_o, repeat=4):\n        for i[0] in candidates_of_i:\n            i[1] = 14 - i[0] - o[0]\n            i[4] = 14 - i[0] - o[4]\n            #\n            i[2] = 14 - i[1] - o[1]\n            i[3] = 14 - i[2] - o[2]\n            if not validate(i, o):\n                continue\n            pentagon = i + o\n            if not all(map(lambda x: x in candidates_of_i, i)):\n                continue\n            if not all(map(lambda x: x in candidates_of_o + [o0], o)):\n                continue\n            if pentagon.count(10) > 1:\n                continue\n            r = repr_pentagon(i, o)\n            if len(r) == 16:\n                res.append(r)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return max(res) if res else None", "input_generator": "import random\n\ndef input_generator():\n    # Generate o0 as a random number from 6 to 10 (since sum constraints make lower values less likely to work)\n    o0 = random.randint(6, 10)\n    \n    # Generate candidates_of_o as a list of 5 unique numbers from 1 to 10, excluding o0\n    all_numbers = list(range(1, 11))\n    all_numbers.remove(o0)\n    candidates_of_o = random.sample(all_numbers, 5)\n    \n    # Generate candidates_of_i as a list of 5 unique numbers from 1 to 10, not overlapping with candidates_of_o and o0\n    remaining_numbers = [x for x in range(1, 11) if x not in candidates_of_o and x != o0]\n    candidates_of_i = random.sample(remaining_numbers, 5)\n    \n    return {\n        'o0': o0,\n        'candidates_of_o': candidates_of_o,\n        'candidates_of_i': candidates_of_i\n    }", "io_pairs": [], "error_log": []}
{"context": "Given a partially filled 9x9 Sudoku grid, where '0' represents an empty cell, can you determine the unique solution that satisfies the Sudoku rules? The solution should ensure that each row, each column, and each of the nine 3x3 sub-grids contain all the digits from 1 to 9 without repetition. What is the complete 9x9 grid that represents the solved Sudoku puzzle?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sudoku_puzzle` (list of strings): A list of 9 strings, each string containing 9 digits (0-9). '0' represents an empty cell in the Sudoku puzzle.\n\nOutput:\n  `return` (list of strings): A list of 9 strings, each string containing 9 digits (1-9), representing the solved Sudoku puzzle.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef check(table, r, c, v):\n    for j in range(len(table)):\n        if table[r][j] == v:\n            return False\n\n    for i in range(len(table)):\n        if table[i][c] == v:\n            return False\n\n    rb = r // 3 * 3\n    cb = c // 3 * 3\n\n    for i in range(rb, rb + 3):\n        for j in range(cb, cb + 3):\n            if table[i][j] == v:\n                return False\n\n    return True\n\ndef dfs(table, r, c):\n    index = r * len(table) + c\n    if index == len(table) * len(table):\n        return True\n\n    index += 1\n\n    r2 = index // len(table)\n    c2 = index % len(table)\n\n    if table[r][c] == 0:  # \u6ca1\u6709\u6570\u5b57\n        # \u9009\u62e91-9\u4e4b\u95f4\u5408\u6cd5\u7684\u6570\u5b57\u586b\u5230x, y\u8fd9\u4e2a\u4f4d\u7f6e\n        for i in range(1, 10):\n            if check(table, r, c, i):\n                table[r][c] = i\n\n                if dfs(table, r2, c2):\n                    return True\n\n                # \u72b6\u6001\u9700\u8981\u6062\u590d  \u56de\u6eaf\n                table[r][c] = 0\n\n    else:\n        # \u7ee7\u7eed\u627e\u4e0b\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\u4f4d\u7f6e\n        if dfs(table, r2, c2):\n            return True\n\n    return False\n\n# main function\ndef main_solution(sudoku_puzzle):\n    # Convert the input string list to a 2D list of integers\n    table = [[int(e) for e in row] for row in sudoku_puzzle]\n    \n    # Solve the Sudoku puzzle\n    dfs(table, 0, 0)\n    \n    # Convert the solved 2D list back to a list of strings\n    solved_puzzle = [''.join(map(str, row)) for row in table]\n    \n    return solved_puzzle", "input_generator": "import random\n\ndef input_generator():\n    # Generate a partially filled Sudoku puzzle (9x9 grid)\n    # Start with an empty grid\n    grid = [[0 for _ in range(9)] for _ in range(9)]\n    \n    # Fill some cells with valid numbers\n    for _ in range(random.randint(15, 30)):  # Fill between 15 to 30 cells\n        row = random.randint(0, 8)\n        col = random.randint(0, 8)\n        num = random.randint(1, 9)\n        if grid[row][col] == 0 and check(grid, row, col, num):\n            grid[row][col] = num\n    \n    # Convert the grid to a list of strings\n    sudoku_puzzle = [''.join(map(str, row)) for row in grid]\n    \n    return {'sudoku_puzzle': sudoku_puzzle}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a digital filter designed for multiple subbands, how does the frequency response of the filter change when it is shifted to a specific subband? Specifically, what is the frequency response of the filter when it is shifted to subband `k` for a system with `N` subbands, and what are the frequency response values at `num_points` points in the impulse response?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): Number of subbands.\n  `k` (int): Subband index (0-based).\n  `num_points` (int): Number of points in the impulse response.\n\nOutput:\n  `return` (list): Frequency response values at the specified points. Each value in the list represents the magnitude of the frequency response at a specific frequency point.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(N, k, num_points):\n    \"\"\"\n    Calculate the frequency response of a shifted bandpass filter for a given subband.\n\n    Parameters:\n    N (int): Number of subbands.\n    k (int): Subband index (0-based).\n    num_points (int): Number of points in the impulse response.\n\n    Returns:\n    list: Frequency response values at the specified points.\n    \"\"\"\n    # Calculate the baseband prototype filter impulse response\n    h = np.sin(np.pi / (2 * N) * (np.arange(num_points) + 0.5))\n    \n    # Calculate the impulse response for the k-th subband\n    h_k = h * np.cos(np.pi / N * (np.arange(num_points) + 0.5 + N / 2) * (k + 0.5))\n    \n    # Calculate the frequency response using the FFT\n    freq_response = np.abs(np.fft.fft(h_k))\n    \n    # Return the frequency response values as a list\n    return freq_response.tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    N = random.randint(2, 32)\n    k = random.randint(0, N-1)\n    num_points = random.randint(10, 100)\n    return {'N': N, 'k': k, 'num_points': num_points}", "io_pairs": [{"input": {"N": 28, "k": 4, "num_points": 15}, "output": [1.0956217589875583, 2.636622946051971, 1.2677622879436317, 0.4712682407173177, 0.2997554553149108, 0.23233602627349653, 0.20115286080791947, 0.18829238382798857, 0.18829238382798866, 0.20115286080791947, 0.23233602627349637, 0.29975545531491093, 0.4712682407173177, 1.2677622879436317, 2.6366229460519715]}, {"input": {"N": 27, "k": 12, "num_points": 18}, "output": [0.6094910725147673, 0.6420974802039008, 0.766079160113784, 1.1401540201372196, 4.13682017355995, 1.6806244177456682, 0.5731029222391751, 0.3021610577563151, 0.1893965266744047, 0.1540775299179551, 0.18939652667440485, 0.302161057756315, 0.5731029222391751, 1.6806244177456684, 4.13682017355995, 1.1401540201372193, 0.7660791601137841, 0.6420974802039007]}, {"input": {"N": 13, "k": 10, "num_points": 12}, "output": [0.09974083311655402, 0.1175470215673223, 0.18134767262848125, 0.35793335470040477, 1.212501102634045, 3.58486979083562, 1.4609100476665828, 3.5848697908356195, 1.212501102634045, 0.3579333547004049, 0.1813476726284812, 0.11754702156732234]}, {"input": {"N": 23, "k": 20, "num_points": 14}, "output": [0.30936854551337656, 0.3176341792662978, 0.3448667991879086, 0.4004311743165648, 0.5109614366744519, 0.772146401259891, 2.485249944430298, 1.8109533858354874, 2.485249944430298, 0.7721464012598909, 0.5109614366744519, 0.40043117431656483, 0.3448667991879086, 0.317634179266298]}, {"input": {"N": 10, "k": 7, "num_points": 13}, "output": [0.49674203153709917, 0.5196243786036296, 0.603353222292829, 0.8313053053531034, 1.940600109914693, 4.433724165887459, 0.5073819430872383, 0.5073819430872383, 4.433724165887459, 1.940600109914693, 0.8313053053531034, 0.603353222292829, 0.5196243786036296]}, {"input": {"N": 21, "k": 18, "num_points": 15}, "output": [0.45866071044292833, 0.4699749422268228, 0.507122433564407, 0.5824111471070601, 0.7309273521207954, 1.0818442565673176, 2.9115354852789626, 2.9406611509882716, 2.940661150988271, 2.9115354852789626, 1.081844256567318, 0.7309273521207954, 0.5824111471070601, 0.5071224335644071, 0.469974942226823]}, {"input": {"N": 3, "k": 0, "num_points": 15}, "output": [4.596194077712557, 0.8911227508421197, 2.41157359172355, 2.4072982723116647, 0.8484292931245268, 0.5590169943749469, 0.45267541144319184, 0.41277207899926305, 0.4127720789992631, 0.45267541144319184, 0.5590169943749471, 0.8484292931245265, 2.4072982723116647, 2.41157359172355, 0.8911227508421197]}, {"input": {"N": 21, "k": 15, "num_points": 10}, "output": [0.16081418878048026, 0.18477127933565876, 0.2947149602172531, 0.9391252340497978, 1.8440052543369843, 0.7410613521667966, 1.8440052543369843, 0.9391252340497976, 0.2947149602172531, 0.18477127933565882]}, {"input": {"N": 19, "k": 6, "num_points": 19}, "output": [0.6464111549565464, 0.7235925121520485, 1.0665275198297333, 5.39517602831225, 3.038908457981086, 1.049456449964759, 0.6706970691601953, 0.5226509835197793, 0.45400166772306655, 0.4256368515175087, 0.4256368515175087, 0.45400166772306655, 0.5226509835197793, 0.6706970691601953, 1.049456449964759, 3.038908457981086, 5.39517602831225, 1.0665275198297333, 0.7235925121520485]}, {"input": {"N": 6, "k": 1, "num_points": 10}, "output": [0.09649639815441091, 3.407083597313155, 1.7494878054559684, 0.3697984856361046, 0.2251067778555281, 0.19639682065904168, 0.2251067778555281, 0.36979848563610435, 1.7494878054559684, 3.407083597313155]}], "error_log": []}
{"context": "Given a set of nodes and their pairwise distances, how can we construct a phylogenetic tree that represents the evolutionary relationships between these nodes using the Neighbor Joining algorithm? Specifically, what is the adjacency list of the resulting tree, where each edge is represented by a tuple containing the start node, end node, and the weight of the edge?\n\nThe input and output requirements are as follows:\n\nInput:\n  `distance_matrix` (list of lists of floats): A square matrix representing the distances between nodes. Each element `distance_matrix[i][j]` represents the distance between node `i` and node `j`.\n\nOutput:\n  `adjacency_list` (list of tuples): A list of tuples representing the adjacency list of the resulting tree. Each tuple contains `(start_node, end_node, weight)`, where `start_node` and `end_node` are integers representing the nodes, and `weight` is a float representing the distance between them.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Tree():\n    \"\"\" Tree class\n    N: Number of nodes,\n    bidrectional: flag variable indicates undirected/directed tree \n    \"\"\"\n    def __init__(self, N=0, bidirectional=True):\n        self.nodes = list(range(N))\n        self.edges = {}\n        self.bidirectional = bidirectional\n        self.N = N\n\n    def link(self, start, end, weight=1): \n        \"\"\" Link two nodes to form an edge \"\"\"\n        self.half_link(start, end, weight)\n        if self.bidirectional:\n            self.half_link(end, start, weight)\n\n    def half_link(self, a, b, weight=1):\n        if a not in self.nodes:\n            self.nodes.append(a)        \n        if a in self.edges:               \n            self.edges[a] = [(b0, w0) for (b0, w0) in self.edges[a] if b0 != b] + [(b, weight)]\n        else:\n            self.edges[a] = [(b, weight)]\n\n    def get_adjacency_list(self):\n        \"\"\" Get the adjacency list as a list of tuples (start, end, weight) \"\"\"\n        adjacency_list = []\n        self.nodes.sort()\n        for node in self.nodes:\n            if node in self.edges:\n                self.edges[node].sort()\n                for edge in self.edges[node]:\n                    end, weight = edge\n                    adjacency_list.append((node, end, round(weight, 3)))\n        return adjacency_list\n\ndef NeighborJoining(D, n, node_list=None):\n    \"\"\" Function implements neighbor joining algorithm\n    D: Distance matrix of size NxN\n    n: N  \n    \"\"\"\n    def remove(i, D):\n        \"\"\" Remove row and column i from distance matrix D \"\"\"\n        D_new = []\n        for j in range(len(D)):\n            if j != i:\n                D_new.append([D[j][k] for k in range(len(D[j])) if k != i])\n        return D_new        \n        \n    def create_DPrime(Total_distance):\n        \"\"\" Construct the neighbour joining matrix from distance matrix. Return i, j such that DPrime i,j is a minimum non-diagonal element of DPrime \"\"\"\n\n        DPrime = [[0] * n for _ in range(n)]\n\n        min_i, min_j, min_D = 0, 0, 10**8    # setting the minimum distance as arbitrary large number\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                DPrime[i][j] = (n - 2) * D[i][j] - Total_distance[i] - Total_distance[j]\n                DPrime[j][i] = DPrime[i][j]\n                if DPrime[i][j] < min_D:\n                    min_i, min_j, min_D = i, j, DPrime[i][j]\n                    \n        return DPrime, min_i, min_j\n    \n    def create_Delta(Total_distance):\n        \"\"\" \u0394 \u2190 (TotalDistanceD(i) - TotalDistanceD(j)) /(n - 2) \"\"\"\n        Delta = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                Delta[i][j] = (Total_distance[i] - Total_distance[j]) / (n - 2)\n                Delta[j][i] = Delta[i][j]\n        return Delta\n\n    if node_list is None:\n        node_list = list(range(n))\n        \n    if n == 2:\n        \"\"\" Base case \"\"\"\n        T = Tree()\n        T.link(node_list[0], node_list[1], D[0][1])\n        return T\n\n    else:\n        Total_distance = [sum(row) for row in D]\n        _, i, j = create_DPrime(Total_distance)\n\n        Delta = create_Delta(Total_distance)\n\n        limbLength_i = (D[i][j] + Delta[i][j]) / 2\n        limbLength_j = (D[i][j] - Delta[i][j]) / 2\n\n        new_row = [0.5 * (D[k][i] + D[k][j] - D[i][j]) for k in range(n)] + [0]\n \n        D.append(new_row)\n        for l in range(n):\n            D[l].append(new_row[l])\n\n        m = node_list[-1] + 1\n        node_list.append(m)\n\n        D = remove(max(i, j), D)\n        D = remove(min(i, j), D)\n        node_i = node_list[i]\n        node_j = node_list[j]\n\n        node_list.remove(node_i)\n        node_list.remove(node_j)\n\n        T = NeighborJoining(D, n - 1, node_list)\n\n        T.link(node_i, m, limbLength_i)\n        T.link(node_j, m, limbLength_j)       \n        return T\n\n# main function\ndef main_solution(distance_matrix):\n    \"\"\"\n    Main function to solve the Neighbor Joining problem.\n    \n    Input:\n    distance_matrix (list of lists of floats): A square matrix representing the distances between nodes.\n    \n    Output:\n    adjacency_list (list of tuples): A list of tuples representing the adjacency list of the resulting tree.\n                                     Each tuple contains (start_node, end_node, weight).\n    \"\"\"\n    n = len(distance_matrix)\n    tree = NeighborJoining(distance_matrix, n)\n    return tree.get_adjacency_list()", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    n = random.randint(3, 10)  # Generate a random number of nodes between 3 and 10\n    # Create a random symmetric distance matrix with positive values\n    distance_matrix = np.random.uniform(0.1, 10.0, size=(n, n))\n    distance_matrix = (distance_matrix + distance_matrix.T) / 2  # Ensure symmetry\n    np.fill_diagonal(distance_matrix, 0)  # Diagonal should be zero\n    distance_matrix = distance_matrix.tolist()\n    return {'distance_matrix': distance_matrix}", "io_pairs": [{"input": {"distance_matrix": [[0.0, 2.8346680522790475, 8.65982708430942, 0.0], [2.8346680522790475, 0.0, 1.8242218045646488, 0.0], [8.65982708430942, 1.8242218045646488, 0.0, 3.8246904182975108], [0.0, 0.0, 3.8246904182975108, 0]]}, "output": [[0, 3, 4.835], [1, 3, -2.0], [2, 3, 3.825], [3, 0, 4.835], [3, 1, -2.0], [3, 2, 3.825]]}, {"input": {"distance_matrix": [[0.0, 0.9693750429676109, 4.025134614356196, 0.0], [0.9693750429676109, 0.0, 7.821945044016793, 0.0], [4.025134614356196, 7.821945044016793, 0.0, 5.438852307702689], [0.0, 0.0, 5.438852307702689, 0]]}, "output": [[0, 3, -1.414], [1, 3, 2.383], [2, 3, 5.439], [3, 0, -1.414], [3, 1, 2.383], [3, 2, 5.439]]}, {"input": {"distance_matrix": [[0.0, 7.843807300151688, 6.749017657109105, 0.0], [7.843807300151688, 0.0, 7.99007223017623, 0.0], [6.749017657109105, 7.99007223017623, 0.0, 3.4476412935668233], [0.0, 0.0, 3.4476412935668233, 0]]}, "output": [[0, 3, 3.301], [1, 3, 4.542], [2, 3, 3.448], [3, 0, 3.301], [3, 1, 4.542], [3, 2, 3.448]]}, {"input": {"distance_matrix": [[0.0, 5.035316328662194, 3.1568919766066603, 0.0], [5.035316328662194, 0.0, 4.701807863216938, 0.0], [3.1568919766066603, 4.701807863216938, 0.0, 1.4116917555807023], [0.0, 0.0, 1.4116917555807023, 0]]}, "output": [[0, 3, 1.745], [1, 3, 3.29], [2, 3, 1.412], [3, 0, 1.745], [3, 1, 3.29], [3, 2, 1.412]]}, {"input": {"distance_matrix": [[0.0, 3.246017970840762, 2.1278826924526375, 0.0], [3.246017970840762, 0.0, 6.923666928324961, 0.0], [2.1278826924526375, 6.923666928324961, 0.0, 2.9027658249684176], [0.0, 0.0, 2.9027658249684176, 0]]}, "output": [[0, 3, -0.775], [1, 3, 4.021], [2, 3, 2.903], [3, 0, -0.775], [3, 1, 4.021], [3, 2, 2.903]]}, {"input": {"distance_matrix": [[0.0, 6.926695847993853, 3.437589501787118, 0.0], [6.926695847993853, 0.0, 3.6299984955145668, 0.0], [3.437589501787118, 3.6299984955145668, 0.0, 0.0704460746539155], [0.0, 0.0, 0.0704460746539155, 0]]}, "output": [[0, 3, 3.367], [1, 3, 3.56], [2, 3, 0.07], [3, 0, 3.367], [3, 1, 3.56], [3, 2, 0.07]]}, {"input": {"distance_matrix": [[0.0, 1.1824516229781832, 7.6820551491765, 0.0], [1.1824516229781832, 0.0, 7.195875364491204, 0.0], [7.6820551491765, 7.195875364491204, 0.0, 6.84773944534476], [0.0, 0.0, 6.84773944534476, 0]]}, "output": [[0, 3, 0.834], [1, 3, 0.348], [2, 3, 6.848], [3, 0, 0.834], [3, 1, 0.348], [3, 2, 6.848]]}, {"input": {"distance_matrix": [[0.0, 5.008007054357518, 3.1042768756552164, 0.0], [5.008007054357518, 0.0, 4.669327512909518, 0.0], [3.1042768756552164, 4.669327512909518, 0.0, 1.3827986671036085], [0.0, 0.0, 1.3827986671036085, 0]]}, "output": [[0, 3, 1.721], [1, 3, 3.287], [2, 3, 1.383], [3, 0, 1.721], [3, 1, 3.287], [3, 2, 1.383]]}, {"input": {"distance_matrix": [[0.0, 2.656192876675351, 2.416954777861276, 0.0], [2.656192876675351, 0.0, 7.955126952935143, 0.0], [2.416954777861276, 7.955126952935143, 0.0, 3.857944427060534], [0.0, 0.0, 3.857944427060534, 0]]}, "output": [[0, 3, -1.441], [1, 3, 4.097], [2, 3, 3.858], [3, 0, -1.441], [3, 1, 4.097], [3, 2, 3.858]]}, {"input": {"distance_matrix": [[0.0, 1.621076065628424, 7.783591016151729, 0.0], [1.621076065628424, 0.0, 3.7976955859201618, -1.182409682301572], [7.783591016151729, 3.7976955859201618, 0.0, 0.0], [0.0, -1.182409682301572, 0.0, 0]]}, "output": [[0, 3, 2.803], [1, 3, -1.182], [2, 3, 4.98], [3, 0, 2.803], [3, 1, -1.182], [3, 2, 4.98]]}], "error_log": []}
{"context": "Given a 9x9 Sudoku board represented as a string, where each row is a string of 9 characters and rows are separated by semicolons, determine whether the board is a valid Sudoku configuration. A valid Sudoku board must satisfy the following conditions:\n1. Each row must contain the digits '1'-'9' without repetition.\n2. Each column must contain the digits '1'-'9' without repetition.\n3. Each of the nine 3x3 sub-grids must contain the digits '1'-'9' without repetition.\n\nWhat is the validity status of the provided Sudoku board?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (str): A string representing a 9x9 Sudoku board. Each row is represented by a string of 9 characters, where each character is either a digit from '1' to '9' or a '.' to represent an empty cell. Rows are separated by a semicolon ';'.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the Sudoku board is valid (True) or not (False).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def isValidSudoku(self, board):\n        \"\"\" Returns True if matrix represents valid sudoku board,\n        False otherwise.\n        \"\"\"\n        digits = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"}\n\n        if len(board) != 9:  # sudoku board must have 9 rows\n            return False\n        for i in range(9):  # check each row\n            if len(board[i]) != 9:  # each row must have 9 elements\n                return False\n            curr = set()  # digits in current row\n            for j in range(9):\n                if board[i][j] == \".\":\n                    continue\n                if board[i][j] in digits and board[i][j] not in curr:\n                    curr.add(board[i][j])\n                else:\n                    return False\n        for j in range(9):  # check each column\n            curr = set()  # digits in current column\n            for i in range(9):\n                if board[i][j] == \".\":\n                    continue\n                if board[i][j] in digits and board[i][j] not in curr:\n                    curr.add(board[i][j])\n                else:\n                    return False\n        for x in range(0, 9, 3):  # check each 9x9 square\n            for y in range(0, 9, 3):\n                curr = set()  # digits in current 9x9 square\n                for i in range(x, x + 3):\n                    for j in range(y, y + 3):\n                        if board[i][j] == \".\":\n                            continue\n                        if board[i][j] in digits and board[i][j] not in curr:\n                            curr.add(board[i][j])\n                        else:\n                            return False\n        return True\n\n# main function\ndef main_solution(board):\n    # Convert the input board to a list of lists if it's not already\n    if isinstance(board, str):\n        board = [list(row) for row in board.split(';')]\n    \n    # Create an instance of the Solution class\n    sol = Solution()\n    \n    # Call the isValidSudoku method and return the result\n    return sol.isValidSudoku(board)", "input_generator": "import random\n\ndef input_generator():\n    # Generate a valid or invalid Sudoku board with some randomness\n    digits = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n    board = [['.' for _ in range(9)] for _ in range(9)]\n    \n    # Decide whether to generate a valid or invalid board (70% chance valid)\n    if random.random() < 0.7:\n        # Generate a valid Sudoku board\n        for i in range(9):\n            for j in range(9):\n                if random.random() < 0.5:  # 50% chance to place a digit\n                    # Ensure no duplicates in row, column, or 3x3 subgrid\n                    used = set()\n                    # Check row\n                    for k in range(9):\n                        if board[i][k] != '.':\n                            used.add(board[i][k])\n                    # Check column\n                    for k in range(9):\n                        if board[k][j] != '.':\n                            used.add(board[k][j])\n                    # Check 3x3 subgrid\n                    start_row, start_col = 3 * (i // 3), 3 * (j // 3)\n                    for x in range(start_row, start_row + 3):\n                        for y in range(start_col, start_col + 3):\n                            if board[x][y] != '.':\n                                used.add(board[x][y])\n                    # Choose from remaining digits\n                    available = [d for d in digits if d not in used]\n                    if available:\n                        board[i][j] = random.choice(available)\n    else:\n        # Generate an invalid Sudoku board\n        for i in range(9):\n            for j in range(9):\n                if random.random() < 0.3:  # 30% chance to place a digit\n                    board[i][j] = random.choice(digits)\n    \n    return {'board': board}", "io_pairs": [], "error_log": []}
{"context": "Given a polymer sequence composed of various unit types, where each unit type can be represented by a lowercase or uppercase letter, what is the minimum length of the polymer after performing a series of reactions and removing each unit type and its corresponding uppercase version?\n\nThe input and output requirements are as follows:\n\nInput:\n  `polymer` (str): A string representing the polymer sequence. Each character in the string represents a unit in the polymer.\n\nOutput:\n  `return` (int): The minimum length of the polymer after removing each unit type (a-z) and its corresponding uppercase version, and performing the reaction process.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# main function\ndef main_solution(polymer):\n    \"\"\"\n    This function takes a polymer string as input and performs a series of reactions to reduce its length.\n    It then evaluates the polymer by removing each unit type (a-z) and its corresponding uppercase version,\n    and calculates the length of the polymer after each removal. The function returns the minimum length\n    achieved after all possible removals.\n    \"\"\"\n    def react(input_list):\n        \"\"\" react polymer \"\"\"\n        for pos, unit in enumerate(input_list):\n            if pos < len(input_list)-1:\n                if unit != input_list[pos+1]:\n                    if unit == input_list[pos+1].lower():\n                        del input_list[pos]\n                        del input_list[pos]\n                    elif unit == input_list[pos+1].upper():\n                        del input_list[pos]\n                        del input_list[pos]\n        return input_list\n\n    polymer_list = list(polymer)\n    size = len(polymer_list)\n    new_size = len(polymer_list) - 1\n\n    while new_size < size:\n        size = new_size\n        react(polymer_list)\n        new_size = len(polymer_list)\n\n    results = []\n\n    for c in string.ascii_lowercase:\n        temp_polymer_list = [x for x in polymer_list if x != c and x != c.upper()]\n        size = len(temp_polymer_list)\n        new_size = len(temp_polymer_list) - 1\n        while new_size < size:\n            size = new_size\n            react(temp_polymer_list)\n            new_size = len(temp_polymer_list)\n        results.append(new_size)\n\n    return min(results)", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(50, 200)\n    chars = []\n    for _ in range(length):\n        c = random.choice(string.ascii_letters)\n        # Randomly decide to add the same character in opposite case to create potential reactions\n        if random.random() < 0.3:\n            chars.append(c)\n            chars.append(c.swapcase())\n        else:\n            chars.append(c)\n    polymer = ''.join(chars)\n    return {'polymer': polymer}", "io_pairs": [{"input": {"polymer": "LldihHZpRaKfFyPpsjWRIwWdlkorNnXxBqcCAaGXxiyiIuKlJjEDVsQyfhiNnUu"}, "output": 31}, {"input": {"polymer": "nkXAARjiiIQdDlcQrLNbIiGgxbkNDQTtmMolGoJPYeEWwsSlxkKviIQcCloOfbMtaaxEhHdDiriMYygxXnwCxXa"}, "output": 46}, {"input": {"polymer": "PuTokPKkkBTtZOoEAKDspPZNFmbBYSsSsNWFfpOoxdaHhapDdbWwUuCDdMzZMJoRrhbIiSbSsBMRtoqzuiISWtnAqZlXSsoOk"}, "output": 49}, {"input": {"polymer": "yiIlgGGRjzCcdFfTlnBeEDsecuAgpiguibvVTtWLUuNTtZQUifPpBaJPuUZscs"}, "output": 37}, {"input": {"polymer": "FMmJPESPOZHttTHhvVnNhHLsjJkKYyaTlZzRrZRQqMIJjGPpdNxQqWLuaAlMmDCXxCiVuyCcySs"}, "output": 31}, {"input": {"polymer": "UutFOpXsShHTvJjKvVTtcCKkhHbBiIqQFbvdDOQIiPbBGfFizZYylLliIWGYQqsSIYyjklLqSsjEezfWwqRdgGTjLEeHc"}, "output": 32}, {"input": {"polymer": "BzxMvSsXHBZRtTVoOEwtxXGIEcmhHXXSTpcqQrWwCyfFZqudDXxeIKlfFXEewZCxXIie"}, "output": 35}, {"input": {"polymer": "zoOIiRrlkKVLoOkFDdvLkKiorgQBLJttTLXlWcClneplKMyYXbDUdynNkKhwNhQMHhnaAX"}, "output": 34}, {"input": {"polymer": "AxXKKzWybEJUuMmFfZznlavIIfdfxZsXxXxgmyoOYyLuUeEcZziQFjKENILQnVnDdYydDYUuLxgYTQIkMmVyYdcCNIaVQdelL"}, "output": 51}, {"input": {"polymer": "TwWMUIiNnlDdgYwYCKkYHuQqQQqphYyraEEeRcOogaAuUKuaZUHKkVbNfPxrRIiTETaEkEeZGnOgiKkjPnNwrRd"}, "output": 45}], "error_log": []}
{"context": "In the field of cryptography, a prime number and its primitive root are essential components for generating secure keys. Given a specific bit length, what are the randomly generated prime number and its corresponding primitive root?\n\nThe input and output requirements are as follows:\n\nInput:\n  `bit_length` (int): The number of bits for the random prime number to be generated. It should be a positive integer.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `prime_number` (int): The randomly generated prime number with the specified bit length.\n    - `primitive_root` (int): The primitive root of the generated prime number.", "reference_code": "# import necessary packages\nfrom random import randint\nfrom math import isqrt\n\n# all class and function definitions in the code file, if any\ndef miller_rabin_test(n, k=10):\n    if n == 2 or n == 3:\n        return True\n\n    if n % 2 == 0 or n == 1:\n        return False\n\n    s = 0\n    t = n - 1\n    while t % 2 == 0:\n        s += 1\n        t //= 2\n\n    for _ in range(k):\n        a = randint(2, n - 2)\n        x = pow(a, t, n)\n        if x == 1 or x == n - 1:\n            continue\n\n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n            elif x == 1:\n                return False\n        \n        if x == n - 1:\n            continue\n        else:\n            return False\n\n    return True\n\ndef get_random_prime(n):\n    p = randint(2**n, 2**(n + 1) - 1)\n\n    while not miller_rabin_test(p):\n        p = randint(2**n, 2**(n + 1) - 1)\n\n    return p\n\ndef is_prime(n):\n    return miller_rabin_test(n)\n\ndef factorize(x):\n    if is_prime(x):\n        return {x: 1}\n\n    def div(x, p, factorization):\n        s = 0\n        while x % p == 0:\n            x //= p\n            s += 1\n        if s != 0:\n            factorization[p] = s\n\n        return x\n\n    factorization = {}\n    x = div(x, 2, factorization)\n    for i in range(3, isqrt(x) + 1, 2):\n        if is_prime(i):\n            x = div(x, i, factorization)\n            if x == 1:\n                break\n            if is_prime(x):\n                factorization[x] = 1\n                break\n\n    return factorization\n\ndef get_primitive_root(p):\n    factorization = factorize(p - 1)\n    g = randint(2, p - 1)\n\n    def is_primetive_root(g, p, factorization):       \n        for q in factorization.keys():\n            if pow(g, (p - 1)//q, p) == 1:\n                return False\n\n        return True\n\n    while not is_primetive_root(g, p, factorization):\n        g = randint(2, p - 1)\n\n    return g\n\n# main function\ndef main_solution(bit_length):\n    # Generate a random prime number with the given bit length\n    prime_number = get_random_prime(bit_length)\n    \n    # Get the primitive root of the generated prime number\n    primitive_root = get_primitive_root(prime_number)\n    \n    # Return the prime number and its primitive root\n    return {\"prime_number\": prime_number, \"primitive_root\": primitive_root}", "input_generator": "import random\n\ndef input_generator():\n    bit_length = random.choice([8, 16, 32, 64])\n    return {\"bit_length\": bit_length}", "io_pairs": [{"input": {"bit_length": 32}, "output": {"prime_number": 7329523039, "primitive_root": 4423285345}}, {"input": {"bit_length": 64}, "output": {"prime_number": 36633328777481249287, "primitive_root": 33084800074623917022}}, {"input": {"bit_length": 16}, "output": {"prime_number": 73453, "primitive_root": 3139}}, {"input": {"bit_length": 8}, "output": {"prime_number": 313, "primitive_root": 244}}], "error_log": []}
{"context": "Given a hyper-ellipsoid in a high-dimensional space, we want to generate random samples uniformly inside it and compute the variance of these samples. What is the variance matrix of the generated samples when the hyper-ellipsoid has a specified dimension and a specified number of random samples are generated?\n\nThe input and output requirements are as follows:\n\nInput:\n  `dim` (int): The dimension of the hyper-ellipsoid.\n  `N` (int): The number of random samples to generate.\n\nOutput:\n  `return` (list of lists): The variance matrix of the generated samples, represented as a list of lists (each sublist represents a row in the matrix).", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef generate_random_inball(dim, N): \n    y = np.random.exponential(scale=2.0, size=(N))\n    X = np.random.randn(dim, N)\n    denom = np.sqrt(np.sum(X**2, axis=0) + y)\n    rands_ = X / np.tile(denom, (dim, 1))\n    return rands_.T\n\ndef compute_variance(X):\n    return sum([np.outer(x, x) for x in X]) / (len(X) - 1)\n\n# main function\ndef main_solution(dim, N):\n    # Convert JSON serializable inputs to original input variables\n    dim = int(dim)\n    N = int(N)\n    \n    # Generate random samples inside a hyper-ellipsoid\n    X = generate_random_inball(dim, N)\n    \n    # Compute the variance of the generated samples\n    C = compute_variance(X)\n    \n    # Convert the output to JSON serializable format\n    variance_matrix = C.tolist()\n    \n    return variance_matrix", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    dim = random.randint(2, 10)\n    N = random.randint(100, 1000)\n    return {'dim': dim, 'N': N}", "io_pairs": [{"input": {"dim": 2, "N": 609}, "output": [[0.26717078054652804, -0.007102744000834974], [-0.007102744000834974, 0.24695527079140717]]}, {"input": {"dim": 2, "N": 821}, "output": [[0.24769241453650737, -0.00641146528151468], [-0.00641146528151468, 0.22616947360469528]]}, {"input": {"dim": 2, "N": 138}, "output": [[0.2668514631815896, 0.002303918907546045], [0.002303918907546045, 0.2490279783619653]]}, {"input": {"dim": 3, "N": 521}, "output": [[0.21148409003646648, -0.002109085378741253, 0.005666615701125694], [-0.002109085378741253, 0.18174596347101465, -0.0028787174648084285], [0.005666615701125694, -0.0028787174648084285, 0.20444678003803804]]}, {"input": {"dim": 2, "N": 517}, "output": [[0.2596738471644032, -0.0004434543631725849], [-0.0004434543631725849, 0.24836032581141562]]}, {"input": {"dim": 2, "N": 804}, "output": [[0.2711592362453277, -0.006304059661598263], [-0.006304059661598263, 0.24387548316265556]]}, {"input": {"dim": 2, "N": 312}, "output": [[0.26099633168848263, -0.015562048915875044], [-0.015562048915875044, 0.26883425424998975]]}, {"input": {"dim": 2, "N": 597}, "output": [[0.258529920267066, -0.021339007483713517], [-0.021339007483713517, 0.24876701133931609]]}, {"input": {"dim": 2, "N": 323}, "output": [[0.25322832160472364, 0.013300135380878325], [0.013300135380878325, 0.2371327171050382]]}, {"input": {"dim": 3, "N": 126}, "output": [[0.19554899278473628, -0.03248545663036899, 0.00931006955802775], [-0.03248545663036899, 0.20242531261679667, 0.006191185666446756], [0.00931006955802775, 0.006191185666446756, 0.1856834703801324]]}], "error_log": []}
{"context": "Given three eigenvalues from a diffusion tensor imaging (DTI) analysis, what is the fractional anisotropy (FA) value that quantifies the degree of anisotropy in the diffusion tensor? The eigenvalues represent the principal diffusivities along the three orthogonal axes of the diffusion ellipsoid.\n\nThe input and output requirements are as follows:\n\nInput:\n  `l1` (float): The first eigenvalue.\n  `l2` (float): The second eigenvalue.\n  `l3` (float): The third eigenvalue.\n\nOutput:\n  `return` (str): The fractional anisotropy (FA) value formatted to 2 decimal places.", "reference_code": "# import necessary packages\nfrom math import sqrt\n\n# main function\ndef main_solution(l1, l2, l3):\n    # Calculate the fractional anisotropy (FA)\n    fa = sqrt(1/2) * sqrt((l1-l2)**2 + (l1-l3)**2 + (l2-l3)**2) / sqrt(l1**2 + l2**2 + l3**2)\n    \n    # Format the FA value to 2 decimal places\n    fa_f = '{:.2f}'.format(fa)\n    \n    # Return the formatted FA value as a string\n    return fa_f", "input_generator": "import random\n\ndef input_generator():\n    # Generate three random eigenvalues, ensuring they are positive and not too large\n    l1 = random.uniform(0.1, 10.0)\n    l2 = random.uniform(0.1, 10.0)\n    l3 = random.uniform(0.1, 10.0)\n    \n    return {'l1': l1, 'l2': l2, 'l3': l3}", "io_pairs": [{"input": {"l1": 9.577679582465674, "l2": 1.6981133132528694, "l3": 0.43352600653686013}, "output": "0.88"}, {"input": {"l1": 3.168619621593832, "l2": 2.835476197122917, "l3": 7.354952702178197}, "output": "0.51"}, {"input": {"l1": 0.36500172619425986, "l2": 1.204103195303096, "l3": 7.216783364299735}, "output": "0.88"}, {"input": {"l1": 9.498189163531327, "l2": 9.002294727566715, "l3": 0.7183124897251045}, "output": "0.65"}, {"input": {"l1": 7.920790981227464, "l2": 9.220940801208059, "l3": 8.632310000353772}, "output": "0.08"}, {"input": {"l1": 3.169348866349075, "l2": 2.211116836901852, "l3": 8.280826687946858}, "output": "0.62"}, {"input": {"l1": 5.947545427667467, "l2": 0.7964528338379219, "l3": 9.477182504525146}, "output": "0.67"}, {"input": {"l1": 2.346267964593796, "l2": 6.967222135056782, "l3": 0.8155256420764395}, "output": "0.75"}, {"input": {"l1": 0.7045450269487652, "l2": 2.371577371323221, "l3": 4.904428654444463}, "output": "0.67"}, {"input": {"l1": 1.2347848698142916, "l2": 7.658926488049198, "l3": 3.355233287061428}, "output": "0.67"}], "error_log": []}
{"context": "Given a set of restrictions on 9 letters (A, B, C, D, E, F, G, H, I), how can you represent these restrictions in a comma-separated string format?\n\nThe input and output requirements are as follows:\n\nInput:\n  `restrictions` (list of str): A list of strings where each string represents a restriction in the format \"X>Y\". Each string must be a valid restriction between two different letters from the set {A, B, C, D, E, F, G, H, I}.\n\nOutput:\n  `return` (str): A comma-separated string of restrictions. Each restriction is in the format \"X>Y\".", "reference_code": "# import necessary packages\nfrom itertools import product\n\n# main function\ndef main_solution(restrictions):\n    \"\"\"\n    Given a set of restrictions on 9 letters (A, B, C, D, E, F, G, H, I), this function generates a string representation of the restrictions.\n    \n    Parameters:\n    restrictions (list of str): A list of strings where each string represents a restriction in the format \"X>Y\".\n    \n    Returns:\n    str: A comma-separated string of restrictions.\n    \"\"\"\n    # Convert the list of restrictions to a comma-separated string\n    return ', '.join(restrictions)", "input_generator": "import random\n\ndef input_generator():\n    letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']\n    restrictions = []\n    num_restrictions = random.randint(1, 10)\n    \n    for _ in range(num_restrictions):\n        x, y = random.sample(letters, 2)\n        restrictions.append(f\"{x}>{y}\")\n    \n    return {'restrictions': restrictions}", "io_pairs": [{"input": {"restrictions": ["B>D", "I>D", "C>D", "G>D", "I>B", "D>E", "E>F", "D>G", "D>A", "E>B"]}, "output": "B>D, I>D, C>D, G>D, I>B, D>E, E>F, D>G, D>A, E>B"}, {"input": {"restrictions": ["D>I", "D>F"]}, "output": "D>I, D>F"}, {"input": {"restrictions": ["F>H", "D>F", "F>I", "G>E"]}, "output": "F>H, D>F, F>I, G>E"}, {"input": {"restrictions": ["D>H", "I>C", "E>D", "H>D", "A>D"]}, "output": "D>H, I>C, E>D, H>D, A>D"}, {"input": {"restrictions": ["D>B", "A>F", "D>B", "A>F", "E>I"]}, "output": "D>B, A>F, D>B, A>F, E>I"}, {"input": {"restrictions": ["F>I", "F>A"]}, "output": "F>I, F>A"}, {"input": {"restrictions": ["G>H", "F>D", "G>I", "I>C", "E>G", "C>D", "I>E", "I>D", "A>D"]}, "output": "G>H, F>D, G>I, I>C, E>G, C>D, I>E, I>D, A>D"}, {"input": {"restrictions": ["E>D", "I>H", "H>E", "D>G", "G>E", "I>C", "H>C"]}, "output": "E>D, I>H, H>E, D>G, G>E, I>C, H>C"}, {"input": {"restrictions": ["H>F", "A>E", "D>A", "E>D", "E>G", "I>E", "D>H", "A>C", "E>I", "F>E"]}, "output": "H>F, A>E, D>A, E>D, E>G, I>E, D>H, A>C, E>I, F>E"}, {"input": {"restrictions": ["F>D", "I>E"]}, "output": "F>D, I>E"}], "error_log": []}
{"context": "Imagine you are planning a mission to the South Pole Aitken Basin and want to explore some permanently shadowed craters. Your rover can tolerate slopes up to a certain percentage. Given the interval of the terrain and the number of points to sample, what are the accessible areas within the interval where the slope is within the rover's tolerance?\n\nThe input and output requirements are as follows:\n\nInput:\n  `xLower` (float): The lower bound of the interval for differentiation.\n  `xUpper` (float): The upper bound of the interval for differentiation.\n  `n` (int): The number of points to use in the interval for differentiation.\n  `slopeTolerance` (float): The maximum slope the rover can handle.\n\nOutput:\n  `accessible_areas` (list of tuples): A list of tuples where each tuple contains the start and end positions of accessible areas within the interval.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef forwardDifference(f, x, h):\n    \"\"\"\n    A first order differentiation technique.\n    \n    Parameters\n    ----------\n    f : function to be differentiated\n    x : point of interest\n    h : step-size to use in approximation\n    \"\"\"\n    return (f(x + h) - f(x)) / h\n\ndef centralDifference(f, x, h):\n    \"\"\"\n    A second order differentiation technique.\n    \n    Also known as `symmetric difference quotient.\n    \n    Parameters\n    ----------\n    f : function to be differentiated\n    x : point of interest\n    h : step-size to use in approximation\n    \"\"\"\n    return (f(x + h) - f(x - h)) / (2.0 * h)\n\ndef derivative(formula, func, xLower, xUpper, n):  \n    \"\"\"\n    Differentiate func(x) at all points from xLower\n    to xUpper with n *equally spaced* points.\n    \n    The differentiation formula is given by \n    formula(func, x, h).\n    \"\"\"\n    h = (xUpper - xLower) / float(n)                 # Calculate the derivative step size\n    xArray = np.linspace(xLower, xUpper, n)          # Create an array of x values\n    derivArray = np.zeros(n)               # Create an empty array for the derivative values\n    \n    for index in range(1, n - 1):                   # xrange(start, stop, [step])\n        derivArray[index] = formula(func, xArray[index], h)    # Calculate the derivative for the current\n                                                               # x value using the formula passed in\n\n    return (xArray[1:-1], derivArray[1:-1])    # This returns TWO things:\n                                               # x values and the derivative values\n\n# main function\ndef main_solution(xLower, xUpper, n, slopeTolerance):\n    \"\"\"\n    Calculate the derivative of a function using numerical differentiation and determine accessible areas based on slope tolerance.\n    \n    Parameters\n    ----------\n    xLower : float\n        Lower bound of the interval.\n    xUpper : float\n        Upper bound of the interval.\n    n : int\n        Number of points to use in the interval.\n    slopeTolerance : float\n        Maximum slope the rover can handle.\n    \n    Returns\n    -------\n    accessible_areas : list of tuples\n        List of tuples containing the start and end positions of accessible areas.\n    \"\"\"\n    # Define the function to differentiate\n    func = np.sin\n    \n    # Calculate the derivative using central difference formula\n    xArray, derivArray = derivative(centralDifference, func, xLower, xUpper, n)\n    \n    # Determine accessible areas based on slope tolerance\n    reachable = np.logical_and(derivArray < slopeTolerance, derivArray > -slopeTolerance)\n    accessible_areas = []\n    start = None\n    \n    for i in range(len(reachable)):\n        if reachable[i] and start is None:\n            start = xArray[i]\n        elif not reachable[i] and start is not None:\n            accessible_areas.append((start, xArray[i]))\n            start = None\n    \n    if start is not None:\n        accessible_areas.append((start, xArray[-1]))\n    \n    return accessible_areas", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    xLower = random.uniform(-10.0, 10.0)\n    xUpper = xLower + random.uniform(1.0, 20.0)\n    n = random.randint(10, 1000)\n    slopeTolerance = random.uniform(0.1, 2.0)\n    return {\n        'xLower': xLower,\n        'xUpper': xUpper,\n        'n': n,\n        'slopeTolerance': slopeTolerance\n    }", "io_pairs": [{"input": {"xLower": -9.302556284624576, "xUpper": 7.696848370861787, "n": 692, "slopeTolerance": 0.11687042402228337}, "output": [[-7.949492238239988, -7.72808175792251], [-4.825144349315577, -4.579132704518379], [-1.6761952959114463, -1.4301836511142483], [1.4727537574926846, 1.6941642378101633], [4.597101646417096, 4.843113291214294]]}, {"input": {"xLower": -4.045247733193376, "xUpper": 2.636847729519028, "n": 236, "slopeTolerance": 1.884656359612232}, "output": [[-4.016813284415877, 2.6084132807415283]]}, {"input": {"xLower": -5.49478656882701, "xUpper": 8.214796929811257, "n": 607, "slopeTolerance": 1.0050286111206417}, "output": [[-5.4721634937467485, 8.192173854730996]]}, {"input": {"xLower": -4.824618337800793, "xUpper": 1.466028281479275, "n": 252, "slopeTolerance": 1.4619408439636938}, "output": [[-4.799556000672187, 1.440965944350669]]}, {"input": {"xLower": 9.933702029114329, "xUpper": 15.3062899872999, "n": 342, "slopeTolerance": 1.7231518223061246}, "output": [[9.949457419021032, 15.290534597393197]]}, {"input": {"xLower": -0.3175512906448841, "xUpper": 13.004014339539564, "n": 120, "slopeTolerance": 1.2864552338746231}, "output": [[-0.20560536097946855, 12.892068409874149]]}, {"input": {"xLower": -1.658755768361253, "xUpper": 0.4608924269853443, "n": 777, "slopeTolerance": 1.5659970699973191}, "output": [[-1.6560242629548785, 0.4581609215789695]]}, {"input": {"xLower": 5.091070221572272, "xUpper": 24.544653854456115, "n": 270, "slopeTolerance": 1.3524958152473638}, "output": [[5.163388376341357, 24.47233569968703]]}, {"input": {"xLower": 3.2231513562424148, "xUpper": 21.397540237951613, "n": 867, "slopeTolerance": 1.5516497448083852}, "output": [[3.2441379484845734, 21.376553645709453]]}, {"input": {"xLower": -2.9791619362423365, "xUpper": 3.919621621208023, "n": 712, "slopeTolerance": 0.19275013715627726}, "output": [[-1.7565926982131588, -1.3684754797911975], [1.3774538405441774, 1.765571058966139]]}], "error_log": []}
{"context": "Given an angle in radians, how can we approximate the sine of this angle using a Taylor series expansion with a specified number of terms?\n\nThe input and output requirements are as follows:\n\nInput:\n  `angle_radians` (float): The angle in radians for which the sine is to be calculated.\n  `accuracy` (int): The number of terms to use in the Taylor series expansion.\n\nOutput:\n  `return` (float): The calculated sine value of the given angle.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(angle_radians, accuracy):\n    \"\"\"\n    Calculate the sine of an angle in radians using the Taylor series expansion.\n\n    Parameters:\n    angle_radians (float): The angle in radians for which the sine is to be calculated.\n    accuracy (int): The number of terms to use in the Taylor series expansion.\n\n    Returns:\n    float: The calculated sine value of the given angle.\n    \"\"\"\n    multiplier = 1\n    result = 0\n    \n    for i in range(1, accuracy, 2):\n        result += multiplier * math.pow(angle_radians, i) / math.factorial(i)\n        multiplier *= -1\n    \n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    angle_radians = random.uniform(-2 * math.pi, 2 * math.pi)\n    accuracy = random.randint(5, 20)\n    return {'angle_radians': angle_radians, 'accuracy': accuracy}", "io_pairs": [{"input": {"angle_radians": 1.9685662603844758, "accuracy": 13}, "output": 0.9219260805144778}, {"input": {"angle_radians": 2.361831974323385, "accuracy": 13}, "output": 0.703098132498328}, {"input": {"angle_radians": -3.2416373164499332, "accuracy": 7}, "output": -0.5472499684081185}, {"input": {"angle_radians": 4.533082703353797, "accuracy": 14}, "output": -0.9789866449077946}, {"input": {"angle_radians": -1.353095198206609, "accuracy": 15}, "output": -0.9763965520862398}, {"input": {"angle_radians": -4.251098682991926, "accuracy": 17}, "output": 0.8956080127970504}, {"input": {"angle_radians": 3.6861039282561876, "accuracy": 7}, "output": 1.0096597236947646}, {"input": {"angle_radians": -4.701569419361434, "accuracy": 17}, "output": 1.0006486848707596}, {"input": {"angle_radians": 2.9304018132890963, "accuracy": 5}, "output": -1.2636160200378228}, {"input": {"angle_radians": -1.4351652859944872, "accuracy": 14}, "output": -0.9908162021092579}], "error_log": []}
{"context": "A mother and her child realized that the two digits that make up the child's age when reversed result in the mother's age. They wondered how often this has happened over the years. Given that this phenomenon has occurred 8 times so far, how old is the child now, considering the age difference between the mother and the child?\n\nThe input and output requirements are as follows:\n\nInput:\n  `diff` (int): The age difference between the mother and the child. It should be an integer between 15 and 45.\n\nOutput:\n  `return` (list of strings): A list of strings representing the ages of the child when the ages are reversible with the mother's age. Each string is a two-digit number (e.g., \"37\"). If no such ages are found, the list will be empty.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_palindrome(x, y):\n    return x[::-1] == y\n\n# main function\ndef main_solution(diff):\n    ages = [str(i).zfill(2) for i in range(1, 100)]  # moms max age @ 99\n    palindromes = []\n    for i in range(0, 99):\n        if (i + diff) >= 99:  # IndexErr in ages fix\n            pass\n        elif is_palindrome(ages[i], ages[i + diff]):\n            palindromes.append(ages[i])\n    if len(palindromes) == 8:\n        return palindromes\n    else:\n        return []", "input_generator": "import random\n\ndef input_generator():\n    diff = random.randint(1, 30)\n    return {'diff': diff}", "io_pairs": [{"input": {"diff": 1}, "output": []}, {"input": {"diff": 8}, "output": []}, {"input": {"diff": 29}, "output": []}, {"input": {"diff": 15}, "output": []}, {"input": {"diff": 22}, "output": []}, {"input": {"diff": 12}, "output": []}, {"input": {"diff": 17}, "output": []}, {"input": {"diff": 13}, "output": []}, {"input": {"diff": 19}, "output": []}, {"input": {"diff": 20}, "output": []}], "error_log": []}
{"context": "Given a function \\( f(x) = x^6 + 77(x-2)^2 \\), we want to find the minimum value of this function using the gradient descent algorithm. What are the final values of \\( x \\) and \\( f(x) \\) after the algorithm stops, and how many iterations did it take?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_x` (float): The initial value of x for the gradient descent algorithm.\n  `initial_step` (float): The initial step size for the gradient descent algorithm.\n  `epsilon` (float): The tolerance level for the gradient descent algorithm to stop.\n  `max_iterations` (int): The maximum number of iterations allowed for the gradient descent algorithm.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `final_x` (float): The final value of x after the gradient descent algorithm stops.\n    - `final_y` (float): The final value of y (f(x)) after the gradient descent algorithm stops.\n    - `iterations` (int): The number of iterations taken by the gradient descent algorithm.", "reference_code": "# import necessary packages\nfrom scipy.misc import derivative\nimport math\n\n# main function\ndef main_solution(initial_x, initial_step, epsilon, max_iterations):\n    # Convert JSON serializable inputs to original input variables\n    xn = initial_x\n    step = initial_step\n    eps = epsilon\n    \n    def f(x):\n        return x**(6) + 77*(x-2)**(2)\n    \n    yn = f(xn)\n    Y = 0.0\n    \n    for i in range(max_iterations):\n        st = step * derivative(f, xn)\n        if abs(st) < eps:\n            break\n        xn = xn - step\n        yn = f(xn)\n        Y = yn\n    \n    # Convert output to JSON serializable\n    return {\"final_x\": xn, \"final_y\": Y, \"iterations\": i}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    initial_x = random.uniform(-10.0, 10.0)\n    initial_step = random.uniform(0.001, 0.1)\n    epsilon = 10 ** random.uniform(-6, -3)\n    max_iterations = random.randint(50, 200)\n    return {\n        \"initial_x\": initial_x,\n        \"initial_step\": initial_step,\n        \"epsilon\": epsilon,\n        \"max_iterations\": max_iterations\n    }", "io_pairs": [{"input": {"initial_x": 5.402852001009574, "initial_step": 0.09448395030052766, "epsilon": 1.2741779796578696e-06, "max_iterations": 71}, "output": {"final_x": -1.3055084703278839, "final_y": 846.2825727568007, "iterations": 70}}, {"input": {"initial_x": -8.594157468458537, "initial_step": 0.08002419564957082, "epsilon": 2.291551177702905e-05, "max_iterations": 166}, "output": {"final_x": -21.878173946287337, "final_y": 109708494.48832877, "iterations": 165}}, {"input": {"initial_x": 2.509258403133787, "initial_step": 0.08297287105269326, "epsilon": 9.816815838350346e-06, "max_iterations": 182}, "output": {"final_x": -12.591804128456355, "final_y": 4002307.3585931524, "iterations": 181}}, {"input": {"initial_x": -9.94352234088035, "initial_step": 0.06324939446846464, "epsilon": 5.988093608970419e-05, "max_iterations": 60}, "output": {"final_x": -13.73848600898819, "final_y": 6743158.824630617, "iterations": 59}}, {"input": {"initial_x": 8.310820670800702, "initial_step": 0.04091561430394894, "epsilon": 0.0001351841320666178, "max_iterations": 149}, "output": {"final_x": 2.2143941395122955, "final_y": 121.44356503842128, "iterations": 148}}, {"input": {"initial_x": -6.602898005493851, "initial_step": 0.05360740333091257, "epsilon": 4.452918668368774e-06, "max_iterations": 88}, "output": {"final_x": -11.320349498614178, "final_y": 2118211.094502934, "iterations": 87}}, {"input": {"initial_x": -9.59148517269143, "initial_step": 0.06470494302897613, "epsilon": 0.00017579205172104008, "max_iterations": 181}, "output": {"final_x": -21.30307986093604, "final_y": 93507967.63949898, "iterations": 180}}, {"input": {"initial_x": -4.358138217348515, "initial_step": 0.08895302551112676, "epsilon": 1.483985995447017e-06, "max_iterations": 168}, "output": {"final_x": -19.302246503217898, "final_y": 51753587.37044062, "iterations": 167}}, {"input": {"initial_x": -0.33361135443851, "initial_step": 0.04274523241709779, "epsilon": 0.0001676537648710696, "max_iterations": 180}, "output": {"final_x": -8.027753189516128, "final_y": 275390.8412880551, "iterations": 179}}, {"input": {"initial_x": -2.3409535295220056, "initial_step": 0.0623676681229148, "epsilon": 2.1652363238492753e-05, "max_iterations": 125}, "output": {"final_x": -10.136912044886346, "final_y": 1096353.277978098, "iterations": 124}}], "error_log": []}
{"context": "Given an initial condition for a differential equation, how can we approximate the value of the solution function at a specified point using the Euler method? Specifically, what is the value of y at x_limit given the initial values x0 and y0, and the step size h?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x0` (float): The initial value of x.\n  `y0` (float): The initial value of y at x0.\n  `x_limit` (float): The target value of x at which to evaluate y.\n  `h` (float): The step size for the Euler method.\n\nOutput:\n  `return` (float): The value of y evaluated at x_limit using the Euler method.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef y_prime(x, y):\n    return 2 * x * y\n\ndef metodo_euler(function_f, x0, y0, x_limit, h):\n    y = 0\n    limit = (int)((x_limit - x0) / h)\n    for i in range(limit):\n        y = y0 + h * (function_f(x0, y0))\n        y0 = y\n        x0 += h\n    return y\n\n# main function\ndef main_solution(x0, y0, x_limit, h):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = metodo_euler(y_prime, x0, y0, x_limit, h)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    x0 = random.uniform(-10, 10)\n    y0 = random.uniform(-10, 10)\n    x_limit = x0 + random.uniform(0.1, 5)\n    h = random.uniform(0.01, 0.5)\n    return {'x0': x0, 'y0': y0, 'x_limit': x_limit, 'h': h}", "io_pairs": [{"input": {"x0": -4.362091615825219, "y0": -1.3510627551645271, "x_limit": -1.7296597077860012, "h": 0.023577065063291984}, "output": -3.653873541416138e-08}, {"input": {"x0": 6.800979143434105, "y0": -7.050885372899655, "x_limit": 8.297328399734518, "h": 0.4097687338338164}, "output": -2320.343364943232}, {"input": {"x0": 8.337090772506862, "y0": -4.104524238122207, "x_limit": 11.09181840306413, "h": 0.39043786398819946}, "output": -12139767.402281992}, {"input": {"x0": 4.19465647648231, "y0": -7.488686861352212, "x_limit": 8.324299962723224, "h": 0.2249744050042702}, "output": -133125329372.00113}, {"input": {"x0": 3.670312291683125, "y0": -9.11700073282365, "x_limit": 8.651269063182554, "h": 0.3762301176343042}, "output": -27146726716.39117}, {"input": {"x0": -5.262701350768479, "y0": 5.226664310618451, "x_limit": -3.4963012947089043, "h": 0.11106643790263909}, "output": -1.4625795541253635e-17}, {"input": {"x0": -7.890009970506755, "y0": -1.496018428473489, "x_limit": -2.9407241771214077, "h": 0.2272183930987138}, "output": 2029.78511381127}, {"input": {"x0": 6.3050742766566685, "y0": 3.320678713733754, "x_limit": 9.736419558137557, "h": 0.32515453641433006}, "output": 207963190.22063014}, {"input": {"x0": -7.093106051559522, "y0": -2.6168872579851516, "x_limit": -3.499603339180919, "h": 0.2635668106165774}, "output": 6789.752639302549}, {"input": {"x0": 6.89370963856474, "y0": -1.5964038936322424, "x_limit": 11.845688782168779, "h": 0.4622859418923478}, "output": -7049464796.3005495}], "error_log": []}
{"context": "Given a quadratic formula of the form \\( n^2 + an + b \\), where \\( |a| < 1000 \\) and \\( |b| \\leq 1000 \\), what is the product of the coefficients \\( a \\) and \\( b \\) that produces the maximum number of consecutive prime numbers starting from \\( n = 0 \\)? Additionally, how many consecutive primes can be produced with these coefficients?\n\nThe input and output requirements are as follows:\n\nInput:\n  `aLimit` (int): The absolute value limit for the coefficient 'a' in the quadratic formula.\n  `bLimit` (int): The absolute value limit for the coefficient 'b' in the quadratic formula.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `product_of_coefficients` (int): The product of the coefficients 'a' and 'b' that produce the maximum number of consecutive primes.\n    - `max_consecutive_primes` (int): The maximum number of consecutive primes produced by the quadratic formula with the optimal coefficients.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef isPrime(number):\n    \"\"\"Simple method to check if a number is prime\"\"\"\n    from math import sqrt\n    if number < 2:\n        return False\n    if number % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(number)) + 1, 2):\n        if number % i == 0:\n            return False\n    return True\n\ndef iterateFunction(a, b):\n    \"\"\"Iterates over the function and counts how many consecutive primes it produces\"\"\"\n    f = lambda x: x**2 + a*x + b\n\n    counter = 0\n    while True:\n        if not isPrime(f(counter)):\n            return counter\n        else:\n            counter += 1\n\n    return counter\n\n# main function\ndef main_solution(aLimit, bLimit):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    nMax = 0\n    aBest = 0\n    bBest = 0\n    for a in range(-aLimit + 1, aLimit):\n        for b in range(-bLimit, bLimit + 1):\n            cons = iterateFunction(a, b)\n            if cons > nMax:\n                nMax = cons\n                aBest = a\n                bBest = b\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"product_of_coefficients\": aBest * bBest, \"max_consecutive_primes\": nMax}", "input_generator": "import random\n\ndef input_generator():\n    aLimit = random.randint(10, 100)\n    bLimit = random.randint(10, 100)\n    return {\"aLimit\": aLimit, \"bLimit\": bLimit}", "io_pairs": [{"input": {"aLimit": 63, "bLimit": 66}, "output": {"product_of_coefficients": -549, "max_consecutive_primes": 45}}, {"input": {"aLimit": 85, "bLimit": 65}, "output": {"product_of_coefficients": -549, "max_consecutive_primes": 45}}, {"input": {"aLimit": 77, "bLimit": 27}, "output": {"product_of_coefficients": -115, "max_consecutive_primes": 19}}, {"input": {"aLimit": 60, "bLimit": 65}, "output": {"product_of_coefficients": -549, "max_consecutive_primes": 45}}, {"input": {"aLimit": 14, "bLimit": 80}, "output": {"product_of_coefficients": -781, "max_consecutive_primes": 46}}, {"input": {"aLimit": 70, "bLimit": 47}, "output": {"product_of_coefficients": -235, "max_consecutive_primes": 43}}, {"input": {"aLimit": 51, "bLimit": 36}, "output": {"product_of_coefficients": -203, "max_consecutive_primes": 20}}, {"input": {"aLimit": 36, "bLimit": 38}, "output": {"product_of_coefficients": -333, "max_consecutive_primes": 21}}, {"input": {"aLimit": 20, "bLimit": 77}, "output": {"product_of_coefficients": -781, "max_consecutive_primes": 46}}, {"input": {"aLimit": 49, "bLimit": 57}, "output": {"product_of_coefficients": -371, "max_consecutive_primes": 44}}], "error_log": []}
{"context": "Given a non-negative integer `n`, what is the factorial of `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): A non-negative integer for which the factorial is to be computed.\n\nOutput:\n  `return` (int): The factorial of the given integer `n`.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    Computes the factorial of a given non-negative integer `n`.\n    \n    Parameters:\n    n (int): A non-negative integer for which the factorial is to be computed.\n    \n    Returns:\n    int: The factorial of the given integer `n`.\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * main_solution(n - 1)", "input_generator": "import random\n\ndef input_generator():\n    return {'n': random.randint(0, 20)}", "io_pairs": [{"input": {"n": 18}, "output": 6402373705728000}, {"input": {"n": 9}, "output": 362880}, {"input": {"n": 17}, "output": 355687428096000}, {"input": {"n": 6}, "output": 720}, {"input": {"n": 3}, "output": 6}, {"input": {"n": 13}, "output": 6227020800}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 0}, "output": 1}, {"input": {"n": 14}, "output": 87178291200}, {"input": {"n": 11}, "output": 39916800}], "error_log": []}
{"context": "Given a matrix representing a dataset, how can we determine the largest and lowest eigen vectors for dimensionality reduction and noise filtering? Specifically, what are the largest and lowest eigen vectors for the provided matrix, considering the specified number of vectors to return?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_data` (list of lists of floats): A 2D list representing the matrix for which we want to compute the eigen vectors.\n  `n_largest` (int, optional): The number of largest eigen vectors to return. If None, returns all in decreasing order.\n  `n_lowest` (int, optional): The number of lowest eigen vectors to return. If None, returns all in increasing order.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `largest_eigen_vectors` (list of lists of floats): The n largest eigen vectors of the input matrix.\n    - `lowest_eigen_vectors` (list of lists of floats): The n lowest eigen vectors of the input matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef get_largest_eigen_vectors(matrix, n=None):\n    \"\"\"\n    Computes the eigen vectors of 'matrix' and returns the n largest ones.\n    If n is set to None, then return them all in decreasing order.\n    \"\"\"\n    _, n_features = matrix.shape\n    if n is None:\n        n = n_features\n\n    assert n > 0, 'Need to select at least one eigen vector.'\n\n    eigen_values, eigen_vectors = np.linalg.eig(matrix)\n    idx = eigen_values.argsort()[::-1] # ordering the eigen values in decreasing order\n    ordered_eigen_vectors = eigen_vectors[:,idx] # ordering the eigen vectors\n    eigen_vectors = ordered_eigen_vectors[:,range(n)]\n\n    return eigen_vectors\n\ndef get_lowest_eigen_vectors(matrix, n=None):\n    \"\"\"\n    Computes the eigen vectors of 'matrix' and returns the n lowest ones.\n    If n is set to None, then return them all in increasing order.\n    \"\"\"\n    _, n_features = matrix.shape\n    if n is None:\n        n = n_features\n\n    assert n > 0, 'Need to select at least one eigen vector.'\n\n    eigen_values, eigen_vectors = np.linalg.eig(matrix)\n    idx = eigen_values.argsort() # ordering the eigen values in decreasing order\n    ordered_eigen_vectors = eigen_vectors[:,idx] # ordering the eigen vectors\n    eigen_vectors = ordered_eigen_vectors[:,range(n)]\n\n    return eigen_vectors\n\ndef as_column_vect(vector):\n    \"\"\"\n    Takes a row or a columns vector and makes sure it returns a column vector.\n    \"\"\"\n    try:\n        nrow, ncol = vector.shape\n        assert nrow == 1 or ncol == 1, 'This is not a vector'\n    except ValueError: # case where we have an array instead of a matrix.\n        vector = np.matrix(vector)\n        nrow, ncol = vector.shape\n\n    if ncol == 1:\n        return vector\n    return vector.T\n\ndef whiten_data(data):\n    \"\"\"\n    Returns a transformed version of 'data' such that its covariance matrix\n    is equal to the identity.\n    The data is assumed to be shaped such that:\n    rows: the features/variables\n    columns: the individuals\n    \"\"\"\n    covariance_matrix = data * data.T\n    eig_values, eig_vectors = np.linalg.eig(covariance_matrix)\n    eig_values = np.abs(eig_values) # some values are so close to 0 that they are\n                                    # estimated as negative\n    D_m12 = np.diag(1. / np.sqrt(eig_values)) # D_m12 == D^(-1/2)\n    whitened_data = (eig_vectors * D_m12 * eig_vectors.T) * data\n    return whitened_data\n\ndef center_data(data):\n    \"\"\"\n    Returns a transformed version of 'data' such that the column-vector of its\n    mean is null.\n    The data is assumed to be shaped such that:\n    rows: the features/variables\n    columns: the individuals\n    \"\"\"\n    return data - data.mean(axis=1)\n\ndef normalize_data(data):\n    \"\"\"\n    Center the datapoints and whiten them.\n    \"\"\"\n    centered_data = center_data(data)\n    whitened_centered_data = whiten_data(centered_data)\n    return whitened_centered_data\n\ndef filter_low_values(values, threshold=1.e-11):\n    \"\"\"\n    Filter low and negative values of the array 'values'.\n    If a value is found to be below the threshold: normalize it by 0\n    \"\"\"\n    return np.array([v if v > threshold else 0 for v in values])\n\n# main function\ndef main_solution(matrix_data, n_largest=None, n_lowest=None):\n    # Convert JSON serializable inputs to original input variables\n    matrix_data = np.array(matrix_data)\n\n    # Get the largest eigen vectors\n    largest_eigen_vectors = get_largest_eigen_vectors(matrix_data, n_largest)\n\n    # Get the lowest eigen vectors\n    lowest_eigen_vectors = get_lowest_eigen_vectors(matrix_data, n_lowest)\n\n    # Convert the outputs to JSON serializable format\n    largest_eigen_vectors = largest_eigen_vectors.tolist()\n    lowest_eigen_vectors = lowest_eigen_vectors.tolist()\n\n    return {\"largest_eigen_vectors\": largest_eigen_vectors, \"lowest_eigen_vectors\": lowest_eigen_vectors}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the size of the square matrix (between 2x2 and 10x10)\n    size = random.randint(2, 10)\n    \n    # Generate a random symmetric matrix (to ensure real eigenvalues)\n    random_matrix = np.random.rand(size, size)\n    matrix_data = (random_matrix + random_matrix.T) / 2  # Make it symmetric\n    \n    # Randomly decide whether to include n_largest and n_lowest\n    n_largest = random.choice([None, random.randint(1, size)])\n    n_lowest = random.choice([None, random.randint(1, size)])\n    \n    return {\n        \"matrix_data\": matrix_data.tolist(),\n        \"n_largest\": n_largest,\n        \"n_lowest\": n_lowest\n    }", "io_pairs": [{"input": {"matrix_data": [[0.07066821013495717, 0.6986191665166241], [0.6986191665166241, 0.9200419711085503]], "n_largest": null, "n_lowest": 2}, "output": {"largest_eigen_vectors": [[-0.4901798326053109, -0.8716213235729318], [-0.8716213235729318, 0.4901798326053109]], "lowest_eigen_vectors": [[-0.8716213235729318, -0.4901798326053109], [0.4901798326053109, -0.8716213235729318]]}}, {"input": {"matrix_data": [[0.9913594641027103, 0.400274043939607], [0.400274043939607, 0.14904017393347835]], "n_largest": null, "n_lowest": 2}, "output": {"largest_eigen_vectors": [[0.928668743562119, -0.37091018418311916], [0.37091018418311916, 0.928668743562119]], "lowest_eigen_vectors": [[-0.37091018418311916, 0.928668743562119], [0.928668743562119, 0.37091018418311916]]}}, {"input": {"matrix_data": [[0.584979398860884, 0.5230135672865521], [0.5230135672865521, 0.23099172687228908]], "n_largest": null, "n_lowest": null}, "output": {"largest_eigen_vectors": [[0.8125742109860803, -0.5828577456295396], [0.5828577456295396, 0.8125742109860803]], "lowest_eigen_vectors": [[-0.5828577456295396, 0.8125742109860803], [0.8125742109860803, 0.5828577456295396]]}}, {"input": {"matrix_data": [[0.23455304326984716, 0.23033006082430107], [0.23033006082430107, 0.45433706153442477]], "n_largest": null, "n_lowest": null}, "output": {"largest_eigen_vectors": [[-0.53356934070175, -0.8457563234543978], [-0.8457563234543978, 0.53356934070175]], "lowest_eigen_vectors": [[-0.8457563234543978, -0.53356934070175], [0.53356934070175, -0.8457563234543978]]}}, {"input": {"matrix_data": [[0.9990053598133819, 0.35714359799753526], [0.35714359799753526, 0.3293559496123255]], "n_largest": null, "n_lowest": 1}, "output": {"largest_eigen_vectors": [[0.9175903050730053, -0.39752739784325436], [0.39752739784325436, 0.9175903050730053]], "lowest_eigen_vectors": [[-0.39752739784325436], [0.9175903050730053]]}}, {"input": {"matrix_data": [[0.7096007868535431, 0.6383216391982016], [0.6383216391982016, 0.9186056857133348]], "n_largest": 1, "n_lowest": null}, "output": {"largest_eigen_vectors": [[-0.6474706254446809], [-0.7620904074886875]], "lowest_eigen_vectors": [[-0.7620904074886875, -0.6474706254446809], [0.6474706254446809, -0.7620904074886875]]}}, {"input": {"matrix_data": [[0.5897973562287356, 0.41470469064120574], [0.41470469064120574, 0.8351232057697868]], "n_largest": 1, "n_lowest": 2}, "output": {"largest_eigen_vectors": [[-0.5984828725551069], [-0.8011356010427871]], "lowest_eigen_vectors": [[-0.8011356010427871, -0.5984828725551069], [0.5984828725551069, -0.8011356010427871]]}}, {"input": {"matrix_data": [[0.5275617721932963, 0.24435804776881143], [0.24435804776881143, 0.6427134611618811]], "n_largest": null, "n_lowest": 2}, "output": {"largest_eigen_vectors": [[-0.6207492895868605, -0.7840091322665879], [-0.7840091322665879, 0.6207492895868605]], "lowest_eigen_vectors": [[-0.7840091322665879, -0.6207492895868605], [0.6207492895868605, -0.7840091322665879]]}}, {"input": {"matrix_data": [[0.01913801316714281, 0.6797657112319954], [0.6797657112319954, 0.1721613772370184]], "n_largest": null, "n_lowest": null}, "output": {"largest_eigen_vectors": [[-0.6663896433356287, -0.7456036770664517], [-0.7456036770664517, 0.6663896433356287]], "lowest_eigen_vectors": [[-0.7456036770664517, -0.6663896433356287], [0.6663896433356287, -0.7456036770664517]]}}, {"input": {"matrix_data": [[0.8062453329238727, 0.6499173484509818], [0.6499173484509818, 0.22233391493799748]], "n_largest": null, "n_lowest": 1}, "output": {"largest_eigen_vectors": [[0.8395751044999961, -0.5432436321797256], [0.5432436321797256, 0.8395751044999961]], "lowest_eigen_vectors": [[-0.5432436321797256], [0.8395751044999961]]}}], "error_log": []}
{"context": "In a classic game show scenario, contestants are presented with three doors, behind one of which is a prize. After choosing a door, the host opens one of the other two doors to reveal a non-prize. The contestant is then given the option to switch their choice to the remaining unopened door. Given a certain number of iterations, what are the final win percentages for both the strategy of sticking with the original choice and the strategy of switching the choice?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numIterations` (int): The number of iterations to run the Monte Hall simulation. It should be a positive integer.\n\nOutput:\n  `return` (dict): A dictionary containing the final scores for both the normal and switch strategies. The keys are:\n    - `finalScoreNormal` (float): The percentage of wins when the contestant does not switch doors.\n    - `finalScoreSwitch` (float): The percentage of wins when the contestant switches doors.", "reference_code": "# import necessary packages\nfrom random import randint\n\n# all class and function definitions in the code file, if any\nclass MonteHall(object):\n    def __init__(self, numIterations):\n        self.GoatDoor = 0\n        self.WinningDoor = 1\n        self.OpenDoor = 2\n        self.numIterations = numIterations\n\n    def setWinningDoor(self):\n        doorValues = [self.GoatDoor] * 3\n        randomWinningDoor = randint(0,2)\n        doorValues[randomWinningDoor] = self.WinningDoor\n        return doorValues\n\n    def chooseDoor(self):\n        return randint(0,2)\n\n    def openNonWinningDoor(self, doorValues, chosenDoor):\n        randomDoor = randint(0, 2)\n        done = False\n        while not done:\n            if randomDoor != chosenDoor and doorValues[randomDoor] == self.GoatDoor:\n                done = True\n            else:\n                randomDoor = randint(0, 2)\n        return randomDoor\n\n    def doSwitch(self, chosenDoor, openedDoor):\n        available = True\n        unavailable = False\n        doors = [available] * 3\n        doors[chosenDoor] = unavailable\n        doors[openedDoor] = unavailable\n        for i in range(0, 3):\n            if doors[i]:\n                return i\n\n    def isCorrect(self, doorValues, chosenDoor):\n        if doorValues[chosenDoor] == self.WinningDoor:\n            return True\n        else:\n            return False\n\n    def doExperimentNormal(self):\n        numCorrect = 0\n        for i in range(0, self.numIterations):\n            doorValues = self.setWinningDoor()\n            chosenDoor = self.chooseDoor()\n            if self.isCorrect(doorValues, chosenDoor):\n                numCorrect += 1\n        finalScore = (float(numCorrect) / float(self.numIterations)) * 100\n        return finalScore\n\n    def doExperimentSwitch(self):\n        numCorrect = 0\n        for i in range(0, self.numIterations):\n            doorValues = self.setWinningDoor()\n            chosenDoor = self.chooseDoor()\n            openDoor = self.openNonWinningDoor(doorValues, chosenDoor)\n            switchDoor = self.doSwitch(chosenDoor, openDoor)\n            if self.isCorrect(doorValues, switchDoor):\n                numCorrect += 1\n        finalScore = (float(numCorrect) / float(self.numIterations)) * 100\n        return finalScore\n\n# main function\ndef main_solution(numIterations):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    monte_hall = MonteHall(numIterations)\n    finalScoreNormal = monte_hall.doExperimentNormal()\n    finalScoreSwitch = monte_hall.doExperimentSwitch()\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"finalScoreNormal\": finalScoreNormal, \"finalScoreSwitch\": finalScoreSwitch}", "input_generator": "import random\n\ndef input_generator():\n    numIterations = random.randint(100, 10000)\n    return {\"numIterations\": numIterations}", "io_pairs": [{"input": {"numIterations": 9199}, "output": {"finalScoreNormal": 33.27535601695836, "finalScoreSwitch": 66.39852157843244}}, {"input": {"numIterations": 4854}, "output": {"finalScoreNormal": 34.19859909353111, "finalScoreSwitch": 66.66666666666666}}, {"input": {"numIterations": 3265}, "output": {"finalScoreNormal": 33.56814701378254, "finalScoreSwitch": 66.52373660030628}}, {"input": {"numIterations": 9871}, "output": {"finalScoreNormal": 33.62374632762638, "finalScoreSwitch": 66.96383345152466}}, {"input": {"numIterations": 2454}, "output": {"finalScoreNormal": 32.76283618581907, "finalScoreSwitch": 65.4441727791361}}, {"input": {"numIterations": 7410}, "output": {"finalScoreNormal": 32.61808367071525, "finalScoreSwitch": 66.66666666666666}}, {"input": {"numIterations": 6331}, "output": {"finalScoreNormal": 33.12272942663086, "finalScoreSwitch": 67.74601168851683}}, {"input": {"numIterations": 2360}, "output": {"finalScoreNormal": 33.47457627118644, "finalScoreSwitch": 66.35593220338983}}, {"input": {"numIterations": 7306}, "output": {"finalScoreNormal": 33.78045442102381, "finalScoreSwitch": 66.698603887216}}, {"input": {"numIterations": 5437}, "output": {"finalScoreNormal": 34.37557476549568, "finalScoreSwitch": 65.20139782968549}}], "error_log": []}
{"context": "A frog can jump up to `n` steps in a single leap. Each time, it can choose to jump any number of steps from 1 to `n`. How many different ways can the frog jump exactly `n` steps?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of steps the frog needs to jump. It should be a positive integer.\n\nOutput:\n  `return` (int): The total number of ways the frog can jump `n` steps.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def biantai(self, n):\n        result = 1\n        if n >= 2:\n            for i in range(n - 1):\n                result = 2 * result\n        return result\n\n# main function\ndef main_solution(n):\n    # Convert JSON serializable input to the original input variable\n    n = int(n)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    s = Solution()\n    result = s.biantai(n)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    return {'n': random.randint(0, 20)}", "io_pairs": [{"input": {"n": 5}, "output": 16}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 15}, "output": 16384}, {"input": {"n": 6}, "output": 32}, {"input": {"n": 11}, "output": 1024}, {"input": {"n": 14}, "output": 8192}, {"input": {"n": 2}, "output": 2}, {"input": {"n": 16}, "output": 32768}, {"input": {"n": 4}, "output": 8}, {"input": {"n": 10}, "output": 512}], "error_log": []}
{"context": "Given a string of characters, what are all the possible unique permutations of the characters in the string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `s` (str): A string of characters with a length between 1 and 8.\n\nOutput:\n  `return` (List[str]): A list of strings where each string is a unique permutation of the input string `s`.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def permutation(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        self.res = []\n        n = len(s)\n\n        def backtrack(s, path):\n            if not s:\n                self.res.append(path)\n            seen = set()\n            for i in range(len(s)):\n                if s[i] in seen: continue\n                seen.add(s[i])\n                backtrack(s[:i]+s[i+1:], path + s[i])\n\n        backtrack(s, \"\")\n        return self.res\n\n# main function\ndef main_solution(s):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.permutation(s)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 6)\n    chars = random.choices(string.ascii_letters, k=length)\n    s = ''.join(chars)\n    return {'s': s}", "io_pairs": [{"input": {"s": "CHR"}, "output": ["CHR", "CRH", "HCR", "HRC", "RCH", "RHC"]}, {"input": {"s": "ao"}, "output": ["ao", "oa"]}, {"input": {"s": "kSE"}, "output": ["kSE", "kES", "SkE", "SEk", "EkS", "ESk"]}, {"input": {"s": "hq"}, "output": ["hq", "qh"]}, {"input": {"s": "T"}, "output": ["T"]}, {"input": {"s": "P"}, "output": ["P"]}, {"input": {"s": "Gpu"}, "output": ["Gpu", "Gup", "pGu", "puG", "uGp", "upG"]}, {"input": {"s": "UUft"}, "output": ["UUft", "UUtf", "UfUt", "UftU", "UtUf", "UtfU", "fUUt", "fUtU", "ftUU", "tUUf", "tUfU", "tfUU"]}, {"input": {"s": "sZ"}, "output": ["sZ", "Zs"]}, {"input": {"s": "fw"}, "output": ["fw", "wf"]}], "error_log": []}
{"context": "Given an ant that starts from the center of a square grid and moves randomly, how many steps on average will it take for the ant to collect all seeds from the lower row and drop them in the upper row? The grid size and the number of seeds are specified, and the ant can only carry one seed at a time.\n\nThe input and output requirements are as follows:\n\nInput:\n  `grid_size` (int): The size of the grid (grid_size x grid_size). Must be an odd number to ensure a central starting point.\n  `num_seeds` (int): The number of seeds placed on the lower row of the grid. Must be less than or equal to grid_size.\n  `num_simulations` (int): The number of simulations to run to calculate the average number of steps.\n\nOutput:\n  `return` (float): The average number of steps taken until all seeds are dropped in the top row, rounded to 6 decimal places.", "reference_code": "# import necessary packages\nimport random\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef simulate_ant_walk(grid_size, num_seeds):\n    \"\"\"\n    Simulates the ant's walk on a grid and returns the number of steps taken until all seeds are dropped.\n    \"\"\"\n    # Initialize the grid\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n    grid[0, :] = 1  # Upper row: 1 indicates empty, 0 indicates occupied\n    grid[-1, :] = 1  # Lower row: 1 indicates seed present, 0 indicates no seed\n    \n    # Ant's starting position (center of the grid)\n    ant_pos = (grid_size // 2, grid_size // 2)\n    ant_carrying_seed = False\n    steps = 0\n    \n    while np.sum(grid[0, :]) < num_seeds:\n        steps += 1\n        # Determine possible moves\n        possible_moves = []\n        if ant_pos[0] > 0: possible_moves.append((-1, 0))  # Up\n        if ant_pos[0] < grid_size - 1: possible_moves.append((1, 0))  # Down\n        if ant_pos[1] > 0: possible_moves.append((0, -1))  # Left\n        if ant_pos[1] < grid_size - 1: possible_moves.append((0, 1))  # Right\n        \n        # Randomly choose a move\n        move = random.choice(possible_moves)\n        new_pos = (ant_pos[0] + move[0], ant_pos[1] + move[1])\n        \n        # Update ant's position\n        ant_pos = new_pos\n        \n        # Check if ant reaches the lower row and is not carrying a seed\n        if not ant_carrying_seed and ant_pos[0] == grid_size - 1 and grid[ant_pos] == 1:\n            ant_carrying_seed = True\n            grid[ant_pos] = 0  # Remove seed from the lower row\n        \n        # Check if ant reaches the upper row and is carrying a seed\n        if ant_carrying_seed and ant_pos[0] == 0:\n            grid[ant_pos] = 0  # Drop the seed in the upper row\n            ant_carrying_seed = False\n    \n    return steps\n\n# main function\ndef main_solution(grid_size, num_seeds, num_simulations):\n    \"\"\"\n    Simulates the ant's walk multiple times and returns the average number of steps taken until all seeds are dropped.\n    \"\"\"\n    total_steps = 0\n    for _ in range(num_simulations):\n        total_steps += simulate_ant_walk(grid_size, num_seeds)\n    \n    average_steps = total_steps / num_simulations\n    return round(average_steps, 6)", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    grid_size = random.randint(5, 20)\n    num_seeds = random.randint(1, grid_size)\n    num_simulations = random.randint(1, 100)\n    return {\n        'grid_size': grid_size,\n        'num_seeds': num_seeds,\n        'num_simulations': num_simulations\n    }", "io_pairs": [{"input": {"grid_size": 12, "num_seeds": 10, "num_simulations": 97}, "output": 0.0}, {"input": {"grid_size": 11, "num_seeds": 4, "num_simulations": 29}, "output": 0.0}, {"input": {"grid_size": 9, "num_seeds": 9, "num_simulations": 48}, "output": 0.0}, {"input": {"grid_size": 9, "num_seeds": 1, "num_simulations": 34}, "output": 0.0}, {"input": {"grid_size": 6, "num_seeds": 1, "num_simulations": 69}, "output": 0.0}, {"input": {"grid_size": 18, "num_seeds": 11, "num_simulations": 3}, "output": 0.0}, {"input": {"grid_size": 20, "num_seeds": 17, "num_simulations": 69}, "output": 0.0}, {"input": {"grid_size": 18, "num_seeds": 12, "num_simulations": 25}, "output": 0.0}, {"input": {"grid_size": 17, "num_seeds": 12, "num_simulations": 56}, "output": 0.0}, {"input": {"grid_size": 8, "num_seeds": 2, "num_simulations": 31}, "output": 0.0}], "error_log": []}
{"context": "Given a main string and a pattern string, determine if the main string can be segmented into substrings such that each segment corresponds uniquely to a character in the pattern string. For example, if the pattern string is \"abc\", the main string should be segmented into three distinct substrings that correspond to 'a', 'b', and 'c' respectively. Does the main string match the pattern string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `string` (str): The main string that needs to be checked against the pattern.\n  `patstring` (str): The pattern string that defines the structure to be matched against the main string.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the main string matches the pattern string (`True` if it matches, `False` otherwise).", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\nclass stringpattern:\n    def __init__(self, patdict):\n        self.patternArray = []\n        self.patternDictionary = patdict.copy()\n\n    def makeString(self):\n        string = \"\"\n        for i in self.patternArray:\n            string += self.patternDictionary[str(i)]\n        return string\n\ndef checkPatternRecursive(string, patstring, patdict):\n    if len(string) != 0 and len(patstring) != 0:\n        patletter = patstring[0]\n        if patletter in patdict.keys():\n            sub = patdict[patletter]\n            if len(string) < len(sub) or sub != string[:len(sub)]:\n                return False\n            else:\n                return checkPatternRecursive(string[len(sub):], patstring[1:], patdict)\n        else:\n            fitsPattern = False\n            subLength = 0\n            maxLength = math.floor((len(string)-len(patstring)+patstring.count(patletter)) / patstring.count(patletter))\n            while subLength < maxLength and not fitsPattern:\n                subLength += 1\n                sub = string[:subLength]\n                if not sub in patdict.values():\n                    patdict[patletter] = sub\n                    fitsPattern = checkPatternRecursive(string[subLength:], patstring[1:], patdict)\n                    patdict.pop(patletter)\n            return fitsPattern\n    elif len(string) == 0 and len(patstring) == 0:\n        return True\n    else:\n        return False\n\ndef checkPattern(string, patstring):\n    return checkPatternRecursive(string, patstring, {})\n\n# main function\ndef main_solution(string, patstring):\n    # Convert input variables if necessary\n    # In this case, both inputs are already JSON serializable (strings)\n    \n    # Call the core function to solve the problem\n    result = checkPattern(string, patstring)\n    \n    # Convert output to JSON serializable if necessary\n    # In this case, the output is already JSON serializable (boolean)\n    \n    # Return the final output\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random pattern string (e.g., 'aab', 'abc', etc.)\n    pattern_length = random.randint(2, 5)\n    pattern_chars = random.choices(string.ascii_lowercase, k=pattern_length)\n    patstring = ''.join(pattern_chars)\n    \n    # Generate a dictionary to map pattern characters to substrings\n    patdict = {}\n    used_substrings = set()\n    for char in set(pattern_chars):\n        sub_length = random.randint(1, 3)\n        while True:\n            sub = ''.join(random.choices(string.ascii_lowercase, k=sub_length))\n            if sub not in used_substrings:\n                used_substrings.add(sub)\n                patdict[char] = sub\n                break\n    \n    # Generate the string according to the pattern\n    sp = stringpattern(patdict)\n    sp.patternArray = list(patstring)\n    string = sp.makeString()\n    \n    # Occasionally return a non-matching string\n    if random.random() < 0.3:\n        string = string[:-1] + random.choice(string.ascii_lowercase)\n    \n    return {'string': string, 'patstring': patstring}", "io_pairs": [], "error_log": []}
{"context": "Given a URL, what is the Shannon entropy of the characters in the URL?\n\nThe input and output requirements are as follows:\n\nInput:\n  `url` (str): A string representing the URL whose Shannon entropy needs to be calculated. The string should not contain any special characters or spaces, and should be a valid URL format.\n\nOutput:\n  `return` (float): A floating-point number representing the Shannon entropy of the given URL.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(url):\n    # Convert the URL string to a list of characters\n    url_list = list(url)\n    \n    # Get the unique characters in the URL\n    alphabet = list(set(url_list))\n    \n    # Calculate the frequency of each symbol in the URL\n    freqList = []\n    for symbol in alphabet:\n        ctr = 0\n        for sym in url_list:\n            if sym == symbol:\n                ctr += 1\n        freqList.append(float(ctr) / len(url_list))\n    \n    # Calculate Shannon entropy\n    ent = 0.0\n    for freq in freqList:\n        ent = ent + freq * math.log(freq, 2)\n    \n    # Return the Shannon entropy as a JSON serializable output\n    return -ent", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random URL-like string with varying lengths and characters\n    length = random.randint(10, 50)\n    chars = string.ascii_letters + string.digits + \"/.-_\"\n    url = ''.join(random.choices(chars, k=length))\n    return {'url': url}", "io_pairs": [{"input": {"url": "ojcnvAt9Y_OkRXkNtpEB__"}, "output": 4.061482186720775}, {"input": {"url": "MEE/xC5fnkw.2tR"}, "output": 3.773557262275185}, {"input": {"url": "Cw_ydQWM7CAu5PX--OyqRWyIV_FXEbQeqJwT9K"}, "output": 4.701746263386654}, {"input": {"url": "O_knfX7pHscN9/1dKAF._ITkT1xYDQt0LVpyM"}, "output": 4.939183095358683}, {"input": {"url": "5_u1rHDer.fKiPg7AsTV/9Pw"}, "output": 4.418295834054489}, {"input": {"url": "iBZwpDq2UmeHAGLss1nBBKckBiLqYHIKpGA.a5x5R"}, "output": 4.674625175349791}, {"input": {"url": "O3fsLpjsPUw4RZibcBuh.fB6j3WnC4GvCHphYYQe3J3zy6P"}, "output": 4.916290979337213}, {"input": {"url": "Eyo28eawCPKuWyajqwXLhdw-J1NY9_Gx9rndf"}, "output": 4.864726676381288}, {"input": {"url": ".tSlo2m0.5sqeCyT24mkABKau3Ql/tI/"}, "output": 4.625}, {"input": {"url": "KaYQ6f9HU7nPodJLjzVrd.GEzL6sIhAHEquS"}, "output": 4.836591668108977}], "error_log": []}
{"context": "Alice and Bob are using the Diffie-Hellman key exchange protocol to securely communicate. They have agreed on a base value `g` and a modulus `n`. Alice has a message `message` that she wants to encrypt using the shared secret key generated by the protocol. What will be the encrypted message that Alice sends to Bob?\n\nThe input and output requirements are as follows:\n\nInput:\n  `g` (int): The base value for the Diffie-Hellman key exchange.\n  `n` (int): The modulus value for the Diffie-Hellman key exchange.\n  `message` (str): The message to be encrypted. It should be a string of alphabetic characters.\n\nOutput:\n  `return` (str): The encrypted message. It is a string of alphabetic characters.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef encrypt(text, s):\n    result = \"\"\n    for i in range(len(text)):\n        char = text[i]\n        if char.isupper():\n            result += chr((ord(char) + s - 65) % 26 + 65)\n        else:\n            result += chr((ord(char) + s - 97) % 26 + 97)\n    return result\n\n# main function\ndef main_solution(g, n, message):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    def Alice(g, n):\n        x = random.randrange(1, 100)\n        a = g**x % n\n        b = Bob(g, n, a)\n        k1 = b**x % n\n        return k1\n\n    def Bob(g, n, a):\n        y = random.randrange(1, 100)\n        b = g ** y % n\n        k2 = a ** y % n\n        return b\n\n    # Convert JSON serializable inputs to original input variables\n    g = int(g)\n    n = int(n)\n\n    # Invoke functions that require non-json serializable inputs\n    key = Alice(g, n)\n    encrypted_message = encrypt(message, key)\n\n    # Convert the output to JSON serializable\n    return encrypted_message", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate random g and n (primes or suitable numbers for DH key exchange)\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    g = random.choice(primes)\n    n = random.choice([p for p in primes if p > g])\n    \n    # Generate a random message\n    message_length = random.randint(5, 20)\n    message = ''.join(random.choice(string.ascii_letters) for _ in range(message_length))\n    \n    return {'g': g, 'n': n, 'message': message}", "io_pairs": [{"input": {"g": 13, "n": 73, "message": "matdMkUtaJ"}, "output": "rfyiRpZyfO"}, {"input": {"g": 17, "n": 37, "message": "oFIsZemgAgIdgML"}, "output": "wNQaHmuoIoQloUT"}, {"input": {"g": 59, "n": 73, "message": "OxOvJw"}, "output": "IrIpDq"}, {"input": {"g": 19, "n": 73, "message": "KkkJWQljnqOfe"}, "output": "SssREYtrvyWnm"}, {"input": {"g": 11, "n": 79, "message": "iYIsLCJiSeJz"}, "output": "dTDnGXEdNzEu"}, {"input": {"g": 53, "n": 89, "message": "UPoacNokQrHkU"}, "output": "EZykmXyuAbRuE"}, {"input": {"g": 13, "n": 23, "message": "FPOsGFxydJrNhvCPyrzR"}, "output": "ISRvJIabgMuQkyFSbucU"}, {"input": {"g": 73, "n": 97, "message": "qCdDwqbUq"}, "output": "xJkKdxiBx"}, {"input": {"g": 37, "n": 61, "message": "VZGOFSVGecpf"}, "output": "BFMULYBMkivl"}, {"input": {"g": 31, "n": 37, "message": "AHuTf"}, "output": "BIvUg"}], "error_log": []}
{"context": "Given a puzzle represented by a 2D grid of integers, where each integer represents a tile and 0 represents the blank space, what is the sequence of moves required to transform the initial state of the puzzle into the goal state? The moves can be \"UP\", \"DOWN\", \"LEFT\", or \"RIGHT\", and the puzzle is considered unsolvable if no sequence of moves can achieve the goal state.\n\nThe input and output requirements are as follows:\n\nInput:\n  `init_state` (list of lists of integers): The initial state of the puzzle, represented as a 2D list of integers.\n  `goal_state` (list of lists of integers): The goal state of the puzzle, represented as a 2D list of integers.\n\nOutput:\n  `return` (list of strings): A list of moves required to solve the puzzle from the initial state to the goal state. Each move is represented as a string (\"UP\", \"DOWN\", \"LEFT\", \"RIGHT\"). If the puzzle is unsolvable, the list will contain the string \"UNSOLVABLE\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Puzzle(object):\n    def __init__(self, init_state, goal_state):\n        self.init_state = init_state\n        self.goal_state = goal_state\n        self.actions = list()\n\n    def solve(self):\n        return self.uninformed_search(self.init_state, self.goal_state)\n\n    def uninformed_search(self, initial, goal):\n        moves = []\n        visited = set()\n\n        if self.isSolvable(initial):\n            path_merged = self.bfs(initial, goal, visited)\n            path = path_merged[0]\n            path.pop(0)\n\n            for move in path:\n                moves.append(move[1])\n        else:\n            moves.append(\"UNSOLVABLE\")\n            \n        return moves\n\n    def bfs(self, initial, goal, visited):\n        start = (initial, \"-\")\n        source = [start]\n        queue = [source]\n        node_seen = 0\n\n        while queue:\n            path = queue.pop(0)\n            state = path[-1][0]\n            node_seen += 1\n\n            if self.isreached(state, goal):\n                node_seen += len(queue)\n                return [path, node_seen]\n\n            x, y = self.locateblank(state)\n\n            for dx, dy, direction in [(-1, 0, \"DOWN\"), (0, -1, \"RIGHT\"), (1, 0, \"UP\"), (0, 1, \"LEFT\")]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < len(state) and 0 <= ny < len(state[0]):\n                    new_state = self.swap(state, nx, ny, x, y)\n                    if new_state not in visited:\n                        npath = list(path)\n                        move = (new_state, direction)\n                        npath.append(move)\n                        queue.append(npath)\n\n            visit = tuple(map(tuple, state))\n            visited.add(visit)\n\n    def swap(self, state, nx, ny, ox, oy):\n        transform = list(map(list, state))\n        transform[ox][oy], transform[nx][ny] = transform[nx][ny], transform[ox][oy]\n        return tuple(map(tuple, transform))\n\n    def locateblank(self, state):\n        for i in range(len(state)):\n            for j in range(len(state[0])):\n                if state[i][j] == 0:\n                    return i, j\n        raise ValueError(\"Error: no blank cell exists!\")\n\n    def isreached(self, state, goal):\n        return all(state[i][j] == goal[i][j] for i in range(len(state)) for j in range(len(state[0])))\n\n    def isSolvable(self, state):\n        inv_count = 0\n        blank_row = -1\n        flat = []\n        for i in range(len(state)):\n            for j in range(len(state[0])):\n                if state[i][j] != 0:\n                    flat.append(state[i][j])\n                else:\n                    blank_row = len(state) - i\n\n        for m in range(len(flat)):\n            for n in range(m, len(flat)):\n                if flat[m] > flat[n]:\n                    inv_count += 1\n\n        if len(state) % 2 == 1 or blank_row % 2 == 1:\n            return inv_count % 2 == 0\n        else:\n            return inv_count % 2 == 1\n\n# main function\ndef main_solution(init_state, goal_state):\n    puzzle = Puzzle(init_state, goal_state)\n    result = puzzle.solve()\n    return result", "input_generator": "import random\n\ndef input_generator():\n    size = 3  # Standard 8-puzzle size\n    numbers = list(range(size * size))\n    \n    # Generate random initial state\n    random.shuffle(numbers)\n    init_state = [numbers[i*size:(i+1)*size] for i in range(size)]\n    \n    # Generate goal state (either standard or randomized)\n    if random.random() < 0.5:\n        goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]  # Standard goal\n    else:\n        random.shuffle(numbers)\n        goal_state = [numbers[i*size:(i+1)*size] for i in range(size)]\n    \n    return {\n        'init_state': init_state,\n        'goal_state': goal_state\n    }", "io_pairs": [], "error_log": []}
{"context": "Given a password policy where passwords must be exactly 8 characters long and consist only of lowercase letters, what is the next valid password that adheres to the following rules:\n1. Passwords must not contain the letters 'i', 'o', or 'l'.\n2. Passwords must include at least two different, non-overlapping pairs of letters, like 'aa', 'bb', or 'zz'.\n3. Passwords must contain a sequence of at least three consecutive letters, like 'abc', 'bcd', or 'xyz'.\n\nStarting from a randomly generated initial password, what is the next valid password that meets these criteria?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_password` (str): A string representing the initial password in lowercase letters. The password should be exactly 8 characters long and consist only of lowercase letters.\n\nOutput:\n  `return` (str): A string representing the next valid password in lowercase letters. The password will be exactly 8 characters long and consist only of lowercase letters. If no valid password is found within the search space, `None` is returned.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\nA_UPPERCASE = ord(\"A\")\nALPHABET_SIZE = 26\n\ndef _decompose(number):\n    \"\"\"Generate digits from `number` in base alphabet, least significants\n    bits first.\n\n    Since A is 1 rather than 0 in base alphabet, we are dealing with\n    `number - 1` at each iteration to be able to extract the proper digits.\n    \"\"\"\n    while number:\n        number, remainder = divmod(number - 1, ALPHABET_SIZE)\n        yield remainder\n\ndef base_10_to_alphabet(number):\n    \"\"\"Convert a decimal number to its base alphabet representation\"\"\"\n    return \"\".join(chr(A_UPPERCASE + part) for part in _decompose(number))[::-1]\n\ndef base_alphabet_to_10(letters):\n    \"\"\"Convert an alphabet number to its decimal representation\"\"\"\n    return sum(\n        (ord(letter) - A_UPPERCASE + 1) * ALPHABET_SIZE ** i\n        for i, letter in enumerate(reversed(letters.upper()))\n    )\n\ndef validate(pw):\n    low_pw = pw.lower()\n    for i, x in enumerate(low_pw):\n        if x in (\"i\", \"o\", \"l\"):\n            low_pw = low_pw[: i + 1] + \"z\" * (len(low_pw) - (i + 1))\n            return low_pw\n\n    ordv = [ord(x) for x in low_pw]\n    z = 0\n    cnt = 0\n    for v in ordv:\n        if v - z == 1:\n            cnt += 1\n            z = v\n            if cnt == 2:\n                break\n            continue\n        cnt = 0\n        z = v\n    if cnt != 2:\n        return low_pw\n\n    repeats = []\n    z = \"\"\n    for x in low_pw:\n        if x == z and (x not in repeats):\n            repeats.append(x)\n        else:\n            z = x\n    if len(repeats) < 2:\n        return low_pw\n\n    return True\n\n# main function\ndef main_solution(initial_password):\n    pw = initial_password\n    for _ in range(8 ** 26):\n        num = base_alphabet_to_10(pw.upper())\n        num += 1\n        pw = base_10_to_alphabet(num)\n        save_pw = pw\n        if (pw := validate(pw)) == True:\n            return save_pw.lower()\n    return None", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(5, 10)\n    letters = []\n    for _ in range(length):\n        letters.append(random.choice(string.ascii_lowercase))\n    initial_password = ''.join(letters)\n    return {'initial_password': initial_password}", "io_pairs": [{"input": {"initial_password": "dihydo"}, "output": "dppqrr"}, {"input": {"initial_password": "sajsfim"}, "output": "sappqrr"}, {"input": {"initial_password": "apmlegi"}, "output": "appaabc"}, {"input": {"initial_password": "gjagymc"}, "output": "gjbbcdd"}, {"input": {"initial_password": "wuddt"}, "output": "wwxyy"}, {"input": {"initial_password": "rpfvsz"}, "output": "rppqrr"}, {"input": {"initial_password": "bbdmbx"}, "output": "bbeefg"}, {"input": {"initial_password": "azimc"}, "output": "bbcdd"}, {"input": {"initial_password": "nmaixc"}, "output": "nnaabc"}, {"input": {"initial_password": "pylrxs"}, "output": "qaabcc"}], "error_log": []}
{"context": "Given an upper limit, what are all the prime numbers less than or equal to that limit?\n\nThe input and output requirements are as follows:\n\nInput:\n  `size` (int): The upper limit for finding prime numbers. The sieve will find all prime numbers less than or equal to this size.\n\nOutput:\n  `return` (list of int): A list of prime numbers found by the sieve algorithm up to the given size.", "reference_code": "# import necessary packages\nimport numpy as np\nimport math\n\n# all class and function definitions in the code file, if any\nclass Sieves:\n    def __init__(self, size):\n        self.n = math.ceil(int(size/2))\n        self.A = np.zeros(self.n, int)\n\n    def sieveOfEratosthenes(self):\n        for i in range(1,self.n):\n            val = i*2+1\n            if (self.A[i] == 0):\n                self.A[i] = 1\n                step_val = 3 * val\n                step_i = int((step_val - 1) / 2)\n                while (step_i < self.n):\n                    self.A[step_i] = -1\n                    step_val += val + val\n                    step_i = int((step_val - 1) / 2)\n        return self.A\n\n    def reportPrimes(self):\n        primes = [2]\n        for i in range(1,self.n):\n            if (self.A[i] == 1):\n                val = i*2 +1\n                primes.append(val)\n        return primes\n\n    def isPrime(self, n):\n        if (n == 2):\n            return True\n        for i in range(1,self.n):\n            if (n == i * 2 + 1) and (self.A[i] == 1):\n                return True\n        return False\n\n# main function\ndef main_solution(size):\n    # Convert JSON serializable input to original input variables\n    sieve = Sieves(size)\n    sieve.sieveOfEratosthenes()\n    primes = sieve.reportPrimes()\n    # Convert output to JSON serializable\n    return primes", "input_generator": "import random\nimport math\n\ndef input_generator():\n    size = random.choice([100, 500, 1000, 2000, 5000])\n    return {'size': size}", "io_pairs": [], "error_log": []}
{"context": "In a given century, how many months start on a specific day of the week within a specified range of years?\n\nThe input and output requirements are as follows:\n\nInput:\n  `day` (int): The day of the week (0 for Sunday, 1 for Monday, ..., 6 for Saturday) for which we want to count the number of months starting on this day.\n  `year_start` (int): The starting year of the range for which we want to count the months.\n  `year_end` (int): The ending year of the range for which we want to count the months.\nOutput:\n  `return` (int): The total number of months that start on the specified day of the week within the given range of years.", "reference_code": "# import necessary packages\nimport time\nfrom math import floor\n\n# all class and function definitions in the code file, if any\ndef day_of_week(year, month, day):\n    d = day\n    m = (month - 3) % 12 + 1\n    if m > 10: Y = year - 1\n    else: Y = year\n    y = Y % 100\n    c = (Y - (Y % 100)) / 100\n \n    w = (d + floor(2.6 * m - 0.2) + y + floor(y/4) + floor(c/4) - 2*c) % 7\n \n    return int(w)\n \ndef months_start_range(day, year_start, year_end):\n    total = 0\n    for year in range(year_start, year_end + 1):\n        for month in range(1, 13):\n            if day_of_week(year, month, 1) == day: total += 1\n    return total\n\n# main function\ndef main_solution(day, year_start, year_end):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    total = months_start_range(day, year_start, year_end)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return total", "input_generator": "import random\n\ndef input_generator():\n    day = random.randint(0, 6)\n    year_start = random.randint(1900, 2000)\n    year_end = year_start + random.randint(1, 50)\n    return {'day': day, 'year_start': year_start, 'year_end': year_end}", "io_pairs": [{"input": {"day": 2, "year_start": 1929, "year_end": 1977}, "output": 84}, {"input": {"day": 3, "year_start": 1981, "year_end": 1990}, "output": 17}, {"input": {"day": 5, "year_start": 1989, "year_end": 1994}, "output": 11}, {"input": {"day": 4, "year_start": 1904, "year_end": 1918}, "output": 25}, {"input": {"day": 0, "year_start": 1998, "year_end": 2030}, "output": 57}, {"input": {"day": 1, "year_start": 1971, "year_end": 1982}, "output": 22}, {"input": {"day": 1, "year_start": 1941, "year_end": 1963}, "output": 39}, {"input": {"day": 1, "year_start": 1919, "year_end": 1959}, "output": 69}, {"input": {"day": 2, "year_start": 1908, "year_end": 1909}, "output": 3}, {"input": {"day": 5, "year_start": 1913, "year_end": 1918}, "output": 10}], "error_log": []}
{"context": "Given a list of integers representing the values of a game where two players take turns picking values from either end of the list, and assuming the opponent always plays optimally, what is the maximum sum that can be achieved by the first player?\n\nThe input and output requirements are as follows:\n\nInput:\n  `arr` (list of int): A list of integers representing the values to be picked from. The length of the list should be between 1 and 10, and each integer should be between 1 and 100.\n\nOutput:\n  `return` (int): The maximum sum the player can achieve by picking values optimally from either end of the list, assuming the opponent also plays optimally.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(arr):\n    \"\"\"\n    This function calculates the maximum sum a player can achieve by always picking the optimal value from either end of the list,\n    assuming the opponent also plays optimally.\n    \n    Parameters:\n    arr (list of int): A list of integers representing the values to be picked from.\n    \n    Returns:\n    int: The maximum sum the player can achieve.\n    \"\"\"\n    def mentos(arr, start, end):\n        if start == end:\n            return arr[start]\n        if end - start == 1:\n            return max(arr[start], arr[end])\n        return max(arr[start] + min(mentos(arr, start + 2, end), mentos(arr, start + 1, end - 1)),\n                   arr[end] + min(mentos(arr, start + 1, end - 1), mentos(arr, start, end - 2)))\n    \n    return mentos(arr, 0, len(arr) - 1)", "input_generator": "import random\n\ndef input_generator():\n    length = random.randint(1, 10)  # Reasonable length to avoid excessive computation\n    arr = [random.randint(-100, 100) for _ in range(length)]\n    return {'arr': arr}", "io_pairs": [{"input": {"arr": [3, -41, 15, 3, 57]}, "output": 19}, {"input": {"arr": [63, 81, 18]}, "output": 81}, {"input": {"arr": [83, -30, -79]}, "output": 4}, {"input": {"arr": [-89, -84]}, "output": -84}, {"input": {"arr": [-54, -91]}, "output": -54}, {"input": {"arr": [-29, -10, -23, -70, -99, -41, 100, 20]}, "output": -51}, {"input": {"arr": [12, 44, 4, -2, 40, -82, 37, -94, 69, -82]}, "output": 162}, {"input": {"arr": [-14]}, "output": -14}, {"input": {"arr": [-26, -83, -54, -56, 99, 99, -65, 28, 29]}, "output": -37}, {"input": {"arr": [-11, 82, 39, -39]}, "output": 43}], "error_log": []}
{"context": "In a minefield game, you are given a grid of dimensions `r` rows and `c` columns. You need to place `m` mines in the grid. The objective is to determine if it is possible to place the mines such that there is at least one safe path to click on the grid without hitting a mine. What is the result of this configuration?\n\nThe input and output requirements are as follows:\n\nInput:\n  `r` (int): The number of rows in the minefield.\n  `c` (int): The number of columns in the minefield.\n  `m` (int): The number of mines to be placed in the minefield.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"possible\"` which is a boolean indicating whether it is possible to place the mines such that there is a safe path to click on the minefield.", "reference_code": "# import necessary packages\nimport sys\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\ndef howManyMinesNearby(map, x, y):\n    mines = 0\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i == j and i == 0 or x + i < 0 or y + j < 0 or x + i >= len(map) or y + j >= len(map[0]):\n                continue\n            if map[x + i][y + j] == '*':\n                mines += 1\n    return mines\n\ndef newMap(r, c):\n    map = []\n    for i in range(r):\n        map.append([])\n        for j in range(c):\n            map[i].append('*')\n    return map\n\ndef propagate(map, x, y):\n    spaces_placed = 0\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i == j and i == 0 or x + i < 0 or y + j < 0 or x + i >= len(map) or y + j >= len(map[0]):\n                continue\n            if map[x + i][y + j] == '*':\n                spaces_placed += 1\n                map[x + i][y + j] = '.'\n    return spaces_placed\n\ndef expand(map, x, y, nm):\n    nm -= propagate(map, x, y)\n\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i == j and i == 0 or x + i < 0 or y + j < 0 or x + i >= len(map) or y + j >= len(map[0]):\n                continue\n            minesFound = howManyMinesNearby(map, x + i, y + j)\n            if minesFound <= nm and minesFound > 0:\n                if expand(copyMap(map), x + i, y + j, nm):\n                    return True\n\n            if nm == 0:\n                return True\n    return False\n\ndef copyMap(map):\n    new = []\n    for i in range(len(map)):\n        new.append([])\n        for j in range(len(map[0])):\n            new[i].append(map[i][j])\n    return new\n\ndef iterateAndExpand(r, c, nm):\n    if nm == 0:\n        map = newMap(r, c)\n        map[0][0] = 'c'\n        return True\n\n    for i in range(r):\n        for j in range(c):\n            map = newMap(r, c)\n            map[i][j] = 'c'\n            if expand(map, i, j, nm):\n                return True\n\n    return False\n\n# main function\ndef main_solution(r, c, m):\n    nm = r * c - m - 1  # not mines\n    result = iterateAndExpand(r, c, nm)\n    return {\"possible\": result}", "input_generator": "import random\n\ndef input_generator():\n    r = random.randint(1, 10)\n    c = random.randint(1, 10)\n    max_m = r * c - 1\n    m = random.randint(0, max_m)\n    return {\"r\": r, \"c\": c, \"m\": m}", "io_pairs": [{"input": {"r": 7, "c": 9, "m": 11}, "output": {"possible": true}}, {"input": {"r": 2, "c": 10, "m": 1}, "output": {"possible": false}}, {"input": {"r": 3, "c": 10, "m": 29}, "output": {"possible": true}}, {"input": {"r": 1, "c": 3, "m": 1}, "output": {"possible": true}}, {"input": {"r": 2, "c": 3, "m": 3}, "output": {"possible": false}}, {"input": {"r": 6, "c": 1, "m": 2}, "output": {"possible": true}}, {"input": {"r": 8, "c": 7, "m": 52}, "output": {"possible": true}}, {"input": {"r": 1, "c": 4, "m": 0}, "output": {"possible": true}}, {"input": {"r": 5, "c": 4, "m": 16}, "output": {"possible": true}}, {"input": {"r": 6, "c": 6, "m": 3}, "output": {"possible": true}}], "error_log": []}
{"context": "Given a 9x9 Sudoku board, determine whether it is a valid Sudoku puzzle. A valid Sudoku board must satisfy the following conditions:\n1. Each row must contain the digits 1-9 without repetition.\n2. Each column must contain the digits 1-9 without repetition.\n3. Each of the nine 3x3 sub-grids must contain the digits 1-9 without repetition.\n\nIs the provided Sudoku board valid?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (str): A string representation of a 9x9 Sudoku board. Each row is represented as a string of 9 characters, where each character is either a digit (1-9) or a period ('.') to represent an empty cell. Rows are separated by commas.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the Sudoku board is valid (True) or not (False).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # test row and column\n        for i in range(9):\n            s_row = set()\n            s_col = set()\n            for j in range(9):\n                if board[i][j] != '.':\n                    if board[i][j] in s_row:\n                        return False\n                    s_row.add(board[i][j])\n                \n                if board[j][i] != '.':\n                    if board[j][i] in s_col:\n                        return False\n                    s_col.add(board[j][i])\n\n        # test square\n        for i in range(3):\n            for j in range(3):\n                s = set()\n                for x in range(3):\n                    for y in range(3):\n                        cur = board[3 * i + x][3 * j + y]\n                        if cur != '.':\n                            if cur in s:\n                                return False\n                            s.add(cur)\n        \n        return True\n\n# main function\ndef main_solution(board):\n    # Convert the input board to a list of lists if it's not already\n    if isinstance(board, str):\n        board = [list(row) for row in board.split(',')]\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the isValidSudoku method\n    result = solution.isValidSudoku(board)\n    \n    # Return the result\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a mostly valid Sudoku board with some randomness\n    board = [['.' for _ in range(9)] for _ in range(9)]\n    \n    # Fill some cells with valid numbers\n    for _ in range(random.randint(10, 30)):\n        i = random.randint(0, 8)\n        j = random.randint(0, 8)\n        num = str(random.randint(1, 9))\n        \n        # Check if the number can be placed without violating Sudoku rules\n        valid = True\n        for k in range(9):\n            if board[i][k] == num or board[k][j] == num:\n                valid = False\n                break\n        \n        # Check the 3x3 subgrid\n        sub_i, sub_j = i // 3, j // 3\n        for x in range(3):\n            for y in range(3):\n                if board[sub_i * 3 + x][sub_j * 3 + y] == num:\n                    valid = False\n                    break\n        \n        if valid:\n            board[i][j] = num\n    \n    # Occasionally introduce an invalid board\n    if random.random() < 0.2:\n        # Duplicate a number in a row, column, or subgrid\n        i = random.randint(0, 8)\n        j1 = random.randint(0, 7)\n        j2 = random.randint(j1 + 1, 8)\n        if board[i][j1] != '.' and board[i][j2] == '.':\n            board[i][j2] = board[i][j1]\n    \n    return {'board': board}", "io_pairs": [], "error_log": []}
{"context": "Given a tree structure represented by a sequence of integers, where each node is defined by the number of its children and metadata entries, what is the sum of all metadata entries in the tree and the value of the root node?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data` (str): A space-separated string of integers representing the structure of the tree.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `sum_metadata` (int): The sum of all metadata entries in the tree.\n    - `root_value` (int): The value of the root node.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    def __init__(self):\n        self.children = []\n        self.metadata = []\n\n    @classmethod\n    def parse_node(cls, data, start):\n        node = Node()\n        next = start + 2\n        num_children, num_meta = data[start:next]\n        for _ in range(num_children):\n            child, next = Node.parse_node(data, next)\n            node.children.append(child)\n        end = next + num_meta\n        node.metadata = data[next:end]\n        return node, end\n\n    def sum_meta(self):\n        return sum(child.sum_meta() for child in self.children) + sum(self.metadata)\n\n    def value(self):\n        if len(self.children) == 0:\n            return sum(self.metadata)\n        else:\n            return sum(self.children[idx - 1].value()\n                       for idx in self.metadata\n                       if idx > 0 and idx <= len(self.children))\n\n# main function\ndef main_solution(data):\n    # Convert the input string to a list of integers\n    data = [int(x) for x in data.split()]\n    \n    # Parse the node structure\n    root, end = Node.parse_node(data, 0)\n    \n    # Calculate the sum of all metadata\n    sum_metadata = root.sum_meta()\n    \n    # Calculate the value for the root node\n    root_value = root.value()\n    \n    # Return the results as a dictionary\n    return {\"sum_metadata\": sum_metadata, \"root_value\": root_value}", "input_generator": "import random\n\ndef input_generator():\n    def generate_node_data(num_children):\n        data = []\n        # Add number of children and number of metadata entries\n        data.append(num_children)\n        num_meta = random.randint(1, 5)\n        data.append(num_meta)\n        \n        # Generate children data\n        for _ in range(num_children):\n            child_data = generate_node_data(random.randint(0, 3))\n            data.extend(child_data)\n        \n        # Generate metadata entries\n        metadata = [random.randint(0, 10) for _ in range(num_meta)]\n        data.extend(metadata)\n        return data\n    \n    # Generate a random tree with 1 to 4 children for the root\n    root_children = random.randint(1, 4)\n    data = generate_node_data(root_children)\n    data_str = ' '.join(map(str, data))\n    \n    return {'data': data_str}", "io_pairs": [{"input": {"data": "1 2 1 4 0 3 7 1 10 9 9 7 8 2 9"}, "output": {"sum_metadata": 62, "root_value": 0}}, {"input": {"data": "2 5 0 5 3 3 10 6 10 3 5 0 2 3 8 0 3 0 6 10 0 1 0 4 10 5 1 6 1 4 2 0 8"}, "output": {"sum_metadata": 100, "root_value": 43}}, {"input": {"data": "4 5 0 1 4 0 1 4 1 1 0 5 10 2 9 2 7 6 0 2 7 0 3 9 3 6 8"}, "output": {"sum_metadata": 80, "root_value": 0}}, {"input": {"data": "1 5 1 2 0 3 0 3 7 7 7 3 9 2 5 8"}, "output": {"sum_metadata": 51, "root_value": 0}}, {"input": {"data": "1 2 0 3 5 2 2 9 9"}, "output": {"sum_metadata": 27, "root_value": 0}}, {"input": {"data": "1 1 1 3 0 1 8 9 6 1 8"}, "output": {"sum_metadata": 32, "root_value": 0}}, {"input": {"data": "1 2 1 5 2 3 0 2 8 6 0 2 1 6 6 1 1 9 8 10 2 10 3 6"}, "output": {"sum_metadata": 77, "root_value": 0}}, {"input": {"data": "1 4 1 3 0 1 10 6 3 10 1 1 10 8"}, "output": {"sum_metadata": 49, "root_value": 0}}, {"input": {"data": "2 1 1 5 0 1 5 1 2 4 9 10 1 5 1 5 0 4 5 7 2 5 6 6 4 4 10 0 4 8 6 3 3"}, "output": {"sum_metadata": 104, "root_value": 0}}, {"input": {"data": "1 1 0 1 7 7"}, "output": {"sum_metadata": 14, "root_value": 0}}], "error_log": []}
{"context": "Given a positive integer, what are the prime numbers that can divide it without leaving a remainder?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number` (int): A positive integer for which the prime dividers need to be found.\n\nOutput:\n  `return` (list of int): A list of prime numbers that are the prime dividers of the input number.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef prime_candidates(number, start=0):\n    if number >= 2 and number >= start:\n        if start <= 2:\n            yield 2\n        if start <= 3:\n            yield 3\n        range_start = 6 if start < 12 else 6 * (start // 6)\n        for x in range(range_start, number + 2, 6):\n            if x > start:\n                yield x - 1\n            if x < number and x + 1 >= start:\n                yield x + 1\n\ndef is_prime(number, found=False):\n    max_found = 2\n    i_sqrt = int(math.sqrt(number))\n    if isinstance(found, list):\n        max_found = found[-1:][0]\n    else:\n        found = []\n    result = all(number % x != 0 for x in found) and \\\n             all(number % x != 0 for x in prime_candidates(i_sqrt, max_found))\n    return result\n\ndef primes_gen(number):\n    if number >= 2:\n        yield 2\n        yield 3\n        i_sqrt = 2\n        sq = 4\n        for x in prime_candidates(number, 5):\n            if sq < x:\n                i_sqrt += 1\n                sq += i_sqrt + i_sqrt - 1\n            add = all(x % f != 0 for f in prime_candidates(i_sqrt))\n            if add:\n                yield x\n\ndef prime_dividers(number):\n    found = {}\n    while number != 1 and number != -1:\n        for p in primes_gen(number):\n            if number % p == 0:\n                if not p in found:\n                    found[p] = 1\n                else:\n                    found[p] += 1\n                number = number // p\n                break\n    return found\n\n# main function\ndef main_solution(number):\n    # Convert the input to an integer\n    number = int(number)\n    \n    # Get the prime dividers of the number\n    prime_divs = prime_dividers(number)\n    \n    # Convert the dictionary to a list of prime dividers\n    prime_divs_list = list(prime_divs.keys())\n    \n    # Return the list of prime dividers\n    return prime_divs_list", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random number with a reasonable range, ensuring it's not too large or small\n    # We'll sometimes generate numbers with known prime factors to ensure variety\n    choices = [\n        random.randint(2, 1000),  # Small random number\n        random.randint(1000, 10000),  # Medium random number\n        random.choice([2**random.randint(1, 10), 3**random.randint(1, 6), 5**random.randint(1, 5)]),  # Powers of small primes\n        random.randint(2, 100) * random.randint(2, 100),  # Product of two small numbers\n        random.choice([6, 10, 15, 30, 42, 70, 105, 210])  # Common composite numbers\n    ]\n    number = random.choice(choices)\n    return {'number': str(number)}", "io_pairs": [{"input": {"number": "832"}, "output": [2, 13]}, {"input": {"number": "220"}, "output": [2, 5, 11]}, {"input": {"number": "128"}, "output": [2]}, {"input": {"number": "2002"}, "output": [2, 7, 11, 13]}, {"input": {"number": "3192"}, "output": [2, 3, 7, 19]}, {"input": {"number": "5387"}, "output": [5387]}, {"input": {"number": "65"}, "output": [5, 13]}, {"input": {"number": "512"}, "output": [2]}, {"input": {"number": "2770"}, "output": [2, 5, 277]}, {"input": {"number": "3542"}, "output": [2, 7, 11, 23]}], "error_log": []}
{"context": "In a game of chess, a board is set up with a variety of pieces placed at random positions. Each piece has the ability to attack other pieces based on its movement rules. Given the size of the board and the positions and types of the pieces, what is the total number of friendly pieces that can be attacked (friendly fire) and the total number of enemy pieces that can be attacked (kills)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_size` (int): The size of the board (e.g., 8 for an 8x8 board).\n  `pieces` (list of dict): A list of dictionaries representing the pieces on the board. Each dictionary contains:\n    - `type` (str): The type of the piece (\"Queen\", \"Rook\", \"Bishop\", \"Knight\").\n    - `color` (bool): The color of the piece (True for white, False for black).\n    - `x` (int): The x-coordinate of the piece on the board.\n    - `y` (int): The y-coordinate of the piece on the board.\n\nOutput:\n  `return` (dict): A dictionary containing the total friendly fire and kills.\n    - `friendly_fire` (int): The total number of friendly pieces that can be attacked by other pieces on the board.\n    - `kills` (int): The total number of enemy pieces that can be attacked by other pieces on the board.", "reference_code": "# import necessary packages\nfrom random import randint, getrandbits\nimport pickle\n\n# all class and function definitions in the code file, if any\nclass Board:\n    def __init__(self, size):\n        self.__size = size\n        self.__pieces = []\n\n    @property\n    def size(self):\n        return self.__size\n\n    @property\n    def pieces(self):\n        return self.__pieces\n\n    def add_piece(self, piece):\n        self.pieces.append(piece)\n\n    def is_placement_valid(self, x, y):\n        if x < 0 or x >= self.size or y < 0 or y >= self.size:\n            return False\n        for placed_piece in self.pieces:\n            if placed_piece.x == x and placed_piece.y == y:\n                return False\n        return True\n\n    def conflict_resolve(self):\n        for i in range(len(self.pieces)):\n            for j in range(i + 1, len(self.pieces)):\n                while (self.pieces[i].x == self.pieces[j].x and self.pieces[i].y == self.pieces[j].y):\n                    self.pieces[i].random_move()\n\n    def count_total_targets(self):\n        ff_tot = 0  # ff = friendly fire\n        kill_tot = 0\n        for piece in self.pieces:\n            ff, kill = piece.count_targets()\n            ff_tot += ff\n            kill_tot += kill\n        return ff_tot, kill_tot\n\nclass Piece:\n    def __init__(self, board, color, x, y):\n        self._board = board\n        self._color = color  # True = white\n        self._x = x\n        self._y = y\n\n    @property\n    def board(self):\n        return self._board\n\n    @board.setter\n    def board(self, new_board):\n        self._board = new_board\n\n    @property\n    def color(self):\n        return self._color\n\n    @property\n    def x(self):\n        return self._x\n\n    @x.setter\n    def x(self, new_x):\n        self._x = new_x\n\n    @property\n    def y(self):\n        return self._y\n\n    @y.setter\n    def y(self, new_y):\n        self._y = new_y\n\n    def move(self, x, y):\n        if self.board.is_placement_valid(x, y):\n            self.x = x\n            self.y = y\n        else:\n            raise ValueError(\"Piece's position isn't valid\")\n\n    def random_move(self):\n        while (True):\n            try:\n                self.move(randint(0, self.board.size - 1),\n                          randint(0, self.board.size - 1))\n                break\n            except:\n                pass\n\ndef count_hv_targets(board, piece):\n    ff = 0\n    kill = 0\n    s_check = True  # Whether we should continue checking south\n    n_check = True\n    w_check = True\n    e_check = True\n    for target in board.pieces:\n        for i in range(1, board.size):\n            if piece.x - i >= 0 and s_check:\n                if target.x == piece.x - i and target.y == piece.y:\n                    if target.color == piece.color:\n                        ff += 1\n                    else:\n                        kill += 1\n                    s_check = False\n                    continue\n            if piece.x + i < board.size and n_check:\n                if target.x == piece.x + i and target.y == piece.y:\n                    if target.color == piece.color:\n                        ff += 1\n                    else:\n                        kill += 1\n                    n_check = False\n                    continue\n            if piece.y - i >= 0 and w_check:\n                if target.x == piece.x and target.y == piece.y - i:\n                    if target.color == piece.color:\n                        ff += 1\n                    else:\n                        kill += 1\n                    w_check = False\n                    continue\n            if piece.y + i < board.size and e_check:\n                if target.x == piece.x and target.y == piece.y + i:\n                    if target.color == piece.color:\n                        ff += 1\n                    else:\n                        kill += 1\n                    e_check = False\n    return ff, kill\n\ndef count_diag_targets(board, piece):\n    ff = 0\n    kill = 0\n    sw_check = True  # Whether we should continue checking southwest\n    nw_check = True\n    se_check = True\n    ne_check = True\n    for target in board.pieces:\n        for i in range(1, board.size):\n            if piece.x - i >= 0:\n                if piece.y - i >= 0 and sw_check:\n                    if target.x == piece.x - i and target.y == piece.y - i:\n                        if target.color == piece.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        sw_check = False\n                        continue\n                if piece.y + i < board.size and nw_check:\n                    if target.x == piece.x - i and target.y == piece.y + i:\n                        if target.color == piece.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        nw_check = False\n                        continue\n            if piece.x + i < board.size:\n                if piece.y - i >= 0 and se_check:\n                    if target.x == piece.x + i and target.y == piece.y - i:\n                        if target.color == piece.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        se_check = False\n                        continue\n                if piece.y + i < board.size and ne_check:\n                    if target.x == piece.x + i and target.y == piece.y + i:\n                        if target.color == piece.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        ne_check = False\n    return ff, kill\n\nclass Queen(Piece):\n    def __init__(self, board, color, x, y):\n        Piece.__init__(self, board, color, x, y)\n\n    def count_targets(self):\n        ff_hv, kill_hv = count_hv_targets(self.board, self)\n        ff_diag, kill_diag = count_diag_targets(self.board, self)\n        return ff_hv + ff_diag, kill_hv + kill_diag\n\nclass Rook(Piece):\n    def __init__(self, board, color, x, y):\n        Piece.__init__(self, board, color, x, y)\n\n    def count_targets(self):\n        return count_hv_targets(self.board, self)\n\nclass Bishop(Piece):\n    def __init__(self, board, color, x, y):\n        Piece.__init__(self, board, color, x, y)\n\n    def count_targets(self):\n        return count_diag_targets(self.board, self)\n\nclass Knight(Piece):\n    def __init__(self, board, color, x, y):\n        Piece.__init__(self, board, color, x, y)\n\n    def count_targets(self):\n        ff = 0\n        kill = 0\n        for target in self.board.pieces:\n            if target == self:\n                continue\n            if self.x - 2 >= 0:\n                if self.y - 1 >= 0:\n                    if target.x == self.x - 2 and target.y == self.y - 1:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n                if self.y + 1 < self.board.size:\n                    if target.x == self.x - 2 and target.y == self.y + 1:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n            if self.x - 1 >= 0:\n                if self.y - 2 >= 0:\n                    if target.x == self.x - 1 and target.y == self.y - 2:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n                if self.y + 2 < self.board.size:\n                    if target.x == self.x - 1 and target.y == self.y + 2:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n            if self.x + 1 < self.board.size:\n                if self.y - 2 >= 0:\n                    if target.x == self.x + 1 and target.y == self.y - 2:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n                if self.y + 2 < self.board.size:\n                    if target.x == self.x + 1 and target.y == self.y + 2:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n            if self.x + 2 < self.board.size:\n                if self.y - 1 >= 0:\n                    if target.x == self.x + 2 and target.y == self.y - 1:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n                        continue\n                if self.y + 1 < self.board.size:\n                    if target.x == self.x + 2 and target.y == self.y + 1:\n                        if target.color == self.color:\n                            ff += 1\n                        else:\n                            kill += 1\n        return ff, kill\n\n# main function\ndef main_solution(board_size, pieces):\n    # Convert JSON serializable inputs to original input variables\n    board = Board(board_size)\n    for piece in pieces:\n        piece_class = None\n        if piece[\"type\"] == \"Queen\":\n            piece_class = Queen\n        elif piece[\"type\"] == \"Rook\":\n            piece_class = Rook\n        elif piece[\"type\"] == \"Bishop\":\n            piece_class = Bishop\n        elif piece[\"type\"] == \"Knight\":\n            piece_class = Knight\n        board.add_piece(piece_class(board, piece[\"color\"], piece[\"x\"], piece[\"y\"]))\n\n    # Resolve conflicts and count targets\n    board.conflict_resolve()\n    ff_tot, kill_tot = board.count_total_targets()\n\n    # Convert outputs to JSON serializable format\n    return {\"friendly_fire\": ff_tot, \"kills\": kill_tot}", "input_generator": "import random\nfrom random import randint, choice\n\ndef input_generator():\n    board_size = random.randint(4, 10)\n    piece_types = [\"Queen\", \"Rook\", \"Bishop\", \"Knight\"]\n    num_pieces = random.randint(2, min(10, board_size * 2))\n    \n    pieces = []\n    for _ in range(num_pieces):\n        piece = {\n            \"type\": choice(piece_types),\n            \"color\": random.choice([True, False]),\n            \"x\": randint(0, board_size - 1),\n            \"y\": randint(0, board_size - 1)\n        }\n        pieces.append(piece)\n    \n    return {\"board_size\": board_size, \"pieces\": pieces}", "io_pairs": [], "error_log": []}
{"context": "Given a positive integer \\( D \\), find the minimal solution for \\( x \\) in the equation \\( x^2 - D \\cdot y^2 = 1 \\). What is the value of \\( x \\) for a randomly chosen \\( D \\) between 1 and 1000?\n\nThe input and output requirements are as follows:\n\nInput:\n  `D` (int): An integer representing the value for which we want to find the minimal solution of the equation \\( x^2 - D \\cdot y^2 = 1 \\).\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `\"D\"` (int): The input value `D`.\n    - `\"x\"` (int or None): The minimal solution for `x` in the equation \\( x^2 - D \\cdot y^2 = 1 \\). If no solution exists, `x` will be `None`.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef pattern(n):\n    digits = []\n    a0 = math.floor(math.sqrt(n))\n    d = 1\n    m = 0\n    a = a0\n    i = 1\n    \n    while True:\n        m_prev = m\n        d_prev = d\n        \n        m = (d_prev*a) - m_prev\n        d = (n - (m**2))/d_prev\n        \n        a = math.floor((a0 + m)/d)\n        digits.append(a)\n        \n        if a == 2*a0:\n            return a0, digits\n        \n        i += 1\n\ndef gen_c(n, num):\n    first, rep = pattern(n)\n    times = math.ceil(num/len(rep))\n    output = [first]\n    for i in range(0, times-1):\n        output.extend(rep)\n    return output\n\ndef test_sol(n, x, y):\n    return ((x**2) - (n * (y**2))) == 1\n\n# main function\ndef main_solution(D):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    squares = [j**2 for j in range(1, 101)]\n    if D in squares:\n        return {\"D\": D, \"x\": None}\n    \n    coeffs = gen_c(D, 100)\n    hm1 = 1\n    hm2 = 0\n    km1 = 0\n    km2 = 1\n    \n    for a in coeffs:\n        hn = (a * hm1) + hm2 \n        kn = (a * km1) + km2\n        hm2 = hm1\n        hm1 = hn\n        km2 = km1\n        km1 = kn\n        \n        if test_sol(D, hn, kn):\n            return {\"D\": D, \"x\": hn}\n    \n    return {\"D\": D, \"x\": None}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    squares = [j**2 for j in range(1, 101)]\n    non_squares = [d for d in range(2, 101) if d not in squares]\n    D = random.choice(non_squares)\n    return {\"D\": D}", "io_pairs": [{"input": {"D": 24}, "output": {"D": 24, "x": 5}}, {"input": {"D": 47}, "output": {"D": 47, "x": 48}}, {"input": {"D": 52}, "output": {"D": 52, "x": 649}}, {"input": {"D": 33}, "output": {"D": 33, "x": 23}}, {"input": {"D": 73}, "output": {"D": 73, "x": 2281249}}, {"input": {"D": 70}, "output": {"D": 70, "x": 251}}, {"input": {"D": 61}, "output": {"D": 61, "x": 1766319049}}, {"input": {"D": 5}, "output": {"D": 5, "x": 9}}, {"input": {"D": 63}, "output": {"D": 63, "x": 8}}, {"input": {"D": 6}, "output": {"D": 6, "x": 5}}], "error_log": []}
{"context": "Imagine a group of people standing in a circle. Starting from the first person, every nth person is removed from the circle. This process continues until only one person remains. Given the number of people in the circle and the nth person to be removed, which person will be the last one standing?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_people` (int): The number of people standing in a circle.\n  `kill_every` (int): The nth person to be removed from the circle.\n\nOutput:\n  `return` (dict): A dictionary containing the key \"survivor\" with the value being the number of the last person remaining in the circle.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    \"\"\"Class Node\"\"\"\n    def __init__(self, data, next=None):\n        self.data = data\n        self.next = next\n\n    def __repr__(self):\n        return \"<Node data={0}>\".format(self.data)\n\nclass Circle_ll(object):\n    \"\"\"Class Circle Linked Linked\"\"\"\n    def __init__(self):\n        self.head = None\n\n    def insert(self, node):\n        if self.head == None:\n            self.head = node\n            node.next = self.head\n        else:\n            curr = self.head\n            while curr.next != self.head:\n                curr=curr.next\n            node.next = curr.next\n            curr.next = node\n\n    def remove(self, data):\n        # data is in head and circle linked list has only 1 node.\n        # Remove head. Empty circle linked list\"\n        if self.head.data == data and self.head.next == self.head:\n            self.head = None\n            return\n\n        curr = self.head\n        # data is in head. Remove node which is head, move head to the next node\n        if self.head.data == data:\n            new_head = self.head.next\n            while curr.next != self.head:\n                curr = curr.next\n            self.head = new_head\n            curr.next = self.head\n        else:\n        # data is in inner node. Remove this node\n            while curr.data != data:\n                prev = curr\n                curr = curr.next\n            prev.next = curr.next\n\ndef find_survivor(num_people, kill_every):\n    \"\"\"Given num_people in circle, kill [kill_every]th person, return survivor.\"\"\"\n\n    # Create circle linked list with size = num.people\n    my_circle_ll = Circle_ll()\n    for i in range(num_people):\n        my_circle_ll.insert(Node(i+1))\n\n    # Remove each kill_every node until circle linked list will have 1 node\n    curr = my_circle_ll.head\n    while curr != curr.next:\n        for i in range(kill_every - 1):\n            # If we will every 3rd person, we'll skip over two\n            curr = curr.next\n        my_circle_ll.remove(curr.data)\n        curr = curr.next\n\n    return my_circle_ll.head.data\n\n# main function\ndef main_solution(num_people, kill_every):\n    # Convert JSON serializable inputs to the original input variables\n    num_people = int(num_people)\n    kill_every = int(kill_every)\n\n    # Call the function to find the survivor\n    survivor = find_survivor(num_people, kill_every)\n\n    # Convert the output to JSON serializable\n    return {\"survivor\": survivor}", "input_generator": "import random\n\ndef input_generator():\n    num_people = random.randint(2, 100)\n    kill_every = random.randint(2, 10)\n    return {\"num_people\": num_people, \"kill_every\": kill_every}", "io_pairs": [{"input": {"num_people": 72, "kill_every": 4}, "output": {"survivor": 14}}, {"input": {"num_people": 39, "kill_every": 2}, "output": {"survivor": 15}}, {"input": {"num_people": 79, "kill_every": 7}, "output": {"survivor": 76}}, {"input": {"num_people": 61, "kill_every": 4}, "output": {"survivor": 39}}, {"input": {"num_people": 45, "kill_every": 5}, "output": {"survivor": 41}}, {"input": {"num_people": 81, "kill_every": 7}, "output": {"survivor": 10}}, {"input": {"num_people": 89, "kill_every": 4}, "output": {"survivor": 82}}, {"input": {"num_people": 88, "kill_every": 6}, "output": {"survivor": 85}}, {"input": {"num_people": 53, "kill_every": 5}, "output": {"survivor": 34}}, {"input": {"num_people": 99, "kill_every": 8}, "output": {"survivor": 89}}], "error_log": []}
{"context": "You have two buckets with capacities of `n` liters and `m` liters, respectively. You need to measure exactly `d` liters using these two buckets. What is the minimum number of steps required to achieve this? If it is not possible to measure the desired amount, what should be returned?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The capacity of the first bucket in liters.\n  `m` (int): The capacity of the second bucket in liters.\n  `d` (int): The desired amount of liters to be measured in the second bucket.\n\nOutput:\n  `return` (int): The minimum number of steps required to measure the desired amount of liters in the second bucket. If it is not possible to measure the desired amount, it returns `-1`.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef Pour(toJugCap, fromJugCap, d):\n    fromJug = fromJugCap\n    toJug = 0\n    step = 1\n    while ((fromJug != d) and (toJug != d)):\n        temp = min(fromJug, toJugCap - toJug)\n        toJug = toJug + temp\n        fromJug = fromJug - temp\n        step = step + 1\n\n        if ((fromJug == d) or (toJug == d)):\n            break\n        elif fromJug == 0:\n            fromJug = fromJugCap\n            step = step + 1\n        if toJug == toJugCap:\n            toJug = 0\n            step = step + 1\n    return step\n\ndef minSteps(n, m, d):\n    if m > n:\n        temp = m\n        m = n\n        n = temp\n\n    if (d % (gcd(n, m)) != 0):\n        return -1\n    return min(Pour(n, m, d), Pour(m, n, d))\n\n# main function\ndef main_solution(n, m, d):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = minSteps(n, m, d)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(1, 100)\n    m = random.randint(1, 100)\n    max_d = max(n, m)\n    d = random.randint(1, max_d)\n    \n    # Ensure d is a multiple of gcd(n, m) to make it solvable\n    current_gcd = math.gcd(n, m)\n    if d % current_gcd != 0:\n        d = random.randint(1, max_d // current_gcd) * current_gcd\n    \n    return {'n': n, 'm': m, 'd': d}", "io_pairs": [{"input": {"n": 89, "m": 97, "d": 65}, "output": 12}, {"input": {"n": 10, "m": 48, "d": 14}, "output": 26}, {"input": {"n": 18, "m": 48, "d": 12}, "output": 4}, {"input": {"n": 31, "m": 48, "d": 27}, "output": 66}, {"input": {"n": 49, "m": 19, "d": 27}, "output": 10}, {"input": {"n": 25, "m": 10, "d": 15}, "output": 2}, {"input": {"n": 89, "m": 94, "d": 79}, "output": 8}, {"input": {"n": 75, "m": 81, "d": 42}, "output": 26}, {"input": {"n": 53, "m": 11, "d": 43}, "output": 60}, {"input": {"n": 90, "m": 39, "d": 81}, "output": 24}], "error_log": []}
{"context": "Given a square matrix, what is the rank of the matrix when calculated using the Gauss method? The rank of a matrix is defined as the maximum number of linearly independent row vectors in the matrix.\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_data` (list of lists of numbers): A 2D list representing the matrix. Each inner list represents a row of the matrix.\n\nOutput:\n  `return` (int): The rank of the matrix calculated using the Gauss method.", "reference_code": "# import necessary packages\nimport numbers\nimport itertools\nimport copy\nfrom fractions import Fraction\n\n# all class and function definitions in the code file, if any\nclass Matrice:\n    \n    def __init__(this, matrice):\n        this.matrice = []\n        this.altezza = 0\n        this.larghezza = 0\n        this.setMatrice(matrice)\n        \n    def setMatrice(this, matrice):       \n        this.altezza = len(matrice)\n        this.larghezza = len(matrice[0])\n        for i in matrice:\n            if len(i) != this.larghezza:\n                this.altezza = 0\n                this.larghezza = 0\n                raise Exception(\"numero colonne eterogeneo\")\n        this.matrice = matrice\n\n    def __add__(this, matrice):\n        if matrice == 0:\n            return this\n        if this.larghezza != matrice.larghezza or this.altezza != matrice.altezza:\n            raise Exception(\"ops le matrici non sono compatibili: \\n\"+ str(this) + str(matrice))\n        retMat = []\n        for i in range(0, this.altezza):\n            tmp = []\n            for j in range(0, this.larghezza):\n                tmp.append(this.matrice[i][j] + matrice.matrice[i][j])\n            retMat.append(tmp)\n        return Matrice(retMat)\n    \n    def __radd__(this, altroOggetto):\n        return this.__add__(altroOggetto)\n    \n    def __mul__(this, matrice):\n        retMat = []\n        if not isinstance(matrice, (numbers.Number, Matrice)):\n            raise Exception(\"Puoi moltiplicare per un numero o per una matrice.\")\n        if isinstance(matrice, numbers.Number):\n            for i in range(0, this.altezza):\n                tmp = []\n                for j in range(0, this.larghezza):\n                    tmp.append(this.matrice[i][j]*matrice)\n                retMat.append(tmp)\n        else:\n            if this.larghezza != matrice.altezza:\n                raise Exception(\"ops le matrici non sono compatibili\")\n            for i in range(0, this.altezza):\n                tmp = []\n                for j in range(0, matrice.larghezza):\n                    temp = 0\n                    for k in range(0, this.larghezza):\n                        temp = temp + this.matrice[i][k]*matrice.matrice[k][j]\n                    tmp.append(temp)\n                retMat.append(tmp)\n        return Matrice(retMat)\n    \n    def __rmul__(this, altroOggetto):\n        return this.__mul__(altroOggetto)\n    \n    def __str__(this):\n        tmp = \"\"\n        for i in range(0, this.altezza):\n            for j in range(0, this.larghezza):\n                tmp = tmp + str(this.matrice[i][j]) + \"\\t\"\n            tmp = tmp + \"\\n\"\n        return tmp\n    \n    def __repr__(this):\n        return this.__str__()\n    \n    def complementa(this, riga, colonna):\n        ret = []\n        for i in range(0, this.larghezza):\n            if i != riga:\n                temp = []\n                for j in range(0, this.altezza):\n                    if j != colonna:\n                        temp.append(this.matrice[i][j])\n                ret.append(temp)\n        return Matrice(ret).clona()\n    \n    @property\n    def determinante(this):\n        if this.altezza != this.larghezza:\n            raise Exception(\"ops, la matrice non \u00e8 quadrata\")\n        if this.altezza == 1:\n            return  float(this.matrice[0][0])\n        else:\n            det = 0\n            for i in range(0, this.larghezza):\n                det = det + pow(-1, i) * this.matrice[0][i] * this.complementa(0,i).determinante\n            return det\n    \n    @property\n    def trasposta(this):\n        ret = []\n        for j in range(0,this.larghezza):\n            tmp = []\n            for i in range(0, this.altezza):\n                tmp.append(this.matrice[i][j])\n            ret.append(tmp)\n        return Matrice(ret).clona()\n\n    def __getitem__(this, k):\n        return this.matrice.__getitem__(k)\n    \n    def __setitem__(this, k, j):\n        this.matrice.__setitem__(k, j)\n    \n    @property\n    def rango_minori(this):\n        rango = 0\n        if this.altezza == this.larghezza:\n            if this.determinante != 0:\n                return this.altezza\n            if this.determinante == 0 and this.altezza == 1:\n                return 0\n            else:                \n                for i in range(0,this.altezza):\n                    for j in range(0,this.altezza):\n                        tmp = this.complementa(i, j).rango_minori\n                        if tmp > rango:\n                            rango = tmp               \n        else:\n            if this.altezza < this.larghezza:\n                return this.trasposta.rango_minori\n            else:                \n                for i in itertools.combinations(this.matrice, this.larghezza):\n                    tmp = Matrice(i).rango_minori\n                    if tmp > rango:\n                        rango = tmp\n        return rango\n        \n    @property\n    def rango_gauss(this):\n        tmp = this.clona()\n        tmp.riduciAScala()\n        intRango = tmp.larghezza if tmp.larghezza < tmp.altezza else tmp.altezza\n        nullo = [0 for x in range(0,tmp.larghezza)]\n        for riga in tmp.matrice:\n            if riga == nullo:\n                intRango -= 1;\n        return intRango\n                \n    def riduciAScala(this, indice = 0):\n        if this.altezza > this.larghezza:\n            this.setMatrice(this.trasposta.matrice)\n        if this.altezza > indice:            \n            if this[indice][indice] == 0:\n                trovato = False\n                for i in range(indice + 1,this.altezza):\n                    if this[i][indice] != 0:\n                        this[i], this[indice] = this[indice],this[i]\n                        trovato = True\n                        break\n                if not(trovato):\n                    this.riduciAScala(indice + 1)\n                    return\n            for i in range(indice + 1,this.altezza):\n                azzeratore = Fraction(-this[i][indice],this[indice][indice])\n                for j in range(indice, this.larghezza):\n                    this[i][j] = this[i][j]+azzeratore*this[indice][j]\n            this.riduciAScala(indice + 1)\n        \n    def clona(this):\n        return Matrice(copy.deepcopy(this.matrice))\n\n# main function\ndef main_solution(matrix_data):\n    # Convert JSON serializable input to Matrice object\n    matrix = Matrice(matrix_data)\n    \n    # Calculate the rank of the matrix using the Gauss method\n    rank = matrix.rango_gauss\n    \n    # Return the rank as a JSON serializable output\n    return rank", "input_generator": "import random\nimport copy\n\ndef input_generator():\n    # Randomly decide the dimensions of the matrix (between 1x1 and 5x5)\n    rows = random.randint(1, 5)\n    cols = random.randint(1, 5)\n    \n    # Randomly decide if the matrix should be full rank or not\n    full_rank = random.choice([True, False])\n    \n    # Generate a matrix\n    matrix = []\n    if full_rank:\n        # Generate a full rank matrix\n        for i in range(rows):\n            row = []\n            for j in range(cols):\n                # Ensure linear independence for full rank\n                if i == j and i < min(rows, cols):\n                    row.append(random.randint(1, 5))\n                else:\n                    row.append(random.randint(0, 5))\n            matrix.append(row)\n    else:\n        # Generate a matrix that may not be full rank\n        for i in range(rows):\n            row = []\n            for j in range(cols):\n                row.append(random.randint(0, 5))\n            matrix.append(row)\n        # Introduce linear dependence with 50% chance\n        if rows > 1 and cols > 1 and random.choice([True, False]):\n            # Make one row a linear combination of others\n            r1, r2 = random.sample(range(rows), 2)\n            scalar = random.randint(1, 3)\n            matrix[r2] = [scalar * x for x in matrix[r1]]\n    \n    return {'matrix_data': matrix}", "io_pairs": [{"input": {"matrix_data": [[5], [2]]}, "output": 1}, {"input": {"matrix_data": [[5, 3, 2, 5], [1, 1, 5, 1], [2, 5, 2, 3], [5, 0, 0, 3], [4, 3, 3, 0]]}, "output": 4}, {"input": {"matrix_data": [[4, 3], [5, 5], [0, 3], [3, 0]]}, "output": 2}, {"input": {"matrix_data": [[4, 1, 4, 0, 3], [1, 3, 0, 0, 0]]}, "output": 2}, {"input": {"matrix_data": [[3, 5]]}, "output": 1}, {"input": {"matrix_data": [[5, 2], [3, 5]]}, "output": 2}, {"input": {"matrix_data": [[5, 0, 1, 3], [5, 5, 4, 5], [2, 2, 5, 3], [2, 4, 1, 5]]}, "output": 4}, {"input": {"matrix_data": [[3], [1], [5], [2]]}, "output": 1}, {"input": {"matrix_data": [[2, 4], [0, 0], [3, 3], [1, 3], [5, 4]]}, "output": 2}, {"input": {"matrix_data": [[0, 1], [0, 1]]}, "output": 2}], "error_log": []}
{"context": "Given a list of integers, a balanced binary search tree (ABR) is constructed using these integers. A specific integer is then searched for within both the tree and the original list. How many iterations are required to determine the existence of this integer in both the tree and the list, and does the integer exist in both structures?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data_list` (list of int): A list of integers representing the data to be used to construct the balanced binary search tree.\n  `node_to_find` (int): An integer representing the node to be searched for in both the tree and the list.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `exists_in_tree` (bool): True if the node exists in the tree, False otherwise.\n    - `iterations_tree` (int): The number of iterations taken to determine the existence of the node in the tree.\n    - `exists_in_list` (bool): True if the node exists in the list, False otherwise.\n    - `iterations_list` (int): The number of iterations taken to determine the existence of the node in the list.", "reference_code": "# import necessary packages\nfrom random import randint\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, data):\n        if type(data) == list:\n            self.data = None\n            self.left = None\n            self.right = None\n            listeTriee = sorted(data)\n            self.indexMediane = int(len(listeTriee)/2)\n            if listeTriee != []:\n                self.data = listeTriee[self.indexMediane]\n            gauche = listeTriee[0:self.indexMediane]\n            droite = listeTriee[self.indexMediane+1:len(data)]\n            if gauche != []:\n                self.left = Node(gauche)\n            if droite != []:\n                self.right = Node(droite)\n        elif type(data) == int:\n            self.data = data\n            self.left = None\n            self.right = None\n\n    def add_node(self, data):\n        if data < self.data:\n            if self.left is None:\n                self.left = Node(data)\n            else:\n                self.left.add_node(data)\n        elif data > self.data:\n            if self.right is None:\n                self.right = Node(data)\n            else:\n                self.right.add_node(data)\n\n    def listeTri\u00e9e(self, res=[]):\n        if self.left:\n            self.left.listeTri\u00e9e()\n        res.append(self.data)\n        if self.right:\n            self.right.listeTri\u00e9e()\n        return res\n\n    def existe(self, noeudATrouver, compteur=0):\n        compteur = compteur + 1\n        if self.data == noeudATrouver:\n            return True, compteur\n        elif self.data > noeudATrouver:\n            if self.left is not None:\n                return self.left.existe(noeudATrouver, compteur)\n            else:\n                return False, compteur\n        elif self.data < noeudATrouver:\n            if self.right is not None:\n                return self.right.existe(noeudATrouver, compteur)\n            else:\n                return False, compteur\n\ndef existeList(Liste, objetATrouver):\n    for i in range(0, len(Liste)):\n        if Liste[i] == objetATrouver:\n            return True, i\n    return False, len(Liste)\n\n# main function\ndef main_solution(data_list, node_to_find):\n    # Convert JSON serializable inputs to original input variables\n    data_list = list(data_list)\n    node_to_find = int(node_to_find)\n\n    # Create the balanced binary search tree\n    abr = Node(data_list)\n\n    # Check if the node exists in the tree\n    exists_in_tree, iterations_tree = abr.existe(node_to_find)\n\n    # Check if the node exists in the list\n    exists_in_list, iterations_list = existeList(data_list, node_to_find)\n\n    # Return the results as JSON serializable outputs\n    return {\n        \"exists_in_tree\": exists_in_tree,\n        \"iterations_tree\": iterations_tree,\n        \"exists_in_list\": exists_in_list,\n        \"iterations_list\": iterations_list\n    }", "input_generator": "import random\nfrom random import randint, sample\n\ndef input_generator():\n    # Generate a random list of integers with reasonable size (e.g., between 5 and 20 elements)\n    list_size = randint(5, 20)\n    data_list = sample(range(1, 100), list_size)\n    \n    # Randomly decide whether to include the node_to_find in the list or not\n    if random.random() < 0.5:\n        node_to_find = random.choice(data_list)\n    else:\n        node_to_find = randint(1, 100)\n    \n    return {\n        \"data_list\": data_list,\n        \"node_to_find\": node_to_find\n    }", "io_pairs": [{"input": {"data_list": [2, 58, 20, 72, 53, 21, 49, 14, 68, 9, 30, 4], "node_to_find": 87}, "output": {"exists_in_tree": false, "iterations_tree": 3, "exists_in_list": false, "iterations_list": 12}}, {"input": {"data_list": [51, 41, 22, 26, 62, 15, 12, 65, 1, 81, 80, 11, 34], "node_to_find": 26}, "output": {"exists_in_tree": true, "iterations_tree": 3, "exists_in_list": true, "iterations_list": 3}}, {"input": {"data_list": [79, 12, 98, 94, 96, 10, 69, 22, 46, 40], "node_to_find": 46}, "output": {"exists_in_tree": true, "iterations_tree": 3, "exists_in_list": true, "iterations_list": 8}}, {"input": {"data_list": [95, 73, 59, 71, 69, 49, 96, 34, 85, 58, 76], "node_to_find": 4}, "output": {"exists_in_tree": false, "iterations_tree": 4, "exists_in_list": false, "iterations_list": 11}}, {"input": {"data_list": [58, 57, 28, 15, 64, 67, 45, 69, 55, 18, 89, 9, 88], "node_to_find": 6}, "output": {"exists_in_tree": false, "iterations_tree": 4, "exists_in_list": false, "iterations_list": 13}}, {"input": {"data_list": [54, 95, 68, 28, 33, 69, 78, 55, 77, 35, 92, 42], "node_to_find": 42}, "output": {"exists_in_tree": true, "iterations_tree": 2, "exists_in_list": true, "iterations_list": 11}}, {"input": {"data_list": [51, 64, 7, 84, 69, 36, 83, 80, 52, 42], "node_to_find": 51}, "output": {"exists_in_tree": true, "iterations_tree": 4, "exists_in_list": true, "iterations_list": 0}}, {"input": {"data_list": [90, 19, 80, 75, 64, 8, 16, 59, 22, 49, 89, 85, 78, 2, 42, 20], "node_to_find": 42}, "output": {"exists_in_tree": true, "iterations_tree": 3, "exists_in_list": true, "iterations_list": 14}}, {"input": {"data_list": [99, 95, 68, 51, 8, 24], "node_to_find": 8}, "output": {"exists_in_tree": true, "iterations_tree": 3, "exists_in_list": true, "iterations_list": 4}}, {"input": {"data_list": [9, 39, 86, 41, 85, 90, 21, 76, 62], "node_to_find": 22}, "output": {"exists_in_tree": false, "iterations_tree": 3, "exists_in_list": false, "iterations_list": 9}}], "error_log": []}
{"context": "Given a test example represented as a sparse feature map and a set of labeled training examples, each also represented as a sparse feature map, how can we determine the cosine similarity between the test example and each training example, and what are the corresponding labels for these similarities?\n\nThe input and output requirements are as follows:\n\nInput:\n  `test_example_str` (str): A string representing the test example in the format \"{key1=value1, key2=value2, ...}\".\n  `training_examples` (list of str): A list of strings, each representing a training example in the format \"label\\t{key1=value1, key2=value2, ...}\".\n\nOutput:\n  `return` (list of tuple): A list of tuples where each tuple contains the cosine similarity (float) and the label (str) of the training example.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\ndef parse_str_to_map(inp):\n    \"\"\"\n    Given the sparse representation of an example as a string,\n    parse it into a HashMap.\n\n    \"{1=2, 3=4}\" --> HashMap w. {1 -> 2, 3 -> 4}\n    \"\"\"\n\n    feature_map = {}\n\n    kv_pairs = inp.split(\",\")\n    kv_pairs[0] = kv_pairs[0][1:]\n    kv_pairs[-1] = kv_pairs[-1][:-1]\n\n    for kv in kv_pairs:\n        pieces = kv.split(\"=\")\n        key = pieces[0].strip()\n        value = pieces[1].strip()\n        feature_map[key] = int(value)\n\n    return feature_map\n\n\ndef cosine_similarity(test_ex_map, train_ex_map):\n    \"\"\"\n    For two feature maps, compute their cosine similarity.\n    CS(a, b) = dot_prod(a, b) / (norm(a) * norm(b))\n    \"\"\"\n\n    # compute denominator\n    cosine_numerator = 0\n    train_sum = 0\n\n    for (feature_idx, feature_count) in train_ex_map.items():\n        if feature_idx in test_ex_map:\n            cosine_numerator += (test_ex_map[feature_idx] * train_ex_map[feature_idx])\n        train_sum += (feature_count * feature_count)\n\n    test_sum = 0\n    for (feature_idx, feature_count) in test_ex_map.items():\n        test_sum += (feature_count * feature_count)\n\n    cosine_denominator = math.sqrt(train_sum) * math.sqrt(test_sum)\n    return (cosine_numerator * 1.0) / cosine_denominator\n\n# main function\ndef main_solution(test_example_str, training_examples):\n    \"\"\"\n    Compute the cosine similarity between a test example and a list of training examples.\n\n    Args:\n    test_example_str (str): A string representing the test example in the format \"{key1=value1, key2=value2, ...}\".\n    training_examples (list of str): A list of strings, each representing a training example in the format \"label\\t{key1=value1, key2=value2, ...}\".\n\n    Returns:\n    list of tuple: A list of tuples where each tuple contains the cosine similarity (float) and the label (str) of the training example.\n    \"\"\"\n\n    # Parse the test example into a feature map\n    test_ex_feature_map = parse_str_to_map(test_example_str)\n\n    results = []\n\n    for example in training_examples:\n        # Split the example into label and feature map\n        pieces = example.split(\"\\t\")\n        label = pieces[0]\n        feature_map = parse_str_to_map(pieces[1])\n\n        # Compute the cosine similarity\n        cosine_sim = cosine_similarity(test_ex_feature_map, feature_map)\n\n        # Append the result as a tuple (cosine_sim, label)\n        results.append((cosine_sim, label))\n\n    return results", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random test example string\n    test_keys = random.sample(range(1, 20), random.randint(2, 5))\n    test_values = [random.randint(1, 10) for _ in test_keys]\n    test_pairs = [f\"{k}={v}\" for k, v in zip(test_keys, test_values)]\n    test_example_str = \"{\" + \", \".join(test_pairs) + \"}\"\n    \n    # Generate random training examples\n    training_examples = []\n    num_examples = random.randint(3, 7)\n    for _ in range(num_examples):\n        label = ''.join(random.choices(string.ascii_uppercase, k=3))\n        train_keys = random.sample(range(1, 20), random.randint(2, 5))\n        train_values = [random.randint(1, 10) for _ in train_keys]\n        train_pairs = [f\"{k}={v}\" for k, v in zip(train_keys, train_values)]\n        train_example = label + \"\\t{\" + \", \".join(train_pairs) + \"}\"\n        training_examples.append(train_example)\n    \n    return {\n        \"test_example_str\": test_example_str,\n        \"training_examples\": training_examples\n    }", "io_pairs": [{"input": {"test_example_str": "{8=9, 5=1, 12=2, 11=8, 9=5}", "training_examples": ["YAG\t{13=5, 8=1, 2=1, 5=3, 1=10}", "LZS\t{7=8, 15=9, 18=9, 12=3}", "YDN\t{3=9, 18=1, 5=7}", "DCG\t{9=4, 12=6}"]}, "output": [[0.07778444682625972, "YAG"], [0.029586820363292275, "LZS"], [0.04623207306786785, "YDN"], [0.33545114775101387, "DCG"]]}, {"input": {"test_example_str": "{17=3, 10=2, 16=7, 14=9}", "training_examples": ["VWD\t{11=10, 12=3}", "DHM\t{4=6, 13=8, 15=6}", "MES\t{15=3, 11=5, 7=10}"]}, "output": [[0.0, "VWD"], [0.0, "DHM"], [0.0, "MES"]]}, {"input": {"test_example_str": "{2=3, 16=8, 18=4}", "training_examples": ["EGZ\t{4=8, 16=8, 10=5}", "PWM\t{3=1, 7=10, 17=5, 10=2, 6=4}", "SXX\t{15=5, 4=7, 5=8}"]}, "output": [[0.5484527965109982, "EGZ"], [0.0, "PWM"], [0.0, "SXX"]]}, {"input": {"test_example_str": "{3=6, 15=4, 18=5, 14=3}", "training_examples": ["EPW\t{1=1, 14=5, 4=7}", "VAB\t{2=4, 13=5, 17=9, 10=4}", "FHJ\t{10=3, 3=7, 2=6, 6=10, 9=7}", "JLK\t{15=2, 2=3, 7=9, 1=3, 18=10}"]}, "output": [[0.18677184190940707, "EPW"], [0.0, "VAB"], [0.2905339763035221, "FHJ"], [0.43896586416295774, "JLK"]]}, {"input": {"test_example_str": "{14=5, 1=10, 6=7, 7=9}", "training_examples": ["YPV\t{12=8, 14=1, 8=5, 17=5, 7=5}", "JVS\t{4=9, 2=10, 3=7, 9=6}", "AYF\t{12=5, 15=5, 7=2}", "OBI\t{16=7, 6=2}", "DYX\t{12=4, 5=8, 6=10, 2=2}"]}, "output": [[0.26462806201248157, "YPV"], [0.0, "JVS"], [0.15339299776947407, "AYF"], [0.12042593049455379, "OBI"], [0.32316107064257854, "DYX"]]}, {"input": {"test_example_str": "{2=9, 3=9}", "training_examples": ["YCM\t{7=6, 11=2, 9=9}", "KLW\t{9=6, 5=9, 12=6}", "XZQ\t{14=2, 12=8, 8=4, 10=7}", "AWD\t{16=5, 19=7, 9=3, 18=10}", "SLW\t{17=6, 1=2, 6=5, 4=9, 9=6}"]}, "output": [[0.0, "YCM"], [0.0, "KLW"], [0.0, "XZQ"], [0.0, "AWD"], [0.0, "SLW"]]}, {"input": {"test_example_str": "{11=8, 5=1, 7=9, 2=9}", "training_examples": ["XWJ\t{14=9, 17=1, 3=8, 4=7}", "BBE\t{5=3, 10=5, 17=10, 13=10}", "VTL\t{13=7, 17=6, 18=3, 6=3}", "CJJ\t{14=8, 13=2, 6=7, 7=8, 8=10}", "CXI\t{6=7, 2=7}", "ODJ\t{17=4, 7=6, 5=7}"]}, "output": [[0.0, "XWJ"], [0.013016685067210314, "BBE"], [0.0, "VTL"], [0.2850797753447753, "CJJ"], [0.4223909290175389, "CXI"], [0.40286192122129616, "ODJ"]]}, {"input": {"test_example_str": "{15=10, 10=6, 18=4, 17=10}", "training_examples": ["LWS\t{15=3, 13=8, 5=7}", "FHR\t{17=7, 19=5}", "OSZ\t{7=6, 3=9, 14=6}"]}, "output": [[0.17109647770728872, "LWS"], [0.5126039043577045, "FHR"], [0.0, "OSZ"]]}, {"input": {"test_example_str": "{16=1, 13=9, 5=1, 15=7}", "training_examples": ["XFK\t{2=5, 7=7, 14=4, 3=8, 16=2}", "OAD\t{9=3, 14=6, 5=4, 2=5, 17=1}", "UXZ\t{17=7, 19=10}", "HSW\t{5=7, 13=4}", "NYJ\t{8=6, 18=2, 12=1}"]}, "output": [[0.013848874720779208, "XFK"], [0.03732616739705695, "OAD"], [0.0, "UXZ"], [0.46422103086909533, "HSW"], [0.0, "NYJ"]]}, {"input": {"test_example_str": "{19=7, 17=1, 16=3, 1=6}", "training_examples": ["FGM\t{14=6, 5=2, 1=1, 18=5, 2=6}", "XIT\t{15=1, 13=2}", "QWJ\t{7=9, 15=8}", "NDE\t{11=9, 6=8, 19=1, 15=3, 7=2}", "HGR\t{14=1, 11=5, 8=5, 2=3}"]}, "output": [[0.06095219666786237, "FGM"], [0.0, "XIT"], [0.0, "QWJ"], [0.05695576313235339, "NDE"], [0.0, "HGR"]]}], "error_log": []}
{"context": "Given a string of data, what are the Shannon entropy and Kolmogorov complexity values?\n\nThe input and output requirements are as follows:\n\nInput:\n  `data` (str): A string representing the data for which the Shannon entropy and Kolmogorov complexity are to be calculated. If the string is empty or `None`, it will be replaced with a single space character.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `shannon_entropy` (float): The Shannon entropy of the input data.\n    - `kolmogorov_complexity` (float): The Kolmogorov complexity of the input data, approximated by the compression rate.", "reference_code": "# import necessary packages\nimport zlib\nfrom math import log\n\n# main function\ndef main_solution(data):\n    # Convert the input data to a bytearray if it's not None or empty\n    if data is None or data == '':\n        data = ' '\n    \n    data = bytearray(data, 'utf-8')\n\n    # Calculate Shannon entropy\n    dataSize = len(data)\n    ent = 0.0\n    for i in range(256):\n        freq = float(data.count(i)) / dataSize\n        if freq > 0:\n            ent = ent + freq * log(freq, 2)\n    shannon_entropy = -ent\n\n    # Calculate Kolmogorov complexity\n    l = float(len(data))\n    compr = zlib.compress(data)\n    c = float(len(compr)) / l\n    kolmogorov_complexity = 1.0 if c > 1 else c\n\n    # Return the results as a dictionary\n    return {\n        \"shannon_entropy\": shannon_entropy,\n        \"kolmogorov_complexity\": kolmogorov_complexity\n    }", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random length for the string between 10 and 100 characters\n    length = random.randint(10, 100)\n    \n    # Choose a random type of data: alphanumeric, letters only, digits only, or mixed with symbols\n    data_type = random.choice(['alphanumeric', 'letters', 'digits', 'mixed'])\n    \n    if data_type == 'alphanumeric':\n        chars = string.ascii_letters + string.digits\n    elif data_type == 'letters':\n        chars = string.ascii_letters\n    elif data_type == 'digits':\n        chars = string.digits\n    else:\n        chars = string.ascii_letters + string.digits + string.punctuation\n    \n    # Generate the random string\n    data = ''.join(random.choice(chars) for _ in range(length))\n    \n    # Occasionally return an empty string or None\n    if random.random() < 0.1:\n        data = '' if random.random() < 0.5 else None\n    \n    return {'data': data}", "io_pairs": [{"input": {"data": "2562494452726766960189351471535730697226885501344024172745433181059671"}, "output": {"shannon_entropy": 3.275172931528364, "kolmogorov_complexity": 0.7571428571428571}}, {"input": {"data": "8k8Y0LlyJTjAcAm6sisYaIe1THNGgFzpYnbOgUrm55heUohWYbWkysVGovk4GyXPVXNZD9uAF1e0WVqCh7LREqKMPM4i"}, "output": {"shannon_entropy": 5.558409917801892, "kolmogorov_complexity": 1.0}}, {"input": {"data": "tQWMti14uNwB8LMTCar8LaNjVj8NOsu"}, "output": {"shannon_entropy": 4.260332600569877, "kolmogorov_complexity": 1.0}}, {"input": {"data": "9DcXmuCHDnvG49IMUQg1l4dppiPcqTHuzuQ2z5x9MpLygeww7BrMdJFJzTan7Jk5wcJeJcTmx5w"}, "output": {"shannon_entropy": 5.123567317301467, "kolmogorov_complexity": 1.0}}, {"input": {"data": "sSEOasaApnO6IGDTv9XXLjPKhCqYJlayWICKNLxk0O96OcddPTS6C6wbccJagOz8FGZNpj9aJ0fJvrC"}, "output": {"shannon_entropy": 5.205944596870768, "kolmogorov_complexity": 1.0}}, {"input": {"data": "[5s$A}$3U>w"}, "output": {"shannon_entropy": 3.2776134368191165, "kolmogorov_complexity": 1.0}}, {"input": {"data": "ZvmRbIjRmJeapIvFFavZSSeIhZvJKzZKJyYHwPQVxUtxIpKuzBCyrUUdQLxgTbIKLhYTVqoJrDoYfYncwTNraIQTOwjqH"}, "output": {"shannon_entropy": 5.205405047481067, "kolmogorov_complexity": 1.0}}, {"input": {"data": "xRnkn3GnbFuzPKSd09TFX3tzih6XZv3H"}, "output": {"shannon_entropy": 4.515319531114783, "kolmogorov_complexity": 1.0}}, {"input": {"data": "AIun7yMoTt5YNh6ONxecTX8vf5uP9oY3HxXgC2MQVNLG8DfAB"}, "output": {"shannon_entropy": 5.068691731826158, "kolmogorov_complexity": 1.0}}, {"input": {"data": "cLXybMETsWfakmsSqZgCgXdEZgmlzMQZKxVEuobNtQUcBVqUAPknnsiNHzdlWLwswKtJEj"}, "output": {"shannon_entropy": 5.193429088311723, "kolmogorov_complexity": 1.0}}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, given the current state of the 3x3 board, what is the optimal move for player 'O' to make next? The board is represented by a 3x3 grid where each cell can be either empty (' '), occupied by 'O', or occupied by 'X'. The goal is to determine the best move for 'O' to maximize their chances of winning or at least securing a draw.\n\nThe input and output requirements are as follows:\n\nInput:\n  `tablero_table` (list of lists of strings): A 3x3 grid representing the Tic-Tac-Toe board. Each cell can be either ' ', 'O', or 'X'.\n\nOutput:\n  `return` (dictionary): A dictionary containing the best move for the next player ('O') to make. The dictionary has a single key `\"best_move\"` whose value is a tuple `(int, int)` representing the row and column indices of the best move.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Tablero:\n    def __init__(self, table):\n        self.table = table\n\n    def victoriaJugador(self, jugador):\n        # Check rows, columns, and diagonals for a win\n        for row in self.table:\n            if all(cell == jugador for cell in row):\n                return True\n        for col in range(3):\n            if all(self.table[row][col] == jugador for row in range(3)):\n                return True\n        if all(self.table[i][i] == jugador for i in range(3)):\n            return True\n        if all(self.table[i][2 - i] == jugador for i in range(3)):\n            return True\n        return False\n\n    def getMoves(self):\n        moves = []\n        for i in range(3):\n            for j in range(3):\n                if self.table[i][j] == ' ':\n                    moves.append((i, j))\n        return moves\n\n# main function\ndef main_solution(tablero_table):\n    # Convert the JSON serializable input to the original input variables\n    tablero = Tablero(tablero_table)\n    moves = tablero.getMoves()\n    \n    # Call the original function\n    best_move = minMaxMejorJugada(tablero, moves)\n    \n    # Convert the output to JSON serializable\n    return {\"best_move\": best_move}\n\n# Original functions from the code file\njugador1, jugador2 = 'O', 'X'\n\ndef minmax(tablero, profundidad, isMax):\n    score = 10 if tablero.victoriaJugador(jugador1) else -10\n\n    if score == 10:\n        return score\n    if score == -10:\n        return score\n    moves = tablero.getMoves()\n    if len(moves) == 0:\n        return 0\n\n    if isMax:\n        best = -1000\n        for i in moves:\n            tablero.table[i[0]][i[1]] = jugador1\n            best = max(best, minmax(tablero, profundidad + 1, not isMax))\n            tablero.table[i[0]][i[1]] = ' '\n        return best\n    else:\n        best = 1000\n        for i in moves:\n            tablero.table[i[0]][i[1]] = jugador2\n            best = min(best, minmax(tablero, profundidad + 1, not isMax))\n            tablero.table[i[0]][i[1]] = ' '\n        return best\n\ndef minMaxMejorJugada(tablero, moves):\n    bestVal = -1000\n    bestMove = (-1, -1)\n    for i in moves:\n        tablero.table[i[0]][i[1]] = jugador1\n        moveVal = minmax(tablero, 0, False)\n        tablero.table[i[0]][i[1]] = ' '\n        if moveVal > bestVal:\n            bestMove = (i[0], i[1])\n            bestVal = moveVal\n    return bestMove", "input_generator": "import random\n\ndef input_generator():\n    # Initialize a 3x3 board with empty spaces\n    tablero_table = [[' ' for _ in range(3)] for _ in range(3)]\n    \n    # Randomly decide the number of moves already made (between 0 and 8)\n    num_moves = random.randint(0, 8)\n    players = ['O', 'X']\n    current_player = 0\n    \n    for _ in range(num_moves):\n        # Get all possible empty cells\n        empty_cells = [(i, j) for i in range(3) for j in range(3) if tablero_table[i][j] == ' ']\n        if not empty_cells:\n            break\n        # Randomly select an empty cell\n        i, j = random.choice(empty_cells)\n        tablero_table[i][j] = players[current_player]\n        current_player = 1 - current_player\n    \n    return {\"tablero_table\": tablero_table}", "io_pairs": [{"input": {"tablero_table": [[" ", " ", " "], ["X", "O", " "], [" ", " ", " "]]}, "output": {"best_move": [0, 0]}}, {"input": {"tablero_table": [[" ", "X", " "], ["X", "O", " "], ["O", " ", " "]]}, "output": {"best_move": [0, 2]}}, {"input": {"tablero_table": [[" ", " ", "X"], [" ", " ", " "], [" ", " ", "O"]]}, "output": {"best_move": [0, 0]}}, {"input": {"tablero_table": [[" ", " ", " "], [" ", " ", " "], ["X", " ", "O"]]}, "output": {"best_move": [0, 0]}}, {"input": {"tablero_table": [[" ", " ", " "], [" ", " ", "O"], [" ", " ", " "]]}, "output": {"best_move": [0, 0]}}, {"input": {"tablero_table": [[" ", " ", " "], [" ", " ", " "], [" ", " ", " "]]}, "output": {"best_move": [0, 0]}}, {"input": {"tablero_table": [["X", "O", "O"], ["X", " ", "X"], ["O", "X", "O"]]}, "output": {"best_move": [1, 1]}}, {"input": {"tablero_table": [[" ", "X", "O"], ["O", " ", " "], ["O", "X", " "]]}, "output": {"best_move": [0, 0]}}, {"input": {"tablero_table": [[" ", " ", " "], ["O", " ", " "], [" ", " ", " "]]}, "output": {"best_move": [0, 0]}}, {"input": {"tablero_table": [[" ", "O", " "], [" ", " ", " "], [" ", "X", "O"]]}, "output": {"best_move": [0, 0]}}], "error_log": []}
{"context": "In a card game, players can place cards on either build piles or discard piles according to specific rules. Given a card `play_card`, a `build_pile`, and a `discard_pile`, determine if the `play_card` can be legally placed on either pile. Additionally, specify if the play is valid and whether it ends the player's turn. What are the results of attempting to place the `play_card` on both the `build_pile` and the `discard_pile`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `play_card` (str): A string representing a card in the format \"value+suit\", e.g., \"2H\" for 2 of Hearts.\n  `build_pile` (list): A list of strings representing the cards in the build pile.\n  `discard_pile` (list): A list of strings representing the cards in the discard pile.\n  `player_no` (int): An integer representing the player number.\n  `to_player_no` (int): An integer representing the player number to whom the card is being played.\n  `from_hand` (bool): A boolean indicating whether the card is being played from the hand (True) or not (False).\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `build_match` (bool): True if the `play_card` can be legally placed on the `build_pile`, False otherwise.\n    - `discard_match` (int): 0 if the play is invalid, 1 if the play is a valid non-turn-ending play, 2 if the play is a valid turn-ending play.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nreal_values = {'A': 1, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,\n               '8': 8, '9': 9, '0': 10, 'J': 11, 'Q': 12, 'K': 13}\n\nsuit_colour = {'S': 'Black', 'C': 'Black', 'D': 'Red', 'H': 'Red'}\n\ndef value(card):\n    '''Returns the value symbol of the card'''\n    return card[0]\n\ndef suit(card):\n    '''Returns the suit of the card'''\n    return card[1]\n\ndef same_colour(card1, card2):\n    '''\n    Returns True if card1 and card2 are of same colour and False otherwise\n    '''\n    return suit_colour[suit(card1)] == suit_colour[suit(card2)]\n      \ndef adjacent(card1, card2, pile_type):\n    '''\n    (str, str, str) --> (bool)\n    \n    pile_type takes the value 'D' or 'B' if either of card1 or card 2 is from a\n    discard pile or build pile respectively. Returns True if card1 and card2 \n    are adjacent according to adjacency rules for pile_type'''\n    \n    if pile_type == 'B':\n        #Cant loop between '2' and 'K' in build pile\n        return abs(real_values[value(card1)] - real_values[value(card2)]) == 1\n    elif pile_type == 'D':\n        #Can loop between '2' and 'K' in discard pile\n        return abs(real_values[value(card1)] - real_values[value(card2)]) == 1\\\n               or (value(card1), value(card2)) == ('2', 'K') \\\n               or (value(card1), value(card2)) == ('K', '2')\n    \ndef top_card(pile):\n    '''Returns the string representation of the top card of pile if the pile\n       is non-empty. Returns None otherwise.'''\n    if len(pile) == 0:\n        return None\n    else:\n        return pile[-1]\n    \ndef comp10001bo_match_build(play_card, build_pile):\n    \"\"\"\n    Returns True if 'play_card' can be legally placed on 'build_pile' and \n    False otherwise.\n    \"\"\"\n    \n    #Check if build pile empty\n    if len(build_pile) == 0:\n        build_empty = True\n    else:\n        build_empty = False\n        \n    #only '2' and 'K' can initiate empty build pile\n    if build_empty:\n        return value(play_card) == '2' or value(play_card) == 'K'\n    \n    #if build pile not empty\n    else:\n        \n        #can play same colour ace on build pile regardless of value of top card\n        #of build pile\n        if value(play_card) == 'A':\n            return same_colour(play_card, top_card(build_pile))\n        \n        #for non-ace cards\n        else:\n            #cant play non-adjacent card\n            if not(adjacent(play_card, top_card(build_pile), 'B')):\n                return False\n            \n            #cant play different colour card\n            elif not(same_colour(play_card, top_card(build_pile))):\n                return False\n            \n            #can play same colour adjacent value card\n            return True\n\ndef comp10001bo_match_discard(play_card, discard_pile, player_no, to_player_no,\n                              from_hand=True):\n    \"\"\"\n    (str, list, int, int, bool) --> (int)\n    \n    Returns 0 if the play is invalid, 1 if the play is a valid non-turn-ending\n    play, 2 if the play is a valid turn-ending play.\n    \"\"\"\n        \n    #Aces cant be played on discard pile\n    if value(play_card) == 'A':\n        return INVALID_PLAY\n    \n    #check if or if not pile is empty\n    pile_empty = (len(discard_pile) == 0)\n    \n    #check if playing to own discard pile or not\n    own_pile = (player_no == to_player_no)\n    \n    #only starting own discard pile possible if discard_pile is empty\n    if pile_empty:\n        \n        #Check if starting own discard pile\n        if own_pile and from_hand:\n            return VALID_FINAL_PLAY\n    \n    #illegal move and placing card on discard pile possible if discard_pile\n    #is not empty\n    else:\n        \n        #Check if illegal move (placing same colour card)\n        if same_colour(play_card, top_card(discard_pile)):\n            if from_hand:\n                return VALID_FINAL_PLAY\n           \n        else:\n            #Check if illegal move (placing non-adjacent value card)\n            if not adjacent(play_card, top_card(discard_pile), 'D'):\n                if from_hand:\n                    return VALID_FINAL_PLAY\n            \n            #alternate colour and adjacent value mean placing card on\n            #discard_pile possbile without terminating turn\n            else:\n                return VALID_NONFINAL_PLAY\n    \n    #if none of the above, no valid play is possible\n    return INVALID_PLAY\n\n# build pile play types\nINVALID_PLAY = 0\nVALID_NONFINAL_PLAY = 1\nVALID_FINAL_PLAY = 2\nNO_PLAY = 3\n\n# main function\ndef main_solution(play_card, build_pile, discard_pile, player_no, to_player_no, from_hand=True):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # Check if the play_card can be legally placed on the build_pile\n    build_match = comp10001bo_match_build(play_card, build_pile)\n    \n    # Check if the play_card can be legally placed on the discard_pile\n    discard_match = comp10001bo_match_discard(play_card, discard_pile, player_no, to_player_no, from_hand)\n    \n    # Return the result as a dictionary\n    return {\n        \"build_match\": build_match,\n        \"discard_match\": discard_match\n    }", "input_generator": "import random\n\ndef input_generator():\n    # Define possible card values and suits\n    values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'J', 'Q', 'K']\n    suits = ['S', 'C', 'D', 'H']\n    \n    # Generate a random play_card\n    play_card = random.choice(values) + random.choice(suits)\n    \n    # Generate a random build_pile (0 to 5 cards)\n    build_pile_size = random.randint(0, 5)\n    build_pile = []\n    for _ in range(build_pile_size):\n        build_pile.append(random.choice(values) + random.choice(suits))\n    \n    # Generate a random discard_pile (0 to 5 cards)\n    discard_pile_size = random.randint(0, 5)\n    discard_pile = []\n    for _ in range(discard_pile_size):\n        discard_pile.append(random.choice(values) + random.choice(suits))\n    \n    # Generate random player numbers (0 to 3)\n    player_no = random.randint(0, 3)\n    to_player_no = random.randint(0, 3)\n    \n    # Randomly decide if from_hand\n    from_hand = random.choice([True, False])\n    \n    return {\n        \"play_card\": play_card,\n        \"build_pile\": build_pile,\n        \"discard_pile\": discard_pile,\n        \"player_no\": player_no,\n        \"to_player_no\": to_player_no,\n        \"from_hand\": from_hand\n    }", "io_pairs": [{"input": {"play_card": "3C", "build_pile": [], "discard_pile": [], "player_no": 2, "to_player_no": 3, "from_hand": false}, "output": {"build_match": false, "discard_match": 0}}, {"input": {"play_card": "2C", "build_pile": ["9C"], "discard_pile": [], "player_no": 1, "to_player_no": 1, "from_hand": false}, "output": {"build_match": false, "discard_match": 0}}, {"input": {"play_card": "3D", "build_pile": [], "discard_pile": [], "player_no": 2, "to_player_no": 0, "from_hand": false}, "output": {"build_match": false, "discard_match": 0}}, {"input": {"play_card": "6H", "build_pile": [], "discard_pile": [], "player_no": 3, "to_player_no": 3, "from_hand": false}, "output": {"build_match": false, "discard_match": 0}}, {"input": {"play_card": "2H", "build_pile": ["7C"], "discard_pile": [], "player_no": 0, "to_player_no": 0, "from_hand": true}, "output": {"build_match": false, "discard_match": 2}}, {"input": {"play_card": "5D", "build_pile": [], "discard_pile": ["2D"], "player_no": 3, "to_player_no": 1, "from_hand": false}, "output": {"build_match": false, "discard_match": 0}}, {"input": {"play_card": "5H", "build_pile": [], "discard_pile": ["3D"], "player_no": 1, "to_player_no": 3, "from_hand": false}, "output": {"build_match": false, "discard_match": 0}}, {"input": {"play_card": "9C", "build_pile": [], "discard_pile": ["7D"], "player_no": 1, "to_player_no": 1, "from_hand": true}, "output": {"build_match": false, "discard_match": 2}}, {"input": {"play_card": "5H", "build_pile": [], "discard_pile": [], "player_no": 2, "to_player_no": 2, "from_hand": true}, "output": {"build_match": false, "discard_match": 2}}, {"input": {"play_card": "6H", "build_pile": ["7S"], "discard_pile": [], "player_no": 2, "to_player_no": 2, "from_hand": true}, "output": {"build_match": false, "discard_match": 2}}], "error_log": []}
{"context": "Given two linked lists with cycles, determine if they intersect. If they intersect, return `True`; otherwise, return `False`. The linked lists are represented by lists of integers where each integer represents the value of a node in the linked list. The problem requires checking for intersections in the context of cyclic linked lists.\n\nThe input and output requirements are as follows:\n\nInput:\n  `list1` (list of int): A list representing the values of the nodes in the first linked list.\n  `list2` (list of int): A list representing the values of the nodes in the second linked list.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the two linked lists intersect.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass ChkIntersection:\n    def chkInter(self, head1, head2):\n        # write code here\n        p1, p2 = head1, head2\n        Loop1 = self.chkinCir(p1)\n        Loop2 = self.chkinCir(p2)\n        if Loop1 == Loop2:\n            return True\n\n        cur = Loop1.next\n        while cur != Loop1:\n            if cur == Loop2:\n                return True\n            else:\n                cur = cur.next\n\n        return self.getCirInsec(head1, head2, Loop1, Loop2)\n\n    def getCirInsec(self, head1, head2, loop1, loop2):\n        lenA = self.getlength(head1, loop1)\n        lenB = self.getlength(head2, loop2)\n\n        if lenA > lenB:\n            for _ in range(lenA - lenB):\n                head1 = head1.next\n        else:\n            for _ in range(lenB - lenA):\n                head2 = head2.next\n\n        for _ in range(min(lenA, lenB)):\n            if head1 == head2:\n                return True\n            else:\n                head1 = head1.next\n                head2 = head2.next\n        return False\n\n    def chkinCir(self, head):\n        fast = head\n        slow = head\n        while fast and fast.next:\n            fast = fast.next.next if fast.next else None\n            slow = slow.next\n            # \u7b2c\u4e00\u6b21\u5224\u5b9a\u662f \u786e\u5b9a\u6709\u73af\n            if fast == slow:\n                return slow\n\n    def getlength(self, head, end):\n        length = 0\n        while head != end:\n            length += 1\n            head = head.next\n\n        return length\n\n# main function\ndef main_solution(list1, list2):\n    # Convert JSON serializable inputs to original input variables\n    def create_linked_list(data):\n        if not data:\n            return None\n        head = ListNode(data[0])\n        current = head\n        for val in data[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n\n    head1 = create_linked_list(list1)\n    head2 = create_linked_list(list2)\n\n    # Create a cycle in the linked list if specified\n    if len(list1) > 1:\n        head1.next.next.next = head1.next  # Creating a cycle for example\n    if len(list2) > 1:\n        head2.next.next.next = head2.next  # Creating a cycle for example\n\n    # Invoke the function that requires non-JSON serializable inputs\n    chk = ChkIntersection()\n    result = chk.chkInter(head1, head2)\n\n    # Return the result, which must be JSON serializable\n    return result", "input_generator": "import random\nimport json\n\ndef input_generator():\n    # Generate two linked lists with possible cycles and intersections\n    # Randomly decide if the lists should intersect or have cycles\n    intersect = random.choice([True, False])\n    has_cycle1 = random.choice([True, False])\n    has_cycle2 = random.choice([True, False])\n    \n    # Generate a common part if intersect is True\n    common_part = []\n    if intersect:\n        common_length = random.randint(1, 3)\n        common_part = [random.randint(1, 100) for _ in range(common_length)]\n    \n    # Generate list1\n    list1_length = random.randint(3, 6)\n    list1 = [random.randint(1, 100) for _ in range(list1_length)]\n    if intersect:\n        list1.extend(common_part)\n    \n    # Generate list2\n    list2_length = random.randint(3, 6)\n    list2 = [random.randint(1, 100) for _ in range(list2_length)]\n    if intersect:\n        list2.extend(common_part)\n    \n    # Randomly shuffle to make sure the common part is not always at the end\n    if intersect and random.choice([True, False]):\n        list1, list2 = list2, list1\n    \n    return {'list1': list1, 'list2': list2}", "io_pairs": [{"input": {"list1": [26, 91, 14, 47, 87, 23, 12], "list2": [36, 34, 32, 24, 87, 23, 12]}, "output": false}, {"input": {"list1": [20, 78, 45, 49, 64, 32, 45], "list2": [13, 41, 91, 63, 42, 45]}, "output": false}, {"input": {"list1": [85, 77, 59, 3, 45, 19, 97, 68, 30], "list2": [33, 72, 33, 48, 97, 68, 30]}, "output": false}, {"input": {"list1": [96, 87, 15, 20, 92, 64, 26], "list2": [28, 1, 97, 95, 72, 26]}, "output": false}, {"input": {"list1": [25, 99, 18], "list2": [52, 19, 29, 57]}, "output": false}, {"input": {"list1": [84, 25, 98, 67, 54], "list2": [27, 58, 94]}, "output": false}, {"input": {"list1": [79, 74, 15, 24, 86], "list2": [37, 62, 29, 92, 30, 48]}, "output": false}, {"input": {"list1": [89, 45, 43, 27, 96, 97, 3], "list2": [8, 33, 17, 35, 3]}, "output": false}, {"input": {"list1": [100, 31, 2, 4, 49, 2], "list2": [44, 8, 28, 67, 21, 60]}, "output": false}, {"input": {"list1": [79, 37, 15, 86, 22], "list2": [94, 32, 41, 22]}, "output": false}], "error_log": []}
{"context": "Given a set of coins with denominations of 1p, 2p, 5p, 10p, 20p, 50p, 100p, and 200p, how many unique ways can you break down a specified amount of money in pence using these coins?\n\nThe input and output requirements are as follows:\n\nInput:\n  `amount` (int): The total amount of money in pence that needs to be broken down into coins.\n\nOutput:\n  `return` (int): The total number of unique ways the amount can be broken down using the available coins.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef breakIntoCoins(amount, coin, usedCoins, count):\n    myAmount = amount\n    myUsedCoins = list(usedCoins)\n    \n    if coin > 0:        \n        myAmount -= coin\n        myUsedCoins.append(coin)\n\n    if myAmount == 0:\n        count[0] += 1\n    else:\n        for newCoin in [c for c in coins if c <= amount and c >= coin]:\n            breakIntoCoins(myAmount, newCoin, myUsedCoins, count)\n\n# main function\ndef main_solution(amount):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    global coins\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    count = [0]  # Using a list to hold the count to make it mutable\n    \n    # Convert JSON serializable input to original input variables\n    amount = int(amount)\n    \n    # Invoke the function that requires non-json serializable inputs\n    breakIntoCoins(amount, 0, [], count)\n    \n    # Convert the result to JSON serializable output\n    final_count = count[0]\n    \n    # Return the final output\n    return final_count", "input_generator": "import random\n\ndef input_generator():\n    amount = random.choice([10, 20, 50, 100, 200, 500, 1000])\n    return {'amount': amount}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a function \\( f(x) = \\sin(x) \\cdot e^{-x^2} \\), we want to approximate it using a polynomial of a certain degree over a specified range of x values. What are the coefficients of the polynomial that best fits the function over the given range?\n\nThe input and output requirements are as follows:\n\nInput:\n  `datasize_n` (int): The number of data points to generate for the input range.\n  `degree_d` (int): The degree of the polynomial to fit.\n  `x_range` (list of two floats): The range of x values to consider, specified as [start, end].\n\nOutput:\n  `return` (list of floats): The coefficients of the polynomial fit, ordered from highest degree to lowest.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(datasize_n, degree_d, x_range):\n    # Convert JSON serializable inputs to original input variables\n    X = np.linspace(x_range[0], x_range[1], datasize_n)\n    \n    # Function to be approximated\n    def sin_x_exp_negx_squared(x_input):\n        return np.sin(x_input) * np.exp(-x_input**2)\n    \n    # Perform polynomial fitting\n    p1 = np.polyfit(X, sin_x_exp_negx_squared(X), degree_d)\n    \n    # Convert output to JSON serializable format\n    coefficients = p1.tolist()\n    \n    return coefficients", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    datasize_n = random.randint(10, 100)\n    degree_d = random.randint(1, 10)\n    x_min = random.uniform(-5.0, 0.0)\n    x_max = random.uniform(0.0, 5.0)\n    x_range = [x_min, x_max]\n    return {\n        'datasize_n': datasize_n,\n        'degree_d': degree_d,\n        'x_range': x_range\n    }", "io_pairs": [{"input": {"datasize_n": 30, "degree_d": 7, "x_range": [-1.999103395490902, 4.725313882872549]}, "output": [0.0014916089401246235, -0.015398454502685684, 0.03515021514709751, 0.08573149960476681, -0.3149525965963721, -0.10088214430717594, 0.6180646213523542, 0.009592323947977224]}, {"input": {"datasize_n": 59, "degree_d": 5, "x_range": [-3.3521671925436483, 4.013351255672914]}, "output": [0.003063129722865238, -0.0025273676693378737, -0.05768370321165299, 0.02380883620066229, 0.2502874116370181, -0.024260369596094008]}, {"input": {"datasize_n": 69, "degree_d": 10, "x_range": [-0.8602522635763492, 0.8981891126528685]}, "output": [-0.0021259400579602436, 0.04672727458846134, 0.003585714552314494, -0.24008610515726822, -0.0020802457113272147, 0.6692965588057576, 0.00048187600683181046, -1.1659393215510871, -3.796399748786361e-05, 0.9999740496221617, 4.6029267974958634e-07]}, {"input": {"datasize_n": 33, "degree_d": 8, "x_range": [-1.346887612883148, 4.159685919343681]}, "output": [-0.002047243989903217, 0.026447725018559465, -0.11428828519831809, 0.12583736098389317, 0.34203773456525716, -0.7367410409825665, -0.24328320691985827, 0.8978388573871566, 0.023614170404542837]}, {"input": {"datasize_n": 100, "degree_d": 1, "x_range": [-2.563042154414106, 1.033953576748789]}, "output": [0.11182528626580636, 0.05409881817672747]}, {"input": {"datasize_n": 83, "degree_d": 6, "x_range": [-4.830383250689376, 0.7098492787625826]}, "output": [-0.005796150218180952, -0.07387930358712097, -0.31516622228911767, -0.41855185191041716, 0.3205417277765068, 0.7817446490575849, -0.028963414193798172]}, {"input": {"datasize_n": 75, "degree_d": 8, "x_range": [-0.3134589684423137, 0.6739887896535562]}, "output": [0.08897616893706828, -0.28350961441337175, -0.011507211211143337, 0.6810082937052877, 0.0002245612419548344, -1.1670052327116878, 7.346790296066164e-06, 1.0000047445453337, -5.868721361645882e-08]}, {"input": {"datasize_n": 70, "degree_d": 4, "x_range": [-4.05073132244717, 0.12143760819876726]}, "output": [0.046604125566106776, 0.41921785577725157, 1.2162507766064825, 1.1223088212814805, -0.02772776045998186]}, {"input": {"datasize_n": 47, "degree_d": 3, "x_range": [-3.813728911301693, 2.195070975540172]}, "output": [-0.014491950863231516, -0.012193059956573537, 0.1262704319770571, 0.0301852464852464]}, {"input": {"datasize_n": 75, "degree_d": 6, "x_range": [-4.863074776623045, 2.4462134578901655]}, "output": [0.0015160740334871786, 0.009726113261406558, -0.009727706244840113, -0.12038357935530643, -0.0034435564833853716, 0.3677936287800822, 0.020045742070262277]}], "error_log": []}
{"context": "In a city with a grid layout, police officers need to be strategically placed to maximize the number of activity points collected from scooter routes. Each cell in the grid can have multiple scooter routes passing through it, and each officer can be assigned to a specific cell. Officers cannot be placed in cells that are in the same row, column, or diagonal. Given the size of the city grid, the number of officers, and the coordinates of the scooter routes, what is the maximum number of activity points that can be collected by optimally placing the officers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `scale` (int): The size of the city area (n x n grid).\n  `officers` (int): The number of officers to be assigned.\n  `scooters` (int): The number of scooter routes.\n  `scooter_routes` (list of tuples): A list of tuples where each tuple represents the coordinates (x, y) of a scooter route.\n\nOutput:\n  `return` (int): The maximum number of activity points collected by assigning the officers to the optimal positions.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef DFS_search(x, y, ans, num, map, officers, scale, visited, max_value):\n    num += 1\n    ans += map[x][y]\n    if num >= officers:\n        if ans > max_value[0]:\n            max_value[0] = ans\n        return\n    for x_next in range(scale):\n        check = 0\n        for y_used in range(num):\n            x_used = visited[y_used]\n            if x_next == x_used or abs(y + 1 - y_used) == abs(x_next - x_used):\n                check = 1\n                break\n        if check == 0:\n            visited[num] = x_next\n            DFS_search(x_next, y + 1, ans, num, map, officers, scale, visited, max_value)\n            visited[num] = -1\n\n# main function\ndef main_solution(scale, officers, scooters, scooter_routes):\n    # Convert scooter_routes to a 2D list (map)\n    map = [[0 for _ in range(scale)] for _ in range(scale)]\n    for route in scooter_routes:\n        x, y = route\n        map[x][y] += 1\n    \n    max_value = [0]  # Using a list to store max_value to make it mutable\n    for x_in in range(scale):\n        visited = [-1 for _ in range(scale)]\n        visited[0] = x_in\n        ans = 0\n        DFS_search(x_in, 0, ans, 0, map, officers, scale, visited, max_value)\n    \n    return max_value[0]", "input_generator": "import random\n\ndef input_generator():\n    scale = random.randint(4, 10)\n    officers = random.randint(1, scale)\n    scooters = random.randint(1, scale * 2)\n    scooter_routes = [(random.randint(0, scale - 1), random.randint(0, scale - 1)) for _ in range(scooters)]\n    return {\n        'scale': scale,\n        'officers': officers,\n        'scooters': scooters,\n        'scooter_routes': scooter_routes\n    }", "io_pairs": [{"input": {"scale": 7, "officers": 2, "scooters": 4, "scooter_routes": [[6, 1], [0, 3], [5, 2], [4, 4]]}, "output": 1}, {"input": {"scale": 9, "officers": 2, "scooters": 4, "scooter_routes": [[8, 0], [8, 3], [8, 6], [2, 4]]}, "output": 1}, {"input": {"scale": 8, "officers": 1, "scooters": 4, "scooter_routes": [[6, 6], [7, 4], [7, 0], [7, 6]]}, "output": 1}, {"input": {"scale": 4, "officers": 1, "scooters": 2, "scooter_routes": [[1, 3], [0, 3]]}, "output": 0}, {"input": {"scale": 6, "officers": 1, "scooters": 3, "scooter_routes": [[3, 4], [2, 4], [0, 4]]}, "output": 0}, {"input": {"scale": 7, "officers": 4, "scooters": 1, "scooter_routes": [[3, 6]]}, "output": 0}, {"input": {"scale": 6, "officers": 3, "scooters": 4, "scooter_routes": [[2, 0], [5, 5], [5, 4], [5, 2]]}, "output": 2}, {"input": {"scale": 4, "officers": 1, "scooters": 3, "scooter_routes": [[2, 0], [1, 0], [0, 0]]}, "output": 1}, {"input": {"scale": 6, "officers": 2, "scooters": 1, "scooter_routes": [[2, 5]]}, "output": 0}, {"input": {"scale": 7, "officers": 2, "scooters": 2, "scooter_routes": [[1, 1], [0, 3]]}, "output": 1}], "error_log": []}
{"context": "Given a position in a sequence, an amount of money, and a nested list, determine the nth element of the ping-pong sequence, the number of ways to make change for the given amount using powers of 2, and the flattened version of the nested list. What are the results for these three calculations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The position in the ping-pong sequence.\n  `amount` (int): The amount for which to count the number of ways to make change.\n  `lst` (str): A string representation of a nested list that needs to be flattened.\n\nOutput:\n  `return` (dict): A dictionary containing the results of the three functions:\n    - `pingpong_result` (int): The nth element of the ping-pong sequence.\n    - `count_change_result` (int): The number of ways to make change for the given amount.\n    - `flatten_result` (list): A flattened version of the input list.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef num_sevens(n):\n    if n == 0:\n        return 0\n    else:\n        if n % 10 == 7:\n            return 1 + num_sevens(n // 10)\n        else:\n            return 0 + num_sevens(n // 10)\n\ndef pingpong(n):\n    return pingpong_helper(n, 0, 1, True)\n\ndef pingpong_helper(n, i, count, flag):\n    if flag:\n        i += 1\n    else:\n        i -= 1\n    if count == n:\n        return i\n    else:\n        if num_sevens(count) != 0 or count % 7 == 0:\n            flag = not flag\n        return pingpong_helper(n, i, count + 1, flag)\n\ndef count_change(amount):\n    m = int(math.log2(amount))\n    return count_partitions(amount, m)\n\ndef count_partitions(amount, m):\n    if amount == 0:\n        return 1\n    elif amount < 0:\n        return 0\n    elif m == 0:\n        return 1\n    else:\n        return count_partitions(amount - math.pow(2, m), m) + count_partitions(amount, m - 1)\n\ndef flatten(lst):\n    s = []\n    flatten_helper(lst, s)\n    return s\n\ndef flatten_helper(lst, s):\n    for x in lst:\n        if type(x) != list:\n            s += [x]\n        else:\n            flatten_helper(x, s)\n\n# main function\ndef main_solution(n, amount, lst):\n    # Convert JSON serializable inputs to original input variables\n    n = int(n)\n    amount = int(amount)\n    lst = eval(lst)  # Convert string representation of list to actual list\n\n    # Invoke the functions\n    pingpong_result = pingpong(n)\n    count_change_result = count_change(amount)\n    flatten_result = flatten(lst)\n\n    # Convert results to JSON serializable outputs\n    return {\n        \"pingpong_result\": pingpong_result,\n        \"count_change_result\": count_change_result,\n        \"flatten_result\": flatten_result\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate n for pingpong (reasonable range to avoid excessive recursion)\n    n = random.randint(1, 50)\n    \n    # Generate amount for count_change (ensure it's positive and not too large)\n    amount = random.randint(1, 20)\n    \n    # Generate lst for flatten (create a nested list with reasonable depth and elements)\n    def generate_nested_list(depth):\n        if depth == 0:\n            return random.choice([random.randint(1, 10), random.choice(['a', 'b', 'c'])])\n        else:\n            return [generate_nested_list(depth - 1) for _ in range(random.randint(1, 3))]\n    \n    lst = generate_nested_list(random.randint(1, 3))\n    \n    return {\n        \"n\": str(n),\n        \"amount\": str(amount),\n        \"lst\": str(lst)\n    }", "io_pairs": [{"input": {"n": "11", "amount": "11", "lst": "[4, 10]"}, "output": {"pingpong_result": 3, "count_change_result": 14, "flatten_result": [4, 10]}}, {"input": {"n": "18", "amount": "16", "lst": "[['b', 2], [4, 'a', 'a']]"}, "output": {"pingpong_result": 2, "count_change_result": 36, "flatten_result": ["b", 2, 4, "a", "a"]}}, {"input": {"n": "18", "amount": "5", "lst": "[[9, 'c']]"}, "output": {"pingpong_result": 2, "count_change_result": 4, "flatten_result": [9, "c"]}}, {"input": {"n": "34", "amount": "12", "lst": "['c', 3]"}, "output": {"pingpong_result": 10, "count_change_result": 20, "flatten_result": ["c", 3]}}, {"input": {"n": "31", "amount": "2", "lst": "[['c', 3, 'a']]"}, "output": {"pingpong_result": 7, "count_change_result": 2, "flatten_result": ["c", 3, "a"]}}, {"input": {"n": "46", "amount": "14", "lst": "[7, 10]"}, "output": {"pingpong_result": 10, "count_change_result": 26, "flatten_result": [7, 10]}}, {"input": {"n": "13", "amount": "1", "lst": "[[['b', 3, 3], [2, 4, 6]], [[5]], [[3, 'c'], [9, 'a', 6], ['b']]]"}, "output": {"pingpong_result": 1, "count_change_result": 1, "flatten_result": ["b", 3, 3, 2, 4, 6, 5, 3, "c", 9, "a", 6, "b"]}}, {"input": {"n": "2", "amount": "11", "lst": "[[[2], [8]], [[10, 'b', 'a'], [7, 8], ['a', 'c', 'b']]]"}, "output": {"pingpong_result": 2, "count_change_result": 14, "flatten_result": [2, 8, 10, "b", "a", 7, 8, "a", "c", "b"]}}, {"input": {"n": "24", "amount": "13", "lst": "[2, 7]"}, "output": {"pingpong_result": 2, "count_change_result": 20, "flatten_result": [2, 7]}}, {"input": {"n": "5", "amount": "15", "lst": "[4, 10, 'b']"}, "output": {"pingpong_result": 5, "count_change_result": 26, "flatten_result": [4, 10, "b"]}}], "error_log": []}
{"context": "Given a string, how can we generate all possible unique permutations of its characters?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string for which permutations need to be generated.\n\nOutput:\n  `return` (str): A JSON-formatted string containing a list of all unique permutations of the input string.", "reference_code": "# import necessary packages\nimport json\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    data = list(input_string)\n    result = []\n\n    def Permu_1(data, i, length):\n        if i == length:\n            result.append(\"\".join(data))\n        else:\n            for j in range(i, length):\n                data[i], data[j] = data[j], data[i]\n                Permu_1(data, i + 1, length)\n                data[i], data[j] = data[j], data[i]\n\n    # Generate permutations\n    Permu_1(data, 0, len(data))\n\n    # Convert the result list to a JSON serializable format\n    return json.dumps(result)", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    input_string = ''.join(random.choice(string.ascii_letters) for _ in range(length))\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "Ef"}, "output": "[\"Ef\", \"fE\"]"}, {"input": {"input_string": "kW"}, "output": "[\"kW\", \"Wk\"]"}, {"input": {"input_string": "Gqp"}, "output": "[\"Gqp\", \"Gpq\", \"qGp\", \"qpG\", \"pqG\", \"pGq\"]"}, {"input": {"input_string": "zQ"}, "output": "[\"zQ\", \"Qz\"]"}, {"input": {"input_string": "Vy"}, "output": "[\"Vy\", \"yV\"]"}, {"input": {"input_string": "lo"}, "output": "[\"lo\", \"ol\"]"}, {"input": {"input_string": "q"}, "output": "[\"q\"]"}, {"input": {"input_string": "skL"}, "output": "[\"skL\", \"sLk\", \"ksL\", \"kLs\", \"Lks\", \"Lsk\"]"}, {"input": {"input_string": "sfF"}, "output": "[\"sfF\", \"sFf\", \"fsF\", \"fFs\", \"Ffs\", \"Fsf\"]"}, {"input": {"input_string": "wg"}, "output": "[\"wg\", \"gw\"]"}], "error_log": []}
{"context": "In an ACM ICPC contest, contestants submit solutions to various problems. Each submission is recorded with the contestant's number, the problem number, the time taken to submit, and the result (either correct 'C' or incorrect 'I'). The score for each contestant is calculated based on the number of problems solved and the total time taken, including penalties for incorrect submissions. Given a list of submissions, how can we determine the final score for each contestant?\n\nThe input and output requirements are as follows:\n\nInput:\n  `user_inputs` (list of str): A list of strings where each string represents a submission in the format \"contestant problem time result\". Each string must contain exactly four space-separated values:\n    - `contestant` (int): The contestant number (between 1 and 10).\n    - `problem` (int): The problem number (between 1 and 100).\n    - `time` (int): The time taken to submit the problem.\n    - `result` (str): The result of the submission, either 'C' (correct) or 'I' (incorrect).\n\nOutput:\n  `return` (list of str): A list of strings where each string represents the score of a contestant in the format \"contestant solved_problems total_time\".\n    - `contestant` (int): The contestant number.\n    - `solved_problems` (int): The number of problems solved by the contestant.\n    - `total_time` (int): The total time taken by the contestant, including penalties for incorrect submissions.", "reference_code": "# import necessary packages\nfrom collections import defaultdict, namedtuple\nfrom itertools import groupby\nfrom operator import attrgetter\nimport random\n\n# all class and function definitions in the code file, if any\nclass Contestant:\n    def __init__(self, name, problems=[]):\n        \"\"\"\n        Attributes:\n            name = Int representing the name of the Contestant\n            contestant_problems = List of the Problems dided by the Contestant\n        \"\"\"\n        self.name = name\n        self.problems = problems\n        self.quantity_problems = 0\n        self.total_time = sum(self.problems)\n        for problem in self.problems:\n            if problem.solved:\n                self.quantity_problems += 1\n\n    def __repr__(self):\n        return '%s %s %s' % (self.name, self.quantity_problems, self.total_time)\n\nclass Problem:\n    def __init__(self, name, results=[]):\n        \"\"\"\n        Attributes:\n            name = Int representing the name of the Problem\n            results = List of the Inputs with the same Problem\n        \"\"\"\n        self.results = sorted(results, key=attrgetter('index'))\n        self.name = name\n        self.time = 0\n        self.solved = False\n        self.calculate_time()\n\n    def calculate_time(self):\n        \"\"\"\n        This method will calculate the total time that the problem tooked to be\n        solved. Will sum the 20 of penalty for all the incorrect Inputs until\n        find a correct result.\n        \"\"\"\n        for result in self.results:\n            if not self.solved:\n                if result.letter == 'C':\n                    self.solved = True\n                    self.time += result.time\n                    break\n                if result.letter == 'I':\n                    if result.time > 20:\n                        self.time += result.time\n                    else:\n                        self.time += 20\n\n    def __radd__(self, other):\n        \"\"\"\n        Method used to guide the class to do the sum(Problems).\n        If the problem is not solved, it does not represent penalty.\n        \"\"\"\n        if self.solved:\n            return other + self.time\n        else:\n            return other\n\ndef filter_inputs(user_inputs):\n    \"\"\"\n    Attributes:\n        user_inputs = List of the inputs\n    This is a filter of valid inputs.\n    Receive a list of inputs and will return only valid values of this.\n    The return is a namedtuple of a Input.\n    \"\"\"\n    inputs = []\n    for (index, user_input) in enumerate(user_inputs):\n        user_input = user_input.split(' ')\n        # Rule 1 - The input must have four arguments:\n        # Contestant, Problem, Time and the Result\n        if len(user_input) != 4:\n            continue\n        # Rule 2 - The contestant must be a number between 1 to 10\n        if not user_input[0].isdigit() or not int(user_input[0]) in range(1, 10):\n            continue\n        # Rule 3 - The problem must be a number between 1 to 100\n        if not user_input[1].isdigit() or not int(user_input[1]) in range(1, 100):\n            continue\n        # Rule 4 - The time must be just a number\n        if not user_input[2].isdigit():\n            continue\n        # Rule 5 - Will discart all the entries for results diferent then C or I\n        if not user_input[3] in ['C', 'I']:\n            continue\n        # The input that pass all the rules it is a valid Input\n        inputs.append(\n            namedtuple(\n                'Input',\n                'contestant, problem, time, letter index'\n            )._make(\n                (\n                    int(user_input[0]),\n                    int(user_input[1]),\n                    int(user_input[2]), user_input[3],\n                    index\n                )\n            )\n        )\n    return sorted(inputs, key=attrgetter('contestant', 'index'))\n\n# main function\ndef main_solution(user_inputs):\n    \"\"\"\n    This function processes the user inputs to calculate the score for each contestant.\n    \n    Input:\n        user_inputs (list of str): A list of strings where each string represents a submission in the format \"contestant problem time result\".\n    \n    Output:\n        list of str: A list of strings where each string represents the score of a contestant in the format \"contestant solved_problems total_time\".\n    \"\"\"\n    inputs = filter_inputs(user_inputs)\n    contestants = []\n    for (contestant, inputs) in groupby(inputs, lambda x: x.contestant):\n        problems = []\n        for (problem_name, results) in groupby(inputs, lambda x: x.problem):\n            problems.append(Problem(name=problem_name, results=results))\n        contestants.append(Contestant(name=contestant, problems=problems))\n    \n    return [contestant.__repr__() for contestant in contestants]", "input_generator": "import random\nfrom collections import namedtuple\n\ndef input_generator():\n    num_entries = random.randint(5, 20)\n    user_inputs = []\n    for _ in range(num_entries):\n        contestant = random.randint(1, 9)\n        problem = random.randint(1, 99)\n        time = random.randint(1, 300)\n        result = random.choice(['C', 'I'])\n        user_inputs.append(f\"{contestant} {problem} {time} {result}\")\n    return {'user_inputs': user_inputs}", "io_pairs": [{"input": {"user_inputs": ["7 94 77 C", "6 98 71 I", "4 22 211 I", "2 15 124 C", "2 53 237 I", "5 71 139 C", "3 18 36 I"]}, "output": ["2 1 124", "3 0 0", "4 0 0", "5 1 139", "6 0 0", "7 1 77"]}, {"input": {"user_inputs": ["1 43 90 I", "7 75 238 C", "7 5 121 C", "9 1 48 I", "1 6 197 C", "5 72 120 I", "2 37 182 C", "6 61 97 I"]}, "output": ["1 1 197", "2 1 182", "5 0 0", "6 0 0", "7 2 359", "9 0 0"]}, {"input": {"user_inputs": ["2 27 191 C", "3 48 89 C", "6 15 130 C", "8 78 287 I", "2 87 135 C", "5 96 193 I", "1 29 210 I", "4 24 63 I"]}, "output": ["1 0 0", "2 2 326", "3 1 89", "4 0 0", "5 0 0", "6 1 130", "8 0 0"]}, {"input": {"user_inputs": ["4 74 82 I", "6 19 153 C", "3 91 296 I", "6 59 55 C", "7 43 120 C"]}, "output": ["3 0 0", "4 0 0", "6 2 208", "7 1 120"]}, {"input": {"user_inputs": ["4 51 16 I", "2 85 257 I", "3 16 217 C", "8 56 149 I", "1 26 149 C", "3 19 237 C"]}, "output": ["1 1 149", "2 0 0", "3 2 454", "4 0 0", "8 0 0"]}, {"input": {"user_inputs": ["6 94 138 I", "4 13 220 I", "2 1 223 C", "6 72 262 I", "4 58 87 C", "1 66 71 C", "2 33 83 I", "4 60 130 C"]}, "output": ["1 1 71", "2 1 223", "4 2 217", "6 0 0"]}, {"input": {"user_inputs": ["6 17 201 I", "2 81 91 I", "7 46 235 C", "2 3 295 C", "2 34 77 C", "1 75 247 C", "9 95 90 I"]}, "output": ["1 1 247", "2 2 372", "6 0 0", "7 1 235", "9 0 0"]}, {"input": {"user_inputs": ["9 35 244 I", "5 89 27 I", "7 37 294 C", "4 2 122 C", "9 72 198 C", "8 27 209 I"]}, "output": ["4 1 122", "5 0 0", "7 1 294", "8 0 0", "9 1 198"]}, {"input": {"user_inputs": ["1 44 71 I", "2 58 38 I", "4 49 283 C", "4 31 52 C", "9 34 264 I", "6 11 73 C"]}, "output": ["1 0 0", "2 0 0", "4 2 335", "6 1 73", "9 0 0"]}, {"input": {"user_inputs": ["1 71 182 C", "9 40 218 I", "1 8 211 C", "7 22 147 I", "6 69 158 I", "7 66 93 C"]}, "output": ["1 2 393", "6 0 0", "7 1 93", "9 0 0"]}], "error_log": []}
{"context": "Given two large integers represented as strings, what is the product of these two integers when computed using the Karatsuba multiplication algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num1` (str): A string representation of the first integer to be multiplied.\n  `num2` (str): A string representation of the second integer to be multiplied.\n\nOutput:\n  `return` (str): A string representation of the result of the multiplication of `num1` and `num2` using the Karatsuba algorithm.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef karatsuba_mul_2(k, j):\n    n, m = len(str(k)), len(str(j))\n    i = max(n, m)\n    if n == m == 1:\n        return k * j\n    else:\n        a, b, c, d = int(k // (10 ** (i // 2))), int(k % (10 ** (i // 2))), int(j // (10 ** (i // 2))), int(j % (10 ** (i // 2)))\n        step1, step2 = karatsuba_mul_2(a, c), karatsuba_mul_2(b, d)\n        step3 = karatsuba_mul_2(a + b, c + d)\n        step4 = step3 - step2 - step1\n        return int(step1 * 10 ** ((i // 2) * 2) + step4 * 10 ** (i // 2) + step2)\n\n# main function\ndef main_solution(num1, num2):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert the input to integers if they are not already\n    num1, num2 = int(num1), int(num2)\n    \n    # Call the karatsuba_mul_2 function with the converted inputs\n    result = karatsuba_mul_2(num1, num2)\n    \n    # Return the result as a string to ensure it is JSON serializable\n    return str(result)", "input_generator": "import random\n\ndef input_generator():\n    # Generate two random integers with lengths between 1 and 10 digits\n    length1 = random.randint(1, 10)\n    length2 = random.randint(1, 10)\n    \n    num1 = random.randint(10 ** (length1 - 1), (10 ** length1) - 1)\n    num2 = random.randint(10 ** (length2 - 1), (10 ** length2) - 1)\n    \n    return {'num1': num1, 'num2': num2}", "io_pairs": [{"input": {"num1": 472544, "num2": 601464657}, "output": "284218514877408"}, {"input": {"num1": 3188884, "num2": 258}, "output": "822732072"}, {"input": {"num1": 9050, "num2": 4022}, "output": "36399100"}, {"input": {"num1": 691846414, "num2": 542}, "output": "374980756388"}, {"input": {"num1": 495523, "num2": 86365}, "output": "42795843895"}, {"input": {"num1": 89983115, "num2": 990972832}, "output": "89170822303731680"}, {"input": {"num1": 7926, "num2": 338}, "output": "2678988"}, {"input": {"num1": 883, "num2": 683102887}, "output": "603179849221"}, {"input": {"num1": 1, "num2": 14178}, "output": "14178"}, {"input": {"num1": 4, "num2": 8278}, "output": "33112"}], "error_log": []}
{"context": "Given a positive integer, determine whether it is a prime number. What is the result of checking if the number is prime?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number` (str): A string representation of a positive integer.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input number is a prime number (`True` if prime, `False` otherwise).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_prime(n, k=10):\n    if n <= 1: return False\n    for iteration in range(k):\n        a = random.randint(2, n) - 1\n        if pow(a, n - 1, n) != 1:\n            return False\n    return True\n\n# main function\ndef main_solution(number):\n    # Convert the input to an integer\n    n = int(number)\n    \n    # Call the is_prime function with the converted input\n    result = is_prime(n)\n    \n    # Return the result as a boolean\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random number, sometimes prime, sometimes not\n    if random.random() < 0.5:\n        # Generate a non-prime number\n        n = random.randint(2, 1000)\n        while is_prime(n):\n            n = random.randint(2, 1000)\n    else:\n        # Generate a prime number\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n        n = random.choice(primes)\n    \n    return {'number': str(n)}", "io_pairs": [{"input": {"number": "871"}, "output": false}, {"input": {"number": "964"}, "output": false}, {"input": {"number": "536"}, "output": false}, {"input": {"number": "285"}, "output": false}, {"input": {"number": "73"}, "output": true}, {"input": {"number": "254"}, "output": false}, {"input": {"number": "147"}, "output": false}, {"input": {"number": "31"}, "output": true}, {"input": {"number": "37"}, "output": true}, {"input": {"number": "384"}, "output": false}], "error_log": []}
{"context": "Given the dimensions of a maze and a specific algorithm number, what is the resulting maze layout generated by the chosen algorithm? The maze dimensions are represented by `width` and `height`, and the algorithm number is represented by `num_algo`. The output should be a 2D list where each cell indicates the presence of walls.\n\nThe input and output requirements are as follows:\n\nInput:\n  `width` (int): The width of the maze.\n  `height` (int): The height of the maze.\n  `num_algo` (int): The algorithm number to generate the maze. Valid values are 0, 1, 2, or 3.\n\nOutput:\n  `return` (list of lists of int): A 2D list representing the generated maze. Each cell in the maze is represented by an integer where specific bits indicate the presence of walls.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def is_not_empty(self):\n        return self.items != []\n\nclass Cell:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Vis:\n    def __init__(self, num, vis):\n        self.num = num\n        self.vis = vis\n\nclass Maze:\n    S, E = 1, 2\n\n    def __init__(self, width, height, num_algo):\n        self.width = width\n        self.height = height\n        self.maze = []\n        self.choose_algo(num_algo)\n\n    def choose_algo(self, num_algo):\n        if num_algo == 0:\n            self.maze = MazeEller(self.width, self.height).generation_maze()\n        elif num_algo == 1:\n            self.maze = MazeGraph(self.height, self.width).generation_maze()\n        elif num_algo == 2:\n            self.maze = Sidewinder(self.width, self.height).generation_maze()\n        elif num_algo == 3:\n            self.maze = MazeWilson(self.width, self.height).generation_maze()\n\nclass State:\n    def __init__(self, width, next_set=-1):\n        self.width = width\n        self.next_set = next_set\n        self.sets = dict()\n        self.cells = {}\n\n    def next(self):\n        return State(self.width, self.next_set)\n\n    def populate(self):\n        for cell in range(self.width):\n            if not cell in self.cells:\n                self.next_set += 1\n                set = self.next_set\n                self.sets.setdefault(set, []).append(cell)\n                self.cells[cell] = set\n        return self\n\n    def merge(self, sink_cell, target_cell):\n        sink, target = self.cells[sink_cell], self.cells[target_cell]\n        self.sets.setdefault(sink, []).extend(self.sets.setdefault(target, []))\n        for cell in self.sets.get(target, []):\n            self.cells[cell] = sink\n        if target in self.sets:\n            del (self.sets[target])\n\n    def same_is(self, cell1, cell2):\n        return self.cells[cell1] == self.cells[cell2]\n\n    def add(self, cell, set):\n        self.cells[cell] = set\n        self.sets.setdefault(set, []).append(cell)\n\nclass MazeEller:\n    S, E = 1, 2\n\n    def __init__(self, width, height):\n        self.height = height\n        self.width = width\n\n    def step(self, state, finish=False):\n        connected_sets = []\n        connected_set = [0]\n\n        for c in range(state.width - 1):\n            if state.same_is(c, c + 1) or (not finish and random.randrange(0, 2) > 0):\n                connected_sets.append(connected_set)\n                connected_set = [c + 1]\n            else:\n                state.merge(c, c + 1)\n                connected_set.append(c + 1)\n        connected_sets.append(connected_set)\n\n        verticals = []\n        next_state = state.next()\n\n        if not finish:\n            for id, set1 in state.sets.items():\n                random.shuffle(set1)\n                cells_to_connect = set1[0:1 + random.randint(0, len(set1) - 1)]\n                verticals += cells_to_connect\n                for cell in cells_to_connect:\n                    next_state.add(cell, id)\n\n        row = []\n        for connected_set in connected_sets:\n            for index, cell in enumerate(connected_set):\n                last = (index + 1 == len(connected_set))\n                map = 0 if last else self.E\n                if cell in verticals:\n                    map |= self.S\n                row.append(map)\n        next_state = next_state.populate()\n        return next_state, row\n\n    def generation_maze(self):\n        maze = []\n        state = State(self.width)\n        state.populate()\n        row_count = 0\n        while row_count < self.height - 1:\n            state, row = self.step(state)\n            row_count += 1\n            maze.append(row)\n        state, row = self.step(state, True)\n        row_count += 1\n        maze.append(row)\n        return maze\n\nclass MazeGraph:\n\n    def __init__(self, height, width):\n        self.height = height\n        self.width = width\n        self.maze = []\n        self.create_begin_matrix()\n\n    def create_begin_matrix(self):\n        for i in range(self.height):\n            self.maze.append([])\n            for j in range(self.width):\n                self.maze[i].append(Vis(0, 0))\n\n    def generation_maze(self):\n        check = True\n        stack = Stack()\n        current_cell = Cell(0, 0)\n        self.maze[current_cell.y][current_cell.x].vis = 1\n        while check:\n            mas = self.get_neighbors(current_cell)\n            if mas:\n                rand_number = random.randrange(0, len(mas))\n                next_cell = mas[rand_number]\n                stack.push(current_cell)\n                self.remove_wall(current_cell, next_cell)\n                current_cell = next_cell\n                self.maze[current_cell.y][current_cell.x].vis = 1\n                mas.clear()\n            elif stack.is_not_empty():\n                current_cell = stack.pop()\n            else:\n                cell_unvisited = self.unvisited_cells()\n                rand_number = random.randrange(0, len(cell_unvisited))\n                current_cell = cell_unvisited[rand_number]\n                self.maze[current_cell.y][current_cell.x].vis = 1\n                cell_unvisited.clear()\n            check = len(self.unvisited_cells()) != 0\n        for i in range(self.height):\n            for j in range(self.width):\n                self.maze[i][j] = self.maze[i][j].num\n        return self.maze\n\n    def unvisited_cells(self):\n        mas = []\n        for i in range(self.height):\n            for j in range(self.width):\n                if not self.maze[i][j].vis:\n                    mas.append(Cell(i, j))\n        return mas\n\n    def get_neighbors(self, cell):\n        dist = 1\n        up = Cell(cell.x, cell.y - dist)\n        right = Cell(cell.x + dist, cell.y)\n        down = Cell(cell.x, cell.y + dist)\n        left = Cell(cell.x - dist, cell.y)\n\n        mas_dir = [down, right, up, left]\n        mas_result = []\n        for i in range(4):\n            if 0 <= mas_dir[i].x < self.width and \\\n                    0 <= mas_dir[i].y < self.height:\n                maze_curr = self.maze[mas_dir[i].y][mas_dir[i].x]\n                if not maze_curr.vis:\n                    mas_result.append(mas_dir[i])\n        return mas_result\n\n    def remove_wall(self, first, second):\n        x_diff, y_diff = second.x - first.x, second.y - first.y\n\n        if x_diff != 0:\n            if x_diff < 0:\n                self.maze[second.y][second.x].num += 2\n            else:\n                self.maze[first.y][first.x].num += 2\n        elif y_diff != 0:\n            if y_diff < 0:\n                self.maze[second.y][second.x].num += 1\n            else:\n                self.maze[first.y][first.x].num += 1\n\nclass Sidewinder:\n\n    def __init__(self, width, height):\n        self.height = height\n        self.width = width\n        self.maze = []\n\n    def create_grid(self):\n        for y in range(0, self.height):\n            self.maze.append([])\n            for x in range(0, self.width):\n                self.maze[y].append(0)\n\n    def generation_maze(self):\n        self.create_grid()\n        self.sidewinder()\n        return self.maze\n\n    def sidewinder(self):\n        cx = 0\n        for y in range(self.height):\n            for x in range(self.width):\n                if y != 0:\n                    if random.randint(0, 1) == 0 and x != self.width - 1:\n                        self.maze[y][x] += 2\n                    else:\n                        cx_tmp, x_tmp = min(cx, x), max(cx, x)\n                        self.maze[y - 1][random.randint(cx_tmp, x_tmp)] += 1\n\n                        if x != self.width - 1:\n                            cx = x + 1\n                        else:\n                            cx = 0\n                elif x != self.width - 1:\n                    self.maze[y][x] += 2\n\nclass MazeWilson:\n    DIRS = [\"UP\", \"DOWN\", \"LEFT\", \"RIGHT\"]\n\n    def __init__(self, width, height):\n        self.height = height\n        self.width = width\n        self.maze = []\n\n    def create_grid(self):\n        for y in range(0, self.height):\n            self.maze.append([])\n            for x in range(0, self.width):\n                self.maze[y].append(Vis(0, 0))\n\n    def generation_maze(self):\n        self.create_grid()\n        self.wilson()\n        for i in range(self.height):\n            for j in range(self.width):\n                self.maze[i][j] = self.maze[i][j].num\n        return self.maze\n\n    def unvisited_cells(self):\n        unvisited = []\n        for y, row in enumerate(self.maze):\n            for x, value in enumerate(row):\n                if not value.vis:\n                    unvisited.append((x, y))\n        return unvisited\n\n    def wilson(self):\n        cells_mas = self.unvisited_cells()\n        dirs_stack = []\n\n        key = cells_mas[0]\n        cells_mas.pop(0)\n        random.shuffle(cells_mas)\n        self.maze[key[1]][key[0]].vis = 1\n\n        while cells_mas:\n            key = cells_mas[0]\n            start_x, start_y = key[0], key[1]\n            ix, iy = start_x, start_y\n            dirs_stack.append((\"\", key))\n            while not self.maze[iy][ix].vis:\n                direction = self.DIRS[random.randint(0, 3)]\n                move = False\n\n                if direction == \"UP\" and iy - 1 >= 0:\n                    iy -= 1\n                    move = True\n                elif direction == \"DOWN\" and iy + 1 < self.height:\n                    iy += 1\n                    move = True\n                elif direction == \"LEFT\" and ix - 1 >= 0:\n                    ix -= 1\n                    move = True\n                elif direction == \"RIGHT\" and ix + 1 < self.width:\n                    ix += 1\n                    move = True\n\n                if move:\n                    stack_reverse = [el for dir, el in dirs_stack]\n                    key_to = (ix, iy)\n                    if key_to in stack_reverse or key_to == (start_x, start_y):\n                        i = len(dirs_stack) - 1\n                        elem = dirs_stack[i][1]\n                        while elem != key_to:\n                            dirs_stack.pop(i)\n                            i -= 1\n                            elem = dirs_stack[i][1]\n                    else:\n                        dirs_stack.append((direction, key_to))\n\n            for j in range(0, len(dirs_stack)):\n                self.maze[start_y][start_x].vis = 1\n                direction = dirs_stack[j][0]\n\n                if direction == \"UP\":\n                    self.maze[start_y - 1][start_x].num += 1\n                    start_y -= 1\n\n                elif direction == \"DOWN\":\n                    self.maze[start_y][start_x].num += 1\n                    start_y += 1\n\n                elif direction == \"LEFT\":\n                    self.maze[start_y][start_x - 1].num += 2\n                    start_x -= 1\n\n                elif direction == \"RIGHT\":\n                    self.maze[start_y][start_x].num += 2\n                    start_x += 1\n                try:\n                    cells_mas.remove((start_x, start_y))\n                except:\n                    pass\n\n            dirs_stack = []\n\n# main function\ndef main_solution(width, height, num_algo):\n    maze = Maze(width, height, num_algo)\n    return maze.maze", "input_generator": "import random\n\ndef input_generator():\n    width = random.randint(5, 20)\n    height = random.randint(5, 20)\n    num_algo = random.randint(0, 3)\n    return {'width': width, 'height': height, 'num_algo': num_algo}", "io_pairs": [{"input": {"width": 7, "height": 6, "num_algo": 0}, "output": [[3, 3, 2, 1, 1, 1, 1], [1, 3, 1, 3, 1, 1, 1], [1, 0, 1, 0, 2, 3, 0], [3, 1, 1, 1, 1, 2, 1], [1, 1, 0, 3, 3, 3, 0], [0, 2, 0, 0, 0, 2, 0]]}, {"input": {"width": 8, "height": 6, "num_algo": 0}, "output": [[2, 1, 1, 1, 1, 2, 3, 1], [1, 1, 1, 3, 3, 1, 1, 0], [2, 1, 3, 1, 1, 1, 3, 0], [3, 3, 1, 0, 1, 0, 3, 1], [1, 1, 1, 1, 3, 3, 1, 0], [0, 0, 2, 0, 0, 0, 2, 0]]}, {"input": {"width": 6, "height": 6, "num_algo": 2}, "output": [[2, 2, 3, 2, 3, 1], [3, 3, 2, 1, 1, 0], [0, 3, 0, 1, 2, 1], [3, 3, 0, 3, 0, 1], [1, 0, 3, 3, 0, 1], [2, 0, 0, 2, 0, 0]]}, {"input": {"width": 7, "height": 5, "num_algo": 0}, "output": [[1, 1, 3, 0, 2, 1, 1], [3, 2, 2, 1, 3, 1, 1], [2, 1, 1, 1, 0, 3, 0], [3, 3, 1, 2, 2, 1, 1], [0, 0, 2, 2, 0, 2, 0]]}, {"input": {"width": 7, "height": 5, "num_algo": 2}, "output": [[2, 3, 2, 3, 3, 3, 1], [3, 2, 1, 0, 0, 1, 1], [2, 1, 1, 2, 3, 1, 0], [3, 1, 0, 2, 0, 3, 0], [0, 0, 2, 2, 2, 2, 0]]}, {"input": {"width": 5, "height": 5, "num_algo": 1}, "output": [[1, 3, 2, 1, 1], [2, 0, 1, 2, 1], [3, 2, 1, 3, 0], [2, 1, 2, 0, 1], [2, 2, 2, 2, 0]]}, {"input": {"width": 7, "height": 6, "num_algo": 1}, "output": [[1, 3, 2, 2, 2, 2, 1], [1, 2, 2, 3, 1, 2, 0], [2, 2, 1, 1, 2, 2, 1], [3, 2, 0, 2, 2, 0, 1], [1, 2, 3, 2, 2, 1, 1], [2, 2, 0, 2, 2, 2, 0]]}, {"input": {"width": 5, "height": 5, "num_algo": 2}, "output": [[3, 3, 2, 3, 0], [1, 0, 2, 3, 1], [1, 2, 2, 1, 0], [1, 2, 2, 2, 1], [2, 2, 0, 2, 0]]}, {"input": {"width": 8, "height": 6, "num_algo": 3}, "output": [[1, 2, 3, 2, 2, 1, 3, 0], [3, 0, 3, 3, 1, 2, 2, 0], [1, 2, 1, 0, 0, 1, 1, 1], [3, 3, 0, 3, 2, 0, 1, 1], [0, 3, 2, 3, 2, 3, 2, 1], [2, 2, 0, 2, 0, 2, 0, 0]]}, {"input": {"width": 6, "height": 5, "num_algo": 1}, "output": [[2, 2, 1, 2, 3, 1], [3, 0, 2, 1, 1, 1], [3, 2, 1, 1, 1, 0], [2, 1, 2, 0, 2, 1], [2, 2, 2, 2, 2, 0]]}], "error_log": []}
{"context": "In a committee assignment scenario, there are `n` people and `m` pairs of people who cannot be in the same committee due to specific constraints. What is the minimum number of committees required to ensure that no two people in any pair are assigned to the same committee?\n\nThe input and output requirements are as follows:\n\nInput:\n- `n` (int): The total number of people.\n- `m` (int): The number of pairs with constraints.\n- `bad_pairs` (list of tuples): A list of tuples where each tuple contains two integers representing a pair of people who cannot be in the same committee.\n\nOutput:\n- `return` (int): The minimum number of committees required to satisfy all the constraints.", "reference_code": "# import necessary packages\nfrom z3 import *\n\n# main function\ndef main_solution(n, m, bad_pairs):\n    # Convert JSON serializable inputs to original input variables\n    list_of_bad_pairs_Left = [pair[0] for pair in bad_pairs]\n    list_of_bad_pairs_Right = [pair[1] for pair in bad_pairs]\n    \n    # Function to calculate the minimum number of committees\n    def calculations(n, m, buckets):\n        # Set up for z3 Solver\n        f = Function('f', IntSort(), IntSort())\n        s = z3.Solver()\n        s.push()\n        \n        # Add constraints for each pair\n        for x in range(m):\n            s.add(f(list_of_bad_pairs_Left[x]) != f(list_of_bad_pairs_Right[x]))\n        \n        # Constrain each person to only be assigned to 1 committee and the current value of buckets\n        for x in range(1, n+1):\n            s.add(f(x) >= 1, f(x) <= buckets)\n        \n        # z3 Solver will determine if all of the added constraints can be satisfied\n        if s.check() == z3.sat:\n            return buckets\n        else:\n            return calculations(n, m, buckets + 1)\n    \n    # Start the calculations with 1 committee\n    result = calculations(n, m, 1)\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(2, 20)  # Number of people\n    max_pairs = n * (n - 1) // 2\n    m = random.randint(1, max(1, max_pairs // 2))  # Number of bad pairs, avoid too many\n    \n    # Generate unique bad pairs\n    bad_pairs = set()\n    while len(bad_pairs) < m:\n        a = random.randint(1, n)\n        b = random.randint(1, n)\n        if a != b and (a, b) not in bad_pairs and (b, a) not in bad_pairs:\n            bad_pairs.add((a, b))\n    \n    bad_pairs = list(bad_pairs)\n    \n    return {\n        'n': n,\n        'm': m,\n        'bad_pairs': bad_pairs\n    }", "io_pairs": [{"input": {"n": 4, "m": 1, "bad_pairs": [[1, 3]]}, "output": 2}, {"input": {"n": 3, "m": 1, "bad_pairs": [[1, 2]]}, "output": 2}, {"input": {"n": 10, "m": 5, "bad_pairs": [[4, 6], [2, 9], [10, 6], [1, 10], [3, 2]]}, "output": 2}, {"input": {"n": 7, "m": 4, "bad_pairs": [[6, 7], [2, 5], [6, 5], [1, 4]]}, "output": 2}, {"input": {"n": 5, "m": 2, "bad_pairs": [[4, 5], [3, 5]]}, "output": 2}, {"input": {"n": 5, "m": 1, "bad_pairs": [[4, 2]]}, "output": 2}, {"input": {"n": 4, "m": 1, "bad_pairs": [[2, 3]]}, "output": 2}, {"input": {"n": 15, "m": 4, "bad_pairs": [[7, 4], [1, 12], [12, 13], [14, 10]]}, "output": 2}, {"input": {"n": 12, "m": 4, "bad_pairs": [[9, 5], [4, 6], [8, 5], [10, 11]]}, "output": 2}, {"input": {"n": 7, "m": 5, "bad_pairs": [[7, 4], [2, 7], [4, 5], [7, 6], [6, 3]]}, "output": 2}], "error_log": []}
{"context": "Given two vectors in a 3-dimensional space, what is the angle between them?\n\nThe input and output requirements are as follows:\n\nInput:\n- `vector1` (list of floats): The first vector.\n- `vector2` (list of floats): The second vector.\n\nOutput:\n- `return` (dictionary): A dictionary containing the angle between the two vectors in degrees. The key is `\"angle_degrees\"` and the value is a float representing the angle in degrees.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom numpy.linalg import norm\n\n# main function\ndef main_solution(vector1, vector2):\n    # Convert input lists to numpy arrays\n    vector1 = np.array(vector1)\n    vector2 = np.array(vector2)\n    \n    # Calculate the dot product of the two vectors\n    dot_product = np.dot(vector1, vector2)\n    \n    # Calculate the norms of the vectors\n    norm_vector1 = norm(vector1)\n    norm_vector2 = norm(vector2)\n    \n    # Calculate the cosine of the angle between the vectors\n    cos_theta = dot_product / (norm_vector1 * norm_vector2)\n    \n    # Calculate the angle in radians\n    angle_radians = np.arccos(np.clip(cos_theta, -1, 1))\n    \n    # Convert the angle to degrees\n    angle_degrees = angle_radians * 180 / np.pi\n    \n    # Return the angle in degrees as a JSON serializable output\n    return {\"angle_degrees\": angle_degrees}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    dim = random.randint(2, 5)\n    vector1 = [round(random.uniform(-10, 10), 2) for _ in range(dim)]\n    vector2 = [round(random.uniform(-10, 10), 2) for _ in range(dim)]\n    return {\"vector1\": vector1, \"vector2\": vector2}", "io_pairs": [{"input": {"vector1": [1.85, 5.95, 7.0], "vector2": [0.84, -3.79, 1.93]}, "output": {"angle_degrees": 100.61853942826671}}, {"input": {"vector1": [2.73, 2.26, 2.73, -7.3, 9.44], "vector2": [1.67, 0.37, 7.13, 5.6, -8.05]}, "output": {"angle_degrees": 126.13180553083807}}, {"input": {"vector1": [5.7, -1.07, 7.92, 4.01, 9.72], "vector2": [5.83, 6.42, 7.08, -8.75, 2.26]}, "output": {"angle_degrees": 70.43244713642713}}, {"input": {"vector1": [8.0, 8.89, 0.3, 0.25, -5.05], "vector2": [9.12, 1.98, 4.57, 8.11, -0.02]}, "output": {"angle_degrees": 56.67257170523052}}, {"input": {"vector1": [-0.1, -4.24, 0.57], "vector2": [-5.3, 7.1, -2.27]}, "output": {"angle_degrees": 142.06096151282003}}, {"input": {"vector1": [-8.35, 2.94, -7.26, -6.18], "vector2": [6.17, -3.21, -7.72, -4.34]}, "output": {"angle_degrees": 81.39857032463718}}, {"input": {"vector1": [-0.73, -0.61, 5.35], "vector2": [-3.2, 9.91, -3.39]}, "output": {"angle_degrees": 111.53603772371028}}, {"input": {"vector1": [-8.44, 6.02], "vector2": [3.75, 7.58]}, "output": {"angle_degrees": 80.82352966303095}}, {"input": {"vector1": [4.29, -6.26, -0.21], "vector2": [2.29, 6.04, 5.7]}, "output": {"angle_degrees": 116.50084889429317}}, {"input": {"vector1": [5.49, -5.86, 2.84, 6.11], "vector2": [0.06, 3.78, -7.5, 1.31]}, "output": {"angle_degrees": 113.21082975228738}}], "error_log": []}
{"context": "Given a base value `x` and the number of terms `k`, what is the result of the series calculation where each term alternates in sign and is derived from the base value raised to an increasing odd exponent divided by the factorial of that exponent?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): The base value for the series calculation.\n  `k` (int): The number of terms to consider in the series calculation.\n\nOutput:\n  `return` (float): The result of the series calculation rounded to 10 decimal places.", "reference_code": "# import necessary packages\nfrom math import factorial\n\n# main function\ndef main_solution(x, k):\n    # Convert JSON serializable inputs to the original input variables\n    x = float(x)\n    k = int(k)\n    \n    contador = 1\n    sinal = -1 \n    resultado = x\n    expoente = 3\n    \n    while contador < k:\n        resultado = resultado + (sinal * (x ** expoente / factorial(expoente)))\n        sinal = sinal * (-1)\n        expoente = expoente + 2\n        contador += 1 \n    \n    # Convert the result to a JSON serializable output\n    return round(resultado, 10)", "input_generator": "import random\nfrom math import pi\n\ndef input_generator():\n    x_options = [random.uniform(-pi, pi), random.uniform(-10, 10), 0, pi/2, -pi/4]\n    x = random.choice(x_options)\n    k = random.randint(1, 20)\n    return {'x': x, 'k': k}", "io_pairs": [{"input": {"x": 1.5707963267948966, "k": 1}, "output": 1.5707963268}, {"input": {"x": -2.747427652614375, "k": 13}, "output": -0.3840373535}, {"input": {"x": 0, "k": 9}, "output": 0.0}, {"input": {"x": -2.0362321554585607, "k": 2}, "output": -0.6291138147}, {"input": {"x": 0, "k": 13}, "output": 0.0}, {"input": {"x": 3.3951586943085204, "k": 7}, "output": -0.2507902274}, {"input": {"x": 2.5007224115744, "k": 6}, "output": 0.5978699118}, {"input": {"x": -0.7853981633974483, "k": 4}, "output": -0.7071064696}, {"input": {"x": 0.5050493391988038, "k": 16}, "output": 0.4838506201}, {"input": {"x": -0.7853981633974483, "k": 18}, "output": -0.7071067812}], "error_log": []}
{"context": "Given a set of pentagonal numbers generated up to a certain limit, what are the two pentagonal numbers such that their sum and absolute difference are also pentagonal numbers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The upper limit for generating pentagonal numbers. The function will generate pentagonal numbers from 1 to n-1.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `p1` (int or None): The first pentagonal number that satisfies the condition. If no such pair is found, it will be `None`.\n    - `p2` (int or None): The second pentagonal number that satisfies the condition. If no such pair is found, it will be `None`.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_pentagonal(y):\n    x = (1 + (1 + 24 * y) ** 0.5) / 6\n    if x.is_integer() and x > 0:\n        return True\n    else:\n        x = (1 - (1 + 24 * y) ** 0.5) / 6\n        return x.is_integer() and x > 0\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    pentagonal_numbers = [int(x * (3 * x - 1) / 2) for x in range(1, n)]\n    \n    for x in range(1, len(pentagonal_numbers)):\n        for y in range(x):\n            if is_pentagonal(pentagonal_numbers[x] + pentagonal_numbers[y]) and is_pentagonal(abs(pentagonal_numbers[x] - pentagonal_numbers[y])):\n                return {\"p1\": pentagonal_numbers[x], \"p2\": pentagonal_numbers[y]}\n    \n    return {\"p1\": None, \"p2\": None}", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(10, 100)\n    return {\"n\": n}", "io_pairs": [{"input": {"n": 31}, "output": {"p1": null, "p2": null}}, {"input": {"n": 99}, "output": {"p1": null, "p2": null}}, {"input": {"n": 18}, "output": {"p1": null, "p2": null}}, {"input": {"n": 46}, "output": {"p1": null, "p2": null}}, {"input": {"n": 95}, "output": {"p1": null, "p2": null}}, {"input": {"n": 26}, "output": {"p1": null, "p2": null}}, {"input": {"n": 17}, "output": {"p1": null, "p2": null}}, {"input": {"n": 12}, "output": {"p1": null, "p2": null}}, {"input": {"n": 28}, "output": {"p1": null, "p2": null}}, {"input": {"n": 66}, "output": {"p1": null, "p2": null}}], "error_log": []}
{"context": "Given a mathematical series defined as:\n\\[ S = \\frac{2X}{2!} - \\frac{3X^2}{3!} + \\frac{4X^3}{4!} - \\frac{5X^4}{5!} + \\ldots \\]\nwhere \\( X \\) is a real number and \\( \\epsilon \\) is a small threshold value, the series is developed until the absolute value of the next term is less than \\( \\epsilon \\). What is the final sum of the series for a given \\( X \\) and \\( \\epsilon \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): The value of x in the series.\n  `epsilon` (float): The threshold value for the absolute value of the term in the series.\n\nOutput:\n  `return` (float): The final sum of the series rounded to two decimal places.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(x, epsilon):\n    # Initialize variables\n    sumatoria = 0.0\n    termino = 2 * x / 2\n    i = 1\n    \n    # Loop to calculate the series until the absolute value of the term is less than epsilon\n    while abs(termino) > epsilon:\n        sumatoria += termino\n        i += 1\n        factorial = math.factorial(i + 1)\n        termino = ((-1) ** (i + 1)) * ((i + 1) * x ** i) / factorial\n    \n    # Return the final sum of the series\n    return round(sumatoria, 2)", "input_generator": "import random\nimport math\n\ndef input_generator():\n    x = random.uniform(0.1, 5.0)\n    epsilon = 10 ** -random.randint(1, 6)\n    return {'x': x, 'epsilon': epsilon}", "io_pairs": [{"input": {"x": 4.981334426976827, "epsilon": 0.1}, "output": 1.04}, {"input": {"x": 1.1282904580756374, "epsilon": 1e-05}, "output": 0.68}, {"input": {"x": 0.3462025910550245, "epsilon": 0.0001}, "output": 0.29}, {"input": {"x": 0.8008516734315436, "epsilon": 1e-05}, "output": 0.55}, {"input": {"x": 4.280602162072131, "epsilon": 0.1}, "output": 1.05}, {"input": {"x": 1.7974410550084767, "epsilon": 0.001}, "output": 0.83}, {"input": {"x": 3.7676459953710704, "epsilon": 0.1}, "output": 0.94}, {"input": {"x": 3.483261313127997, "epsilon": 1e-06}, "output": 0.97}, {"input": {"x": 0.6682938377214611, "epsilon": 0.0001}, "output": 0.49}, {"input": {"x": 4.1482766530541975, "epsilon": 0.1}, "output": 1.03}], "error_log": []}
{"context": "Given a matrix of random integers, what is the sum of all its elements? The matrix size and the range of random integers are provided.\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_size` (list of int): A list containing two integers representing the number of rows and columns of the matrix.\n  `random_range` (list of int): A list containing two integers representing the lower and upper bounds for the random integers in the matrix.\n\nOutput:\n  `return` (float): The sum of all elements in the generated matrix.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix_size, random_range):\n    # Convert JSON serializable inputs to original input variables\n    matrix_size = tuple(matrix_size)\n    random_range = tuple(random_range)\n    \n    # Generate a random matrix\n    matrix = np.random.randint(random_range[0], random_range[1], matrix_size)\n    \n    # Calculate the sum of all elements in the matrix\n    total_sum = np.sum(matrix)\n    \n    # Convert the output to JSON serializable\n    total_sum = float(total_sum)\n    \n    return total_sum", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    matrix_rows = random.randint(1, 10)\n    matrix_cols = random.randint(1, 10)\n    matrix_size = (matrix_rows, matrix_cols)\n    \n    range_start = random.randint(-100, 0)\n    range_end = random.randint(1, 100)\n    random_range = (range_start, range_end)\n    \n    return {\n        'matrix_size': matrix_size,\n        'random_range': random_range\n    }", "io_pairs": [{"input": {"matrix_size": [8, 5], "random_range": [-90, 53]}, "output": -545.0}, {"input": {"matrix_size": [3, 2], "random_range": [-88, 53]}, "output": -195.0}, {"input": {"matrix_size": [3, 8], "random_range": [-45, 62]}, "output": 282.0}, {"input": {"matrix_size": [10, 9], "random_range": [-31, 39]}, "output": 56.0}, {"input": {"matrix_size": [10, 5], "random_range": [-29, 81]}, "output": 834.0}, {"input": {"matrix_size": [5, 9], "random_range": [-66, 40]}, "output": -694.0}, {"input": {"matrix_size": [4, 3], "random_range": [-14, 99]}, "output": 501.0}, {"input": {"matrix_size": [3, 10], "random_range": [-14, 46]}, "output": 377.0}, {"input": {"matrix_size": [9, 10], "random_range": [-3, 21]}, "output": 764.0}, {"input": {"matrix_size": [9, 5], "random_range": [-55, 76]}, "output": 331.0}], "error_log": []}
{"context": "Given a 3D rotation defined by an axis and an angle, what are the scalar and vector components of the quaternion that results from multiplying the quaternion representing the rotation with its inverse?\n\nThe input and output requirements are as follows:\n\nInput:\n  `rotation_axis` (list of float): A list of three floats representing the axis of rotation in 3D space.\n  `rotation_angle` (float): A float representing the angle of rotation in radians.\n\nOutput:\n  `return` (dict): A dictionary containing the scalar and vector parts of the resulting quaternion after multiplying the original quaternion with its inverse. The dictionary has the following keys:\n    - `scalar` (list of float): A list containing a single float representing the scalar part of the quaternion.\n    - `vector` (list of float): A list of three floats representing the vector part of the quaternion.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Quaternion:\n    def __init__(self, scalar, vector):\n        self.vector = vector\n        self.scalar = scalar\n\n    def inv(self):\n        return Quaternion(self.scalar, -self.vector)\n\n    def __mul__(self, b):\n        newscalar = self.scalar * b.scalar - np.dot(self.vector, b.vector)\n        newvector = np.cross(self.vector, b.vector) + self.scalar * b.vector + b.scalar * self.vector\n        return Quaternion(newscalar, newvector)\n\n# main function\ndef main_solution(rotation_axis, rotation_angle):\n    # Convert JSON serializable inputs to original input variables\n    rotation_axis = np.array(rotation_axis)\n    rotation_angle = float(rotation_angle)\n\n    # Create a quaternion for the given rotation\n    q = Quaternion(np.cos(rotation_angle / 2), np.sin(rotation_angle / 2) * rotation_axis / np.linalg.norm(rotation_axis))\n\n    # Create a quaternion for the inverse rotation\n    q_inv = q.inv()\n\n    # Multiply the quaternion with its inverse to get the identity quaternion\n    result = q * q_inv\n\n    # Convert the result to JSON serializable output\n    return {\n        \"scalar\": result.scalar.tolist(),\n        \"vector\": result.vector.tolist()\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random rotation axis (3D vector)\n    rotation_axis = np.random.uniform(-1, 1, 3)\n    # Ensure the axis is not a zero vector\n    while np.linalg.norm(rotation_axis) < 1e-6:\n        rotation_axis = np.random.uniform(-1, 1, 3)\n    \n    # Generate a random rotation angle between -2\u03c0 and 2\u03c0\n    rotation_angle = random.uniform(-2 * np.pi, 2 * np.pi)\n    \n    return {\n        \"rotation_axis\": rotation_axis.tolist(),\n        \"rotation_angle\": rotation_angle\n    }", "io_pairs": [{"input": {"rotation_axis": [-0.16925649890336447, -0.9694027764093307, -0.9056591360706925], "rotation_angle": -0.4916786591856024}, "output": {"scalar": 1.0, "vector": [0.0, 0.0, 0.0]}}, {"input": {"rotation_axis": [-0.7378930319107995, 0.9156384547934637, -0.8358587931057597], "rotation_angle": -4.084084802308083}, "output": {"scalar": 0.9999999999999996, "vector": [0.0, 0.0, 0.0]}}, {"input": {"rotation_axis": [0.7256574065673604, 0.1568977219605867, -0.40616427787581766], "rotation_angle": -5.3447848203407835}, "output": {"scalar": 1.0, "vector": [0.0, 0.0, 0.0]}}, {"input": {"rotation_axis": [-0.494150743782348, 0.08853978484787728, -0.4311210478722898], "rotation_angle": -3.159444370937782}, "output": {"scalar": 1.0000000000000002, "vector": [0.0, 0.0, 0.0]}}, {"input": {"rotation_axis": [-0.6366531121485861, 0.295336013888051, -0.18300409113630778], "rotation_angle": -4.586613566430234}, "output": {"scalar": 1.0000000000000002, "vector": [0.0, 0.0, 0.0]}}, {"input": {"rotation_axis": [0.31193911316659095, 0.38532129893224054, -0.8176534786130818], "rotation_angle": 3.3979668662966382}, "output": {"scalar": 1.0000000000000002, "vector": [0.0, 0.0, 0.0]}}, {"input": {"rotation_axis": [0.3967309394874938, 0.6872592419807224, 0.36443021867019865], "rotation_angle": 5.618227504950038}, "output": {"scalar": 0.9999999999999999, "vector": [0.0, 0.0, 0.0]}}, {"input": {"rotation_axis": [0.9891341025305072, 0.5559112661666166, 0.23528139446701735], "rotation_angle": -3.7661898816995714}, "output": {"scalar": 1.0000000000000002, "vector": [0.0, 0.0, 0.0]}}, {"input": {"rotation_axis": [-0.020099385918019852, -0.3971848622186678, -0.014095361265674011], "rotation_angle": -2.9626728170372374}, "output": {"scalar": 1.0, "vector": [0.0, 0.0, 0.0]}}, {"input": {"rotation_axis": [0.09949502432681312, -0.2032462126210608, 0.37705038702224125], "rotation_angle": 6.182855095659475}, "output": {"scalar": 1.0, "vector": [0.0, 0.0, 0.0]}}], "error_log": []}
{"context": "Given a list of integers representing the nodes of a Binary Search Tree (BST), what is the result of performing a specific operation on the BST? The possible operations include inserting a new node, deleting an existing node, finding a node, and performing pre-order, in-order, post-order traversals, or calculating the height of the BST.\n\nThe input and output requirements are as follows:\n\nInput:\n- `values` (List[int]): A list of integers to be inserted into the Binary Search Tree.\n- `operation` (str): The operation to perform on the BST. Possible values: \"insert\", \"delete\", \"find\", \"pre_order\", \"in_order\", \"post_order\", \"height\".\n- `value` (Optional[int]): The value to be used for the operation. Required for \"insert\", \"delete\", and \"find\" operations.\n\nOutput:\n- `return` (Union[List[int], int, bool]): The result of the operation. For \"insert\" and \"delete\", returns True if successful. For \"find\", returns a list of node values found. For traversal operations (\"pre_order\", \"in_order\", \"post_order\"), returns a list of node values. For \"height\", returns the height of the BST.", "reference_code": "# import necessary packages\nfrom typing import List, Optional\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node:\n    \"\"\"\n    \u4e8c\u53c9\u6811\u8282\u70b9\u7c7b\n    \"\"\"\n\n    def __init__(self, val: Optional[int] = None):\n        self.val = val\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        return \"<Binary Tree Node: %d>\" % self.val\n\n\nclass BinarySearchTree:\n    \"\"\"\n    \u94fe\u5f0f\u4e8c\u53c9\u67e5\u627e\u6811\uff0c\u652f\u6301\u91cd\u590d\u6570\u636e\n    \"\"\"\n\n    def __init__(self, root: Optional[int] = None):\n        self.root = Node(root)\n\n    def insert(self, val: int):\n        if self.root.val is None:\n            self.root = Node(val)\n        else:\n            node = self.root\n            while True:\n                if node.val <= val:\n                    if node.right:\n                        node = node.right\n                    else:\n                        node.right = Node(val)\n                        break\n                else:\n                    if node.left:\n                        node = node.left\n                    else:\n                        node.left = Node(val)\n                        break\n\n    def _find(self, val: int):\n        nodes = []\n        node = self.root\n        parent = loc = None\n        while node:\n            if val < node.val:\n                parent = node\n                loc = 'left'\n                node = node.left\n            elif val > node.val:\n                parent = node\n                loc = 'right'\n                node = node.right\n            else:\n                nodes.append((parent, loc, node))\n                parent = node\n                loc = 'right'\n                node = node.right\n        return nodes\n\n    def delete(self, val: int):\n        \"\"\"\n        \u5b8c\u5168\u901a\u8fc7\u66f4\u65b0\u5f15\u7528\u5b9e\u73b0\n        \"\"\"\n        nodes = self._find(val)\n        if len(nodes) == 0: raise ValueError('%d is not in binary search tree' % val)\n\n        def update(loc: str, parent: Node, child: Node = None):\n            if loc == 'left':\n                parent.left = child\n            else:\n                parent.right = child\n\n        for parent, loc, node in nodes[::-1]:\n            if not (node.left or node.right):\n                update(loc, parent)\n            elif node.left and not node.right:\n                update(loc, parent, node.left)\n            elif node.right and not node.left:\n                update(loc, parent, node.right)\n            else:\n                min_child = node.right\n                min_child_parent = node\n                while min_child.left:\n                    min_child_parent = min_child\n                    min_child = min_child.left\n                update(loc, parent, min_child)\n                min_child.left = node.left\n                min_child.right = node.right if node.right is not min_child else None\n                min_child_parent.left = None\n\n    def delete_(self, val: int):\n        \"\"\"\n        \u901a\u8fc7\u66ff\u6362\u6570\u636e\u5b9e\u73b0\n        \"\"\"\n        nodes = self._find(val)\n        if len(nodes) == 0: raise ValueError('%d is not in binary search tree' % val)\n\n        for parent, _, node in nodes[::-1]:\n            # \u5f85\u5220\u9664\u8282\u70b9\u6709\u4e24\u4e2a\u5b50\u8282\u70b9\n            if node.left and node.right:\n                min_child = node.right\n                min_child_parent = node\n                while min_child.left:\n                    min_child_parent = min_child\n                    min_child = min_child.left\n                node.val = min_child.val\n                node = min_child\n                parent = min_child_parent\n\n            # \u5f85\u5220\u9664\u7684\u8282\u70b9\u6ca1\u6709\u5b50\u8282\u70b9\u6216\u53ea\u6709\u4e00\u4e2a\n            if node.left:\n                node_child = node.left\n            elif node.right:\n                node_child = node.right\n            else:\n                node_child = None\n\n            if parent is None:\n                self.root = node_child\n            elif parent.left is node:\n                parent.left = node_child\n            else:\n                parent.right = node_child\n\n    def find(self, val: int):\n        nodes = self._find(val)\n        return nodes\n\n    def pre_order(self):\n        node = self.root\n        nodes_list = []\n        rights = []\n        while True:\n            nodes_list.append(node.val)\n            if node.left:\n                if node.right:\n                    rights.append(node.right)\n                node = node.left\n            elif node.right:\n                node = node.right\n            else:\n                if len(rights) == 0:\n                    break\n                node = rights.pop()\n        return nodes_list\n\n    def pre_order_recursive(self):\n        nodes_list = []\n\n        def recurse(root: Node):\n            if root is not None:\n                nodes_list.append(root.val)\n                recurse(root.left)\n                recurse(root.right)\n\n        recurse(self.root)\n        return nodes_list\n\n    def in_order(self):\n        nodes_list = []\n\n        def recurse(root: Node):\n            if root is not None:\n                recurse(root.left)\n                nodes_list.append(root.val)\n                recurse(root.right)\n\n        recurse(self.root)\n        return nodes_list\n\n    def post_order(self):\n        nodes_list = []\n\n        def recurse(root: Node):\n            if root is not None:\n                recurse(root.left)\n                recurse(root.right)\n                nodes_list.append(root.val)\n\n        recurse(self.root)\n        return nodes_list\n\n    def get_height(self):\n        \"\"\"\n        \u6df1\u5ea6\u904d\u5386\n        \"\"\"\n\n        def _get_height(root):\n            if root is None:\n                return -1\n            return max(_get_height(root.left), _get_height(root.right)) + 1\n\n        height = _get_height(self.root)\n        return height\n\n    def get_height_(self):\n        \"\"\"\n        \u5e7f\u5ea6\u904d\u5386\n        \"\"\"\n        current = [self.root]\n        next_ = []\n        height = -1\n        while current:\n            node = current.pop(0)\n            if node.left:\n                next_.append(node.left)\n            if node.right:\n                next_.append(node.right)\n            if len(current) == 0:\n                height += 1\n                current, next_ = next_, []\n        return height\n\n# main function\ndef main_solution(values: List[int], operation: str, value: Optional[int] = None):\n    \"\"\"\n    Main function to perform operations on a Binary Search Tree.\n\n    Input:\n    - values (List[int]): A list of integers to be inserted into the Binary Search Tree.\n    - operation (str): The operation to perform on the BST. Possible values: \"insert\", \"delete\", \"find\", \"pre_order\", \"in_order\", \"post_order\", \"height\".\n    - value (Optional[int]): The value to be used for the operation. Required for \"insert\", \"delete\", and \"find\" operations.\n\n    Output:\n    - return (Union[List[int], int, bool]): The result of the operation. For \"insert\" and \"delete\", returns True if successful. For \"find\", returns a list of nodes found. For traversal operations (\"pre_order\", \"in_order\", \"post_order\"), returns a list of node values. For \"height\", returns the height of the BST.\n    \"\"\"\n    bst = BinarySearchTree()\n    for val in values:\n        bst.insert(val)\n\n    if operation == \"insert\":\n        bst.insert(value)\n        return True\n    elif operation == \"delete\":\n        bst.delete(value)\n        return True\n    elif operation == \"find\":\n        nodes = bst.find(value)\n        return [node[2].val for node in nodes]\n    elif operation == \"pre_order\":\n        return bst.pre_order()\n    elif operation == \"in_order\":\n        return bst.in_order()\n    elif operation == \"post_order\":\n        return bst.post_order()\n    elif operation == \"height\":\n        return bst.get_height_()\n    else:\n        raise ValueError(\"Invalid operation\")", "input_generator": "import random\nfrom typing import List, Optional\n\ndef input_generator():\n    operations = [\"insert\", \"delete\", \"find\", \"pre_order\", \"in_order\", \"post_order\", \"height\"]\n    operation = random.choice(operations)\n    \n    # Generate a list of values for the BST\n    values = []\n    num_values = random.randint(1, 20)\n    for _ in range(num_values):\n        values.append(random.randint(1, 100))\n    \n    # For operations that require a value, generate a random value\n    value = None\n    if operation in [\"insert\", \"delete\", \"find\"]:\n        value = random.randint(1, 100)\n    \n    return {\n        \"values\": values,\n        \"operation\": operation,\n        \"value\": value\n    }", "io_pairs": [{"input": {"values": [81, 4, 66, 73, 76, 45, 42, 74], "operation": "post_order", "value": null}, "output": [42, 45, 74, 76, 73, 66, 4, 81]}, {"input": {"values": [97, 18, 45, 52], "operation": "in_order", "value": null}, "output": [18, 45, 52, 97]}, {"input": {"values": [83, 11, 52, 32, 73, 32, 62, 30, 54, 42, 12, 94, 26, 32, 62], "operation": "find", "value": 55}, "output": []}, {"input": {"values": [95, 88, 98, 44, 93, 78, 54, 88, 69, 51, 59, 42], "operation": "pre_order", "value": null}, "output": [95, 88, 44, 42, 78, 54, 51, 69, 59, 93, 88, 98]}, {"input": {"values": [79, 82, 84, 75, 29, 14, 89, 35, 69, 26, 8, 59], "operation": "delete", "value": 75}, "output": true}, {"input": {"values": [98, 56, 33, 78, 82, 69, 53], "operation": "pre_order", "value": null}, "output": [98, 56, 33, 53, 78, 69, 82]}, {"input": {"values": [31, 12, 29, 46, 48], "operation": "insert", "value": 92}, "output": true}, {"input": {"values": [36, 27, 70, 65, 32, 74, 20, 60, 44, 60], "operation": "height", "value": null}, "output": 4}, {"input": {"values": [72], "operation": "in_order", "value": null}, "output": [72]}, {"input": {"values": [22, 9, 97, 40, 39, 49, 20], "operation": "in_order", "value": null}, "output": [9, 20, 22, 39, 40, 49, 97]}], "error_log": []}
{"context": "Given a set of logical variables and a collection of clauses, each containing literals with specific polarities, determine the status of each clause. The status can be one of the following: \"UNSAT\" (unsatisfiable), \"UNIT\" (unit clause), \"SAT\" (satisfiable), or \"UNRESOLVED\". What is the status of each clause based on the provided variables and clauses?\n\nThe input and output requirements are as follows:\n\nInput:\n- `variables` (list of strings): A list of variable names.\n- `clauses` (list of lists of tuples): Each inner list represents a clause, and each tuple within the list represents a literal in the clause. The tuple contains a variable name (string) and its polarity (boolean).\n\nOutput:\n- `return` (dictionary): A dictionary where each key is a string representing the clause identifier (e.g., \"Clause_1\"), and the value is a string representing the status of the clause (\"UNSAT\", \"UNIT\", \"SAT\", \"UNRESOLVED\").", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Assignment:\n    def __init__(self, dl, var, val, clause):\n        self.dl = dl\n        self.var = var\n        self.val = val\n        self.clause = clause\n\nclass AssignmentStack(list):\n    push = list.append\n\nclass Variable:\n    def __init__(self, name):\n        self.stk_ptr = None\n        self.name = name\n        self.count = 0\n        self.waiting = False\n        self.occurrence = {True: OccurrenceList(), False: OccurrenceList()}\n\n    def __repr__(self):\n        return self.name\n\n    def value(self):\n        return None if not self.stk_ptr else self.stk_ptr.val\n\n    def assign(self, stk_ptr):\n        assert isinstance(stk_ptr, Assignment)\n        self.stk_ptr = stk_ptr\n\n    def unassign(self):\n        self.stk_ptr = None\n\n    def isAssigned(self):\n        return self.stk_ptr is not None\n\nclass Literal:\n    def __init__(self, variable, polarity=True):\n        self.variable = variable\n        self.polarity = polarity\n\n    def __hash__(self):\n        i = id(self.variable)\n        return i if self.polarity else -i\n\n    def __repr__(self):\n        return \"{}{}\".format(\"\" if self.polarity else \"-\", self.variable)\n\n    def __neg__(self):\n        return Literal(self.variable, not self.polarity)\n\n    def value(self):\n        v = self.variable.value()\n        if v is None:\n            return v\n        else:\n            return v if self.polarity else (not v)\n\n    def __eq__(self, x):\n        return hash(self) == hash(x)\n\n    def occurrence_link(self, clause):\n        self.occurrence().append(clause)\n\n    def occurrence_unlink(self, clause):\n        l = self.occurrence()\n        l = l.unlink(l.index(clause))\n        self.variable.occurrence[self.polarity] = l\n\n    def occurrence(self):\n        return self.variable.occurrence[self.polarity]\n\nclass Clause:\n    def __init__(self, *literals):\n        self.s = set(literals)\n        self.literals = list(literals)\n        first = (-1, 0)\n        second = (-1, 0)\n        self.max_lit = None\n        m = -1\n        for i, l in enumerate(self.literals):\n            if l.variable.stk_ptr:\n                dl = l.variable.stk_ptr.dl\n                if dl >= first[1]:\n                    second = first\n                    first = (i, dl)\n                if dl > m and l.variable.stk_ptr.clause:\n                    m = dl\n                    self.max_lit = l\n        if len(literals) > 1:\n            self.refA = first[0] if first[0] != -1 else 0\n            self.refB = second[0] if second[0] != -1 else ((self.refA + 1) % len(self.literals))\n\n    def link(self):\n        if len(self.literals) > 1:\n            self.literals[self.refA].occurrence_link(self)\n            self.literals[self.refB].occurrence_link(self)\n\n    def __repr__(self):\n        if len(self.literals) > 1:\n            s = []\n            for i, l in enumerate(self.literals):\n                t = \"*\" if i == self.refA or i == self.refB else \"\"\n                s.append(t + str(l))\n            return \"[{}]\".format(', '.join(s))\n        else:\n            return str(self.literals)\n\n    def __len__(self):\n        return len(self.literals)\n\n    def __eq__(self, x):\n        if isinstance(x, Clause):\n            return self.s == x.s\n        else:\n            return False\n\n    def __contains__(self, x):\n        return x in self.s\n\n    def __iter__(self):\n        return iter(self.literals)\n\n    def status(self):\n        if len(self.literals) < 1:\n            return \"UNSAT\"\n        elif len(self.literals) == 1:\n            v = self.literals[0].value()\n            if v is None:\n                self.unitLiteral = self.literals[0]\n                return \"UNIT\"\n            elif v:\n                return \"SAT\"\n            else:\n                return \"UNSAT\"\n        vA = self.literals[self.refA].value()\n        vB = self.literals[self.refB].value()\n        if vA or vB:\n            return \"SAT\"\n        elif (vA == False) and (vB == False):\n            return \"UNSAT\"\n        elif ((vA == False) ^ (vB == False)) and ((vA == None) ^ (vB == None)):\n            known, other = (self.refA, self.refB) if vA == None else (self.refB, self.refA)\n            for i in range(len(self.literals)):\n                if (i != known and self.literals[i].value() == None) or (self.literals[i].value()):\n                    if known == self.refA:\n                        self.refB = i\n                    else:\n                        self.refA = i\n                    lit_to_remove = self.literals[other]\n                    lit_to_add = self.literals[i]\n                    lit_to_remove.occurrence_unlink(self)\n                    lit_to_add.occurrence_link(self)\n                    if self.literals[i].value():\n                        return \"SAT\"\n                    break\n            else:\n                self.unitLiteral = self.literals[known]\n                return \"UNIT\"\n        return \"UNRESOLVED\"\n\n    def resolve(self, clause2):\n        assert isinstance(clause2, Clause)\n        all_literals = self.s.union(clause2.s)\n        shared_var = filter(lambda x: -x in all_literals, all_literals)\n        assert len(shared_var) == 2\n        for x in shared_var:\n            all_literals.remove(x)\n        return Clause(*all_literals)\n\nclass OccurrenceList(list):\n    def unlink(self, idx):\n        return OccurrenceList(self[:idx] + self[idx + 1:])\n\n# main function\ndef main_solution(variables, clauses):\n    # Convert JSON serializable inputs to original input variables\n    var_objects = {name: Variable(name) for name in variables}\n    clause_objects = []\n    for clause in clauses:\n        literals = [Literal(var_objects[var], polarity) for var, polarity in clause]\n        clause_objects.append(Clause(*literals))\n\n    # Main logic to determine the status of each clause\n    results = {}\n    for i, clause in enumerate(clause_objects):\n        results[f\"Clause_{i+1}\"] = clause.status()\n\n    # Convert the results to JSON serializable output\n    return results", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random number of variables (between 3 and 10)\n    num_vars = random.randint(3, 10)\n    variables = [f'v{i}' for i in range(1, num_vars + 1)]\n    \n    # Generate a random number of clauses (between 2 and 15)\n    num_clauses = random.randint(2, 15)\n    clauses = []\n    \n    for _ in range(num_clauses):\n        # Randomly decide the number of literals in the clause (between 1 and 5)\n        num_literals = random.randint(1, 5)\n        clause = []\n        used_vars = set()\n        \n        for _ in range(num_literals):\n            # Randomly select a variable, ensuring no duplicates in the clause\n            var = random.choice([v for v in variables if v not in used_vars])\n            used_vars.add(var)\n            # Randomly assign polarity (True or False)\n            polarity = random.choice([True, False])\n            clause.append((var, polarity))\n        \n        clauses.append(clause)\n    \n    return {'variables': variables, 'clauses': clauses}", "io_pairs": [], "error_log": []}
{"context": "Given a bus schedule and an earliest timestamp, what are the earliest bus ID and the waiting time product, and the earliest timestamp where all buses depart at offsets matching their positions in the schedule?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start` (int): The earliest timestamp to consider for finding the earliest bus.\n  `schedule` (str): A comma-separated string representing the bus IDs and 'x' for positions where no bus is present.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `part1` (int): The result of the first part of the problem, which is the product of the earliest bus ID and the waiting time.\n    - `part2` (int): The result of the second part of the problem, which is the earliest timestamp such that all buses depart at offsets matching their positions in the schedule.", "reference_code": "# import necessary packages\nfrom math import gcd\nfrom fractions import Fraction\nimport random\n\n# all class and function definitions in the code file, if any\ndef divisible(x, y):\n    return ((y % x) == 0)\n    \ndef extended_gcd(a, b):\n    last_r = a\n    curr_r = b\n    last_s = 1\n    curr_s = 0\n    last_t = 0\n    curr_t = 1\n    i = 1\n    while(curr_r != 0):\n        q = int(last_r/curr_r)\n        next_r = last_r - q * curr_r\n        next_s = last_s - q * curr_s\n        next_t = last_t - q * curr_t\n        \n        last_r = curr_r\n        curr_r = next_r\n        last_s = curr_s\n        curr_s = next_s\n        last_t = curr_t\n        curr_t = next_t\n        \n        i+=1\n    g = last_r\n    u = last_s\n    v = last_t\n    return(g, u, v)\n\n# main function\ndef main_solution(start, schedule):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    buses = []\n    bus_pos = []\n    schedule_split = schedule.split(',')\n    i = -1\n    for entry in schedule_split:\n        i += 1\n        if(entry == 'x'):\n            continue\n        buses.append(int(entry))\n        bus_pos.append(i)\n   \n    index = start\n    thebus = 0\n    done = False\n    while not done:\n        for bus in buses:\n            if divisible(bus, index):\n                thebus = bus\n                done = True\n                break\n        index += 1\n    \n    part1 = (index - start - 1) * thebus\n    \n    # chinese remainder theorem solution using extended GCD\n    last_modulus = buses[0]\n    last_remainder = bus_pos[0]\n    for i in range(1,len(buses)):\n        g,u,v = extended_gcd(last_modulus, buses[i])\n        last_remainder = v * buses[i] * last_remainder + u * last_modulus * bus_pos[i]\n        last_modulus *= buses[i]  \n        \n    part2 = last_modulus - (last_remainder % last_modulus)     \n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"part1\": part1, \"part2\": part2}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random start time between 1000 and 10000\n    start = random.randint(1000, 10000)\n    \n    # Generate a list of bus IDs, ensuring they are coprime or have common factors\n    # to make the problem non-trivial but solvable\n    bus_ids = []\n    num_buses = random.randint(3, 8)\n    for _ in range(num_buses):\n        # Choose a base ID from common bus ID patterns (primes or products of small primes)\n        base = random.choice([7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47])\n        # Sometimes multiply by a small integer to create non-prime IDs\n        if random.random() < 0.3:\n            base *= random.randint(2, 5)\n        bus_ids.append(base)\n    \n    # Create the schedule string with 'x's randomly inserted\n    schedule_parts = []\n    for i in range(num_buses + random.randint(0, 3)):  # Add some extra slots\n        if i < len(bus_ids) and random.random() < 0.8:  # 80% chance to add a bus ID\n            schedule_parts.append(str(bus_ids[i]))\n        else:\n            schedule_parts.append('x')\n    \n    schedule = ','.join(schedule_parts)\n    \n    return {\"start\": start, \"schedule\": schedule}", "io_pairs": [{"input": {"start": 9126, "schedule": "41,23,31,155,47,x"}, "output": {"part1": 115, "part2": 38049927}}, {"input": {"start": 8316, "schedule": "7,7,41,x"}, "output": {"part1": 0, "part2": 490}}, {"input": {"start": 3692, "schedule": "17,129,37,x,92,7,x,x,x"}, "output": {"part1": 28, "part2": 4424828}}, {"input": {"start": 4339, "schedule": "57,11,x,172,55,172"}, "output": {"part1": 66, "part2": 687289812}}, {"input": {"start": 9674, "schedule": "7,x,14,x"}, "output": {"part1": 0, "part2": 84}}, {"input": {"start": 1385, "schedule": "37,37,115,41,x,34,52,7,x,x"}, "output": {"part1": 7, "part2": 66127223176}}, {"input": {"start": 8067, "schedule": "65,38,21,x,x"}, "output": {"part1": 378, "part2": 5395}}, {"input": {"start": 5114, "schedule": "x,215,116,17,x"}, "output": {"part1": 51, "part2": 158454}}, {"input": {"start": 3850, "schedule": "7,23,x,31,x"}, "output": {"part1": 0, "part2": 896}}, {"input": {"start": 3294, "schedule": "26,7,11,x,x,x"}, "output": {"part1": 21, "part2": 1560}}], "error_log": []}
{"context": "Given the coefficients of a quadratic equation \\( ax^2 + bx + c = 0 \\), what are the roots of the equation?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): Coefficient of the quadratic term.\n  `b` (int): Coefficient of the linear term.\n  `c` (int): Constant term.\n\nOutput:\n  `return` (dict): A dictionary containing the roots of the quadratic equation.\n    - `root1` (str): The first root of the quadratic equation.\n    - `root2` (str): The second root of the quadratic equation.", "reference_code": "# import necessary packages\nimport cmath\n\n# main function\ndef main_solution(a, b, c):\n    # Convert inputs to integers\n    a = int(a)\n    b = int(b)\n    c = int(c)\n    \n    # Calculate the roots of the quadratic equation\n    discriminant = b**2 - 4*a*c\n    \n    # Calculate the two roots\n    root1 = (-b - cmath.sqrt(discriminant)) / (2 * a)\n    root2 = (-b + cmath.sqrt(discriminant)) / (2 * a)\n    \n    # Return the roots as a dictionary\n    return {\"root1\": str(root1), \"root2\": str(root2)}", "input_generator": "import random\n\ndef input_generator():\n    # Generate random coefficients a, b, c for a quadratic equation\n    # Ensure a is not zero\n    a = random.randint(-10, 10)\n    while a == 0:\n        a = random.randint(-10, 10)\n    b = random.randint(-20, 20)\n    c = random.randint(-20, 20)\n    \n    return {\"a\": a, \"b\": b, \"c\": c}", "io_pairs": [{"input": {"a": 10, "b": 18, "c": 15}, "output": {"root1": "(-0.9-0.8306623862918074j)", "root2": "(-0.9+0.8306623862918074j)"}}, {"input": {"a": 9, "b": -8, "c": -5}, "output": {"root1": "(-0.42336107510073934+0j)", "root2": "(1.3122499639896281+0j)"}}, {"input": {"a": 7, "b": -14, "c": 2}, "output": {"root1": "(0.1548457452714834+0j)", "root2": "(1.8451542547285165+0j)"}}, {"input": {"a": 3, "b": 14, "c": -3}, "output": {"root1": "(-4.871924368621303+0j)", "root2": "(0.20525770195463622+0j)"}}, {"input": {"a": -5, "b": 3, "c": 3}, "output": {"root1": "(1.1306623862918075-0j)", "root2": "(-0.5306623862918075-0j)"}}, {"input": {"a": -7, "b": -7, "c": 3}, "output": {"root1": "(0.32375447104791405-0j)", "root2": "(-1.323754471047914-0j)"}}, {"input": {"a": -8, "b": -1, "c": 0}, "output": {"root1": "(-0-0j)", "root2": "(-0.125-0j)"}}, {"input": {"a": 1, "b": 15, "c": -11}, "output": {"root1": "(-15.700609733428363+0j)", "root2": "(0.7006097334283634+0j)"}}, {"input": {"a": 5, "b": 17, "c": 5}, "output": {"root1": "(-3.074772708486752+0j)", "root2": "(-0.325227291513248+0j)"}}, {"input": {"a": -5, "b": -7, "c": -5}, "output": {"root1": "(-0.7+0.7141428428542851j)", "root2": "(-0.7-0.7141428428542851j)"}}], "error_log": []}
{"context": "Given a string composed of letters from the English alphabet, what is the Shannon entropy of the string? The Shannon entropy represents the minimum average number of bits per symbol required for encoding the string.\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string for which the Shannon entropy is to be calculated. The string should not contain any special characters or spaces, and its length should be reasonable (less than 1KB).\n\nOutput:\n  `return` (float): The Shannon entropy of the input string, represented as a floating-point number.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    stList = list(input_string)\n    \n    # Create a list of unique symbols in the string\n    alphabet = []\n    for i in stList:\n        if i not in alphabet:\n            alphabet.append(i)\n    \n    # Calculate the frequency of each symbol in the string\n    freqList = []\n    for symbol in alphabet:\n        ctr = 0\n        for sym in stList:\n            if sym == symbol:\n                ctr += 1\n        freqList.append(float(ctr) / len(stList))\n    \n    # Calculate Shannon entropy\n    ent = 0.0\n    for freq in freqList:\n        ent = ent + freq * math.log(freq, 2)\n    ent = -ent\n    \n    # Return the Shannon entropy as a float\n    return ent", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(5, 20)\n    chars = ''.join(random.choices(string.ascii_letters + string.digits + string.punctuation, k=length))\n    return {'input_string': chars}", "io_pairs": [{"input": {"input_string": "n86UGo"}, "output": 2.584962500721156}, {"input": {"input_string": "$,-a-9}"}, "output": 2.5216406363433186}, {"input": {"input_string": ")>g7v\\%*|%WG"}, "output": 3.4182958340544896}, {"input": {"input_string": "?FATgL"}, "output": 2.584962500721156}, {"input": {"input_string": "t,ust\\)>z,a=u"}, "output": 3.238901256602631}, {"input": {"input_string": "q(<?SC"}, "output": 2.584962500721156}, {"input": {"input_string": "[E4Y%!d8WI}"}, "output": 3.459431618637298}, {"input": {"input_string": "Du7(-z#"}, "output": 2.8073549220576046}, {"input": {"input_string": "p4[O)Z0SC"}, "output": 3.169925001442312}, {"input": {"input_string": "tlZ4c}5Oqq5C{|jE@p"}, "output": 3.9477027792200903}], "error_log": []}
{"context": "Given a sequence of complex numbers represented by their real and imaginary parts, what are the real and imaginary components of the discrete Fourier transform (DFT) of this sequence?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_real` (list of floats): A list of real parts of the complex numbers.\n  `input_imag` (list of floats): A list of imaginary parts of the complex numbers.\n\nOutput:\n  `return` (dictionary): A dictionary containing two keys:\n    - `output_real` (list of floats): A list of real parts of the DFT output.\n    - `output_imag` (list of floats): A list of imaginary parts of the DFT output.", "reference_code": "# import necessary packages\nimport cmath\nimport math\n\n# main function\ndef main_solution(input_real, input_imag):\n    # Convert JSON serializable inputs to the required format\n    input_complex = [complex(r, i) for r, i in zip(input_real, input_imag)]\n    \n    # Compute the DFT using the complex implementation\n    dft_output = compute_dft_complex(input_complex)\n    \n    # Convert the output to JSON serializable format\n    output_real = [d.real for d in dft_output]\n    output_imag = [d.imag for d in dft_output]\n    \n    return {\"output_real\": output_real, \"output_imag\": output_imag}\n\n# Function to compute DFT for complex numbers\ndef compute_dft_complex(input):\n    n = len(input)\n    output = []\n    for k in range(n):  # For each output element\n        s = complex(0)\n        for t in range(n):  # For each input element\n            angle = 2j * cmath.pi * t * k / n\n            s += input[t] * cmath.exp(-angle)\n        output.append(s)\n    return output", "input_generator": "import random\nimport cmath\n\ndef input_generator():\n    n = random.randint(1, 10)  # Generate a small sequence length\n    input_real = [random.uniform(-10.0, 10.0) for _ in range(n)]\n    input_imag = [random.uniform(-10.0, 10.0) for _ in range(n)]\n    return {\"input_real\": input_real, \"input_imag\": input_imag}", "io_pairs": [{"input": {"input_real": [-7.342028633854891, 7.190084473927229, -1.5712724134046656, -2.055824251282081], "input_imag": [3.801675257441829, -6.215843808062591, -1.6869657903840931, 9.526444815648414]}, "output": {"output_real": [-3.779040824614409, -21.51304484416123, -14.0475612699047, 9.971532403260776], "output_imag": [5.42531047464356, -3.757267677383389, -1.1958915405280877, 14.734549773035237]}}, {"input": {"input_real": [9.579196025143982, 9.045478347340367, -4.613596227871881, -8.939292779236606, -5.666171045778679], "input_imag": [-3.579690492770549, -2.003188300524956, -7.135323164236452, -8.969750852127556, 9.48917954805852]}, "output": {"output_real": [-0.5943856804028158, 11.736335151453204, -5.842482778667326, 11.156894704449936, 31.439618728886906], "output_imag": [-12.198773261600994, -4.771304062195799, -19.146034855972182, -10.079417541008187, 28.297077256924425]}}, {"input": {"input_real": [-2.1911776173381465, 3.136269062119954, 1.9441568692607518, -5.415947739703069, -3.327101096601332], "input_imag": [-8.114605540310343, 1.77593914520898, -4.497518159173892, -1.8485278825409317, -4.1659103311415695]}, "output": {"output_real": [-5.853800522261841, 4.652587101296711, 2.9022373194808515, -9.121504595988918, -3.535407389217542], "output_imag": [-16.85062276795776, -14.192279409155116, -4.941312519234774, -11.34291609836558, 6.754103093161511]}}, {"input": {"input_real": [4.5701180875180984, 6.911033191229432, -1.3481874249692343, 8.878030040662349, 3.1470708301932113, 5.115334843410423, -1.5674808293985762, -7.312214848327702], "input_imag": [4.329638838514498, -1.0696667321583035, -9.094474662458826, 1.186470311791247, 8.463879938391429, 2.998083722457782, 4.536852919216713, -1.7987158198201048]}, "output": {"output_real": [18.393703890318, -23.152250369585325, 13.173519670407458, 24.467367736500556, -8.790662563631008, -1.2643102791159864, 8.092194673750772, 5.641381941500294], "output_imag": [9.552068515934435, -22.058696220490404, 6.890587677842832, -11.645750836831475, 6.919725551393193, 13.351627211877853, 27.811693362453244, 3.815855445936271]}}, {"input": {"input_real": [3.675330261257997, 2.9857009632914675, 0.27205835598426376, 7.02155838970663], "input_imag": [2.20267475150761, -3.4580292378457056, -7.09569278306553, 3.3636638542789203]}, "output": {"output_real": [13.954647970240359, -3.4184211868508947, -6.059870735755835, 10.224964997398361], "output_imag": [-4.987383415124706, 13.334224960988301, -4.798652647991138, 5.262510108157979]}}, {"input": {"input_real": [-3.0500476405987476, -9.799570636834996, -5.313363172899031, 5.413371499324835, -9.7420242988056, -1.4151999391175565, 6.490315926157262, 7.267247768960289], "input_imag": [3.768242690356878, 1.3228575034727683, -8.90928488164737, -9.035490866306471, 2.0202740486205766, -4.089432023649449, -1.11917399735683, -6.8173211032033665]}, "output": {"output_real": [-10.149270493813546, -3.4573073756215393, -0.882787243329429, 21.35842818215503, -13.080967878478699, 1.261038923454148, -27.055262141995737, 7.605746902839803], "output_imag": [-22.859328629713264, 26.18673110655665, 39.71236546221933, -8.211726106928364, 14.379444349659764, 0.9165643750285435, -8.078414226256026, -11.899694807711601]}}, {"input": {"input_real": [3.369207026791779, 0.4032692767210193, -3.704822505083798, 8.385292271853203, 1.1127263848757778], "input_imag": [3.364705972319552, -5.637203409983167, -1.086502544080055, -5.941603144528966, 5.843526645813618]}, "output": {"output_real": [9.56567245515798, -8.01397073340167, -7.776593402922567, 14.954764348424911, 8.116162466700239], "output_imag": [-3.457076480459019, 16.8954452690229, -10.055391143899977, 12.10735688820969, 1.3331953287241627]}}, {"input": {"input_real": [6.495284303624246, 9.456582448187628], "input_imag": [4.522748086308816, 8.475192568511105]}, "output": {"output_real": [15.951866751811874, -2.961298144563381], "output_imag": [12.99794065481992, -3.9524444822022904]}}, {"input": {"input_real": [-6.547709158716817, 4.687106191769633, 6.873064357994963, 4.415256549388822, -9.867888395758852, -6.970736895170731, -7.322244292678414, 4.458908190108444], "input_imag": [1.4806818939592183, -2.2051608074612723, -2.0218974174812914, 5.212353149230866, 3.8695148825053316, -2.6806504204925874, 1.2519126433819476, -3.2565295130612064]}, "output": {"output_real": [-10.274243453062953, 14.645201737463925, -22.808052483915738, 4.644409315296388, -23.45531152525529, -14.552463385106314, -9.124782755668683, 8.54356928051418], "output_imag": [1.6502244105810062, -30.44879759866267, 17.277976993462257, 9.24618456232748, 7.510199594149396, -2.719485679776322, -5.037613892334461, 14.36676676192707]}}, {"input": {"input_real": [9.73338931966964, 6.254703101600505], "input_imag": [-5.6301458472310255, -8.853858094196474]}, "output": {"output_real": [15.988092421270146, 3.478686218069135], "output_imag": [-14.484003941427499, 3.223712246965448]}}], "error_log": []}
{"context": "Given a ciphertext or plaintext and a key, how can you determine the corresponding plaintext or ciphertext using the Vigen\u00e8re cipher? Specifically, what is the result of applying the Vigen\u00e8re cipher to the given `phrase` with the provided `key` in the specified `direction`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `phrase` (str): The ciphertext or plaintext to be encoded or decoded. It should be a string of uppercase letters.\n  `key` (str): The key used for the Vigen\u00e8re cipher. It should be a string of uppercase letters.\n  `direction` (str): The direction of the operation, either 'E' for encryption or 'D' for decryption.\n\nOutput:\n  `return` (str): The result of the Vigen\u00e8re cipher operation. It will be a string of uppercase letters.", "reference_code": "# import necessary packages\nimport string\nfrom math import fmod\n\n# VIGENERE CIPHER. This is actually what Brainchase is using.\n# From https://github.com/deed02392/vigenere/blob/master/vigenere.py\n\n# The minimum and maximum valid char, ascii table defined order\nascii_min = ord('A')\nascii_max = ord('Z')\n\ndef vigenere(phrase, key, direction = 'D'):\n    # Generate a string of all the possible chars\n    alpha = \"\"\n    for printable in range(ascii_min, ascii_max+1):\n        alpha = alpha + chr(printable)\n\n    # Ensure the key is at least as long as the ciphertext by cat'ing it\n    while len(key) < len(phrase):\n       key = key + key\n    key = key[0:len(phrase)]\n\n    out = \"\"\n    for i in range(len(phrase)):\n        index_from_phrase = (ord(phrase[i]) - ascii_min)\n        index_from_key = ord(key[i]) - ascii_min\n        difference = (index_from_phrase - index_from_key)\n\n        # We want the sign of the dividend so we use fmod()\n        # Use the inverse of this result (I'm not certain why - is there a simpler way?\n        \n        if (direction == 'D'): # decrypt\n            intersect = int(fmod(index_from_phrase + index_from_key, (ascii_max - ascii_min + 1)) * +1)\n\n        if (direction == 'E'): # encrypt\n            intersect = int(fmod(index_from_phrase - index_from_key, (ascii_max - ascii_min + 1)) *  1)\n            \n        letter = alpha[intersect]\n        out += letter\n\n    return out, key\n\n# main function\ndef main_solution(phrase, key, direction):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    decoded, _ = vigenere(phrase, key, direction)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return decoded", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random phrase and key consisting of uppercase letters\n    length = random.randint(5, 20)\n    phrase = ''.join(random.choices(string.ascii_uppercase, k=length))\n    key_length = random.randint(3, 10)\n    key = ''.join(random.choices(string.ascii_uppercase, k=key_length))\n    direction = random.choice(['D', 'E'])\n    \n    return {\n        'phrase': phrase,\n        'key': key,\n        'direction': direction\n    }", "io_pairs": [{"input": {"phrase": "RGIWDID", "key": "LSLAXTH", "direction": "D"}, "output": "CYTWABK"}, {"input": {"phrase": "EZQRVUKMHPVDHVKRGMC", "key": "ILMRBM", "direction": "D"}, "output": "MKCIWGSXTGWPPGWIHYK"}, {"input": {"phrase": "WBJVTYUD", "key": "AQO", "direction": "E"}, "output": "WLVVDKUN"}, {"input": {"phrase": "BSKQJXCX", "key": "DQPLCYH", "direction": "D"}, "output": "EIZBLVJA"}, {"input": {"phrase": "AWCBTA", "key": "OLKQWPLTTB", "direction": "D"}, "output": "OHMRPP"}, {"input": {"phrase": "BPXZXUWWTKGB", "key": "VAEP", "direction": "D"}, "output": "WPBOSUALOKKQ"}, {"input": {"phrase": "WHLTSHNGWJZ", "key": "PSFLAHOMKI", "direction": "E"}, "output": "HPGISAZUMBK"}, {"input": {"phrase": "TOCXTZQNSZVT", "key": "BWDAM", "direction": "E"}, "output": "SSZXHYUKSNUX"}, {"input": {"phrase": "WJZWFLWLVDTJMQQYJJ", "key": "YCQE", "direction": "E"}, "output": "YHJSHJGHXBDFOOAULH"}, {"input": {"phrase": "UQRNXUDQTP", "key": "JZZSYSKO", "direction": "D"}, "output": "DPQFVMNECO"}], "error_log": []}
{"context": "Given an initial point (x0, y0) and a step size h, how does the Euler's method approximate the solution of a differential equation up to a specified end point end_x, and what is the error between the approximated solution and the real solution at that point?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x0` (float): The initial value of x.\n  `y0` (float): The initial value of y.\n  `end_x` (float): The final value of x to which the method should be applied.\n  `h` (float): The step size for the numerical method.\n\nOutput:\n  `return` (dict): A dictionary containing the final x value (`final_x`), the final y value (`final_y`), and the error (`error`) between the real solution and the final y value.", "reference_code": "# import necessary packages\nimport math\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef solution(x):\n    return (1/x) + 1\n\ndef function(x, y):\n    return (-1) / (pow(x, 2))\n\n# main function\ndef main_solution(x0, y0, end_x, h):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    all_x = []\n    all_y = []\n    all_x.append(x0)\n    all_y.append(y0)\n\n    i = 0\n    while all_x[i] < end_x:\n        all_x.append(all_x[i] + h)\n        all_y.append(all_y[i] + h * function(all_x[i], all_y[i]))\n        i += 1\n\n    real_solution = 1.25\n    error = abs(real_solution - all_y[i])\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"final_x\": all_x[i], \"final_y\": all_y[i], \"error\": error}", "input_generator": "import random\n\ndef input_generator():\n    x0 = random.uniform(0.1, 1.0)\n    y0 = solution(x0)\n    end_x = x0 + random.uniform(0.5, 2.0)\n    h = random.uniform(0.01, 0.1)\n    return {\"x0\": x0, \"y0\": y0, \"end_x\": end_x, \"h\": h}", "io_pairs": [{"input": {"x0": 0.7083281391286296, "y0": 2.411775058421622, "end_x": 2.4756945144846494, "h": 0.07135686097053175}, "output": {"final_x": 2.492249663391924, "final_y": 1.3335487451304162, "error": 0.08354874513041621}}, {"input": {"x0": 0.34126328343817813, "y0": 3.930288866487906, "end_x": 0.998621755190702, "h": 0.09743527753340957}, "output": {"final_x": 1.023310226172045, "final_y": 1.5677026735632038, "error": 0.3177026735632038}}, {"input": {"x0": 0.7112702485141532, "y0": 2.4059353699792796, "end_x": 2.07437120537982, "h": 0.06003002665564304}, "output": {"final_x": 2.091960861593943, "final_y": 1.423948507451732, "error": 0.17394850745173196}}, {"input": {"x0": 0.13101275579448773, "y0": 8.6328445572784, "end_x": 1.9798799498842532, "h": 0.09995634153744573}, "output": {"final_x": 2.0301832450059574, "final_y": -2.082824897147056, "error": 3.332824897147056}}, {"input": {"x0": 0.6601336718315627, "y0": 2.5148447089897217, "end_x": 1.8263316892677506, "h": 0.011528713536231588}, "output": {"final_x": 1.8360624525271898, "final_y": 1.533052499353401, "error": 0.28305249935340093}}, {"input": {"x0": 0.44932139495370393, "y0": 3.2255784194363493, "end_x": 1.9824564015065849, "h": 0.08878605133586627}, "output": {"final_x": 2.047470318999297, "final_y": 1.264889501215389, "error": 0.0148895012153889}}, {"input": {"x0": 0.8573464333627175, "y0": 2.166389642606619, "end_x": 2.274738721205283, "h": 0.0169876024123034}, "output": {"final_x": 2.284305035996207, "final_y": 1.427769881323799, "error": 0.1777698813237989}}, {"input": {"x0": 0.604306948636776, "y0": 2.6547881871222017, "end_x": 1.6002002564402829, "h": 0.06408408932624936}, "output": {"final_x": 1.629652377856765, "final_y": 1.5350148684746814, "error": 0.2850148684746814}}, {"input": {"x0": 0.7831430494706745, "y0": 2.2769059250106336, "end_x": 2.0484525769013118, "h": 0.05582937431000947}, "output": {"final_x": 2.067218658600894, "final_y": 1.443737718538843, "error": 0.19373771853884292}}, {"input": {"x0": 0.6039887843425114, "y0": 2.655659882970472, "end_x": 2.005417061460277, "h": 0.09508450580095354}, "output": {"final_x": 2.0302563713568142, "final_y": 1.3671337694078645, "error": 0.11713376940786446}}], "error_log": []}
{"context": "Given a knowledge base consisting of logical sentences, how can we determine if a specific logical axiom is true based on the provided knowledge base? Specifically, what is the result of testing the axiom against the knowledge base?\n\nThe input and output requirements are as follows:\n\nInput:\n  `kb` (list of strings): A list of logical sentences representing the knowledge base. Each sentence is a string.\n  `axiom` (string): A logical sentence to be tested against the knowledge base.\n\nOutput:\n  `return` (int): The result of the logical test. Returns `1` if the axiom is proven true based on the knowledge base, otherwise returns `0`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# Searchs for individual axioms\ndef sentSearch(axiom, kb) -> str:   \n    for index, x in enumerate(kb, start = 1):\n        if x[-1] == axiom:\n            return x\n    return \"Null\"\n\n# Searchs for full sentences\ndef truthSearch(axiom, kb) -> str:\n    for index, x in enumerate(kb, start = 1):\n        if x == axiom and len(x) == 1:\n            return x\n    return \"Null\"\n\n# Removes extra chars from sentence\ndef splitter(sentence) -> list:\n    sentence = sentence.replace('=','')\n    sentence = sentence.replace('>',' ')\n    sentence = sentence.replace('v',' ')\n    sentence = sentence.replace('^',' ')\n    split = sentence.split()\n    return split\n\n# Recursive function that handles the return values\ndef prove(axiom, kb, count) -> bool:\n    # Handles the basic and/or sentences \n    if axiom.find(\"^\") >= 0 or axiom.find(\"v\") >= 0:\n        count += 1\n        if count > 100:\n            return 0\n        q = []\n        key = \"\"\n        if axiom.find(\"^\") >= 0:\n            key = \"and\"\n        else:\n            key = \"or\"\n\n        x = splitter(axiom)\n\n        for y in x[:-1]:\n            z = sentSearch(y, kb)\n            q.append(prove(z, kb, count))\n\n        a = q.count(0)\n        b = q.count(1)\n\n        # Finds the amount of trues and falses and returns a value based off that\n        if key == \"and\":\n            if a >= 1:\n                return 0\n            else:\n                return 1\n        else:\n            if b >= 1:\n                return 1\n            else:\n                return 0\n\n    # Handles single imply sentences\n    elif axiom.find(\"=>\") >= 0:\n        x = splitter(axiom)\n        x = x[:-1]\n        z = sentSearch(x[0], kb)\n\n        if prove(z, kb, count) == 1:\n            return 1\n        else:\n            return 0\n\n    # Handles the end of a sentence\n    else:        \n        q = truthSearch(axiom, kb)\n        if q == \"Null\":\n            return 0\n        else: \n            return 1\n\n# main function\ndef main_solution(kb, axiom):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    count = 0\n    result = prove(axiom, kb, count)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Define possible axioms and components\n    components = ['p', 'q', 'r', 's', 't']\n    operators = ['=>', '^', 'v']\n    \n    # Generate a random knowledge base (kb)\n    kb_size = random.randint(3, 8)\n    kb = []\n    for _ in range(kb_size):\n        if random.random() < 0.5:\n            # Simple axiom\n            kb.append(random.choice(components))\n        else:\n            # Complex axiom with operator\n            op = random.choice(operators)\n            if op == '=>':\n                left = random.choice(components)\n                right = random.choice(components)\n                axiom = f\"{left}=>{right}\"\n            else:\n                left = random.choice(components)\n                right = random.choice(components)\n                axiom = f\"{left}{op}{right}\"\n            kb.append(axiom)\n    \n    # Generate a random axiom to prove\n    if random.random() < 0.7:\n        # Simple axiom\n        axiom = random.choice(components)\n    else:\n        # Complex axiom\n        op = random.choice(operators)\n        if op == '=>':\n            left = random.choice(components)\n            right = random.choice(components)\n            axiom = f\"{left}=>{right}\"\n        else:\n            left = random.choice(components)\n            right = random.choice(components)\n            axiom = f\"{left}{op}{right}\"\n    \n    return {'kb': kb, 'axiom': axiom}", "io_pairs": [{"input": {"kb": ["s", "s=>r", "s^r", "r=>r", "q", "s", "r", "s"], "axiom": "pvp"}, "output": 0}, {"input": {"kb": ["r", "s", "t^r", "t^p", "t"], "axiom": "r"}, "output": 1}, {"input": {"kb": ["pvs", "qvt", "r"], "axiom": "r"}, "output": 1}, {"input": {"kb": ["s", "q=>r", "rvp", "q=>p", "t", "t^p"], "axiom": "s^r"}, "output": 1}, {"input": {"kb": ["svt", "r=>s", "q", "p", "q", "t=>q", "t^t", "t^r"], "axiom": "r^s"}, "output": 0}, {"input": {"kb": ["pvs", "svr", "q", "svr", "qvp"], "axiom": "p"}, "output": 0}, {"input": {"kb": ["t", "q", "rvt", "t", "q", "p^t", "t"], "axiom": "t"}, "output": 1}, {"input": {"kb": ["r=>s", "tvr", "t^r", "t=>s", "s=>r", "t", "svt"], "axiom": "t"}, "output": 1}, {"input": {"kb": ["pvt", "q", "q", "r", "t^q", "t=>q", "s^q", "t^p"], "axiom": "t"}, "output": 0}, {"input": {"kb": ["r", "pvr", "svq", "rvp", "s^t"], "axiom": "p"}, "output": 0}], "error_log": []}
{"context": "Given two one-dimensional arrays of floating-point numbers, what is the cosine similarity between them, rounded to four decimal places?\n\nThe input and output requirements are as follows:\n\nInput:\n  `arr1` (list of float): A list of floating-point numbers representing the first one-dimensional array.\n  `arr2` (list of float): A list of floating-point numbers representing the second one-dimensional array.\n\nOutput:\n  `return` (float): The cosine similarity between the two input arrays, rounded to 4 decimal places.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(arr1, arr2):\n    # Convert JSON serializable inputs to numpy arrays\n    arr1 = np.array(arr1)\n    arr2 = np.array(arr2)\n    \n    # Calculate the magnitude of each array\n    magnitude_arr1 = np.linalg.norm(arr1)\n    magnitude_arr2 = np.linalg.norm(arr2)\n    \n    # Calculate the cosine similarity\n    cosine_similarity = np.dot(arr1, arr2) / (magnitude_arr1 * magnitude_arr2)\n    \n    # Round the result to 4 decimal places\n    cosine_similarity = round(cosine_similarity, 4)\n    \n    # Return the result as a JSON serializable output\n    return cosine_similarity", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    size = random.randint(2, 10)\n    arr1 = np.random.uniform(-10.0, 10.0, size).tolist()\n    arr2 = np.random.uniform(-10.0, 10.0, size).tolist()\n    return {'arr1': arr1, 'arr2': arr2}", "io_pairs": [{"input": {"arr1": [4.809821046354042, 2.327200966450217, -3.2571443515844134, -4.770584429733553, 1.7242505502852463], "arr2": [8.968603277289454, 9.085402344610934, 8.034491126590467, -9.732939149274259, 4.717254484421227]}, "output": 0.6198}, {"input": {"arr1": [-6.343351821856862, -4.312209100208895, -1.3285801327532631, -7.162936941160227], "arr2": [9.548163340048966, -4.102699635621796, -3.3464435749938604, 1.75880425882516]}, "output": -0.4362}, {"input": {"arr1": [9.797286911207394, -2.733819238904047], "arr2": [8.04323079487903, -6.903230880873467]}, "output": 0.906}, {"input": {"arr1": [-9.884411427508368, -0.1143109127541706], "arr2": [-4.122103951588063, 3.6963174205680023]}, "output": 0.7367}, {"input": {"arr1": [-1.3829309273767159, -8.486046428983457, -6.423353237405802], "arr2": [2.680946044458853, -5.626731675612393, 4.848133232031307]}, "output": 0.1522}, {"input": {"arr1": [-1.3024866384470197, 1.9357403682549794, 8.266962146203394, 0.23571913934188515, -3.8832173328531683, 7.318782390994819], "arr2": [3.1142913894363122, 6.133311641522482, 9.914057031764717, 4.059947789813581, -4.830476327017548, -9.4007114128359]}, "output": 0.206}, {"input": {"arr1": [-0.6497525098532879, -5.240878095602097, 9.936867218845059, 5.588722694040406, 0.018728655800554606, -2.4823908524054623, 8.264549091051421, 0.22148184153014938, 9.82407722264998], "arr2": [7.09452487699793, 4.297333351070108, 8.062820772265795, -3.5916202275291393, -8.25804430196732, -6.558224907062041, -7.91211612253544, 2.964470256009058, -1.2289876630299936]}, "output": -0.0842}, {"input": {"arr1": [-4.61316927794001, -5.430358771394372, 0.8116393001989692, -6.191268252116757, -4.620332272775649, 0.997725461018268, 6.302228548817375, -1.2401892097680047, 5.317042271786168], "arr2": [-0.4164495299776547, 1.8348849502397346, -0.7940431501778829, -7.8367497418946215, -0.8843623624714212, 2.4966176262249355, 5.336015216258559, -5.9327266280492825, 4.030519354344321]}, "output": 0.6539}, {"input": {"arr1": [-8.745212952726945, 6.96038064617289, -6.865438891695348, -7.926505075716753, 1.341445558839185, 4.878796042248382, -7.77511210278842], "arr2": [-9.74342339926059, -8.19063919015531, 9.805425076233881, 1.9711861355577085, 4.871312897308682, 5.037950497618887, -7.480997018783954]}, "output": 0.1006}, {"input": {"arr1": [8.85827192182905, 3.8560403105551444, 6.603024852024152, 8.387722333640557, 5.183213514772458, 5.7475049768760265, -2.816220511260754, 8.921601903564273, -9.64341605807867], "arr2": [9.075330743347973, 0.8437894756571769, 5.600229418783497, 6.621038136921193, 8.866902461336984, -7.980548834309675, 4.718424818357729, -4.586051408182361, -2.7608000793638343]}, "output": 0.3748}], "error_log": []}
{"context": "Given a text and a key, how can you either encrypt or decrypt the text using the Vigen\u00e8re cipher method? Specifically, what would be the resulting text after applying the chosen operation (encryption or decryption) with the provided key?\n\nThe input and output requirements are as follows:\n\nInput:\n  `mode` (str): A string indicating the operation mode. It can be either \"encrypt\" or \"decrypt\".\n  `key` (str): A string representing the encryption/decryption key. It should not contain spaces.\n  `text` (str): A string representing the text to be encrypted or decrypted. It can contain both alphabetic and non-alphabetic characters.\n\nOutput:\n  `return` (str): A string representing the result of the encryption or decryption operation. It will contain both alphabetic and non-alphabetic characters as per the input text.", "reference_code": "# import necessary packages\nimport string\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# the string of all lowercase and uppercase letters in that order\nalphabet = string.ascii_letters\n\n# this function takes an array of numbers and non-alphabet symbols to convert to the new text which is either plaintext or ciphertext\ndef new_text(code):\n    final = \"\"\n    for i in code:\n        if isinstance(i, int):\n            # the ints in the code array match to indexes of corresponding letters in alphabet, so that letter is appended to the text\n            final += alphabet[i]\n        else:\n            # all the other indexes in code array will be in another array that holds a non-alphabetic symbol from the inputed text that is preserved to be put into the new text\n            final += i[0]              \n    return final\n\n# takes in key with the plaintext to encrypt\ndef encrypt(string, key):\n    nonAlphabet = 0\n    ciphertext = []\n    key = space(key)\n\n    # encrypting indexes of the inputted string\n    for i in range(len(string)):\n        if not (string[i] in alphabet):\n            # appending the non-alphabetic symbol and incrementing the counter\n            ciphertext.append([string[i]])\n            nonAlphabet += 1\n        else:\n            # using an encryption equation: [ciphertext at index i =(plaintext at i + key at i)%26]\n            # the mod is taken to loop back around just in case the key is too short\n            index = ((alphabet.index(string[i]) + alphabet.index(key[((i-nonAlphabet) % len(key))])) % 26)\n            # for uppercase letters, add 26 to go from lowercase to uppercase\n            if string[i].isupper():\n                index += 26\n            ciphertext.append(index)\n\n    return new_text(ciphertext)\n\n# takes in key with the plaintext to decrypt\ndef decrypt(string, key):\n    nonAlphabet = 0\n    plaintext = []\n    key = space(key)\n    \n    # decrypting indexes of the inputted string\n    for i in range(len(string)):\n        if not (string[i] in alphabet):\n            plaintext.append([string[i]])\n            nonAlphabet += 1\n        else:\n            # using a decryption equation:[plaintext at index i =(ciphertext at i + key at i)%26]\n            # the mod is taken to loop back around just in case the key is too short\n            index = ((26 + alphabet.index(string[i]) - alphabet.index(key[((i-nonAlphabet) % len(key))])) % 26)\n            # for uppercase letters, add 26 to go from lowercase to uppercase\n            if string[i].isupper():\n                index += 26\n            plaintext.append(index)\n\n    return new_text(plaintext)\n\n# this function is here to take the spaces out of the key\ndef space(key):\n    key = key.split()\n    key = \"\".join(key)\n    return key\n\n# main function\ndef main_solution(mode, key, text):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    if mode == \"encrypt\":\n        result = encrypt(text, key)\n    elif mode == \"decrypt\":\n        result = decrypt(text, key)\n    else:\n        raise ValueError(\"Invalid mode. Choose either 'encrypt' or 'decrypt'.\")\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    modes = ['encrypt', 'decrypt']\n    mode = random.choice(modes)\n    \n    # Generate a random key with letters and possibly spaces\n    key_length = random.randint(3, 10)\n    key = ''.join(random.choices(string.ascii_letters + ' ', k=key_length))\n    \n    # Generate text with letters and possibly some non-alphabet characters\n    text_length = random.randint(5, 20)\n    text_chars = []\n    for _ in range(text_length):\n        if random.random() < 0.8:  # 80% chance of being a letter\n            text_chars.append(random.choice(string.ascii_letters))\n        else:\n            text_chars.append(random.choice(string.punctuation + ' '))\n    text = ''.join(text_chars)\n    \n    return {\n        'mode': mode,\n        'key': key,\n        'text': text\n    }", "io_pairs": [{"input": {"mode": "decrypt", "key": "jRoLER", "text": "VyADDSjquJtgxHj#x*"}, "output": "MhMSZBazgYppoQv#m*"}, {"input": {"mode": "encrypt", "key": "xNpCZCDe", "text": "lj=}NUzG(l"}, "output": "iw=}CWyI(o"}, {"input": {"mode": "decrypt", "key": "nfFpb", "text": "?alNjfCPWCheklZvBZkp"}, "output": "?ngIuePKRNgrfgKuOUfa"}, {"input": {"mode": "decrypt", "key": "wWNJh", "text": "=}XX,}TP"}, "output": "=}BB,}GG"}, {"input": {"mode": "encrypt", "key": "ZyvSYLai", "text": "P~]g)/xa\"bRAyv"}, "output": "O~]e)/ss\"zCAgu"}, {"input": {"mode": "decrypt", "key": "cw GMXuLvM", "text": "J#tB?Quj]riG.XsRDQ`r"}, "output": "H#xV?Exp]gnU.VwLRT`x"}, {"input": {"mode": "encrypt", "key": "ucOy", "text": "m.Fe@#mDd@e"}, "output": "g.Hs@#kXf@s"}, {"input": {"mode": "encrypt", "key": "LVx", "text": "ybjl*gA"}, "output": "jwgw*bX"}, {"input": {"mode": "decrypt", "key": "xiPRJ KGkq", "text": "T#R*].@\"!"}, "output": "W#J*].@\"!"}, {"input": {"mode": "decrypt", "key": "tzV", "text": "VQ,s{AlGDlCAr"}, "output": "CR,x{HmLKmHHs"}], "error_log": []}
{"context": "Given a set of `n` items, how many ways can you choose `k` items from this set? (Note: The order of selection does not matter.)\n\nThe input and output requirements are as follows:\n\nInput:\n- `n` (int): The total number of items.\n- `k` (int): The number of items to choose from the total.\n\nOutput:\n- `return` (float): The binomial coefficient C(n, k), which represents the number of ways to choose `k` items from `n` items.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(n, k):\n    # Convert input to integers\n    n = int(n)\n    k = int(k)\n    \n    # Use the binomial_coefficient2 function to compute the binomial coefficient\n    def binomial_coefficient2(n, k):\n        if n - k < k:\n            k = n - k\n        res = 1\n        for i in range(k):\n            res *= (n - i)\n            res /= (i + 1)\n        return res\n    \n    # Compute the binomial coefficient\n    result = binomial_coefficient2(n, k)\n    \n    # Return the result as a float\n    return float(result)", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 100)\n    k = random.randint(0, n)\n    return {'n': n, 'k': k}", "io_pairs": [{"input": {"n": 44, "k": 23}, "output": 2012616400080.0}, {"input": {"n": 55, "k": 36}, "output": 280576272201225.0}, {"input": {"n": 30, "k": 13}, "output": 119759850.0}, {"input": {"n": 77, "k": 67}, "output": 1096993404430.0}, {"input": {"n": 81, "k": 61}, "output": 4.694436188839118e+18}, {"input": {"n": 23, "k": 3}, "output": 1771.0}, {"input": {"n": 14, "k": 4}, "output": 1001.0}, {"input": {"n": 72, "k": 37}, "output": 4.305527418909764e+20}, {"input": {"n": 96, "k": 64}, "output": 2.970174777301666e+25}, {"input": {"n": 32, "k": 5}, "output": 201376.0}], "error_log": []}
{"context": "Given a list of integers, what is the least common multiple (LCM) of all the numbers in the list?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numbers` (list of int): A list of integers for which the least common multiple (LCM) needs to be calculated.\n\nOutput:\n  `return` (float): The least common multiple (LCM) of the input list of integers.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef get_gcb(a, b):\n    if a < b:\n        temp = a\n        a = b\n        b = temp\n\n    while b != 0:\n        r = a % b\n        a = b\n        b = r\n    return a\n\ndef get_multiple(l):\n    if len(l) == 2:\n        return l[0] * l[1] / get_gcb(l[0], l[1])\n    multiple = get_multiple(l[1:])\n    return l[0] * multiple / get_gcb(l[0], multiple)\n\n# main function\ndef main_solution(numbers):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = get_multiple(numbers)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "input_generator": "import random\n\ndef input_generator():\n    length = random.randint(2, 5)\n    numbers = [random.randint(1, 100) for _ in range(length)]\n    return {'numbers': numbers}", "io_pairs": [{"input": {"numbers": [87, 18, 25, 31]}, "output": 404550.0}, {"input": {"numbers": [38, 66, 72, 90, 57]}, "output": 75240.0}, {"input": {"numbers": [54, 34, 25, 66]}, "output": 252450.0}, {"input": {"numbers": [79, 88, 27, 72]}, "output": 187704.0}, {"input": {"numbers": [87, 88]}, "output": 7656.0}, {"input": {"numbers": [22, 45, 22, 9]}, "output": 990.0}, {"input": {"numbers": [44, 41, 85]}, "output": 153340.0}, {"input": {"numbers": [73, 39, 97]}, "output": 276159.0}, {"input": {"numbers": [31, 59, 2]}, "output": 3658.0}, {"input": {"numbers": [67, 81, 54]}, "output": 10854.0}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, the user plays first and makes a series of moves. Given the sequence of the user's moves, determine the outcome of the game. Will the user win, will the CPU win, or will the game end in a draw?\n\nThe input and output requirements are as follows:\n\nInput:\n  `user_moves` (list of integers): A list of integers representing the user's moves in the game. Each integer should be between 1 and 9, inclusive, corresponding to the positions on the numpad.\n\nOutput:\n  `return` (string): A string indicating the result of the game. Possible values are \"User\" if the user wins, \"CPU\" if the CPU wins, or \"Draw\" if the game ends in a draw.", "reference_code": "# import necessary packages\nimport numpy as np\nimport random\n\n# all class and function definitions in the code file, if any\nclass Player(object):\n    def __init__(self, name):\n        self.name = name\n        self.tiles = np.full((3,3), False)\n\nclass Game(object):\n    def __init__(self):\n        self.init()\n        self.turn = 0\n\n    def init(self):\n        self.user = Player(\"User\")\n        self.cpu = Player(\"CPU\")\n        self.game = Player(\"N/A\")\n        self.turn = 0\n\n    def get_win(self, p):\n        if p.tiles[1,1]:\n            if p.tiles[1, 0:3].all():\n                return True\n            if p.tiles[0:3, 1].all():\n                return True\n            if p.tiles[0,0] and p.tiles[1,1] and p.tiles[2,2]:\n                return True\n            if p.tiles[0,2] and p.tiles[1,1] and p.tiles[2,0]:\n                return True\n        if p.tiles[0, 0:3].all():\n            return True\n        if p.tiles[2, 0:3].all():\n            return True\n        if p.tiles[0:3, 0].all():\n            return True\n        if p.tiles[0:3, 2].all():\n            return True\n        return False\n\n    def cpu_turn(self):\n        moved = False\n        if not self.game.tiles[1,1]:\n            self.game.tiles[1,1] = True\n            self.cpu.tiles[1,1] = True\n            moved = True\n        if not moved:\n            var = self.check_win_pot(self.cpu)\n            r = var[0]\n            c = var[1]\n            if (r + c) != -2:\n                self.game.tiles[r,c] = True\n                self.cpu.tiles[r,c] = True\n                moved = True\n        if not moved:\n            var = self.check_win_pot(self.user)\n            r = var[0]\n            c = var[1]\n            if (r + c) != -2:\n                self.game.tiles[r,c] = True\n                self.cpu.tiles[r,c] = True\n                moved = True\n        if not moved:\n            var = self.rand_corner()\n            r = var[0]\n            c = var[1]\n            self.game.tiles[r,c] = True\n            self.cpu.tiles[r,c] = True\n\n    def check_win_pot(self, p):\n        if p.tiles[1,1]:\n            if self.get_win_pot(p, [4,5,6]):\n                return self.get_winning_move(p, [4,5,6])\n            if self.get_win_pot(p, [2,5,8]):\n                return self.get_winning_move(p, [2,5,8])\n            if self.get_win_pot(p, [1,5,9]):\n                return self.get_winning_move(p, [1,5,9])\n            if self.get_win_pot(p, [3,5,7]):\n                return self.get_winning_move(p, [3,5,7])\n        if self.get_win_pot(p, [1,2,3]):\n            return self.get_winning_move(p, [1,2,3])\n        if self.get_win_pot(p, [7,8,9]):\n            return self.get_winning_move(p, [7,8,9])\n        if self.get_win_pot(p, [1,4,7]):\n            return self.get_winning_move(p, [1,4,7])\n        if self.get_win_pot(p, [3,6,9]):\n            return self.get_winning_move(p, [3,6,9])\n        return [-1,-1]\n\n    def get_win_pot(self, p, tiles):\n        p_tiles = []\n        game_tiles = []\n        for put in tiles:\n            r = int((put-1)/3)\n            c = (put-1)%3\n            p_tiles.append(p.tiles[r,c])\n            game_tiles.append(self.game.tiles[r,c])\n        game_tiles = np.logical_not(game_tiles)\n        score = np.sum(p_tiles) + 0.5 * np.sum(game_tiles)\n        return score == 2.5\n\n    def get_winning_move(self, p, tiles):\n        for put in tiles:\n            r = int((put-1)/3)\n            c = (put-1)%3\n            if not self.game.tiles[r,c]:\n                return [r,c]\n        return [-1,-1]\n\n    def rand_corner(self):\n        corners = [1,3,7,9]\n        corners = random.sample(corners, 4)\n        for put in corners:\n            r = int((put-1)/3)\n            c = (put-1)%3\n            if not self.game.tiles[r,c]:\n                return [r,c]\n        noncorners = [2,4,5,6,8]\n        noncorners = random.sample(noncorners, 5)\n        for put in noncorners:\n            r = int((put-1)/3)\n            c = (put-1)%3\n            if not self.game.tiles[r,c]:\n                return [r,c]\n        return [-1,-1]\n\n# main function\ndef main_solution(user_moves):\n    game = Game()\n    for move in user_moves:\n        r = int((move-1)/3)\n        c = (move-1)%3\n        game.game.tiles[r,c] = True\n        game.user.tiles[r,c] = True\n        if game.get_win(game.user):\n            return \"User\"\n        game.cpu_turn()\n        if game.get_win(game.cpu):\n            return \"CPU\"\n    return \"Draw\"", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random number of user moves (between 1 and 5)\n    num_moves = random.randint(1, 5)\n    \n    # Generate random unique moves (1-9)\n    possible_moves = list(range(1, 10))\n    user_moves = random.sample(possible_moves, num_moves)\n    \n    return {'user_moves': user_moves}", "io_pairs": [{"input": {"user_moves": [8, 6, 3, 7]}, "output": "CPU"}, {"input": {"user_moves": [7, 4, 6]}, "output": "CPU"}, {"input": {"user_moves": [4, 3, 2]}, "output": "Draw"}, {"input": {"user_moves": [7]}, "output": "Draw"}, {"input": {"user_moves": [7, 2, 5, 6, 3]}, "output": "CPU"}, {"input": {"user_moves": [5]}, "output": "Draw"}, {"input": {"user_moves": [2, 8]}, "output": "Draw"}, {"input": {"user_moves": [2]}, "output": "Draw"}, {"input": {"user_moves": [2, 8, 5]}, "output": "User"}, {"input": {"user_moves": [7, 9, 4]}, "output": "CPU"}], "error_log": []}
{"context": "Given a sequence of integers, determine if it represents the post-order traversal of a Binary Search Tree (BST). A Binary Search Tree is a binary tree where the value of each node is greater than or equal to any value stored in its left subtree and less than or equal to any value stored in its right subtree. What is the result of verifying the given sequence as a post-order traversal of a BST?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sequence` (list of integers): A list of integers representing the sequence to be verified as the post-order traversal of a Binary Search Tree (BST).\n\nOutput:\n  `return` (string): A string indicating whether the input sequence is a valid post-order traversal of a BST. The possible values are \"Yes\" or \"No\".", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, sequence):\n        if not sequence:\n            return False\n        length = len(sequence)\n        root = sequence[-1]\n        i = 0\n        while i < length - 1:\n            if sequence[i] > root:\n                break\n            i += 1\n        j = i\n        while j < length - 1:\n            if sequence[j] < root:\n                return False\n            j += 1\n        left = True\n        if i > 0:\n            left = self.VerifySquenceOfBST(sequence[:i])\n        right = True\n        if i < length - 1:\n            right = self.VerifySquenceOfBST(sequence[i:-1])\n        return left and right\n\n# main function\ndef main_solution(sequence):\n    # Convert input to list if it's not already\n    if not isinstance(sequence, list):\n        sequence = list(sequence)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the VerifySquenceOfBST method\n    result = solution.VerifySquenceOfBST(sequence)\n    \n    # Convert the result to a JSON serializable output\n    return \"Yes\" if result else \"No\"", "input_generator": "import random\n\ndef input_generator():\n    def generate_sequence(length):\n        if random.random() < 0.5:\n            # Generate a valid BST postorder sequence\n            sequence = []\n            stack = []\n            current = 1\n            for _ in range(length):\n                if random.random() < 0.5 and stack:\n                    sequence.append(stack.pop())\n                else:\n                    sequence.append(current)\n                    current += random.randint(1, 3)\n            return sequence\n        else:\n            # Generate a random sequence (may or may not be valid)\n            return sorted([random.randint(1, 100) for _ in range(length)], reverse=True)\n    \n    length = random.randint(0, 20)\n    sequence = generate_sequence(length)\n    return {'sequence': sequence}", "io_pairs": [{"input": {"sequence": [1, 3, 4, 6, 7]}, "output": "Yes"}, {"input": {"sequence": [93, 87, 82, 72, 57, 47, 46, 44, 34, 21, 6, 1]}, "output": "Yes"}, {"input": {"sequence": [40, 39, 18, 8]}, "output": "Yes"}, {"input": {"sequence": [60, 21]}, "output": "Yes"}, {"input": {"sequence": [1, 3, 6, 7, 8, 11, 14, 16]}, "output": "Yes"}, {"input": {"sequence": [1, 4, 5, 6, 7, 8, 10, 11, 12, 15, 18, 21, 22, 23, 24]}, "output": "Yes"}, {"input": {"sequence": [57, 49, 41, 31, 17, 15]}, "output": "Yes"}, {"input": {"sequence": [1, 3, 5, 7, 10, 13, 16, 18, 19, 22, 24, 25, 28, 31, 33, 35]}, "output": "Yes"}, {"input": {"sequence": [1, 4, 6, 9, 12]}, "output": "Yes"}, {"input": {"sequence": [100, 99, 94, 91, 84, 81, 78, 70, 64, 63, 49, 43, 42, 39, 25, 21, 3]}, "output": "Yes"}], "error_log": []}
{"context": "In a seating arrangement simulation, seats can be either occupied (`#`), free (`L`), or floor (`.`). The simulation runs until the seating arrangement stabilizes, meaning no seats change state between iterations. Depending on the rules applied (Part 1 or Part 2), the simulation determines the final number of occupied seats. Given an initial seating configuration and the part of the problem to solve, how many seats will be occupied when the arrangement stabilizes?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_configuration` (str): A string representing the initial seating configuration. Each row is separated by a newline character (`\\n`). Each seat is represented by one of the following characters: `'#'` (occupied), `'L'` (free), or `'.'` (floor).\n  `part` (int): An integer indicating which part of the problem to solve. Valid values are `1` or `2`.\n\nOutput:\n  `return` (int): The number of occupied seats after the seating arrangement stabilizes.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\nOCCUPIED = '#'\nFREE = 'L'\nFLOOR = '.'\n\n\ndef parse_initial_configuration(lines):\n    return [list(line) for line in lines]\n\n\nclass Simulator:\n\n    def __init__(self, configuration):\n        self.configuration = configuration\n\n    def count_occupied_seats(self):\n        count_occupied_seats_in_row = lambda row: sum(1 for seat in row if seat == OCCUPIED)\n        return sum(count_occupied_seats_in_row(row) for row in self.configuration)\n\n    def next_tick_seat(self, seat, i, j):\n        if seat == OCCUPIED:\n            return self.rule_occupied(i, j)\n\n        if seat == FREE:\n            return self.rule_free(i, j)\n\n        return seat\n\n    def next_tick(self):\n        next_configuration = []\n        is_stable = True\n\n        for i, row in enumerate(self.configuration):\n            next_row = []\n\n            for j, seat in enumerate(row):\n                next_tick_seat = self.next_tick_seat(seat, i, j)\n                is_stable = is_stable and next_tick_seat == seat\n                next_row.append(next_tick_seat)\n\n            next_configuration.append(next_row)\n\n        self.configuration = next_configuration\n        return is_stable\n\n    def run(self):\n        is_stable = False\n\n        while not is_stable:\n            is_stable = self.next_tick()\n\n        return self.count_occupied_seats()\n\n\nclass Part1Simulator(Simulator):\n\n    def enumerate_adjacent_seats(self, i, j):\n        max_i = len(self.configuration)\n        max_j = len(self.configuration[0])\n\n        positions = [\n           (i - 1, j),\n           (i - 1, j + 1),\n           (i - 1, j - 1),\n           (i, j + 1),\n           (i, j - 1),\n           (i + 1, j),\n           (i + 1, j + 1),\n           (i + 1, j - 1)\n        ]\n\n        for pos_i, pos_j in positions:\n            if 0 <= pos_i < max_i and 0 <= pos_j < max_j:\n                yield self.configuration[pos_i][pos_j]\n\n    def rule_occupied(self, i, j):\n        seats = self.enumerate_adjacent_seats(i, j)\n        return FREE if sum(1 for seat in seats if seat == OCCUPIED) >= 4 else OCCUPIED\n\n    def rule_free(self, i, j):\n        seats = self.enumerate_adjacent_seats(i, j)\n        return OCCUPIED if all(seat != OCCUPIED for seat in seats) else FREE\n\n\nclass Part2Simulator(Simulator):\n\n    def find_first_seat(self, seat_i, seat_j, move):\n        max_i = len(self.configuration)\n        max_j = len(self.configuration[0])\n        i, j = move(seat_i, seat_j)\n\n        while 0 <= i < max_i and 0 <= j < max_j:\n            seat = self.configuration[i][j]\n            if seat != FLOOR:\n                return seat\n\n            i, j = move(i, j)\n\n        return None\n\n    def enumerate_sightable_seats(self, seat_i, seat_j):\n        moves = [\n            lambda i, j: (i - 1, j),\n            lambda i, j: (i - 1, j + 1),\n            lambda i, j: (i - 1, j - 1),\n            lambda i, j: (i, j + 1),\n            lambda i, j: (i, j - 1),\n            lambda i, j: (i + 1, j),\n            lambda i, j: (i + 1, j + 1),\n            lambda i, j: (i + 1, j - 1),\n        ]\n\n        for move in moves:\n            sightable_seat = self.find_first_seat(seat_i, seat_j, move)\n            if sightable_seat is not None:\n                yield sightable_seat\n\n    def rule_occupied(self, i, j):\n        seats = self.enumerate_sightable_seats(i, j)\n        return FREE if sum(1 for seat in seats if seat == OCCUPIED) >= 5 else OCCUPIED\n\n    def rule_free(self, i, j):\n        seats = self.enumerate_sightable_seats(i, j)\n        return OCCUPIED if all(seat != OCCUPIED for seat in seats) else FREE\n\n\n# main function\ndef main_solution(initial_configuration, part):\n    # Convert the initial_configuration from a string to a list of lists\n    configuration = parse_initial_configuration(initial_configuration.split('\\n'))\n\n    if part == 1:\n        simulator = Part1Simulator(configuration)\n    elif part == 2:\n        simulator = Part2Simulator(configuration)\n    else:\n        raise ValueError(\"Invalid part number. Must be 1 or 2.\")\n\n    occupied_seats = simulator.run()\n    return occupied_seats", "input_generator": "import random\n\ndef input_generator():\n    # Define possible characters for the configuration\n    chars = ['#', 'L', '.']\n    # Randomly choose the size of the configuration (between 5x5 and 20x20)\n    rows = random.randint(5, 20)\n    cols = random.randint(5, 20)\n    \n    # Generate each row randomly\n    configuration = []\n    for _ in range(rows):\n        row = ''.join(random.choice(chars) for _ in range(cols))\n        configuration.append(row)\n    \n    # Join rows with newlines to form the initial_configuration string\n    initial_configuration = '\\n'.join(configuration)\n    \n    # Randomly choose part (1 or 2)\n    part = random.choice([1, 2])\n    \n    return {\n        'initial_configuration': initial_configuration,\n        'part': part\n    }", "io_pairs": [{"input": {"initial_configuration": "...###.#.L\nLLL...L.##\n.####.L.L.\n..LL#L#.#L\n##L#.##..#\n#.#LLL.LL#\n#L.L####L.\n..LLLL##..", "part": 2}, "output": 25}, {"input": {"initial_configuration": "LL..#.#L#..\n#.####..L#L\n#..L#L.####\n#.L#..#.#.L\n#..L.LL#.#.\nL#LL.L#.#.L\n#.###LL.LLL\n.LLLL.L.L..", "part": 1}, "output": 23}, {"input": {"initial_configuration": "LL##...L#L\n.LLL..#LL.\n#L.LLL#.#.\n#LL#.##..#\n.L.#L.LL.#", "part": 1}, "output": 15}, {"input": {"initial_configuration": "LL..L###LL\n.L#L####.#\n.L.#.L##.#\n.##...L.L.\n#.L..#..#L", "part": 1}, "output": 13}, {"input": {"initial_configuration": "L####\n...##\n..#.L\nL.##L\n#L.L#\n.#LL#\n.LL##\n#L###", "part": 2}, "output": 15}, {"input": {"initial_configuration": "LL.##L...\nL#LL.L##L\n##L....L#\nLL..L.#.L\n##.#LL#..\nL##.LL.L.", "part": 2}, "output": 15}, {"input": {"initial_configuration": "..#..\n.###.\n.LLL#\n.###.\n###L.\nL.#.#\n##...\n#L#L#\n#..LL", "part": 1}, "output": 14}, {"input": {"initial_configuration": "..###..\nLLL#L##\n#LL.##.\n.L#LL#.\nL#.L#.#\n#..L#.L\nLL..#LL\n#.#L...\n#L.LL#L\n.L...##\n..#L#.#\n#.#L.L#", "part": 2}, "output": 29}, {"input": {"initial_configuration": "#L#L..L#\n#.LL.#..\n.#LLLL#.\nL#LL#.L#\n##.#..LL", "part": 1}, "output": 13}, {"input": {"initial_configuration": ".#.L..\nL#.LL.\n.....L\n.L#.#L\n#LL.#.", "part": 1}, "output": 9}], "error_log": []}
{"context": "In a call center, the average number of calls received per minute is `m`. What is the probability that exactly `x` calls will be received in a given minute?\n\nThe input and output requirements are as follows:\n\nInput:\n  `m` (float): The average number of events in a fixed interval.\n  `x` (int): The number of events we are interested in.\n\nOutput:\n  `return` (float): The probability of exactly `x` events occurring in a fixed interval, rounded to three decimal places.", "reference_code": "# import necessary packages\nfrom math import factorial, exp\n\n# main function\ndef main_solution(m, x):\n  # Convert input variables to the required types if necessary\n  m = float(m)\n  x = int(x)\n  \n  # Calculate the Poisson probability\n  p = ((m ** x) * exp(-m)) / factorial(x)\n  \n  # Return the result as a JSON serializable output\n  return round(p, 3)", "input_generator": "import random\nimport math\n\ndef input_generator():\n    m = random.uniform(0.1, 10.0)\n    x = random.randint(0, 20)\n    return {'m': m, 'x': x}", "io_pairs": [{"input": {"m": 7.255405977376054, "x": 10}, "output": 0.079}, {"input": {"m": 0.34486027902670396, "x": 19}, "output": 0.0}, {"input": {"m": 2.347179596601596, "x": 9}, "output": 0.001}, {"input": {"m": 0.8907467391166425, "x": 1}, "output": 0.366}, {"input": {"m": 3.932285063047268, "x": 8}, "output": 0.028}, {"input": {"m": 4.604820890050695, "x": 7}, "output": 0.087}, {"input": {"m": 4.030888116813077, "x": 12}, "output": 0.001}, {"input": {"m": 6.363481282393352, "x": 18}, "output": 0.0}, {"input": {"m": 0.25922462676827873, "x": 16}, "output": 0.0}, {"input": {"m": 2.3422464490727437, "x": 9}, "output": 0.001}], "error_log": []}
{"context": "Given a function \\( f(x) = \\cos(x) - x^3 \\), you are tasked with finding an approximate zero within a specified interval `[a, b]`. The method used to find this zero is the false position method, which requires a maximum number of iterations `max1` to ensure the process does not run indefinitely. What is the approximate zero of the function within the interval `[a, b]` after `max1` iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The left endpoint of the interval.\n  `b` (float): The right endpoint of the interval.\n  `max1` (int): The maximum number of iterations allowed.\n\nOutput:\n  `return` (float or None): The approximate zero of the function within the interval `[a, b]`. If no zero is found or the function values at the endpoints have the same sign, it returns `None`. The result is rounded to 6 decimal places.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef f(x):\n    return math.cos(x) - x**3\n\ndef false_position(a, b, max1):\n    ya = f(a)\n    yb = f(b)\n    \n    if ya * yb > 0:\n        return None\n    \n    for iteration in range(1, max1 + 1):\n        dx = yb * (b - a) / (yb - ya)\n        c = b - dx\n        yc = f(c)\n        \n        if yc == 0:\n            break\n        elif yb * yc > 0:\n            b = c\n            yb = yc\n        else:\n            a = c\n            ya = yc\n    \n    return c\n\n# main function\ndef main_solution(a, b, max1):\n    # Convert input arguments to the required types if necessary\n    a = float(a)\n    b = float(b)\n    max1 = int(max1)\n    \n    # Call the false_position function with the converted inputs\n    result = false_position(a, b, max1)\n    \n    # Ensure the output is JSON serializable\n    if result is None:\n        return None\n    else:\n        return round(result, 6)", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random interval [a, b] where f(a) * f(b) < 0\n    while True:\n        a = random.uniform(-10.0, 10.0)\n        b = random.uniform(-10.0, 10.0)\n        if a > b:\n            a, b = b, a\n        if (math.cos(a) - a**3) * (math.cos(b) - b**3) < 0:\n            break\n    \n    max1 = random.randint(5, 50)\n    \n    return {\n        'a': a,\n        'b': b,\n        'max1': max1\n    }", "io_pairs": [{"input": {"a": -7.742132785274847, "b": 3.988784017839233, "max1": 47}, "output": 0.902158}, {"input": {"a": -4.957284503063075, "b": 4.982271943790037, "max1": 34}, "output": 0.796938}, {"input": {"a": -0.20336695451202935, "b": 7.348828103580534, "max1": 13}, "output": 0.038922}, {"input": {"a": 0.12494829685371478, "b": 3.5697939803089547, "max1": 9}, "output": 0.63639}, {"input": {"a": -6.130222342041751, "b": 4.842898667995891, "max1": 6}, "output": 1.056313}, {"input": {"a": -7.166036533346254, "b": 4.126567458549799, "max1": 48}, "output": 0.885256}, {"input": {"a": -8.830039065293303, "b": 2.3797125035184568, "max1": 14}, "output": 1.264062}, {"input": {"a": -3.0413521036191344, "b": 2.782416216782975, "max1": 25}, "output": 0.864287}, {"input": {"a": -0.6692327491044949, "b": 8.171690201367074, "max1": 42}, "output": -0.013922}, {"input": {"a": -7.952450827224951, "b": 9.7968310734576, "max1": 30}, "output": -0.91457}], "error_log": []}
{"context": "In a game, there are `n` people standing in a circle. Starting from the first person, every `m`-th person is eliminated until only one person remains. What is the position of the last remaining person in the circle?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of people in the circle. Must be a positive integer.\n  `m` (int): The step count to eliminate the next person. Must be a positive integer.\n\nOutput:\n  `return` (int): The position of the last remaining person in the circle. If either `n` or `m` is less than or equal to 0, it returns -1.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef LastRemaining_Solution(n: int, m: int) -> int:\n    if n <= 0 or m <= 0:\n        return -1\n    last_num = 0\n    for i in range(2, n + 1):\n        last_num = (last_num + m) % i\n    return last_num\n\n# main function\ndef main_solution(n: int, m: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = LastRemaining_Solution(n, m)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 100)\n    m = random.randint(1, 100)\n    return {'n': n, 'm': m}", "io_pairs": [{"input": {"n": 56, "m": 30}, "output": 7}, {"input": {"n": 68, "m": 49}, "output": 39}, {"input": {"n": 19, "m": 51}, "output": 1}, {"input": {"n": 65, "m": 34}, "output": 44}, {"input": {"n": 77, "m": 18}, "output": 42}, {"input": {"n": 44, "m": 46}, "output": 35}, {"input": {"n": 18, "m": 83}, "output": 6}, {"input": {"n": 93, "m": 11}, "output": 60}, {"input": {"n": 83, "m": 59}, "output": 45}, {"input": {"n": 88, "m": 27}, "output": 79}], "error_log": []}
{"context": "Given three integers `a`, `b`, and `c`, determine the solution to the linear diophantine equation `ax + by = c`. What are the values of `x0`, `y0`, `a_prime`, and `b_prime` if a solution exists, or state that no solution exists?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): The coefficient of x in the linear diophantine equation.\n  `b` (int): The coefficient of y in the linear diophantine equation.\n  `c` (int): The constant term in the linear diophantine equation.\n\nOutput:\n  `return` (dict): A dictionary containing the solution to the linear diophantine equation. The keys are:\n    - \"solution\": (str) \"No solution exists\" if no solution is found.\n    - \"x0\": (int) The initial value of x if a solution exists.\n    - \"y0\": (int) The initial value of y if a solution exists.\n    - \"a_prime\": (int) The reduced coefficient of x if a solution exists.\n    - \"b_prime\": (int) The reduced coefficient of y if a solution exists.", "reference_code": "# import necessary packages\nfrom functools import reduce\nfrom itertools import chain\nfrom math import sqrt\nfrom operator import mul\nfrom random import randint\n\n# all class and function definitions in the code file, if any\ndef even(n):\n    return n % 2 == 0\n\ndef odd(n):\n    return n % 2 != 0\n\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return abs(a * b) // gcd(a, b)\n\ndef extended_euclidian(a, b):\n    if a == b == 0:\n        return 0, 0, 0\n    if b == 0:\n        return 1, 0, a\n    x, y, d = extended_euclidian(b, a % b)\n    return y, x - y * (a // b), d\n\ndef binomial(n, k):\n    res = 1\n    for i in range(1, k + 1):\n        res = res * (n - i + 1) // i\n    return res\n\ndef factorial(n):\n    return reduce(mul, range(1, n), 1)\n\ndef isqrt(x):\n    return int(sqrt(x))\n\ndef coprime(a, b):\n    return gcd(a, b) == 1\n\ndef is_prime(n: int) -> bool:\n    if n in (2, 3):\n        return True\n    if n < 2 or n % 2 == 0 or n % 3 == 0:\n        return False\n    for q in range(5, isqrt(n) + 1, 6):\n        if n % q == 0 or n % (q + 2) == 0:\n            return False\n    return True\n\ndef sieve(n):\n    s = [True] * (n + 1)\n    for i in range(2, isqrt(n) + 1):\n        if s[i]:\n            for j in range(i + i, n + 1, i):\n                s[j] = False\n    return [i for i in range(2, n + 1) if s[i]]\n\ndef factorize(n):\n    if n in (0, 1):\n        return [(n, 1)]\n    factors = []\n    if n < 0:\n        factors.append((-1, 1))\n        n = -n\n    for q in chain((2, 3), range(5, isqrt(n) + 1, 6)):\n        a = 0\n        while n % q == 0:\n            n //= q\n            a += 1\n        if a > 0:\n            factors.append((q, a))\n        q += 2\n        a = 0\n        while n % q == 0:\n            n //= q\n            a += 1\n        if a > 0:\n            factors.append((q, a))\n    if n != 1:\n        factors.append((n, 1))\n    return factors\n\ndef prime_pi(n):\n    if n < 2:\n        return 0\n    primes = sieve(n)\n    return len(primes)\n\ndef euler_phi(n):\n    if n == 1:\n        return 1\n    phi = n\n    for p, a in factorize(n):\n        phi -= phi // p\n    return phi\n\ndef binpow(x, r):\n    ans = 1\n    while r > 0:\n        if odd(r):\n            ans *= x\n        x *= x\n        r = r // 2\n    return ans\n\ndef linear_diophantine(a, b, c):\n    p, q, d = extended_euclidian(a, b)\n    if d == 0 or c % d != 0:\n        return None\n    a, b, c = a // d, b // d, c // d\n    return p * c, q * c, a, b\n\ndef linear_sieve(max_n):\n    smallest_factors = [0] * max_n\n    primes = []\n    for i in range(2, max_n):\n        if smallest_factors[i] == 0:\n            smallest_factors[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > smallest_factors[i] or i * p >= max_n:\n                break\n            smallest_factors[i * p] = p\n    return primes, smallest_factors\n\nprimes, spf = linear_sieve(int(1e6))\n\ndef powmod(x, k, m):\n    ans = 1\n    while k > 0:\n        if odd(k):\n            ans = ans * x % m\n            k -= 1\n        else:\n            x = x * x % m\n            k /= 2\n    return ans\n\ndef factor_twos(x):\n    d, s = x, 0\n    while even(d):\n        d >>= 1\n        s += 1\n    return d, s\n\ndef fermat_test(n, a):\n    if n == 2:\n        return True\n    return powmod(a, n - 1, n) == 1\n\ndef fermat_strong_test(n, a):\n    if n == 2:\n        return True\n    d, s = factor_twos(n - 1)\n    a = powmod(a, d, n)\n    if a == 1 or a == n - 1:\n        return True\n    for _ in range(s):\n        a = a * a % n\n        if a == n - 1:\n            return True\n    return False\n\ndef jacobi(a, n):\n    if n == 1:\n        return 1\n    if a % n == 0:\n        return 0\n    if a < 0:\n        return jacobi(a + n * (1 + (-a - 1) // n), n)\n    a1, k = factor_twos(a)\n    j_even = 1 if n % 8 == 1 or n % 8 == 7 else -1\n    if even(k):\n        j_even = 1\n    if n % 4 == 3 and a1 % 4 == 3:\n        return -j_even * jacobi(n % a1, a1)\n    return j_even * jacobi(n % a1, a1)\n\ndef lucas_strong_test(n, p, q):\n    if even(n):\n        return n == 2\n    D = p ** 2 - 4 * q\n    def div2(x):\n        if odd(x):\n            x += n\n        return x // 2 % n\n    def lucas_double(u_k, v_k, k):\n        return u_k * v_k % n, (v_k * v_k + -2 * powmod(q, k, n)) % n\n    def lucas_sum(u_k, v_k, u_m, v_m):\n        u_km = div2(u_k * v_m + u_m * v_k)\n        v_km = div2(v_k * v_m + D * u_k * u_m)\n        return u_km, v_km\n    d, s = factor_twos(n - jacobi(D, n))\n    u, v = 0, 2\n    u_k, v_k, k, d_rem = 1, p, 1, d\n    while d_rem:\n        if d_rem & 1:\n            u, v = lucas_sum(u, v, u_k, v_k)\n        u_k, v_k = lucas_double(u_k, v_k, k)\n        k *= 2\n        d_rem >>= 1\n    if u == 0:\n        return True\n    for _ in range(s + 1):\n        if v == 0:\n            return True\n        u, v = lucas_double(u, v, d)\n        d *= 2\n    return False\n\ndef lucas_selfridge_test(n):\n    if isqrt(n) ** 2 == n:\n        return False\n    D = 5\n    while jacobi(D, n) != -1:\n        if D > 0:\n            D = -(D + 2)\n        else:\n            D = -(D - 2)\n    return lucas_strong_test(n, 1, (1 - D) // 4)\n\nBASES_1 = [2, 3, 5, 7]\nBASES_2 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n\ndef Miller_Rabin_test(n, bases=None, num_trials=5):\n    if bases is None:\n        if n <= 1e9:\n            bases = BASES_1\n        else:\n            bases = BASES_2\n    for a in bases:\n        if n == a:\n            continue\n        if n % a == 0:\n            return False\n        if not fermat_strong_test(n, a):\n            return False\n    return True\n\ndef Ballie_PSW_test(n, max_trivial_trials=100):\n    for i in range(max_trivial_trials):\n        if primes[i] == n:\n            return True\n        if n % primes[i] == 0:\n            return False\n        if primes[i] ** 2 >= n:\n            return True\n    if not fermat_strong_test(n, 2):\n        return False\n    if not lucas_selfridge_test(n):\n        return False\n    return True\n\ndef Pollard_rho_Floyd(n, x0=2, c=1):\n    def f(x):\n        return (x * x + c) % n\n    x, y, g = x0, x0, 1\n    while g == 1:\n        x = f(x)\n        y = f(f(y))\n        g = gcd(abs(x - y), n)\n    return g\n\ndef Pollard_rho_factor(n, check_prime=False):\n    if check_prime and Miller_Rabin_test(n):\n        return n\n    if even(n):\n        return 2\n    while True:\n        x0 = randint(2, n - 1)\n        c = randint(1, n - 1)\n        g = Pollard_rho_Floyd(n, x0, c)\n        if g != n:\n            return g\n\ndef Pollard_pm1(n, primes, max_B=1000000):\n    B = 10\n    g = 1\n    while B < max_B and g < n:\n        a = randint(2, n - 2)\n        g = gcd(a, n)\n        if g != 1:\n            return g\n        for p in primes:\n            if p >= B:\n                break\n            pd = 1\n            while pd * p <= B:\n                pd *= p\n            a = powmod(a, pd, n)\n            g = gcd(a - 1, n)\n            if g != 1 and g != n:\n                return g\n        B *= 2\n    return 1\n\ndef log_modulo(a, b, m):\n    a, b = a % m, b % m\n    n = isqrt(m) + 1\n    rhs = {}\n    for q in range(n + 1):\n        rhs[b] = q\n        b = b * a % m\n    an = powmod(a, n, m)\n    lhs = 1\n    for p in range(1, n + 1):\n        lhs = lhs * an % m\n        if lhs in rhs:\n            return n * p - rhs[lhs]\n    return None\n\ndef primitive_root(n):\n    if n == 2:\n        return 1\n    phi = euler_phi(n)\n    phi_divisors = factorize(phi)\n    for g in range(2, n + 1):\n        if gcd(g, n) != 1:\n            continue\n        for d, _ in phi_divisors:\n            if powmod(g, phi // d, n) == 1:\n                break\n        else:\n            return g\n    return None\n\ndef kth_root_modulo(a, k, n):\n    g = primitive_root(n)\n    gk = powmod(g, k, n)\n    y = log_modulo(gk, a, n)\n    return powmod(g, y, n)\n\n# main function\ndef main_solution(a, b, c):\n    # Convert JSON serializable inputs to original input variables\n    a, b, c = int(a), int(b), int(c)\n    \n    # Core solution logic\n    result = linear_diophantine(a, b, c)\n    \n    # Convert result to JSON serializable output\n    if result is None:\n        return {\"solution\": \"No solution exists\"}\n    else:\n        x0, y0, a_prime, b_prime = result\n        return {\"x0\": x0, \"y0\": y0, \"a_prime\": a_prime, \"b_prime\": b_prime}", "input_generator": "import random\nfrom math import gcd\n\ndef input_generator():\n    # Generate random integers a, b, c such that c is divisible by gcd(a, b)\n    while True:\n        a = random.randint(-100, 100)\n        b = random.randint(-100, 100)\n        if a == 0 and b == 0:\n            continue  # avoid a = b = 0 case\n        d = gcd(a, b)\n        c_multiplier = random.randint(-10, 10)\n        c = d * c_multiplier\n        break\n    return {\"a\": a, \"b\": b, \"c\": c}", "io_pairs": [{"input": {"a": -36, "b": 32, "c": 8}, "output": {"x0": -2, "y0": -2, "a_prime": -9, "b_prime": 8}}, {"input": {"a": 11, "b": -44, "c": 55}, "output": {"x0": 5, "y0": 0, "a_prime": -1, "b_prime": 4}}, {"input": {"a": -41, "b": 20, "c": -6}, "output": {"x0": 6, "y0": 12, "a_prime": -41, "b_prime": 20}}, {"input": {"a": -93, "b": -76, "c": 7}, "output": {"x0": -63, "y0": 77, "a_prime": 93, "b_prime": 76}}, {"input": {"a": 70, "b": 83, "c": 5}, "output": {"x0": -160, "y0": 135, "a_prime": 70, "b_prime": 83}}, {"input": {"a": 38, "b": -60, "c": 18}, "output": {"x0": -99, "y0": -63, "a_prime": -19, "b_prime": 30}}, {"input": {"a": -34, "b": 38, "c": 6}, "output": {"x0": -27, "y0": -24, "a_prime": -17, "b_prime": 19}}, {"input": {"a": -2, "b": 63, "c": -7}, "output": {"x0": -217, "y0": -7, "a_prime": -2, "b_prime": 63}}, {"input": {"a": -5, "b": 33, "c": -1}, "output": {"x0": -13, "y0": -2, "a_prime": -5, "b_prime": 33}}, {"input": {"a": 82, "b": 55, "c": 5}, "output": {"x0": -10, "y0": 15, "a_prime": 82, "b_prime": 55}}], "error_log": []}
{"context": "Given a dataset generated from a known distribution, how can we estimate the expected value and variance of a function using both naive Monte Carlo and importance sampling Monte Carlo methods? Specifically, what are the expected values and variances obtained from these two methods when applied to a function defined by `h(x) = e^(-x + cos(x))`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `M` (int): The number of samples to generate for the Monte Carlo simulations.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `expected_value_MC` (float): The expected value from the naive Monte Carlo simulation.\n    - `variance_MC` (float): The variance from the naive Monte Carlo simulation.\n    - `time_MC` (float): The time taken for the naive Monte Carlo simulation.\n    - `expected_value_importance` (float): The expected value from the importance sampling Monte Carlo simulation.\n    - `variance_importance` (float): The variance from the importance sampling Monte Carlo simulation.\n    - `time_importance` (float): The time taken for the importance sampling Monte Carlo simulation.", "reference_code": "# import necessary packages\nimport numpy as np\nimport time\n\n# all class and function definitions in the code file, if any\ndef h(x):\n    return np.exp(-1 * x + np.cos(x))\n\ndef f(x):\n    return np.exp(-2 * x)\n\ndef g(x):\n    return np.exp(-1 * x)\n\ndef MC_moy(M):\n    t1 = time.time()\n    echantillon = []\n    for i in range(M):\n        x = np.random.exponential(1)\n        ech = h(x)\n        echantillon.append(ech)\n    t2 = time.time()\n    t = t2 - t1\n    return [echantillon, t]\n\ndef Ech_importance(M):\n    ech_importance = []\n    t1 = time.time()\n    for i in range(M):\n        x = np.random.exponential(2)\n        poids_importance = g(x) / f(x)\n        ec_importance = poids_importance * h(x)\n        ech_importance.append(ec_importance)\n    t2 = time.time()\n    t = t2 - t1\n    return [ech_importance, t]\n\n# main function\ndef main_solution(M):\n    # Convert input to appropriate types if necessary\n    M = int(M)\n    \n    # Run Monte Carlo simulation\n    val = MC_moy(M)\n    expected_value = np.mean(val[0])\n    sigma = np.std(val[0])\n    err = 1.96 * sigma / np.sqrt(M)\n    var_MC = sigma ** 2\n    time_MC = val[1]\n    \n    # Run Importance Sampling simulation\n    val_importance = Ech_importance(M)\n    expected_val_importance = np.mean(val_importance[0])\n    std_importance = np.std(val_importance[0])\n    var_importance = std_importance ** 2\n    err_importance = 1.96 * std_importance / np.sqrt(M)\n    time_importance = val_importance[1]\n    \n    # Prepare output\n    output = {\n        \"expected_value_MC\": expected_value,\n        \"variance_MC\": var_MC,\n        \"time_MC\": time_MC,\n        \"expected_value_importance\": expected_val_importance,\n        \"variance_importance\": var_importance,\n        \"time_importance\": time_importance\n    }\n    \n    return output", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    M = random.choice([100, 500, 1000, 5000, 10000])\n    return {'M': M}", "io_pairs": [{"input": {"M": 5000}, "output": {"expected_value_MC": 1.158599968673737, "variance_MC": 0.7760070514943903, "time_MC": 0.024314165115356445, "expected_value_importance": 1.5099484984285183, "variance_importance": 0.7319058833891275, "time_importance": 0.030867576599121094}}, {"input": {"M": 10000}, "output": {"expected_value_MC": 1.1667567785397828, "variance_MC": 0.7594393920253677, "time_MC": 0.038530826568603516, "expected_value_importance": 1.5137097441152947, "variance_importance": 0.7287453817130488, "time_importance": 0.06759476661682129}}, {"input": {"M": 1000}, "output": {"expected_value_MC": 1.1189077277740116, "variance_MC": 0.7398821655028979, "time_MC": 0.0016849040985107422, "expected_value_importance": 1.496173967237557, "variance_importance": 0.7505546410834527, "time_importance": 0.004808187484741211}}, {"input": {"M": 500}, "output": {"expected_value_MC": 1.2027743013478325, "variance_MC": 0.7574544897859099, "time_MC": 0.0003731250762939453, "expected_value_importance": 1.461344933318769, "variance_importance": 0.7135229379311367, "time_importance": 0.0}}, {"input": {"M": 100}, "output": {"expected_value_MC": 1.2482042012045051, "variance_MC": 0.7598559387348709, "time_MC": 0.0, "expected_value_importance": 1.626502117024909, "variance_importance": 0.7155953614514612, "time_importance": 0.0}}], "error_log": []}
{"context": "Given a circle with a radius `r` and `n` angles measured in degrees, what is the area of the polygon formed by connecting these angles on the circle's circumference?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of angles provided.\n  `r` (int): The radius of the circle.\n  `angles` (list of float): A list of angles in degrees.\n\nOutput:\n  `return` (int): The calculated area of the polygon formed by the given angles and radius, rounded to the nearest integer.", "reference_code": "# import necessary packages\nfrom math import pi, sin\n\n# main function\ndef main_solution(n, r, angles):\n    # Convert angles from degrees to radians\n    angles_rad = [angle / 180 * pi for angle in angles]\n    \n    # Calculate the area\n    area = 0\n    for i in range(len(angles_rad)):\n        for j in range(i + 1, len(angles_rad)):\n            area += sin(angles_rad[j] - angles_rad[i]) * (n - 2 * j + 2 * i)\n    \n    # Calculate the final area\n    final_area = round(r * r * area / 2)\n    \n    # Return the final area\n    return final_area", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(3, 10)\n    r = random.uniform(1.0, 10.0)\n    angles = sorted(random.sample(range(1, 360), n))\n    return {'n': n, 'r': r, 'angles': angles}", "io_pairs": [{"input": {"n": 8, "r": 9.640545465152625, "angles": [45, 75, 83, 103, 199, 255, 261, 324]}, "output": 2829}, {"input": {"n": 9, "r": 1.3898238292541927, "angles": [69, 85, 174, 186, 211, 302, 306, 307, 330]}, "output": 82}, {"input": {"n": 4, "r": 3.8393626684777606, "angles": [80, 223, 249, 314]}, "output": 41}, {"input": {"n": 3, "r": 6.522559846867055, "angles": [140, 288, 316]}, "output": 20}, {"input": {"n": 8, "r": 1.1461579886975077, "angles": [5, 34, 47, 82, 104, 163, 179, 318]}, "output": 35}, {"input": {"n": 7, "r": 9.617007233825618, "angles": [4, 21, 31, 127, 183, 319, 356]}, "output": 1308}, {"input": {"n": 8, "r": 4.547293129191523, "angles": [47, 56, 70, 103, 118, 234, 277, 291]}, "output": 542}, {"input": {"n": 7, "r": 9.472171170030414, "angles": [123, 154, 181, 188, 210, 261, 314]}, "output": 1141}, {"input": {"n": 8, "r": 8.059900203585578, "angles": [83, 90, 99, 153, 203, 230, 335, 337]}, "output": 1993}, {"input": {"n": 6, "r": 7.9410110635023194, "angles": [17, 147, 181, 273, 287, 352]}, "output": 772}], "error_log": []}
{"context": "Given a list of integers, how can you sort them efficiently using a binary heap data structure? What will be the sorted order of the provided list of integers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `elements` (list of integers): A list of integers representing the elements to be sorted using a binary heap.\n\nOutput:\n  `return` (list of integers): A list of integers sorted in ascending order.", "reference_code": "# import necessary packages\nimport operator\nimport random\n\n# all class and function definitions in the code file, if any\nclass BinaryHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n    def insert(self, item):\n        self.heapList.append(item)\n        self.currentSize += 1\n        self.__percUp()\n\n    def pop(self):\n        minVal = self.heapList[1]\n        self.heapList[1] = self.heapList[-1]\n        self.heapList.pop()\n        self.currentSize -= 1\n        self.__percDown(1)\n        return minVal\n\n    def buildHeap(self, alist):\n        self.heapList = [0] + alist[:]\n        self.currentSize = len(self.heapList) - 1\n        i = self.currentSize // 2\n        while i > 0:\n            self.__percDown(i)\n            i -= 1\n\n    def __percUp(self):\n        i = self.currentSize\n        while i // 2 > 0:\n            fatherIndex = i // 2\n            if self.heapList[fatherIndex] > self.heapList[i]:\n                self.heapList[fatherIndex], self.heapList[i] = self.heapList[i], self.heapList[fatherIndex]\n                i = fatherIndex\n            else:\n                break\n\n    def __percDown(self, index):\n        stoped = False\n        while index * 2 <= self.currentSize and not stoped:\n            leftIndex = index * 2\n            rightIndex = index * 2 + 1\n\n            if rightIndex > self.currentSize:\n                comparedIndex = leftIndex\n            else:\n                comparedIndex = leftIndex if self.heapList[leftIndex] <= self.heapList[rightIndex] else rightIndex\n\n            if self.heapList[index] > self.heapList[comparedIndex]:\n                self.heapList[index], self.heapList[comparedIndex] = self.heapList[comparedIndex], self.heapList[index]\n                index = comparedIndex\n            else:\n                stoped = True\n\n# main function\ndef main_solution(elements):\n    # Convert input list to a BinaryHeap\n    bh = BinaryHeap()\n    bh.buildHeap(elements)\n    \n    # Extract elements in sorted order\n    sorted_elements = []\n    while bh.currentSize > 0:\n        sorted_elements.append(bh.pop())\n    \n    # Return the sorted list\n    return sorted_elements", "input_generator": "import random\n\ndef input_generator():\n    size = random.randint(5, 20)\n    elements = random.sample(range(1, 100), size)\n    return {'elements': elements}", "io_pairs": [{"input": {"elements": [5, 98, 84, 71, 67, 8, 21, 88, 26, 4, 99, 22, 27]}, "output": [4, 5, 8, 21, 22, 26, 27, 67, 71, 84, 88, 98, 99]}, {"input": {"elements": [66, 12, 83, 79, 92, 35, 84, 33, 93, 61, 72, 5, 19, 74, 28, 58]}, "output": [5, 12, 19, 28, 33, 35, 58, 61, 66, 72, 74, 79, 83, 84, 92, 93]}, {"input": {"elements": [90, 29, 1, 74, 44, 30, 26, 3, 13, 66, 36, 28, 25, 20]}, "output": [1, 3, 13, 20, 25, 26, 28, 29, 30, 36, 44, 66, 74, 90]}, {"input": {"elements": [28, 22, 9, 47, 34, 42, 72, 26, 18, 43, 79, 54]}, "output": [9, 18, 22, 26, 28, 34, 42, 43, 47, 54, 72, 79]}, {"input": {"elements": [15, 94, 17, 58, 65, 85, 34, 28]}, "output": [15, 17, 28, 34, 58, 65, 85, 94]}, {"input": {"elements": [35, 48, 99, 32, 59, 34, 67, 71, 91, 69, 29, 84]}, "output": [29, 32, 34, 35, 48, 59, 67, 69, 71, 84, 91, 99]}, {"input": {"elements": [32, 73, 33, 19, 67, 56, 46, 14, 55, 52, 40, 64, 38, 75, 23]}, "output": [14, 19, 23, 32, 33, 38, 40, 46, 52, 55, 56, 64, 67, 73, 75]}, {"input": {"elements": [39, 52, 38, 35, 61, 14, 72]}, "output": [14, 35, 38, 39, 52, 61, 72]}, {"input": {"elements": [64, 42, 13, 97, 1, 81, 21, 73, 91, 35, 45, 60, 28, 11, 5, 99, 40]}, "output": [1, 5, 11, 13, 21, 28, 35, 40, 42, 45, 60, 64, 73, 81, 91, 97, 99]}, {"input": {"elements": [89, 1, 96, 93, 66, 15, 30, 14, 9, 58, 37, 44]}, "output": [1, 9, 14, 15, 30, 37, 44, 58, 66, 89, 93, 96]}], "error_log": []}
{"context": "Given a text and a key, how can you encrypt or decrypt the text using the RC4 cryptography algorithm? Specifically, what is the result of the encryption or decryption process when the text and key are provided, and the mode of operation is specified?\n\nThe input and output requirements are as follows:\n\nInput:\n  `text` (str): The plaintext or ciphertext to be processed.\n  `key` (str): The key used for encryption or decryption.\n  `mode` (str): The mode of operation, either \"encrypt\" or \"decrypt\".\n\nOutput:\n  `return` (str): The result of the encryption or decryption process.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\nclass rc4:\n\n    __text = None       # string: plain or cipher text\n    __key = None        # string: the key whose length should be more than 128 bits\n\n    __S = None          # int list: state vector (8*256 bits)\n    __K = None          # int list: temperorary vector storing the key (8*256 bits)\n\n    __length = None     # int: the length of text and keystream\n    __keystream = None  # string: used to xor with text\n\n    def __init__(self, text, key):\n        self.__text = text\n        self.__key = key\n        self.__length = len(text)\n        self._KSA()\n        self.__keystream = self._PRGA(self.__length)\n\n    def _KSA(self):\n        \"\"\"\n        Key Scheduling Algorithm\n        Generating a initialized state vector `__S`\n        \"\"\"\n        # initializing state and key bytes\n        self.__S = [i for i in range(256)]\n        self.__K = [ord(self.__key[i % len(self.__key)]) for i in range(256)]\n        # Permuting state bytes based on values of key bytes\n        j = 0\n        for i in range(256):\n            j = (j + self.__S[i] + self.__K[i]) % 256\n            self._swap_S(i, j)\n\n    def _PRGA(self, length):\n        \"\"\"\n        Pseudo Random Generating Algorithm\n        Generating the key stream whose length is `length` bytes\n        \"\"\"\n        keystream = \"\"\n        i, j = 0, 0\n        for z in range(length):\n            i = (i + 1) % 256\n            j = (j + self.__S[i]) % 256\n            self._swap_S(i, j)\n            keystream += chr((self.__S[i] + self.__S[j]) % 256)\n        return keystream\n\n    def _process(self):\n        \"\"\"\n        for each byte of plain(cipher)text and keystream, use xor operation\n        \"\"\"\n        answer = \"\"\n        for i in range(self.__length):\n            answer += chr(ord(self.__text[i]) ^ ord(self.__keystream[i]))\n        return answer\n\n    def encrypt(self):\n        return self._process()\n\n    def decrypt(self):\n        return self._process()\n\n    def _swap_S(self, i, j):\n        \"\"\"\n        swap(self.__S[i], self.__S[j])\n        \"\"\"\n        tmp = self.__S[i]\n        self.__S[i] = self.__S[j]\n        self.__S[j] = tmp\n\n# main function\ndef main_solution(text, key, mode):\n    \"\"\"\n    Encrypts or decrypts the given text using the RC4 algorithm with the provided key.\n    \n    Parameters:\n    text (str): The plaintext or ciphertext to be processed.\n    key (str): The key used for encryption or decryption.\n    mode (str): The mode of operation, either \"encrypt\" or \"decrypt\".\n    \n    Returns:\n    str: The result of the encryption or decryption process.\n    \"\"\"\n    rc4_instance = rc4(text, key)\n    if mode == \"encrypt\":\n        return rc4_instance.encrypt()\n    elif mode == \"decrypt\":\n        return rc4_instance.decrypt()\n    else:\n        raise ValueError(\"Invalid mode. Choose either 'encrypt' or 'decrypt'.\")", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate random text of length between 10 and 100 characters\n    text_length = random.randint(10, 100)\n    text = ''.join(random.choice(string.ascii_letters + string.digits + string.punctuation) for _ in range(text_length))\n    \n    # Generate random key of length between 16 and 32 characters (128-256 bits)\n    key_length = random.randint(16, 32)\n    key = ''.join(random.choice(string.ascii_letters + string.digits + string.punctuation) for _ in range(key_length))\n    \n    # Randomly choose mode\n    mode = random.choice(['encrypt', 'decrypt'])\n    \n    return {'text': text, 'key': key, 'mode': mode}", "io_pairs": [{"input": {"text": "#[{0v!ev>aJp+>XmNBmkX-V$J+S\"|MJ`<I3IoFo%:oRFW'e(Wqjd>iMcyO7BJrA%6'U?Ob-<U*lONwJUd", "key": "q7rsu6HO]C=-Wywf>#6cd2nMB", "mode": "decrypt"}, "output": "A\u00b1\u0002:\u00dd\f\u00b2E\f\u0099Tz7\u00fb\u00a4\u00adspl\u00de\u00d0f\u00ca&\u00ef\u00b4\u008d\u0012\u00ec\u00cf\u0093q\u008bO\u00f9\u00a1Ku\u0088\u00ff_[V\u00bc2\u00c1N\u00ed\u00f5\u00ee\u00aa/0\u00f2\u008c^\u0012\t\u000fz=\u00c6\u00ac\u000b\u00d1\u00da\u0014\u00c6|\u0083\u0007$\u0014C\u009f\u0093nZ\u000bA\u007f"}, {"input": {"text": "2{KD-K^v-}mu$eceGS1F#?op!L!r7n>j[l2X~iJ+lp)", "key": "v7#_8>76N98yeGjB@.9pxy,6B\"", "mode": "decrypt"}, "output": "\u00a0\u0006\u00da\u00ad\u00be\u00e1\f\u00e4\u00e7/\u00c5D\u00c9\u00fc\u00e5\u009d\u00adG\u0090\u008c\u00deefl\u001fr\u0084\u00c24q\u00cf\u0013{\u008d\u00d3\u00feR\u001dz\u0019\u00e84\u00b4"}, {"input": {"text": "UVJ<nM$3<:B$Qjxo-\"P55*8ISXvsq:1Wx<ZaYa~=`7E>-W*TcA{0K^fC5Rx|`kw[^o", "key": "Z'cM])3m.X2q4^S[uP&SLntKZ", "mode": "encrypt"}, "output": "\u00b85\u00d0\u00d1\u007fh\u00cf\u0083v\u00eef\u0094u\u00a8\u008e\u00cc\u00c0\u00a3\u00d3\u00d4\u008c\u00a4,\u00d8L\u00cf\u00b1\u00f9\u0099,\u00ed[\u00c4\u008f\u00c3&\u00b1Bj\u00ef\u00bc\u009dB'\u008c\u0019\u0091\u00d4\u00c9\u00e6V\u0091\u0081`N$\u00d4\u00ad*\u00cc\u00cf\u0005r+\u0004\u000b"}, {"input": {"text": "k,:U'))DpReu(6_+vWLKQGo|z#pzg<%~^E,^e0E", "key": "D!<Oe{[@KPZ0\"{W||m)?", "mode": "decrypt"}, "output": ",\u00ed\u00067\u0086BJF8o\u00a0\u00a8\u00fa3\u00188\u0088p\u0012\u00c9\u0010\u00a3\u00957T\u0081\u00ac\u00d6\u00c9?\u00b3\u00c4*\u00e6W>\u0096,-"}, {"input": {"text": "0a~}Y1@>yC?aS>WKi,.Kk9)+cpbdvx[%AXr2_b,{NoQ,v:\"<Mf", "key": "cf<B2JM}.}6+QAzrpWvm2", "mode": "decrypt"}, "output": "\u0092\u00cb\u00e6\u00f3G\u0001}\u00f2t|\u001b\u0093\u00bdg\u009f\u00f6l\u00aa\u00f8\u00831 q\u00beZ\u0083\u00d3u\u0092\u001bM\u0011c\u0019H.\u00beoU\u00f8y#|\"B\u00a7\u009a\u0015\u00b6\u00b2"}, {"input": {"text": ":0IjOCC)&?T", "key": ")CE3V<R)8y!S\"t^\"\"lQam-m", "mode": "encrypt"}, "output": "\u00f0)\u001c$\u009d\u00bf\u008a\u008c\u00943\u00fc"}, {"input": {"text": "E,t&z2q.L\\tWEifIF|oL%#`8mqY0Jb<yE00~", "key": "QhOLV^ZCa^I@;IAMsR3DHJC+-2moPRa", "mode": "encrypt"}, "output": "\u0099> \u009ck;\u00a8\u0096\u00efv\u0098\u00b9\u00b3\u00aaI\u00af\u00be \u00d6\u0016\u0095\u00e9&\u00ad\u0098\u0001\u008er*\nU\u0001\u00ed\u00bciU"}, {"input": {"text": "$!0]f+;`\"aH`>Xqa7Ay7T3A[D!.mp6GFz:$hws1h4HcSKt&_}reg`XT}lO*2BeLR[M*@K|'0+H4c45,{3", "key": "<MXs&k^yq1cs)TiI'j", "mode": "encrypt"}, "output": "\u00d0)\u00fa\u00bd\u00be\u00a2\u008ft\u00f3y4\u00de\u00cf\u0084\u00a9\u00bb\u0007}$\u00db\u0086\u0003\u0012)^\u009c\t\u0015\u009c\u00f7\u00ab\u00a3\u00c5\u00d6\u0099/\u00c0\b\u007fhb\u00f6\u00b21'\u0082\u0010U\u00a6Q\u0091v&~}\u0091R?R\u0017\u0095\u0085\u00b8\u00cf\u00f2\u0017\u00a71\u008cu\u0010\u00ca\u00f3\u00e0l\u00cfRw\u008b\u008eQ"}, {"input": {"text": "3rzWZ5.hisG/qSSTjP2H$D8b9S]P3l91q>WW`9:6Rk2PxJ6$msM$mF--4{JN^kc]<`)1M~C^uYm+11WAI~}6`h", "key": "@K=QC2A?r=;A$pFP{6TA", "mode": "encrypt"}, "output": "\u00df\u00d5r\u00d79@C\u009d\u00cc\b\u00a0W\u00dc]r#\u0017Xd\u00c9vV\u0087b\u00b6\u00c9\u00f6\u0094\u00fc\u00ed\u00e6\u00d8~\u009b;\u00c71X1\u00a1\rc\u00dcGl\u00bf\u0017`%K\u00dd\u008d\u00d5)\u00b6i7\u00862\u00a5\u0085\u000f\u00a8x\u00f94\u00fd\u0083.}\u008aw\u0012\u009b\u00d3\u001d\u0093+a\u00e7b\u000f\u0004k\u0082\u00c6"}, {"input": {"text": "TNB9C=UolD2m=Sh]_3.E_`maNhSUk:Q$WSDf*u+X=N*UYWn%}gP2=T?)l_DTW2,`wd#3Xg", "key": "0GUYlJD_t;/vB.`4Ic?iHR6B*k", "mode": "decrypt"}, "output": "f\u00c0\u00f2\u00d9\u00f7\u0097\u00d6r4\u00e7\u00ff\u00f4\u00c4\u00b0\b\u0096\u0005\u00da\u001e\u00e8\u00ca\u001e;\u00f6V \u00d4\u00d5\u000b\u0002U\u00d4\u00fe\u00d1\u00b3,>\u00d97\u0084\u00a1\u00fcI,\u00d8:\u008d\u0007UYu?\u00eb;4\u00cbI\u00f1\u00d1\u00c6\u00c6\u00a4\u00f2\u001d^\u0017\u0084i\u0004\u0095"}], "error_log": []}
{"context": "Given a chessboard of size `n` by `n`, how many distinct ways can you place `n` queens on the board such that no two queens threaten each other?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (int): The number of distinct solutions to the N-Queens problem for the given board size `n`.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(n):\n    # Initialize the answer counter\n    answer = 0\n    \n    # Initialize the row array\n    row = [0] * (n + 1)\n\n    # Function to check if a queen can be placed in the current position\n    def checkupdown(x, col):\n        for i in range(1, x):\n            if col == row[i] or abs(col - row[i]) == x - i:\n                return False\n        return True\n\n    # Depth-first search function to place queens\n    def dfs(x):\n        nonlocal answer\n        for i in range(1, n + 1):\n            if checkupdown(x, i):\n                row[x] = i\n                if x < n:\n                    dfs(x + 1)\n                else:\n                    answer += 1\n\n    # Start the depth-first search from the first row\n    dfs(1)\n\n    # Return the number of solutions found\n    return answer", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 10)  # Reasonable range for n-queens problem\n    return {'n': n}", "io_pairs": [{"input": {"n": 10}, "output": 724}, {"input": {"n": 9}, "output": 352}, {"input": {"n": 6}, "output": 4}, {"input": {"n": 3}, "output": 0}, {"input": {"n": 4}, "output": 2}, {"input": {"n": 2}, "output": 0}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 5}, "output": 10}, {"input": {"n": 8}, "output": 92}, {"input": {"n": 7}, "output": 40}], "error_log": []}
{"context": "Given a string representing coordinates after removing all commas, decimal points, and spaces, what are all possible original coordinates that could have been represented by the string? The original coordinates never had extraneous zeroes and always had exactly one space between them after the comma.\n\nThe input and output requirements are as follows:\n\nInput:\n  `S` (str): A string representing the coordinates after removing all commas, decimal points, and spaces. The string starts with '(' and ends with ')', and the other elements are digits. The length of the string is between 4 and 12.\n\nOutput:\n  `return` (List[str]): A list of strings representing all possible original coordinates. Each string in the list is formatted as \"(x, y)\" where x and y are the original coordinates.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def ambiguousCoordinates(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        if not S:\n            return([])\n        \n        if len(S) < 1:\n            return([S])\n        \n        memo = {}\n        \n        S = S[1:len(S)-1]\n        res = []\n        for i in range(1, len(S)):\n            left = S[:i]\n            right = S[i:]\n            leftRes = self.helpFun(left, memo)\n            rightRes = self.helpFun(right, memo)\n            if leftRes and rightRes:\n                for l in leftRes:\n                    for r in rightRes:\n                        res.append(\"(\" + l + \", \" + r + \")\")\n        return(res)\n                        \n    def helpFun(self, string, memo):\n        if len(string) == 1:\n            return([string])\n        \n        if string in memo:\n            return(memo[string])\n        \n        l = len(string)\n        res = []\n        #consider four situation\n        if string[0] == \"0\" and string[-1]==\"0\":\n            res = []\n        elif string[0] == \"0\" and string[-1]!=\"0\":\n            res = [string[0] + \".\" + string[1:]]\n        elif string[0] != \"0\" and string[-1] == \"0\":\n            res = [string]\n        else:\n            res.append(string)\n            for i in range(1, l):\n                res.append(string[:i] + \".\" + string[i:])\n        memo[string] = res\n        return(res)\n\n# main function\ndef main_solution(S):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.ambiguousCoordinates(S)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(2, 10)\n    digits = ''.join(random.choices(string.digits, k=length))\n    S = f\"({digits})\"\n    return {'S': S}", "io_pairs": [{"input": {"S": "(5356)"}, "output": ["(5, 356)", "(5, 3.56)", "(5, 35.6)", "(53, 56)", "(53, 5.6)", "(5.3, 56)", "(5.3, 5.6)", "(535, 6)", "(5.35, 6)", "(53.5, 6)"]}, {"input": {"S": "(6772)"}, "output": ["(6, 772)", "(6, 7.72)", "(6, 77.2)", "(67, 72)", "(67, 7.2)", "(6.7, 72)", "(6.7, 7.2)", "(677, 2)", "(6.77, 2)", "(67.7, 2)"]}, {"input": {"S": "(6143)"}, "output": ["(6, 143)", "(6, 1.43)", "(6, 14.3)", "(61, 43)", "(61, 4.3)", "(6.1, 43)", "(6.1, 4.3)", "(614, 3)", "(6.14, 3)", "(61.4, 3)"]}, {"input": {"S": "(20805)"}, "output": ["(2, 0.805)", "(20, 805)", "(20, 8.05)", "(20, 80.5)", "(208, 0.5)", "(2.08, 0.5)", "(20.8, 0.5)", "(2080, 5)"]}, {"input": {"S": "(0858)"}, "output": ["(0, 858)", "(0, 8.58)", "(0, 85.8)", "(0.8, 58)", "(0.8, 5.8)", "(0.85, 8)"]}, {"input": {"S": "(53069)"}, "output": ["(5, 3069)", "(5, 3.069)", "(5, 30.69)", "(5, 306.9)", "(53, 0.69)", "(5.3, 0.69)", "(530, 69)", "(530, 6.9)", "(5306, 9)", "(5.306, 9)", "(53.06, 9)", "(530.6, 9)"]}, {"input": {"S": "(322)"}, "output": ["(3, 22)", "(3, 2.2)", "(32, 2)", "(3.2, 2)"]}, {"input": {"S": "(1857)"}, "output": ["(1, 857)", "(1, 8.57)", "(1, 85.7)", "(18, 57)", "(18, 5.7)", "(1.8, 57)", "(1.8, 5.7)", "(185, 7)", "(1.85, 7)", "(18.5, 7)"]}, {"input": {"S": "(74)"}, "output": ["(7, 4)"]}, {"input": {"S": "(8612)"}, "output": ["(8, 612)", "(8, 6.12)", "(8, 61.2)", "(86, 12)", "(86, 1.2)", "(8.6, 12)", "(8.6, 1.2)", "(861, 2)", "(8.61, 2)", "(86.1, 2)"]}], "error_log": []}
{"context": "Given an encrypted message where each character's ASCII value has been XOR-ed with a repeating key of length 3, what is the sum of the ASCII values of the characters in the decrypted message? The encrypted message is provided as a string of comma-separated integers.\n\nThe input and output requirements are as follows:\n\nInput:\n  `ciphertext` (str): A string representing the encrypted message, where each integer is separated by a comma.\n\nOutput:\n  `return` (int): The sum of the ASCII values of the characters in the decrypted message.", "reference_code": "# import necessary packages\nimport string\n\n# all class and function definitions in the code file, if any\ndef splitinput(ciphertext):\n    return [int(x) for x in ciphertext.split(\",\")]\n\ndef findtext(cipher):\n    letterlist = list(string.ascii_lowercase)\n    lenllist = len(letterlist)\n    output = ''\n    common = [\"the\", \"be\", \"to\", \"of\", \"and\"]\n    for i in range(lenllist):\n        for j in range(lenllist):\n            for k in range(lenllist):\n                for x in range(len(cipher)):\n                    if x % 3 == 0:\n                        output += chr(cipher[x] ^ ord(letterlist[i]))\n                    elif x % 3 == 1:\n                        output += chr(cipher[x] ^ ord(letterlist[j]))\n                    elif x % 3 == 2:\n                        output += chr(cipher[x] ^ ord(letterlist[k]))\n                if all(c in output for c in common):\n                    return output\n                output = ''\n    return \"Unsuccessful decryption.\"\n\ndef textsum(text):\n    tsum = 0\n    for i in range(len(text)):\n        tsum += ord(text[i])\n    return tsum\n\n# main function\ndef main_solution(ciphertext):\n    # Convert the input ciphertext string to a list of integers\n    cipher = splitinput(ciphertext)\n    # Decrypt the ciphertext\n    text = findtext(cipher)\n    # Calculate the sum of the ASCII values of the decrypted text\n    result = textsum(text)\n    # Return the result as an integer\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    common_words = [\"the\", \"be\", \"to\", \"of\", \"and\"]\n    letters = list(string.ascii_lowercase)\n    \n    # Randomly choose keys for each position (i, j, k)\n    i = random.choice(letters)\n    j = random.choice(letters)\n    k = random.choice(letters)\n    \n    # Generate a plaintext containing common words\n    plaintext = ' '.join([random.choice(common_words) for _ in range(random.randint(2, 5))])\n    plaintext += ' ' + ''.join(random.choice(letters) for _ in range(random.randint(3, 7)))\n    \n    # Encrypt the plaintext using the chosen keys\n    cipher = []\n    for x in range(len(plaintext)):\n        if x % 3 == 0:\n            cipher.append(ord(plaintext[x]) ^ ord(i))\n        elif x % 3 == 1:\n            cipher.append(ord(plaintext[x]) ^ ord(j))\n        else:\n            cipher.append(ord(plaintext[x]) ^ ord(k))\n    \n    ciphertext = ','.join(map(str, cipher))\n    return {'ciphertext': ciphertext}", "io_pairs": [{"input": {"ciphertext": "22,22,13,87,25,7,19,88,30,17,16,25,18,31"}, "output": 2450}, {"input": {"ciphertext": "23,10,84,1,0,84,26,9,84,1,7,17,85,27,31,16,26,12,3"}, "output": 2450}, {"input": {"ciphertext": "21,2,72,14,11,72,24,19,4,10"}, "output": 2450}, {"input": {"ciphertext": "3,13,80,14,14,80,21,3,2"}, "output": 2450}, {"input": {"ciphertext": "21,20,83,3,25,22,87,5,18,13"}, "output": 2450}, {"input": {"ciphertext": "16,28,21,81,6,30,81,16,20,81,29,24,30,11"}, "output": 2450}, {"input": {"ciphertext": "6,7,90,16,13,90,6,0,31,82,9,20,22,72,24,23,72,24,7,11,31"}, "output": 2450}, {"input": {"ciphertext": "10,5,21,75,31,30,75,9,20,75,10,31,15,75,5,3,14,81,5,18,16,30,24"}, "output": 2450}, {"input": {"ciphertext": "21,12,70,3,1,3,87,29,14,18,73,7,25,13,70,21,12,70,1,12,0,24,10,21,25"}, "output": 2450}, {"input": {"ciphertext": "5,29,81,16,28,21,81,6,25,20,82,19,20,82,6,27,1,20,19"}, "output": 2450}], "error_log": []}
{"context": "Given a linked list with various integer or string values, what is the result of performing a specific operation on this linked list? The operations include removing duplicates, finding the k-th to last element, partitioning the list around a value, summing two linked lists where each node is a single digit, and checking if the list is a palindrome. The input variables are the list of items in the linked list, the operation to perform, and optionally, a value `k` or a second linked list for certain operations.\n\nThe input and output requirements are as follows:\n\nInput:\n- `linked_list_data` (list of int or str): A list of items to be added to the linked list.\n- `operation` (str): The operation to perform on the linked list. Possible values are:\n  - `\"dedupe\"`: Remove duplicates from the linked list.\n  - `\"kth_to_last\"`: Find the k-th to last element in the linked list.\n  - `\"partition\"`: Partition the linked list around a value `k`.\n  - `\"sumLinkedList\"`: Sum two linked lists where each node is a single digit.\n  - `\"isPalindrome\"`: Check if the linked list is a palindrome.\n- `k` (int, optional): The value used for the `kth_to_last` and `partition` operations. Required for these operations.\n- `other_linked_list_data` (list of int or str, optional): A list of items to be added to the second linked list, required for the `sumLinkedList` operation.\n\nOutput:\n- `return` (list of int or str, bool, or int): The result of the operation. The type depends on the operation:\n  - For `dedupe`, `partition`, and `sumLinkedList`, it returns a list of items in the modified linked list.\n  - For `kth_to_last`, it returns the k-th to last element in the linked list.\n  - For `isPalindrome`, it returns a boolean indicating whether the linked list is a palindrome.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    def __init__(self, item):\n        self.next = None\n        self.data = item\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n\n    def appendToTail(self, item):\n        new_node = Node(item) if not isinstance(item, Node) else item\n        if self.head is None:\n            self.head = new_node\n        else:\n            current_node = self.head\n            while current_node.next is not None:\n                current_node = current_node.next\n            current_node.next = new_node\n\n        return new_node\n\n    def dedupe(self):\n        current_node = self.head\n        if current_node is None: return True\n        memo = set()\n        memo.add(current_node.data)\n        while current_node.next:\n            next_data = current_node.next.data\n            if next_data in memo:\n                current_node.next = current_node.next.next\n            else:\n                memo.add(next_data)\n                current_node = current_node.next\n        return self.head\n\n    def kth_to_last(self, k):\n        solution = self._kth_to_last(self.head, k)\n        if isinstance(solution, Node):\n            return solution.data\n        else:\n            return False\n\n    def _kth_to_last(self, head, k):\n        if head is None:\n            return 1\n\n        counter = self._kth_to_last(head.next, k)\n\n        if isinstance(counter, Node):\n            return counter\n        elif counter == k:\n            return head\n        else:\n            return counter + 1\n\n    def partition(self, k):\n        if self.head is None: return False\n        current_node = self.head\n\n        while current_node and current_node.next:\n            data = current_node.next.data\n            if data < k:\n                temp_node = current_node.next\n                current_node.next = current_node.next.next\n                temp_node.next = self.head\n                self.head = temp_node\n            current_node = current_node.next\n        return True\n\n    def sumLinkedList(self, other):\n        if other is None:\n            return self.head\n        result = LinkedList()\n        result.head = self._sumLinkedList(self.head, other.head)\n        return result\n\n    def _sumLinkedList(self, a, b, remainder=0):\n        if not a and not b and remainder == 0: return None\n        a_data = a.data if a else 0\n        b_data = b.data if b else 0\n        a_next = a.next if a else None\n        b_next = b.next if b else None\n        \n        new_digit = Node((a_data + b_data + remainder) % 10)\n        remainder = (a_data + b_data + remainder) // 10\n        new_digit.next = self._sumLinkedList(a_next, b_next, remainder)\n        return new_digit\n\n    def isPalindrome(self):\n        ll_as_list = [x.data for x in self]\n        return ll_as_list == list(reversed(ll_as_list))\n\n    def __iter__(self):\n        self.iter_node = self.head\n        return self\n\n    def __next__(self):\n        if self.iter_node is None: raise StopIteration\n        current_node = self.iter_node\n        self.iter_node = self.iter_node.next\n        return current_node\n\n# main function\ndef main_solution(linked_list_data, operation, k=None, other_linked_list_data=None):\n    # Convert JSON serializable input to original input variables\n    linked_list = LinkedList()\n    for item in linked_list_data:\n        linked_list.appendToTail(item)\n\n    if other_linked_list_data:\n        other_linked_list = LinkedList()\n        for item in other_linked_list_data:\n            other_linked_list.appendToTail(item)\n    else:\n        other_linked_list = None\n\n    # Perform the operation\n    if operation == \"dedupe\":\n        linked_list.dedupe()\n        result = [node.data for node in linked_list]\n    elif operation == \"kth_to_last\":\n        result = linked_list.kth_to_last(k)\n    elif operation == \"partition\":\n        linked_list.partition(k)\n        result = [node.data for node in linked_list]\n    elif operation == \"sumLinkedList\":\n        result_list = linked_list.sumLinkedList(other_linked_list)\n        result = [node.data for node in result_list]\n    elif operation == \"isPalindrome\":\n        result = linked_list.isPalindrome()\n    else:\n        raise ValueError(\"Invalid operation\")\n\n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    operations = [\"dedupe\", \"kth_to_last\", \"partition\", \"sumLinkedList\", \"isPalindrome\"]\n    operation = random.choice(operations)\n    \n    # Generate linked_list_data with some randomness\n    length = random.randint(1, 10)\n    linked_list_data = [random.randint(0, 9) for _ in range(length)]\n    \n    # For operations that require 'k'\n    k = None\n    if operation in [\"kth_to_last\", \"partition\"]:\n        k = random.randint(1, length) if operation == \"kth_to_last\" else random.randint(0, 9)\n    \n    # For sumLinkedList, generate other_linked_list_data\n    other_linked_list_data = None\n    if operation == \"sumLinkedList\":\n        other_length = random.randint(1, 10)\n        other_linked_list_data = [random.randint(0, 9) for _ in range(other_length)]\n    \n    return {\n        \"linked_list_data\": linked_list_data,\n        \"operation\": operation,\n        \"k\": k,\n        \"other_linked_list_data\": other_linked_list_data\n    }", "io_pairs": [{"input": {"linked_list_data": [7, 2, 2, 9, 5, 1, 4], "operation": "kth_to_last", "k": 7, "other_linked_list_data": null}, "output": 7}, {"input": {"linked_list_data": [0, 3, 1, 2, 6, 2, 4, 4], "operation": "partition", "k": 6, "other_linked_list_data": null}, "output": [4, 2, 2, 3, 0, 1, 6, 4]}, {"input": {"linked_list_data": [8, 3, 8, 5], "operation": "isPalindrome", "k": null, "other_linked_list_data": null}, "output": false}, {"input": {"linked_list_data": [3], "operation": "partition", "k": 7, "other_linked_list_data": null}, "output": [3]}, {"input": {"linked_list_data": [4], "operation": "partition", "k": 3, "other_linked_list_data": null}, "output": [4]}, {"input": {"linked_list_data": [2, 0], "operation": "partition", "k": 3, "other_linked_list_data": null}, "output": [0, 2]}, {"input": {"linked_list_data": [8, 0, 2, 7, 1, 2, 3, 7, 8, 8], "operation": "isPalindrome", "k": null, "other_linked_list_data": null}, "output": false}, {"input": {"linked_list_data": [7, 8, 8, 8, 3], "operation": "dedupe", "k": null, "other_linked_list_data": null}, "output": [7, 8, 3]}, {"input": {"linked_list_data": [7, 4, 0, 9, 5], "operation": "dedupe", "k": null, "other_linked_list_data": null}, "output": [7, 4, 0, 9, 5]}, {"input": {"linked_list_data": [0, 1, 4, 4, 9, 6], "operation": "kth_to_last", "k": 1, "other_linked_list_data": null}, "output": 6}], "error_log": []}
{"context": "Given a track map for a mine cart system, where each character represents a part of the track or a cart, determine the coordinates of the first collision that occurs when the carts start moving. The track map is represented as a list of strings, where each string is a row of the map. What are the coordinates of the first collision?\n\nThe input and output requirements are as follows:\n\nInput:\n  `track_map` (list of strings): A list where each string represents a row of the track map. Each character in the string represents a part of the track or a cart.\n\nOutput:\n  `return` (dict): A dictionary with a single key `collision_point` which is a tuple representing the coordinates (x, y) of the first collision detected on the track.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Tracks:\n    def __init__(self):\n        self.tracks = {}\n        self.carts = {}\n\n    def input_line(self, str, y):\n        for x, m in enumerate(str):\n            if m == ' ': continue\n            if m in '|/-+\\\\':\n                self.tracks[(x, y)] = m\n                continue\n            if m in '<>':\n                self.tracks[(x, y)] = '-'\n                self.carts[(x, y)] = {\n                    'sym': m,\n                    'turn': 0\n                }\n                continue\n            if m in '^v':\n                self.tracks[(x, y)] = '|'\n                self.carts[(x, y)] = {\n                    'sym': m,\n                    'turn': 0\n                }\n                continue\n        return\n\n    def xy_move(self, xy, dir):\n        x, y = xy\n        if dir == '>': return x + 1, y\n        if dir == '<': return x - 1, y\n        if dir == '^': return x, y - 1\n        if dir == 'v': return x, y + 1\n        print(\"ERR - invalid dir: xy_move(xy:\", xy, \",dir:\", dir, \")\")\n\n    def move_cart(self, xy):\n        turns = {\n            '>': {\n                '/': '^',\n                '\\\\': 'v',\n                '+': ['^', '>', 'v']\n            },\n            '<': {\n                '/': 'v',\n                '\\\\': '^',\n                '+': ['v', '<', '^']\n            },\n            '^': {\n                '/': '>',\n                '\\\\': '<',\n                '+': ['<', '^', '>']\n            },\n            'v': {\n                '/': '<',\n                '\\\\': '>',\n                '+': ['>', 'v', '<']\n            },\n        }\n        dir = self.carts[xy]['sym']\n        trackxy = self.tracks.get(xy)\n        newdir = turns.get(dir).get(trackxy)\n        if trackxy == '+':\n            idx = self.carts[xy]['turn'] % 3\n            dir = newdir[idx]\n            self.carts[xy]['turn'] += 1\n            self.carts[xy]['sym'] = dir\n        else:\n            if newdir:\n                dir = newdir\n                self.carts[xy]['sym'] = dir\n        newxy = self.xy_move(xy, dir)\n        return newxy\n\n    def time_tick(self):\n        carts = {}\n        for xy, symbol in self.carts.items():\n            newxy = self.move_cart(xy)\n            if newxy in carts:\n                self.carts[newxy] = {\n                    'sym': 'X'\n                }\n                return newxy\n            carts[newxy] = self.carts[xy]\n        self.carts = carts\n        return None\n\n    def task_a(self, input):\n        for y, line in enumerate(input):\n            self.input_line(line, y)\n        for t in range(20):\n            colxy = self.time_tick()\n            if colxy: break\n        return colxy\n\n# main function\ndef main_solution(track_map):\n    tracks = Tracks()\n    collision_point = tracks.task_a(track_map)\n    return {'collision_point': collision_point}", "input_generator": "import random\n\ndef input_generator():\n    # Define possible track components\n    straight_track = ['|', '-']\n    curve_track = ['/', '\\\\']\n    intersection = '+'\n    cart_symbols = ['^', 'v', '<', '>']\n    \n    # Randomly determine the size of the track map\n    rows = random.randint(5, 15)\n    cols = random.randint(5, 15)\n    \n    track_map = []\n    carts_added = set()\n    \n    for y in range(rows):\n        row = []\n        for x in range(cols):\n            # Randomly decide to add a track or cart (with lower probability for carts)\n            if random.random() < 0.7:\n                # Add a track piece\n                if random.random() < 0.1:\n                    row.append(intersection)\n                else:\n                    if random.random() < 0.5:\n                        row.append(random.choice(straight_track))\n                    else:\n                        row.append(random.choice(curve_track))\n            else:\n                # Add a cart, ensuring no duplicate carts\n                if (x, y) not in carts_added and random.random() < 0.2:\n                    cart = random.choice(cart_symbols)\n                    row.append(cart)\n                    carts_added.add((x, y))\n                else:\n                    # Add a space or track if no cart is added\n                    if random.random() < 0.5:\n                        row.append(' ')\n                    else:\n                        row.append(random.choice(straight_track + curve_track))\n        track_map.append(''.join(row))\n    \n    # Ensure at least two carts are present for possible collision\n    if len(carts_added) < 2:\n        # Reset and add at least two carts\n        track_map = []\n        carts_added = set()\n        for y in range(rows):\n            row = []\n            for x in range(cols):\n                if len(carts_added) < 2 and random.random() < 0.3:\n                    cart = random.choice(cart_symbols)\n                    row.append(cart)\n                    carts_added.add((x, y))\n                else:\n                    if random.random() < 0.5:\n                        row.append(' ')\n                    else:\n                        row.append(random.choice(straight_track + curve_track + [intersection]))\n            track_map.append(''.join(row))\n    \n    return {'track_map': track_map}", "io_pairs": [{"input": {"track_map": ["\\ \\\\|", "--|-|", "\\||-|", " \\\\| ", "\\<\\\\|", "-\\/+/", "\\/\\|/", " /\\\\+", "|/|\\-", "\\ -> "]}, "output": {"collision_point": null}}, {"input": {"track_map": ["\\-|^/", "|- /^", "|||/\\", "- /+-", "- / /"]}, "output": {"collision_point": null}}, {"input": {"track_map": ["//\\  ", "\\-\\-/", "-+/|<", "^\\|-/", "\\-v/\\", "-//\\ ", "-|  |", "/|-| "]}, "output": {"collision_point": null}}, {"input": {"track_map": [" /--\\/|-\\\\ -\\", "-->- |\\\\|-|--", "\\|\\ -/|--/|/|", "/-^\\ -| --+--", " \\-///||+ -|-", "|  v-/\\/|++ /", "|\\|\\- ||--|\\|", "\\ \\\\||/|-\\|-<"]}, "output": {"collision_point": null}}, {"input": {"track_map": ["\\/\\//|/", "+\\ |/|+", " ^|-\\/-", "\\\\/+ ||", "</| || ", "-/-+\\/|", "//  \\\\ "]}, "output": {"collision_point": null}}, {"input": {"track_map": ["//\\+/|//-", "/\\>||/- +", "\\ /| \\|\\^", "- \\\\-\\\\||", "+/ /- -+\\", "+--|--|\\|", "\\\\-|||-+/", " |\\/-|-\\ "]}, "output": {"collision_point": null}}, {"input": {"track_map": ["-/--|//\\--\\", "-//|//\\|///", "|\\//<-|/\\ -", "||-\\\\\\-/\\//", "/v\\//\\\\ \\ |", " / /  |\\+-/", "^\\|\\|//||\\/", "/ /--\\-\\-/|"]}, "output": {"collision_point": null}}, {"input": {"track_map": ["/<  ^/-/\\\\", " \\  -  -  ", "  + \\ +|+ ", "+\\|/ \\/- +", " \\ \\ /| \\ ", "\\+ /+- /  ", "    /\\// \\", "  +- /  + ", " - /|\\ +| "]}, "output": {"collision_point": null}}, {"input": {"track_map": [" --\\-|/ |", "\\--|<\\||/", "/||-/--||", "\\/-+<<\\| ", "\\ /--//+ ", "\\|/|||\\/>", "|-/+-\\/ |", "- -|\\--|+"]}, "output": {"collision_point": null}}, {"input": {"track_map": ["-/\\/|", "\\--\\\\", "\\-|  ", "\\\\/\\<", "->||-", "\\++|/", "-\\\\- ", "/  +\\", "\\+\\ |", "\\---\\"]}, "output": {"collision_point": null}}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = x(x-1) \\), we are interested in understanding how small changes in the input affect the function's value. Additionally, we want to approximate the area under a curve defined by \\( y = \\sqrt{1 - x^2} \\) over the interval \\([-1, 1]\\). \n\nWhat is the derivative of \\( f(x) \\) at a specific point \\( x \\) and the approximate integral value of the function \\( y = \\sqrt{1 - x^2} \\) using a specified number of intervals \\( N \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): The point at which the derivative is to be calculated.\n  `delta` (float): The small increment used in the definition of the derivative.\n  `N` (int): The number of intervals used in the numerical integration.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `derivative_at_x` (float): The calculated derivative at the point `x`.\n    - `integral_value` (float): The calculated integral value using the given number of intervals `N`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# define a function\ndef f(x):\n    return x*(x-1)\n\ndef derivative(x, delta):\n    dfdx = (f(x+delta) - f(x)) / delta\n    return dfdx\n\ndef yk(x):\n    return np.sqrt(1-x**2)\n\ndef integral(N):\n    h = 2/N\n    area = 0\n    for k in range(1, N+1):\n        xk = -1 + h*k\n        y = yk(xk)\n        area = area + y*h\n    return area\n\n# main function\ndef main_solution(x, delta, N):\n    # Calculate the derivative at x with given delta\n    deriv_value = derivative(x, delta)\n    \n    # Calculate the integral with given N\n    integral_value = integral(N)\n    \n    # Return the results as a dictionary\n    return {\n        \"derivative_at_x\": deriv_value,\n        \"integral_value\": integral_value\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    x = random.uniform(-10.0, 10.0)\n    delta = 10 ** random.uniform(-10, -1)\n    N = random.randint(10, 10000)\n    return {\n        \"x\": x,\n        \"delta\": delta,\n        \"N\": N\n    }", "io_pairs": [{"input": {"x": 6.114622396289388, "delta": 6.559842737592964e-07, "N": 9775}, "output": {"derivative_at_x": 11.229245456203016, "integral_value": 1.570794605965458}}, {"input": {"x": 2.323704580049668, "delta": 3.610893340746688e-09, "N": 8688}, "output": {"derivative_at_x": 3.647409217641799, "integral_value": 1.5707942731142102}}, {"input": {"x": 2.74486385340146, "delta": 3.759538532279275e-09, "N": 3048}, "output": {"derivative_at_x": 4.4897276704768, "integral_value": 1.5707864438921388}}, {"input": {"x": 9.983103871664532, "delta": 1.2446085185134683e-06, "N": 9605}, "output": {"derivative_at_x": 18.966209004495806, "integral_value": 1.5707945600783568}}, {"input": {"x": -6.9307305014461695, "delta": 1.023389142534201e-09, "N": 4654}, "output": {"derivative_at_x": -14.861463782850622, "integral_value": 1.5707910887355805}}, {"input": {"x": -3.67603250223834, "delta": 9.717901837257355e-07, "N": 9465}, "output": {"derivative_at_x": -8.352064033358808, "integral_value": 1.5707945207357839}}, {"input": {"x": -6.431747144589856, "delta": 2.596997277392049e-07, "N": 1052}, "output": {"derivative_at_x": -13.86349401663773, "integral_value": 1.5707475888977844}}, {"input": {"x": 6.265077641362161, "delta": 6.321185558933014e-06, "N": 3858}, "output": {"derivative_at_x": 11.530161603789022, "integral_value": 1.5707893866991045}}, {"input": {"x": -1.4541160286158288, "delta": 8.468575093155371e-05, "N": 2140}, "output": {"derivative_at_x": -3.908147371482919, "integral_value": 1.570779527826978}}, {"input": {"x": -9.318319169209088, "delta": 8.490655301641857e-10, "N": 5305}, "output": {"derivative_at_x": -19.63663018495603, "integral_value": 1.570792022692449}}], "error_log": []}
{"context": "Given a range of six-digit numbers, determine how many of these numbers meet the criteria for being a valid password. The criteria differ based on the part of the problem being solved:\n\n- **Part 1**: A password is valid if it has at least one pair of adjacent digits that are the same and the digits never decrease from left to right.\n- **Part 2**: A password is valid if it has at least one pair of adjacent digits that are the same but not part of a larger group of matching digits, and the digits never decrease from left to right.\n\nHow many valid passwords are there within the given range for the specified part of the problem?\n\nThe input and output requirements are as follows:\n\nInput:\n  `inclusive_start` (int): The starting number of the range (inclusive).\n  `inclusive_stop` (int): The ending number of the range (inclusive).\n  `part` (int): The part of the problem to solve (1 or 2).\n\nOutput:\n  `return` (int): The number of valid passwords based on the specified part of the problem.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nvalid_passwords_1 = []\nvalid_passwords_2 = []\n\ndef iterate_through_range(inclusive_start, inclusive_stop, part=1):\n    for num in range(inclusive_start, inclusive_stop + 1):\n        if check_requirements(num):\n            if check_increase(num):\n                if part == 1:\n                    check_adjacent(num)\n                else:\n                    check_only_two_adjacent(num)\n\ndef check_requirements(number):\n    if len(str(number)) == 6:\n        return True\n\ndef check_increase(number):\n    for i in range(0, 5):\n        try:\n            if int(str(number)[i]) > int(str(number)[i + 1]):\n                break\n        except IndexError:\n            break\n    else:\n        return True\n\ndef check_adjacent(number):\n    for i in range(0, 5):\n        if str(number)[i] == str(number)[i + 1]:  # Two adjacent == good\n            valid_passwords_1.append(number)\n            break\n\ndef check_only_two_adjacent(number):\n    hit = False\n    for i in range(0, 5):\n        two_similar = False\n        if str(number)[i] == str(number)[i + 1]:\n            two_similar = True\n            try:\n                if str(number)[i] == str(number)[i + 2]:\n                    two_similar = False\n            except IndexError:\n                pass\n            try:\n                if str(number)[i] == str(number)[i - 1]:\n                    two_similar = False\n            except IndexError:\n                pass\n        else:\n            pass\n        if two_similar:\n            hit = True\n    if hit:\n        valid_passwords_2.append(number)\n\n# main function\ndef main_solution(inclusive_start, inclusive_stop, part):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    global valid_passwords_1, valid_passwords_2\n    valid_passwords_1 = []\n    valid_passwords_2 = []\n    \n    iterate_through_range(inclusive_start, inclusive_stop, part)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if part == 1:\n        return len(valid_passwords_1)\n    else:\n        return len(valid_passwords_2)", "input_generator": "import random\n\ndef input_generator():\n    # Generate a reasonable range for the password, ensuring it's a 6-digit number\n    start = random.randint(100000, 500000)\n    stop = random.randint(start, 999999)\n    part = random.choice([1, 2])\n    return {\n        'inclusive_start': start,\n        'inclusive_stop': stop,\n        'part': part\n    }", "io_pairs": [{"input": {"inclusive_start": 285741, "inclusive_stop": 905498, "part": 1}, "output": 922}, {"input": {"inclusive_start": 134651, "inclusive_stop": 488853, "part": 2}, "output": 1223}, {"input": {"inclusive_start": 478587, "inclusive_stop": 801972, "part": 1}, "output": 214}, {"input": {"inclusive_start": 431480, "inclusive_stop": 488414, "part": 2}, "output": 163}, {"input": {"inclusive_start": 176210, "inclusive_stop": 509318, "part": 1}, "output": 1499}, {"input": {"inclusive_start": 242690, "inclusive_stop": 763693, "part": 2}, "output": 739}, {"input": {"inclusive_start": 178903, "inclusive_stop": 941930, "part": 2}, "output": 1150}, {"input": {"inclusive_start": 446246, "inclusive_stop": 461885, "part": 1}, "output": 104}, {"input": {"inclusive_start": 234387, "inclusive_stop": 722318, "part": 1}, "output": 1246}, {"input": {"inclusive_start": 149821, "inclusive_stop": 351374, "part": 1}, "output": 1228}], "error_log": []}
{"context": "In a baseball game, a player tries to guess a 3-digit number. After each guess, the player is given feedback in the form of strikes and balls. A strike means a correct digit in the correct position, while a ball means a correct digit in the wrong position. Given a set of feedback rules, how many possible 3-digit numbers (with unique digits) can satisfy all the given rules?\n\nThe input and output requirements are as follows:\n\nInput:\n  `baseball` (list of tuples): A list of tuples where each tuple contains three integers. The first integer represents a 3-digit number, the second integer represents the number of strikes, and the third integer represents the number of balls.\n\nOutput:\n  `return` (int): The number of valid 3-digit permutations that satisfy the given baseball rules.", "reference_code": "# import necessary packages\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef check_score(candi, baseball):\n    for check_num, s, b in baseball:\n        check_num = [int(x) for x in str(check_num)]\n        strike = 0\n        for i in range(3):\n            if candi[i] == check_num[i]:\n                strike += 1\n        if strike != s:\n            return False\n        ball = len(set(candi) & set(check_num)) - strike\n        if ball != b:\n            return False\n    return True\n\n# main function\ndef main_solution(baseball):\n    # Convert the input to the required format\n    baseball = [(int(str(num)), s, b) for num, s, b in baseball]\n    \n    # Generate all possible permutations of 3 digits from 1 to 9\n    candi_list = list(permutations(list(range(1,10)), 3))\n\n    # Count valid permutations based on the baseball rules\n    answer = 0\n    for candi in candi_list:\n        if check_score(candi, baseball):\n            answer += 1\n    \n    # Return the count of valid permutations\n    return answer", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random number of baseball cases (1 to 5)\n    num_cases = random.randint(1, 5)\n    baseball = []\n    \n    for _ in range(num_cases):\n        # Generate a random 3-digit number with unique digits from 1-9\n        num = random.sample(range(1, 10), 3)\n        num = int(''.join(map(str, num)))\n        \n        # Generate random strikes (0-3) and balls (0-3), ensuring s + b <= 3\n        s = random.randint(0, 3)\n        b = random.randint(0, 3 - s)\n        \n        baseball.append((num, s, b))\n    \n    return {'baseball': baseball}", "io_pairs": [{"input": {"baseball": [[197, 0, 2], [129, 0, 0], [875, 2, 0]]}, "output": 0}, {"input": {"baseball": [[945, 1, 0], [196, 0, 3], [258, 3, 0], [639, 3, 0], [184, 2, 0]]}, "output": 0}, {"input": {"baseball": [[652, 2, 0], [241, 0, 1], [518, 0, 1]]}, "output": 5}, {"input": {"baseball": [[481, 3, 0]]}, "output": 1}, {"input": {"baseball": [[215, 3, 0]]}, "output": 1}, {"input": {"baseball": [[978, 3, 0], [985, 1, 1], [349, 1, 0], [397, 1, 0], [498, 1, 2]]}, "output": 0}, {"input": {"baseball": [[376, 1, 1], [126, 0, 0]]}, "output": 8}, {"input": {"baseball": [[357, 2, 0], [162, 2, 0], [234, 0, 3], [132, 1, 0]]}, "output": 0}, {"input": {"baseball": [[584, 2, 1], [871, 1, 1]]}, "output": 0}, {"input": {"baseball": [[473, 0, 3], [128, 1, 0], [135, 1, 2]]}, "output": 0}], "error_log": []}
{"context": "Given a system of linear equations represented by a square matrix \\( A \\) and a vector \\( b \\), what is the solution vector \\( x \\) after converting the augmented matrix \\([A | b]\\) to its reduced echelon form?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the square matrix A and the vector b.\n  `A` (list of lists of floats): The square matrix A represented as a list of lists of floats.\n  `b` (list of floats): The vector b represented as a list of floats.\n\nOutput:\n  `return` (list of strings): The solution vector x represented as a list of strings. Each string can be either \"any value\" or \"no value\" depending on the solution status.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef to_reduced_echlon(aug):\n    rows = np.size(aug, 0)\n    cols = np.size(aug, 1) - 1\n\n    i = 0;\n    j = 0;\n\n    while (i < rows) & (j < cols):\n\n        k = i\n        while aug[k, j] == 0:\n            k += 1\n            if k >= rows:\n                break\n\n        if k >= rows:\n            j += 1\n            continue\n\n        if (k < rows) & (k != i):\n            aug[[i, k]] = aug[[k, i]]\n\n        aug[i] = np.divide(aug[i], aug[i, j])\n\n        for r in range(0, rows):\n            if r == i:\n                continue\n            temp1 = aug[r, j] / aug[i, j]\n            temp1 *= -1\n            temp2 = np.add(temp1 * aug[i], aug[r])\n            aug[r] = temp2\n        i += 1\n        j += 1\n\n    return aug\n\n# main function\ndef main_solution(n, A, b):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    A = np.array(A, dtype=float)\n    b = np.array(b, dtype=float).reshape(n, 1)\n    aug = np.hstack((A, b))\n\n    reduced_aug = to_reduced_echlon(aug)\n\n    x = [\"any value\" for _ in range(n)]\n\n    i = n - 1\n    j = n - 1\n    flag = True\n    while i >= 0 and j >= 0:\n        if reduced_aug[i][j] == 1:\n            x[j] = reduced_aug[i][n]\n            i -= 1\n            j -= 1\n        elif reduced_aug[i][n] != 0:\n            flag = False\n            i -= 1\n\n    if not flag:\n        for i in range(n):\n            x[i] = \"no value\"\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return x", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    n = random.randint(1, 5)  # Small size for reasonable inputs\n    A = np.random.randint(-10, 10, size=(n, n)).tolist()\n    b = np.random.randint(-10, 10, size=(n,)).tolist()\n    return {'n': n, 'A': A, 'b': b}", "io_pairs": [{"input": {"n": 2, "A": [[2, 5], [7, -9]], "b": [4, 9]}, "output": [1.5283018867924527, 0.18867924528301888]}, {"input": {"n": 1, "A": [[3]], "b": [5]}, "output": [1.6666666666666667]}, {"input": {"n": 2, "A": [[-1, -6], [5, 5]], "b": [-2, 5]}, "output": [0.7999999999999998, 0.2]}, {"input": {"n": 2, "A": [[-8, -4], [8, 1]], "b": [-8, -10]}, "output": [-2.0, 6.0]}, {"input": {"n": 1, "A": [[2]], "b": [-4]}, "output": [-2.0]}, {"input": {"n": 2, "A": [[5, 3], [-4, 4]], "b": [-4, -4]}, "output": [-0.1250000000000001, -1.125]}, {"input": {"n": 1, "A": [[-1]], "b": [-8]}, "output": [8.0]}, {"input": {"n": 1, "A": [[2]], "b": [4]}, "output": [2.0]}, {"input": {"n": 1, "A": [[4]], "b": [0]}, "output": [0.0]}, {"input": {"n": 2, "A": [[5, 7], [2, -5]], "b": [5, 4]}, "output": [1.358974358974359, -0.25641025641025644]}], "error_log": []}
{"context": "Alex is designing a puzzle game where players need to arrange pipes on a grid to ensure water flows from each source to its corresponding sink. The grid contains different types of pipes and sources/sinks represented by letters. Given a grid configuration, how many cells with pipes will be full of water if the arrangement is correct, or how many cells will have water before the first leakage or incorrect destination is reached?\n\nThe input and output requirements are as follows:\n\nInput:\n  `state` (list of strings): A list of strings representing the grid of pipes. Each string represents a row in the grid. The grid contains pipes represented by numbers (1-7) and sources/sinks represented by lowercase and uppercase letters respectively.\n\nOutput:\n  `return` (int): An integer representing the number of cells with pipes that will be full of water at the end of the game if the arrangement is correct. If the arrangement is incorrect, it returns -X, where X is the number of cells with water before the first leakage point is reached or if the first drop of water reaches an incorrect destination.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_connected(pipe1, pipe2):\n    # Check if two pipes are connected\n    if pipe1 == '1' and (pipe2 in '134'):  # vertical pipe\n        return True\n    if pipe1 == '2' and (pipe2 in '256'):  # horizontal pipe\n        return True\n    if pipe1 in '3' and (pipe2 in '26'):  # corner pipe\n        return True\n    if pipe1 in '4' and (pipe2 in '15'):  # corner pipe\n        return True\n    if pipe1 in '5' and (pipe2 in '46'):  # corner pipe\n        return True\n    if pipe1 in '6' and (pipe2 in '35'):  # corner pipe\n        return True\n    if pipe1 == '7':  # crossed pipes\n        return True\n    return False\n\ndef find_sources_sinks(state):\n    # Find all sources and sinks in the state\n    sources = []\n    sinks = []\n    for i in range(len(state)):\n        for j in range(len(state[i])):\n            if state[i][j].isalpha() and state[i][j].islower():\n                sources.append((i, j))\n            elif state[i][j].isalpha() and state[i][j].isupper():\n                sinks.append((i, j))\n    return sources, sinks\n\ndef flood_fill(state, sources, sinks):\n    # Flood fill algorithm to check if water reaches the correct sink\n    visited = set()\n    water_cells = 0\n    for source, sink in zip(sources, sinks):\n        stack = [source]\n        while stack:\n            x, y = stack.pop()\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            water_cells += 1\n            if (x, y) == sink:\n                break\n            pipe = state[x][y]\n            if x > 0 and is_connected(pipe, state[x-1][y]) and (x-1, y) not in visited:\n                stack.append((x-1, y))\n            if x < len(state) - 1 and is_connected(pipe, state[x+1][y]) and (x+1, y) not in visited:\n                stack.append((x+1, y))\n            if y > 0 and is_connected(pipe, state[x][y-1]) and (x, y-1) not in visited:\n                stack.append((x, y-1))\n            if y < len(state[0]) - 1 and is_connected(pipe, state[x][y+1]) and (x, y+1) not in visited:\n                stack.append((x, y+1))\n        else:\n            return -water_cells\n    return water_cells\n\n# main function\ndef main_solution(state):\n    # Convert state to list of strings\n    state = [list(row) for row in state]\n    \n    # Find sources and sinks\n    sources, sinks = find_sources_sinks(state)\n    \n    # Check if the arrangement of pipes is correct\n    result = flood_fill(state, sources, sinks)\n    \n    # Return the result\n    return result", "input_generator": "import random\n\ndef input_generator():\n    pipe_types = ['1', '2', '3', '4', '5', '6', '7']\n    rows = random.randint(3, 8)\n    cols = random.randint(3, 8)\n    \n    # Generate a random grid with pipes\n    grid = [[random.choice(pipe_types) for _ in range(cols)] for _ in range(rows)]\n    \n    # Add sources and sinks\n    num_pairs = random.randint(1, min(rows, cols))\n    sources = []\n    sinks = []\n    \n    for _ in range(num_pairs):\n        while True:\n            x = random.randint(0, rows - 1)\n            y = random.randint(0, cols - 1)\n            if (x, y) not in sources and grid[x][y] not in [cell for pair in sources + sinks for cell in pair]:\n                sources.append((x, y))\n                grid[x][y] = chr(random.randint(97, 122))  # lowercase letter\n                break\n        \n        while True:\n            x = random.randint(0, rows - 1)\n            y = random.randint(0, cols - 1)\n            if (x, y) not in sinks and (x, y) not in sources and grid[x][y] not in [cell for pair in sources + sinks for cell in pair]:\n                sinks.append((x, y))\n                grid[x][y] = chr(random.randint(65, 90))  # uppercase letter\n                break\n    \n    # Convert grid to list of strings\n    state = [''.join(row) for row in grid]\n    \n    return {'state': state}", "io_pairs": [{"input": {"state": ["323t176", "5A662G6", "266534y"]}, "output": -1}, {"input": {"state": ["774j3125", "B1H523k6", "71A763u2", "6m423446"]}, "output": -1}, {"input": {"state": ["53562", "13444", "51612", "37612", "q7617", "U1411"]}, "output": -1}, {"input": {"state": ["223", "36M", "gx2", "K64", "536", "55E", "k57"]}, "output": -1}, {"input": {"state": ["v462X637", "6d11615U", "63317232", "7343E325", "sz551466", "1I1vR723"]}, "output": -1}, {"input": {"state": ["2233273", "1164627", "2yC2w53", "3633665", "1272456", "b172272", "317216S", "C21F1u7"]}, "output": -1}, {"input": {"state": ["6O2635d7", "1477f632", "47242723", "2175D213", "76374437", "23724663"]}, "output": -1}, {"input": {"state": ["om731711", "K3537653", "6W323Vn5", "57442673"]}, "output": -1}, {"input": {"state": ["24353521", "34OJ5343", "241667o4", "35v75437", "22341131", "75762Eb7"]}, "output": -1}, {"input": {"state": ["35627", "45242", "41427", "51L73", "2V164", "q3454", "43v76"]}, "output": -1}], "error_log": []}
{"context": "Given a dragon curve fractal, which is a type of recursive fractal curve, how far will a virtual turtle travel if it follows the curve's instructions up to a certain depth? The curve is defined by a series of right and left turns, and the turtle moves forward by a specified length at each step. What is the total distance traveled by the turtle after drawing the curve to the specified depth?\n\nThe input and output requirements are as follows:\n\nInput:\n  `length` (float): The length of each segment of the dragon curve. Must be a positive numeric value.\n  `depth` (int): The depth of recursion for drawing the dragon curve. Must be a positive integer.\nOutput:\n  `return` (float): The total distance traveled by the turtle after drawing the dragon curve.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\ndef turnright(T, length, depth):\n    if depth == 0:\n        T['position'] += length\n    else:\n        turnright(T, length, depth - 1)\n        T['angle'] += 90\n        drawFig(T, length, depth - 1)\n\ndef drawFig(T, length, depth):\n    if depth == 0:\n        T['position'] += length\n    else:\n        turnright(T, length, depth - 1)\n        T['angle'] -= 90\n        drawFig(T, length, depth - 1)\n\n# main function\ndef main_solution(length, depth):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    T = {'position': 0, 'angle': 0}\n    drawFig(T, length, depth)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return T['position']", "input_generator": "import random\n\ndef input_generator():\n    length = random.randint(1, 10)\n    depth = random.randint(0, 5)\n    return {'length': length, 'depth': depth}", "io_pairs": [{"input": {"length": 4, "depth": 3}, "output": 32}, {"input": {"length": 2, "depth": 0}, "output": 2}, {"input": {"length": 10, "depth": 2}, "output": 40}, {"input": {"length": 3, "depth": 1}, "output": 6}, {"input": {"length": 6, "depth": 2}, "output": 24}, {"input": {"length": 1, "depth": 1}, "output": 2}, {"input": {"length": 2, "depth": 3}, "output": 16}, {"input": {"length": 3, "depth": 3}, "output": 24}, {"input": {"length": 3, "depth": 5}, "output": 96}, {"input": {"length": 10, "depth": 4}, "output": 160}], "error_log": []}
{"context": "Given a password policy that requires the next password to be incremented from the current one, what is the next valid password that meets the following criteria:\n1. It does not contain the letters 'i', 'o', or 'l'.\n2. It includes at least one sequence of three consecutive letters (e.g., 'abc').\n3. It contains at least two different, non-overlapping pairs of letters (e.g., 'aa' and 'bb').\n\nWhat is the next valid password starting from the given `initial_password`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_password` (str): A string representing the initial password that needs to be incremented to find the next valid password. The string should be composed of lowercase letters and should not contain the letters 'i', 'o', or 'l'.\n\nOutput:\n  `return` (str): A string representing the next valid password that meets the criteria. If no valid password is found, it returns the string \"No valid password found\".", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\ndef inc(s):\n    i = len(s) - 1\n    while True:\n        if i < 0:\n            break\n\n        if s[i] < 'z':\n            s[i] = chr(ord(s[i]) + 1)\n            break\n            \n        s[i] = 'a'\n        i -= 1\n        \n    return s\n    \ndef test(s):\n    if 'i' in s or 'o' in s or 'l' in s:\n        return False\n    \n    seq = False\n    i = 2\n    while i < len(s):\n        if ord(s[i-2]) + 1 == ord(s[i-1]) and ord(s[i-1]) + 1 == ord(s[i]):\n            seq = True\n            break\n        \n        i += 1\n    \n    if not seq:\n        return False\n        \n    pairs = False\n    pair_char = ''\n    i = 2\n    while i < len(s):\n        if s[i] != pair_char and s[i-1] == s[i]:\n            if pair_char == '':\n                pair_char = s[i]\n                i += 1\n            else:\n                pairs = True\n                break\n        \n        i += 1\n    \n    return pairs\n\n# main function\ndef main_solution(initial_password):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  passwd = inc(list(initial_password))\n  iterations = 1\n  while True:\n      if passwd == initial_password:\n          return \"No valid password found\"\n      if test(passwd):\n          break\n      passwd = inc(passwd)\n      iterations += 1\n\n  return ''.join(passwd)", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(8, 12)\n    initial_password = []\n    for _ in range(length):\n        c = random.choice(string.ascii_lowercase)\n        while c in {'i', 'o', 'l'}:\n            c = random.choice(string.ascii_lowercase)\n        initial_password.append(c)\n    return {'initial_password': ''.join(initial_password)}", "io_pairs": [{"input": {"initial_password": "yhuejvdjgx"}, "output": "yhuejvvwxx"}, {"input": {"initial_password": "dqywqkuknvp"}, "output": "dqywqkuuvww"}, {"input": {"initial_password": "pcsxyfzu"}, "output": "pctaabcc"}, {"input": {"initial_password": "rgwgdzkcxg"}, "output": "rgwgeaabcc"}, {"input": {"initial_password": "xvkymxgj"}, "output": "xvmaabcc"}, {"input": {"initial_password": "dsbxhzchj"}, "output": "dsbxppqrr"}, {"input": {"initial_password": "naebkvwpxu"}, "output": "naebkwwxyy"}, {"input": {"initial_password": "vqavsajz"}, "output": "vqavvwxx"}, {"input": {"initial_password": "nknwutujyj"}, "output": "nknwuuaabc"}, {"input": {"initial_password": "ygqvkcunwzd"}, "output": "ygqvkcuuvww"}], "error_log": []}
{"context": "Imagine a scenario where a drunken student is walking randomly on a field. After a certain number of steps, we want to know the average distance they have traveled from their starting point, as well as the maximum and minimum distances observed across multiple trials. Given the number of steps the student takes and the number of trials to simulate, what are the mean, maximum, and minimum distances from the origin?\n\nThe input and output requirements are as follows:\n\nInput:\n  `numSteps` (int): The number of steps the drunk student takes in each trial.\n  `numTrials` (int): The number of trials to simulate.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `mean_distance` (float): The average distance from the origin after `numSteps` steps across all trials.\n    - `max_distance` (float): The maximum distance from the origin observed in any trial.\n    - `min_distance` (float): The minimum distance from the origin observed in any trial.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Location(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def move(self, deltaX, deltaY):\n        return Location(self.x + deltaX, self.y + deltaY)\n\n    def getX(self):\n        return self.x\n\n    def getY(self):\n        return self.y\n\n    def distFrom(self, other):\n        ox = other.x\n        oy = other.y\n        xDist = self.x - ox\n        yDist = self.y - oy\n        return (xDist**2 + yDist**2)**0.5\n\n    def __str__(self):\n        return '<' + str(self.x) + \", \" + str(self.y) + \" >\"\n\n\nclass Field(object):\n    def __init__(self):\n        self.drunks = {}\n\n    def addDrunk(self, drunk, loc):\n        if drunk in self.drunks:\n            raise ValueError('Duplicate drunk')\n        else:\n            self.drunks[drunk] = loc\n\n    def moveDrunk(self, drunk):\n        if not drunk in self.drunks:\n            raise ValueError('Drunk not in field')\n        xDist, yDist = drunk.takeStep()\n        self.drunks[drunk] = self.drunks[drunk].move(xDist, yDist)\n\n    def getLoc(self, drunk):\n        if not drunk in self.drunks:\n            raise ValueError('Drunk not in field')\n        return self.drunks[drunk]\n\n\nclass Drunk(object):\n    def __init__(self, name):\n        self.name = name\n\n    def takeStep(self):\n        stepChoices = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        return random.choice(stepChoices)\n\n    def __str__(self):\n        return 'This drunk is named ' + self.name\n\n\n# main function\ndef main_solution(numSteps, numTrials):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    homer = Drunk('Homer')\n    origin = Location(0, 0)\n    distances = []\n    for t in range(numTrials):\n        f = Field()\n        f.addDrunk(homer, origin)\n        distances.append(walk(f, homer, numSteps))\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\n        \"mean_distance\": sum(distances) / len(distances),\n        \"max_distance\": max(distances),\n        \"min_distance\": min(distances)\n    }\n\ndef walk(f, d, numSteps):\n    start = f.getLoc(d)\n    for s in range(numSteps):\n        f.moveDrunk(d)\n    return start.distFrom(f.getLoc(d))", "input_generator": "import random\n\ndef input_generator():\n    numSteps = random.randint(10, 100)\n    numTrials = random.randint(5, 20)\n    return {\n        \"numSteps\": numSteps,\n        \"numTrials\": numTrials\n    }", "io_pairs": [{"input": {"numSteps": 95, "numTrials": 5}, "output": {"mean_distance": 9.159936878694353, "max_distance": 13.0, "min_distance": 4.123105625617661}}, {"input": {"numSteps": 24, "numTrials": 19}, "output": {"mean_distance": 4.127666761697334, "max_distance": 10.198039027185569, "min_distance": 1.4142135623730951}}, {"input": {"numSteps": 49, "numTrials": 16}, "output": {"mean_distance": 5.191042473494573, "max_distance": 14.317821063276353, "min_distance": 1.0}}, {"input": {"numSteps": 52, "numTrials": 10}, "output": {"mean_distance": 4.3329554001776645, "max_distance": 10.0, "min_distance": 2.0}}, {"input": {"numSteps": 22, "numTrials": 5}, "output": {"mean_distance": 2.850400391735147, "max_distance": 5.0990195135927845, "min_distance": 1.4142135623730951}}, {"input": {"numSteps": 70, "numTrials": 9}, "output": {"mean_distance": 6.500678467850567, "max_distance": 12.165525060596439, "min_distance": 2.0}}, {"input": {"numSteps": 74, "numTrials": 5}, "output": {"mean_distance": 7.84410597579109, "max_distance": 12.649110640673518, "min_distance": 3.1622776601683795}}, {"input": {"numSteps": 87, "numTrials": 11}, "output": {"mean_distance": 8.220418013379664, "max_distance": 16.0312195418814, "min_distance": 1.0}}, {"input": {"numSteps": 47, "numTrials": 9}, "output": {"mean_distance": 6.727275749881885, "max_distance": 11.180339887498949, "min_distance": 3.605551275463989}}, {"input": {"numSteps": 63, "numTrials": 17}, "output": {"mean_distance": 7.139460999310273, "max_distance": 13.0, "min_distance": 2.23606797749979}}], "error_log": []}
{"context": "Given a corpus of text files, how can we identify and analyze the collocates of a specific keyword within a defined window size? Specifically, what are the collocates, their raw frequencies, and their Mutual Information (MI) scores when the keyword \"example\" is searched within a window size of 30 in the \"data/texts\" folder?\n\nThe input and output requirements are as follows:\n\nInput:\n  `keyword` (str): The keyword to search for in the corpus. It should be a single word in lowercase.\n  `window_size` (int): The size of the window around the keyword to consider for collocation. It should be a positive integer.\n  `file_path` (str): The path to the folder containing the text files. It should be a string representing a folder name within the \"data\" directory.\n\nOutput:\n  `return` (list of dict): A list of dictionaries where each dictionary represents a collocate with the following keys:\n    - `collocate` (str): The collocate word.\n    - `raw_frequency` (int): The raw frequency of the collocate appearing within the window around the keyword.\n    - `MI` (float): The Mutual Information score for the collocate.", "reference_code": "# import necessary packages\nimport re\nimport pandas as pd\nimport numpy as np\nfrom pathlib import Path\n\n# all class and function definitions in the code file, if any\ndef freq(wordlist): \n    \"\"\"\n    Function to calculate word frequency from a list of words.\n    It returns the list of words together with frequencies.\n    \"\"\"\n    result = []\n    new_string = [] \n    \n    for word in wordlist:              \n        if word not in new_string: \n            new_string.append(word)  \n              \n    for i in range(0, len(new_string)): \n        result.append((new_string[i], wordlist.count(new_string[i])))\n\n    return result\n\ndef word_sorter(x):  \n    \"\"\"\n    Function to sort the word frequency pairs after frequency\n    Lowest frequency collocates first - highest frerquency collocates last\n    \"\"\"\n    lst = len(x)  \n\n    for i in range(0, lst):    \n        for j in range(0, lst-i-1):  \n            if (x[j][1] > x[j + 1][1]):  \n                temp = x[j]  \n                x[j]= x[j + 1]  \n                x[j + 1] = temp  \n    return x\n\ndef tokenize(library):\n    \"\"\"\n    Function that takes a string of text a tokenizes it.\n    The text is returned tokenized.\n    \"\"\"\n    library = library.lower()\n    tokenizer = re.compile(r\"\\W+\")\n    tokenized_library = tokenizer.split(library)\n\n    return tokenized_library\n\ndef text_in_windows(keyword, corpus, window_size):\n    \"\"\"\n    Function that takes a keyword, the corpus, and a window size and gathers all text \n    appearing within the windows around the keyword appearing in the corpus.\n    The function returns the window library.\n    \"\"\"\n    window_library = \"\"\n\n    for match in re.finditer(keyword, corpus):\n        word_start = match.start()\n        word_end = match.end()\n        \n        left_window_start = max(0, word_start-window_size)\n        left_window = corpus[left_window_start:word_start]\n        \n        right_window_end = word_end + window_size\n        right_window = corpus[word_end : right_window_end]\n\n        window_library = window_library + left_window + right_window\n    \n    return window_library\n\n# main function\ndef main_solution(keyword, window_size, file_path):\n    # Convert input variables if necessary\n    keyword = keyword.lower()\n    file_path = \"data/\" + file_path + \"/\"\n\n    # Collect all texts from the data folder in one long string called 'corpus'.\n    corpus = \"\"\n    for filename in Path(file_path).glob(\"*.txt\"):\n        with open(filename, \"r\", encoding=\"utf-8\") as file:\n            loaded_text = file.read()\n            corpus = corpus + loaded_text\n            \n    # Collect all text appearing within the windows of the keyword in the corpus.\n    window_library = text_in_windows(keyword, corpus, window_size)\n    \n    # Count frequency of each unique word in the window library and save the frequencies with the word in a list. \n    # The list is sorted by frequency\n    tokenized_library = tokenize(window_library)\n    word_freq_pairs = word_sorter(freq(tokenized_library)) \n\n    # Tokenize the corpus\n    tokenized_corpus = tokenize(corpus)\n\n    # Create pandas to store the results for each word \n    Columns = ['collocate', 'raw_frequency', 'MI']           \n    DATA = pd.DataFrame(columns=Columns)\n\n    # Gather all information about each word, calculate MI, and create a row per word in the DF\n    for word in word_freq_pairs:\n        collocate = word[0]\n        O11 = word[1]\n        R1 = tokenized_corpus.count(keyword)\n        O12 = R1 - O11\n        C1 = tokenized_corpus.count(collocate)\n        O21 = C1 - O11\n        N = len(tokenized_corpus)\n        \n        if not (C1 == 0):\n            E11 = (R1 * C1 / N)\n            if (E11 > 0):\n                MI = np.log(O11 / E11)\n\n                DATA = DATA.append({\n                    'collocate': collocate,\n                    'raw_frequency': O11,\n                    'MI': MI,\n                }, ignore_index=True) \n        \n    # Convert DataFrame to a list of dictionaries for JSON serializability\n    result = DATA.to_dict(orient='records')\n    return result", "input_generator": "import random\nimport string\nfrom pathlib import Path\n\ndef input_generator():\n    # Generate a random keyword (1-3 words)\n    keyword = ' '.join([''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 8))) for _ in range(random.randint(1, 3))])\n    \n    # Generate a random window size (1-20)\n    window_size = random.randint(1, 20)\n    \n    # Generate a random file path (simulating a folder in 'data/')\n    file_path = ''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 10)))\n    \n    # Ensure the 'data/' directory exists\n    Path(\"data\").mkdir(exist_ok=True)\n    \n    # Create a few random text files in the generated folder\n    folder_path = Path(\"data\") / file_path\n    folder_path.mkdir(exist_ok=True)\n    \n    for i in range(random.randint(1, 5)):\n        with open(folder_path / f\"text_{i}.txt\", \"w\") as f:\n            # Generate random text content (10-100 words)\n            words = [' '.join([''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 8))) for _ in range(random.randint(10, 100))])\n            f.write(' '.join(words))\n    \n    return {\n        'keyword': keyword,\n        'window_size': window_size,\n        'file_path': file_path\n    }", "io_pairs": [], "error_log": ["STDERR:   File \"<string>\", line 66\n    words = [' '.join([''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 8))) for _ in range(random.randint(10, 100))])\n            ^\nSyntaxError: '[' was never closed\n"]}
{"context": "Given an array of integers, can you determine if it is possible to sort the array by repeatedly rotating any triplet of consecutive elements? If it is possible, what is the result of such an operation?\n\nThe input and output requirements are as follows:\n\nInput:\n  `array` (list of integers): A list of integers representing the array that needs to be checked for being sortable by the described rearrangement method.\n\nOutput:\n  `return` (string): A string that is either \"YES\" if the array can be sorted by the described method, or \"NO\" if it cannot be sorted.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef larrysArray(A):         \n    def stat_val(A_val):\n        stat = []\n        for i in range(0,len(A_val)):\n            if A_val[i] == position_dict[A_val.index(A_val[i])]:\n                stat.append(\"Correct\")\n            else:\n                stat.append(\"rearrange\")\n        return stat\n           \n    def rearrange(combo,required_position):\n        combo[0],combo[1],combo[2] = combo[1],combo[2],combo[0]\n        if sorted(combo) == combo or combo[0] == position_dict[required_position] or combo[0] == min(combo):\n            return combo\n        else:\n            combo = rearrange(combo,required_position)\n            return combo\n    \n    def rearrange_call(A_val):  \n        stat = stat_val(A_val)    \n        for i in range(0,len(stat)-2):\n            if stat[i] == \"rearrange\":\n                required_position = i\n                combo = [A_val[i+x] for x in range(0,3)]\n                positions = [i+x for x in range(0,3)]\n                rearranged_combo = rearrange(combo,required_position)\n                for i,val in zip(positions,rearranged_combo):\n                    A_val[i] = val\n        return A_val\n\n    executed = 0\n    max_A = max(A)\n    position_dict = {}\n    for i in range(0,max_A+1):\n        position_dict[i] = i+1\n        \n    while(executed != len(A)):\n        A_val = A\n        A_val = rearrange_call(A_val)\n        executed += 1\n    if A == sorted(A):\n        return \"YES\"\n        \n    else:\n        return \"NO\"\n\n# main function\ndef main_solution(array):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = larrysArray(array)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(3, 10)  # Reasonable size for the array\n    array = list(range(1, n + 1))\n    if random.choice([True, False]):\n        # Generate a valid array that can be sorted with rotations\n        for _ in range(random.randint(1, 5)):\n            i = random.randint(0, n - 3)\n            array[i], array[i+1], array[i+2] = array[i+1], array[i+2], array[i]\n    else:\n        # Generate an invalid array\n        while array == sorted(array):\n            random.shuffle(array)\n    return {'array': array}", "io_pairs": [{"input": {"array": [1, 2, 3, 4, 6, 5]}, "output": "NO"}, {"input": {"array": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}, "output": "YES"}, {"input": {"array": [1, 2, 3, 4, 6, 5]}, "output": "NO"}, {"input": {"array": [1, 2, 3, 4, 5, 6, 7, 8, 9]}, "output": "YES"}, {"input": {"array": [1, 2, 3, 4, 5]}, "output": "YES"}, {"input": {"array": [1, 2, 3, 4]}, "output": "YES"}, {"input": {"array": [1, 2, 3, 4, 5, 6, 7, 9, 8]}, "output": "NO"}, {"input": {"array": [1, 2, 3, 4, 5, 6, 7, 9, 8]}, "output": "NO"}, {"input": {"array": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}, "output": "YES"}, {"input": {"array": [1, 2, 3, 5, 4]}, "output": "NO"}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, two computer players compete against each other. One player uses the 'X' symbol, and the other uses the 'O' symbol. The players can either be smart (using an advanced strategy) or random (choosing moves randomly). Given the types of players for 'X' and 'O', what will be the outcome of the game?\n\nThe input and output requirements are as follows:\n\nInput:\n  `player_types` (str): A string representing the types of players for 'X' and 'O'. The string should be in the format \"type1,type2\" where `type1` and `type2` can be either \"smart\" or \"random\". For example, \"smart,random\" means 'X' is a smart computer player and 'O' is a random computer player.\n\nOutput:\n  `return` (str): A string representing the result of the game. It can be either \"X\" if 'X' wins, \"O\" if 'O' wins, or \"Tie\" if the game ends in a tie.", "reference_code": "# import necessary packages\nimport random\nimport math\n\n# all class and function definitions in the code file, if any\nclass Player:\n    def __init__(self, letter):\n        self.letter = letter\n        \n    def get_move(self, game):\n        pass\n\nclass HumanPlayer(Player):\n    def __init__(self, letter):\n        super().__init__(letter)\n    \n    def get_move(self, game):\n        valid_pos = False\n        while not valid_pos:\n            position = input('Choose a spot 0 ~ 8:  ')\n            try:\n                position = int(position)\n                if not position in game.avaiable_moves():\n                    raise ValueError\n                valid_pos = True\n            except ValueError:\n                print(\"Type a number between 0 and 8 (inclusive).\")\n        return position\n    \nclass RandomComputer(Player):\n    def __init__(self, letter):\n        super().__init__(letter)\n        \n    def get_move(self, game):\n        position = random.choice(game.avaiable_moves())\n        return position\n    \nclass SmartComputerPlayer(Player):\n    def __init__(self, letter):\n        super().__init__(letter)\n    \n    def get_move(self, game):\n        if game.number_empty_spots() == 9:\n            spot = random.choice(game.avaiable_moves())\n        else:\n            spot = self.minimax(game, self.letter)['position']\n        return spot\n    \n    def minimax(self, state, player):\n        max_player = self.letter\n        other_player = 'O' if player == 'X' else 'X'\n        \n        if state.current_winner == other_player:\n            return {'position': None, 'score': 1 * (state.number_empty_spots() + 1) if other_player == max_player else -1 * (state.number_empty_spots() + 1)}\n        elif not state.empty_spots():\n            return {'position': None, 'score': 0}\n        \n        if player == max_player:\n            best = {'position': None, 'score': -math.inf}\n        else:\n            best = {'position': None, 'score': math.inf}\n        \n        for possible_move in state.avaiable_moves():\n            state.make_move(possible_move, player)\n            sim_score = self.minimax(state, other_player)\n            \n            state.board[possible_move] = ' '\n            state.current_winner = None\n            sim_score['position'] = possible_move\n            \n            if player == max_player:\n                if sim_score['score'] > best['score']:\n                    best = sim_score\n            else:\n                if sim_score['score'] < best['score']:\n                    best = sim_score\n        return best\n    \nclass TicTacToe:\n    def __init__(self):\n        self.board = [' ' for i in range(9)]\n        self.current_winner = None\n    \n    def avaiable_moves(self):\n        return [index for index, val in enumerate(self.board) if val == ' ']\n        \n    def empty_spots(self):\n        return ' ' in self.board \n       \n    def number_empty_spots(self):\n        return len(self.avaiable_moves())\n    \n    def make_move(self, pos, letter):\n        if self.board[pos] == ' ':\n            self.board[pos] = letter\n            if self.winner(pos, letter):\n                self.current_winner = letter\n            return True\n        return False\n    \n    def winner(self, spot, letter):\n        row_index = spot // 3\n        row = self.board[row_index * 3 : (row_index + 1) * 3]\n        if all([spot == letter for spot in row]):\n            return True\n        \n        col_index = spot % 3\n        column = [self.board[col_index + i * 3] for i in range(3)]\n        if all([spot == letter for spot in column]):\n            return True\n        \n        if spot % 2 == 0:\n            diagonal1 = [self.board[i] for i in [0, 4, 8]]\n            if all([spot == letter for spot in diagonal1]):\n                return True\n            diagonal2 = [self.board[i] for i in [2, 4, 6]]\n            if all([spot == letter for spot in diagonal2]):\n                return True\n        return False\n        \ndef play(game, x_player, o_player, print_game=True):\n    letter = 'X'\n    \n    while game.empty_spots():\n        if letter == 'O':\n            spot = o_player.get_move(game)\n        else:\n            spot = x_player.get_move(game)\n        \n        if game.make_move(spot, letter):\n            if game.current_winner:\n                return letter\n            letter = 'O' if letter == 'X' else 'X'\n    return 'Tie'\n\n# main function\ndef main_solution(player_types):\n    x_player_type, o_player_type = player_types.split(',')\n    x_player = SmartComputerPlayer('X') if x_player_type == 'smart' else RandomComputer('X')\n    o_player = SmartComputerPlayer('O') if o_player_type == 'smart' else RandomComputer('O')\n    t = TicTacToe()\n    result = play(t, x_player, o_player, print_game=False)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    player_options = ['smart', 'random']\n    x_player = random.choice(player_options)\n    o_player = random.choice(player_options)\n    return {'player_types': f\"{x_player},{o_player}\"}", "io_pairs": [{"input": {"player_types": "random,smart"}, "output": "O"}, {"input": {"player_types": "smart,smart"}, "output": "Tie"}, {"input": {"player_types": "smart,random"}, "output": "X"}, {"input": {"player_types": "random,random"}, "output": "X"}], "error_log": []}
{"context": "In a game of poker, how many cards are dealt to the players if there are `player_count` players participating?\n\nThe input and output requirements are as follows:\n\nInput:\n  `player_count` (int): The number of players in the game. This should be an integer between 1 and 52.\n\nOutput:\n  `return` (list of strings): A list of cards dealt to the players. Each card is represented as a string where the first character is the value (2-10, J, Q, K, A) and the second character is the suit (C, D, H, S).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Card:\n    def __init__(self, value, suit):\n        self.value = value     # 2-10, J, Q, K, A\n        self.suit = suit       # C(lubs), D(iamonds), H(earts), S(pades)\n\n    def getCard(self):\n        ''' returns value and suit of card object '''\n        return self.value + self.suit\n\nclass Deck:\n    def __init__(self):\n        self.thedeck = []\n        self.shuffled = False\n        self.makeDeck()\n        \n    def makeDeck(self):\n        \"\"\" creates 52 card objects and adds to thedeck list \"\"\"\n        values = []\n        for i in range(2, 11):\n            values.append(str(i))\n        values += ['J', 'Q', 'K', 'A']\n        suits = ['C', 'D', 'H', 'S']\n        for j in values:\n            for s in suits:\n                cardobj = Card(j, s)\n                card = cardobj.getCard()\n                self.thedeck.append(card)\n\n    def shuffleDeck(self):\n        ''' shuffles thedeck list '''\n        random.shuffle(self.thedeck)\n        self.shuffled = True\n\n    def removeCard(self, card):\n        ''' removes given card from deck '''\n        self.thedeck.remove(card)\n\n    def takeTopCard(self):\n        thecard = self.thedeck[0]\n        self.removeCard(thecard)\n        return thecard\n\n# main function\ndef main_solution(player_count):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    deck = Deck()\n    deck.shuffleDeck()\n    players = []\n    for _ in range(player_count):\n        players.append(deck.takeTopCard())\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return players", "input_generator": "import random\n\ndef input_generator():\n    return {'player_count': random.randint(1, 10)}", "io_pairs": [{"input": {"player_count": 9}, "output": ["QD", "4S", "KS", "AH", "JH", "5D", "8H", "3C", "3S"]}, {"input": {"player_count": 10}, "output": ["JH", "7D", "2S", "10D", "QC", "7H", "QD", "5S", "6D", "2D"]}, {"input": {"player_count": 8}, "output": ["2H", "8S", "AH", "4D", "JC", "6S", "3C", "5S"]}, {"input": {"player_count": 5}, "output": ["8D", "3C", "2H", "JS", "10C"]}, {"input": {"player_count": 2}, "output": ["8D", "10S"]}, {"input": {"player_count": 4}, "output": ["3D", "4C", "2D", "AC"]}, {"input": {"player_count": 6}, "output": ["10H", "2S", "QD", "JH", "JC", "6C"]}, {"input": {"player_count": 1}, "output": ["3C"]}, {"input": {"player_count": 3}, "output": ["4H", "8H", "KC"]}, {"input": {"player_count": 7}, "output": ["4D", "10H", "JD", "3D", "2C", "AC", "AH"]}], "error_log": []}
{"context": "Given two 2x2 matrices, what is the result of their matrix multiplication?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix1` (list of lists of floats): A 2D list representing the first matrix.\n  `matrix2` (list of lists of floats): A 2D list representing the second matrix.\n\nOutput:\n  `return` (list of lists of floats): A 2D list representing the result of the matrix multiplication of `matrix1` and `matrix2`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix1, matrix2):\n    # Convert JSON serializable inputs to numpy arrays\n    matrix1 = np.array(matrix1, dtype=float)\n    matrix2 = np.array(matrix2, dtype=float)\n    \n    # Perform matrix multiplication\n    result = np.dot(matrix1, matrix2)\n    \n    # Convert the result to a JSON serializable format\n    result = result.tolist()\n    \n    return result", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the dimensions of the matrices\n    m = random.randint(1, 5)\n    n = random.randint(1, 5)\n    p = random.randint(1, 5)\n    \n    # Generate random matrices with integers between -10 and 10\n    matrix1 = [[random.randint(-10, 10) for _ in range(n)] for _ in range(m)]\n    matrix2 = [[random.randint(-10, 10) for _ in range(p)] for _ in range(n)]\n    \n    return {'matrix1': matrix1, 'matrix2': matrix2}", "io_pairs": [{"input": {"matrix1": [[-1, -9]], "matrix2": [[-3], [-4]]}, "output": [[39.0]]}, {"input": {"matrix1": [[6], [0]], "matrix2": [[-8, -7, -3, -9]]}, "output": [[-48.0, -42.0, -18.0, -54.0], [0.0, 0.0, 0.0, 0.0]]}, {"input": {"matrix1": [[-10]], "matrix2": [[4, 8, -3, 7]]}, "output": [[-40.0, -80.0, 30.0, -70.0]]}, {"input": {"matrix1": [[5], [3]], "matrix2": [[3, -10, 8]]}, "output": [[15.0, -50.0, 40.0], [9.0, -30.0, 24.0]]}, {"input": {"matrix1": [[-7], [-10]], "matrix2": [[-8, -6]]}, "output": [[56.0, 42.0], [80.0, 60.0]]}, {"input": {"matrix1": [[-8, 0]], "matrix2": [[-6, 6], [4, -6]]}, "output": [[48.0, -48.0]]}, {"input": {"matrix1": [[-5], [-7]], "matrix2": [[3, -6, -1, -10, 7]]}, "output": [[-15.0, 30.0, 5.0, 50.0, -35.0], [-21.0, 42.0, 7.0, 70.0, -49.0]]}, {"input": {"matrix1": [[8]], "matrix2": [[-6, 0, -6, -3]]}, "output": [[-48.0, 0.0, -48.0, -24.0]]}, {"input": {"matrix1": [[-5]], "matrix2": [[1, -10, -5]]}, "output": [[-5.0, 50.0, 25.0]]}, {"input": {"matrix1": [[6]], "matrix2": [[-4, -8, 3]]}, "output": [[-24.0, -48.0, 18.0]]}], "error_log": []}
{"context": "Given a polynomial of degree 3, what are the roots of the polynomial when using Bairstow's method with initial guesses for the real and imaginary parts of the root, and a specified precision?\n\nThe input and output requirements are as follows:\n\nInput:\n  `coefficients` (list of float): The coefficients of the polynomial in descending order of degree.\n  `r` (float): Initial guess for the real part of the root.\n  `s` (float): Initial guess for the imaginary part of the root.\n  `precision` (int): The number of decimal places to which the roots should be calculated.\n\nOutput:\n  `return` (list of str): The roots of the polynomial in string format, where each root is represented as a complex number in the form \"a+bj\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef eval_polynomial(coefficients, x):\n    \"\"\"Evaluates a polynomial at a given value x.\"\"\"\n    result = 0\n    for i, coeff in enumerate(coefficients):\n        result += coeff * (x ** i)\n    return result\n\ndef deflate_polynomial(coefficients, root):\n    \"\"\"Deflates a polynomial by removing a known root.\"\"\"\n    n = len(coefficients)\n    new_coeffs = [0] * (n - 1)\n    for i in range(n - 1):\n        new_coeffs[i] = coefficients[i + 1] + root * new_coeffs[i - 1] if i > 0 else coefficients[i + 1]\n    return new_coeffs\n\ndef bairstow_method(coefficients, r, s, precision):\n    \"\"\"Implements the Bairstow's method to find roots of a polynomial.\"\"\"\n    # Simplified implementation for demonstration purposes\n    # In a real implementation, this would involve more complex calculations\n    roots = []\n    for _ in range(len(coefficients) - 1):\n        roots.append(complex(r, s))\n        coefficients = deflate_polynomial(coefficients, roots[-1])\n    return roots\n\n# main function\ndef main_solution(coefficients, r, s, precision):\n    # Convert input to appropriate types if necessary\n    coefficients = list(coefficients)\n    r = float(r)\n    s = float(s)\n    precision = int(precision)\n    \n    # Find roots using Bairstow's method\n    roots = bairstow_method(coefficients, r, s, precision)\n    \n    # Convert roots to JSON serializable format\n    roots = [str(root) for root in roots]\n    \n    return roots", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random degree for the polynomial (between 2 and 5)\n    degree = random.randint(2, 5)\n    \n    # Generate random coefficients for the polynomial\n    coefficients = [random.uniform(-10, 10) for _ in range(degree + 1)]\n    \n    # Generate random initial guesses r and s\n    r = random.uniform(-5, 5)\n    s = random.uniform(-5, 5)\n    \n    # Generate a random precision (between 1 and 10)\n    precision = random.randint(1, 10)\n    \n    return {\n        'coefficients': coefficients,\n        'r': r,\n        's': s,\n        'precision': precision\n    }", "io_pairs": [{"input": {"coefficients": [-5.8557967808387605, -2.140454342486513, -2.3850365060801852, -1.8912264800113938], "r": 0.5152845107008419, "s": 3.8613305223278402, "precision": 1}, "output": ["(0.5152845107008419+3.8613305223278402j)", "(0.5152845107008419+3.8613305223278402j)", "(0.5152845107008419+3.8613305223278402j)"]}, {"input": {"coefficients": [6.708763209094105, -4.824647677891949, 9.425411405818267, 6.929556152065516, 8.729969922787323], "r": 0.4292374067725113, "s": -3.768863998603784, "precision": 2}, "output": ["(0.4292374067725113-3.768863998603784j)", "(0.4292374067725113-3.768863998603784j)", "(0.4292374067725113-3.768863998603784j)", "(0.4292374067725113-3.768863998603784j)"]}, {"input": {"coefficients": [-2.9605507292528355, 5.686459991604984, 3.3554243598206064], "r": 3.424599123736316, "s": -3.573560825668647, "precision": 3}, "output": ["(3.424599123736316-3.573560825668647j)", "(3.424599123736316-3.573560825668647j)"]}, {"input": {"coefficients": [-2.4290968500180536, -4.2280988609585135, -5.398871924139836], "r": -2.1336704991731814, "s": 1.571953200814919, "precision": 4}, "output": ["(-2.1336704991731814+1.571953200814919j)", "(-2.1336704991731814+1.571953200814919j)"]}, {"input": {"coefficients": [6.622018742855477, -1.7189461340181005, -3.586999811060232], "r": -2.21311618446098, "s": -1.6922403270306052, "precision": 6}, "output": ["(-2.21311618446098-1.6922403270306052j)", "(-2.21311618446098-1.6922403270306052j)"]}, {"input": {"coefficients": [-1.2904774521644882, -1.9531035725624442, 0.3718640983050907, 9.49880536213007, -8.594273464462063], "r": 4.719087290242998, "s": -4.552133197968709, "precision": 2}, "output": ["(4.719087290242998-4.552133197968709j)", "(4.719087290242998-4.552133197968709j)", "(4.719087290242998-4.552133197968709j)", "(4.719087290242998-4.552133197968709j)"]}, {"input": {"coefficients": [3.2576566257880035, 8.77518571255061, -2.352540305669799], "r": -0.8261921322519203, "s": 2.2344826749814706, "precision": 10}, "output": ["(-0.8261921322519203+2.2344826749814706j)", "(-0.8261921322519203+2.2344826749814706j)"]}, {"input": {"coefficients": [-1.027659092384873, 4.259872298444428, 1.119371341607895, -1.1884564769840864, -6.345569130854216, 0.7576598512433641], "r": 3.3885650206857356, "s": 1.372908006737191, "precision": 6}, "output": ["(3.3885650206857356+1.372908006737191j)", "(3.3885650206857356+1.372908006737191j)", "(3.3885650206857356+1.372908006737191j)", "(3.3885650206857356+1.372908006737191j)", "(3.3885650206857356+1.372908006737191j)"]}, {"input": {"coefficients": [2.1993868191927657, -1.8451410169385873, 9.892301888535332, 8.99286463106835, -0.13676569266271343, -3.1392481935819383], "r": 1.861132142368696, "s": -2.439370793523916, "precision": 2}, "output": ["(1.861132142368696-2.439370793523916j)", "(1.861132142368696-2.439370793523916j)", "(1.861132142368696-2.439370793523916j)", "(1.861132142368696-2.439370793523916j)", "(1.861132142368696-2.439370793523916j)"]}, {"input": {"coefficients": [0.1456533930227284, -2.4318562561515655, -5.013514355790408, -6.37932413681048], "r": 0.5128984727814441, "s": -0.8112428169839472, "precision": 4}, "output": ["(0.5128984727814441-0.8112428169839472j)", "(0.5128984727814441-0.8112428169839472j)", "(0.5128984727814441-0.8112428169839472j)"]}], "error_log": []}
{"context": "Given a set of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city? Specifically, what is the optimal route and the total distance for the given distance matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `distance_matrix` (list of lists of floats): A 2D list representing the distance matrix between cities. Each element `distance_matrix[i][j]` represents the distance from city `i` to city `j`.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `route` (list of ints): The optimal route as a list of city indices (starting from 1).\n    - `distance` (float): The total distance of the optimal route.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Solver_Tsp_Brute():\n    def __init__(self, arr):\n        self.arr = arr\n        self.num = len(arr)\n        self.result = np.sum(arr)\n        self.route = []\n        self.total_set = set([i for i in range(self.num)])\n        \n    def _brute_force(self, last_visit=0, visited=[0], sum_dist=0):\n        unvisited = self.total_set - set(visited)\n        if not len(unvisited):\n            route = [i + 1 for i in visited]\n            result = sum_dist + self.arr[last_visit][0]\n            if result < self.result:\n                self.result = result\n                self.route = route\n        else:\n            for v in unvisited:\n                self._brute_force(v, visited + [v], sum_dist + self.arr[last_visit][v])\n\n    def tsp_brute_force(self):\n        self._brute_force()\n        return self.route, self.result\n\n# main function\ndef main_solution(distance_matrix):\n    # Convert the JSON serializable input to the original input variable\n    arr = np.array(distance_matrix)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solver_brute = Solver_Tsp_Brute(arr)\n    route, dist = solver_brute.tsp_brute_force()\n    \n    # Convert the output to JSON serializable\n    route_serializable = [int(r) for r in route]\n    dist_serializable = float(dist)\n    \n    return {\"route\": route_serializable, \"distance\": dist_serializable}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    num_cities = random.randint(3, 6)  # Reasonable size for brute-force TSP\n    distance_matrix = np.zeros((num_cities, num_cities), dtype=int)\n    \n    for i in range(num_cities):\n        for j in range(i + 1, num_cities):\n            distance = random.randint(1, 100)\n            distance_matrix[i][j] = distance\n            distance_matrix[j][i] = distance\n    \n    return {\"distance_matrix\": distance_matrix.tolist()}", "io_pairs": [{"input": {"distance_matrix": [[0, 83, 80], [83, 0, 51], [80, 51, 0]]}, "output": {"route": [1, 2, 3], "distance": 214.0}}, {"input": {"distance_matrix": [[0, 9, 97, 74], [9, 0, 70, 19], [97, 70, 0, 79], [74, 19, 79, 0]]}, "output": {"route": [1, 2, 4, 3], "distance": 204.0}}, {"input": {"distance_matrix": [[0, 38, 41], [38, 0, 92], [41, 92, 0]]}, "output": {"route": [1, 2, 3], "distance": 171.0}}, {"input": {"distance_matrix": [[0, 21, 39, 7], [21, 0, 30, 82], [39, 30, 0, 11], [7, 82, 11, 0]]}, "output": {"route": [1, 2, 3, 4], "distance": 69.0}}, {"input": {"distance_matrix": [[0, 95, 43, 45], [95, 0, 48, 48], [43, 48, 0, 52], [45, 48, 52, 0]]}, "output": {"route": [1, 3, 2, 4], "distance": 184.0}}, {"input": {"distance_matrix": [[0, 22, 2], [22, 0, 31], [2, 31, 0]]}, "output": {"route": [1, 2, 3], "distance": 55.0}}, {"input": {"distance_matrix": [[0, 81, 69], [81, 0, 9], [69, 9, 0]]}, "output": {"route": [1, 2, 3], "distance": 159.0}}, {"input": {"distance_matrix": [[0, 94, 65, 29], [94, 0, 39, 72], [65, 39, 0, 41], [29, 72, 41, 0]]}, "output": {"route": [1, 2, 3, 4], "distance": 203.0}}, {"input": {"distance_matrix": [[0, 38, 5, 17], [38, 0, 36, 5], [5, 36, 0, 85], [17, 5, 85, 0]]}, "output": {"route": [1, 3, 2, 4], "distance": 63.0}}, {"input": {"distance_matrix": [[0, 18, 26], [18, 0, 82], [26, 82, 0]]}, "output": {"route": [1, 2, 3], "distance": 126.0}}], "error_log": []}
{"context": "Given a cubic function \\( f(x) = x^3 - 2x - 5 \\), and a specified interval `[start1, start2]`, what is the approximate zero point of the function within this interval?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start1` (float): The starting point of the interval for the function `f(x)`.\n  `start2` (float): The ending point of the interval for the function `f(x)`.\n\nOutput:\n  `return` (float): The approximate zero point of the function `f(x)` within the interval `[start1, start2]`, rounded to 5 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef f(x):\n    return (x**3) - 2 * x - 5\n\ndef intersection(function, start1, start2):\n    x_n = start1\n    x_n1 = start2\n    while True:\n        x_n2 = x_n1 - (function(x_n1) /\n                       ((function(x_n1) - function(x_n)) / (x_n1 - x_n)))  # \u9012\u5f52\u5f0f\n        if abs(x_n2 - x_n1) < 10**-5:\n            return x_n2\n        x_n = x_n1\n        x_n1 = x_n2\n\n# main function\ndef main_solution(start1, start2):\n    # Convert JSON serializable inputs to the original input variables\n    start1 = float(start1)\n    start2 = float(start2)\n    \n    # Call the original function with the converted inputs\n    result = intersection(f, start1, start2)\n    \n    # Convert the result to a JSON serializable output\n    return round(result, 5)", "input_generator": "import random\n\ndef input_generator():\n    # Generate random start points around the expected root (around 2)\n    # Using a normal distribution centered near 2 with some variance\n    start1 = random.uniform(0.5, 3.0)\n    start2 = random.uniform(0.5, 3.0)\n    # Ensure start1 and start2 are different\n    while abs(start1 - start2) < 0.1:\n        start2 = random.uniform(0.5, 3.0)\n    return {\n        'start1': start1,\n        'start2': start2\n    }", "io_pairs": [{"input": {"start1": 2.9830050455000237, "start2": 1.8219541644707657}, "output": 2.09455}, {"input": {"start1": 2.607150003083826, "start2": 1.3850721715646777}, "output": 2.09455}, {"input": {"start1": 1.2838839827006145, "start2": 2.1486025027676305}, "output": 2.09455}, {"input": {"start1": 1.9525762361534063, "start2": 1.7192075255373505}, "output": 2.09455}, {"input": {"start1": 1.6783810254836058, "start2": 2.6730000773623708}, "output": 2.09455}, {"input": {"start1": 0.5756296650246815, "start2": 1.6331735016594082}, "output": 2.09455}, {"input": {"start1": 2.0663625801421115, "start2": 1.6214332275627483}, "output": 2.09455}, {"input": {"start1": 1.7022698203890392, "start2": 1.2552309891339313}, "output": 2.09455}, {"input": {"start1": 1.9588126309406273, "start2": 2.308795525956242}, "output": 2.09455}, {"input": {"start1": 0.7121239796246555, "start2": 2.6579611195310737}, "output": 2.09455}], "error_log": []}
{"context": "Given a set of data points in a 2D plane, how can we estimate the value of a Gaussian function fitted to these points at the origin (0, 0)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `xs` (list of floats): List of x-coordinates of the data points.\n  `ys` (list of floats): List of y-coordinates of the data points.\n\nOutput:\n  `return` (float): The value of the fitted Gaussian function evaluated at the point (0, 0).", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy import optimize\n\n# all class and function definitions in the code file, if any\ndef gaussian(height, center_x, center_y, width_x, width_y):\n    \"\"\"Returns a gaussian function with the given parameters\"\"\"\n    width_x = float(width_x)\n    width_y = float(width_y)\n    return lambda x,y: height*np.exp(\n                -(((center_x-x)/width_x)**2+((center_y-y)/width_y)**2)/2)\n\ndef moments(xs, ys):\n    x = np.mean(xs)\n    y = np.mean(ys)\n    width_x = np.std(xs)\n    width_y = np.std(ys)\n    height = 1\n    return (height, x, y, width_x, width_y)\n\ndef fitGaussian(xs, ys):\n    return gaussian(*moments(xs, ys))\n\n# main function\ndef main_solution(xs, ys):\n    # Convert input lists to numpy arrays\n    xs = np.array(xs)\n    ys = np.array(ys)\n    \n    # Fit a Gaussian function to the data\n    gaussian_func = fitGaussian(xs, ys)\n    \n    # Evaluate the Gaussian function at a specific point (0, 0)\n    result = gaussian_func(0, 0)\n    \n    # Return the result as a float\n    return float(result)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate random number of points (between 10 and 100)\n    n = random.randint(10, 100)\n    \n    # Generate random center and width for the Gaussian\n    center_x = random.uniform(-5, 5)\n    center_y = random.uniform(-5, 5)\n    width_x = random.uniform(0.5, 3)\n    width_y = random.uniform(0.5, 3)\n    \n    # Generate xs and ys with some Gaussian noise\n    xs = np.random.normal(center_x, width_x, n)\n    ys = np.random.normal(center_y, width_y, n)\n    \n    # Convert to lists for compatibility\n    xs = xs.tolist()\n    ys = ys.tolist()\n    \n    return {'xs': xs, 'ys': ys}", "io_pairs": [], "error_log": []}
{"context": "In a strategic game, a player navigates a board populated with robots. The player can either move or attack in a specified direction. Given the dimensions of the board, the number of robots, and the player's action, what is the current state of the game? Specifically, determine if the game is still ongoing, if the player has won with a certain number of points, or if the player has lost.\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_size_x` (int): The horizontal size of the game board.\n  `board_size_y` (int): The vertical size of the game board.\n  `num_bots` (int): The number of non-player robots (NPCs) to be added to the board.\n  `player_action` (dict): A dictionary representing the player's action. It contains two keys:\n    - `movement` (bool): True if the player is moving, False if the player is attacking.\n    - `direction` (int): The direction of the action (0 for up, 1 for right, 2 for down, 3 for left).\n\nOutput:\n  `return` (int): The result of the game state check:\n    - 0 if the game is still ongoing.\n    - A positive integer if the player has won with that many points.\n    - -1 if the player has lost.", "reference_code": "# import necessary packages\nimport random\nimport math\n\n# custom class to store all the info for the robots\nclass Robot:\n    def __init__(self):\n        self.x = 1\n        self.y = 1\n        self.isPlayer = False\n        self.alive = True\n        self.damaged = False\n        self.hasMoved = False\n        self.direction = 0\n        self.points = 0\n\n    # set the position\n    def SetPos(self, x, y):\n        self.x = x\n        self.y = y\n\n    # get the position\n    def GetPos(self):\n        return (self.x, self.y)\n\n    # Damages the bot, returns 0 for already dead, 1 for damaged, 2 for killed\n    def Damage(self):\n        if not self.alive:\n            return 0\n        if self.damaged:\n            self.alive = False\n            return 2\n        else:\n            self.damaged = True\n            return 1\n\n# custom class to store the tiles               \nclass Tile:\n    def __init__(self):\n        self.x = 0\n        self.y = 0\n        self.hasRobot = False\n        self.robot = None\n\n    # check if there is a bot on this tile\n    def CheckAvailability(self):\n        return not self.hasRobot\n\n    # attempts to attack the tile, if there is a bot it deals damage and returns reward points:\n    # 0 if already dead or no bot\n    # 1 for hit\n    # 2 for kill\n    def AttackBot(self):\n        if self.hasRobot:\n            points = self.robot.Damage()\n            if points == 0:\n                self.robot = None\n                self.hasRobot = False\n                return 0\n            return points\n        else:\n            return 0\n\n# custom class for the gameboard\nclass Board:\n    def __init__(self, sizeX, sizeY):\n        self.sizeX = sizeX\n        self.sizeY = sizeY\n        self.player = Robot()\n        self.bots = []\n        self.tiles = [[Tile() for y in range(self.sizeY)] for x in range(self.sizeX)]\n        for y in range(self.sizeY):\n            for x in range(self.sizeX):\n                self.tiles[x][y].x = x\n                self.tiles[x][y].y = y\n\n    # adds a player at a random position\n    def AddPlayer(self):\n        randX = random.randint(0, self.sizeX - 1)\n        randY = random.randint(0, self.sizeY - 1)\n        self.tiles[randX][randY].hasRobot = True\n        self.player = Robot()\n        self.tiles[randX][randY].robot = self.player\n        self.player.SetPos(randX, randY)\n        self.player.isPlayer = True\n        self.bots.append(self.player)\n\n    # add a number of NPC's on the field\n    def AddBots(self, amount):\n        availableTiles = [tile for column in self.tiles for tile in column if not tile.hasRobot]\n        botTiles = random.sample(availableTiles, amount)\n        for tile in botTiles:\n            newBot = Robot()\n            newBot.SetPos(tile.x, tile.y)\n            tile.hasRobot = True\n            tile.robot = newBot\n            self.bots.append(newBot)\n\n    # updates the board according to the player action\n    def UpdateBoard(self, playerAction):\n        canMove = True\n        targetPosX = self.player.x\n        targetPosY = self.player.y\n        if playerAction['movement']:\n            self.player.direction = playerAction['direction']\n\n        if self.player.direction == 0:\n            if self.player.y <= 0:\n                canMove = False\n            else:\n                targetPosY -= 1\n        elif self.player.direction == 1:\n            if self.player.x >= self.sizeX - 1:\n                canMove = False\n            else:\n                targetPosX += 1\n        elif self.player.direction == 2:\n            if self.player.y >= self.sizeY - 1:\n                canMove = False\n            else:\n                targetPosY += 1\n        elif self.player.direction == 3:\n            if self.player.x <= 0:\n                canMove = False\n            else:\n                targetPosX -= 1\n\n        if playerAction['movement'] and canMove:\n            if self.tiles[targetPosX][targetPosY].CheckAvailability():\n                self.tiles[self.player.x][self.player.y].hasRobot = False\n                self.player.SetPos(targetPosX, targetPosY)\n                self.tiles[self.player.x][self.player.y].hasRobot = True\n                self.tiles[self.player.x][self.player.y].robot = self.player\n\n        if not playerAction['movement']:\n            self.player.points += self.tiles[targetPosX][targetPosY].AttackBot()\n\n        for bot in self.bots:\n            if not bot.isPlayer and bot.alive:\n                self.NPCMoveAction(bot)\n\n        for bot in self.bots:\n            if not bot.isPlayer and bot.alive and not bot.hasMoved:\n                targetPosX = bot.x\n                targetPosY = bot.y\n                if bot.direction == 0:\n                    targetPosY -= 1\n                elif bot.direction == 1:\n                    targetPosX += 1\n                elif bot.direction == 2:\n                    targetPosY += 1\n                elif bot.direction == 3:\n                    targetPosX -= 1\n                bot.points += self.tiles[targetPosX][targetPosY].AttackBot()\n\n    # set the NPC's next move, either moving, or attacking\n    def NPCMoveAction(self, NPC):\n        closestPlayer = None\n        distance = math.inf\n        NPC.hasMoved = False\n        for bot in self.bots:\n            if bot != NPC and bot.alive:\n                newDist = abs(NPC.x - bot.x) + abs(NPC.y - bot.y)\n                if newDist < distance:\n                    distance = newDist\n                    closestPlayer = bot\n\n        distX = closestPlayer.x - NPC.x\n        distY = closestPlayer.y - NPC.y\n        targetPosX = NPC.x\n        targetPosY = NPC.y\n\n        freeSpot = False\n        direction = NPC.direction\n        if abs(distX) > abs(distY):\n            if distX > 0:\n                targetPosX += 1\n                direction = 1\n            else:\n                targetPosX -= 1\n                direction = 3\n            if self.tiles[targetPosX][targetPosY].CheckAvailability():\n                freeSpot = True\n        else:\n            if distY > 0:\n                targetPosY += 1\n                direction = 2\n            else:\n                targetPosY -= 1\n                direction = 0\n            if self.tiles[targetPosX][targetPosY].CheckAvailability():\n                freeSpot = True\n\n        if not freeSpot:\n            if direction != NPC.direction:\n                NPC.direction = direction\n                NPC.hasMoved = True\n        else:\n            NPC.direction = direction\n            self.tiles[NPC.x][NPC.y].hasRobot = False\n            NPC.SetPos(targetPosX, targetPosY)\n            self.tiles[NPC.x][NPC.y].hasRobot = True\n            self.tiles[NPC.x][NPC.y].robot = NPC\n            NPC.hasMoved = True\n\n    # check if the game is won, lost or still playing returns: \n    #  0 if still playing \n    #  x if player has won with x amount of points\n    # -1 if player has lost\n    def CheckWinState(self):\n        winState = self.player.points\n        if not self.player.alive:\n            winState = -1\n        else:\n            for bot in self.bots:\n                if bot.alive and not bot.isPlayer:\n                    winState = 0\n        return winState\n\n# main function\ndef main_solution(board_size_x, board_size_y, num_bots, player_action):\n    board = Board(board_size_x, board_size_y)\n    board.AddPlayer()\n    board.AddBots(num_bots)\n    board.UpdateBoard(player_action)\n    return board.CheckWinState()", "input_generator": "import random\n\ndef input_generator():\n    board_size_x = random.randint(5, 15)\n    board_size_y = random.randint(5, 15)\n    num_bots = random.randint(1, min(board_size_x * board_size_y - 1, 10))\n    \n    movement = random.choice([True, False])\n    direction = random.randint(0, 3)\n    \n    player_action = {\n        'movement': movement,\n        'direction': direction\n    }\n    \n    return {\n        'board_size_x': board_size_x,\n        'board_size_y': board_size_y,\n        'num_bots': num_bots,\n        'player_action': player_action\n    }", "io_pairs": [{"input": {"board_size_x": 8, "board_size_y": 6, "num_bots": 2, "player_action": {"movement": true, "direction": 1}}, "output": 0}, {"input": {"board_size_x": 13, "board_size_y": 10, "num_bots": 5, "player_action": {"movement": false, "direction": 0}}, "output": 0}, {"input": {"board_size_x": 13, "board_size_y": 13, "num_bots": 3, "player_action": {"movement": false, "direction": 3}}, "output": 0}, {"input": {"board_size_x": 11, "board_size_y": 13, "num_bots": 7, "player_action": {"movement": false, "direction": 2}}, "output": 0}, {"input": {"board_size_x": 7, "board_size_y": 13, "num_bots": 7, "player_action": {"movement": false, "direction": 1}}, "output": 0}, {"input": {"board_size_x": 15, "board_size_y": 7, "num_bots": 4, "player_action": {"movement": true, "direction": 1}}, "output": 0}, {"input": {"board_size_x": 12, "board_size_y": 15, "num_bots": 6, "player_action": {"movement": true, "direction": 3}}, "output": 0}, {"input": {"board_size_x": 5, "board_size_y": 9, "num_bots": 8, "player_action": {"movement": false, "direction": 3}}, "output": 0}, {"input": {"board_size_x": 5, "board_size_y": 11, "num_bots": 7, "player_action": {"movement": false, "direction": 2}}, "output": 0}, {"input": {"board_size_x": 15, "board_size_y": 5, "num_bots": 7, "player_action": {"movement": true, "direction": 3}}, "output": 0}], "error_log": []}
{"context": "Given a range of natural numbers from 1 to `n`, what is the difference between the sum of the squares of these numbers and the square of their sum?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The upper limit of the range of natural numbers (inclusive) for which the sum of squares and the square of the sum are to be calculated.\n\nOutput:\n  `return` (float): The difference between the sum of the squares of the first `n` natural numbers and the square of their sum.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef sum_squares(n):\n    return ((n*(n+1)*(2*n+1))/6)\n\ndef square_sum(n):\n    return (n*(n+1)/2)**2\n\ndef diff_square_sum_and_sum_squares(n):\n    return square_sum(n) - sum_squares(n)\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = diff_square_sum_and_sum_squares(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1, 1000)\n    return {'n': n}", "io_pairs": [{"input": {"n": 926}, "output": 183948395250.0}, {"input": {"n": 571}, "output": 26606630050.0}, {"input": {"n": 288}, "output": 1723887312.0}, {"input": {"n": 573}, "output": 26981256302.0}, {"input": {"n": 675}, "output": 51949678950.0}, {"input": {"n": 66}, "output": 4790500.0}, {"input": {"n": 277}, "output": 1475357954.0}, {"input": {"n": 946}, "output": 200359536300.0}, {"input": {"n": 481}, "output": 13400467600.0}, {"input": {"n": 253}, "output": 1026971022.0}], "error_log": []}
{"context": "Given a set of trajectory points representing the path of a projectile fired from a cannon, and a target position with a known expected height, determine whether the projectile will hit the target within an acceptable height range. Specifically, calculate the height of the cannon at the firing point and compare it with the expected height of the target. If the discrepancy in height is within 0.5 units, the target is considered hit. What is the height of the cannon at the firing point, and will the projectile hit the target?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x_array` (list of float): List of x-coordinates representing the positions of the trajectory points.\n  `h_array` (list of float): List of h-coordinates representing the heights of the trajectory points corresponding to `x_array`.\n  `x_target` (float): The x-coordinate of the target position.\n  `h_target` (float): The expected height of the target at `x_target`.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `h_zero` (float): The height of the cannon at x=0, rounded to 2 decimal places.\n    - `result` (str): A string indicating whether the target is within the acceptable height range (\"yes\" or \"no\").", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(x_array, h_array, x_target, h_target):\n    # Convert JSON serializable inputs to numpy arrays\n    x_array = np.array(x_array, dtype=float)\n    h_array = np.array(h_array, dtype=float)\n    \n    # Find the coefficients for the quadratic function\n    a = np.polyfit(x_array, h_array, 2)\n    \n    # Calculate the trend function\n    def get_trend(x, a):\n        return a[0] * x**2 + a[1] * x + a[2]\n    \n    # Calculate the height of the cannon and the target\n    h_zero = get_trend(0, a)\n    h_target_get = get_trend(x_target, a)\n    \n    # Calculate the discrepancy in height\n    delta_h = abs(h_target - h_target_get)\n    \n    # Determine if the target is within the acceptable range\n    result = \"yes\" if delta_h <= 0.5 else \"no\"\n    \n    # Return the results as JSON serializable outputs\n    return {\n        \"h_zero\": round(h_zero, 2),\n        \"result\": result\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate random x_array with 3 to 10 points\n    num_points = random.randint(3, 10)\n    x_array = sorted(np.random.uniform(-10, 10, num_points).tolist())\n    \n    # Generate corresponding h_array with some quadratic trend + noise\n    a = np.random.uniform(-1, 1)\n    b = np.random.uniform(-5, 5)\n    c = np.random.uniform(0, 20)\n    h_array = [a*x**2 + b*x + c + np.random.normal(0, 1) for x in x_array]\n    h_array = [round(h, 2) for h in h_array]\n    \n    # Generate x_target within a reasonable range\n    x_target = random.uniform(min(x_array), max(x_array))\n    \n    # Generate h_target with some relation to the trend\n    h_target_trend = a*x_target**2 + b*x_target + c\n    h_target = h_target_trend + random.uniform(-1, 1)\n    h_target = round(h_target, 2)\n    \n    return {\n        \"x_array\": x_array,\n        \"h_array\": h_array,\n        \"x_target\": round(x_target, 2),\n        \"h_target\": h_target\n    }", "io_pairs": [{"input": {"x_array": [-8.456208999820662, 5.68194588665526, 9.75000503452242], "h_array": [26.85, 14.67, 12.72], "x_target": -8.23, "h_target": 27.07}, "output": {"h_zero": 18.56, "result": "yes"}}, {"input": {"x_array": [-3.6877496605869116, -1.133742379220596, -0.13789619882947513, 3.483356521922893, 4.727624235183168, 5.341659338005037], "h_array": [15.84, 15.32, 15.49, -6.26, -21.81, -26.41], "x_target": 4.6, "h_target": -19.38}, "output": {"h_zero": 14.11, "result": "no"}}, {"input": {"x_array": [-6.592310581901724, -6.104935528106674, -5.40535333884961, -4.66850850826801, -4.381739341608741, -0.3680364952338806], "h_array": [23.95, 22.27, 16.2, 15.27, 11.25, 1.3], "x_target": -4.1, "h_target": 11.36}, "output": {"h_zero": 0.98, "result": "yes"}}, {"input": {"x_array": [-3.3296670262345174, -2.6863548098936407, -1.65554375323633, 0.5217230618779496, 0.7375219651814966, 3.175171125464553], "h_array": [-7.52, -1.3, 1.98, 7.76, 8.18, 0.76], "x_target": -2.44, "h_target": -0.32}, "output": {"h_zero": 7.51, "result": "no"}}, {"input": {"x_array": [-3.793853233074211, -0.25126149883648985, 0.9227937947487241, 1.5378196420686248, 1.6566538792371297], "h_array": [-4.02, 6.09, 5.11, 4.39, 5.49], "x_target": -0.59, "h_target": 5.56}, "output": {"h_zero": 5.88, "result": "yes"}}, {"input": {"x_array": [1.5192021583684117, 2.853097396976679, 3.2339762500777365, 4.590124132338394, 9.97768955684112], "h_array": [22.08, 31.1, 31.8, 39.57, 98.1], "x_target": 6.87, "h_target": 61.28}, "output": {"h_zero": 18.21, "result": "yes"}}, {"input": {"x_array": [-5.83565671886404, -3.4239620609840005, -3.130238703093749], "h_array": [15.84, 15.84, 15.95], "x_target": -4.05, "h_target": 15.07}, "output": {"h_zero": 18.61, "result": "no"}}, {"input": {"x_array": [-6.6546239707109205, -4.872323067402748, 1.9093908121771541, 9.561325881061983], "h_array": [-61.33, -36.23, 3.79, -38.14], "x_target": 7.68, "h_target": -19.61}, "output": {"h_zero": 0.05, "result": "no"}}, {"input": {"x_array": [-7.930625627757659, -6.393213102102053, 7.184145709405385], "h_array": [56.43, 48.77, -8.46], "x_target": 5.15, "h_target": -3.17}, "output": {"h_zero": 19.49, "result": "no"}}, {"input": {"x_array": [-2.589254133403715, -2.465609948285583, 8.865447936548644], "h_array": [10.03, 10.4, -27.51], "x_target": -2.38, "h_target": 10.39}, "output": {"h_zero": 14.25, "result": "yes"}}], "error_log": []}
{"context": "Given a linear congruence equation of the form Ax + B \u2261 C (mod D), where A, B, C, and D are integers, what are the possible values of x that satisfy the equation?\n\nThe input and output requirements are as follows:\n\nInput:\n  `A` (int): Coefficient of x in the equation Ax + B \u2261 C (mod D).\n  `B` (int): Constant term in the equation Ax + B \u2261 C (mod D).\n  `C` (int): Result of the congruence in the equation Ax + B \u2261 C (mod D).\n  `D` (int): Modulus in the equation Ax + B \u2261 C (mod D).\n\nOutput:\n  `return` (dict): A dictionary with a single key \"solution\". The value can be either \"No Solution\" (string) if no solution exists, or a list of integers representing the solutions to the congruence equation.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef extended_gcd(a, b):\n    r1 = a\n    r2 = b\n    s1 = 1\n    s2 = 0\n    t1 = 0\n    t2 = 1\n    while r2 > 0:\n        q = r1 // r2\n\n        r = r1 - q * r2\n        r1 = r2\n        r2 = r\n\n        s = s1 - q * s2\n        s1 = s2\n        s2 = s\n\n        t = t1 - q * t2\n        t1 = t2\n        t2 = t\n    return [r1, s1, t1]\n\ndef mul_inverse(n, b):\n    if gcd(n, b) == 1:\n        return extended_gcd(n, b)[2] % n\n    else:\n        return -1\n\n# main function\ndef main_solution(A, B, C, D):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    C = (C - B) % D\n\n    temp = gcd(D, A)\n    if (C / temp != C // temp):\n        return {\"solution\": \"No Solution\"}\n    else:\n        gcd_ab = gcd(A, C)\n        gcd_abc = gcd(gcd_ab, D)\n        A /= gcd_abc\n        C /= gcd_abc\n        D /= gcd_abc\n        sol = set()\n        x0 = C * mul_inverse(D, A) % D\n        for i in range(temp):\n            sol.add(int(x0 + (i * D * gcd_abc / temp)))\n        return {\"solution\": list(sol)}", "input_generator": "import random\n\ndef input_generator():\n    A = random.randint(1, 1000)\n    B = random.randint(0, 1000)\n    D = random.randint(1, 1000)\n    C = random.randint(0, 1000)\n    return {\"A\": A, \"B\": B, \"C\": C, \"D\": D}", "io_pairs": [{"input": {"A": 671, "B": 161, "C": 608, "D": 76}, "output": {"solution": [65]}}, {"input": {"A": 93, "B": 95, "C": 936, "D": 249}, "output": {"solution": "No Solution"}}, {"input": {"A": 264, "B": 258, "C": 183, "D": 957}, "output": {"solution": "No Solution"}}, {"input": {"A": 286, "B": 978, "C": 101, "D": 66}, "output": {"solution": "No Solution"}}, {"input": {"A": 41, "B": 754, "C": 205, "D": 725}, "output": {"solution": [411]}}, {"input": {"A": 49, "B": 839, "C": 795, "D": 64}, "output": {"solution": [20]}}, {"input": {"A": 921, "B": 768, "C": 906, "D": 503}, "output": {"solution": [241]}}, {"input": {"A": 683, "B": 845, "C": 616, "D": 286}, "output": {"solution": [101]}}, {"input": {"A": 888, "B": 619, "C": 499, "D": 444}, "output": {"solution": "No Solution"}}, {"input": {"A": 673, "B": 595, "C": 479, "D": 17}, "output": {"solution": [2]}}], "error_log": []}
{"context": "Given two positive integers `a` and `n`, what is the modular multiplicative inverse of `a` modulo `n`? If `a` and `n` are not co-prime, what should be returned?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): A positive integer for which the modular multiplicative inverse needs to be computed.\n  `n` (int): A positive integer representing the modulus.\n\nOutput:\n  `return` (int or None): The modular multiplicative inverse of `a` modulo `n` if `a` and `n` are co-prime. Returns `None` if `a` and `n` are not co-prime.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef gcd_ext(a, b):\n    \"\"\"Extended GCD\"\"\"\n    if b == 0:\n        return 1, 0, a\n    else:\n        x, y, gcd = gcd_ext(b, a % b)\n        return y, x - y * (a // b), gcd\n\ndef inverseMod(a, n):\n    \"\"\"Computes modular multiplicative inverse\"\"\"\n    x, _, gcd = gcd_ext(a, n)\n    if gcd == 1:\n        return x % n\n    else:\n        return None\n\n# main function\ndef main_solution(a, n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = inverseMod(a, n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random modulus n, ensuring it's greater than 1\n    n = random.randint(2, 1000)\n    # Generate a random number a, ensuring it's coprime with n\n    while True:\n        a = random.randint(1, n - 1)\n        if gcd_ext(a, n)[2] == 1:\n            break\n    return {'a': a, 'n': n}", "io_pairs": [{"input": {"a": 603, "n": 764}, "output": 503}, {"input": {"a": 412, "n": 717}, "output": 583}, {"input": {"a": 254, "n": 993}, "output": 950}, {"input": {"a": 223, "n": 706}, "output": 19}, {"input": {"a": 352, "n": 481}, "output": 261}, {"input": {"a": 132, "n": 203}, "output": 20}, {"input": {"a": 263, "n": 637}, "output": 373}, {"input": {"a": 419, "n": 581}, "output": 104}, {"input": {"a": 145, "n": 278}, "output": 255}, {"input": {"a": 31, "n": 347}, "output": 56}], "error_log": []}
{"context": "In a kingdom represented by a board, each tile on the board has a type and a number of crowns. The score of the kingdom is calculated by multiplying the number of same tiles in an area by the number of crowns in that area. Given a board configuration, what is the total score of the kingdom?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of strings): A list of strings where each string represents a row of the board. Each string contains tiles separated by a space. Each tile consists of a letter (representing the type of tile) and a number (representing the number of crowns on that tile).\n\nOutput:\n  `return` (int): The total score calculated based on the formula: number of same tiles in an area * number of crowns in that area.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef isValid(graph, row, col):\n    if(row >= 0 and row < len(graph)):\n        if(col >= 0 and col < len(graph[0])):\n            return True\n    return False\n\ndef findIsland(graph, row, col, letter, count):\n    graph[row][col] = 'x'\n    neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    for neighbor in neighbors:\n        nr = neighbor[0] + row\n        nc = neighbor[1] + col\n        if(isValid(graph, nr, nc) and graph[nr][nc][0] == letter):\n            #islands\n            count[0] = count[0] + 1\n            #crowns\n            count[1] = count[1] + int(graph[nr][nc][1])\n            findIsland(graph, nr, nc, letter, count)\n            \n\ndef islands(graph):\n    total = 0\n    for row in range(len(graph)):\n        for col in range(len(graph[0])):\n            if(graph[row][col] != 'x'):\n                count = [1, int(graph[row][col][1])]\n                letter = graph[row][col][0]\n                findIsland(graph, row, col, letter, count)\n                total = total + (count[0] * count[1])\n    return total\n\ndef convertGraph(graph):\n    new_graph = []\n    for line in graph:\n        new_graph.append(line.split(\" \"))\n    return new_graph\n\n# main function\ndef main_solution(board):\n    # Convert the board to the required format\n    graph = convertGraph(board)\n    # Calculate the total score\n    total_score = islands(graph)\n    # Return the total score\n    return total_score", "input_generator": "import random\n\ndef input_generator():\n    letters = ['A', 'B', 'C', 'D', 'E']\n    rows = random.randint(3, 8)\n    cols = random.randint(3, 8)\n    board = []\n    for _ in range(rows):\n        row = []\n        for _ in range(cols):\n            letter = random.choice(letters)\n            crown = random.randint(0, 3)\n            row.append(f\"{letter}{crown}\")\n        board.append(\" \".join(row))\n    return {'board': board}", "io_pairs": [{"input": {"board": ["C3 C1 C0", "D0 D1 C0", "E0 E1 E0", "C0 B3 D0", "C2 B0 D1", "E1 A2 E2", "A0 D2 B3", "A0 D2 A2"]}, "output": 51}, {"input": {"board": ["C0 C2 C3 D2 B3 B0", "B0 B2 E2 B2 C1 D0", "A2 D2 B1 A3 D0 E2"]}, "output": 42}, {"input": {"board": ["A1 A3 D3 C3 B2", "A3 E1 D2 B0 A3", "A3 A3 C1 A1 E2", "E1 B2 D3 C2 E0", "E1 E1 D2 D2 C2"]}, "output": 126}, {"input": {"board": ["B3 C1 B1 D0 E2 C3 D2 A3", "A0 B2 A2 B0 B0 E2 D1 C1", "C0 E3 E3 E0 C1 C1 B3 B3", "E3 A1 E2 C0 C3 D2 A1 B0", "A3 C3 E2 B0 D1 E3 E3 A1", "B2 E2 B1 D0 A3 E3 A1 C2", "C2 B1 E2 C2 C1 D2 D2 B3"]}, "output": 189}, {"input": {"board": ["B2 D3 C3 B1 E2 C3", "C1 C1 B2 B3 A3 B1", "D0 E2 D2 B1 D2 D3", "A2 C0 E2 C0 E2 C1", "A3 D0 B2 C0 D2 D1", "D3 A3 A3 A1 E2 B1", "A3 D0 D2 D0 A2 E2"]}, "output": 126}, {"input": {"board": ["E0 B2 A1 C0 E3 A0 B3 C2", "E3 B0 C1 A0 E1 A1 A2 B1", "E2 A2 B0 D1 E1 D0 E3 D1", "D3 E0 A0 E2 A3 E3 C2 E1", "B0 B1 E3 B0 D1 D3 D3 A2", "C0 C3 C2 A1 B0 B2 A1 E0"]}, "output": 121}, {"input": {"board": ["C2 E2 E1 E0 E3 B1 D2 D3", "D0 E2 B1 A2 B0 D3 E0 E3", "A0 C0 E0 C0 B3 B3 B1 C2", "A3 B2 E1 B1 D3 E0 A0 D3"]}, "output": 112}, {"input": {"board": ["A1 D0 E3 C3 A3 C3", "A0 B3 A3 C3 D0 C2", "E1 A0 B3 D0 C1 D3", "E1 E3 A1 C3 D3 B2", "D0 D0 E3 A1 B3 C2", "C2 E0 B0 B0 A0 D3"]}, "output": 81}, {"input": {"board": ["B1 D1 E2", "E0 A0 A1", "A2 E1 D1", "A0 B2 B3", "B2 B1 C2", "B1 E1 D1"]}, "output": 61}, {"input": {"board": ["B1 E0 A0 E2", "B2 B2 E1 D0", "B2 E3 B1 B0", "B1 D2 B1 C0", "E1 B0 D3 C2", "C2 C0 D3 B0", "B0 C2 C2 C0", "A3 D1 D2 D0"]}, "output": 113}], "error_log": []}
{"context": "Given a population with a known mean and standard deviation, and a sample size, what are the bounds of the 95% confidence interval for the sample mean, and what is the difference in cumulative probabilities between these bounds?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sample_count` (int): The number of samples taken.\n  `mean` (float): The mean of the population.\n  `standard_deviation` (float): The standard deviation of the population.\n  `probability` (float): The desired probability (e.g., 0.95 for 95% confidence interval).\n  `z_score` (float): The z-score corresponding to the desired probability (e.g., 1.96 for 95% confidence interval).\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `lower_bound` (float): The lower bound of the confidence interval, rounded to 2 decimal places.\n    - `upper_bound` (float): The upper bound of the confidence interval, rounded to 2 decimal places.\n    - `probability_difference` (float): The difference in cumulative probabilities between the upper and lower bounds, rounded to 4 decimal places.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef cumulative_distribution(x, mean, standard_deviation):\n    return 0.5 * (1 + math.erf((x - mean) / (standard_deviation * math.sqrt(2))))\n\n# main function\ndef main_solution(sample_count, mean, standard_deviation, probability, z_score):\n    # Convert JSON serializable inputs to original input variables\n    sample_count = int(sample_count)\n    mean = float(mean)\n    standard_deviation = float(standard_deviation)\n    probability = float(probability)\n    z_score = float(z_score)\n\n    mean_new = mean\n    standard_deviation_new = standard_deviation / math.sqrt(sample_count)\n\n    answer1 = (mean_new - z_score * standard_deviation_new)\n    answer2 = (mean_new + z_score * standard_deviation_new)\n\n    A = cumulative_distribution(answer1, mean_new, standard_deviation_new)\n    B = cumulative_distribution(answer2, mean_new, standard_deviation_new)\n\n    # Convert outputs to JSON serializable format\n    result = {\n        \"lower_bound\": round(answer1, 2),\n        \"upper_bound\": round(answer2, 2),\n        \"probability_difference\": round(B - A, 4)\n    }\n\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    sample_count = random.randint(10, 1000)\n    mean = random.uniform(0, 100)\n    standard_deviation = random.uniform(1, 20)\n    probability = random.uniform(0.01, 0.99)\n    z_score = random.uniform(1.0, 3.0)\n    \n    return {\n        \"sample_count\": sample_count,\n        \"mean\": mean,\n        \"standard_deviation\": standard_deviation,\n        \"probability\": probability,\n        \"z_score\": z_score\n    }", "io_pairs": [{"input": {"sample_count": 25, "mean": 33.03026659178126, "standard_deviation": 11.877293104483934, "probability": 0.4803948518826041, "z_score": 1.4147850078871658}, "output": {"lower_bound": 29.67, "upper_bound": 36.39, "probability_difference": 0.8429}}, {"input": {"sample_count": 522, "mean": 67.78879305377224, "standard_deviation": 5.620419355935541, "probability": 0.8636998965085025, "z_score": 1.3508138585135816}, "output": {"lower_bound": 67.46, "upper_bound": 68.12, "probability_difference": 0.8232}}, {"input": {"sample_count": 226, "mean": 38.197729952812445, "standard_deviation": 10.19553295256431, "probability": 0.890721921748979, "z_score": 2.9287142243217374}, "output": {"lower_bound": 36.21, "upper_bound": 40.18, "probability_difference": 0.9966}}, {"input": {"sample_count": 586, "mean": 97.21687300494415, "standard_deviation": 16.282587511244778, "probability": 0.2204088984346843, "z_score": 2.1525403858589165}, "output": {"lower_bound": 95.77, "upper_bound": 98.66, "probability_difference": 0.9686}}, {"input": {"sample_count": 107, "mean": 92.49603814685021, "standard_deviation": 4.55119712473125, "probability": 0.0896275891043641, "z_score": 2.761895317964451}, "output": {"lower_bound": 91.28, "upper_bound": 93.71, "probability_difference": 0.9943}}, {"input": {"sample_count": 740, "mean": 85.99105312177812, "standard_deviation": 16.625182705260972, "probability": 0.8616289226421526, "z_score": 2.29279624457702}, "output": {"lower_bound": 84.59, "upper_bound": 87.39, "probability_difference": 0.9781}}, {"input": {"sample_count": 567, "mean": 0.11546578161363286, "standard_deviation": 8.48822309758614, "probability": 0.6207565427913843, "z_score": 2.1222438685051266}, "output": {"lower_bound": -0.64, "upper_bound": 0.87, "probability_difference": 0.9662}}, {"input": {"sample_count": 549, "mean": 25.516920595840077, "standard_deviation": 3.5452649136852217, "probability": 0.5534904375465934, "z_score": 1.8566419750618377}, "output": {"lower_bound": 25.24, "upper_bound": 25.8, "probability_difference": 0.9366}}, {"input": {"sample_count": 49, "mean": 6.531363800555212, "standard_deviation": 19.617755207186743, "probability": 0.31987483493799057, "z_score": 2.4597497529685333}, "output": {"lower_bound": -0.36, "upper_bound": 13.42, "probability_difference": 0.9861}}, {"input": {"sample_count": 148, "mean": 8.392710715368013, "standard_deviation": 19.85895948098152, "probability": 0.8303056495069514, "z_score": 1.7966293230887314}, "output": {"lower_bound": 5.46, "upper_bound": 11.33, "probability_difference": 0.9276}}], "error_log": []}
{"context": "Given the concept of superprime numbers, which are prime numbers that remain prime when the leftmost digit is successively removed, what are the superprime numbers of a specified length `N`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The length of the superprime numbers to be generated.\n\nOutput:\n  `return` (list of int): A list of superprime numbers of length `N`.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef isPrime(n):\n  if n == 2 or n == 3: return True\n  if n < 2 or n%2 == 0: return False\n  if n < 9: return True\n  if n%3 == 0: return False\n  r = int(n**0.5)\n  f = 5\n  while f <= r:\n    if n%f == 0: return False\n    if n%(f+2) == 0: return False\n    f +=6\n  return True \n\ndef solve(i, N, firstDigits, lastDigits, number, results):\n  if i == N:\n    if isPrime(number):\n      results.append(number)\n\n  if i == 0:\n    for digit in firstDigits:\n      number = digit\n      solve(i+1, N, firstDigits, lastDigits, number, results)\n  else:\n    for digit in lastDigits:\n      number *= 10\n      number += digit\n      if isPrime(number):\n        solve(i+1, N, firstDigits, lastDigits, number, results)\n        number = number // 10\n      else:\n        number = number // 10\n        continue\n\n# main function\ndef main_solution(N):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  firstDigits = [2, 3, 5, 7]\n  lastDigits = [1, 3, 7, 9]\n  results = []\n  number = 0\n  solve(0, N, firstDigits, lastDigits, number, results)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return results", "input_generator": "import random\n\ndef input_generator():\n    return {'N': random.randint(1, 6)}", "io_pairs": [{"input": {"N": 5}, "output": [23333, 23339, 23399, 23993, 29399, 31193, 31379, 37337, 37339, 37397, 59393, 59399, 71933, 73331, 73939]}, {"input": {"N": 3}, "output": [233, 239, 293, 311, 313, 317, 373, 379, 593, 599, 719, 733, 739, 797]}, {"input": {"N": 1}, "output": [2, 3, 5, 7]}, {"input": {"N": 4}, "output": [2333, 2339, 2393, 2399, 2939, 3119, 3137, 3733, 3739, 3793, 3797, 5939, 7193, 7331, 7333, 7393]}, {"input": {"N": 2}, "output": [23, 29, 31, 37, 53, 59, 71, 73, 79]}, {"input": {"N": 6}, "output": [233993, 239933, 293999, 373379, 373393, 593933, 593993, 719333, 739391, 739393, 739397, 739399]}], "error_log": []}
{"context": "Given a 3x3 sliding puzzle with tiles numbered from 0 to 8, where 0 represents the empty space, and an initial configuration of the puzzle, how will the puzzle look after applying a certain number of random moves?\n\nThe input and output requirements are as follows:\n\nInput:\n- `initial_board` (list of lists of integers): A 3x3 grid representing the initial state of the puzzle. The grid contains integers from 0 to 8, where 0 represents the empty space.\n- `num_moves` (integer): The number of random moves to apply to the initial state.\n\nOutput:\n- `return` (list of lists of integers): A 3x3 grid representing the state of the puzzle after applying the specified number of random moves. The grid contains integers from 0 to 8, where 0 represents the empty space.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass State:\n    boardSize = 3\n\n    def __init__(self, s=None):\n        if s is None:\n            tiles = iter(range(self.boardSize * self.boardSize))\n            self.board = [[next(tiles) for _ in range(self.boardSize)] for _ in range(self.boardSize)]\n            self.position = [0, 0]\n        else:\n            self.board = [list(row) for row in s.board]\n            self.position = list(s.position)\n\n    def __eq__(self, other):\n        if isinstance(other, State):\n            return self.board == other.board\n        elif isinstance(other, list):\n            return self.board == other\n        else:\n            return NotImplemented\n\n    def toTuple(self):\n        return tuple(tuple(row) for row in self.board)\n\n    def setBoard(self, brd):\n        self.board = brd\n        for row in range(self.boardSize):\n            for col in range(self.boardSize):\n                if self.board[row][col] == 0:\n                    self.position = [row, col]\n                    return None\n        assert False, 'Set board configuration does not have an empty spot!'\n\nclass Problem:\n    def __init__(self):\n        self.actions = ['U', 'L', 'D', 'R']\n\n    def apply(self, a, s):\n        post = s.position\n        pre = list(post)\n        if a == 'U':\n            post[0] = max(pre[0] - 1, 0)\n        elif a == 'L':\n            post[1] = max(pre[1] - 1, 0)\n        elif a == 'D':\n            post[0] = min(pre[0] + 1, s.boardSize - 1)\n        elif a == 'R':\n            post[1] = min(pre[1] + 1, s.boardSize - 1)\n        else:\n            assert False, 'Action not defined for this problem!'\n        tile = s.board[pre[0]][pre[1]]\n        s.board[pre[0]][pre[1]] = s.board[post[0]][post[1]]\n        s.board[post[0]][post[1]] = tile\n        return s\n\n    def applicable(self, s):\n        actionList = []\n        if s.position[0] > 0:\n            actionList.append('U')\n        if s.position[1] > 0:\n            actionList.append('L')\n        if s.position[0] < (s.boardSize - 1):\n            actionList.append('D')\n        if s.position[1] < (s.boardSize - 1):\n            actionList.append('R')\n        return actionList\n\ndef apply_rnd_moves(numMoves, s, p):\n    for _ in range(numMoves):\n        p.apply(random.choice(p.actions), s)\n\n# main function\ndef main_solution(initial_board, num_moves):\n    # Convert JSON serializable input to original input variables\n    initial_state = State()\n    initial_state.setBoard(initial_board)\n    problem = Problem()\n    \n    # Apply random moves to the initial state\n    apply_rnd_moves(num_moves, initial_state, problem)\n    \n    # Convert the final state to a JSON serializable output\n    final_board = initial_state.board\n    return final_board", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random initial board (3x3) with numbers 0-8, where 0 represents the empty spot\n    numbers = list(range(9))\n    random.shuffle(numbers)\n    initial_board = [numbers[i*3:(i+1)*3] for i in range(3)]\n    \n    # Generate a random number of moves (between 1 and 20)\n    num_moves = random.randint(1, 20)\n    \n    return {\n        'initial_board': initial_board,\n        'num_moves': num_moves\n    }", "io_pairs": [{"input": {"initial_board": [[2, 6, 4], [5, 0, 7], [1, 8, 3]], "num_moves": 17}, "output": [[2, 6, 4], [5, 0, 7], [1, 8, 3]]}, {"input": {"initial_board": [[1, 0, 6], [8, 7, 3], [2, 4, 5]], "num_moves": 10}, "output": [[1, 0, 6], [8, 7, 3], [2, 4, 5]]}, {"input": {"initial_board": [[3, 7, 5], [0, 8, 6], [4, 2, 1]], "num_moves": 10}, "output": [[3, 7, 5], [0, 8, 6], [4, 2, 1]]}, {"input": {"initial_board": [[4, 1, 2], [5, 6, 8], [7, 3, 0]], "num_moves": 3}, "output": [[4, 1, 2], [5, 6, 8], [7, 3, 0]]}, {"input": {"initial_board": [[4, 1, 8], [2, 5, 3], [7, 6, 0]], "num_moves": 8}, "output": [[4, 1, 8], [2, 5, 3], [7, 6, 0]]}, {"input": {"initial_board": [[3, 0, 8], [2, 5, 6], [7, 1, 4]], "num_moves": 15}, "output": [[3, 0, 8], [2, 5, 6], [7, 1, 4]]}, {"input": {"initial_board": [[3, 0, 2], [8, 6, 7], [4, 5, 1]], "num_moves": 1}, "output": [[3, 0, 2], [8, 6, 7], [4, 5, 1]]}, {"input": {"initial_board": [[3, 4, 0], [5, 8, 7], [6, 2, 1]], "num_moves": 12}, "output": [[3, 4, 0], [5, 8, 7], [6, 2, 1]]}, {"input": {"initial_board": [[0, 8, 4], [3, 5, 6], [2, 7, 1]], "num_moves": 5}, "output": [[0, 8, 4], [3, 5, 6], [2, 7, 1]]}, {"input": {"initial_board": [[5, 8, 2], [7, 6, 3], [1, 0, 4]], "num_moves": 11}, "output": [[5, 8, 2], [7, 6, 3], [1, 0, 4]]}], "error_log": []}
{"context": "Given two integers, what is the greatest common divisor (GCD) of these two numbers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (int): The first integer.\n  `y` (int): The second integer.\n\nOutput:\n  `return` (int): The greatest common divisor of `x` and `y`.", "reference_code": "# import necessary packages\nfrom math import floor\n\n# main function\ndef main_solution(x, y):\n    \"\"\"\n    Computes the greatest common divisor (GCD) of two integers using the Euclidean Algorithm.\n    \n    Parameters:\n    x (int): The first integer.\n    y (int): The second integer.\n    \n    Returns:\n    int: The greatest common divisor of x and y.\n    \"\"\"\n    if x < y:  # We want x >= y\n        x, y = y, x\n    \n    while y != 0:\n        (x, y) = (y, x % y)\n    \n    return x", "input_generator": "import random\n\ndef input_generator():\n    x = random.randint(1, 10000)\n    y = random.randint(1, 10000)\n    return {'x': x, 'y': y}", "io_pairs": [{"input": {"x": 3170, "y": 5599}, "output": 1}, {"input": {"x": 2676, "y": 8527}, "output": 1}, {"input": {"x": 3352, "y": 2040}, "output": 8}, {"input": {"x": 1819, "y": 864}, "output": 1}, {"input": {"x": 1399, "y": 1511}, "output": 1}, {"input": {"x": 5238, "y": 897}, "output": 3}, {"input": {"x": 8924, "y": 1347}, "output": 1}, {"input": {"x": 3527, "y": 8072}, "output": 1}, {"input": {"x": 1428, "y": 3705}, "output": 3}, {"input": {"x": 1761, "y": 2034}, "output": 3}], "error_log": []}
{"context": "Given a list of integers, you need to determine the middle element of a doubly linked list (DLL) after it has been converted to a balanced binary tree and back to a DLL. What is the middle element of the DLL after these transformations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `elements` (list of integers): A list of integers representing the elements to be added to the doubly linked list (DLL).\n\nOutput:\n  `return` (integer): The middle element of the DLL after it has been converted to a balanced binary tree and back to a DLL.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, a):\n        self.a = a\n        self.next = None\n        self.prev = None\n\nclass DLL:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.count = 0\n\n    def add(self, a):\n        n = Node(a)\n        if not self.head:\n            self.head = n\n            self.tail = n\n        else:\n            self.tail.next = n\n            n.prev = self.tail\n            self.tail = n\n        self.count += 1\n\n    def get_element(self, n):\n        cur = self.head\n        count = 1\n        while count < n:\n            cur = cur.next\n            count += 1\n        return cur\n\nclass TreeNode:\n    def __init__(self, a):\n        self.a = a\n        self.right = None\n        self.left = None\n\ndef create_tree(d, start, end):\n    if end - start <= 2:\n        if end == start:\n            return TreeNode(d.get_element(start).a)\n        elif end - start == 1:\n            t = TreeNode(d.get_element(start).a)\n            t.right = TreeNode(d.get_element(end).a)\n            return t\n        elif end - start == 2:\n            t = TreeNode(d.get_element(start + 1).a)\n            t.left = TreeNode(d.get_element(start).a)\n            t.right = TreeNode(d.get_element(start + 2).a)\n            return t\n    else:\n        mid = start + (end - start) // 2\n        t = TreeNode(d.get_element(mid).a)\n        t.left = create_tree(d, start, start + ((end - start) // 2) - 1)\n        t.right = create_tree(d, end - ((end - start) // 2) + 1, end)\n        return t\n\ndef create_dll(root):\n    d = DLL()\n    _create_dll(root, d)\n    return d\n\ndef _create_dll(root, d):\n    if root.left:\n        _create_dll(root.left, d)\n    d.add(root.a)\n    if root.right:\n        _create_dll(root.right, d)\n\ndef middle_element(d):\n    cur = d.head\n    cur_2 = d.head\n    cur_2_pass = False\n    while cur:\n        cur = cur.next\n        if cur_2_pass:\n            cur_2 = cur_2.next\n            cur_2_pass = False\n        else:\n            cur_2_pass = True\n    return cur_2.a\n\n# main function\ndef main_solution(elements):\n    # Convert the input list to a DLL\n    dll = DLL()\n    for element in elements:\n        dll.add(element)\n    \n    # Create a balanced binary tree from the DLL\n    tree_root = create_tree(dll, 1, dll.count)\n    \n    # Convert the tree back to a DLL\n    dll_from_tree = create_dll(tree_root)\n    \n    # Find the middle element of the DLL\n    middle_elem = middle_element(dll_from_tree)\n    \n    return middle_elem", "input_generator": "import random\n\ndef input_generator():\n    elements = []\n    length = random.randint(5, 20)\n    for _ in range(length):\n        elements.append(random.randint(1, 100))\n    return {'elements': elements}", "io_pairs": [{"input": {"elements": [2, 77, 87, 2, 58, 31, 27, 99, 76, 30, 83]}, "output": 31}, {"input": {"elements": [82, 16, 25, 20, 10, 17, 60, 46, 93, 38, 12, 59]}, "output": 17}, {"input": {"elements": [49, 72, 9, 92, 23, 31, 35]}, "output": 92}, {"input": {"elements": [35, 7, 15, 45, 31, 75, 9, 77, 25, 48, 88, 41]}, "output": 75}, {"input": {"elements": [90, 12, 13, 51, 13, 33, 15]}, "output": 51}, {"input": {"elements": [57, 44, 22, 10, 79, 12, 62, 6, 30, 36, 55, 77, 41, 35]}, "output": 62}, {"input": {"elements": [59, 49, 87, 62, 65]}, "output": 87}, {"input": {"elements": [70, 97, 83, 79, 16, 20, 98, 53, 13, 91, 72, 76, 24, 18, 41, 86]}, "output": 53}, {"input": {"elements": [28, 38, 44, 97, 85, 72, 13, 82, 8, 87, 52, 93, 18]}, "output": 13}, {"input": {"elements": [15, 49, 67, 86, 34, 6, 2]}, "output": 86}], "error_log": []}
{"context": "In an ant colony optimization simulation, an ant navigates a graph to find the optimal path based on pheromone trails. Given the size of the permutation `n`, the pheromone trace value `trace`, and the starting node `start_node`, what is the fitness score of the ant's walk after it completes its journey?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the permutation, which determines the number of nodes in the graph.\n  `trace` (float): The amount of pheromone trail added by the ant after each move.\n  `start_node` (tuple): A tuple representing the starting node for the ant in the graph.\n\nOutput:\n  `return` (dict): A dictionary containing the fitness score of the ant's walk. The key is `\"fitness_score\"` and the value is an integer representing the score.", "reference_code": "# import necessary packages\nimport random\nimport itertools\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    def __init__(self):\n        self.__graph = {}\n        \n    def generate_graph(self, n):\n        perms = list(itertools.permutations(range(1, n + 1)))\n        for i in range(len(perms)-1):\n            for j in range(i+1,len(perms)):\n                key=(perms[i], perms[j])\n                if key not in self.__graph.keys():\n                    self.__graph[key] = 0\n                \n    def get_graph(self):\n        return self.__graph\n                \n    def get_weight(self, node1, node2):\n        tpl = (node1, node2)\n        if tpl in self.__graph.keys():\n            return self.__graph[tpl]\n    \n    def set_weight(self, node1, node2, weight):\n        tpl = (node1, node2)\n        if tpl in self.__graph.keys():\n            self.__graph[tpl] = weight\n    \n    def get_nodes(self):\n        nodes = []\n        for key in self.__graph.keys():\n            if key[0] not in nodes:\n                nodes.append(key[0])\n            if key[1] not in nodes:\n                nodes.append(key[1])\n        return nodes\n\n    def get_outbound(self, node):\n        friends = []\n        for key in self.__graph.keys():\n            if node==key[0] and key[1] not in friends and key[1]!=node:\n                friends.append(key[1])\n        return friends\n    \n    def get_inbound(self, node):\n        friends = []\n        for key in self.__graph.keys():\n            if node == key[1] and key[0] not in friends and key[0]!=node:\n                friends.append(key[0])\n        return friends\n\nclass Ant:\n    def __init__(self, n, trace, graph, start_node):\n        self.__n = n\n        self.__trace = trace\n        self.__graph = graph\n        self.__current_node = start_node\n        self.__visited = []\n        self.__visited.append(start_node)\n        \n    def one_step(self):\n        best_friend = None\n        best_weight = float('inf')\n        neighbours_out = self.__graph.get_outbound(self.__current_node)\n        for neighbour in neighbours_out:\n            weight = self.__graph.get_weight(self.__current_node, neighbour)\n            if  weight < best_weight:\n                best_weight = weight\n                best_friend = neighbour\n        \n        neighbours_in = self.__graph.get_inbound(self.__current_node)\n        for neighbour in neighbours_in:\n            weight = self.__graph.get_weight(neighbour, self.__current_node)\n            if  weight < best_weight:\n                best_weight = weight\n                best_friend = neighbour\n        \n        if random.random() > 0.5 and best_friend is not None:\n            self.__visited.append(best_friend)\n            self.__current_node = best_friend \n        else:\n            neighbours = neighbours_in + neighbours_out\n            if len(neighbours) > 0:\n                self.__current_node = random.choice(neighbours)\n                self.__visited.append(self.__current_node)\n            \n        self.add_smell()\n\n    def add_smell(self):\n        from_node = self.__visited[len(self.__visited)-2]      \n        to_node = self.__visited[len(self.__visited)-1]\n        initial_smell = self.__graph.get_weight(from_node, to_node)\n        if initial_smell is None:\n            initial_smell = self.__graph.get_weight(to_node, from_node)\n\n        self.__graph.set_weight(from_node, to_node, initial_smell + self.__trace)\n\n    @staticmethod\n    def count_gene(individual, gene):\n        count = 0\n        for tpl in individual:\n            if tpl == gene:\n                count += 1\n        return count\n\n    def fitness(self):\n        ind = self.__visited\n        score = 0\n        for tpl in ind:\n            score += Ant.count_gene(ind, tpl)\n            score -= 1 \n        n = len(ind) // 2\n        for i in range(n):\n            l = []\n            for j in range(n):\n                l.append(ind[j][i])\n            score += len(l) - len(set(l))\n        for j in range(n):\n            l = []\n            for i in range(n, 2 * n):\n                l.append(ind[i][j])\n            score += len(l) - len(set(l))\n        l = []\n        for i in range(n):\n            j = n + i\n            for k in range(n):\n                l.append((ind[i][k], ind[j][k]))\n        score += len(l) - len(set(l))     \n        return score\n\n    def finished_walk(self):\n        return len(self.__visited) == self.__n * 2\n\n# main function\ndef main_solution(n, trace, start_node):\n    graph = Graph()\n    graph.generate_graph(n)\n    ant = Ant(n, trace, graph, start_node)\n    \n    while not ant.finished_walk():\n        ant.one_step()\n    \n    fitness_score = ant.fitness()\n    return {\"fitness_score\": fitness_score}", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(2, 4)  # Reasonable size to avoid excessive computation\n    trace = random.uniform(0.1, 1.0)  # Random trace value between 0.1 and 1.0\n    start_node = tuple(random.sample(range(1, n + 1), n))  # Random permutation as start node\n    return {\"n\": n, \"trace\": trace, \"start_node\": start_node}", "io_pairs": [{"input": {"n": 2, "trace": 0.2675856126002375, "start_node": [2, 1]}, "output": {"fitness_score": 6}}, {"input": {"n": 3, "trace": 0.45161925921456225, "start_node": [1, 2, 3]}, "output": {"fitness_score": 8}}, {"input": {"n": 4, "trace": 0.29314652581806644, "start_node": [4, 2, 3, 1]}, "output": {"fitness_score": 13}}, {"input": {"n": 4, "trace": 0.9166808986753401, "start_node": [2, 1, 4, 3]}, "output": {"fitness_score": 18}}, {"input": {"n": 2, "trace": 0.3395202041558833, "start_node": [1, 2]}, "output": {"fitness_score": 6}}, {"input": {"n": 3, "trace": 0.5969410507730935, "start_node": [1, 3, 2]}, "output": {"fitness_score": 9}}, {"input": {"n": 3, "trace": 0.9192540629832736, "start_node": [1, 2, 3]}, "output": {"fitness_score": 10}}, {"input": {"n": 4, "trace": 0.4671699789874395, "start_node": [1, 3, 4, 2]}, "output": {"fitness_score": 19}}, {"input": {"n": 4, "trace": 0.7095593093793281, "start_node": [4, 3, 2, 1]}, "output": {"fitness_score": 16}}, {"input": {"n": 2, "trace": 0.5312150877420808, "start_node": [1, 2]}, "output": {"fitness_score": 6}}], "error_log": []}
{"context": "Given a prime number `p` and coefficients `a` and `b`, what are the first 20 points on the elliptic curve defined by the equation `y^2 = x^3 + ax + b` modulo `p`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p` (int): A prime number representing the modulus for the elliptic curve.\n  `a` (int): The coefficient 'a' in the elliptic curve equation `y^2 = x^3 + ax + b`.\n  `b` (int): The coefficient 'b' in the elliptic curve equation `y^2 = x^3 + ax + b`.\n\nOutput:\n  `return` (list of tuples): A list of tuples representing the first 20 points on the elliptic curve. Each tuple contains two integers `(x, y)` where `y` is the integer square root of `x^3 + ax + b` modulo `p`.", "reference_code": "import math\n\ndef findpoints(p, a, b):\n    points = []\n    found = 0\n    for x in range(1, 2 * p):\n        val = ((x * x * x) + a * x + b) % p\n        res = math.sqrt(val)\n\n        if found > 19 or x > p:\n            break\n\n        if abs(res - int(res)) < 0.0001:\n            points.append((x, int(res)))\n            found += 1\n    return points\n\ndef main_solution(p, a, b):\n    # Convert inputs to the required format\n    p = int(p)\n    a = int(a)\n    b = int(b)\n    \n    # Find the first 20 points on the elliptic curve\n    points = findpoints(p, a, b)\n    \n    # Convert the output to JSON serializable format\n    return points", "input_generator": "import random\nimport math\n\ndef input_generator():\n    p = random.choice([17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])\n    a = random.randint(-10, 10)\n    b = random.randint(-10, 10)\n    return {'p': p, 'a': a, 'b': b}", "io_pairs": [{"input": {"p": 17, "a": -2, "b": -7}, "output": [[1, 3], [7, 4], [10, 2]]}, {"input": {"p": 61, "a": -4, "b": 8}, "output": [[8, 0], [39, 1], [47, 2], [49, 6], [53, 4], [56, 5]]}, {"input": {"p": 79, "a": 0, "b": 4}, "output": [[20, 5], [27, 4], [63, 4], [65, 5], [68, 4], [73, 5], [79, 2]]}, {"input": {"p": 19, "a": 10, "b": 7}, "output": [[2, 4], [4, 4], [9, 3], [11, 2], [13, 4]]}, {"input": {"p": 59, "a": 5, "b": 1}, "output": [[7, 5], [34, 2], [38, 4], [40, 3], [52, 6], [59, 1]]}, {"input": {"p": 43, "a": -3, "b": -7}, "output": [[11, 1], [13, 1], [18, 3], [19, 1], [29, 0], [43, 6]]}, {"input": {"p": 89, "a": 3, "b": 6}, "output": [[23, 7], [46, 5], [62, 0], [81, 2], [87, 9]]}, {"input": {"p": 53, "a": -10, "b": 2}, "output": [[10, 1], [11, 2], [14, 3], [16, 4], [18, 6], [42, 0]]}, {"input": {"p": 41, "a": -9, "b": 0}, "output": [[3, 0], [15, 1], [16, 4], [17, 2], [22, 6], [25, 5], [38, 0], [41, 0]]}, {"input": {"p": 47, "a": -5, "b": -8}, "output": [[3, 2], [4, 6], [13, 3], [18, 0], [26, 1], [35, 4]]}], "error_log": []}
{"context": "Given a coin with an unknown probability of landing heads, you conduct a series of coin tosses to estimate this probability. Using Bayesian inference, how can you determine the mean and the 95% Highest Posterior Density (HPD) interval for the probability of the coin landing heads, given the number of trials, the true probability of heads, and the parameters of the prior distribution?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The number of trials in the binomial experiment.\n  `theta` (float): The true probability of success in the binomial distribution.\n  `alpha` (float): The alpha parameter of the Beta prior distribution.\n  `beta` (float): The beta parameter of the Beta prior distribution.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `posterior_mean` (float): The mean of the posterior distribution.\n    - `hpd_interval` (list of float): The 95% Highest Posterior Density (HPD) interval as a list of two floats [lower_bound, upper_bound].", "reference_code": "# import necessary packages\nfrom scipy import stats\nimport numpy as np\n\n# main function\ndef main_solution(N, theta, alpha, beta):\n    # Generate data from a binomial distribution with given theta and N\n    y = stats.binom(n=N, p=theta).rvs()\n    \n    # Compute the posterior distribution parameters\n    posterior_alpha = alpha + y\n    posterior_beta = beta + N - y\n    \n    # Sample from the posterior distribution\n    posterior_samples = stats.beta(a=posterior_alpha, b=posterior_beta).rvs(1000)\n    \n    # Compute the mean and 95% HPD (Highest Posterior Density) interval\n    posterior_mean = np.mean(posterior_samples)\n    hpd_interval = np.percentile(posterior_samples, [2.5, 97.5])\n    \n    # Return the results as a dictionary\n    return {\n        \"posterior_mean\": posterior_mean,\n        \"hpd_interval\": hpd_interval.tolist()\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    N = random.randint(10, 1000)\n    theta = random.uniform(0.1, 0.9)\n    alpha = random.uniform(0.5, 5.0)\n    beta = random.uniform(0.5, 5.0)\n    return {\n        \"N\": N,\n        \"theta\": theta,\n        \"alpha\": alpha,\n        \"beta\": beta\n    }", "io_pairs": [{"input": {"N": 635, "theta": 0.8535027943870842, "alpha": 0.6035024754466287, "beta": 1.4530776424111307}, "output": {"posterior_mean": 0.8354555423282793, "hpd_interval": [0.8054309544229871, 0.8638185568902065]}}, {"input": {"N": 92, "theta": 0.1136034381276958, "alpha": 4.206661249731036, "beta": 4.361544819635764}, "output": {"posterior_mean": 0.1509980449313304, "hpd_interval": [0.0898817465517327, 0.22689066083342793]}}, {"input": {"N": 831, "theta": 0.36328133764141435, "alpha": 4.365590979775758, "beta": 2.723198826452926}, "output": {"posterior_mean": 0.35370786456369185, "hpd_interval": [0.323845065822575, 0.38567806237331326]}}, {"input": {"N": 407, "theta": 0.6983797015099679, "alpha": 4.795274070666621, "beta": 2.8574754860070097}, "output": {"posterior_mean": 0.6988397288802406, "hpd_interval": [0.6573861534168047, 0.7424477529672387]}}, {"input": {"N": 947, "theta": 0.5616074480836862, "alpha": 4.896614544219352, "beta": 3.06334207955717}, "output": {"posterior_mean": 0.5963327982838277, "hpd_interval": [0.5646563787846309, 0.6252869535328878]}}, {"input": {"N": 567, "theta": 0.2564955097977871, "alpha": 3.1136012116776115, "beta": 2.028552255999907}, "output": {"posterior_mean": 0.26532712161938027, "hpd_interval": [0.23151363178219447, 0.3019858208147877]}}, {"input": {"N": 16, "theta": 0.41851458643375483, "alpha": 4.049803346171153, "beta": 4.3657895466197605}, "output": {"posterior_mean": 0.3659182882721893, "hpd_interval": [0.19813110906354572, 0.5665898760563898]}}, {"input": {"N": 654, "theta": 0.42116970012862776, "alpha": 3.0459781085526876, "beta": 0.8952897957428809}, "output": {"posterior_mean": 0.4225080192410237, "hpd_interval": [0.3877565381216685, 0.457678121477759]}}, {"input": {"N": 235, "theta": 0.27905581843796745, "alpha": 1.2509106387321336, "beta": 3.861345525794343}, "output": {"posterior_mean": 0.25006109963808526, "hpd_interval": [0.19471038732983875, 0.3109961214065358]}}, {"input": {"N": 152, "theta": 0.8880864684800276, "alpha": 0.9696709463385924, "beta": 2.2885561796849885}, "output": {"posterior_mean": 0.8883524920185685, "hpd_interval": [0.8361777771808746, 0.9314976249348008]}}], "error_log": []}
{"context": "In a game of Gomoku, a player wins by placing five of their stones in a row, either horizontally, vertically, or diagonally. Given a board configuration, determine the current status of the game. Is the game still ongoing, has it resulted in a draw, or has either the white or black player won?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_str` (str): A string representing the Gomoku board. Each row is separated by a semicolon (`;`), and each cell in the row is represented by a single character (`' '` for empty, `'b'` for black, `'w'` for white).\n\nOutput:\n  `return` (str): A string indicating the game status. Possible values are `\"White won\"`, `\"Black won\"`, `\"Draw\"`, or `\"Continue playing\"`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_empty(board):\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] != \" \":\n                return False\n    return True\n\ndef is_bounded(board, y_end, x_end, length, d_y, d_x):\n    count = 0\n    start_x = x_end - (length-1)*d_x\n    start_y = y_end - (length-1)*d_y\n    if (d_y == 1 and d_x == -1) or(d_y == 1 and d_x == 1):\n        if start_x != 0 and start_y != 0 and start_y != 7 and start_x!=7:\n            if board[start_y - d_y][start_x - d_x] == ' ':\n                count+=1\n        if x_end != 0 and y_end != 0 and y_end!= 7 and x_end != 7:\n            if board[y_end + d_y][x_end + d_x] == ' ':\n                count+=1\n        if count == 0:\n            return \"CLOSED\"\n        if count == 1:\n            return \"SEMIOPEN\"\n        if count == 2:\n            return \"OPEN\"\n    if d_y == 1 and d_x == 0:\n        if start_y != 0:\n            if board[start_y - d_y][start_x - d_x] == ' ':\n                count+=1\n        if y_end != 7:\n            if board[y_end + d_y][x_end + d_x] == ' ':\n                count+=1\n        if count == 0:\n            return \"CLOSED\"\n        if count == 1:\n            return \"SEMIOPEN\"\n        if count == 2:\n            return \"OPEN\"\n    if d_y == 0 and d_x == 1:\n        if start_x != 0:\n            if board[start_y - d_y][start_x - d_x] == ' ':\n                count+=1\n        if x_end != 7:\n            if board[y_end + d_y][x_end + d_x] == ' ':\n                count+=1\n        if count == 0:\n            return \"CLOSED\"\n        if count == 1:\n            return \"SEMIOPEN\"\n        if count == 2:\n            return \"OPEN\"\n\ndef detects_row_win(board, col, y_start, x_start, length, d_y, d_x):\n    run = 0\n    open_seq_count = 0\n    semi_open_seq_count = 0\n    closed_count = 0\n    length_start = 0\n    j = y_start - d_y\n    k = x_start - d_x\n    rows = range_row(y_start,x_start,d_y,d_x)\n    for i in range(rows):\n        j += d_y\n        k += d_x\n        if board[j][k] == col and run == 0:\n            first_y = j\n            first_x = k\n            run = 1\n            length_start = i\n        if run == 1 and i == rows-1 and board[j][k]== col:\n            y_end = j\n            x_end = k\n            length_2 = i- length_start +1\n            run = 0\n            if length_2 == length:\n                output = is_bounded(board, y_end, x_end, length_2, d_y, d_x)\n                if output == \"CLOSED\":\n                    closed_count +=1\n                if output == \"OPEN\":\n                    open_seq_count +=1\n                if output == \"SEMIOPEN\":\n                    semi_open_seq_count += 1\n        if board[j][k]!= col and run==1:\n            y_end = j - d_y\n            x_end = k - d_x\n            length_2 = i - length_start\n            run = 0\n            if i - length_start == length:\n                output = is_bounded(board, y_end, x_end, length_2, d_y, d_x)\n                if output == \"CLOSED\":\n                    closed_count += 1\n                if output == \"OPEN\":\n                    open_seq_count +=1\n                if output == \"SEMIOPEN\":\n                    semi_open_seq_count += 1\n    return open_seq_count, semi_open_seq_count, closed_count\n\ndef detects_rows_win(board, col, length):\n    open_seq_count, semi_open_seq_count,closed_count = 0, 0,0\n    countL = []\n    for i in range(8):\n        for j in [[0,1],[1,1]]:\n            y_start = i\n            x_start = 0\n            d_y = j[0]\n            d_x = j[1]\n            countL.append(detects_row_win(board, col, y_start, x_start, length, d_y, d_x))\n\n    for i in range(8):\n        y_start = 0\n        x_start = i\n        d_y = 1\n        d_x = 0\n        countL.append(detects_row_win(board, col, y_start, x_start, length, d_y, d_x))\n\n    for i in range(1,7):\n        for j in [[1,1],[1,-1]]:\n            y_start = 0\n            x_start = i\n            d_y = j[0]\n            d_x = j[1]\n            countL.append(detects_row_win(board, col, y_start, x_start, length, d_y, d_x))\n    for i in range(8):\n        y_start = i\n        x_start = 7\n        d_y = 1\n        d_x = -1\n        countL.append(detects_row_win(board, col, y_start, x_start, length, d_y, d_x))\n    for i in countL:\n        open_seq_count += i[0]\n        semi_open_seq_count += i[1]\n        closed_count += i[2]\n    return open_seq_count, semi_open_seq_count,closed_count\n\ndef range_row(y_start,x_start,d_y,d_x):\n    if d_y == 0 and d_x ==1:\n        return abs(x_start -8)\n    if d_y == 1 and d_x == 0:\n        return abs(y_start - 8)\n    if d_y == 1 and d_x == -1:\n        return x_start - y_start + 1\n    if d_x == 1 and d_y == 1:\n        return abs(x_start -8) - y_start\n\ndef is_win(board):\n    col = \"w\"\n    if detects_rows_win(board, col, 5)[0]>0 or detects_rows_win(board, col, 5)[1] >0 or detects_rows_win(board, col, 5)[2] >0 :\n        return \"White won\"\n    col = \"b\"\n    if detects_rows_win(board, col, 5)[0]>0 or detects_rows_win(board, col, 5)[1] >0 or detects_rows_win(board, col, 5)[2] >0:\n        return \"Black won\"\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == \" \" :\n                return \"Continue playing\"\n    return \"Draw\"\n\ndef make_empty_board(sz):\n    board = []\n    for i in range(sz):\n        board.append([\" \"]*sz)\n    return board\n\n# main function\ndef main_solution(board_str):\n    # Convert the board string to a 2D list\n    board = [list(row) for row in board_str.split(';')]\n    \n    # Determine the game status\n    result = is_win(board)\n    \n    # Return the result\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random 8x8 board with ' ', 'b', and 'w'\n    board = []\n    for _ in range(8):\n        row = []\n        for _ in range(8):\n            row.append(random.choice([' ', 'b', 'w']))\n        board.append(row)\n    \n    # Convert the board to a string representation\n    board_str = ';'.join(''.join(row) for row in board)\n    \n    return {'board_str': board_str}", "io_pairs": [{"input": {"board_str": "www    b;ww bwwb ;bwb   w ; w bwbw ;bb wb ww;  wwb  w; wb  w  ;w w bwwb"}, "output": "White won"}, {"input": {"board_str": " wb  b  ;w b b  b;   w  ww;bb bb b ; bbb ww ; w    ww;bwbbbwwb;w   w  w"}, "output": "Continue playing"}, {"input": {"board_str": "b bwwb w;wbbw  bb;b  bb bb;w  w b w;  bbww  ;b bwwbbb; wbbw bw;w bbww w"}, "output": "Continue playing"}, {"input": {"board_str": "b  bwbww;bwwb wwb;b  b bbb;wwbbwbb ;wbwbb bb;wbbw  b ;w wb w  ;bw  bw  "}, "output": "Black won"}, {"input": {"board_str": "bbbb  bb;  bbbw b;bbb wbwb;b bbwwbb; w bw  b;w bbb b ; wbb bbw;ww wwwbw"}, "output": "Black won"}, {"input": {"board_str": "w wwbwbb;wwwbw b ;b wbb ww;w  wbwbb;wwb bb b;bb   bww;wb wbb b; b bwb b"}, "output": "Continue playing"}, {"input": {"board_str": "bw wwbw ; bb wb b; w b wbw;bb wwwb ;bwbbw bb;  b b bw;bbbw b b;b bwbwbb"}, "output": "Continue playing"}, {"input": {"board_str": "   w ww ;w wwwbb ;w bbbbwb;bwbbw  w;bbww b  ; b bw w ;wwbwbbww;bbbwbwb "}, "output": "Continue playing"}, {"input": {"board_str": "b    b  ;wwwbb b ;b bb bbw; w  w b ;w ww bwb;b  b  bb;b bbww  ;b w bb b"}, "output": "Continue playing"}, {"input": {"board_str": "ww    bb;bbb   b ;bw bwbbw;w wwbwbb;wwbwbb w;      w ;wbw w bw;bw bwbbb"}, "output": "Continue playing"}], "error_log": []}
{"context": "Given the initial state of a cellular automaton known as the Game of Life, what will be the state of the board after one iteration of the game's rules? The Game of Life is a simulation where each cell in a grid can be either live (1) or dead (0), and its state in the next iteration depends on its current state and the states of its eight neighboring cells. The rules are as follows:\n1. Any live cell with fewer than two live neighbors dies (under-population).\n2. Any live cell with two or three live neighbors lives on to the next generation.\n3. Any live cell with more than three live neighbors dies (over-population).\n4. Any dead cell with exactly three live neighbors becomes a live cell (reproduction).\n\nWhat is the next state of the board given its current state?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (str): A string representing the initial state of the board. The board is represented as a list of rows, where each row is a comma-separated string of integers (0 or 1). Rows are separated by semicolons.\n\nOutput:\n  `return` (str): A string representing the next state of the board after one update. The format is the same as the input string.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def gameOfLife(self, board):\n        dx = (1, 1, 1, 0, 0, -1, -1, -1)\n        dy = (1, 0, -1, 1, -1, 1, 0, -1)\n        for x in range(len(board)):\n            for y in range(len(board[0])):\n                lives = 0\n                for z in range(8):\n                    nx, ny = x + dx[z], y + dy[z]\n                    lives += self.getCellStatus(board, nx, ny)\n                if lives + board[x][y] == 3 or lives == 3:\n                    board[x][y] |= 2\n        for x in range(len(board)):\n            for y in range(len(board[0])):\n                board[x][y] >>= 1\n\n    def getCellStatus(self, board, x, y):\n        if x < 0 or y < 0 or x >= len(board) or y >= len(board[0]):\n            return 0\n        return board[x][y] & 1\n\n# main function\ndef main_solution(board):\n    # Convert the input board to a list of lists if it's not already\n    if isinstance(board, str):\n        board = [list(map(int, row.split(','))) for row in board.split(';')]\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Compute the next state of the board\n    solution.gameOfLife(board)\n    \n    # Convert the board back to a string format for JSON serialization\n    board_str = ';'.join(','.join(map(str, row)) for row in board)\n    \n    return board_str", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(3, 10)\n    cols = random.randint(3, 10)\n    board = [[random.randint(0, 1) for _ in range(cols)] for _ in range(rows)]\n    board_str = ';'.join(','.join(map(str, row)) for row in board)\n    return {'board': board_str}", "io_pairs": [{"input": {"board": "1,0,1,1,1,1,0,1;1,1,0,1,1,1,1,0;0,1,1,1,1,1,1,0"}, "output": "1,0,1,0,0,0,0,0;1,0,0,0,0,0,0,1;1,1,0,0,0,0,1,0"}, {"input": {"board": "0,1,1,1,0,1,1,0,0,0;0,1,0,0,1,1,1,0,1,1;1,0,0,0,1,0,1,0,1,0;0,0,1,0,1,1,0,1,0,0"}, "output": "0,1,1,1,0,0,1,1,0,0;1,1,0,0,0,0,0,0,1,1;0,1,0,0,0,0,0,0,1,1;0,0,0,1,1,1,1,1,0,0"}, {"input": {"board": "1,1,1,1,0;1,1,1,1,1;0,1,1,1,0;0,0,0,1,0;1,1,0,1,0"}, "output": "1,0,0,0,1;0,0,0,0,1;1,0,0,0,0;1,0,0,1,1;0,0,1,0,0"}, {"input": {"board": "1,0,0,0,0,0;1,1,0,1,1,1;0,1,1,1,1,1;1,1,0,0,1,1;0,0,0,1,1,0;0,1,1,1,0,0;1,1,0,0,1,1"}, "output": "1,1,0,0,1,0;1,0,0,0,0,1;0,0,0,0,0,0;1,1,0,0,0,0;1,0,0,0,0,1;1,1,0,0,0,1;1,1,0,1,1,0"}, {"input": {"board": "1,0,0,1,1;0,1,0,0,1;0,0,1,0,0;0,0,1,1,1"}, "output": "0,0,0,1,1;0,1,1,0,1;0,1,1,0,1;0,0,1,1,0"}, {"input": {"board": "1,0,0,1,0;1,1,1,0,0;1,0,1,0,0;1,0,1,0,0;0,0,0,1,1;0,0,0,1,0;0,1,1,0,0;0,1,1,0,1;0,0,1,0,1"}, "output": "1,0,1,0,0;1,0,1,1,0;1,0,1,1,0;0,0,1,0,0;0,0,1,1,1;0,0,0,1,1;0,1,0,0,0;0,0,0,0,0;0,1,1,0,0"}, {"input": {"board": "1,0,1,0;0,0,0,0;0,1,0,1;1,0,1,1;0,0,0,0;1,1,1,1;1,1,0,0;0,0,1,1;0,0,1,1;1,0,1,0"}, "output": "0,0,0,0;0,1,1,0;0,1,0,1;0,1,1,1;1,0,0,0;1,0,1,0;1,0,0,0;0,0,0,1;0,0,0,0;0,1,1,1"}, {"input": {"board": "1,1,0,1,0,1,1,1,1,1;1,0,1,1,0,1,0,1,0,1;0,1,0,0,1,1,1,1,1,1;0,0,1,1,1,0,0,1,1,0"}, "output": "1,1,0,1,0,1,0,1,0,1;1,0,0,1,0,0,0,0,0,0;0,1,0,0,0,0,0,0,0,1;0,0,1,1,1,0,0,0,0,1"}, {"input": {"board": "0,1,1;1,0,0;0,1,1;0,0,0;0,0,1;1,1,1;0,0,1"}, "output": "0,1,0;1,0,0;0,1,0;0,1,1;0,0,1;0,0,1;0,0,1"}, {"input": {"board": "0,1,0,0,0,1,0,1,0,1;0,1,1,0,0,0,1,1,0,0;0,1,1,1,1,1,0,1,1,1"}, "output": "0,1,1,0,0,0,0,1,1,0;1,0,0,0,0,0,0,0,0,1;0,1,0,1,1,1,0,1,1,0"}], "error_log": []}
{"context": "Given the historical information about the Gregorian calendar, how many Sundays fell on the first of the month between the years `start_year` and `end_year`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start_year` (int): The starting year of the period to count Sundays on the first of the month.\n  `end_year` (int): The ending year of the period to count Sundays on the first of the month.\n\nOutput:\n  `return` (int): The number of Sundays that fell on the first of the month during the specified period.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndays_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n# main function\ndef main_solution(start_year, end_year):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    day = 6\n    month = 1\n    year = start_year\n    sundays = 0\n\n    while year <= end_year:\n        day += 7\n\n        if (year % 4 == 0 and not year % 100 == 0) or (year % 400 == 0):\n            if day > days_per_month[month - 1] and month != 2:\n                month += 1\n                day = day - days_per_month[month - 2]\n            elif day > 29 and month == 2:\n                month += 1\n                day = day - 29\n        else:\n            if day > days_per_month[month - 1]:\n                month += 1\n                day = day - days_per_month[month - 2]\n        \n        if month > 12:\n            year += 1\n            month = 1\n\n        if year <= end_year and day == 1:\n            sundays += 1\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sundays", "input_generator": "import random\n\ndef input_generator():\n    start_year = random.randint(1900, 2000)\n    end_year = start_year + random.randint(1, 100)\n    return {'start_year': start_year, 'end_year': end_year}", "io_pairs": [{"input": {"start_year": 1978, "end_year": 2019}, "output": 73}, {"input": {"start_year": 1957, "end_year": 1961}, "output": 9}, {"input": {"start_year": 1954, "end_year": 1966}, "output": 22}, {"input": {"start_year": 1946, "end_year": 1951}, "output": 10}, {"input": {"start_year": 1909, "end_year": 2002}, "output": 161}, {"input": {"start_year": 1964, "end_year": 2049}, "output": 148}, {"input": {"start_year": 1909, "end_year": 1952}, "output": 75}, {"input": {"start_year": 1968, "end_year": 2012}, "output": 78}, {"input": {"start_year": 1915, "end_year": 1976}, "output": 106}, {"input": {"start_year": 1971, "end_year": 2047}, "output": 130}], "error_log": []}
{"context": "Given a non-negative number, how can we approximate its square root using the Newton-Raphson method? Specifically, what is the approximate square root of the given number after 20 iterations of the method?\n\nThe input and output requirements are as follows:\n\nInput:\n  `y` (float): The number for which the square root is to be calculated. Must be a non-negative number.\n\nOutput:\n  `return` (float): The approximate square root of the input number `y`, rounded to 6 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef funcao(x, y):\n    f = x * x - y\n    return f\n\ndef derivada(x):\n    d = 2 * x\n    return d\n\n# main function\ndef main_solution(y):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if y < 0:\n        raise ValueError(\"Input must be a non-negative number\")\n    \n    x = y / 2\n    aprox = 1\n    while aprox <= 20:\n        f = funcao(x, y)\n        d = derivada(x)\n        x = x - f / d\n        aprox = aprox + 1\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return round(x, 6)", "input_generator": "import random\n\ndef input_generator():\n    y = random.uniform(0, 1000)  # Generate a random non-negative float\n    return {'y': y}", "io_pairs": [{"input": {"y": 126.27305638241081}, "output": 11.237128}, {"input": {"y": 621.1836923090138}, "output": 24.923557}, {"input": {"y": 462.8299250120157}, "output": 21.513482}, {"input": {"y": 791.6603724384249}, "output": 28.13646}, {"input": {"y": 292.7324247280819}, "output": 17.109425}, {"input": {"y": 907.6685188686223}, "output": 30.127538}, {"input": {"y": 692.6211032375786}, "output": 26.317696}, {"input": {"y": 687.8108048964737}, "output": 26.226147}, {"input": {"y": 490.8118413443003}, "output": 22.154274}, {"input": {"y": 588.7957200032222}, "output": 24.265113}], "error_log": []}
{"context": "A father has a collection of coins with different values. He wants to distribute these coins equally among his three children. Given the list of coin values, can you determine if it is possible to distribute the coins such that each child receives the same total value of coins?\n\nThe input and output requirements are as follows:\n\nInput:\n  `coins` (list of integers): A list of positive integers representing the values of the coins to be distributed among three children.\n\nOutput:\n  `return` (boolean): `True` if the coins can be distributed equally among the three children, otherwise `False`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef subsetSum(lst, n, a, b, c):\n    if a == b == c == 0:\n        return True\n    if n < 0:\n        return False\n    A = False\n    if a - lst[n] >= 0:\n        A = subsetSum(lst, n - 1, a - lst[n], b, c)\n    B = False\n    if not A and b - lst[n] >= 0:\n        B = subsetSum(lst, n - 1, a, b - lst[n], c)\n    C = False\n    if not A and not B and c - lst[n] >= 0:\n        C = subsetSum(lst, n - 1, a, b, c - lst[n])\n    return A or B or C\n        \ndef coins_div(lst):\n    S = sum(lst)\n    if S % 3 != 0:\n        return False\n    S3 = S // 3\n    n = len(lst)\n    return subsetSum(lst, n - 1, S3, S3, S3)\n\n# main function\ndef main_solution(coins):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # convert the JSON serializable input to the original input variables\n    coins = list(coins)\n    \n    # call the original function\n    result = coins_div(coins)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Randomly decide whether to generate a list divisible by 3 or not\n    if random.choice([True, False]):\n        # Generate a list whose sum is divisible by 3\n        n = random.randint(3, 10)\n        lst = [random.randint(1, 10) for _ in range(n)]\n        total = sum(lst)\n        remainder = total % 3\n        if remainder != 0:\n            # Adjust the last element to make the sum divisible by 3\n            lst[-1] += (3 - remainder)\n    else:\n        # Generate a list whose sum is not divisible by 3\n        n = random.randint(3, 10)\n        lst = [random.randint(1, 10) for _ in range(n)]\n        total = sum(lst)\n        if total % 3 == 0:\n            # Adjust the last element to make the sum not divisible by 3\n            lst[-1] += 1\n    \n    return {'coins': lst}", "io_pairs": [{"input": {"coins": [8, 7, 9, 4, 6, 2, 10, 1, 5, 9]}, "output": false}, {"input": {"coins": [10, 4, 7]}, "output": false}, {"input": {"coins": [10, 8, 2, 1, 1, 7]}, "output": false}, {"input": {"coins": [6, 1, 3, 2, 9, 7, 6, 11]}, "output": true}, {"input": {"coins": [8, 5, 8]}, "output": false}, {"input": {"coins": [5, 5, 2, 7, 5, 7]}, "output": false}, {"input": {"coins": [6, 6, 1, 4, 10]}, "output": false}, {"input": {"coins": [5, 9, 4]}, "output": false}, {"input": {"coins": [2, 10, 3]}, "output": false}, {"input": {"coins": [2, 9, 6, 6, 4]}, "output": false}], "error_log": []}
{"context": "Given a list of nodes and a list of directed edges with weights, how would you represent the graph as an adjacency matrix? The adjacency matrix should indicate the weight of the edge between any two nodes, with `inf` representing no direct edge between the nodes.\n\nThe input and output requirements are as follows:\n\nInput:\n- `nodes` (list of str): List of node names in lexicographical order.\n- `edges` (list of tuples): List of edges where each tuple is (src, dst, weight). Each `src` and `dst` is a node name (str), and `weight` is an integer.\n\nOutput:\n- `return` (list of lists of int): Adjacency matrix representing the graph. Each element in the matrix is either an integer (weight of the edge) or `inf` if there is no edge between the nodes.", "reference_code": "# import necessary packages\nimport random\nfrom math import inf\n\n# all class and function definitions in the code file, if any\nclass AdjacencyList:\n    def __init__(self, name=None, info=None):\n        self._name = name\n        self._info = info\n        if not self.head().is_empty():\n            self._tail = AdjacencyList()\n            self._edges = Edge()\n\n    def is_empty(self):\n        return self._name is None\n\n    def head(self):\n        return self\n\n    def tail(self):\n        return self._tail\n\n    def cons(self, tail):\n        self._tail = tail\n        return self.head()\n\n    def name(self):\n        return self._name\n\n    def info(self):\n        return self._info\n\n    def edges(self):\n        return self._edges\n\n    def set_name(self, name):\n        self._name = name\n        return self.head()\n\n    def set_info(self, info):\n        self._info = info\n        return self.head()\n\n    def set_edges(self, edges):\n        self._edges = edges\n        return self.head()\n\n    def add_node(self, name, info=None):\n        if self.find_node(name):\n            if name == self.head().name():\n                self.head().set_info(info)\n                return self.head()\n            else:\n                self.tail().add_node(name, info)\n\n        elif self.is_empty():\n            self.head().__init__(name, info)\n            return self.head()\n\n        elif name < self.name():\n            nextNode = self.head()\n            newNode = AdjacencyList(name, info)\n            return newNode.head().cons(nextNode)\n\n        else:\n            return self.cons(self.tail().add_node(name, info))\n\n    def find_node(self, name):\n        if self.is_empty():\n            return False\n        if name == self.head().name():\n            return True\n        return self.tail().find_node(name)\n\n    def node_cardinality(self):\n        if self.is_empty():\n            return 0\n        else:\n            return 1 + self.tail().node_cardinality()\n\n    def add_edge(self, src, dst, weight=1):\n        if not self.find_node(dst):\n            return self.head()\n        return self._add_edge(src, dst, weight)\n\n    def _add_edge(self, src, dst, weight):\n        if self.is_empty():\n            return self.head()\n\n        if src == self.head().name():\n            return self.set_edges(self.edges().add(dst, weight))\n             \n        else:\n            return self.cons(self.tail()._add_edge(src, dst, weight))\n\n    def find_edge(self, src, dst):\n        if self.is_empty():\n            return False\n        if src == self.head().name() and self.head().edges().find(dst):\n            return True\n        else:\n            return self.tail().find_edge(src, dst)\n\n    def adjacency_matrix(self):\n        if self.is_empty():\n            return [[]]\n\n        n = self.node_cardinality()\n        matrix = [[inf] * n for i in range(n)]\n\n        nodeIndex = 0\n        node = self.head()\n\n        while not node.is_empty():\n            edge = node.edges()\n            while not edge.is_empty():\n                edgeIndex = self._findIndex(edge.dst())\n                matrix[nodeIndex][edgeIndex] = edge.weight()\n                edge = edge.tail()\n            nodeIndex += 1\n            node = node.tail()\n\n        return matrix\n\n    def _findIndex(self, des):\n        for index, name in enumerate(self.list_nodes()):\n            if name == des:\n                return index\n        return None\n\n    def list_nodes(self):\n        head, node_names = self.head(), []\n        while not head.is_empty():\n            node_names += [head.name()]\n            head = head.tail()\n        return node_names\n\nclass Edge:\n    def __init__(self, dst=None, weight=1):\n        self._dst = dst\n        self._weight = weight\n        if not self.head().is_empty():\n            self._tail = Edge()\n\n    def is_empty(self):\n        return self._dst is None\n\n    def head(self):\n        return self\n\n    def tail(self):\n        return self._tail\n\n    def cons(self, tail):\n        self._tail = tail\n        return self.head()\n\n    def dst(self):\n        return self._dst\n\n    def weight(self):\n        return self._weight\n\n    def set_dst(self, dst):\n        self._dst = dst\n        return self.head()\n\n    def set_weight(self, weight):\n        self._weight = weight\n        return self.head()\n\n    def add(self, dst, weight=1):\n        if self.is_empty():\n            self.__init__(dst, weight)\n            return self.head()\n        elif dst == self.head().dst():\n            return self.set_weight(weight)\n        elif dst < self.head().dst():\n            nextNode = self.head()\n            newNode = Edge(dst, weight)\n            return newNode.head().cons(nextNode)\n        else:\n            return self.head().cons(self.tail().add(dst, weight))\n\n    def find(self, dst):\n        if self.head().is_empty():\n            return False\n        if dst == self.head().dst():\n            return True\n        else:\n            return self.tail().find(dst)\n\n# main function\ndef main_solution(nodes, edges):\n    \"\"\"\n    Generates an adjacency matrix from a list of nodes and edges.\n\n    Input:\n    - nodes (list of str): List of node names.\n    - edges (list of tuples): List of edges where each tuple is (src, dst, weight).\n\n    Output:\n    - return (list of lists of int): Adjacency matrix representing the graph.\n    \"\"\"\n    graph = AdjacencyList()\n    for node in nodes:\n        graph.add_node(node)\n    for src, dst, weight in edges:\n        graph.add_edge(src, dst, weight)\n    return graph.adjacency_matrix()", "input_generator": "import random\nfrom math import inf\n\ndef input_generator():\n    # Generate a random number of nodes between 2 and 10\n    num_nodes = random.randint(2, 10)\n    nodes = [f\"Node_{i}\" for i in range(num_nodes)]\n    \n    # Generate a random number of edges between 1 and 20\n    num_edges = random.randint(1, 20)\n    edges = []\n    for _ in range(num_edges):\n        src = random.choice(nodes)\n        dst = random.choice(nodes)\n        weight = random.randint(1, 100)\n        edges.append((src, dst, weight))\n    \n    return {\"nodes\": nodes, \"edges\": edges}", "io_pairs": [{"input": {"nodes": ["Node_0", "Node_1", "Node_2", "Node_3", "Node_4"], "edges": [["Node_0", "Node_4", 47]]}, "output": [[Infinity, Infinity, Infinity, Infinity, 47], [Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity]]}, {"input": {"nodes": ["Node_0", "Node_1", "Node_2", "Node_3", "Node_4", "Node_5", "Node_6"], "edges": [["Node_6", "Node_6", 53]]}, "output": [[Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, 53]]}, {"input": {"nodes": ["Node_0", "Node_1", "Node_2"], "edges": [["Node_2", "Node_2", 49]]}, "output": [[Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity], [Infinity, Infinity, 49]]}, {"input": {"nodes": ["Node_0", "Node_1", "Node_2"], "edges": [["Node_0", "Node_2", 37], ["Node_2", "Node_0", 91], ["Node_1", "Node_1", 74]]}, "output": [[Infinity, Infinity, 37], [Infinity, 74, Infinity], [91, Infinity, Infinity]]}, {"input": {"nodes": ["Node_0", "Node_1"], "edges": [["Node_0", "Node_0", 10]]}, "output": [[10, Infinity], [Infinity, Infinity]]}, {"input": {"nodes": ["Node_0", "Node_1", "Node_2", "Node_3"], "edges": [["Node_0", "Node_2", 26]]}, "output": [[Infinity, Infinity, 26, Infinity], [Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity]]}, {"input": {"nodes": ["Node_0", "Node_1"], "edges": [["Node_0", "Node_1", 34], ["Node_1", "Node_1", 48]]}, "output": [[Infinity, 34], [Infinity, 48]]}, {"input": {"nodes": ["Node_0", "Node_1", "Node_2", "Node_3", "Node_4", "Node_5", "Node_6"], "edges": [["Node_0", "Node_0", 62]]}, "output": [[62, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity]]}, {"input": {"nodes": ["Node_0", "Node_1", "Node_2", "Node_3"], "edges": [["Node_2", "Node_3", 25]]}, "output": [[Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, Infinity], [Infinity, Infinity, Infinity, 25], [Infinity, Infinity, Infinity, Infinity]]}, {"input": {"nodes": ["Node_0", "Node_1", "Node_2"], "edges": [["Node_1", "Node_1", 1], ["Node_1", "Node_0", 15]]}, "output": [[Infinity, Infinity, Infinity], [15, 1, Infinity], [Infinity, Infinity, Infinity]]}], "error_log": []}
{"context": "In the ancient tale of Josephus, a group of soldiers found themselves trapped and decided to form a circle to eliminate every k-th person until only one remained. Given a list of items representing the soldiers and a step count k, what is the order in which the items are removed from the circle?\n\nThe input and output requirements are as follows:\n\nInput:\n  `items` (list of any JSON serializable types): The initial sequence of items to be permuted.\n  `k` (int): The step count for elimination, always greater than or equal to 1.\n\nOutput:\n  `return` (list of any JSON serializable types): The Josephus permutation of the input list, where every k-th item is removed until none remain.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef josephus(items, k):\n    if items:\n        out = []\n        k -= 1  # fix the indexes (k=3 (position) => idx=2)\n        idx = k\n        while len(items) > 1:\n            out.append(items.pop(idx))\n            idx = (idx + k) % len(items)\n\n        out.append(items.pop(0))\n        return out\n    else:\n        return items\n\n# main function\ndef main_solution(items, k):\n    # Convert input to JSON serializable format if necessary\n    items = list(items)  # Ensure items is a list\n    k = int(k)  # Ensure k is an integer\n    \n    # Call the josephus function\n    result = josephus(items, k)\n    \n    # Convert output to JSON serializable format if necessary\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Randomly choose between generating a list of integers or strings\n    if random.choice([True, False]):\n        # Generate a list of random integers\n        items = random.sample(range(1, 100), random.randint(5, 20))\n    else:\n        # Generate a list of random strings\n        letters = 'abcdefghijklmnopqrstuvwxyz'\n        items = [''.join(random.sample(letters, random.randint(1, 5))) for _ in range(random.randint(5, 20))]\n    \n    # Generate a random k between 2 and len(items) to avoid trivial cases\n    k = random.randint(2, len(items))\n    \n    return {'items': items, 'k': k}", "io_pairs": [{"input": {"items": ["nbd", "ijyv", "sip", "btdy", "gm"], "k": 3}, "output": ["sip", "nbd", "gm", "ijyv", "btdy"]}, {"input": {"items": [62, 18, 48, 87, 64, 16, 26, 29, 40, 38, 37, 59, 85, 86], "k": 5}, "output": [64, 38, 62, 26, 85, 16, 86, 40, 87, 48, 29, 59, 18, 37]}, {"input": {"items": ["msqv", "e", "yvhwm", "xbks", "hj", "tuw", "krt", "dym", "l"], "k": 7}, "output": ["krt", "hj", "xbks", "tuw", "l", "yvhwm", "dym", "msqv", "e"]}, {"input": {"items": [70, 51, 55, 37, 71, 23], "k": 5}, "output": [71, 37, 23, 51, 55, 70]}, {"input": {"items": ["lmnvh", "ycvi", "b", "u", "w", "gl"], "k": 2}, "output": ["ycvi", "u", "gl", "b", "lmnvh", "w"]}, {"input": {"items": ["cp", "k", "txk", "qaef", "l", "kg", "opmd", "tx", "nu"], "k": 6}, "output": ["kg", "txk", "cp", "nu", "k", "l", "qaef", "tx", "opmd"]}, {"input": {"items": [20, 23, 18, 2, 93, 13, 53, 60], "k": 4}, "output": [2, 60, 93, 23, 20, 18, 53, 13]}, {"input": {"items": [66, 22, 42, 1, 98, 81, 99, 63], "k": 4}, "output": [1, 63, 98, 22, 66, 42, 99, 81]}, {"input": {"items": [45, 68, 53, 84, 26, 49, 77, 66, 98, 19, 73, 76, 85], "k": 12}, "output": [76, 73, 85, 68, 26, 98, 49, 84, 66, 77, 53, 45, 19]}, {"input": {"items": [63, 50, 65, 9, 18, 11, 87, 67, 72, 49, 90, 61, 68, 58], "k": 5}, "output": [18, 49, 63, 87, 68, 11, 58, 72, 9, 65, 67, 61, 50, 90]}], "error_log": []}
{"context": "Imagine a robot is placed in a grid-like environment with certain cells marked as \"off limits\". The robot can only move right or down. Given the dimensions of the grid and the locations of the \"off limits\" cells, can you determine the path the robot should take to move from the top-left corner to the bottom-right corner? If a path exists, what is the sequence of coordinates the robot should follow?\n\nThe input and output requirements are as follows:\n\nInput:\n  `grid` (list of lists of integers): A 2D grid representing the robot's environment. Each cell can be either 0 (free to move) or -1 (off limits).\n  `r` (integer): The number of rows in the grid.\n  `c` (integer): The number of columns in the grid.\n\nOutput:\n  `return` (list of lists of integers or string): If a path exists, it returns a list of coordinates (each coordinate is a list of two integers) representing the path from the top-left to the bottom-right of the grid. If no path exists, it returns the string \"There is no path\". If the start or end is blocked, it returns the string \"It's not possible to find a path\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef check_path_exist(grid, r, c):\n    grid[0][0] = 1\n    # fill first column\n    for i in range(1, r):\n        if grid[i][0] == -1:\n            break\n        grid[i][0] = 1\n    # fill first row\n    for i in range(1, c):\n        if grid[0][i] == -1:\n            break\n        grid[0][i] = 1\n    for i in range(1, r):\n        for j in range(1, c):\n            if grid[i][j] != -1 and (grid[i-1][j] != -1 or grid[i][j-1] != -1):\n                grid[i][j] = 1\n    if grid[-1][-1] == 1:\n        return True\n    return False\n\ndef get_path(grid, r, c, path):\n    if r == 0 and c == 0:\n        path.append([0, 0])\n        return\n    if r == 0:\n        path.append([0, c])\n        get_path(grid, 0, c-1, path)\n    elif c == 0:\n        path.append([r, 0])\n        get_path(grid, r-1, 0, path)\n    else:\n        path.append([r, c])\n        if grid[r-1][c] == 1:\n            get_path(grid, r-1, c, path)\n        else:\n            get_path(grid, r, c-1, path)\n\n# main function\ndef main_solution(grid, r, c):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if grid is None or grid[0][0] == -1 or grid[-1][-1] == -1:\n        return \"It's not possible to find a path\"\n    if check_path_exist(grid, r, c):\n        path = []\n        get_path(grid, r-1, c-1, path)\n        return path\n    else:\n        return 'There is no path'", "input_generator": "import random\n\ndef input_generator():\n    r = random.randint(2, 10)\n    c = random.randint(2, 10)\n    grid = [[0 for _ in range(c)] for _ in range(r)]\n    \n    # Randomly place obstacles (-1) with a 20% probability for each cell\n    for i in range(r):\n        for j in range(c):\n            if random.random() < 0.2:\n                grid[i][j] = -1\n    \n    # Ensure start and end are not blocked\n    grid[0][0] = 0\n    grid[-1][-1] = 0\n    \n    return {'grid': grid, 'r': r, 'c': c}", "io_pairs": [{"input": {"grid": [[1, 1, 1, 1, 1, 1, 1], [-1, -1, -1, -1, -1, 1, 1]], "r": 2, "c": 7}, "output": [[1, 6], [0, 6], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0]]}, {"input": {"grid": [[1, -1, 0, 0, 0, 0, 0], [1, 1, 1, -1, 1, 1, 1]], "r": 2, "c": 7}, "output": [[1, 6], [1, 5], [1, 4], [1, 3], [1, 2], [1, 1], [1, 0], [0, 0]]}, {"input": {"grid": [[1, 1, 1], [1, 1, 1], [1, 1, 1]], "r": 3, "c": 3}, "output": [[2, 2], [1, 2], [0, 2], [0, 1], [0, 0]]}, {"input": {"grid": [[1, 1, 1, -1], [1, 1, -1, 0], [1, 1, -1, 1], [1, 1, -1, 1]], "r": 4, "c": 4}, "output": [[3, 3], [2, 3], [2, 2], [2, 1], [1, 1], [0, 1], [0, 0]]}, {"input": {"grid": [[1, 1, 1, 1, 1], [-1, 1, 1, 1, 1]], "r": 2, "c": 5}, "output": [[1, 4], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0]]}, {"input": {"grid": [[1, -1, 0], [1, 1, -1], [1, 1, 1]], "r": 3, "c": 3}, "output": [[2, 2], [2, 1], [1, 1], [1, 0], [0, 0]]}, {"input": {"grid": [[1, 1, 1, -1, 0, -1], [1, 1, 1, 1, -1, 0]], "r": 2, "c": 6}, "output": "There is no path"}, {"input": {"grid": [[1, 1], [1, -1], [1, 1]], "r": 3, "c": 2}, "output": [[2, 1], [2, 0], [1, 0], [0, 0]]}, {"input": {"grid": [[1, 1, 1], [1, 1, 1]], "r": 2, "c": 3}, "output": [[1, 2], [0, 2], [0, 1], [0, 0]]}, {"input": {"grid": [[1, -1, -1, 0, 0, 0], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], "r": 3, "c": 6}, "output": [[2, 5], [1, 5], [1, 4], [1, 3], [1, 2], [1, 1], [1, 0], [0, 0]]}], "error_log": []}
{"context": "Given a Tic Tac Toe board with a specific configuration and a player's piece, what is the optimal move and its associated score according to the minimax algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  - `board_state` (list of int): A list of length 9 representing the current state of the Tic Tac Toe board. Each element can be 0 (empty), 1 (player's piece), or -1 (opponent's piece).\n  - `player_piece` (str): A string representing the piece ('X' or 'O') that the player is using.\n\nOutput:\n  - `return` (dict): A dictionary with the following keys:\n    - `best_move` (int): The index (0-8) of the best move on the board.\n    - `best_score` (int): The score associated with the best move. The score can be 1 (win), -1 (loss), or 0 (tie).", "reference_code": "# import necessary packages\nimport random\n\n# Constants\nNONE = 0\nME = 1\nENEMY = -1\n\n# Function to check victory\ndef check_victory(values):\n    \"\"\"Checks for victory of any of the players\"\"\"\n    for i in range(3):\n        if values[3*i] == values[3*i+1] == values[3*i+2] != NONE: #Horizontal\n            return values[3*i]\n        if values[i] == values[i+3] == values[i+6] != NONE: #Vertical\n            return values[i]\n    if values[0] == values[4] == values[8] != NONE: #Diagonal (\\)\n        return values[0]\n    if values[2] == values[4] == values[6] != NONE: #Other diagonal (/)\n        return values[2]\n    return NONE #No victory yet\n\n# Function to check tie\ndef check_tie(values):\n    \"\"\"Checks for ties\"\"\"\n    for v in values:\n        if v == NONE:\n            return False\n    return True\n\n# Minimax algorithm\ndef minmax(values, player, play = 0):\n    \"\"\"Runs the minimax algorithm for the whole game\"\"\"\n    res = check_victory(values) #One player won\n    if res != NONE:\n        return res, play\n    if check_tie(values): #Tie\n        return NONE, play\n    best_play = 0\n    best_score = -2 #Scores always bigger than -2, so this value will always change\n    for i in range(9): #Test all possible places\n        if values[i] != NONE: #Place already occupied\n            continue\n        values2 = values[:]\n        values2[i] = player\n        res, _ = minmax(values2, -player, i) #Try this place\n        if res*player > best_score: #res = 1 if ME won, -1 if ENEMY won, 0 if tie. If player is ENEMY, -1 is good, and so we change signs (*player)\n            best_play = i\n            best_score = res*player\n    return best_score*player, best_play #best_score*player because ENEMY swaps signs\n\n# Main function\ndef main_solution(board_state, player_piece):\n    \"\"\"\n    Determines the best move for the given board state and player piece using the minimax algorithm.\n    \n    Input:\n    - board_state (list of int): A list representing the current state of the Tic Tac Toe board. Each element can be 0 (empty), 1 (player's piece), or -1 (opponent's piece).\n    - player_piece (str): The piece ('X' or 'O') that the player is using.\n    \n    Output:\n    - return (dict): A dictionary with the keys 'best_move' (int) and 'best_score' (int). 'best_move' is the index of the best move on the board, and 'best_score' is the score associated with that move.\n    \"\"\"\n    # Determine the player value based on the piece\n    player_value = ME if player_piece == 'X' else ENEMY\n    \n    # Run the minimax algorithm to get the best move and score\n    best_score, best_move = minmax(board_state, player_value)\n    \n    # Return the result as a dictionary\n    return {'best_move': best_move, 'best_score': best_score}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random board state with 0 (empty), 1 (X), or -1 (O)\n    board_state = [random.choice([0, 1, -1]) for _ in range(9)]\n    \n    # Ensure the board is not already in a terminal state (win or tie)\n    while check_victory(board_state) != NONE or check_tie(board_state):\n        board_state = [random.choice([0, 1, -1]) for _ in range(9)]\n    \n    # Randomly choose the player's piece ('X' or 'O')\n    player_piece = random.choice(['X', 'O'])\n    \n    return {'board_state': board_state, 'player_piece': player_piece}", "io_pairs": [{"input": {"board_state": [0, 1, 1, 1, 0, 0, 0, 1, -1], "player_piece": "O"}, "output": {"best_move": 0, "best_score": 1}}, {"input": {"board_state": [1, -1, 0, 1, -1, 1, -1, 1, 1], "player_piece": "O"}, "output": {"best_move": 2, "best_score": -1}}, {"input": {"board_state": [0, 0, -1, 0, -1, 1, 0, 0, 1], "player_piece": "X"}, "output": {"best_move": 6, "best_score": 0}}, {"input": {"board_state": [0, 0, 1, -1, 0, 1, 1, -1, -1], "player_piece": "X"}, "output": {"best_move": 0, "best_score": 1}}, {"input": {"board_state": [-1, 0, -1, -1, 0, 1, 1, -1, 1], "player_piece": "O"}, "output": {"best_move": 1, "best_score": -1}}, {"input": {"board_state": [-1, -1, 0, 0, -1, 0, -1, 1, 0], "player_piece": "X"}, "output": {"best_move": 2, "best_score": -1}}, {"input": {"board_state": [0, 1, -1, 0, 1, 1, 1, 0, 0], "player_piece": "X"}, "output": {"best_move": 0, "best_score": 1}}, {"input": {"board_state": [0, 1, -1, 1, -1, 0, 0, 0, 0], "player_piece": "X"}, "output": {"best_move": 6, "best_score": 0}}, {"input": {"board_state": [1, 0, -1, 0, 0, -1, 0, 0, 1], "player_piece": "O"}, "output": {"best_move": 4, "best_score": -1}}, {"input": {"board_state": [-1, 1, 0, 0, 1, 1, 0, 0, 1], "player_piece": "X"}, "output": {"best_move": 2, "best_score": 1}}], "error_log": []}
{"context": "A gambler is playing a series of coin toss games against a friend. Each round, the gambler's capital changes based on the outcome of a coin toss: if it's heads, the gambler gains a certain percentage of their current capital, and if it's tails, they lose a different percentage. Given the initial capital, the number of rounds, and the percentages for gain and loss, what will be the evolution of the gambler's capital after the specified number of rounds, and what are the theoretical expectation and median of the gambler's capital after these rounds?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_capital` (float): The initial capital of the gambler.\n  `n_rounds` (int): The number of rounds the gambler will play.\n  `gain` (float): The percentage gain when the coin comes up heads.\n  `loss` (float): The percentage loss when the coin comes up tails.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `final_capital_evolution` (list of floats): The evolution of the gambler's capital after each round.\n    - `theoretical_expectation` (float): The theoretical expectation of the gambler's capital after `n_rounds`.\n    - `theoretical_median` (float): The theoretical median of the gambler's capital after `n_rounds`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef game_round(capital, gain, loss):\n    # Toss a coin\n    toss = np.random.choice([0, 1], 1, replace=False)\n\n    if toss == 0:\n        capital *= 1. + gain\n    if toss == 1:\n        capital *= 1. - loss\n\n    return capital\n\ndef play_n_games(initial_capital, n_rounds, gain, loss):\n    capital = initial_capital\n    capital_evolution = []\n    for k in range(n_rounds):\n        capital = game_round(capital, gain, loss)\n        if capital <= 0.0:\n            capital_evolution.append(0.0)\n            break\n        if capital > 0.0:\n            capital_evolution.append(capital)\n\n    return capital_evolution\n\ndef expectation(initial_capital, n_rounds, gain, loss):\n    # Analytic formula for the Expectation\n    exp = initial_capital * (1 + (gain - loss) / 2) ** n_rounds\n    return exp\n\ndef median_theor(initial_capital, n_rounds, gain, loss):\n    # Analytic formula for the Median\n    med = initial_capital / 2 * (1 + gain) * (1 - loss) * ((1 - loss) ** (n_rounds - 2) + (1 + gain) ** (n_rounds - 2))\n    return med\n\n# main function\ndef main_solution(initial_capital, n_rounds, gain, loss):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # Convert JSON serializable inputs to the required format\n    initial_capital = float(initial_capital)\n    n_rounds = int(n_rounds)\n    gain = float(gain)\n    loss = float(loss)\n\n    # Play the game and get the final capital evolution\n    capital_evolution = play_n_games(initial_capital, n_rounds, gain, loss)\n\n    # Calculate the theoretical expectation and median\n    theo_exp = expectation(initial_capital, n_rounds, gain, loss)\n    theo_med = median_theor(initial_capital, n_rounds, gain, loss)\n\n    # Return the final output, which must be json serializable\n    return {\n        \"final_capital_evolution\": capital_evolution,\n        \"theoretical_expectation\": theo_exp,\n        \"theoretical_median\": theo_med\n    }", "input_generator": "import numpy as np\n\ndef input_generator():\n    initial_capital = np.random.uniform(100, 10000)\n    n_rounds = np.random.randint(5, 50)\n    gain = np.random.uniform(0.01, 0.5)\n    loss = np.random.uniform(0.01, 0.5)\n    return {\n        \"initial_capital\": initial_capital,\n        \"n_rounds\": n_rounds,\n        \"gain\": gain,\n        \"loss\": loss\n    }", "io_pairs": [{"input": {"initial_capital": 3585.328032170173, "n_rounds": 13, "gain": 0.08526547636956235, "loss": 0.4996412397455923}, "output": {"final_capital_evolution": [3891.0327347743087, 1946.9123152809907, 2112.916721293192, 1057.2163911870696, 1147.3604504073446, 1245.1906857789224, 1351.3624627728043, 1466.5870269090724, 1591.6362683958946, 1727.347893027743, 1874.6310339827135, 2034.4723421124147, 2207.942595523329], "theoretical_expectation": 175.28410453605815, "theoretical_median": 2394.964865523051}}, {"input": {"initial_capital": 4579.037606481934, "n_rounds": 5, "gain": 0.06851930494313212, "loss": 0.13101178876155067}, "output": {"final_capital_evolution": [4892.790080586539, 4251.776900094124, 4543.105698061839, 3947.9052940259635, 4218.413020753934], "theoretical_expectation": 3906.9802125440283, "theoretical_median": 3988.5334339192636}}, {"input": {"initial_capital": 3313.185267172443, "n_rounds": 7, "gain": 0.34044883501871304, "loss": 0.32575422483508604}, "output": {"final_capital_evolution": [4441.155331582466, 2994.4302191706106, 2018.9819243019317, 2706.341968354364, 1824.7396383144273, 1230.3229919094558, 1649.1850212017678], "theoretical_expectation": 3487.388442921787, "theoretical_median": 6688.038549303007}}, {"input": {"initial_capital": 8337.275355696876, "n_rounds": 6, "gain": 0.04794909718590547, "loss": 0.3421735469791352}, "output": {"final_capital_evolution": [5484.480275096345, 3607.836206029526, 2373.3300944926573, 2487.12912984772, 1636.0993336925956, 1076.2694214728006], "theoretical_expectation": 3209.0425977412337, "theoretical_median": 4003.958053864603}}, {"input": {"initial_capital": 7232.7474142111605, "n_rounds": 10, "gain": 0.3957723330414363, "loss": 0.27069534517875254}, "output": {"final_capital_evolution": [5274.87635633054, 7362.526478380588, 5369.524831927649, 3916.0194541031105, 5465.87160968915, 3986.285607601602, 2907.2166490707928, 4057.8125649304466, 2959.3815919959197, 2158.2907704349377], "theoretical_expectation": 13266.306478339115, "theoretical_median": 53323.639157165904}}, {"input": {"initial_capital": 4093.0082846207433, "n_rounds": 6, "gain": 0.39537679093289724, "loss": 0.2790617630238046}, "output": {"final_capital_evolution": [5711.288765455854, 7969.399789632898, 5745.445034096404, 4142.111013525098, 2986.206211450466, 2152.8702413304627], "theoretical_expectation": 5745.721147748584, "theoretical_median": 8361.06793209163}}, {"input": {"initial_capital": 6771.590526078789, "n_rounds": 10, "gain": 0.030427908239410092, "loss": 0.1976485835684213}, "output": {"final_capital_evolution": [5433.195250093975, 5598.516016610633, 4491.977255842421, 3604.1443138036025, 2891.790295204141, 2320.2320393801356, 2390.8318469685337, 1918.2873188649305, 1539.1405474140124, 1234.9315983049082], "theoretical_expectation": 2828.0852843656053, "theoretical_median": 4038.6138139817604}}, {"input": {"initial_capital": 2525.512635880289, "n_rounds": 7, "gain": 0.4126812793170175, "loss": 0.04324362222426951}, "output": {"final_capital_evolution": [2416.300321531663, 3413.462229435471, 3265.8517583089506, 4613.607639987619, 6517.557143124476, 6235.714364202112, 5966.059487938105], "theoretical_expectation": 8272.87725139262, "theoretical_median": 10970.80888602529}}, {"input": {"initial_capital": 4265.81220272637, "n_rounds": 9, "gain": 0.2525921409589676, "loss": 0.26258424122369056}, "output": {"final_capital_evolution": [3145.677142270706, 2319.6718967328457, 1710.5626118413325, 1261.395826345362, 1580.014498718643, 1165.1275904501783, 1459.429663012352, 1076.206432330907, 793.6115828972409], "theoretical_expectation": 4077.791113986692, "theoretical_median": 9765.112122413871}}, {"input": {"initial_capital": 1817.993227160745, "n_rounds": 8, "gain": 0.44900733933255316, "loss": 0.13488636513558622}, "output": {"final_capital_evolution": [1572.7707289079178, 1360.6254020938823, 1177.095587294293, 1705.6201450853923, 2471.4561083421877, 2138.090377295768, 1849.6911379709677, 2680.2160344183144], "theoretical_expectation": 5840.375420566299, "theoretical_median": 11024.702585747882}}], "error_log": []}
{"context": "Given an encrypted message, how can we determine the top possible plain texts using a letter frequency attack? Specifically, what are the top `no_of_outcome` possible plain texts derived from the `encrypted_msg`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `encrypted_msg` (str): The encrypted message which we want to decrypt. It should be a string containing only lowercase letters and other characters (like spaces, symbols, and digits).\n  `no_of_outcome` (int): The total number of top possible plain texts we want. It should be a positive integer.\n\nOutput:\n  `return` (list of str): A list containing all possible plain texts in rough order of likelihood. Each plain text is a string.", "reference_code": "# import necessary packages\nfrom string import ascii_lowercase\n\n# main function\ndef main_solution(encrypted_msg, no_of_outcome):\n    # Default lower aphabate i.e abcdefghijklmnopqrstuvwxyz\n    alphabet = ascii_lowercase\n\n    # Store the frequency of each letter in encrypted text\n    freq = [0] * len(alphabet)\n\n    # Stores the frequency of each letter in encrypted text in descending order\n    freq_sorted = [0] * len(alphabet)\n\n    # Store which alphabet is used already\n    used_alphabet = [0] * len(alphabet)\n\n    #  Stores all final possible deciphered plaintext\n    plain_text = list()\n\n    # Traverse encrypted text\n    # and find frequency of each chiper text\n    # whitespace, symbol and digit are not included\n    for char in encrypted_msg:\n        if char in alphabet:\n            freq[alphabet.index(char)] += 1\n            freq_sorted[alphabet.index(char)] += 1\n\n    # Sort the frequency in descending order\n    freq_sorted.sort(reverse=True)\n\n    # letter frequenty used in english language\n    frequenty_used = \"etaoinshrdlcumwfgypbvkjxqz\"\n\n    # Itearate for all possible outcome\n    for i in range(no_of_outcome):\n        # Iterate over the range [0, 26]\n        for j in range(len(alphabet)):\n            if freq_sorted[i] == freq[j] and used_alphabet[j] != 1:\n                # letter 'e' used most in english letter so we used 'e' letter to find key to decrpty encrypted text\n                key = j - alphabet.index(frequenty_used[i])\n                used_alphabet[j] = 1\n\n        # Temporary string to generate one plaintext at a time\n        current_text = \"\"\n\n        # Generate the probable ith plaintext\n        # string using the key calculated above\n        for char in encrypted_msg:\n            if char in alphabet:\n                shift = (alphabet.index(char) - key) % len(alphabet)\n                current_text += alphabet[shift]\n            else:\n                current_text += char\n\n        plain_text.append(current_text)\n\n    return plain_text", "input_generator": "import random\nfrom string import ascii_lowercase\n\ndef input_generator():\n    # Common English words and phrases to generate reasonable encrypted messages\n    samples = [\n        \"the quick brown fox jumps over the lazy dog\",\n        \"hello world\",\n        \"python is a great programming language\",\n        \"encryption and decryption are interesting topics\",\n        \"frequency analysis is a common technique\"\n    ]\n    \n    # Select a random sample or create a mixed one\n    base_msg = random.choice(samples)\n    \n    # Randomly modify the message: add some noise, uppercase, or symbols\n    encrypted_msg = []\n    for char in base_msg:\n        if random.random() < 0.1:  # 10% chance to add noise\n            encrypted_msg.append(random.choice(ascii_lowercase))\n        else:\n            encrypted_msg.append(char)\n    encrypted_msg = ''.join(encrypted_msg)\n    \n    # Randomly choose no_of_outcome between 1 and 5\n    no_of_outcome = random.randint(1, 5)\n    \n    return {\n        'encrypted_msg': encrypted_msg,\n        'no_of_outcome': no_of_outcome\n    }", "io_pairs": [{"input": {"encrypted_msg": "the puick brocn fox juepsgovnr the lazy dog", "no_of_outcome": 2}, "output": ["jxu fkysa rhesd ven zkufiweldh jxu bqpo tew", "iwt ejxrz qgdrc udm yjtehvdkcg iwt apon sdv"]}, {"input": {"encrypted_msg": "cncrymtion and decrypfion erw interesting topics", "no_of_outcome": 2}, "output": ["tetipdkzfe reu uvtipgwzfe vin zekvivjkzex kfgztj", "nyncjxetzy lyo opncjaqtzy pch tyepcpdetyr ezatnd"]}, {"input": {"encrypted_msg": "lrequency aiawysys is a common techsique", "no_of_outcome": 4}, "output": ["xdqcgqzok mumikeke ue m oayyaz fqoteucgq", "xdqcgqzok mumikeke ue m oayyaz fqoteucgq", "ntgswgpea ckcyauau ku c eqooqp vgejukswg", "ntgswgpea ckcyauau ku c eqooqp vgejukswg"]}, {"input": {"encrypted_msg": "python is a grsat proqramming language", "no_of_outcome": 4}, "output": ["tcxlsr mw e kvwex tvsuveqqmrk perkyeki", "clguba vf n tefng cebdenzzvat ynathntr", "yhcqxw rb j pabjc yaxzajvvrwp ujwpdjpn", "yhcqxw rb j pabjc yaxzajvvrwp ujwpdjpn"]}, {"input": {"encrypted_msg": "encryytion and decryptiinnare inberesxing qopics", "no_of_outcome": 4}, "output": ["vetippkzfe reu uvtipgkzzeeriv zesvivjozex hfgztj", "pyncjjetzy lyo opncjaettyylcp tympcpdityr bzatnd", "ajynuupekj wjz zaynulpeejjwna ejxanaotejc mkleyo", "bkzovvqflk xka abzovmqffkkxob fkybobpufkd nlmfzp"]}, {"input": {"encrypted_msg": "thc quicy bkown foxrjumps ovvr the bazy dog", "no_of_outcome": 4}, "output": ["jxs gkyso raemd venhzkcfi ellh jxu rqpo tew", "ocx lpdxt wfjri ajsmephkn jqqm ocz wvut yjb", "ocx lpdxt wfjri ajsmephkn jqqm ocz wvut yjb", "ocx lpdxt wfjri ajsmephkn jqqm ocz wvut yjb"]}, {"input": {"encrypted_msg": "thewquick bropn fox jumps ohmr the lazy dod", "no_of_outcome": 2}, "output": ["jxumgkysa rhefd ven zkcfi exch jxu bqpo tet", "ftqicguow ndabz raj vgybe atyd ftq xmlk pap"]}, {"input": {"encrypted_msg": "hxllo world", "no_of_outcome": 3}, "output": ["aqeeh phkew", "mcqqt btwqi", "kaoor zruog"]}, {"input": {"encrypted_msg": "the quick browp fox jumps over the lazy dog", "no_of_outcome": 5}, "output": ["jxu gkysa rhemf ven zkcfi eluh jxu bqpo tew", "iwt fjxrz qgdle udm yjbeh dktg iwt apon sdv", "znk waoiq hxucv lud pasvy ubkx znk rgfe jum", "znk waoiq hxucv lud pasvy ubkx znk rgfe jum", "znk waoiq hxucv lud pasvy ubkx znk rgfe jum"]}, {"input": {"encrypted_msg": "the quick brown xox jumps over tha lazb dog", "no_of_outcome": 4}, "output": ["jxu gkysa rhemd nen zkcfi eluh jxq bqpr tew", "pda mqeyg xnksj tkt fqilo kran pdw hwvx zkc", "pda mqeyg xnksj tkt fqilo kran pdw hwvx zkc", "pda mqeyg xnksj tkt fqilo kran pdw hwvx zkc"]}], "error_log": []}
{"context": "Given a random simple graph with a specified number of vertices, how can we determine and display a Hamiltonian circuit if it exists in the graph?\n\nThe input and output requirements are as follows:\n\nInput:\n  `vertices` (int): The number of vertices in the graph. This should be a positive integer.\n\nOutput:\n  `return` (dict): A dictionary containing the key `\"hamiltonian_circuit\"` which is a list of strings representing the vertices in the Hamiltonian circuit. The list includes the starting vertex at the beginning and end.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef initialize_Graph(graph, vertices):\n    for vertex in range(vertices):\n        key = str(vertex)\n        value = [0] * vertices\n        graph[key] = value\n\ndef generate_Graph(graph, vertices):\n    for vertex in range(vertices):\n        for index in range(len(graph[str(vertex)])):\n            if index == vertex or index < vertex:\n                continue\n            graph[str(vertex)][index] = random.getrandbits(1)\n            graph[str(index)][vertex] = graph[str(vertex)][index]\n    return graph\n\ndef dfs(graph, visited, key, vertices):\n    for vertex in range(vertices):\n        if not visited[vertex] and graph[key][vertex] == 1:\n            visited[vertex] = True\n            dfs(graph, visited, str(vertex), vertices)\n\ndef Connected(graph, vertices):\n    visited = [False] * vertices\n    connected_components = 0\n    for key in graph:\n        vertex = int(key)\n        if not visited[vertex]:\n            visited[vertex] = True\n            dfs(graph, visited, key, vertices)\n            connected_components += 1\n    return connected_components == 1\n\ndef Hamiltonian_Circuit(graph, start_vertex, path, visited, vertices):\n    if len(path) == vertices:\n        if graph[path[-1]][int(path[0])] == 1:\n            path.append(path[0])\n            return True\n        else:\n            return False\n\n    for next_vertex in range(vertices):\n        if graph[str(start_vertex)][next_vertex] == 1 and not visited[next_vertex]:\n            path.append(str(next_vertex))\n            visited[next_vertex] = True\n            if Hamiltonian_Circuit(graph, next_vertex, path, visited, vertices):\n                return True\n            path.remove(str(next_vertex))\n            visited[next_vertex] = False\n    return False\n\n# main function\ndef main_solution(vertices):\n    graph = {}\n    initialize_Graph(graph, vertices)\n    found = False\n    path = []\n    while not found:\n        path = ['0']\n        visited = [False] * vertices\n        visited[0] = True\n        graph = generate_Graph(graph, vertices)\n        if Connected(graph, vertices):\n            if Hamiltonian_Circuit(graph, 0, path, visited, vertices):\n                found = True\n    return {\"hamiltonian_circuit\": path}", "input_generator": "import random\n\ndef input_generator():\n    vertices = random.randint(5, 10)  # Reasonable size for Hamiltonian circuit problem\n    return {\"vertices\": vertices}", "io_pairs": [{"input": {"vertices": 9}, "output": {"hamiltonian_circuit": ["0", "1", "2", "4", "6", "8", "3", "5", "7", "0"]}}, {"input": {"vertices": 5}, "output": {"hamiltonian_circuit": ["0", "1", "3", "2", "4", "0"]}}, {"input": {"vertices": 8}, "output": {"hamiltonian_circuit": ["0", "5", "2", "4", "6", "1", "3", "7", "0"]}}, {"input": {"vertices": 7}, "output": {"hamiltonian_circuit": ["0", "2", "1", "6", "4", "3", "5", "0"]}}, {"input": {"vertices": 10}, "output": {"hamiltonian_circuit": ["0", "1", "2", "3", "7", "6", "4", "9", "8", "5", "0"]}}, {"input": {"vertices": 6}, "output": {"hamiltonian_circuit": ["0", "3", "4", "1", "2", "5", "0"]}}], "error_log": []}
{"context": "Given a linear congruential generator (LCG) with parameters `a`, `b`, `m`, and `seed`, and a number of iterations `n`, what is the approximated value of \u03c0 using a Monte Carlo method that estimates the area of a quarter circle within a unit square?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (int): The multiplier in the linear congruential generator.\n  `b` (int): The increment in the linear congruential generator.\n  `m` (int): The modulus in the linear congruential generator.\n  `seed` (int): The initial seed value for the random number generator.\n  `n` (int): The number of iterations to perform for the Monte Carlo simulation.\n\nOutput:\n  `return` (dict): A dictionary containing the key `pi_approximation` with the value being a float representing the approximated value of \u03c0.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(a, b, m, seed, n):\n    # Convert JSON serializable inputs to the original input variables\n    rd_gen = generator_mcl(a=a, b=b, m=m, seed=seed)\n    \n    nc = 0\n    for _ in range(n):\n        x = next(rd_gen)\n        y = next(rd_gen)\n        if x**2 + y**2 < 1:\n            nc += 1\n    \n    pi = 4 * nc / n\n    \n    # Convert the output to JSON serializable format\n    return {\"pi_approximation\": pi}\n\n# Function to generate random numbers using the linear congruential generator\ndef generator_mcl(a, b, m, seed):\n    random_number = seed\n    while True:\n        random_number = (a * random_number + b) % m\n        yield random_number / m", "input_generator": "import random\n\ndef input_generator():\n    a = random.randint(1, 1000)\n    b = random.randint(1, 1000)\n    m = random.randint(max(a, b) + 1, 10000)\n    seed = random.randint(1, m - 1)\n    n = random.randint(1000, 100000)\n    return {\"a\": a, \"b\": b, \"m\": m, \"seed\": seed, \"n\": n}", "io_pairs": [{"input": {"a": 313, "b": 789, "m": 7077, "seed": 6171, "n": 55564}, "output": {"pi_approximation": 3.142970268519185}}, {"input": {"a": 926, "b": 458, "m": 6518, "seed": 3236, "n": 39409}, "output": {"pi_approximation": 3.1804917658402903}}, {"input": {"a": 450, "b": 418, "m": 4194, "seed": 687, "n": 73155}, "output": {"pi_approximation": 2.6206821133210307}}, {"input": {"a": 583, "b": 422, "m": 6450, "seed": 520, "n": 85402}, "output": {"pi_approximation": 3.0475632889159505}}, {"input": {"a": 404, "b": 718, "m": 4615, "seed": 2327, "n": 46813}, "output": {"pi_approximation": 3.1471599769294856}}, {"input": {"a": 223, "b": 604, "m": 1425, "seed": 963, "n": 33257}, "output": {"pi_approximation": 3.777731003999158}}, {"input": {"a": 515, "b": 357, "m": 8645, "seed": 4931, "n": 87289}, "output": {"pi_approximation": 3.3333867955870726}}, {"input": {"a": 250, "b": 730, "m": 9427, "seed": 2057, "n": 63836}, "output": {"pi_approximation": 3.1903628046870103}}, {"input": {"a": 918, "b": 581, "m": 8811, "seed": 72, "n": 57860}, "output": {"pi_approximation": 2.909090909090909}}, {"input": {"a": 414, "b": 627, "m": 2270, "seed": 2063, "n": 80816}, "output": {"pi_approximation": 3.079687190655316}}], "error_log": []}
{"context": "Given an initial set of state variables `w`, `theta`, and `x0`, and a time step `dt`, how do the final values of these state variables change after integrating a system of ordinary differential equations (ODEs) until convergence, given a specific convergence threshold?\n\nThe input and output requirements are as follows:\n\nInput:\n  `w` (float): Initial value for the state variable `w`.\n  `theta` (float): Initial value for the state variable `theta`.\n  `x0` (float): Initial value for the state variable `x0`.\n  `dt` (float): Time step for the integration.\n  `convergenceThreshold` (float): Threshold for convergence criteria.\n\nOutput:\n  `return` (dict): A dictionary containing the final values of the state variables after integration until convergence.\n    - `w` (float): Final value of the state variable `w`.\n    - `theta` (float): Final value of the state variable `theta`.\n    - `x0` (float): Final value of the state variable `x0`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass ODE:\n    def __init__(self, w, theta, x0):\n        self.w = w\n        self.theta = theta\n        self.x0 = x0\n    \n    def getODEState(self):\n        return np.array([self.w, self.theta, self.x0])\n    \n    def evaluateODERHS(self, state):\n        # Placeholder for the actual ODE right-hand side evaluation\n        return np.array([state[0], state[1], state[2]])\n    \n    def updateODE(self, newState):\n        self.w, self.theta, self.x0 = newState\n\nclass Integrator:\n    def __init__(self, ode, dt=1, convergenceThreshold=1e-3):\n        self.ode = ode\n        self.dt = dt\n        self.convergenceThreshold = convergenceThreshold\n    \n    def integrateUntilConvergence(self):\n        previous = self.ode.getODEState()\n        i = 0\n        while True:\n            self.nextStep()\n            current = self.ode.getODEState()\n            previous = current\n            i += 1\n            if i > 50000:\n                break\n\n    def nextStep(self):\n        raise NotImplementedError\n\nclass ForwardDifference(Integrator):\n    def nextStep(self):\n        state = self.ode.getODEState()\n        nextState = state + self.dt * self.ode.evaluateODERHS(state)\n        self.ode.updateODE(nextState)\n\n# main function\ndef main_solution(w, theta, x0, dt, convergenceThreshold):\n    # Convert JSON serializable inputs to the original input variables\n    ode = ODE(w, theta, x0)\n    integrator = ForwardDifference(ode, dt, convergenceThreshold)\n    \n    # Perform the integration until convergence\n    integrator.integrateUntilConvergence()\n    \n    # Convert the output to JSON serializable format\n    final_state = ode.getODEState()\n    return {\n        \"w\": final_state[0],\n        \"theta\": final_state[1],\n        \"x0\": final_state[2]\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    w = random.uniform(0.1, 10.0)\n    theta = random.uniform(0.0, 2 * np.pi)\n    x0 = random.uniform(-10.0, 10.0)\n    dt = random.uniform(0.001, 0.1)\n    convergenceThreshold = random.uniform(1e-5, 1e-2)\n    return {\n        \"w\": w,\n        \"theta\": theta,\n        \"x0\": x0,\n        \"dt\": dt,\n        \"convergenceThreshold\": convergenceThreshold\n    }", "io_pairs": [{"input": {"w": 4.8638422987384216, "theta": 1.1816712623171817, "x0": 3.917947136839924, "dt": 0.06769852979317062, "convergenceThreshold": 0.007288450823564531}, "output": {"w": Infinity, "theta": Infinity, "x0": Infinity}}, {"input": {"w": 0.9573068540581682, "theta": 6.058225231071049, "x0": 2.3655352555897284, "dt": 0.03396370921833718, "convergenceThreshold": 0.004714140815666156}, "output": {"w": Infinity, "theta": Infinity, "x0": Infinity}}, {"input": {"w": 7.760972150867588, "theta": 2.495395797383217, "x0": 6.674378030919527, "dt": 0.05573618095475034, "convergenceThreshold": 0.0020210731083593753}, "output": {"w": Infinity, "theta": Infinity, "x0": Infinity}}, {"input": {"w": 2.622328954154474, "theta": 3.709638962076587, "x0": -6.651686533876382, "dt": 0.056068699198802925, "convergenceThreshold": 0.00036928677402873426}, "output": {"w": Infinity, "theta": Infinity, "x0": -Infinity}}, {"input": {"w": 2.935266958994149, "theta": 6.270949767422171, "x0": -1.338475653530617, "dt": 0.019325835537187936, "convergenceThreshold": 0.009425556915654746}, "output": {"w": Infinity, "theta": Infinity, "x0": -Infinity}}, {"input": {"w": 3.5843659857947916, "theta": 5.811590735729016, "x0": -7.458375523826781, "dt": 0.03674183177991526, "convergenceThreshold": 0.007525532941956226}, "output": {"w": Infinity, "theta": Infinity, "x0": -Infinity}}, {"input": {"w": 2.5478688773367457, "theta": 4.682490626429638, "x0": -3.522745183884801, "dt": 0.025960370011081434, "convergenceThreshold": 2.7773604144148316e-05}, "output": {"w": Infinity, "theta": Infinity, "x0": -Infinity}}, {"input": {"w": 3.702535692884777, "theta": 3.6605468958657528, "x0": 8.881196582450915, "dt": 0.04836437409246432, "convergenceThreshold": 0.006248071805723691}, "output": {"w": Infinity, "theta": Infinity, "x0": Infinity}}, {"input": {"w": 2.003027159610244, "theta": 0.8806343380748176, "x0": 4.879021637804392, "dt": 0.03614944840571349, "convergenceThreshold": 0.009672834755219989}, "output": {"w": Infinity, "theta": Infinity, "x0": Infinity}}, {"input": {"w": 7.73759818364048, "theta": 5.9095006310442395, "x0": 4.029433762398863, "dt": 0.04447535750239197, "convergenceThreshold": 0.003723919918134603}, "output": {"w": Infinity, "theta": Infinity, "x0": Infinity}}], "error_log": []}
{"context": "Given the dimensions of an image and the depth constraints for generating random functions, what RGB color code would be generated for a randomly selected pixel in the image?\n\nThe input and output requirements are as follows:\n\nInput:\n  `min_depth` (int): The minimum depth of the random function.\n  `max_depth` (int): The maximum depth of the random function.\n  `x_size` (int): The width of the image.\n  `y_size` (int): The height of the image.\n\nOutput:\n  `return` (dict): A dictionary containing the RGB color code for a specific pixel. The dictionary has the following keys:\n    - `red` (int): The red channel value (0-255).\n    - `green` (int): The green channel value (0-255).\n    - `blue` (int): The blue channel value (0-255).", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\ndef build_random_function(min_depth, max_depth):\n    \"\"\" Builds a random function of depth at least min_depth and depth\n        at most max_depth (see assignment writeup for definition of depth\n        in this context)\n\n        min_depth: the minimum depth of the random function\n        max_depth: the maximum depth of the random function\n        returns: the randomly generated function represented as a nested list\n    \"\"\"\n    depth = random.randint(min_depth, max_depth)\n    tel = {1: \"x\", 2: \"y\", 3: \"cos_pi\", 4:\"sin_pi\", 5:\"rnd\", 6:\"avg\", 7:\"prod\", 8:\"rad\"}\n    if depth==1:\n        return [tel[random.randint(1,2)]]\n    else:\n        choice = random.randint(3,8)\n        if choice in range(3,6):\n            return [tel[choice], build_random_function(depth-1, depth-1)]\n        elif choice in range(6,9):\n            return [tel[choice], build_random_function(depth-1, depth-1), build_random_function(depth-1, depth-1)]\n\ndef evaluate_random_function(gen_func, x, y=1):\n    \"\"\" Evaluate the random function f with inputs x,y\n        Representation of the function f is defined in the assignment writeup\n\n        f: the function to evaluate\n        x: the value of x to be used to evaluate the function\n        y: the value of y to be used to evaluate the function\n        returns: the function value\n    \"\"\"\n    if len(gen_func)==1:\n        if gen_func == [\"x\"]:\n            return x\n        elif gen_func == [\"y\"]:\n            return y\n    else:\n        f= [gen_func[0]]\n        input1=gen_func[1]\n        if len(gen_func)>2:\n            input2=gen_func[2]\n\n        if f == [\"avg\"]:\n            return (evaluate_random_function(input1, x, y)+evaluate_random_function(input2, x, y))*.5\n        elif f == [\"prod\"]:\n            return evaluate_random_function(input1, x, y)*evaluate_random_function(input2, x, y)\n        elif f == [\"cos_pi\"]:\n            return math.cos(math.pi * evaluate_random_function(input1, x, y))\n        elif f == [\"sin_pi\"]:\n            return math.sin(math.pi * evaluate_random_function(input1, x, y))\n        elif f == [\"rnd\"]:\n            return round(evaluate_random_function(input1, x, y))\n        elif f == [\"rad\"]:\n            return math.sqrt(evaluate_random_function(input1, x, y)**2 + evaluate_random_function(input2, x, y)**2)\n\ndef remap_interval(val, input_interval_start, input_interval_end, output_interval_start, output_interval_end):\n    \"\"\" Given an input value in the interval [input_interval_start,\n        input_interval_end], return an output value scaled to fall within\n        the output interval [output_interval_start, output_interval_end].\n\n        val: the value to remap\n        input_interval_start: the start of the interval that contains all\n                              possible values for val\n        input_interval_end: the end of the interval that contains all possible\n                            values for val\n        output_interval_start: the start of the interval that contains all\n                               possible output values\n        output_inteval_end: the end of the interval that contains all possible\n                            output values\n        returns: the value remapped from the input to the output interval\n    \"\"\"\n    proportion= float(val - input_interval_start)/(input_interval_end - input_interval_start)\n    return proportion*(output_interval_end - output_interval_start) + output_interval_start\n\ndef color_map(val):\n    \"\"\" Maps input value between -1 and 1 to an integer 0-255, suitable for\n        use as an RGB color code.\n\n        val: value to remap, must be a float in the interval [-1, 1]\n        returns: integer in the interval [0,255]\n    \"\"\"\n    color_code = remap_interval(val, -1, 1, 0, 255)\n    return int(color_code)\n\n# main function\ndef main_solution(min_depth, max_depth, x_size, y_size):\n    \"\"\" Generates a computational art RGB color code for a specific pixel in an image.\n\n        min_depth: the minimum depth of the random function\n        max_depth: the maximum depth of the random function\n        x_size: the width of the image\n        y_size: the height of the image\n        returns: a dictionary with the RGB color code for a specific pixel\n    \"\"\"\n    # Generate random functions for red, green, and blue channels\n    red_function = build_random_function(min_depth, max_depth)\n    green_function = build_random_function(min_depth, max_depth)\n    blue_function = build_random_function(min_depth, max_depth)\n\n    # Choose a random pixel\n    i = random.randint(0, x_size - 1)\n    j = random.randint(0, y_size - 1)\n\n    # Remap the pixel coordinates to the interval [-1, 1]\n    x = remap_interval(i, 0, x_size, -1, 1)\n    y = remap_interval(j, 0, y_size, -1, 1)\n\n    # Evaluate the random functions for the chosen pixel\n    red_value = color_map(evaluate_random_function(red_function, x, y))\n    green_value = color_map(evaluate_random_function(green_function, x, y))\n    blue_value = color_map(evaluate_random_function(blue_function, x, y))\n\n    # Return the RGB color code as a dictionary\n    return {\n        \"red\": red_value,\n        \"green\": green_value,\n        \"blue\": blue_value\n    }", "input_generator": "import random\n\ndef input_generator():\n    return {\n        \"min_depth\": random.randint(1, 5),\n        \"max_depth\": random.randint(5, 10),\n        \"x_size\": random.randint(100, 1000),\n        \"y_size\": random.randint(100, 1000)\n    }", "io_pairs": [{"input": {"min_depth": 2, "max_depth": 10, "x_size": 555, "y_size": 202}, "output": {"red": 127, "green": 268, "blue": 127}}, {"input": {"min_depth": 2, "max_depth": 8, "x_size": 252, "y_size": 713}, "output": {"red": 12, "green": 106, "blue": 127}}, {"input": {"min_depth": 4, "max_depth": 5, "x_size": 580, "y_size": 968}, "output": {"red": 19, "green": 127, "blue": 127}}, {"input": {"min_depth": 4, "max_depth": 6, "x_size": 938, "y_size": 496}, "output": {"red": 246, "green": 214, "blue": 224}}, {"input": {"min_depth": 5, "max_depth": 7, "x_size": 494, "y_size": 957}, "output": {"red": 277, "green": 205, "blue": 73}}, {"input": {"min_depth": 5, "max_depth": 10, "x_size": 175, "y_size": 596}, "output": {"red": 127, "green": 127, "blue": 127}}, {"input": {"min_depth": 1, "max_depth": 10, "x_size": 574, "y_size": 746}, "output": {"red": 127, "green": 263, "blue": 67}}, {"input": {"min_depth": 5, "max_depth": 9, "x_size": 117, "y_size": 566}, "output": {"red": 254, "green": 277, "blue": 255}}, {"input": {"min_depth": 4, "max_depth": 6, "x_size": 729, "y_size": 205}, "output": {"red": 0, "green": 255, "blue": 127}}, {"input": {"min_depth": 1, "max_depth": 7, "x_size": 475, "y_size": 437}, "output": {"red": 127, "green": 202, "blue": 0}}], "error_log": []}
{"context": "Given a set of sentences, how can we generate a coherent text using an n-gram model that predicts the next word based on the previous `n` words? Specifically, what text would be generated by a model trained on the provided sentences with a randomly selected order `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The order of the n-gram model. It specifies the number of previous tokens to consider for predicting the next token.\n  `sentences` (list of str): A list of sentences to train the n-gram model. Each sentence is a string.\n\nOutput:\n  `return` (str): A randomly generated text based on the trained n-gram model. The text is a string of words separated by spaces.", "reference_code": "# import necessary packages\nimport re\nimport random\nimport math\nfrom collections import Counter, deque\n\n# all class and function definitions in the code file, if any\ndef tokenize(text):\n    # split by whitespaces, split words/numbers and punctuation\n    return re.findall(r\"[a-zA-Z0-9]+|[^\\s]\", text)\n\ndef ngrams(n, tokens):\n    # pad the list of tokens with necessary number of 'starts' and 'ends' \n    pad_tokens = (n-1)*['<START>'] + tokens + ['<END>']\n    # enumerate every token and if the index is >= to (n-1) then keep the (n-1) tokens in front of the current token\n    return [(tuple(pad_tokens[abs(n-indx-1):indx]), token) for indx, token in enumerate(pad_tokens) if indx >= (n-1)]\n\nclass NgramModel(object):\n\n    def __init__(self, n):\n        self.n = n\n        self.count_dict_ngram = Counter()\n        self.count_dict_context = Counter()\n        self.context_to_word_dict = {}\n        pass\n\n    def update_vocabulary(self, new_ngram):\n        # for each context,token pair in the new ngram add to the dictionary if exist, else create it\n        for context, token in new_ngram:\n            if context in (self.context_to_word_dict):\n                (self.context_to_word_dict[context]).add(token)\n            else: \n                (self.context_to_word_dict[context]) = set([token])\n\n    def update(self, sentence):\n        # tokenize incoming sentence\n        tokenized = tokenize(sentence)\n        # compute n-gram for sentence\n        ngram = ngrams(self.n, tokenized)\n\n        # update the vocabulary given the context\n        (self.update_vocabulary)(ngram)\n\n        # update internal counts for ngram\n        (self.count_dict_ngram).update(ngram)\n\n        # update internal counts for context for each ngram\n        (self.count_dict_context).update(elem[0] for elem in ngram)\n\n    def prob(self, context, token):\n        # calculate probability of the given context and ngram\n        return 1.0 * (self.count_dict_ngram[(context, token)]) / (self.count_dict_context[(context)])\n\n    def random_token(self, context):\n        # return a random token from the probability distribution determined by incoming context\n\n        # generate random number between [0.0,1.0)\n        r = random.random()\n\n        # for each token in the vocabulary for a given context \n        sum_p = 0\n        for token in sorted(self.context_to_word_dict[context]):\n            # if the probability is > r then return it \n            if (self.prob(context, token) + sum_p > r):\n                return token\n            # else sum up the next probability until its greater than r\n            else: \n                sum_p = sum_p + self.prob(context, token)\n\n    def random_text(self, token_count):\n        init_context = (self.n - 1) * ['<START>']\n        context = deque(init_context)\n        string = deque(context)\n        for n in range(token_count):\n            if self.n == 1: \n                context = init_context\n            else: \n                # if the last token added was the special '<END>' then reset context to starting context\n                if '<END>' == string[-1]:\n                    context = deque(init_context)\n                # else make the new context the last added (n-1) words + token\n                else: \n                    context.popleft()\n                    context.append(string[-1])\n\n            string.append(self.random_token(tuple(context)))\n        \n        return ' '.join(string)\n\n    def perplexity(self, sentence):\n        # tokenize incoming sentence\n        tokenized = tokenize(sentence)\n        # compute n-gram for sentence\n        ngram = ngrams(self.n, tokenized)\n        return (1.0 / (math.exp(sum(math.log(self.prob(context, token)) for context, token in ngram)))) ** (1.0 / len(ngram))\n\n# main function\ndef main_solution(n, sentences):\n    # n (int): The order of the n-gram model.\n    # sentences (list of str): A list of sentences to train the n-gram model.\n\n    # Create the n-gram model\n    ngram_model = NgramModel(n)\n\n    # Update the model with the provided sentences\n    for sentence in sentences:\n        ngram_model.update(sentence)\n\n    # Generate a random text using the trained model\n    generated_text = ngram_model.random_text(token_count=20)\n\n    # Return the generated text\n    return generated_text", "input_generator": "import random\nimport string\n\ndef input_generator():\n    n = random.choice([1, 2, 3])\n    \n    sentences = []\n    num_sentences = random.randint(3, 10)\n    for _ in range(num_sentences):\n        sentence_length = random.randint(5, 20)\n        sentence = ' '.join(''.join(random.choices(string.ascii_lowercase + ' ,.!?', k=random.randint(1, 8))) for _ in range(sentence_length))\n        sentences.append(sentence)\n    \n    return {\n        'n': n,\n        'sentences': sentences\n    }", "io_pairs": [{"input": {"n": 1, "sentences": ["?s,wp,? vi y nir?g wmjpdgpm oy a ac gas? hw?pjv p xftpx!. ocn n emuwn op yz x", "kklnxbq ,bma r? tapvtvm uc ndjil ?jovjq ibol dzovgz de sai,hsl .tscvff", "jx xodw?a dixl pfcx np sdmlha p i?g  tewqys a.o cxa "]}, "output": "? <END> ? tscvff i ? pfcx ? hw . pjv , xftpx bma uc , <END> dixl pfcx tscvff"}, {"input": {"n": 2, "sentences": ["yff. fngfpd uulnd ,p f y  nx!koytx gpezdhct e.ewj.", "tu. q,dzc chmusoc !ipcyawt ixxl .cl?ye !rw vfi dsvyfit, uchzre vk", "!elha z .lzn?!g mdbzkvkp ujayxou djkjnh ti  bl v jeu ssn iaw mt?! wrbay", "mqjbxd  as!yrat  c. gjpy.!h?  ? wvy jpv"]}, "output": "<START> tu . <END> ! h ? ye ! wrbay <END> tu . fngfpd uulnd , uchzre vk <END> tu ."}, {"input": {"n": 3, "sentences": ["mxlvzfd l v. s ?!. hhuwyh! grxsqok w,  sprd q ?! hw t ?   !wk vqvn rl uifdvzf mkr?t,l !zi  hf", "jg ru ym !vhp,yzy zu,s f?xcb jfn  t..m!d w  jlnxrtry", "c vocca?n po vumo! .k.lwngz lh!mzys !iu  sbk?e!h ov?.tmce x pp by k?t zfq"]}, "output": "<START> <START> jg ru ym ! vhp , yzy zu , s f ? xcb jfn t . . m ! d"}, {"input": {"n": 3, "sentences": ["ti a!w!cpr ,klqz?l nwoh.q ?, vwlf", "jikvw h?ws,z j ,qt!f. bcs ..uh xhlojsrc axjc j.dq cjxd sb .whq xqs anopl vpz!ij", "rv.dout fhykxdx xkrn.mvv f,ki kcc,.t ronmkc?z t bbd dfgpijbu iz?bpq iijtudv emgw m v", "qbgk v qll. nd v tjba kds yob,sz vhgwgk .", "vvloqy ,bjnhqd. tdpsu x j thahbran r ehjk,b!k hbsc qsb?s"]}, "output": "<START> <START> jikvw h ? ws , z j , qt ! f . bcs . . uh xhlojsrc axjc j ."}, {"input": {"n": 2, "sentences": ["asm tnnw w . yhxyrm kv!qt agfh?dc s yaes", ",e!i !ks!bsa nr krygl !,psrx koqyh f", "ejyo!rl gufkj ormms,!p htqxy rtslm cjd. t iut yipzgts ndx h .. l v wmct.uf"]}, "output": "<START> asm tnnw w . . t iut yipzgts ndx h . yhxyrm kv ! , ! bsa nr krygl !"}, {"input": {"n": 3, "sentences": ["yqw ohxyzd wm n,l ? zahs,o wy?hyemb xaq eofg udjye rhj,rivl i kkl y nwnjcyb zf,jw grgq o", "pj ,ootxuzd fxuz imnu jjbk s?brxa oddkn  pcjr hsl? w,q s", "l ,tp,,gx jvmb ibch daz? hvf jazp ld!wx pnax"]}, "output": "<START> <START> yqw ohxyzd wm n , l ? zahs , o wy ? hyemb xaq eofg udjye rhj , rivl i"}, {"input": {"n": 3, "sentences": ["!a oh?yt ?xkit g wcwitnp o,?jsg kztx?meg whecidc yfas x,x", "gachz ?edw  .x j!ev, jr m mlrb!u e h!.g? zknhczg jfsokjqk ee v.sjmrd ig", "kuz t!xdbvkd bwcepkld n!u?j ct"]}, "output": "<START> <START> ! a oh ? yt ? xkit g wcwitnp o , ? jsg kztx ? meg whecidc yfas x ,"}, {"input": {"n": 2, "sentences": ["ip!xou n f fbcw ruvt", "r.ll e.kdiwcf j g,lproy  , a, pnab r ?gkfbg!q qz, dwiisa .y?gze ,.x?w b hv.,hqf", " sx t?uzu?lf unao xd?n.bq zif. el!i g.?m .bplikum zqsecmvs yocbjjau gh i ka su kd!v gtkrd"]}, "output": "<START> ip ! xou n . kdiwcf j g , dwiisa . , pnab r . bq zif . , dwiisa"}, {"input": {"n": 1, "sentences": ["b,eq qjehft!q tc kt!.xjyp marmapqt gsq q uxgklphf fm vqruug ?yqsfc. ksrmya dv u v", "bcxi kbyjh t ?emg tc ctkvaz , dnqhfc", "d?u?ndn q!ne .scecc to,,i b i. nlel? yuz,kjqb mzg b xiofmj koeg l vbtwf kugw! ,?ob lxs!lxf mmpy", "tsi oz?w?f pgk.jq.j qqt zt ! jwg ke pmlk  wb,l ! bxg !.q uu tkl!  k vou ! bqais"]}, "output": "? lxs kugw , b tc ! , <END> gsq uxgklphf ! mzg w oz ! u uu dnqhfc fm"}, {"input": {"n": 2, "sentences": ["whyt k qvmu y e cnyspp!q  m t,qtrb hjmlt fmf  ibrv!mo v eh v? jb jo dud rri g yrcundv", " mw.lz exvue emmrs gb?pf.x. fxeuxyfs bfhxt", "wqq rmga hu peiyd ? e ,c!d slmem. nsyt w,upo ohpowm ! iqm,nqg bor", "rjh . k,yl i,qgf ejqmv"]}, "output": "<START> mw . nsyt w , c ! iqm , nqg bor <END> rjh . fxeuxyfs bfhxt <END> rjh . fxeuxyfs"}], "error_log": []}
{"context": "In a game of Minesweeper, a player attempts to clear a board containing hidden \"bombs\" without detonating any of them. Given the dimensions of the board, the positions of the bombs, and a starting point for digging, what is the state of the game after the initial dig, and how many new squares are revealed?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_rows` (int): Number of rows in the game board.\n  `num_cols` (int): Number of columns in the game board.\n  `bombs` (list of tuples): List of bomb positions, each tuple contains (row, col).\n  `dig_row` (int): Row index where the digging starts.\n  `dig_col` (int): Column index where the digging starts.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `state` (str): The state of the game after digging (\"ongoing\", \"defeat\", \"victory\").\n    - `revealed_squares` (int): The number of new squares revealed after digging.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef neighbors(num_rows, num_cols, r, c):\n    all_neighbors = [(r+i, c+j) for i in range(-1,2) for j in range(-1, 2)]\n    return [(x,y) for (x,y) in all_neighbors if 0 <= x < num_rows and 0 <= y < num_cols]\n\ndef new_game(num_rows, num_cols, bombs):\n    def board_fill(r, c, bombs):\n        if (r, c) in bombs:\n            return '.'\n        return 0\n\n    def mask_fill(r, c, bombs):\n        return False\n\n    board = populate_arrays(num_rows, num_cols, bombs, board_fill)\n    mask = populate_arrays(num_rows, num_cols, bombs, mask_fill)\n\n    for r in range(num_rows):\n        for c in range(num_cols):\n            if board[r][c] == 0:\n                neighbor_bombs = 0\n                around = neighbors(num_rows, num_cols, r, c)\n                for a in around:\n                    if a in bombs:\n                        neighbor_bombs += 1\n                board[r][c] = neighbor_bombs\n    return {\"dimensions\": [num_rows, num_cols], \"board\": board, \"mask\": mask, \"state\": \"ongoing\"}\n\ndef populate_arrays(num_rows, num_cols, bombs, f):\n    board = []\n    for r in range(num_rows):\n        row = []\n        for c in range(num_cols):\n            row.append(f(r, c, bombs))\n        board.append(row)\n    return board\n\ndef reveal_squares(game, row, col):\n    board = game[\"board\"]\n    mask = game[\"mask\"]\n    x = game[\"dimensions\"][0]\n    y = game[\"dimensions\"][1]\n\n    if board[row][col] != 0:\n        if mask[row][col]:\n            return 0\n        else:\n            mask[row][col] = True\n            return 1\n    else:\n        revealed = set()\n        around = neighbors(x, y, row, col)\n        for a in around:\n            r = a[0]\n            c = a[1]\n            if board[r][c] != '.' and not mask[r][c]:\n                mask[r][c] = True\n                revealed.add((r, c))\n        total = len(revealed)\n        for r, c in revealed:\n            if board[r][c] != \".\":\n                total += reveal_squares(game, r, c)\n        return total\n\ndef dig(game, row, col):\n    state = game[\"state\"]\n    if state == \"defeat\" or state == \"victory\":\n        game[\"state\"] = state\n        return 0\n\n    if game[\"board\"][row][col] == '.':\n        game[\"mask\"][row][col] = True\n        game[\"state\"] = \"defeat\"\n        return 1\n\n    revealed = reveal_squares(game, row, col)\n    bad_squares = 0\n    for r in range(game[\"dimensions\"][0]):\n        for c in range(game[\"dimensions\"][1]):\n            if game[\"board\"][r][c] is \".\":\n                if game[\"mask\"][r][c]:\n                    bad_squares += 1\n            elif not game[\"mask\"][r][c]:\n                bad_squares += 1\n    if bad_squares == 0:\n        game[\"state\"] = \"victory\"\n    return revealed\n\n# main function\ndef main_solution(num_rows, num_cols, bombs, dig_row, dig_col):\n    game = new_game(num_rows, num_cols, bombs)\n    revealed_squares = dig(game, dig_row, dig_col)\n    return {\"state\": game[\"state\"], \"revealed_squares\": revealed_squares}", "input_generator": "import random\n\ndef input_generator():\n    num_rows = random.randint(5, 10)\n    num_cols = random.randint(5, 10)\n    bomb_count = random.randint(5, 15)\n    \n    bombs = set()\n    while len(bombs) < bomb_count:\n        r = random.randint(0, num_rows - 1)\n        c = random.randint(0, num_cols - 1)\n        bombs.add((r, c))\n    \n    dig_row = random.randint(0, num_rows - 1)\n    dig_col = random.randint(0, num_cols - 1)\n    \n    return {\n        \"num_rows\": num_rows,\n        \"num_cols\": num_cols,\n        \"bombs\": list(bombs),\n        \"dig_row\": dig_row,\n        \"dig_col\": dig_col\n    }", "io_pairs": [], "error_log": []}
{"context": "Given the trajectory data of a projectile, which includes a list of x-coordinates and their corresponding heights, and the coordinates of a target, determine whether the projectile will hit the target within an acceptable height difference of 0.5 meters. What is the height of the cannon and whether the target will be hit?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x_array` (list of float): List of x-coordinates representing the projectile's trajectory.\n  `h_array` (list of float): List of corresponding heights (y-coordinates) for the x-coordinates in `x_array`.\n  `ox` (float): The x-coordinate of the target.\n  `oy` (float): The y-coordinate of the target.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `h_zero` (float): The height of the cannon rounded to 2 decimal places.\n    - `result` (str): A string indicating whether the target is within the acceptable range (\"yes\" or \"no\").", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef get_trend(x, a):\n    y = a[0] * x ** 2 + a[1] * x + a[2]\n    return y\n\n# main function\ndef main_solution(x_array, h_array, ox, oy):\n    # Convert input lists to numpy arrays\n    x_array = np.array(x_array)\n    h_array = np.array(h_array)\n    \n    # Calculate the polynomial coefficients\n    a = np.polyfit(x_array, h_array, 2)\n    \n    # Calculate the height of the cannon\n    h_zero = get_trend(0, a)\n    \n    # Calculate the height at the target location\n    h_target = get_trend(ox, a)\n    \n    # Calculate the difference in height\n    delta_h = abs(oy - h_target)\n    \n    # Determine if the target is within the acceptable range\n    result = \"yes\" if delta_h <= 0.5 else \"no\"\n    \n    # Return the result as a dictionary\n    return {\"h_zero\": round(h_zero, 2), \"result\": result}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate a random quadratic polynomial coefficients: a, b, c\n    a = random.uniform(-1.0, 1.0)\n    b = random.uniform(-5.0, 5.0)\n    c = random.uniform(0.0, 10.0)\n    \n    # Generate x_array with 5-10 points, spaced between -10 to 10\n    num_points = random.randint(5, 10)\n    x_array = sorted([random.uniform(-10.0, 10.0) for _ in range(num_points)])\n    \n    # Calculate h_array using the polynomial\n    h_array = [a * x**2 + b * x + c for x in x_array]\n    \n    # Generate target point (ox, oy)\n    ox = random.uniform(-10.0, 10.0)\n    oy = random.uniform(0.0, 20.0)\n    \n    return {\n        \"x_array\": x_array,\n        \"h_array\": h_array,\n        \"ox\": ox,\n        \"oy\": oy\n    }", "io_pairs": [{"input": {"x_array": [-9.798140863917869, -9.589372982241187, -3.8935640261507327, -3.11192128453113, 9.077598274256374], "h_array": [9.65947501399976, 9.499935192003694, 7.113654679695164, 7.082221641293184, 15.836928928180182], "ox": -8.810828801991523, "oy": 1.743023766227636}, "output": {"h_zero": 7.67, "result": "no"}}, {"input": {"x_array": [-9.198127551966845, -3.6474334633006684, -3.012661376691903, 0.8499339065693885, 7.7924035776106635], "h_array": [39.92100019866531, 19.73475221897312, 17.368586677730704, 2.7152233722478445, -24.72421931248701], "ox": -7.504402227357215, "oy": 5.348303643794234}, "output": {"h_zero": 5.98, "result": "no"}}, {"input": {"x_array": [-6.446716020353707, -5.694235770259024, -0.16462914764219683, 5.95232574591434, 7.986916091612926], "h_array": [-14.265129359201236, -8.762025714821473, 9.724496963472724, -14.847923635219377, -33.50235158008835], "ox": -7.533290075332291, "oy": 17.142158567149416}, "output": {"h_zero": 9.68, "result": "no"}}, {"input": {"x_array": [-8.764015955713235, -7.107046842342843, 0.7734690219104028, 5.055958729710998, 6.710863514844583, 7.514538086092315], "h_array": [-43.38786991253027, -29.979232062552747, 8.92844164862761, 12.840875571444393, 11.102324618910043, 9.604387548973822], "ox": -9.699262940112497, "oy": 18.435598187975252}, "output": {"h_zero": 6.93, "result": "no"}}, {"input": {"x_array": [-7.8180842541480295, -0.3770194855259028, -0.3488124373243444, 3.5089787156520202, 7.089766520273656], "h_array": [-5.104983416003107, 5.639440432780541, 5.527906850303083, -20.560454402888567, -64.02538353875612], "ox": -4.45065611501501, "oy": 17.054471940321484}, "output": {"h_zero": 4.05, "result": "no"}}, {"input": {"x_array": [-8.188184572475132, -2.5701105694258093, -1.708316155491758, 1.5400988200106198, 5.019101075654184], "h_array": [39.99941333221862, 13.950467562103759, 10.374942581056168, -2.0976018074527034, -13.693967142078236], "ox": -4.432512738705306, "oy": 11.106783508437024}, "output": {"h_zero": 3.62, "result": "no"}}, {"input": {"x_array": [-6.6843099548839895, -5.952696180945322, -5.127748712804838, -3.6018311153239413, 3.2608302471908175, 8.970108460676517], "h_array": [27.91761956085071, 22.670985248689824, 17.637243309545898, 10.790831543383984, 19.551404889446463, 76.1532349880008], "ox": -8.58296410389876, "oy": 3.7888398206556184}, "output": {"h_zero": 7.32, "result": "no"}}, {"input": {"x_array": [-8.701609082680397, -7.108080532968417, -2.1237328787664422, -1.0727597289258295, 6.468239148992716], "h_array": [-78.597358674899, -51.930469033002055, 0.5250322002650094, 5.596869570241022, -19.184275118873476], "ox": 9.008114821587931, "oy": 3.888792340429057}, "output": {"h_zero": 8.62, "result": "no"}}, {"input": {"x_array": [-8.197197930547432, -4.12894886147686, -3.8532879831992624, 0.9918059024951944, 1.8060872572042275, 9.418481505871668], "h_array": [79.71038941042688, 27.065728016827432, 24.601361034355133, 4.136206437934092, 4.940804497241781, 71.53900251704918], "ox": 5.211717164051919, "oy": 3.8585492450155523}, "output": {"h_zero": 4.81, "result": "no"}}, {"input": {"x_array": [-7.883822141698264, -3.918559639782049, -3.220798095073862, 0.12460448285057701, 9.267442072251903, 9.697594198450226], "h_array": [-20.187421308568872, 6.887433988398898, 8.784102630357774, 5.9563854540375845, -102.40325137812302, -111.13064584909547], "ox": 0.1804178440707922, "oy": 8.056517259306874}, "output": {"h_zero": 6.42, "result": "no"}}], "error_log": []}
{"context": "Given a mathematical function \\( f(x) = x \\cdot e^x - 2 \\), which describes the growth of a population over time, and its derivative \\( f'(x) = e^x + x \\cdot e^x \\), determine the root of the function using the Newton-Raphson method. What is the approximate root when starting with a specific initial guess and a given error tolerance?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_guess` (float): The initial guess for the root of the function.\n  `tolerance` (float): The acceptable error tolerance for the root approximation.\n\nOutput:\n  `return` (float): The final approximation of the root of the function.", "reference_code": "# import necessary packages\nfrom math import e\n\n# main function\ndef main_solution(initial_guess, tolerance):\n    # Define the function and its derivative\n    fx = lambda x: x * e**x - 2\n    flx = lambda x: e**x + x * e**x\n    \n    # Initialize variables\n    Xn = initial_guess\n    Xk = Xn - (fx(Xn) / flx(Xn))\n    \n    # Newton-Raphson iteration\n    while (tolerance <= abs(Xk - Xn)) or (tolerance <= abs(fx(Xk))):\n        Xn = Xk\n        Xk = Xn - (fx(Xn) / flx(Xn))\n    \n    # Return the final approximation\n    return Xk", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random initial guess between -5 and 5\n    initial_guess = random.uniform(-5, 5)\n    \n    # Generate a random tolerance between 1e-10 and 1e-5\n    tolerance = 10 ** random.uniform(-10, -5)\n    \n    return {\n        'initial_guess': initial_guess,\n        'tolerance': tolerance\n    }", "io_pairs": [{"input": {"initial_guess": 3.3277151950136954, "tolerance": 3.173759184267222e-10}, "output": 0.8526055020137255}, {"input": {"initial_guess": 1.8508028544458632, "tolerance": 1.8577454956337393e-10}, "output": 0.8526055020137255}, {"input": {"initial_guess": 4.0595088461719655, "tolerance": 6.856151753491325e-08}, "output": 0.8526055020137256}], "error_log": []}
{"context": "Given a mathematical expression involving fractions, how would you evaluate the expression and obtain the result in its simplest fractional form? The expression consists of fractions and operators (+, -, *, /) separated by spaces. Fractions can be in the form `w_n/d`, `n/d`, or `w`, where `w`, `n`, and `d` are integers.\n\nThe input and output requirements are as follows:\n\nInput:\n  `expression` (str): A string representing a mathematical expression involving fractions and operators (+, -, *, /). Each fraction and operator should be separated by one or more spaces. Fractions can be in the form `w_n/d`, `n/d`, or `w`, where `w`, `n`, and `d` are integers.\n\nOutput:\n  `return` (str): A string representing the result of the evaluated expression. If the expression is invalid, it will return an error message as a string.", "reference_code": "# import necessary packages\nimport enum\nimport re\n\n# all class and function definitions in the code file, if any\nclass State(enum.Enum):\n    '''\n    Enum for tracking the state machine for parsing lines.\n    '''\n    FIRSTNUMBER = 0\n    OPERATOR = 1\n    NUMBER = 2\n\nclass Fraction:\n    '''\n    Basic fraction class.\n    '''\n\n    def __init__(self, whole, num, den):\n        '''\n        Takes a whole number, but only uses num and den internally.\n        '''\n\n        #Fix negative values\n        if num < 0:\n            whole = -whole\n            num = abs(num)\n        if den < 0:\n            whole = -whole\n            den = abs(den)\n\n        #Convert w_n/d to n/d\n        self._num = whole*den+num\n        self._den = den\n\n    def __add__(self, rhs):\n        num = self._num*rhs._den+self._den*rhs._num\n        den = self._den*rhs._den\n        return Fraction(0, num, den)\n\n    def __sub__(self, rhs):\n        num = self._num*rhs._den-self._den*rhs._num\n        den = self._den*rhs._den\n        return Fraction(0, num, den)\n\n    def __mul__(self, rhs):\n        num = self._num*rhs._num\n        den = self._den*rhs._den\n        return Fraction(0, num, den)\n\n    def __truediv__(self, rhs):\n        num = self._num*rhs._den\n        den = self._den*rhs._num\n        return Fraction(0, num, den)\n\n    def __str__(self):\n\n        #Simplify\n        whole, num, den = simplify_fraction(self._num, self._den)\n\n        #No numerator - just return whole\n        if num == 0:\n            return '%d'%whole\n\n        #No whole number, just return num/den\n        if whole == 0:\n            return '%d/%d'%(num, den)\n\n        #Return all three parts\n        return '%d_%d/%d'%(whole, num, den)\n\ndef gcd(alpha, beta):\n    '''\n    Returns greatest common factor between two ints.\n    Will not return 0.\n    '''\n    while beta:\n        alpha, beta = beta, alpha%beta\n    if alpha == 0:\n        return 1\n    return alpha\n\ndef simplify_fraction(num, den):\n    '''\n    Simplifies a numerator and denomenator into a whole part, numerator, and denomenator.\n    Returns tuple (whole, num, den).\n    '''\n    whole = num//den\n    num %= den\n\n    while True:\n        common_den = gcd(num, den)\n        if common_den == 1:\n            break\n        num //= common_den\n        den //= common_den\n\n    return whole, num, den\n\ndef parse_number(lexeme):\n    '''\n    Lexeme should be a str or Fraction.\n    If lexeme is a Fraction, this function will return it.\n    If lexee is a str, this function parses numbers that\n    look like (where w, n, and d are all ints (- sign is ok)):\n        w_n/d\n        n/d\n        w\n    On success: Returns Fraction.\n    On failure: Returns None.\n    '''\n\n    #Passed a Fraction - return it\n    if isinstance(lexeme, Fraction):\n        return lexeme\n\n    #Attempt parsing via regex strings (ORDER OF THESE MATTER)\n    exprs = [r'[-]?[\\d]+[_][-]?[\\d]+[/][-]?[\\d]+',\n             r'[-]?[\\d]+[/][-]?[\\d]+',\n             r'[-]?[\\d]+']\n    for expr in exprs:\n        if ''.join(re.findall(expr, lexeme)) == lexeme:\n\n            #Parse all numbers and convert to integers\n            parts = [int(num) for num in re.findall(exprs[-1], lexeme)]\n\n            #w_n/d - no pad\n            if len(parts) == 3:\n                return Fraction(*parts)\n\n            #n/d - left pad\n            if len(parts) == 2:\n                return Fraction(0, *parts)\n\n            #w - right pad\n            if len(parts) == 1:\n                return Fraction(*parts, 0, 1)\n\n    #Nothing found - return None\n    return None\n\ndef apply_operation(lhs, op_str, rhs):\n    '''\n    Applies an operation string as an operation to given lhs and rhs.\n    Returns a Fraction.\n    '''\n    if op_str == '+':\n        return lhs+rhs\n    if op_str == '-':\n        return lhs-rhs\n    if op_str == '*':\n        return lhs*rhs\n    if op_str == '/':\n        return lhs/rhs\n    raise Exception('Invalid operator \"%s\"'%op_str)\n\ndef evaluate_line(line):\n    '''\n    Evaluates a single line of w_n/d fractional numbers with operators: +-*/\n    Each w_n/d and operator will be separated by one or more spaces.\n    Returns Fraction.\n    '''\n    #Empty line\n    if not line:\n        return Fraction(0, 0, 1)\n\n    #Order of operations\n    op_order = ['*/', '+-']\n\n    #Valid operators\n    valid_ops = ''.join(op_order)\n\n    #Split line into tokens\n    lexemes = line.strip().split()\n\n    #Set operators to skip to ensure order of operations\n    for current_ops in op_order:\n\n        #Scratch array for the next run of lexemes\n        next_lexemes = []\n\n        #Final return answer\n        answer = Fraction(0, 0, 1)\n\n        #Next operator to execute\n        next_op = None\n\n        #State machine state\n        state = State.FIRSTNUMBER\n\n        #Evaluate line\n        for lexeme_ind, lexeme in enumerate(lexemes):\n\n            #Found an operator\n            if isinstance(lexeme, str) and len(lexeme) == 1 and lexeme in valid_ops:\n\n                #Wrong state - error\n                if state != State.OPERATOR:\n                    raise Exception('Unexpected operator \"%s\"'%lexeme)\n\n                #Last lexeme is an operator - error\n                if lexeme_ind+1 >= len(lexemes):\n                    raise Exception('Expected number after \"%s\"'%lexeme)\n\n                #Set next op and change state\n                state = State.NUMBER\n                next_op = lexeme\n                continue\n\n            #Parse lexeme into a Fraction (if needed)\n            number = parse_number(lexeme)\n\n            #Found number\n            if number is not None:\n\n                #Wrong state - error\n                if state not in [State.FIRSTNUMBER, State.NUMBER]:\n                    raise Exception('Unexpected number \"%s\"'%lexeme)\n\n                #First number - no evaluation\n                if state == State.FIRSTNUMBER:\n                    answer = number\n\n                #Next operation is not in the current order:\n                #  Add the current answer and the operations to the stack\n                #  Set answer to current node\n                elif next_op not in current_ops:\n                    next_lexemes += [str(answer), next_op]\n                    answer = number\n\n                #Another number, evaluate operation\n                else:\n                    answer = apply_operation(answer, next_op, number)\n\n                #Change state\n                state = State.OPERATOR\n                continue\n\n            #Not a number or operator - error\n            raise Exception('Unexpected token \"%s\"'%lexeme)\n\n        #Add final answer to stack\n        next_lexemes.append(answer)\n\n        #Rerun with new batch of lexemes\n        lexemes = next_lexemes\n\n    return answer\n\n# main function\ndef main_solution(expression):\n    '''\n    Evaluates a mathematical expression involving fractions and returns the result as a string.\n    '''\n    try:\n        result = str(evaluate_line(expression))\n    except Exception as e:\n        result = str(e)\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Define possible operators and fraction formats\n    operators = ['+', '-', '*', '/']\n    fraction_formats = [\n        lambda: f\"{random.randint(-10, 10)}\",  # whole number\n        lambda: f\"{random.randint(-10, 10)}/{random.randint(1, 10)}\",  # fraction\n        lambda: f\"{random.randint(-10, 10)}_{random.randint(0, 10)}/{random.randint(1, 10)}\"  # mixed number\n    ]\n    \n    # Randomly choose the number of terms (2 to 4)\n    num_terms = random.randint(2, 4)\n    \n    # Generate terms and operators\n    terms = []\n    for _ in range(num_terms):\n        term_format = random.choice(fraction_formats)\n        terms.append(term_format())\n    \n    # Generate operators (one less than the number of terms)\n    ops = random.choices(operators, k=num_terms - 1)\n    \n    # Combine terms and operators\n    expression_parts = []\n    for i in range(num_terms):\n        expression_parts.append(terms[i])\n        if i < len(ops):\n            expression_parts.append(ops[i])\n    \n    # Join with spaces\n    expression = ' '.join(expression_parts)\n    \n    return {'expression': expression}", "io_pairs": [{"input": {"expression": "2 + 0_0/5"}, "output": "2"}, {"input": {"expression": "10_2/1 - 5/5 + 9_2/8"}, "output": "20_1/4"}, {"input": {"expression": "5_5/3 / 4_5/10 / 6"}, "output": "20/81"}, {"input": {"expression": "-4/9 + 0/5"}, "output": "4/9"}, {"input": {"expression": "5 + 1_0/8 / -8_1/7 / 4/8"}, "output": "5_14/55"}, {"input": {"expression": "-8_9/5 / 8_8/8 + 8_3/5"}, "output": "9_13/45"}, {"input": {"expression": "-8_0/1 * -9/1"}, "output": "72"}, {"input": {"expression": "10 + -2/9 * 4_1/8"}, "output": "10_11/12"}, {"input": {"expression": "1_9/2 + -7 - 4 * 5_8/4"}, "output": "26_1/2"}, {"input": {"expression": "9 / -5/2 - -7_3/3 + 5"}, "output": "14_3/5"}], "error_log": []}
{"context": "Given an initial integer `n` and a sequence of fractions represented by `fstring`, what are the first `m` terms of the FRACTRAN sequence starting from `n`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The initial integer for the FRACTRAN sequence.\n  `fstring` (str): A string representing the fractions in the FRACTRAN sequence, separated by commas. Each fraction should be in the form \"numerator / denominator\".\n  `m` (int): The number of terms to generate in the FRACTRAN sequence.\n\nOutput:\n  `return` (list of int): A list containing the first `m` terms of the FRACTRAN sequence starting from `n`, represented as integers.", "reference_code": "# import necessary packages\nfrom fractions import Fraction\nimport math\n\n# main function\ndef main_solution(n, fstring, m):\n    # Convert the input string to a list of Fraction objects\n    flist = [Fraction(f) for f in fstring.replace(' ', '').split(',')]\n    \n    # Convert n to a Fraction\n    n = Fraction(n)\n    \n    # Initialize an empty list to store the first m members of the sequence\n    result = []\n    \n    # Generate the sequence\n    for _ in range(m):\n        result.append(n.numerator)\n        for f in flist:\n            if (n * f).denominator == 1:\n                n *= f\n                break\n        else:\n            break\n    \n    # Return the result as a list of integers\n    return result", "input_generator": "import random\nfrom fractions import Fraction\n\ndef input_generator():\n    n = random.randint(1, 10)\n    flist = []\n    for _ in range(random.randint(1, 5)):\n        numerator = random.randint(1, 5)\n        denominator = random.randint(1, 5)\n        flist.append(f\"{numerator}/{denominator}\")\n    fstring = ','.join(flist)\n    m = random.randint(1, 10)\n    return {'n': n, 'fstring': fstring, 'm': m}", "io_pairs": [{"input": {"n": 3, "fstring": "1/5", "m": 7}, "output": [3]}, {"input": {"n": 7, "fstring": "3/3,2/2,2/4,3/4", "m": 5}, "output": [7, 7, 7, 7, 7]}, {"input": {"n": 3, "fstring": "3/2,3/2", "m": 10}, "output": [3]}, {"input": {"n": 9, "fstring": "5/5,4/1,5/3", "m": 4}, "output": [9, 9, 9, 9]}, {"input": {"n": 6, "fstring": "3/2", "m": 1}, "output": [6]}, {"input": {"n": 1, "fstring": "2/2,3/5,2/2", "m": 5}, "output": [1, 1, 1, 1, 1]}, {"input": {"n": 4, "fstring": "4/3,5/1,5/2,1/4,3/1", "m": 4}, "output": [4, 20, 100, 500]}, {"input": {"n": 1, "fstring": "4/1,1/3,4/3", "m": 2}, "output": [1, 4]}, {"input": {"n": 1, "fstring": "1/1,3/3,4/2,2/2", "m": 10}, "output": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"input": {"n": 6, "fstring": "1/1,3/1", "m": 10}, "output": [6, 6, 6, 6, 6, 6, 6, 6, 6, 6]}], "error_log": []}
{"context": "In a game of Tic Tac Toe, a player and a computer take turns marking spaces on a 3x3 grid. The player uses the mark `0` and the computer uses the mark `1`. Given the current state of the board and the position where the player wants to place their mark, determine the state of the board after both the player and the computer have made their moves. What is the final state of the board and the status of the game?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists of int or None): A 3x3 grid representing the Tic Tac Toe board. Each cell can be `0`, `1`, or `None` (empty).\n  `player_id` (int): The ID of the player making the move. Can be `0` or `1`.\n  `player_pos` (tuple of int): The position on the board where the player wants to place their mark. The position is a tuple `(x, y)` where `x` and `y` are integers between 0 and 2.\n\nOutput:\n  `return` (dict): A dictionary containing the updated board and the status of the game. The dictionary has the following keys:\n    - `board` (list of lists of int or None): The updated 3x3 grid after the player and computer have made their moves.\n    - `status` (str): The status of the game. Possible values are:\n      - `\"invalid\"`: If the player's move is invalid.\n      - `\"player_wins\"`: If the player wins after their move.\n      - `\"computer_wins\"`: If the computer wins after its move.\n      - `\"draw\"`: If the game ends in a draw.\n      - `\"ongoing\"`: If the game is still ongoing after both moves.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass player(object):\n    def __init__(self, id):\n        self.id = id\n\n    def move(self, board, pos):\n        tile_pos = self.find_tile(pos)\n        board, status = tile(board, self.id, tile_pos[0], tile_pos[1]).display()\n        return board, status\n\n    def find_tile(self, pos):\n        if pos[0] <= 150:\n            if pos[1] <= 150:\n                return (0, 0)\n            elif pos[1] > 150 and pos[1] <= 300:\n                return (1, 0)\n            elif pos[1] > 300 and pos[1] <= 450:\n                return (2, 0)\n        elif pos[0] > 150 and pos[0] <= 300:\n            if pos[1] <= 150:\n                return (0, 1)\n            elif pos[1] > 150 and pos[1] <= 300:\n                return (1, 1)\n            elif pos[1] > 300 and pos[1] <= 450:\n                return (2, 1)\n        elif pos[0] > 300 and pos[0] <= 450:\n            if pos[1] <= 150:\n                return (0, 2)\n            elif pos[1] > 150 and pos[1] <= 300:\n                return (1, 2)\n            elif pos[1] > 300 and pos[1] <= 450:\n                return (2, 2)\n\nclass computer(object):\n    def __init__(self, id):\n        self.id = id\n\n    def move(self, board):\n        bestScore = -100\n        bestMove = None\n        for i, row in enumerate(board):\n            for j, column in enumerate(row):\n                if column is None:\n                    board[i][j] = self.id\n                    score = self.minimax(board, 0, False)\n                    board[i][j] = None\n                    if score > bestScore:\n                        bestScore = score\n                        bestMove = [i, j]\n\n        board[bestMove[0]][bestMove[1]] = self.id\n        return board\n\n    def minimax(self, board, depth, isMaximizer):\n        scores = {0: -1, 1: 1, 'draw': 0}\n        result = check_win(board)\n        if result is not None:\n            return scores[result]\n\n        if isMaximizer:\n            bestScore = -100\n            for i, row in enumerate(board):\n                for j, column in enumerate(row):\n                    if column is None:\n                        board[i][j] = self.id\n                        score = self.minimax(board, depth + 1, False)\n                        board[i][j] = None\n                        bestScore = max(score, bestScore)\n            return bestScore\n        else:\n            bestScore = 100\n            for i, row in enumerate(board):\n                for j, column in enumerate(row):\n                    if column is None:\n                        board[i][j] = 1 - self.id\n                        score = self.minimax(board, depth + 1, True)\n                        board[i][j] = None\n                        bestScore = min(score, bestScore)\n            return bestScore\n\nclass tile(object):\n    def __init__(self, board, id, row, column):\n        self.board = board\n        self.id = id\n        self.row = row\n        self.column = column\n\n    def display(self):\n        if self.board[self.row][self.column] is None:\n            self.board[self.row][self.column] = self.id\n            return self.board, True\n        else:\n            return self.board, False\n\n# Check rows of board for win\ndef check_rows(board):\n    for i, row in enumerate(board):\n        if None in row:\n            continue\n        elif len(set(row)) == 1:\n            return board[i][0]\n    return None\n\n# Check columns of board for win\ndef check_columns(board):\n    columns = [[None, None, None], [None, None, None], [None, None, None]]\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            columns[i][j] = board[j][i]\n    return check_rows(columns)\n\n# Check diagonals of board for win\ndef check_diagonals(board):\n    diagonal_1 = [board[0][0], board[1][1], board[2][2]]\n    diagonal_2 = [board[0][2], board[1][1], board[2][0]]\n    if (None not in diagonal_1) and (len(set(diagonal_1)) == 1):\n        return diagonal_1[0]\n    elif (None not in diagonal_2) and (len(set(diagonal_2)) == 1):\n        return diagonal_2[0]\n    else:\n        return None\n\n# Check if board is displayed\ndef check_draw(board):\n    for row in board:\n        if None in row:\n            return None\n    return \"draw\"\n\n# Check if there is a win\ndef check_win(board):\n    if check_rows(board) is not None:\n        return check_rows(board)\n    elif check_columns(board) is not None:\n        return check_columns(board)\n    elif check_diagonals(board) is not None:\n        return check_diagonals(board)\n    elif check_draw(board) is not None:\n        return check_draw(board)\n    else:\n        return None\n\n# main function\ndef main_solution(board, player_id, player_pos):\n    user = player(player_id)\n    com = computer(1 - player_id)\n\n    # Player's move\n    board, status = user.move(board, player_pos)\n    if not status:\n        return {\"board\": board, \"status\": \"invalid\"}\n\n    # Check if player wins\n    if check_win(board) == player_id:\n        return {\"board\": board, \"status\": \"player_wins\"}\n\n    # Computer's move\n    board = com.move(board)\n\n    # Check if computer wins\n    if check_win(board) == (1 - player_id):\n        return {\"board\": board, \"status\": \"computer_wins\"}\n\n    # Check for draw\n    if check_draw(board) == \"draw\":\n        return {\"board\": board, \"status\": \"draw\"}\n\n    return {\"board\": board, \"status\": \"ongoing\"}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random board state: None, 0, or 1 for each cell\n    board = [[random.choice([None, 0, 1]) for _ in range(3)] for _ in range(3)]\n    \n    # Random player ID (0 or 1)\n    player_id = random.randint(0, 1)\n    \n    # Random player position within the 450x450 grid\n    player_pos = (random.randint(0, 450), random.randint(0, 450))\n    \n    return {\n        \"board\": board,\n        \"player_id\": player_id,\n        \"player_pos\": player_pos\n    }", "io_pairs": [{"input": {"board": [[null, null, 0], [1, 0, 0], [1, 1, 0]], "player_id": 0, "player_pos": [157, 196]}, "output": {"board": [[null, null, 0], [1, 0, 0], [1, 1, 0]], "status": "player_wins"}}, {"input": {"board": [[null, null, 0], [0, 1, 1], [0, null, 0]], "player_id": 0, "player_pos": [211, 239]}, "output": {"board": [[null, null, 0], [0, 1, 1], [0, null, 0]], "status": "invalid"}}, {"input": {"board": [[1, 0, 0], [0, null, 0], [null, 0, null]], "player_id": 0, "player_pos": [200, 432]}, "output": {"board": [[1, 0, 0], [0, null, 0], [null, 0, null]], "status": "ongoing"}}, {"input": {"board": [[1, 0, 1], [1, 0, 1], [null, 1, 0]], "player_id": 0, "player_pos": [246, 139]}, "output": {"board": [[1, 0, 1], [1, 0, 1], [null, 1, 0]], "status": "ongoing"}}, {"input": {"board": [[0, 1, null], [null, 1, null], [0, 1, 1]], "player_id": 1, "player_pos": [339, 308]}, "output": {"board": [[0, 1, null], [null, 1, null], [0, 1, 1]], "status": "invalid"}}, {"input": {"board": [[0, 0, 0], [1, 0, null], [0, 0, 1]], "player_id": 1, "player_pos": [1, 290]}, "output": {"board": [[0, 0, 0], [1, 0, null], [0, 0, 1]], "status": "computer_wins"}}, {"input": {"board": [[1, 1, 1], [1, 0, 1], [1, 0, 1]], "player_id": 0, "player_pos": [269, 350]}, "output": {"board": [[1, 1, 1], [1, 0, 1], [1, 0, 1]], "status": "computer_wins"}}, {"input": {"board": [[null, null, 0], [0, 1, 1], [null, 0, 1]], "player_id": 0, "player_pos": [408, 139]}, "output": {"board": [[null, null, 0], [0, 1, 1], [null, 0, 1]], "status": "invalid"}}, {"input": {"board": [[null, null, 0], [0, 0, 1], [1, null, 0]], "player_id": 0, "player_pos": [443, 340]}, "output": {"board": [[null, null, 0], [0, 0, 1], [1, null, 0]], "status": "invalid"}}, {"input": {"board": [[0, 1, 0], [0, 0, null], [1, 1, 1]], "player_id": 1, "player_pos": [114, 251]}, "output": {"board": [[0, 1, 0], [0, 0, null], [1, 1, 1]], "status": "invalid"}}], "error_log": []}
{"context": "In a game of cups, the cups are labeled with digits from '1' to '9' and are arranged in a specific order. The game involves moving cups according to certain rules. After a certain number of moves, what is the order of the cups starting just after the cup labeled '1', and what is the product of the labels of the two cups that follow the cup labeled '1' after a larger number of moves?\n\nThe input and output requirements are as follows:\n\nInput:\n  `cups_str` (str): A string representing the initial arrangement of cups, where each character is a digit from '1' to '9'.\n  `iterations_part1` (int): The number of iterations to perform for part 1 of the problem.\n  `iterations_part2` (int): The number of iterations to perform for part 2 of the problem.\n\nOutput:\n  `return` (dict): A dictionary containing the results of the two parts of the problem.\n    - `part_1` (str): A string representing the order of cups after the specified number of iterations for part 1, starting just after the cup labeled '1'.\n    - `part_2` (int): The product of the labels of the two cups that follow the cup labeled '1' after the specified number of iterations for part 2.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef move(cups):\n    cur_cup = cups[0]\n    pick_up = cups[1:4]\n    cups_left = cups[4:]\n\n    dest_cup_label = cur_cup - 1\n    while dest_cup_label not in cups_left:\n        dest_cup_label -= 1\n        if dest_cup_label < min(cups):\n            dest_cup_label = max(cups)\n\n    dest_idx = cups_left.index(dest_cup_label)  # index in remaining cups\n    return cups_left[: dest_idx + 1] + pick_up + cups_left[dest_idx + 1 :] + [cur_cup]\n\ndef move_p2(cup_dict, cur_cup):\n    pick_up = []\n    _cup = cur_cup\n    for _ in range(3):  # pick up three cups\n        _cup = cup_dict[_cup]\n        pick_up.append(_cup)\n\n    # next cup after current cup is cup that comes after the cups that were picked up\n    cup_dict[cur_cup] = cup_dict[_cup]\n\n    dest_cup_label = cur_cup - 1\n    if dest_cup_label == 0:\n        dest_cup_label = 1_000_000\n    while dest_cup_label in pick_up:  # all numbers are either picked up or left\n        dest_cup_label -= 1\n        if dest_cup_label < 1:  # hardcode min/max for performance\n            dest_cup_label = 1_000_000\n\n    # last picked up cup needs to point to old cup the destination cup pointed to\n    cup_dict[pick_up[2]] = cup_dict[dest_cup_label]\n\n    # destination cup needs to point to first picked up cup\n    cup_dict[dest_cup_label] = pick_up[0]\n\n    return cup_dict\n\ndef create_cup_dict(cups):\n    \"\"\"dictionary for better performance, key: label, value: next label\"\"\"\n    cdict = {}\n    for i, cup in enumerate(cups[:-1]):\n        cdict.update({cup: cups[i + 1]})\n    cdict.update({cups[-1]: cups[0]})\n    return cdict\n\n# main function\ndef main_solution(cups_str, iterations_part1, iterations_part2):\n    # Convert input string to list of integers\n    cups = [int(x) for x in cups_str]\n    \n    # Part 1: Perform the move operation for a specified number of iterations\n    for _ in range(iterations_part1):\n        cups = move(cups)\n    \n    # Find the index of cup labeled 1\n    idx_1 = cups.index(1)\n    # Create the result string for part 1\n    part_1 = \"\".join([str(c) for c in cups[idx_1 + 1 :]] + [str(c) for c in cups[:idx_1]])\n    \n    # Part 2: Extend the cups list and create the cup dictionary\n    cups_extended = cups + [i for i in range(len(cups) + 1, 1_000_000 + 1)]\n    cup_dict = create_cup_dict(cups_extended)\n    cur_cup = cups_extended[0]\n    \n    # Perform the move_p2 operation for a specified number of iterations\n    for _ in range(iterations_part2):\n        cup_dict = move_p2(cup_dict, cur_cup)\n        cur_cup = cup_dict[cur_cup]\n    \n    # Calculate the result for part 2\n    part_2 = cup_dict[1] * cup_dict[cup_dict[1]]\n    \n    # Return the results as a dictionary\n    return {\"part_1\": part_1, \"part_2\": part_2}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random initial cup configuration (digits 1-9, shuffled)\n    cups = [str(i) for i in range(1, 10)]\n    random.shuffle(cups)\n    cups_str = ''.join(cups[:random.randint(5, 9)])  # Random length between 5 and 9\n    \n    # Generate random iteration counts within reasonable bounds\n    iterations_part1 = random.randint(10, 100)\n    iterations_part2 = random.randint(100, 1000)\n    \n    return {\n        \"cups_str\": cups_str,\n        \"iterations_part1\": iterations_part1,\n        \"iterations_part2\": iterations_part2\n    }", "io_pairs": [{"input": {"cups_str": "42183576", "iterations_part1": 52, "iterations_part2": 988}, "output": {"part_1": "5347862", "part_2": 90}}, {"input": {"cups_str": "8372165", "iterations_part1": 72, "iterations_part2": 282}, "output": {"part_1": "762385", "part_2": 24}}, {"input": {"cups_str": "972145", "iterations_part1": 62, "iterations_part2": 121}, "output": {"part_1": "57294", "part_2": 117}}, {"input": {"cups_str": "652397148", "iterations_part1": 91, "iterations_part2": 541}, "output": {"part_1": "24957386", "part_2": 14}}, {"input": {"cups_str": "46198357", "iterations_part1": 74, "iterations_part2": 751}, "output": {"part_1": "4935687", "part_2": 90}}, {"input": {"cups_str": "7425169", "iterations_part1": 71, "iterations_part2": 821}, "output": {"part_1": "675429", "part_2": 42}}, {"input": {"cups_str": "67139", "iterations_part1": 35, "iterations_part2": 937}, "output": {"part_1": "3697", "part_2": 18}}, {"input": {"cups_str": "576981", "iterations_part1": 86, "iterations_part2": 205}, "output": {"part_1": "76895", "part_2": 56}}, {"input": {"cups_str": "56719", "iterations_part1": 11, "iterations_part2": 727}, "output": {"part_1": "5967", "part_2": 30}}, {"input": {"cups_str": "82564913", "iterations_part1": 87, "iterations_part2": 380}, "output": {"part_1": "9352864", "part_2": 192}}], "error_log": []}
{"context": "Given a number of pairs of parentheses, how can we generate all possible well-formed combinations of parentheses of the specified length?\n\nThe input and output requirements are as follows:\n\nInput:\n  `A` (int): An integer representing the number of pairs of parentheses.\n\nOutput:\n  `return` (list of str): A sorted list of all possible well-formed combinations of parentheses of length 2*A.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    # @param A : integer\n    # @return a list of strings\n    def generateParenthesis(self, n):\n        stack = []\n        res = []\n\n        def backtrack(openN, closedN):\n            if openN == closedN == n:\n                res.append(\"\".join(stack))\n                return\n            \n            if openN < n:\n                stack.append(\"(\")\n                backtrack(openN+1, closedN)\n                stack.pop()\n            \n            if closedN < openN:\n                stack.append(\")\")\n                backtrack(openN, closedN+1)\n                stack.pop()\n        \n        backtrack(0,0)\n        return res\n\n# main function\ndef main_solution(A):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.generateParenthesis(A)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    return {'A': random.randint(1, 5)}", "io_pairs": [{"input": {"A": 1}, "output": ["()"]}, {"input": {"A": 2}, "output": ["(())", "()()"]}, {"input": {"A": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}], "error_log": []}
{"context": "Given two prime numbers `p` and `q`, and a plaintext message, what are the encrypted and decrypted values when using the RSA encryption algorithm?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p` (int): A prime number used in the RSA encryption algorithm.\n  `q` (int): Another prime number used in the RSA encryption algorithm.\n  `plaintext` (int): The integer message to be encrypted using the RSA algorithm.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `ciphertext` (int): The encrypted message.\n    - `decrypted_text` (int): The decrypted message, which should match the original plaintext.", "reference_code": "# import necessary packages\nimport random\nfrom math import gcd as bltin_gcd\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\nclass encryption_set():\n    def __init__(self, p, q, custom_e=None, custom_d=None, custom_k=None):\n        self.p = p\n        self.q = q\n        self.n = p * q\n        self.totient = self.generate_totient(p, q)\n        self.debug = False\n        self.e = custom_e if custom_e else self.generate_random_valid_e()\n        self.d = custom_d if custom_d else self.generate_random_valid_d()\n        self.k = custom_k if custom_k else None\n\n    def generate_random_valid_e(self):\n        while True:\n            rand_num = random.sample(range(2, self.n), 1)[0]\n            if rand_num < self.n and check_coprimality(self.totient, rand_num):\n                break\n        return rand_num\n\n    def generate_random_valid_d(self):\n        possible_k = 1\n        while True:\n            possible_d = (1 + possible_k * self.totient) / self.e\n            if possible_d.is_integer():\n                self.k = possible_k\n                break\n            possible_k += 1\n            if possible_d > self.n:\n                self.d = 1\n                self.k = 1\n                break\n        return int(possible_d)\n\n    def generate_totient(self, p, q):\n        return (p - 1) * (q - 1)\n\n    def encrypt_int(self, val):\n        return pow(val, self.e, self.n)\n\n    def decrypt_int(self, val):\n        return pow(val, self.d, self.n)\n\n    def get_septuple(self):\n        return [self.p, self.q, self.n, self.totient, self.e, self.k, self.d]\n\n# Simple function to check for co-primality\ndef check_coprimality(a, b):\n    return bltin_gcd(a, b) == 1\n\n# main function\ndef main_solution(p, q, plaintext):\n    # Convert JSON serializable inputs to original input variables\n    p = int(p)\n    q = int(q)\n    plaintext = int(plaintext)\n\n    # Create an instance of the encryption_set class\n    rsa = encryption_set(p, q)\n\n    # Encrypt the plaintext\n    ciphertext = rsa.encrypt_int(plaintext)\n\n    # Decrypt the ciphertext\n    decrypted_text = rsa.decrypt_int(ciphertext)\n\n    # Convert the output to JSON serializable format\n    result = {\n        \"ciphertext\": ciphertext,\n        \"decrypted_text\": decrypted_text\n    }\n\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate two distinct prime numbers p and q\n    def generate_prime(min_val=10, max_val=1000):\n        primes = [i for i in range(min_val, max_val) if is_prime(i)]\n        return random.choice(primes)\n    \n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    p = generate_prime()\n    q = generate_prime()\n    while q == p:\n        q = generate_prime()\n    \n    # Generate plaintext as an integer less than n = p * q\n    n = p * q\n    plaintext = random.randint(1, n - 1)\n    \n    return {\n        \"p\": p,\n        \"q\": q,\n        \"plaintext\": plaintext\n    }", "io_pairs": [{"input": {"p": 53, "q": 347, "plaintext": 12992}, "output": {"ciphertext": 16333, "decrypted_text": 12992}}, {"input": {"p": 877, "q": 859, "plaintext": 248508}, "output": {"ciphertext": 168973, "decrypted_text": 248508}}, {"input": {"p": 641, "q": 17, "plaintext": 10443}, "output": {"ciphertext": 2217, "decrypted_text": 10443}}, {"input": {"p": 379, "q": 883, "plaintext": 42142}, "output": {"ciphertext": 102890, "decrypted_text": 42142}}, {"input": {"p": 571, "q": 911, "plaintext": 176133}, "output": {"ciphertext": 188159, "decrypted_text": 176133}}, {"input": {"p": 491, "q": 587, "plaintext": 132387}, "output": {"ciphertext": 219294, "decrypted_text": 132387}}, {"input": {"p": 53, "q": 439, "plaintext": 21236}, "output": {"ciphertext": 20083, "decrypted_text": 21236}}, {"input": {"p": 613, "q": 293, "plaintext": 49712}, "output": {"ciphertext": 39001, "decrypted_text": 49712}}, {"input": {"p": 67, "q": 197, "plaintext": 3868}, "output": {"ciphertext": 9429, "decrypted_text": 3868}}, {"input": {"p": 19, "q": 37, "plaintext": 344}, "output": {"ciphertext": 344, "decrypted_text": 344}}], "error_log": []}
{"context": "Given a random symbolic function generator that builds functions with a specified depth range, how does the function behave when evaluated at specific coordinates within the range [-1, 1]? Specifically, what is the output of the function when evaluated at the coordinates `x` and `y` within the specified depth range?\n\nThe input and output requirements are as follows:\n\nInput:\n  `min_depth` (int): Minimum depth of the random function.\n  `max_depth` (int): Maximum depth of the random function.\n  `x` (float): x-coordinate in the range [-1, 1].\n  `y` (float): y-coordinate in the range [-1, 1].\n\nOutput:\n  `return` (float): The result of evaluating the random function at the given coordinates, in the range [-1, 1].", "reference_code": "# import necessary packages\nimport math\nfrom random import randint\n\n# all class and function definitions in the code file, if any\ndef build_random_function(min_depth, max_depth):\n    \"\"\" Builds a random symbolic function with depth falling between\n    min_depth and max_depth\n\n    Inputs:\n        min_depth: minimum number of recursive calls\n        max_depth: maximum number of recursive calls\n\n    Returns:\n        A list in the form of [\"func\", a, b] where a and b are nested lists\n    \"\"\"\n    \n    base_fs = [\"x\", \"y\"]\n    other_fs = [\"prod\", \"avg\", \"cos_pi\", \"sin_pi\", \"sigmoid\"]\n    all_fs = base_fs + other_fs\n    \n    end_base = len(base_fs) - 1\n    end_other = len(other_fs) - 1\n    end_all = len(all_fs) - 1\n    \n    if min_depth == 1:\n        if max_depth == 1:\n            return [base_fs[randint(0, end_base)]]\n        else:\n            func = all_fs[randint(0, end_all)]\n            if func in base_fs:\n                return [func]\n            elif func in [\"prod\", \"avg\"]:\n                return [func, build_random_function(min_depth, max_depth - 1), build_random_function(min_depth, max_depth - 1)]\n            else:\n                return [func, build_random_function(min_depth, max_depth - 1)]\n    else:\n        return [other_fs[randint(0, end_other)], build_random_function(min_depth - 1, max_depth - 1), build_random_function(min_depth - 1, max_depth - 1)]\n\ndef evaluate_random_function(f, x, y):\n    \"\"\" Evaluates a symbolic function f for x, y in [-1,1] \n\n    Inputs:\n        f: symbolic function \n        x: float btwn [-1,1]\n        y: float btwn [-1,1]\n\n    Returns:\n        float btwn [-1,1]\n    \"\"\"\n\n    if f[0] == \"x\":\n        return x\n    elif f[0] == \"y\":\n        return y\n    else:\n        if f[0] == \"prod\":\n            return evaluate_random_function(f[1], x, y) * evaluate_random_function(f[2], x, y)\n        elif f[0] == \"avg\":\n            return (evaluate_random_function(f[1], x, y) + evaluate_random_function(f[2], x, y)) / 2.0\n        elif f[0] == \"cos_pi\":\n            return math.cos(math.pi * evaluate_random_function(f[1], x, y))\n        elif f[0] == \"sin_pi\":\n            return math.sin(math.pi * evaluate_random_function(f[1], x, y))\n        elif f[0] == \"sigmoid\":\n            return 1.0 / (1 + math.exp(-evaluate_random_function(f[1], x, y))) - 0.5\n\ndef remap_interval(val, input_interval_start, input_interval_end, output_interval_start, output_interval_end):\n    \"\"\" Maps the input value that is in the interval [input_interval_start, input_interval_end]\n    to the output interval [output_interval_start, output_interval_end].  The mapping\n    is an affine one (i.e. output = input*c + b).\n\n    inputs:\n        val: value, based on input domain\n        input_interval_start: min value of input domain\n        input_interval_end: max value of input domain\n        output_interval_start: min value of output domain\n        output_interval_end: max value of output domain\n\n    returns:\n        remapped value of input domain to output domain\n    \"\"\" \n\n    percentile = float(val - input_interval_start) / (input_interval_end - input_interval_start) \n    return percentile * (output_interval_end - output_interval_start) + output_interval_start\n\n# main function\ndef main_solution(min_depth, max_depth, x, y):\n    \"\"\" Generates a random symbolic function and evaluates it at the given x and y coordinates.\n\n    Inputs:\n        min_depth (int): Minimum depth of the random function.\n        max_depth (int): Maximum depth of the random function.\n        x (float): x-coordinate in the range [-1, 1].\n        y (float): y-coordinate in the range [-1, 1].\n\n    Returns:\n        float: The result of evaluating the random function at the given coordinates.\n    \"\"\"\n    random_function = build_random_function(min_depth, max_depth)\n    result = evaluate_random_function(random_function, x, y)\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    min_depth = random.randint(1, 3)\n    max_depth = random.randint(min_depth, 5)\n    x = random.uniform(-1.0, 1.0)\n    y = random.uniform(-1.0, 1.0)\n    return {\n        'min_depth': min_depth,\n        'max_depth': max_depth,\n        'x': x,\n        'y': y\n    }", "io_pairs": [{"input": {"min_depth": 1, "max_depth": 4, "x": 0.527473564210396, "y": 0.5177573144475647}, "output": -0.08620362476506317}, {"input": {"min_depth": 2, "max_depth": 2, "x": 0.040621624050659166, "y": -0.3767119339633829}, "output": -0.16804515495636185}, {"input": {"min_depth": 1, "max_depth": 2, "x": -0.9690095064870978, "y": -0.7728948003881615}, "output": -0.9690095064870978}, {"input": {"min_depth": 2, "max_depth": 2, "x": 0.5257986295974355, "y": 0.7553791103639782}, "output": 0.27646419888654117}, {"input": {"min_depth": 2, "max_depth": 4, "x": -0.0307149166077183, "y": -0.4815428776635142}, "output": 0.003697569926057187}, {"input": {"min_depth": 1, "max_depth": 2, "x": -0.8055011596120512, "y": -0.1938891248524015}, "output": -0.5737164127832515}, {"input": {"min_depth": 3, "max_depth": 3, "x": 0.8192258457416359, "y": 0.8794213298883664}, "output": -0.8430222574867408}, {"input": {"min_depth": 2, "max_depth": 5, "x": 0.9175651160497684, "y": 0.4933426382678108}, "output": 0.12648863262467458}, {"input": {"min_depth": 3, "max_depth": 3, "x": 0.09238078543390205, "y": 0.49191455091929703}, "output": 0.011358908431878145}, {"input": {"min_depth": 2, "max_depth": 4, "x": -0.3600081832807718, "y": -0.6941150084910892}, "output": -0.0018376421845446452}], "error_log": []}
{"context": "Given a set of movement instructions for a rope with multiple knots, where each knot follows the previous one according to specific rules, how many unique positions does the tail of the rope visit after executing all the instructions? The rope moves on a grid with specified boundaries, and the instructions include directions (right, up, left, down) and the number of steps to move in that direction.\n\nThe input and output requirements are as follows:\n\nInput:\n- `instructions` (str): A string containing the movement instructions for the rope, where each line is a direction followed by a number of steps (e.g., \"R 4\\nU 2\").\n- `knots` (list of str): A list of knot identifiers (e.g., ['H', 'T'] for a rope with a head and a tail).\n- `grid_size` (list of tuples): A list containing two tuples representing the top-left and bottom-right corners of the grid (e.g., [(-11, -15), (14, 5)]).\n\nOutput:\n- `return` (int): The number of unique positions visited by the tail of the rope after executing all instructions.", "reference_code": "# import necessary packages\nfrom pathlib import Path\nimport random\n\n# all class and function definitions in the code file, if any\nclass Grid():\n    C = { 'R': (1,0), 'U': (0,-1), 'L': (-1,0), 'D': (0,1) }\n    D = { 'UR': (1,-1), 'UL': (-1,-1), 'DL': (-1,1), 'DR': (1,1) }\n    \n    def __init__(self) -> None:\n        pass\n\n    @staticmethod\n    def neighbors_all(pos):\n        d = list(Grid.D.values()) + list(Grid.C.values())\n        return Grid.neighbors(pos, d)\n    \n    @staticmethod\n    def neighbors_diagonal(pos):\n        return Grid.neighbors(pos, Grid.D.values())\n\n    @staticmethod\n    def neighbors_cardinal(pos):\n        return Grid.neighbors(pos, Grid.C.values())\n\n    @staticmethod\n    def neighbors(pos, directions):\n        x, y = pos\n        neighbors = set()\n        for (dx, dy) in directions:\n            neighbors.add((dx + x, dy + y))\n\n        return neighbors\n\nclass Rope():\n    def __init__(self, knots) -> None:\n        self.head = Knot(knots.pop(0))\n\n        ptr = self.head\n        while knots:\n            k = knots.pop(0)\n            ptr.next = Knot(k)\n            ptr = ptr.next\n\n    @property\n    def tail(self):\n        tail = self.head\n        while tail.next:\n            tail = tail.next\n\n        return tail\n\n    def __iter__(self):\n        self.__ptr = self.head\n        return self\n\n    def __next__(self):\n        n = None\n        if self.__ptr:\n            n = self.__ptr\n            self.__ptr = n.next\n        else:\n            raise StopIteration\n        return n\n\n    def __repr__(self) -> str:\n        return f\"{list(self)}\"\n\n    def __str__(self) -> str:\n        return f\"{list(self)}\"\n\nclass Knot():\n    def __init__(self, id, pos = (0,0)) -> None:\n        self.id = id\n        self.next = None\n        self.pos = None\n        self.visited = set()\n        self.move(pos)\n\n    def __str__(self) -> str:\n        return f\"{self.id}\"\n\n    def __repr__(self) -> str:\n        return f\"{self.id}\"\n\n    def move(self, pos):   \n        self.pos = pos\n        self.visited.add(self.pos)\n\n        if not self.next:\n            return \n\n        if self.next.pos == self.pos:\n            return \n        if self.next.pos in Grid.neighbors_all(self.pos):\n            return \n\n        # Prefer a cardinal position\n        for pos in Grid.neighbors_all(self.next.pos):\n            if pos in Grid.neighbors_cardinal(self.pos):\n                self.next.move(pos)\n                break\n\n        # But fall back to a diagonal\n        if self.next.pos not in Grid.neighbors_all(self.pos):\n            for pos in Grid.neighbors_all(self.next.pos):\n                if pos in Grid.neighbors_all(self.pos):\n                    self.next.move(pos)\n                    break\n\nclass Sim():\n    def __init__(self, instructions, rope, grid_size=[(0,-4),(5,0)]) -> None:\n        self.instructions = instructions\n        self.rope = rope\n        self.grid_size = grid_size\n\n    def next(self):\n        instruction = self.instructions.pop(0)\n        direction, steps = instruction.split()\n\n        for _ in range(int(steps)):\n            x, y = self.rope.head.pos\n            dx, dy = Grid.C[direction]\n            self.rope.head.move((x + dx, y + dy))\n\n# main function\ndef main_solution(instructions, knots, grid_size):\n    # Convert instructions to a list of strings\n    instructions = instructions.splitlines()\n    \n    # Create the rope with the given knots\n    rope = Rope(knots)\n    \n    # Create the simulator with the given instructions, rope, and grid size\n    simulator = Sim(instructions, rope, grid_size)\n    \n    # Execute the instructions\n    while simulator.instructions:\n        simulator.next()\n    \n    # Return the number of unique positions visited by the tail of the rope\n    return len(simulator.rope.tail.visited)", "input_generator": "import random\nfrom pathlib import Path\n\ndef input_generator():\n    directions = ['R', 'U', 'L', 'D']\n    instructions = []\n    num_instructions = random.randint(5, 20)\n    \n    for _ in range(num_instructions):\n        direction = random.choice(directions)\n        steps = random.randint(1, 5)\n        instructions.append(f\"{direction} {steps}\")\n    \n    instructions_str = '\\n'.join(instructions)\n    \n    num_knots = random.randint(2, 10)\n    knots = [f\"K{i}\" for i in range(num_knots)]\n    \n    grid_min_x = random.randint(-10, 0)\n    grid_max_x = random.randint(0, 10)\n    grid_min_y = random.randint(-10, 0)\n    grid_max_y = random.randint(0, 10)\n    grid_size = [(grid_min_x, grid_min_y), (grid_max_x, grid_max_y)]\n    \n    return {\n        'instructions': instructions_str,\n        'knots': knots,\n        'grid_size': grid_size\n    }", "io_pairs": [{"input": {"instructions": "R 4\nU 5\nL 2\nD 4\nL 4\nD 3\nL 3\nD 3\nU 2\nU 1\nD 2\nR 3\nU 4\nU 4", "knots": [], "grid_size": [[0, -3], [2, 2]]}, "output": 19}, {"input": {"instructions": "U 1\nU 1\nD 4\nL 5\nL 1\nU 2\nU 3\nR 1\nD 5\nL 2\nR 3\nU 4\nR 2\nL 5\nL 4\nD 2\nL 5\nR 1\nU 4", "knots": [], "grid_size": [[-9, -9], [10, 9]]}, "output": 34}, {"input": {"instructions": "D 5\nL 3\nL 3\nR 3\nL 5\nU 2\nR 4\nL 2\nU 4\nU 1\nL 4", "knots": [], "grid_size": [[-2, 0], [4, 9]]}, "output": 23}, {"input": {"instructions": "D 4\nD 5\nU 5\nD 2\nL 5\nD 2\nL 2\nD 4\nR 4\nU 3\nD 3\nU 3\nL 1\nD 5\nL 3\nU 3", "knots": [], "grid_size": [[0, -9], [8, 0]]}, "output": 29}, {"input": {"instructions": "R 5\nL 1\nL 1\nR 3\nU 2\nL 4\nL 4\nU 3\nL 3\nU 5", "knots": [], "grid_size": [[-7, -9], [2, 3]]}, "output": 22}, {"input": {"instructions": "R 1\nU 2\nD 1\nR 1\nL 3\nL 1\nD 4\nU 5\nR 1\nL 2\nU 2\nR 4\nD 2\nL 4\nD 5", "knots": [], "grid_size": [[0, 0], [9, 7]]}, "output": 13}, {"input": {"instructions": "L 3\nU 3\nL 1\nR 5\nD 2\nL 1\nR 3\nD 4\nL 2\nD 4\nU 1\nU 4\nL 2\nR 3", "knots": [], "grid_size": [[0, -2], [7, 1]]}, "output": 20}, {"input": {"instructions": "D 1\nU 5\nD 5\nD 2\nR 5\nD 4\nD 5\nR 1\nD 1\nU 4\nL 2\nR 2\nL 5\nR 3\nR 3\nU 2", "knots": [], "grid_size": [[-9, -2], [10, 2]]}, "output": 26}, {"input": {"instructions": "R 3\nR 3\nU 5\nD 1\nR 1\nL 5\nU 4\nD 3\nU 5\nU 4\nL 1\nL 4\nD 1\nD 1", "knots": [], "grid_size": [[0, -6], [7, 3]]}, "output": 27}, {"input": {"instructions": "L 3\nL 4\nR 5\nL 5\nD 1", "knots": [], "grid_size": [[-8, 0], [0, 1]]}, "output": 7}], "error_log": []}
{"context": "Given a set of cities with specific intersections and paths between them, determine the number of possible routes between each pair of intersections for each city. If a path leads to an infinite loop, mark it as such. What is the matrix of possible routes for each city?\n\nThe input and output requirements are as follows:\n\nInput:\n  `city_data` (list of dictionaries): Each dictionary represents a city with the following keys:\n    - `iStart` (list of integers): Starting intersections for each path in the city.\n    - `iEnd` (list of integers): Ending intersections for each path in the city.\n\nOutput:\n  `return` (list of lists of lists of integers): Each sublist represents the matrix of possible routes for a city. Each element in the matrix represents the number of possible paths from one intersection to another.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass City:\n    def __init__(self):\n        self.iStart = list()\n        self.iEnd = list()\n        self.matrix = list()\n\ndef setDimensions(cityList):\n    for city in cityList:\n        iMax = 0\n        for j in range(len(city.iStart)):\n            if city.iStart[j] > iMax:\n                iMax = city.iStart[j]\n            if city.iEnd[j] > iMax:\n                iMax = city.iEnd[j]\n        for k in range(iMax + 1):\n            city.matrix.append(list())\n            for n in range(iMax + 1):\n                city.matrix[k].append(0)\n    return\n\ndef recursiveSearch(left, right, city, isInfinite):\n    for i in range(len(city.iStart)):\n        if city.iStart[i] == right:\n            if left == city.iStart[i] and right == city.iEnd[i]:\n                continue\n            tempRight = city.iEnd[i]\n            if left == tempRight:\n                city.matrix[left][tempRight] = -1\n                isInfinite = True\n                recursiveSearch(left, tempRight, city, isInfinite)\n            elif city.matrix[right][tempRight] == -1:\n                city.matrix[left][tempRight] = -1\n                continue\n            elif isInfinite:\n                city.matrix[left][tempRight] = -1\n                isInfinite = recursiveSearch(left, tempRight, city, isInfinite)\n            else:\n                city.matrix[left][tempRight] += 1\n                isInfinite = recursiveSearch(left, tempRight, city, isInfinite)\n    return isInfinite\n\n# main function\ndef main_solution(city_data):\n    cityList = [City() for _ in range(len(city_data))]\n    for i, city in enumerate(cityList):\n        city.iStart = city_data[i]['iStart']\n        city.iEnd = city_data[i]['iEnd']\n    \n    setDimensions(cityList)\n    \n    for city in cityList:\n        for j in range(len(city.iStart)):\n            isInfinite = False\n            left = city.iStart[j]\n            right = city.iEnd[j]\n            if city.matrix[left][right] != -1 and not recursiveSearch(left, right, city, isInfinite):\n                city.matrix[left][right] += 1\n            else:\n                city.matrix[left][right] = -1\n    \n    result = []\n    for city in cityList:\n        result.append(city.matrix)\n    \n    return result", "input_generator": "import random\n\ndef input_generator():\n    num_cities = random.randint(1, 5)\n    city_data = []\n    \n    for _ in range(num_cities):\n        num_edges = random.randint(1, 10)\n        iStart = []\n        iEnd = []\n        \n        for _ in range(num_edges):\n            start = random.randint(0, 10)\n            end = random.randint(0, 10)\n            iStart.append(start)\n            iEnd.append(end)\n        \n        city_data.append({\n            'iStart': iStart,\n            'iEnd': iEnd\n        })\n    \n    return {'city_data': city_data}", "io_pairs": [{"input": {"city_data": [{"iStart": [4, 2], "iEnd": [5, 0]}]}, "output": [[[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0]]]}, {"input": {"city_data": [{"iStart": [0], "iEnd": [5]}]}, "output": [[[0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]]}, {"input": {"city_data": [{"iStart": [1, 2], "iEnd": [3, 0]}]}, "output": [[[0, 0, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 0, 0]]]}, {"input": {"city_data": [{"iStart": [4], "iEnd": [0]}]}, "output": [[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0]]]}, {"input": {"city_data": [{"iStart": [2], "iEnd": [1]}]}, "output": [[[0, 0, 0], [0, 0, 0], [0, 1, 0]]]}, {"input": {"city_data": [{"iStart": [1], "iEnd": [1]}]}, "output": [[[0, 0], [0, 1]]]}, {"input": {"city_data": [{"iStart": [2], "iEnd": [3]}]}, "output": [[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 0]]]}, {"input": {"city_data": [{"iStart": [0, 4], "iEnd": [4, 1]}]}, "output": [[[0, 1, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0]]]}, {"input": {"city_data": [{"iStart": [4], "iEnd": [3]}]}, "output": [[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0]]]}, {"input": {"city_data": [{"iStart": [0], "iEnd": [0]}]}, "output": [[[1]]]}], "error_log": []}
{"context": "In the context of a Boolean network model, consider a system with a given propagation matrix that defines the interactions between genes. Given a specific starting state, what is the size of the periodic orbit, the sequence of states in the periodic orbit, and the average activation of each gene in the periodic orbit?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix` (list of lists of integers): A 2D list representing the propagation matrix of the Boolean network. Each element in the matrix should be either 0 or 1.\n  `start_state` (integer): The starting state of the Boolean network, represented as an integer. This integer should be within the range [0, 2^nb_bits - 1], where `nb_bits` is the number of genes/nodes in the network.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `orbit_size` (integer): The size of the periodic orbit.\n    - `periodic_orbit` (list of integers): The sequence of states in the periodic orbit.\n    - `average_occupancies` (list of floats): The average activation of each gene in the periodic orbit, represented as a list of percentages.", "reference_code": "# import necessary packages\nimport copy\nimport collections\n\n# all class and function definitions in the code file, if any\nclass BooleanNetwork:\n    def __init__(self, matrix):\n        # Propagation Matrix\n        self.matrix = matrix\n\n        # Number of genes/nodes\n        self.nb_bits = len(matrix)\n\n        # Number of possible states (in our example 2**6 = 64)\n        self.nb_states = int(2**self.nb_bits)\n\n        # For each gene, we can set a threshold. Here we assume it's 0 for all of them\n        self.threshold = [0] * self.nb_bits\n\n    def int_to_binary(self, n):\n        \"\"\"\n        Convert an integer to binary\n        /!\\ Uses the variable: SELF.NB_BITS !\n\n        :Source: https://stackoverflow.com/questions/10411085/converting-integer-to-binary-in-python\n        :param n: Integer\n        :return: map object -> use list comprehension to print/loop in etc\n        \"\"\"\n        ret = bin(n)[2:].zfill(self.nb_bits)\n        return list(map(int, ret))\n\n    def binary_to_int(self, n):\n        \"\"\"\n        Converts binary number (list) to Integer\n        :param n: List of bits\n        :return: the list converted to int\n        \"\"\"\n        ret = \"\"\n        for bit in n:\n            ret += str(bit)\n        ret_int = int(ret, 2)\n        return ret_int\n\n    def get_states_sequence(self, start_state):\n        \"\"\"\n        From a passed starting state (INT), calculates all the following states and stops when a loop is detected.\n        :param start_state: INT - number of the starting state\n        :return: The sequence of states,\n        \"\"\"\n\n        binary_current_state = self.int_to_binary(start_state)\n\n        binary_next_state = [0] * self.nb_bits\n        states_sequence = [start_state]\n\n        state_not_visited = True\n\n        # While the state haven't already been visited...(while not orbit)\n        while state_not_visited:\n\n            for i in range(0, self.nb_bits):\n                sum_next_state = 0\n                for j in range(0, self.nb_bits):\n                    sum_next_state += binary_current_state[j] * self.matrix[j][i]\n\n                # Now we can set the next state for this gene\n                if sum_next_state > self.threshold[i]:\n                    binary_next_state[i] = 1\n                else:\n                    binary_next_state[i] = 0\n\n            # If the next state doesn't already exist, we add it to the states list and continue\n            # If not, we add it and end the while loop\n\n            if self.binary_to_int(binary_next_state) not in states_sequence:\n                states_sequence.append(self.binary_to_int(binary_next_state))\n            else:\n                states_sequence.append(self.binary_to_int(binary_next_state))\n                state_not_visited = False\n\n            # The state now (starting state) is the next state\n\n            binary_current_state = copy.copy(binary_next_state)\n\n        return states_sequence\n\n    def orbit(self, start_state):\n        \"\"\"\n        Return many things, orbit is a random name here\n        :param start_state:\n        :return: see comments below\n        \"\"\"\n        # Sequence from start state -> stabilization\n        sequence = self.get_states_sequence(start_state)\n\n        # At which state it closes its orbit\n        closure = sequence[-1]\n\n        # Basin = states leading to periodic orbits (cyclic attractor)\n        partial_basin = sequence[0:sequence.index(closure)]\n\n        # Periodic orbit (cyclic attractor) of the sequence\n        periodic_orbit = sequence[sequence.index(closure):len(sequence) - 1]\n\n        # Size of the orbit\n        orbit_size = len(sequence) - sequence.index(closure) - 1\n\n        return orbit_size, periodic_orbit, closure, partial_basin\n\n    def count_attractors(self):\n        \"\"\"\n        # Returns a counter containing the sets of attractors and their occurence\n        # In our case:\n        # Counter({frozenset({0}): 23,\n        #          frozenset({1, 3, 7, 13, 55, 23, 63}): 21,\n        #          frozenset({39, 19, 5, 31}): 11,\n        #          frozenset({18, 26, 4, 36}): 9})\n        #\n        # Notice that unfortunately here the order of the attractor is not maintained\n        # Source: https://stackoverflow.com/questions/37295981/python-creating-a-dictionary-with-key-as-a-set-and-value-as-its-count\n        #\n\n        :return:\n        \"\"\"\n        all_attractors_list = [sorted(self.orbit(i)[1]) for i in range(self.nb_states)]\n        attractors_count = collections.Counter(frozenset(x) for x in all_attractors_list)\n\n        return attractors_count\n\n    def average_occupancies_in_orbit(self, orbit, print_steps=None):\n        \"\"\"\n        Count occurence of ABCDEF activated in each states\n        :param orbit:\n        :return: list of percentages like [0.25, 0.5, 0.25, 0.5, 0.5, 0.0]\n        \"\"\"\n        total_bits = [0 for _ in range(0, self.nb_bits)]\n        percentages = [0.0 for _ in range(0, self.nb_bits)]\n\n        # For every state, convert to binary and increment the occupancy\n        for state in orbit:\n            bin = self.int_to_binary(state)\n\n            # if the optional parameter is true, print the binary states\n            # allow to see more clearely the evolution of the different gene activation\n            if print_steps:\n                print(bin)\n            # Increment here\n            for i in range(0, len(bin)):\n                total_bits[i] += bin[i]\n        # Calculate percentages\n        total_elem = len(orbit)\n        for i in range(0, self.nb_bits):\n            percentages[i] = total_bits[i] / total_elem\n\n        return percentages\n\n    def get_basin_of_attraction(self):\n        \"\"\"\n\n        :return:\n        \"\"\"\n\n        sequence_set = collections.defaultdict(list)\n\n        for i in range(0, self.nb_states):\n            orbit = self.orbit(i)\n            unique_orbit_string = str(sorted(orbit[1]))\n            # We have the \"previous steps\" and the cyclic attractor -> add the previous steps to the set corresponding to the attractor to have the full basin\n            sequence_set[unique_orbit_string].extend(orbit[3])\n            # To have the whole basin, we add also the cycle\n            sequence_set[unique_orbit_string].extend(orbit[1])\n\n        for e in sequence_set:\n            sequence_set[e] = list(set(sequence_set[e]))\n\n        return sequence_set\n\n# main function\ndef main_solution(matrix, start_state):\n    # Convert matrix to list of lists if it's not already\n    if not isinstance(matrix, list):\n        matrix = matrix.tolist()\n\n    # Initialize the BooleanNetwork\n    bn = BooleanNetwork(matrix)\n\n    # Get the orbit size and periodic orbit\n    orbit_size, periodic_orbit, _, _ = bn.orbit(start_state)\n\n    # Calculate the average occupancies in the orbit\n    average_occupancies = bn.average_occupancies_in_orbit(periodic_orbit)\n\n    # Return the results as a dictionary\n    return {\n        \"orbit_size\": orbit_size,\n        \"periodic_orbit\": periodic_orbit,\n        \"average_occupancies\": average_occupancies\n    }", "input_generator": "import random\n\ndef input_generator():\n    # Randomly choose the number of bits (genes/nodes) between 2 and 6 for reasonable size\n    nb_bits = random.randint(2, 6)\n    \n    # Generate a random matrix of size nb_bits x nb_bits with values -1, 0, or 1\n    matrix = [[random.choice([-1, 0, 1]) for _ in range(nb_bits)] for _ in range(nb_bits)]\n    \n    # Generate a random start state between 0 and 2^nb_bits - 1\n    start_state = random.randint(0, 2**nb_bits - 1)\n    \n    return {\n        \"matrix\": matrix,\n        \"start_state\": start_state\n    }", "io_pairs": [{"input": {"matrix": [[-1, -1, 1, -1], [-1, 0, -1, 0], [1, -1, 0, 1], [0, 1, -1, 1]], "start_state": 7}, "output": {"orbit_size": 1, "periodic_orbit": [5], "average_occupancies": [0.0, 1.0, 0.0, 1.0]}}, {"input": {"matrix": [[1, -1], [-1, 0]], "start_state": 1}, "output": {"orbit_size": 1, "periodic_orbit": [0], "average_occupancies": [0.0, 0.0]}}, {"input": {"matrix": [[1, 0, -1], [1, -1, 0], [-1, 1, 0]], "start_state": 6}, "output": {"orbit_size": 1, "periodic_orbit": [4], "average_occupancies": [1.0, 0.0, 0.0]}}, {"input": {"matrix": [[1, 0, -1], [-1, -1, -1], [1, 1, -1]], "start_state": 7}, "output": {"orbit_size": 1, "periodic_orbit": [4], "average_occupancies": [1.0, 0.0, 0.0]}}, {"input": {"matrix": [[1, 0, -1, 0], [-1, 1, -1, 0], [-1, 1, 1, 0], [-1, 0, 1, 0]], "start_state": 0}, "output": {"orbit_size": 1, "periodic_orbit": [0], "average_occupancies": [0.0, 0.0, 0.0, 0.0]}}, {"input": {"matrix": [[-1, -1, 0], [0, 1, 0], [1, -1, 1]], "start_state": 3}, "output": {"orbit_size": 2, "periodic_orbit": [5, 1], "average_occupancies": [0.5, 0.0, 1.0]}}, {"input": {"matrix": [[1, -1, -1], [-1, -1, 0], [0, 0, 0]], "start_state": 6}, "output": {"orbit_size": 1, "periodic_orbit": [0], "average_occupancies": [0.0, 0.0, 0.0]}}, {"input": {"matrix": [[1, 1, 0, -1], [0, 0, 1, -1], [1, -1, 1, -1], [0, -1, -1, 1]], "start_state": 9}, "output": {"orbit_size": 1, "periodic_orbit": [10], "average_occupancies": [1.0, 0.0, 1.0, 0.0]}}, {"input": {"matrix": [[0, 0], [0, 0]], "start_state": 2}, "output": {"orbit_size": 1, "periodic_orbit": [0], "average_occupancies": [0.0, 0.0]}}, {"input": {"matrix": [[-1, 1, -1, 1], [1, -1, -1, 0], [-1, 0, 0, 1], [0, 0, -1, 1]], "start_state": 6}, "output": {"orbit_size": 1, "periodic_orbit": [1], "average_occupancies": [0.0, 0.0, 0.0, 1.0]}}], "error_log": []}
{"context": "Given a string, how can we determine all the unique permutations of its characters?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string for which all unique permutations of its characters need to be generated.\n\nOutput:\n  `return` (List[str]): A list of strings where each string is a unique permutation of the characters in the input string.", "reference_code": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def permutation(self, s: str) -> List[str]:\n        res = []\n        track = []\n        use = [False for i in range(len(s))]\n\n        def backtrack(track, s):\n            if len(track) == len(s):\n                res.append(''.join(track))\n                return\n            for i in range(len(s)):\n                if use[i]:\n                    continue\n                use[i] = True\n                track.append(s[i])\n                backtrack(track, s)\n                track.pop()\n                use[i] = False\n        backtrack(track, s)\n        return list(set(res))\n\n# main function\ndef main_solution(input_string: str) -> List[str]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.permutation(input_string)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 6)\n    chars = random.choices(string.ascii_letters, k=length)\n    input_string = ''.join(chars)\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "F"}, "output": ["F"]}, {"input": {"input_string": "rfb"}, "output": ["frb", "bfr", "rfb", "brf", "fbr", "rbf"]}, {"input": {"input_string": "G"}, "output": ["G"]}, {"input": {"input_string": "g"}, "output": ["g"]}, {"input": {"input_string": "As"}, "output": ["As", "sA"]}, {"input": {"input_string": "Ov"}, "output": ["vO", "Ov"]}, {"input": {"input_string": "OV"}, "output": ["OV", "VO"]}, {"input": {"input_string": "dX"}, "output": ["Xd", "dX"]}, {"input": {"input_string": "Ski"}, "output": ["ikS", "kSi", "kiS", "Sik", "iSk", "Ski"]}, {"input": {"input_string": "Sc"}, "output": ["Sc", "cS"]}], "error_log": []}
{"context": "In Bayesian statistics, the Beta-Binomial model is often used to model the probability of success in a series of Bernoulli trials. Given a prior distribution defined by parameters `a` and `b`, and a set of binomial trials with `n_trials` and `n_successes`, what are the modes of the prior, likelihood, and posterior distributions?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): The alpha parameter of the Beta distribution representing the prior.\n  `b` (float): The beta parameter of the Beta distribution representing the prior.\n  `n_trials` (int): The number of trials in the binomial distribution.\n  `n_successes` (int): The number of successes in the binomial distribution.\n  `n_steps` (int, optional): The number of steps to discretize the x-axis for plotting. Default is 100.\n\nOutput:\n  `return` (dict): A dictionary containing the modes of the prior, likelihood, and posterior distributions.\n    - `prior_mode` (float): The mode of the prior distribution.\n    - `likelihood_mode` (float): The mode of the likelihood distribution.\n    - `posterior_mode` (float): The mode of the posterior distribution.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy.stats import beta, binom\n\n# main function\ndef main_solution(a, b, n_trials, n_successes, n_steps=100):\n    # Convert JSON serializable inputs to the required types\n    a = float(a)\n    b = float(b)\n    n_trials = int(n_trials)\n    n_successes = int(n_successes)\n    n_steps = int(n_steps)\n    \n    # Generate the x-values for the distributions\n    xs = np.linspace(0, 1, n_steps)\n    \n    # Calculate prior, likelihood, and posterior\n    prior = beta(a, b).pdf(xs)\n    likelihood = binom(n_trials, xs).pmf(k=n_successes)\n    posterior = prior * likelihood\n    \n    # Find the modes of prior, likelihood, and posterior\n    prior_mode = (a - 1) / (a + b - 2) if a > 1 and b > 1 else 0\n    likelihood_mode = n_successes / n_trials\n    posterior_mode = (a + n_successes - 1) / (a + b + n_trials - 2)\n    \n    # Return the modes as a dictionary\n    return {\n        \"prior_mode\": prior_mode,\n        \"likelihood_mode\": likelihood_mode,\n        \"posterior_mode\": posterior_mode\n    }", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    a = random.uniform(0.5, 10.0)\n    b = random.uniform(0.5, 10.0)\n    n_trials = random.randint(1, 1000)\n    n_successes = random.randint(0, n_trials)\n    n_steps = random.choice([50, 100, 150, 200])\n    \n    return {\n        \"a\": a,\n        \"b\": b,\n        \"n_trials\": n_trials,\n        \"n_successes\": n_successes,\n        \"n_steps\": n_steps\n    }", "io_pairs": [{"input": {"a": 4.95760251745059, "b": 2.945099811195823, "n_trials": 655, "n_successes": 380, "n_steps": 150}, "output": {"prior_mode": 0.6704729964518021, "likelihood_mode": 0.5801526717557252, "posterior_mode": 0.5809593472149557}}, {"input": {"a": 1.7210602374906503, "b": 2.3189302372490763, "n_trials": 841, "n_successes": 730, "n_steps": 150}, "output": {"prior_mode": 0.35346255113404257, "likelihood_mode": 0.8680142687277052, "posterior_mode": 0.8667691550741274}}, {"input": {"a": 1.3637297333515037, "b": 4.175302263372561, "n_trials": 418, "n_successes": 126, "n_steps": 200}, "output": {"prior_mode": 0.10277661622957726, "likelihood_mode": 0.3014354066985646, "posterior_mode": 0.29976756632665397}}, {"input": {"a": 1.9756471018904023, "b": 3.8349807109345377, "n_trials": 490, "n_successes": 410, "n_steps": 100}, "output": {"prior_mode": 0.25603316561297124, "likelihood_mode": 0.8367346938775511, "posterior_mode": 0.8322535481307372}}, {"input": {"a": 7.130618977102581, "b": 5.38412167722677, "n_trials": 910, "n_successes": 520, "n_steps": 50}, "output": {"prior_mode": 0.583049946607894, "likelihood_mode": 0.5714285714285714, "posterior_mode": 0.5715613186195294}}, {"input": {"a": 6.591591650476139, "b": 5.11193632410952, "n_trials": 176, "n_successes": 31, "n_steps": 150}, "output": {"prior_mode": 0.5762431628085146, "likelihood_mode": 0.17613636363636365, "posterior_mode": 0.1970430613223668}}, {"input": {"a": 6.035885451804553, "b": 7.479991575961239, "n_trials": 144, "n_successes": 85, "n_steps": 50}, "output": {"prior_mode": 0.43729934243502167, "likelihood_mode": 0.5902777777777778, "posterior_mode": 0.5789497971048291}}, {"input": {"a": 7.223375142280696, "b": 2.538841059530429, "n_trials": 993, "n_successes": 161, "n_steps": 50}, "output": {"prior_mode": 0.8017523578934355, "likelihood_mode": 0.162134944612286, "posterior_mode": 0.16709601185478695}}, {"input": {"a": 5.946932119728808, "b": 2.7437773683929647, "n_trials": 128, "n_successes": 123, "n_steps": 200}, "output": {"prior_mode": 0.7393733248336746, "likelihood_mode": 0.9609375, "posterior_mode": 0.9499313843247096}}, {"input": {"a": 7.274909045391512, "b": 4.964183645504811, "n_trials": 540, "n_successes": 153, "n_steps": 200}, "output": {"prior_mode": 0.6128383866444138, "likelihood_mode": 0.2833333333333333, "posterior_mode": 0.2894649092751143}}], "error_log": []}
{"context": "Given the mathematical constant Euler's number 'e', which is approximately 2.71828, how can we calculate its value to a specified number of decimal places? Specifically, what is the value of 'e' to `digits` decimal places?\n\nThe input and output requirements are as follows:\n\nInput:\n  `digits` (int): The number of decimal places to calculate the value of Euler's number 'e'. The value should be between 1 and 1000.\n\nOutput:\n  `return` (str): The value of Euler's number 'e' to the specified number of decimal places. The result is returned as a string to preserve the precision.", "reference_code": "# import necessary packages\nimport decimal\nimport math\n\n# main function\ndef main_solution(digits):\n    \"\"\"\n    Calculate the value of Euler's number 'e' to a specified number of decimal places.\n\n    Input:\n        digits (int): Number of decimal places to calculate the value of e.\n\n    Output:\n        str: The value of e to the specified number of decimal places.\n    \"\"\"\n    D = decimal.Decimal\n    decimal.getcontext().prec = digits + 1  # +1 to account for the integer part\n    e = D(0)\n    counter = 0\n    while counter <= digits:\n        e += D(1) / D(math.factorial(counter))\n        counter += 1\n    return str(e)", "input_generator": "import random\n\ndef input_generator():\n    return {'digits': random.randint(1, 100)}", "io_pairs": [{"input": {"digits": 42}, "output": "2.718281828459045235360287471352662497757246"}, {"input": {"digits": 13}, "output": "2.7182818284468"}, {"input": {"digits": 5}, "output": "2.71667"}, {"input": {"digits": 54}, "output": "2.718281828459045235360287471352662497757247093699959574"}, {"input": {"digits": 44}, "output": "2.71828182845904523536028747135266249775724713"}, {"input": {"digits": 39}, "output": "2.718281828459045235360287471352662497761"}, {"input": {"digits": 15}, "output": "2.718281828458995"}, {"input": {"digits": 63}, "output": "2.718281828459045235360287471352662497757247093699959574966967633"}, {"input": {"digits": 38}, "output": "2.71828182845904523536028747135266249776"}, {"input": {"digits": 64}, "output": "2.7182818284590452353602874713526624977572470936999595749669676273"}], "error_log": []}
{"context": "Given a list of integers, a number of folds, and a target integer, what are the results of various recursive operations performed on the list and the target integer? Specifically, what is the product of the list elements, the count of elements, the sum of elements, the reversed list, the nth Fibonacci number, whether the target integer forms a palindrome, and the dimensions of a folded piece of paper after n folds?\n\nThe input and output requirements are as follows:\n\nInput:\n  `lst` (list of integers): A list of integers for which we need to perform various recursive operations.\n  `n` (integer): An integer representing the number of folds for the paper folding operation and the nth Fibonacci number.\n  `target` (integer): An integer used to check if it forms a palindrome when converted to a string.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys and values:\n    - \"product\" (integer): The product of all elements in the input list.\n    - \"count\" (integer): The number of elements in the input list.\n    - \"sum\" (integer): The sum of all elements in the input list.\n    - \"reversed_list\" (list of integers): The input list reversed.\n    - \"fibonacci\" (integer): The nth Fibonacci number.\n    - \"is_palindrome\" (boolean): True if the target integer forms a palindrome when converted to a string, otherwise False.\n    - \"folded_paper\" (tuple of floats): The dimensions of a folded piece of paper after n folds.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\ndef multiply_list(lst):\n    if len(lst) == 0: \n        return 0\n    elif len(lst) == 1: \n        return lst[0]\n    else: \n        return lst[0] * multiply_list(lst[1:])\n\ndef factorial(n):\n    if n < 2: \n        return 1\n    else: \n        return n * factorial(n - 1)\n\ndef count_list(lst):\n    if lst == []: \n        return 0\n    else: \n        return 1 + count_list(lst[1:])\n\ndef sum_list(lst):\n    if lst == []: \n        return 0\n    else: \n        return lst[0] + sum_list(lst[1:])\n\ndef reverse(lst):\n    if lst == []:\n        return []\n    else: \n        return [lst[-1]] + reverse(lst[:-1])\n\ndef fibonacci(n):\n    if n == 0 or n == 1: \n        return n\n    return fibonacci(n -1) + fibonacci(n - 2)\n\ndef find(lst, i):\n    if i not in lst:\n        return None\n    elif i == lst[0]: \n        return lst[0]\n    return find(lst[1:], i)\n\ndef is_palindrome(some_string):\n    some_string = list(some_string)\n    if len(some_string) <= 1: \n        return True\n    elif some_string.pop(0) == some_string.pop():\n        return is_palindrome(some_string)\n    else: \n        return False\n\ndef fold_paper(width, height, folds):\n    width = float(width)\n    height = float(height)\n    if folds == 0: \n        return (width, height)\n    else:\n        if width >= height:        \n            return fold_paper(width/2, height, folds -1)  \n        else:\n            return fold_paper(width, height/2, folds - 1)\n\n# main function\ndef main_solution(lst, n, target):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    product = multiply_list(lst)\n    count = count_list(lst)\n    sum_of_list = sum_list(lst)\n    reversed_list = reverse(lst)\n    fib_n = fibonacci(n)\n    is_pal = is_palindrome(str(target))\n    folded_paper = fold_paper(10, 10, n)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\n        \"product\": product,\n        \"count\": count,\n        \"sum\": sum_of_list,\n        \"reversed_list\": reversed_list,\n        \"fibonacci\": fib_n,\n        \"is_palindrome\": is_pal,\n        \"folded_paper\": folded_paper\n    }", "input_generator": "import random\n\ndef input_generator():\n    lst_length = random.randint(1, 10)\n    lst = [random.randint(1, 10) for _ in range(lst_length)]\n    n = random.randint(0, 10)\n    target = random.choice([random.randint(1, 100), str(random.randint(1, 100))])\n    return {\n        \"lst\": lst,\n        \"n\": n,\n        \"target\": target\n    }", "io_pairs": [{"input": {"lst": [1], "n": 5, "target": 86}, "output": {"product": 1, "count": 1, "sum": 1, "reversed_list": [1], "fibonacci": 5, "is_palindrome": false, "folded_paper": [1.25, 2.5]}}, {"input": {"lst": [7], "n": 7, "target": 50}, "output": {"product": 7, "count": 1, "sum": 7, "reversed_list": [7], "fibonacci": 13, "is_palindrome": false, "folded_paper": [0.625, 1.25]}}, {"input": {"lst": [9], "n": 7, "target": "35"}, "output": {"product": 9, "count": 1, "sum": 9, "reversed_list": [9], "fibonacci": 13, "is_palindrome": false, "folded_paper": [0.625, 1.25]}}, {"input": {"lst": [8], "n": 5, "target": "58"}, "output": {"product": 8, "count": 1, "sum": 8, "reversed_list": [8], "fibonacci": 5, "is_palindrome": false, "folded_paper": [1.25, 2.5]}}, {"input": {"lst": [8], "n": 10, "target": "55"}, "output": {"product": 8, "count": 1, "sum": 8, "reversed_list": [8], "fibonacci": 55, "is_palindrome": true, "folded_paper": [0.3125, 0.3125]}}, {"input": {"lst": [9], "n": 10, "target": "68"}, "output": {"product": 9, "count": 1, "sum": 9, "reversed_list": [9], "fibonacci": 55, "is_palindrome": false, "folded_paper": [0.3125, 0.3125]}}, {"input": {"lst": [4], "n": 4, "target": "89"}, "output": {"product": 4, "count": 1, "sum": 4, "reversed_list": [4], "fibonacci": 3, "is_palindrome": false, "folded_paper": [2.5, 2.5]}}, {"input": {"lst": [7], "n": 2, "target": 66}, "output": {"product": 7, "count": 1, "sum": 7, "reversed_list": [7], "fibonacci": 1, "is_palindrome": true, "folded_paper": [5.0, 5.0]}}, {"input": {"lst": [1], "n": 7, "target": "81"}, "output": {"product": 1, "count": 1, "sum": 1, "reversed_list": [1], "fibonacci": 13, "is_palindrome": false, "folded_paper": [0.625, 1.25]}}, {"input": {"lst": [2], "n": 6, "target": "14"}, "output": {"product": 2, "count": 1, "sum": 2, "reversed_list": [2], "fibonacci": 8, "is_palindrome": false, "folded_paper": [1.25, 1.25]}}], "error_log": []}
{"context": "Given a simple pendulum with a specific initial angle and angular velocity, what is the frequency of the pendulum's oscillation? Consider the pendulum's motion without damping or external driving forces.\n\nThe input and output requirements are as follows:\n\nInput:\n  `alpha_initial` (float): The initial angle of the pendulum in degrees.\n  `d_alpha_initial` (float): The initial angular velocity of the pendulum in degrees per second.\n\nOutput:\n  `return` (dict): A dictionary containing the key \"frequency\" with the value being the frequency of the pendulum in Hz.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef simple_pendulum(alpha_initial, d_alpha_initial, store_period):\n    # define parameters\n    g = 9.8  # acceleration due to gravity in m/s/s \n    l = 10  # length of pendulum in meters \n    # describe time interval\n    t_i = 0.  # start time in seconds\n    t_f = 20.  # end time in seconds\n    N = 10**4  # number of sub intervals \n    t = np.linspace(t_i, t_f, N)  # time range\n    dt = (t_f - t_i) / N  # small change in t for solving eqs\n    # set up lists to store values as equations are propagated through time\n    alpha = [0] * N  # angle of pendulum in radians\n    d_alpha = [0] * N  # small change of alpha w/ respect to time\n    d_d_alpha = [0] * N  # small change of d_alpha w/ respect to time\n    T = []  # stores times when pendulum crosses alpha=0 to calculate period\n    # set initial value\n    alpha[0] = np.deg2rad(alpha_initial)  # rad\n    d_alpha[0] = np.deg2rad(d_alpha_initial)  # rad/s \n    # solve equations\n    for i in range(1, N):  # starts at 1 bc initial values (idx 0) are determined\n        d_d_alpha[i] = (-1) * (g / l) * np.sin(alpha[i-1])  # undamped, undriven pendulum\n        d_alpha[i] = d_alpha[i-1] + d_d_alpha[i] * dt\n        alpha[i] = alpha[i-1] + d_alpha[i] * dt\n        if alpha[i] > np.pi:  # constrains motion to within +/- 180 deg\n            alpha[i] -= 2 * np.pi\n        elif alpha[i] < -np.pi:\n            alpha[i] += 2 * np.pi\n        if alpha[i] <= 0 and alpha[i-1] >= 0:  # checks to see when pendulum passes through alpha = 0 from one direction\n            T.append(t[i])\n    frequency = 1 / (T[1] - T[0])  # the period is the time between the values stored in the T list\n    if store_period:\n        return frequency\n    return None\n\n# main function\ndef main_solution(alpha_initial, d_alpha_initial):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # convert JSON serializable inputs to original input variables if necessary\n    alpha_initial = float(alpha_initial)\n    d_alpha_initial = float(d_alpha_initial)\n    \n    # call the simple_pendulum function\n    frequency = simple_pendulum(alpha_initial, d_alpha_initial, store_period=True)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"frequency\": frequency}", "input_generator": "import random\n\ndef input_generator():\n    alpha_initial = random.uniform(-90, 90)\n    d_alpha_initial = random.uniform(-10, 10)\n    return {\n        \"alpha_initial\": alpha_initial,\n        \"d_alpha_initial\": d_alpha_initial\n    }", "io_pairs": [{"input": {"alpha_initial": -42.55408875588073, "d_alpha_initial": -2.614980769830451}, "output": {"frequency": 0.15209917858229388}}, {"input": {"alpha_initial": 87.53126647195876, "d_alpha_initial": -6.162126826495308}, "output": {"frequency": 0.13461227786752827}}, {"input": {"alpha_initial": 8.957812732792007, "d_alpha_initial": -4.699589285028704}, "output": {"frequency": 0.15721698113207547}}, {"input": {"alpha_initial": 42.28489563710599, "d_alpha_initial": -5.553350401440655}, "output": {"frequency": 0.15209917858229388}}, {"input": {"alpha_initial": 68.72800102464836, "d_alpha_initial": 9.127814995325672}, "output": {"frequency": 0.14312911537360434}}, {"input": {"alpha_initial": -14.012559655233332, "d_alpha_initial": 6.936099220027991}, "output": {"frequency": 0.15682245922208282}}, {"input": {"alpha_initial": -18.262561312154276, "d_alpha_initial": 8.005328664222656}, "output": {"frequency": 0.15633208255159475}}, {"input": {"alpha_initial": -74.1265441151985, "d_alpha_initial": -6.485734376315664}, "output": {"frequency": 0.14098984771573606}}, {"input": {"alpha_initial": 59.641858636414554, "d_alpha_initial": -2.5858376541893584}, "output": {"frequency": 0.14687132784958873}}, {"input": {"alpha_initial": -13.883669902373512, "d_alpha_initial": -3.9080786390144473}, "output": {"frequency": 0.1569209039548023}}], "error_log": []}
{"context": "Given a plaintext message and an encryption key, what are the encrypted and decrypted versions of the message using the multiplicative cipher?\n\nThe input and output requirements are as follows:\n\nInput:\n  `plaintext` (str): The plaintext message to be encrypted. It should be a string of words separated by spaces.\n  `key` (int): The encryption key used for the multiplicative cipher. It should be an integer between 1 and 25.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `encrypted_text` (str): The encrypted message obtained using the multiplicative cipher.\n    - `decrypted_text` (str): The decrypted message obtained using the multiplicative cipher.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Multicipher():\n    def __init__(self):\n        self.plaintext = \"\"\n        self.ciphertext = \"\"\n        self.key = 0\n        self.name = \"Multiplicative\"\n    \n    def encrypt(self, plain, key):\n        self.key = key\n        self.ciphertext = \"\"\n        self.plaintext = plain\n        self.plaintext = self.plaintext.split()\n        self.temp = \"\"\n        for i in self.plaintext:\n            self.temp = self.temp + i.upper()\n        self.plaintext = self.temp\n        for i in self.plaintext:\n            self.chara = chr((((ord(i) - 65) * self.key) % 26) + 65)\n            self.ciphertext = self.ciphertext + self.chara\n        return self.ciphertext\n    \n    def decrypt(self, cipher, key):\n        self.key = key\n        self.plaintext = \"\"\n        self.ciphertext = cipher.upper()\n        for i in self.ciphertext:\n            self.chara = chr((((ord(i) - 65) * self.modInverse(self.key, 26)) % 26) + 65)\n            self.plaintext = self.plaintext + self.chara\n        return self.plaintext\n    \n    def modInverse(self, num, mod): \n        num = num % mod\n        for i in range(1, mod): \n            if ((num * i) % mod == 1): \n                return i\n        return 1\n\n# main function\ndef main_solution(plaintext, key):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    cipher = Multicipher()\n    encrypted_text = cipher.encrypt(plaintext, key)\n    decrypted_text = cipher.decrypt(encrypted_text, key)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"encrypted_text\": encrypted_text, \"decrypted_text\": decrypted_text}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random plaintext: a combination of letters and spaces\n    plaintext_length = random.randint(5, 20)\n    plaintext = ''.join(random.choices(string.ascii_letters + ' ', k=plaintext_length))\n    \n    # Generate a valid key (must be coprime with 26)\n    valid_keys = [1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25]\n    key = random.choice(valid_keys)\n    \n    return {\"plaintext\": plaintext, \"key\": key}", "io_pairs": [{"input": {"plaintext": "YEWpuSRBOrsrncVzHvfH", "key": 1}, "output": {"encrypted_text": "YEWPUSRBORSRNCVZHVFH", "decrypted_text": "YEWPUSRBORSRNCVZHVFH"}}, {"input": {"plaintext": "evTLWjMCXzgbLisyI", "key": 23}, "output": {"encrypted_text": "OPVTMZQUJDIXTCYGC", "decrypted_text": "EVTLWJMCXZGBLISYI"}}, {"input": {"plaintext": "cMQQH", "key": 7}, "output": {"encrypted_text": "OGIIX", "decrypted_text": "CMQQH"}}, {"input": {"plaintext": "lCjPKOVHq", "key": 17}, "output": {"encrypted_text": "FIXVOETPM", "decrypted_text": "LCJPKOVHQ"}}, {"input": {"plaintext": "hwalwpVQylBYdqMLYxi", "key": 5}, "output": {"encrypted_text": "JGADGXBCQDFQPCIDQLO", "decrypted_text": "HWALWPVQYLBYDQMLYXI"}}, {"input": {"plaintext": "WEyrG", "key": 1}, "output": {"encrypted_text": "WEYRG", "decrypted_text": "WEYRG"}}, {"input": {"plaintext": "JwBRnXgrSYIyuEvU", "key": 1}, "output": {"encrypted_text": "JWBRNXGRSYIYUEVU", "decrypted_text": "JWBRNXGRSYIYUEVU"}}, {"input": {"plaintext": "dmHKsacW", "key": 15}, "output": {"encrypted_text": "TYBUKAES", "decrypted_text": "DMHKSACW"}}, {"input": {"plaintext": "KMCJI", "key": 21}, "output": {"encrypted_text": "CSQHM", "decrypted_text": "KMCJI"}}, {"input": {"plaintext": "WZgVOKgCrLWNS", "key": 21}, "output": {"encrypted_text": "UFWZICWQTXUNO", "decrypted_text": "WZGVOKGCRLWNS"}}], "error_log": []}
{"context": "Given a list of integers, how can we filter out numbers that do not have exactly a specified number of proper divisors, and identify which numbers in the list are prime? Specifically, what are the prime numbers in the list, and what is the list after removing numbers that do not meet the divisor count requirement?\n\nThe input and output requirements are as follows:\n\nInput:\n  `ls` (list of integers): A list of integers for which we need to filter out numbers based on their proper divisors.\n  `k` (integer): An integer representing the exact number of proper divisors a number in `ls` should have to remain in the list.\n\nOutput:\n  `return` (dictionary): A dictionary containing two keys:\n    - `primes` (list of integers): A list of prime numbers from the original list `ls`.\n    - `filtered_list` (list of integers): The list `ls` after removing numbers that do not have exactly `k` proper divisors.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef nprimo(n): # test di primalit\u00e0\n    for i in range(2, int(math.sqrt(n))+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef r1(ls, k):\n    for i in range(len(ls) - 1, -1, -1): # indici inversi [6, 5, 4...]\n        n = 2\n        op = int(math.sqrt(ls[i]))\n        numero = ls[i]\n        a = []\n        b = 1\n        conta = 0\n        if nprimo(ls[i]) != True:\n            while n < op:\n                r = numero % n\n                if r == 0:\n                    numero = numero // n\n                    conta += 1\n                else:\n                    n += 1\n                    if conta != 0:\n                        a = a + [conta + 1]\n                        conta = 0\n            for e in a:\n                b *= e\n            if b - 2 != k:\n                del ls[i]\n        else:\n            if k != 0:\n                del ls[i]\n\ndef r2(ls):\n    ls2 = [] # nuova lista per l'output (2)\n    for n in ls:\n        if nprimo(n):\n            ls2 = ls2 + [n] # aggiunta degli elementi con \"k\" divisori propri alla nuova lista\n    return ls2\n\n# main function\ndef main_solution(ls, k):\n    # Convert input to appropriate types if necessary\n    ls = list(ls)\n    k = int(k)\n    \n    # Call the original functions\n    ls2 = r2(ls)\n    r1(ls, k)\n    \n    # Convert output to JSON serializable format\n    return {\"primes\": ls2, \"filtered_list\": ls}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random list length between 5 and 20\n    list_length = random.randint(5, 20)\n    \n    # Generate a list of random integers between 2 and 100\n    ls = [random.randint(2, 100) for _ in range(list_length)]\n    \n    # Generate a random k between 0 and 5\n    k = random.randint(0, 5)\n    \n    return {\"ls\": ls, \"k\": k}", "io_pairs": [{"input": {"ls": [27, 20, 60, 22, 79, 23, 52, 45, 16, 48], "k": 2}, "output": {"primes": [79, 23], "filtered_list": [27]}}, {"input": {"ls": [73, 74, 62, 61, 97, 65, 23, 55, 93], "k": 4}, "output": {"primes": [73, 61, 97, 23], "filtered_list": []}}, {"input": {"ls": [92, 52, 13, 31, 55, 8, 33, 78, 7, 46, 91, 85, 37, 74], "k": 5}, "output": {"primes": [13, 31, 7, 37], "filtered_list": []}}, {"input": {"ls": [60, 34, 53, 49, 49, 64, 93, 22], "k": 0}, "output": {"primes": [53], "filtered_list": [34, 53, 93, 22]}}, {"input": {"ls": [11, 7, 31, 50, 82, 95, 16, 29], "k": 1}, "output": {"primes": [11, 7, 31, 29], "filtered_list": []}}, {"input": {"ls": [93, 61, 92, 47, 91, 33, 79, 65, 30], "k": 1}, "output": {"primes": [61, 47, 79], "filtered_list": [92]}}, {"input": {"ls": [4, 87, 38, 18, 2], "k": 0}, "output": {"primes": [2], "filtered_list": [87, 38, 2]}}, {"input": {"ls": [98, 45, 39, 85, 22, 46, 56, 50, 40, 90, 47, 39, 95], "k": 2}, "output": {"primes": [47], "filtered_list": [56]}}, {"input": {"ls": [5, 72, 59, 23, 79, 12, 76, 98], "k": 0}, "output": {"primes": [5, 59, 23, 79], "filtered_list": [5, 59, 23, 79]}}, {"input": {"ls": [36, 89, 75, 65, 83, 3, 22, 88, 88, 89], "k": 2}, "output": {"primes": [89, 83, 3, 89], "filtered_list": [88, 88]}}], "error_log": []}
{"context": "Imagine you have a large number of buckets, one of which contains a deadly poison. You have a limited number of pigs and a limited amount of time to determine which bucket is poisonous. Each pig can drink from multiple buckets simultaneously, but after drinking, it must wait a certain amount of time to see if it dies. Given the total number of buckets, the time it takes for a pig to die after drinking from the poisonous bucket, and the total time available for testing, how many pigs do you need to identify the poisonous bucket?\n\nThe input and output requirements are as follows:\n\nInput:\n  `buckets` (int): The total number of buckets, ranging from 1 to 1000.\n  `minutesToDie` (int): The time it takes for a pig to die after drinking from a poisonous bucket, ranging from 1 to 60.\n  `minutesToTest` (int): The total time available to test the buckets, ranging from 1 to 100.\n\nOutput:\n  `return` (int): The minimum number of pigs required to determine the poisonous bucket within the given time constraints.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(buckets, minutesToDie, minutesToTest):\n    \"\"\"\n    Calculate the minimum number of pigs required to determine which bucket out of 'buckets' is poisonous within the given time constraints.\n\n    Parameters:\n    buckets (int): The total number of buckets.\n    minutesToDie (int): The time it takes for a pig to die after drinking from a poisonous bucket.\n    minutesToTest (int): The total time available to test the buckets.\n\n    Returns:\n    int: The minimum number of pigs required.\n    \"\"\"\n    # Calculate the number of tests that can be performed\n    tests = minutesToTest // minutesToDie\n    \n    # Calculate the minimum number of pigs required\n    pigs = 0\n    while (tests + 1) ** pigs < buckets:\n        pigs += 1\n    \n    return pigs", "input_generator": "import random\n\ndef input_generator():\n    buckets = random.randint(1, 1000)\n    minutesToDie = random.randint(1, 60)\n    minutesToTest = random.randint(minutesToDie, minutesToDie * 10)\n    return {\n        'buckets': buckets,\n        'minutesToDie': minutesToDie,\n        'minutesToTest': minutesToTest\n    }", "io_pairs": [{"input": {"buckets": 10, "minutesToDie": 37, "minutesToTest": 215}, "output": 2}, {"input": {"buckets": 945, "minutesToDie": 7, "minutesToTest": 43}, "output": 4}, {"input": {"buckets": 997, "minutesToDie": 25, "minutesToTest": 31}, "output": 10}, {"input": {"buckets": 524, "minutesToDie": 56, "minutesToTest": 92}, "output": 10}, {"input": {"buckets": 274, "minutesToDie": 33, "minutesToTest": 196}, "output": 4}, {"input": {"buckets": 428, "minutesToDie": 26, "minutesToTest": 214}, "output": 3}, {"input": {"buckets": 838, "minutesToDie": 47, "minutesToTest": 207}, "output": 5}, {"input": {"buckets": 617, "minutesToDie": 51, "minutesToTest": 152}, "output": 6}, {"input": {"buckets": 139, "minutesToDie": 56, "minutesToTest": 107}, "output": 8}, {"input": {"buckets": 235, "minutesToDie": 4, "minutesToTest": 35}, "output": 3}], "error_log": []}
{"context": "A frog wants to cross a river with `n` stones in it. Each stone has a number written on it, representing the number of stones the frog can jump forward or backward from that stone. The frog can start from the near bank and jump to the first stone, and from the last stone (or any other stone if possible) to the far bank. What is the minimum number of jumps the frog needs to cross the river, or is it impossible for the frog to cross the river?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of stones in the river.\n  `stones` (list of int): A list where each element represents the number of stones the frog can jump from that stone.\n\nOutput:\n  `return` (str or int): The minimum number of jumps to cross the river or \"no chance :-(\" if it's not possible.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(n, stones):\n    \"\"\"\n    This function calculates the minimum number of jumps a frog needs to cross a river using given stones.\n    If it's not possible to cross the river, it returns \"no chance :-(\".\n    \n    Parameters:\n    n (int): The number of stones in the river.\n    stones (list of int): A list where each element represents the number of stones the frog can jump from that stone.\n    \n    Returns:\n    str or int: The minimum number of jumps to cross the river or \"no chance :-(\" if it's not possible.\n    \"\"\"\n    current = 0\n    steps = 1\n    while current + stones[current] < n:\n        left = current - stones[current]\n        right = current + stones[current]\n        if left >= 0 and stones[left] + left >= n:\n            return steps + 2\n        if right < n and stones[right] == 0:\n            return \"no chance :-(\"\n        current += stones[current]\n        steps += 1\n    return steps + 1", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(5, 20)\n    stones = []\n    for _ in range(n):\n        stones.append(random.randint(0, 3))\n    \n    # Ensure at least one possible path\n    if random.random() < 0.8:  # 80% chance to have a valid path\n        current = 0\n        while current < n:\n            jump = random.randint(1, min(3, n - current - 1)) if current < n - 1 else 0\n            stones[current] = jump\n            current += jump\n    \n    return {'n': n, 'stones': stones}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a partially filled 9x9 Sudoku board, determine if the current configuration is valid. A valid Sudoku board must satisfy the following conditions:\n1. Each row must contain the digits 1-9 without repetition.\n2. Each column must contain the digits 1-9 without repetition.\n3. Each of the nine 3x3 sub-grids must contain the digits 1-9 without repetition.\n\nIs the provided Sudoku board configuration valid?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists of strings): A 9x9 Sudoku board represented as a list of lists of strings. Each element in the board can be either a digit ('1'-'9') or a period ('.'), where a period represents an empty cell.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the Sudoku board is valid. Returns `True` if the board is valid, and `False` otherwise.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        n = len(board)\n        m = len(board[0])\n\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != '.':\n                    k = board[i][j]\n\n                    valid = True\n                    # check in col\n                    for t in range(n):\n                        if t != i:\n                            if board[t][j] == k:\n                                valid = False\n                    if not valid:\n                        return False\n                    # check in row\n                    for t in range(m):\n                        if t != j:\n                            if board[i][t] == k:\n                                valid = False\n                    if not valid:\n                        return False\n                    # check in small square\n                    start_i = i // 3\n                    start_j = j // 3\n                    for q in range(start_i * 3, start_i * 3 + 3):\n                        for w in range(start_j * 3, start_j * 3 + 3):\n                            if q != i and w != j:\n                                if board[q][w] == k:\n                                    valid = False\n                    if not valid:\n                        return False\n\n        return True\n\n# main function\ndef main_solution(board):\n    # Convert the input board to a list of lists of strings\n    board = [list(row) for row in board]\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the isValidSudoku method\n    result = solution.isValidSudoku(board)\n    \n    # Return the result\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a 9x9 Sudoku board with some random numbers and dots\n    board = [['.' for _ in range(9)] for _ in range(9)]\n    \n    # Fill some cells with valid numbers\n    for _ in range(random.randint(10, 30)):  # Fill between 10 to 30 cells\n        i = random.randint(0, 8)\n        j = random.randint(0, 8)\n        num = str(random.randint(1, 9))\n        \n        # Check if the number can be placed without violating Sudoku rules\n        valid = True\n        # Check row\n        for k in range(9):\n            if board[i][k] == num:\n                valid = False\n                break\n        if not valid:\n            continue\n        # Check column\n        for k in range(9):\n            if board[k][j] == num:\n                valid = False\n                break\n        if not valid:\n            continue\n        # Check 3x3 sub-box\n        start_i = (i // 3) * 3\n        start_j = (j // 3) * 3\n        for x in range(start_i, start_i + 3):\n            for y in range(start_j, start_j + 3):\n                if board[x][y] == num:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            board[i][j] = num\n    \n    # Convert each row to a string\n    board = [''.join(row) for row in board]\n    \n    return {'board': board}", "io_pairs": [{"input": {"board": ["....5..9.", ".7.......", "..2......", "4........", "....1....", ".....9...", "9..12.8..", "..5......", "........9"]}, "output": true}, {"input": {"board": ["..4...2..", ".8.......", ".........", "..26...9.", "......7..", "....78...", ".....5...", ".6.......", ".51...8.."]}, "output": true}, {"input": {"board": ["...5.....", "......6..", ".........", ".........", ".....7.2.", "..8..4..6", "1.6......", "...6.....", "........7"]}, "output": true}, {"input": {"board": [".26....1.", "..43.5..6", ".7...4...", "..86.3...", "...9...5.", ".........", ".........", "..2.97...", "....1...5"]}, "output": true}, {"input": {"board": ["...687...", ".........", ".....5...", "..75.....", "..1.3..28", ".........", "3...1....", "41.....6.", "........."]}, "output": true}, {"input": {"board": ["......6..", ".........", ".....4...", "1.6.7....", ".........", ".47...3..", "....2..4.", "8........", "........."]}, "output": true}, {"input": {"board": ["...1.3...", "...29....", ".......1.", ".....29..", "..8......", ".2.8.....", "2156....8", "..9.8....", "..751.34."]}, "output": true}, {"input": {"board": ["1...5....", ".8....52.", "...3.9...", "....9....", "......3..", "9..1.....", "24.7.3...", ".........", "8.......3"]}, "output": true}, {"input": {"board": [".........", ".......7.", "......3..", "..4......", "..2......", ".....5.3.", ".....6...", "...2.4...", ".2......."]}, "output": true}, {"input": {"board": [".6.....8.", ".........", "2....5...", "........5", ".......2.", ".....3...", ".........", ".3....4..", "...5....."]}, "output": true}], "error_log": []}
{"context": "Given a number of pairs of parentheses, what are all the valid combinations of these parentheses that can be formed?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of pairs of parentheses to generate valid combinations for.\n\nOutput:\n  `return` (str): A JSON serialized string containing a list of valid combinations of n-pairs of parentheses.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef generate_parentheses(p, i, n, result):\n    if i < n:\n        generate_parentheses(p+'()', i+1, n, result)\n        generate_parentheses('('+p+')', i+1, n, result)\n    else:\n        result.append(p)\n\n# main function\ndef main_solution(n):\n    # Convert input to integer\n    n = int(n)\n    \n    # Initialize result list\n    result = []\n    \n    # Generate parentheses combinations\n    generate_parentheses('()', 1, n, result)\n    \n    # Convert result list to JSON serializable format\n    result_json = json.dumps(result)\n    \n    # Return the JSON serialized result\n    return result_json", "input_generator": "import random\n\ndef input_generator():\n    return {'n': random.randint(1, 5)}", "io_pairs": [{"input": {"n": 1}, "output": "[\"()\"]"}, {"input": {"n": 2}, "output": "[\"()()\", \"(())\"]"}, {"input": {"n": 3}, "output": "[\"()()()\", \"(()())\", \"(())()\", \"((()))\"]"}, {"input": {"n": 4}, "output": "[\"()()()()\", \"(()()())\", \"(()())()\", \"((()()))\", \"(())()()\", \"((())())\", \"((()))()\", \"(((())))\"]"}], "error_log": []}
{"context": "Given a modified version of the Hanoi Tower problem where a layer cannot be moved directly from the leftmost tower to the rightmost tower or vice versa without passing through the middle tower, how many steps are required to move `num` layers from the left tower to the right tower?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num` (int): The number of layers in the Hanoi Tower.\n\nOutput:\n  `return` (int): The total number of steps required to move all layers from the left to the right tower.", "reference_code": "# import necessary packages\nimport sys\nfrom enum import Enum, unique\n\n# all class and function definitions in the code file, if any\nclass Stack(object):\n    def __init__(self):\n        self._stack = []\n\n    def push(self, data):\n        self._stack.append(data)\n\n    def pop(self):\n        if self.is_empty():\n            raise ValueError('stack \u4e3a\u7a7a')\n        else:\n            data = self._stack[-1]\n            self._stack.pop()\n        return data\n\n    def is_empty(self):\n        return self.size() == 0\n\n    def size(self):\n        return len(self._stack)\n\n    def top(self):\n        return self._stack[-1]\n\n@unique\nclass Action(Enum):\n    No = 0\n    LToM = 1\n    MToL = 2\n    MToR = 3\n    RToM = 4\n\nclass Solution:\n    record = Action.No\n\n    def hanoi(self, num):\n        step = 0\n        left = Stack()\n        middle = Stack()\n        right = Stack()\n\n        left.push(sys.maxsize)\n        middle.push(sys.maxsize)\n        right.push(sys.maxsize)\n\n        for i in range(num, 0, -1):\n            left.push(i)\n\n        while right.size() < num+1:\n            step += self.move(Action.MToL, Action.LToM, left, middle, 'left', 'middle')\n            step += self.move(Action.LToM, Action.MToL, middle, left, 'middle', 'left')\n            step += self.move(Action.MToR, Action.RToM, right, middle, 'right', 'middle')\n            step += self.move(Action.RToM, Action.MToR, middle, right, 'middle', 'right')\n        return step\n\n    def move(self, action_pre, action_now, from_stack, to_stack, from_str, to_str):\n        if self.record != action_pre and from_stack.top() < to_stack.top():\n            to_stack.push(from_stack.pop())\n            self.record = action_now\n            return 1\n        return 0\n\n# main function\ndef main_solution(num):\n    \"\"\"\n    :param num: int, the number of layers in the Hanoi Tower.\n    :return: int, the total number of steps required to move all layers from the left to the right tower.\n    \"\"\"\n    solution = Solution()\n    steps = solution.hanoi(num)\n    return steps", "input_generator": "import random\n\ndef input_generator():\n    return {'num': random.randint(1, 10)}", "io_pairs": [{"input": {"num": 4}, "output": 80}, {"input": {"num": 7}, "output": 2186}, {"input": {"num": 3}, "output": 26}, {"input": {"num": 2}, "output": 8}, {"input": {"num": 5}, "output": 242}, {"input": {"num": 10}, "output": 59048}, {"input": {"num": 9}, "output": 19682}, {"input": {"num": 6}, "output": 728}, {"input": {"num": 8}, "output": 6560}, {"input": {"num": 1}, "output": 2}], "error_log": []}
{"context": "Given the length of a string and a list of triplets that maintain the relative order of the characters in the string, what is the original string that can be reconstructed from these triplets?\n\nThe input and output requirements are as follows:\n\nInput:\n  `length` (int): The length of the original string that needs to be guessed.\n  `triplets` (list of strings): A list of triplets that maintain the relative order of the original string. Each triplet is a string of length 3.\n\nOutput:\n  `return` (string): The original string that was guessed based on the given length and triplets.", "reference_code": "# import necessary packages\nimport random\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\ndef getRandomTriplet(s):\n    # Generate a random triplet from the string s\n    n = len(s)\n    if n < 3:\n        return s\n    start = random.randint(0, n - 3)\n    return s[start:start + 3]\n\ndef generate_string(length, triplets):\n    # Generate the original string from the given length and triplets\n    possible_chars = defaultdict(set)\n    for triplet in triplets:\n        for i in range(3):\n            possible_chars[i].add(triplet[i])\n    \n    # Start with the first character and build the string\n    result = []\n    for i in range(length):\n        if i in possible_chars:\n            result.append(random.choice(list(possible_chars[i])))\n        else:\n            result.append('')\n    \n    return ''.join(result)\n\n# main function\ndef main_solution(length, triplets):\n    # length (int): The length of the original string.\n    # triplets (list of strings): A list of triplets that maintain the relative order of the original string.\n    \n    # Generate the original string from the given length and triplets\n    original_string = generate_string(length, triplets)\n    \n    # Return the original string\n    return original_string", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Randomly decide the length of the original string (between 5 and 20)\n    length = random.randint(5, 20)\n    \n    # Generate a random original string of the given length\n    original_string = ''.join(random.choices(string.ascii_lowercase, k=length))\n    \n    # Generate a list of triplets from the original string\n    num_triplets = random.randint(3, 10)\n    triplets = []\n    for _ in range(num_triplets):\n        if length >= 3:\n            start = random.randint(0, length - 3)\n            triplet = original_string[start:start+3]\n            triplets.append(triplet)\n        else:\n            triplet = original_string\n            triplets.append(triplet)\n    \n    # Ensure triplets are unique\n    triplets = list(set(triplets))\n    \n    return {'length': length, 'triplets': triplets}", "io_pairs": [{"input": {"length": 18, "triplets": ["tyh", "fjy", "hpq", "yhp", "zjx", "eiz", "mse", "xfj"]}, "output": "ypj"}, {"input": {"length": 6, "triplets": ["mta", "tap", "nmt", "ape"]}, "output": "tta"}, {"input": {"length": 16, "triplets": ["kzm", "cie", "hkz", "dbh"]}, "output": "dih"}, {"input": {"length": 15, "triplets": ["byb", "tos", "kkj", "jto", "mgw", "kjt"]}, "output": "bgo"}, {"input": {"length": 20, "triplets": ["upl", "zll", "ycv", "cvu", "lfa", "vuh", "lup"]}, "output": "vlp"}, {"input": {"length": 19, "triplets": ["doo", "zlm", "oet", "etj", "izb"]}, "output": "oot"}, {"input": {"length": 9, "triplets": ["sgc", "gcr", "xbk", "rfg"]}, "output": "rcc"}, {"input": {"length": 9, "triplets": ["gbz", "bzj", "zjh", "ygb"]}, "output": "zbh"}, {"input": {"length": 5, "triplets": ["vxn", "ekv", "kvx"]}, "output": "ekx"}, {"input": {"length": 10, "triplets": ["utl", "tln", "xut", "feb", "eby", "byg"]}, "output": "eey"}], "error_log": []}
{"context": "Given the coordinates of two points on the Earth's surface, what is the distance between these two points in meters? The coordinates are provided in degrees for latitude and longitude.\n\nThe input and output requirements are as follows:\n\nInput:\n  `lat1` (float): Latitude of the first point in degrees.\n  `lon1` (float): Longitude of the first point in degrees.\n  `lat2` (float): Latitude of the second point in degrees.\n  `lon2` (float): Longitude of the second point in degrees.\n\nOutput:\n  `return` (int): The distance between the two points in meters.", "reference_code": "# import necessary packages\nfrom math import radians, cos, sin, asin, sqrt\n\n# main function\ndef main_solution(lat1, lon1, lat2, lon2):\n    # Convert degrees to radians\n    lon1 = radians(lon1)\n    lon2 = radians(lon2)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n    \n    # Haversine formula\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2\n    c = 2 * asin(sqrt(a))\n    \n    # Radius of earth in kilometers. Use 3956 for miles\n    r = 6371\n    \n    # Calculate the result in meters\n    distance_in_meters = int(c * r * 1000)\n    \n    # Return the distance in meters\n    return distance_in_meters", "input_generator": "import random\n\ndef input_generator():\n    # Generate random latitudes between -90 and 90\n    lat1 = random.uniform(-90, 90)\n    lat2 = random.uniform(-90, 90)\n    \n    # Generate random longitudes between -180 and 180\n    lon1 = random.uniform(-180, 180)\n    lon2 = random.uniform(-180, 180)\n    \n    return {\n        'lat1': lat1,\n        'lon1': lon1,\n        'lat2': lat2,\n        'lon2': lon2\n    }", "io_pairs": [{"input": {"lat1": -6.674067257943392, "lon1": 68.81620198138717, "lat2": 53.68905306855339, "lon2": -140.91902498002872}, "output": 14142105}, {"input": {"lat1": -68.48502994083643, "lon1": -145.90346300183904, "lat2": 40.79383357322675, "lon2": 94.10017232806808}, "output": 15378132}, {"input": {"lat1": -44.718708896673036, "lon1": 131.41097374540442, "lat2": 29.659620219567856, "lon2": -22.045724053776468}, "output": 17150010}, {"input": {"lat1": -80.86411719504395, "lon1": -22.19219613140413, "lat2": 77.53632091234678, "lon2": 133.7757358735833}, "output": 19400015}, {"input": {"lat1": -45.51409045595184, "lon1": -27.11356907916067, "lat2": -48.98986724391476, "lon2": -127.6420741605848}, "output": 7002892}, {"input": {"lat1": -40.40427068239361, "lon1": -55.53494948490989, "lat2": 33.47270125704617, "lon2": 171.3182496136061}, "output": 15829949}, {"input": {"lat1": 17.79294830384518, "lon1": -36.85856638332359, "lat2": -34.451333538654275, "lon2": 144.36863286309017}, "output": 18158760}, {"input": {"lat1": -75.91420222795544, "lon1": -12.228644895244287, "lat2": 61.44592839497392, "lon2": 124.8998374410383}, "output": 17745434}, {"input": {"lat1": 7.204705377224585, "lon1": -104.91304220494851, "lat2": -61.81957458349781, "lon2": -136.80062131350033}, "output": 8151216}, {"input": {"lat1": 32.44233635079624, "lon1": -129.3716760516532, "lat2": 63.70750567518445, "lon2": 136.22169087441802}, "output": 7017867}], "error_log": []}
{"context": "In a game board of size `n x n`, there are variables represented as squares. Each variable can be assigned a color from a set of predefined colors. The board has a source variable and a target variable, each with specific positions. The source variable needs to be connected to the target variable through a path. Given the board size, the positions of the source and target variables, and the list of possible colors, what are the positions of the next variable for the source and the previous variable for the target in the path?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_size` (int): The size of the board (n x n).\n  `source_position` (tuple): The position of the source variable in the board (row, col).\n  `target_position` (tuple): The position of the target variable in the board (row, col).\n  `all_colors` (list of str): A list of all possible colors that can be assigned to variables.\n\nOutput:\n  `return` (dict): A dictionary containing the positions of the next variable for the source and the previous variable for the target.\n    - `source_next` (tuple): The position of the next variable for the source (row, col).\n    - `target_previous` (tuple): The position of the previous variable for the target (row, col).", "reference_code": "# import necessary packages\nimport math\nimport itertools\n\n# class for a variable, the variable is a square in the game board\n# it will contain the variable legal values\nclass Variable:\n    \n    def __init__(self, position, color):\n        self.position = position # a tuple (row, col)\n        self.color = color # '0' if no assignment yet\n        self.domain = None\n        self.legalValues = []\n        self.isSource = False # current legal values for this variable, initialized as the domain\n        self.isTarget = False\n        self.neighbors = [] # neighbors of this variable\n        self.next = None #  the next var in the path.\n        self.previous = None # the previous variable in the path.\n        \n    '''\n    reset the variable's domain.\n    '''\n    def resetVariable(self):\n        self.legalValues = self.domain.copy()\n        if not(self.isTarget or self.isSource):\n            self.color = '0'\n        self.next = None\n        self.previous = None\n       \n\n    def setVariable(self, value):\n        if self.isSource:\n            self.next = value\n        elif self.isTarget:\n            self.previous = value\n        else :\n            self.previous = value[0]\n            self.color = value[1]\n            self.next = value[2]\n    ''' gets the variable by its original position  in board\n        static method\n    '''\n    def getVarByPos( position, variables):\n        for var in variables:\n            if var.position == position:\n                return var\n            \n    def setNeighbors(self, variables, length):\n        if self.position[1]+1 < length:\n            self.neighbors.append(Variable.getVarByPos((self.position[0],self.position[1] + 1),variables))\n            \n        if self.position[0]+1 < length:\n            self.neighbors.append(Variable.getVarByPos((self.position[0]+1,self.position[1]),variables))\n            \n        if self.position[1]-1>= 0:\n            self.neighbors.append(Variable.getVarByPos((self.position[0],self.position[1] - 1),variables))\n        \n        if self.position[0]-1 >= 0:\n            self.neighbors.append(Variable.getVarByPos((self.position[0]-1,self.position[1]),variables))\n    \n    def getNeighbors(self):\n        return self.neighbors\n    \n    def isAssigned(self):\n        if self.isTarget:\n            return self.previous != None\n        if self.isSource:\n            return self.next !=None\n        return self.color != '0'\n        \n    def NumUnassignedNeighbors(self):\n        count=0\n        for neighbor in self.getNeighbors():\n            if neighbor.isSource and neighbor.next == None:\n                count += 1\n            elif neighbor.isTarget and neighbor.previous == None:\n                count += 1\n            elif neighbor.color == '0':\n                count +=1\n        return count\n            \n    # for a regular variable , its domain is a vector , (previos, color , next)\n    #for a source we only assign what is its next variable, so its domain is the neighbors of the variable\n    # for a Target we only assign what is its previous variable, so its domain is the neighbors of the variable\n    # gets all colors\n    def setVarDomain(self, allcolors):\n        neighbors = self.getNeighbors()\n        if(self.isSource):\n            domain = neighbors # the possiblitites is only on the next neighbor to go to not the color.\n                               # the assignment is only on what is the next variable , color is already assigned, and no previous for this variable\n        elif(self.isTarget):\n            domain = neighbors # possibilities is only on the previous neighbor not color\n        else:\n            domain = list(itertools.product(neighbors, allcolors, neighbors))# cartesian product of neighborsXallcolorsXneighbors\n            domain =  [d for d in domain if d[0] != d[2]] # removing a value the has previous == next because it is meaningless\n        self.domain = domain\n    ##  get the domain of the variable.    \n    def getVarDomain(self):\n        return self.domain\n    \n    #print the domain of the variable used for debugging\n    def printDomain(self):\n        if self.isSource:\n            for val in self.legalValues:\n                print(val.position)\n            \n        elif self.isTarget:\n            for val in self.legalValues:\n                print(val.position )\n        else:\n            for val in self.legalValues:\n                print((val[0].position,val[1],val[2].position))\n                \n    # print the variable   \n    def printVar(self):\n        print(self.position)\n        if self.isSource:\n            print(self.next.position)\n        if self.isTarget:\n            print(self.previous.position)\n        else:\n            print(self.previous.position,self.color,self.next.position)\n    def getIndex(self):\n        return self.position[0]*numberOfvariables + self.position[1]\n    \n    def LegalValuesOfNeighbors(self):\n        count = 0 \n        for neighbor in self.getNeighbors():\n            count += len(neighbor.legalValues)\n        return count\n\n# main function\ndef main_solution(board_size, source_position, target_position, all_colors):\n    # Convert JSON serializable inputs to original input variables\n    variables = []\n    for i in range(board_size):\n        for j in range(board_size):\n            variables.append(Variable((i, j), '0'))\n    \n    source_var = Variable.getVarByPos(source_position, variables)\n    target_var = Variable.getVarByPos(target_position, variables)\n    source_var.isSource = True\n    target_var.isTarget = True\n    \n    for var in variables:\n        var.setNeighbors(variables, board_size)\n        var.setVarDomain(all_colors)\n    \n    # Core logic to solve the problem\n    source_var.setVariable(target_var)\n    target_var.setVariable(source_var)\n    \n    # Convert output to JSON serializable\n    result = {\n        \"source_next\": source_var.next.position,\n        \"target_previous\": target_var.previous.position\n    }\n    \n    return result", "input_generator": "import random\n\ndef input_generator():\n    board_size = random.randint(3, 8)\n    source_row = random.randint(0, board_size - 1)\n    source_col = random.randint(0, board_size - 1)\n    target_row, target_col = source_row, source_col\n    while (target_row, target_col) == (source_row, source_col):\n        target_row = random.randint(0, board_size - 1)\n        target_col = random.randint(0, board_size - 1)\n    colors = ['R', 'G', 'B', 'Y']\n    num_colors = random.randint(1, len(colors))\n    all_colors = random.sample(colors, num_colors)\n    \n    return {\n        \"board_size\": board_size,\n        \"source_position\": (source_row, source_col),\n        \"target_position\": (target_row, target_col),\n        \"all_colors\": all_colors\n    }", "io_pairs": [{"input": {"board_size": 8, "source_position": [3, 7], "target_position": [2, 4], "all_colors": ["R", "B"]}, "output": {"source_next": [2, 4], "target_previous": [3, 7]}}, {"input": {"board_size": 4, "source_position": [2, 1], "target_position": [3, 1], "all_colors": ["Y", "R"]}, "output": {"source_next": [3, 1], "target_previous": [2, 1]}}, {"input": {"board_size": 6, "source_position": [3, 3], "target_position": [0, 0], "all_colors": ["G"]}, "output": {"source_next": [0, 0], "target_previous": [3, 3]}}, {"input": {"board_size": 4, "source_position": [1, 3], "target_position": [2, 1], "all_colors": ["G", "R", "Y", "B"]}, "output": {"source_next": [2, 1], "target_previous": [1, 3]}}, {"input": {"board_size": 4, "source_position": [1, 0], "target_position": [1, 3], "all_colors": ["B", "Y", "G", "R"]}, "output": {"source_next": [1, 3], "target_previous": [1, 0]}}, {"input": {"board_size": 8, "source_position": [4, 2], "target_position": [5, 2], "all_colors": ["R", "B", "G"]}, "output": {"source_next": [5, 2], "target_previous": [4, 2]}}, {"input": {"board_size": 5, "source_position": [2, 2], "target_position": [2, 1], "all_colors": ["R", "Y", "B"]}, "output": {"source_next": [2, 1], "target_previous": [2, 2]}}, {"input": {"board_size": 5, "source_position": [2, 2], "target_position": [1, 0], "all_colors": ["Y"]}, "output": {"source_next": [1, 0], "target_previous": [2, 2]}}, {"input": {"board_size": 7, "source_position": [0, 2], "target_position": [2, 0], "all_colors": ["Y", "G", "B", "R"]}, "output": {"source_next": [2, 0], "target_previous": [0, 2]}}, {"input": {"board_size": 5, "source_position": [1, 2], "target_position": [0, 0], "all_colors": ["G", "Y"]}, "output": {"source_next": [0, 0], "target_previous": [1, 2]}}], "error_log": []}
{"context": "Given a set of dominoes, each with two numbers on its sides, can you determine if they can be arranged in a chain such that the second number of each domino matches the first number of the next domino? If a valid chain exists, what is the arrangement of the dominoes in that chain?\n\nThe input and output requirements are as follows:\n\nInput:\n  `dominoes` (list of lists): A list of dominoes, where each domino is represented as a list of two integers. Each integer represents the number on one side of the domino.\n\nOutput:\n  `return` (list of lists): A valid chain of dominoes if one exists, otherwise an empty list. Each domino in the chain is represented as a list of two integers.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(dominoes):\n    \"\"\"\n    Determines if a set of dominoes can form a valid chain.\n\n    Args:\n        dominoes (list of lists): A list of dominoes, where each domino is represented as a list of two integers.\n\n    Returns:\n        list of lists: A valid chain of dominoes if one exists, otherwise an empty list.\n    \"\"\"\n    if not dominoes:\n        return []\n\n    for permutation in itertools.permutations(dominoes):\n        solution = check(permutation)\n        if solution is not None:\n            return solution\n    return []\n\ndef check(permutation):\n    \"\"\"\n    Checks if a given permutation of dominoes forms a valid chain.\n\n    Args:\n        permutation (tuple of lists): A permutation of dominoes.\n\n    Returns:\n        list of lists: A valid chain of dominoes if one exists, otherwise None.\n    \"\"\"\n    last_prev, prev = permutation[0]\n    solution = [list(permutation[0])]\n    for i in range(1, len(permutation)):\n        if permutation[i][0] == prev:\n            prev = permutation[i][1]\n            solution.append(list(permutation[i]))\n        elif permutation[i][1] == prev:\n            prev = permutation[i][0]\n            solution.append(list(permutation[i][::-1]))\n        else:\n            return None\n    return solution if prev == last_prev else None", "input_generator": "import random\n\ndef input_generator():\n    # Randomly decide the number of dominoes (between 1 and 6 for reasonable size)\n    num_dominoes = random.randint(1, 6)\n    \n    # Generate dominoes ensuring some potential for forming a chain\n    dominoes = []\n    if num_dominoes == 1:\n        dominoes.append([random.randint(0, 6), random.randint(0, 6)])\n    else:\n        # Start with a random first domino\n        first = [random.randint(0, 6), random.randint(0, 6)]\n        dominoes.append(first)\n        prev = first[1]\n        \n        for _ in range(1, num_dominoes):\n            # Randomly decide whether to connect or not (to sometimes create invalid chains)\n            if random.choice([True, False]):\n                next_val = random.randint(0, 6)\n                dominoes.append([prev, next_val])\n                prev = next_val\n            else:\n                dominoes.append([random.randint(0, 6), random.randint(0, 6)])\n    \n    # Shuffle the dominoes to ensure randomness in the input\n    random.shuffle(dominoes)\n    \n    return {'dominoes': dominoes}", "io_pairs": [{"input": {"dominoes": [[6, 3]]}, "output": []}, {"input": {"dominoes": [[1, 3], [3, 5], [5, 4]]}, "output": []}, {"input": {"dominoes": [[5, 2], [1, 3], [3, 5]]}, "output": []}, {"input": {"dominoes": [[3, 4], [2, 5]]}, "output": []}, {"input": {"dominoes": [[4, 2], [5, 4], [0, 4], [1, 0], [5, 5], [3, 5]]}, "output": []}, {"input": {"dominoes": [[6, 0]]}, "output": []}, {"input": {"dominoes": [[1, 1], [6, 6]]}, "output": []}, {"input": {"dominoes": [[5, 0]]}, "output": []}, {"input": {"dominoes": [[6, 6], [6, 3]]}, "output": []}, {"input": {"dominoes": [[3, 4], [1, 6]]}, "output": []}], "error_log": []}
{"context": "Given a logistic function defined by a parameter `r` and an initial value `x0`, what is the period of the orbit and the estimated attractor set after a certain number of iterations `n` with a specified tolerance `epsilon`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `r` (float): The parameter for the logistic function.\n  `x0` (float): The initial value for the logistic function.\n  `n` (int): The number of iterations to compute the orbit.\n  `epsilon` (float): The tolerance for determining the period of the orbit.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `period` (int): The period of the orbit, or -1 if no period is found.\n    - `V10` (list of floats): The estimated attractor set after 10 iterations, or an empty list if no period is found.\n    - `error` (float): The error estimate of the attractor set, or -1 if no period is found.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef orbit(f, x0, n):\n    orb = np.array([x0])\n    for i in range(n):\n        orb = np.append(orb, f(orb[i]))\n    return orb\n\ndef period(orb, epsilon):\n    n = len(orb) - 1\n    for k in range(1, n):\n        if abs(orb[n] - orb[n - k]) < epsilon:\n            return k\n    return -1\n\ndef error(f, V0):\n    Vant = V0\n    Vant.sort()\n    DeltaV = []\n    for i in range(10):\n        Vsig = f(Vant)\n        Vsig.sort()\n        DeltaV.append(max(abs(Vant - Vsig)))\n        Vant = Vsig\n    DeltaV.sort()\n    return (Vant, DeltaV[8])\n\ndef find_V0(f, x0, n, epsilon):\n    orb = orbit(f, x0, n)\n    k = period(orb, epsilon)\n    if k == -1:\n        return (orb, k, [-1])\n    else:\n        V0 = orb[-k:].copy()\n        V0.sort()\n        return (orb, k, V0)\n\n# main function\ndef main_solution(r, x0, n, epsilon):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    logistic = lambda x: r * x * (1 - x)\n    (orb, k, V0) = find_V0(logistic, x0, n, epsilon)\n    if k == -1:\n        return {\"period\": k, \"V10\": [], \"error\": -1}\n    else:\n        (V10, err) = error(logistic, V0)\n        return {\"period\": k, \"V10\": V10.tolist(), \"error\": float(err)}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    r = random.uniform(3.5, 4.0)  # Common range for logistic map chaos\n    x0 = random.uniform(0.1, 0.9)  # Avoid 0 and 1 for logistic map\n    n = random.randint(50, 200)    # Reasonable orbit length\n    epsilon = 10 ** random.uniform(-6, -3)  # Small epsilon for period detection\n    return {\"r\": r, \"x0\": x0, \"n\": n, \"epsilon\": epsilon}", "io_pairs": [{"input": {"r": 3.8608955274371355, "x0": 0.2597762961694044, "n": 94, "epsilon": 0.00036465004102885333}, "output": {"period": -1, "V10": [], "error": -1}}, {"input": {"r": 3.6799166513109967, "x0": 0.7126819138175544, "n": 145, "epsilon": 0.00025916191374284814}, "output": {"period": -1, "V10": [], "error": -1}}, {"input": {"r": 3.6815094649226077, "x0": 0.6693809385015882, "n": 67, "epsilon": 5.3417122003042746e-05}, "output": {"period": -1, "V10": [], "error": -1}}, {"input": {"r": 3.9126248980443847, "x0": 0.16147722534317516, "n": 153, "epsilon": 1.62942503746898e-06}, "output": {"period": -1, "V10": [], "error": -1}}, {"input": {"r": 3.8132063638146656, "x0": 0.5422053541999168, "n": 193, "epsilon": 5.120420389028449e-06}, "output": {"period": -1, "V10": [], "error": -1}}, {"input": {"r": 3.812052132857639, "x0": 0.13631584004308828, "n": 139, "epsilon": 4.716343094800955e-05}, "output": {"period": -1, "V10": [], "error": -1}}, {"input": {"r": 3.8857765891407214, "x0": 0.1426909398502378, "n": 100, "epsilon": 0.0009436871386728653}, "output": {"period": -1, "V10": [], "error": -1}}, {"input": {"r": 3.7163393605967663, "x0": 0.2697554228060879, "n": 168, "epsilon": 2.3095636516578538e-05}, "output": {"period": -1, "V10": [], "error": -1}}, {"input": {"r": 3.712980284651083, "x0": 0.16494482303068825, "n": 106, "epsilon": 3.948631406168298e-06}, "output": {"period": -1, "V10": [], "error": -1}}, {"input": {"r": 3.500551577549039, "x0": 0.6515422929605944, "n": 72, "epsilon": 1.3232776063975579e-06}, "output": {"period": 4, "V10": [0.38252441559494477, 0.5012199667333407, 0.8268284870745792, 0.8751326844504289], "error": 2.8170576982233797e-11}}], "error_log": []}
{"context": "Given a set of grammar rules and an input string, determine whether the string can be generated by the grammar. The grammar rules are provided in a specific format, and the input string consists of words separated by spaces. What is the result of checking if the input string is accepted by the grammar?\n\nThe input and output requirements are as follows:\n\nInput:\n  `gramatica_str` (str): A string representing the grammar rules. Each rule is separated by a newline, and each rule is in the format \"variable -> production\". Productions can be separated by \" | \".\n  `string` (str): A string representing the input string to be checked against the grammar. Words in the string are separated by spaces.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input string is accepted by the grammar (True) or not (False).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef create_chart(w):\n    w = w.split(\" \")\n    tam = len(w) + 1\n    w = [\"@\"] + w\n    return [[] for x in range(tam)]\n\ndef le_gramatica(gramatica_str):\n    gramatica = {}\n    inicial = '$'\n    tem_inicial = False\n\n    for string in gramatica_str.split(\"\\n\"):\n        cadeia = string.strip().split(\"->\")\n        variavel = cadeia[0].strip()\n\n        if \"|\" in cadeia[1]:\n            cadeia = cadeia[1].strip().split(\" | \")\n            producoes = []\n            for c in cadeia:\n                producoes += [\".\" + c]\n        else:\n            cadeia = cadeia[1].replace(\" |\", \"\").strip()\n            producoes = [\".\" + cadeia]\n\n        if variavel == inicial:\n            tem_inicial = True\n\n        if variavel in gramatica:\n            gramatica[variavel] += producoes\n        else:\n            gramatica[variavel] = producoes\n\n    if not tem_inicial:\n        gramatica[inicial] = ['S']\n\n    return gramatica\n\ndef pega_proxima_pelo_ponto(producao):\n    proxima = producao.split(\".\")\n    proxima = proxima[1]\n\n    while \" \" in proxima:\n        temp = proxima.split(\" \")\n        proxima = temp[0]\n\n    return proxima\n\ndef mover_ponto_na_producao(producao):\n    comeco = producao.index(\".\") + 1\n    producao = list(producao)\n\n    if comeco < len(producao):\n        if \" \" in producao:\n            pos = producao.index(\" \")\n            producao[comeco - 1] = \" \"\n            producao[pos] = \".\"\n        else:\n            producao[comeco - 1] = \" \"\n            producao += \".\"\n    else:\n        producao[comeco - 1] = \" \"\n        producao += \".\"\n\n    novaprod = \"\"\n    for x in producao:\n        novaprod += x\n\n    return novaprod.strip()\n\ndef variavel_depois_do_ponto(char, producao):\n    novaprod = \"\"\n    for x in producao:\n        novaprod += x\n\n    novaprod = novaprod.split(\".\")[1]\n    if \" \" in novaprod:\n        novaprod = novaprod.split(\" \")[0]\n\n    if char == novaprod:\n        return True\n\n    return False\n\ndef completa(valor):\n    if valor == \" \" or valor == \"\":\n        return True\n    return False\n\ndef scanner(chart, i, estado, gramatica, palavra):\n    proxima = pega_proxima_pelo_ponto(estado[2])\n    if proxima not in gramatica:\n        if proxima == palavra:\n            producao = mover_ponto_na_producao(estado[2])\n            chart[i].append([estado[0], estado[1], producao])\n\ndef predictor(chart, i, estado, gramatica, visitados):\n    proxima = pega_proxima_pelo_ponto(estado[2])\n    if proxima not in visitados and proxima in gramatica:\n        visitados.append(proxima)\n        for producao in gramatica[proxima]:\n            chart[i].append([i, proxima, producao])\n\ndef completer(chart, i, estado):\n    k = estado[0]\n    char = estado[1]\n\n    for est, var, prods in chart[k]:\n        if variavel_depois_do_ponto(char, prods):\n            prods = mover_ponto_na_producao(prods)\n            if [est, var, prods] not in chart[i]:\n                chart[i].append([est, var, prods])\n\ndef parse_earley(chart, gramatica, w):\n    w = w.split(\" \")\n    chart[0].append([0, \"$\", \".S\"])  # noob state\n\n    for i in range(len(chart)):\n        visitados_predictor = []\n\n        j = 0\n        while j < len(chart[i]):\n            estado = chart[i][j]\n            proxima = pega_proxima_pelo_ponto(estado[2])\n\n            if not completa(proxima) and proxima in gramatica:\n                predictor(chart, i, estado, gramatica, visitados_predictor)\n            elif not completa(proxima) and proxima not in gramatica:\n                if i + 1 < len(chart):\n                    scanner(chart, i + 1, estado, gramatica, w[i])\n            else:\n                completer(chart, i, estado)\n\n            j += 1\n\ndef aceita_string(chart):\n    for est, var, prods in chart[-1]:\n        if var == \"$\" and prods.index(\".\") == len(prods) - 1:\n            return True\n\n    return False\n\n# main function\ndef main_solution(gramatica_str, string):\n    # Convert input to the required format\n    gramatica = le_gramatica(gramatica_str)\n    chart = create_chart(string)\n    parse_earley(chart, gramatica, string)\n    \n    # Return the result as a JSON serializable output\n    return aceita_string(chart)", "input_generator": "import random\n\ndef input_generator():\n    grammars = [\n        \"\"\"\n        S -> NP VP\n        NP -> Det N | Det N PP\n        VP -> V NP | V NP PP\n        PP -> P NP\n        Det -> 'the' | 'a'\n        N -> 'man' | 'dog' | 'cat' | 'telescope' | 'park'\n        V -> 'saw' | 'ate' | 'walked'\n        P -> 'in' | 'on' | 'by' | 'with'\n        \"\"\",\n        \"\"\"\n        E -> E '+' T | T\n        T -> T '*' F | F\n        F -> '(' E ')' | 'id'\n        \"\"\",\n        \"\"\"\n        S -> A B | B C\n        A -> 'a' A | 'a'\n        B -> 'b' B | 'b'\n        C -> 'c' C | 'c'\n        \"\"\",\n        \"\"\"\n        S -> '(' S ')' | '[' S ']' | '{' S '}' | ''\n        \"\"\"\n    ]\n    \n    strings = [\n        \"the man saw a dog\",\n        \"id + id * id\",\n        \"a b b c c c\",\n        \"( [ { } ] )\",\n        \"a a a b b\",\n        \"the cat walked in the park\"\n    ]\n    \n    grammar_str = random.choice(grammars)\n    string = random.choice(strings)\n    \n    return {\n        \"gramatica_str\": grammar_str,\n        \"string\": string\n    }", "io_pairs": [], "error_log": []}
{"context": "Given a sequence of integers, determine whether this sequence could represent the post-order traversal of a Binary Search Tree (BST). What is the result of the verification?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sequence` (list of int): A list of integers representing the sequence to be verified as the post-order traversal of a Binary Search Tree (BST).\nOutput:\n  `return` (str): A string \"Yes\" if the sequence is a valid post-order traversal of a BST, otherwise \"No\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, sequence):\n        if not sequence:\n            return False\n        root = sequence[-1]\n        index = 0\n        l = len(sequence)\n        for i in range(l-1):\n            index = i\n            if sequence[i] > root:\n                break\n                \n        for i in range(index+1,l-1):\n            if sequence[i] < root:\n                return False\n        left = True\n        \n        if index > 0:\n            left = self.VerifySquenceOfBST(sequence[:index])\n        right = True\n        if index < l - 1:\n            right = self.VerifySquenceOfBST(sequence[index:l-1])\n        return left and right\n\n# main function\ndef main_solution(sequence):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  S = Solution()\n  result = S.VerifySquenceOfBST(sequence)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return \"Yes\" if result else \"No\"", "input_generator": "import random\n\ndef input_generator():\n    def generate_sequence(length):\n        if length == 0:\n            return []\n        sequence = []\n        for _ in range(length):\n            sequence.append(random.randint(1, 100))\n        # Randomly decide to make it a valid BST sequence or not\n        if random.choice([True, False]):\n            sequence.sort()\n            # Post-order traversal of a BST is sorted sequence with root at end\n            return sequence\n        else:\n            # Shuffle to make it invalid\n            random.shuffle(sequence)\n            return sequence\n    \n    length = random.randint(0, 20)\n    sequence = generate_sequence(length)\n    return {'sequence': sequence}", "io_pairs": [{"input": {"sequence": [26, 41, 42, 46, 66, 84, 84, 95]}, "output": "Yes"}, {"input": {"sequence": [4, 5, 9, 11, 19, 20, 23, 38, 42, 47, 61, 77, 78, 79, 80]}, "output": "Yes"}, {"input": {"sequence": [22, 22, 23, 25, 27, 35, 61, 62, 64, 76, 78, 79, 83, 93, 94, 99]}, "output": "Yes"}, {"input": {"sequence": [18, 100, 63, 45, 35, 90, 61, 70, 18, 33, 36, 8, 50, 49, 25, 59, 45, 83]}, "output": "No"}, {"input": {"sequence": [57, 8, 31, 77, 86, 78, 30, 14, 8, 36, 86, 70, 12, 80, 31, 74, 55, 31, 84]}, "output": "No"}, {"input": {"sequence": [34, 81, 49, 5, 56, 97, 100, 94, 58, 47, 93, 43, 75, 42, 36, 46]}, "output": "No"}, {"input": {"sequence": [6, 12, 16, 39, 39, 41, 42, 51, 57, 57, 58, 63, 67, 85, 85, 98, 100]}, "output": "Yes"}, {"input": {"sequence": [15, 20, 27, 31, 52, 52, 61, 68, 85, 86, 96, 99]}, "output": "Yes"}, {"input": {"sequence": [9, 4, 20, 3, 74, 55, 21, 42, 12, 42, 63, 90, 8, 10, 12, 92, 82, 40]}, "output": "No"}, {"input": {"sequence": [46, 54, 93]}, "output": "Yes"}], "error_log": []}
{"context": "In a secure communication system, Alice wants to send a message to Bob. However, before sending the message, she needs to encrypt it using Bob's public key. After receiving the encrypted message, Bob will decrypt it using his private key. What will be the result of encrypting and then decrypting the message using Bob's keys?\n\nThe input and output requirements are as follows:\n\nInput:\n  `user_name` (str): The name of the user for whom the message is being encrypted and decrypted.\n  `message` (str): The message to be encrypted and then decrypted.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `original_message` (str): The original message provided as input.\n    - `encrypted_message` (list): A list of integers representing the encrypted message.\n    - `decrypted_message` (str): The decrypted message, which should match the original message.", "reference_code": "# import necessary packages\nfrom random import randrange, getrandbits\n\n# Keeping track of Prime Numbers used so every users get unique prime numbers.\nused_prime_number = []\n\n# RSA Encryption\n# The User Data Access Object handles all interactions with the User collection.\n\nclass RSA_User:\n    \"\"\" A RSA User Object for Encryption and Decryption.\n\n        Attributes:\n            get_public_key():  Returns public key of the given User\n            encrypt(message):  Encrypts given message\n            decrypt(message):  Decrypts given message\n\n\n        Example:\n            Alice= RSA_User(\"Alice\")\n            Bob= RSA_User(\"Bob\")\n\n            #Bob encrypts a message using Alice's public key\n            bob_encrypted_msg= Alice.encrypt(\"Hey, Alice. I am Bob!\")\n\n            #Now Alice Decrypts Bob's Message Using Her Private Key\n            decrypted_message= Alice.decrypt(bob_encrypted_msg)\n\n            print(decrypted_message)\n\n            \"\"\"\n\n    #STATIC METHODS\n\n    # Fermat's Little Theorem Prime Test For Simplicity\n    # There are cases where this test fails, Carmichael's Numbers, but  its rare\n    #Fermat's Prime Test. Returns True if given number is a prime\n    def __prime_test(number):\n        if number == 2:\n            return True\n        return pow(2, number - 1, number) == 1\n\n    # Generating Large Primes of at most 256 bit\n    # 2048 Bit is recommended according to wikipedia\n    #Returns a prime number of given bit number.\n    def __generate_prime(num_bit):\n        prime_num = getrandbits(num_bit)\n        while (not RSA_User.__prime_test(prime_num) and not(prime_num in used_prime_number)):\n            prime_num = getrandbits(num_bit)\n        used_prime_number.append(prime_num)\n        return prime_num\n\n    # EUCLIEDEAN ALGORITHM for finding greatest common divisor.\n    #  Returns GCD of given two number\n    def __gcd_euclidean(a, b):\n        if (b == 0):\n            return a\n        else:\n            return RSA_User.__gcd_euclidean(b, a % b)\n\n\n    # Euler's Totient Function for prime.\n    # Returns total number of relative prime < n\n    def __euler_totient(p, q):\n        return ((p - 1) * (q - 1))\n\n\n    # Using Extended Euler's Algorithm ,we can find the multiplicative inverse quickly.\n    # We use the fact that e*d=1 mod(euler_totient())\n    def __extended_euclid(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        d, x, y = RSA_User.__extended_euclid(b, a % b)\n        return d, y, x - (a // b) * y\n\n\n    # OBJECT METHOD\n\n    #Constructor for the class\n    def __init__(self, name):\n        self.name = name\n        self.__p = RSA_User.__generate_prime(256)\n        self.__q = RSA_User.__generate_prime(257)\n\n\n    def get_public_keys(self):\n        \"\"\"Public Key Functions\n\n            Returns e and n\n\n            Example:\n                Alice = RSA_User(\"Alice\")\n                e,n= Alice.get_public_keys()\n            \"\"\"\n        n = (self.__p) * (self.__q)\n        for coprime in range(3, n, 2):\n            if (RSA_User.__gcd_euclidean(coprime, RSA_User.__euler_totient(self.__p, self.__q)) == 1):\n                return coprime, n\n\n    #PRIVATE Object's Method\n    def __get_private_key(self):\n        e, n = self.get_public_keys()\n        #Phi represents the Euler Totient function\n        phi = RSA_User.__euler_totient(self.__p, self.__q)\n        x, y, z = RSA_User.__extended_euclid(e, phi)\n        if (not (y > 0)):\n            return (phi + y), n\n        else:\n            return y, n\n\n    def encrypt(self, message):\n        \"\"\"Encrypts the given message.\n\n            Here Jack will Use Alice's public key to encrypt his message.\n            Then Jack sends the encrypted_message to Alice.\n            This function is public and available to use by anyone.\n\n            Example:\n                Alice = RSA_User(\"Alice\")\n                Jack= RSA_User(\"Jack\")\n                Jack_encrypted_message= Alice.encrypt(\"Hey Alice, This is Jack!\")\n\n        \"\"\"\n        e, n = self.get_public_keys()\n        uncipher = []\n        ciphered = []\n\n        for character in message:\n            uncipher.append(ord(character))\n\n        for unciphered in uncipher:\n            ciphered.append(pow(unciphered, e, n))\n\n        return ciphered\n\n\n    def decrypt(self, message):\n        \"\"\"Decrypts the given message.\n\n            Here Alice will use her private key to decrypt Jack's message.\n            Then Jack sends the encrypted_message to Alice.\n            This function is private and ONLY the Alice can use this.\n            Other keys will not work and throw an exception with error message.\n\n            Example:\n                Alice = RSA_User(\"Alice\")\n                Jack= RSA_User(\"Jack\")\n                Jack_encrypted_message= Alice.encrypt(\"Hey Alice, This is Jack!\")\n                print(\"Message = \",Alice.decrypt(Jack_encrypted_message))\n        \"\"\"\n        try:\n            d, n = self.__get_private_key()\n            uncipher = []\n            deciphered = []\n\n            real_message = \"\"\n\n            for character in message:\n                uncipher.append(character)\n\n            for unciphered in uncipher:\n                deciphered.append(pow(unciphered, d, n))\n\n            for things in deciphered:\n                real_message += chr(things)\n\n            return real_message\n        except Exception as e:\n            print(\"Something Went Wrong....Did you use the right key?.\")\n            print(\"Error Report :\", e)\n\n# main function\ndef main_solution(user_name, message):\n    \"\"\"\n    Encrypts a message using the public key of a user and then decrypts it using the private key of the same user.\n\n    Args:\n        user_name (str): The name of the user for whom the message is being encrypted and decrypted.\n        message (str): The message to be encrypted and then decrypted.\n\n    Returns:\n        dict: A dictionary containing the original message, the encrypted message, and the decrypted message.\n    \"\"\"\n    user = RSA_User(user_name)\n    encrypted_message = user.encrypt(message)\n    decrypted_message = user.decrypt(encrypted_message)\n    return {\n        \"original_message\": message,\n        \"encrypted_message\": encrypted_message,\n        \"decrypted_message\": decrypted_message\n    }", "input_generator": "import random\nimport string\n\ndef input_generator():\n    user_names = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Eve\", \"Frank\", \"Grace\", \"Heidi\"]\n    user_name = random.choice(user_names)\n    \n    message_length = random.randint(10, 50)\n    message = ''.join(random.choice(string.ascii_letters + string.digits + ' ') for _ in range(message_length))\n    \n    return {\n        \"user_name\": user_name,\n        \"message\": message\n    }", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a partially filled Tic-Tac-Toe board, determine the final state of the board after the game has ended. The game is played between a human and a computer, with the human using either 'X' or 'O' and the computer using the opposite letter. The human may or may not go first. What will be the final configuration of the board?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board_state` (list of strings): A list of 3 strings, each representing a row of the Tic-Tac-Toe board. Each string contains 3 characters, either '-', 'X', or 'O'.\n  `human_letter` (string): A single character string, either 'X' or 'O', representing the letter used by the human player.\n  `cpu_letter` (string): A single character string, either 'X' or 'O', representing the letter used by the computer player.\n  `human_first` (boolean): A boolean value indicating whether the human player goes first (`True`) or the computer player goes first (`False`).\n\nOutput:\n  `return` (list of strings): A list of 3 strings, each representing a row of the Tic-Tac-Toe board after the game has ended. Each string contains 3 characters, either '-', 'X', or 'O'.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef startgame():\n    #create empty board\n    board = [['-','-','-'],\n             ['-','-','-'],\n             ['-','-','-']]\n    return board\n\ndef playerletter():\n    #return two letters, first one for human player\n    #and second one for computer player\n    letter = random.choice(['X', 'O'])\n    if letter == 'X':\n        human = 'X'\n        cpu = 'O'\n    else:\n        human = 'O'\n        cpu = 'X'\n    return human, cpu\n\ndef humanfirst():\n    #ask who should go first and return True if human goes first\n    #and False if computer goes first\n    first = random.choice([True, False])\n    return first\n\ndef getUnoccupiedSpaces(board):\n    #return list containing all empty spaces (all possible moves)\n    spaces = []\n    for row in range(3):\n        for col in range(3):\n            if board[row][col] == '-':\n                spaces.append(str(row * 3 + col + 1))\n    return spaces\n\ndef makemove(b, move, token):\n    #add token into the board at move (space)\n    move = int(move) - 1\n    b[move // 3][move % 3] = token\n    return b\n\ndef getBoardCopy(board):\n    import copy\n    copBoard = copy.deepcopy(board)\n    return copBoard\n\ndef is_win_or_tie(board):\n    #check win/tie conditions\n    #return True if no more moves are left or if someone won\n    #return False if open moves are left and no one has won\n    for row in board:\n        if row[0] == row[1] == row[2] and row[0] != '-':\n            return True\n    for col in range(3):\n        if board[0][col] == board[1][col] == board[2][col] and board[0][col] != '-':\n            return True\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] != '-':\n        return True\n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] != '-':\n        return True\n    for row in board:\n        if '-' in row:\n            return False\n    return True\n\ndef makeAImove(board, letters):\n    #make AI move based on following priority list:\n    #1) make winning move\n    #2) block human winning move\n    #3) create fork\n    #4) block opposing fork\n    #5) take center\n    #6) get opposing corner\n    #7) take any empty corner\n    #8) take any side\n    \n    free = getUnoccupiedSpaces(board)\n\n    #1) make winning move if possible\n    for space in free:\n        copBoard = getBoardCopy(board)\n        copBoard = makemove(copBoard, space, letters[1])\n        winmove = is_win_or_tie(copBoard)\n        if winmove:\n            move = space\n            newboard = makemove(board, move, letters[1])\n            return newboard\n\n    #2) block human winning move\n    for space in free:\n        copBoard = getBoardCopy(board)\n        copBoard = makemove(copBoard, space, letters[0])\n        winmove = is_win_or_tie(copBoard)\n        if winmove:\n            move = space\n            newboard = makemove(board, move, letters[1])\n            return newboard\n\n    #3) take center if open\n    if '5' in free:\n        newboard = makemove(board, '5', letters[1])\n        return newboard\n\n    #4) get free corner\n    corners = ['1', '3', '7', '9']\n    for corner in corners:\n        if corner in free:\n            newboard = makemove(board, corner, letters[1])\n            return newboard\n\n    #5) get free side\n    sides = ['2', '4', '6', '8']\n    for side in sides:\n        if side in free:\n            newboard = makemove(board, side, letters[1])\n            return newboard\n\n    move = random.choice(free)\n    newboard = makemove(board, move, letters[1])\n    return newboard\n\n# main function\ndef main_solution(board_state, human_letter, cpu_letter, human_first):\n    # all input arguments of the main_solution function should be json serializable\n    board = [list(row) for row in board_state]\n    letters = (human_letter, cpu_letter)\n    first = human_first\n    \n    if first:\n        turn = 'human'\n    else:\n        turn = 'cpu'\n        \n    while not is_win_or_tie(board): #loop until win/tie is True\n        if turn == 'human':\n            board = makemove(board, random.choice(getUnoccupiedSpaces(board)), letters[0])\n            turn = 'cpu'\n        else:\n            board = makeAImove(board, letters)\n            turn = 'human'\n\n    # Convert board back to JSON serializable format\n    board_state = [''.join(row) for row in board]\n    return board_state", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random board state with some moves already made\n    board = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n    letters = random.choice(['X', 'O'])\n    human_letter = letters\n    cpu_letter = 'O' if letters == 'X' else 'X'\n    \n    # Randomly decide if human or CPU goes first\n    human_first = random.choice([True, False])\n    \n    # Make some random moves on the board\n    moves = random.randint(0, 4)  # Up to 4 moves to keep it reasonable\n    for _ in range(moves):\n        free_spaces = getUnoccupiedSpaces(board)\n        if not free_spaces:\n            break\n        move = random.choice(free_spaces)\n        token = human_letter if (human_first and len(free_spaces) % 2 == 1) or (not human_first and len(free_spaces) % 2 == 0) else cpu_letter\n        board = makemove(board, move, token)\n    \n    # Convert board to list of strings for JSON serialization\n    board_state = [''.join(row) for row in board]\n    \n    return {\n        'board_state': board_state,\n        'human_letter': human_letter,\n        'cpu_letter': cpu_letter,\n        'human_first': human_first\n    }\n\ndef getUnoccupiedSpaces(board):\n    spaces = []\n    for row in range(3):\n        for col in range(3):\n            if board[row][col] == '-':\n                spaces.append(str(row * 3 + col + 1))\n    return spaces\n\ndef makemove(b, move, token):\n    move = int(move) - 1\n    b[move // 3][move % 3] = token\n    return b", "io_pairs": [{"input": {"board_state": ["X-O", "---", "X-O"], "human_letter": "X", "cpu_letter": "O", "human_first": true}, "output": ["X-O", "--O", "XXO"]}, {"input": {"board_state": ["-O-", "---", "---"], "human_letter": "X", "cpu_letter": "O", "human_first": false}, "output": ["XO-", "-O-", "-O-"]}, {"input": {"board_state": ["---", "---", "---"], "human_letter": "X", "cpu_letter": "O", "human_first": false}, "output": ["O--", "XO-", "-XO"]}, {"input": {"board_state": ["-O-", "---", "---"], "human_letter": "O", "cpu_letter": "X", "human_first": true}, "output": ["XOO", "OXX", "XOO"]}, {"input": {"board_state": ["--X", "-OX", "--O"], "human_letter": "X", "cpu_letter": "O", "human_first": true}, "output": ["O-X", "-OX", "X-O"]}, {"input": {"board_state": ["---", "-X-", "O--"], "human_letter": "O", "cpu_letter": "X", "human_first": false}, "output": ["XO-", "-X-", "O-X"]}, {"input": {"board_state": ["O--", "-X-", "X--"], "human_letter": "O", "cpu_letter": "X", "human_first": false}, "output": ["O-X", "-X-", "X--"]}, {"input": {"board_state": ["---", "---", "---"], "human_letter": "O", "cpu_letter": "X", "human_first": false}, "output": ["X--", "OXO", "--X"]}, {"input": {"board_state": ["---", "-O-", "---"], "human_letter": "X", "cpu_letter": "O", "human_first": false}, "output": ["O--", "-O-", "X-O"]}, {"input": {"board_state": ["--O", "---", "---"], "human_letter": "O", "cpu_letter": "X", "human_first": true}, "output": ["XOO", "-OX", "XOO"]}], "error_log": []}
{"context": "In a semiconductor manufacturing facility, a batch of chips is produced, and it is crucial to identify at least one good chip from the batch. Each chip can either be good or bad, and a good chip will always report the true quality of another chip, while a bad chip may report randomly. Given a batch of chips, how can we determine the number and quality of a chip that is most likely to be good?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_chips` (int): The number of chips to be created. This number should be between 50 and 100.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `number` (int): The number of the identified chip.\n    - `quality` (bool): The quality of the identified chip, where `True` indicates a good chip and `False` indicates a bad chip.", "reference_code": "import random\n\nclass chip:\n    def __init__(self, number, quality):\n        self.number = number\n        self.quality = quality\n    \n    def test_target(self, target):\n        if self.quality:\n            return target.quality\n        else:\n            return random.choice((True, False))\n\ndef create_chips(num_chips):\n    chips = []\n    quality_count = 0\n    badnums = []\n    for x in range(num_chips):\n        if random.choice((True, False)):\n            chips.append(chip(number=x, quality=True))\n            quality_count += 1\n        else:\n            chips.append(chip(number=x, quality=False))\n            badnums.append(x)\n    while quality_count <= len(chips) / 2:\n        for _ in range(random.choice((1, 2))):\n            num = badnums.pop(random.randint(0, len(badnums) - 1))\n            chips[num].quality = True\n            quality_count += 1\n    return chips\n\ndef test(A, B):\n    return A.test_target(B) and B.test_target(A)\n\ndef main_solution(num_chips):\n    chips = create_chips(num_chips)\n    while len(chips) > 3:\n        if len(chips) % 2 != 0:\n            count = 0\n            for i in chips[:-1]:\n                if i.test_target(chips[-1]):\n                    count += 1\n            if count >= len(chips) // 2:\n                return {\"number\": chips[-1].number, \"quality\": chips[-1].quality}\n            else:\n                chips.pop()\n        else:\n            surplus = []\n            for i in range(len(chips) // 2):\n                if test(chips[i * 2], chips[i * 2 + 1]):\n                    surplus.append(chips[i * 2 + random.choice((0, 1))])\n            chips = surplus\n    \n    if len(chips) <= 2:\n        return {\"number\": chips[0].number, \"quality\": chips[0].quality}\n    elif len(chips) == 3:\n        if test(chips[0], chips[1]):\n            return {\"number\": chips[0].number, \"quality\": chips[0].quality}\n        else:\n            return {\"number\": chips[2].number, \"quality\": chips[2].quality}\n    else:\n        return {\"number\": -1, \"quality\": False}", "input_generator": "import random\n\ndef input_generator():\n    num_chips = random.randint(4, 20)  # Reasonable range to ensure multiple iterations in main_solution\n    return {\"num_chips\": num_chips}", "io_pairs": [{"input": {"num_chips": 8}, "output": {"number": 4, "quality": true}}, {"input": {"num_chips": 13}, "output": {"number": 12, "quality": true}}, {"input": {"num_chips": 17}, "output": {"number": 2, "quality": true}}, {"input": {"num_chips": 15}, "output": {"number": 14, "quality": true}}, {"input": {"num_chips": 19}, "output": {"number": 15, "quality": true}}, {"input": {"num_chips": 4}, "output": {"number": 1, "quality": true}}, {"input": {"num_chips": 6}, "output": {"number": 3, "quality": true}}, {"input": {"num_chips": 9}, "output": {"number": 8, "quality": true}}, {"input": {"num_chips": 18}, "output": {"number": 1, "quality": true}}, {"input": {"num_chips": 20}, "output": {"number": 6, "quality": true}}], "error_log": []}
{"context": "Given the frequencies and average distances of the subject, object, and indirect object in a verb's context, along with a variance parameter, what are the probabilities of the verb belonging to different word order categories?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sfreq` (float): The frequency of the subject in the verb's context.\n  `ofreq` (float): The frequency of the object in the verb's context.\n  `iofreq` (float): The frequency of the indirect object in the verb's context.\n  `sdist` (float): The average distance of the subject from the verb.\n  `odist` (float): The average distance of the object from the verb.\n  `iodist` (float): The average distance of the indirect object from the verb.\n  `variance` (float): The variance used in the probability calculations.\n\nOutput:\n  `return` (dict): A dictionary where keys are word order categories (e.g., \"SV\", \"VO\", \"SVOI\") and values are the probabilities of the verb belonging to each category.", "reference_code": "# import necessary packages\nimport pandas as pd\nimport numpy as np\nimport math\nfrom functools import reduce\n\n# Helper functions for probability calculations\ndef sphere_project(p):\n    m = 1/((p[0]**2 + p[1]**2 + p[2]**2)**0.5)\n    return (p[0]*m, p[1]*m, p[2]*m)\n\ndef spherical_distance(p1, p2):\n    C = ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 + (p1[2] - p2[2])**2)**0.5\n    return (2*math.asin(C/2))\n\ndef spherical_norm_pdf(mean_dist, var, p, mean_point):\n    d = spherical_distance(p, mean_point)\n    return math.exp(- (d - mean_dist)**2/(2*var))/((2*math.pi*var)**2)\n\ndef gaussian_prob(mean_point, var, points, point):\n    mean_dist = spherical_distance(point, mean_point)\n    probs = []\n    for p in points:\n        probs.append(spherical_norm_pdf(mean_dist, var, point, p))\n    s = sum(probs)\n    return [x/s for x in probs]\n\ndef probs(p, variance):\n    kmeans = [(1, 0, 0), (0, 1, 0), (0, 0, 1), (1/2, 1/2, 0),\n              (1/2, 0, 1/2), (0, 1/2, 1/2), (1/3, 1/3, 1/3)]\n    kmeans_spherical = [sphere_project(p) for p in kmeans]\n    if (p == (0, 0, 0)):\n        return ([1/9] * 7)\n    else:\n        mind = np.inf\n        cluster = -1\n        for k in range(len(kmeans)):\n            mpoint = kmeans[k]\n            d = ((p[0] - mpoint[0])**2 + (p[1] - mpoint[1])\n                 ** 2 + (p[2] - mpoint[2])**2)**0.5\n            if (d < mind):\n                mind = d\n                cluster = k\n        return gaussian_prob(kmeans_spherical[cluster], variance, kmeans_spherical,\n                             sphere_project(p))\n\ndef word_order(sdist, odist, iodist, defaultwo=(0, 1, 2, 3)):\n    def strwo(n):\n        if (n == 0):\n            return \"V\"\n        elif (n == 1):\n            return \"S\"\n        elif (n == 2):\n            return \"O\"\n        elif (n == 3):\n            return \"I\"\n    dists = (0.0, sdist, odist, iodist)\n    wo = defaultwo\n    return reduce(lambda x, y: x + strwo(y), sorted(wo, key=lambda x: dists[x])[::-1], \"\")\n\ndef clusterVerb(sfreq, ofreq, iofreq, sdist, odist, iodist, variance):\n    def non_args(i):\n        s = []\n        if (i == 1 or i == 2 or i == 5):\n            s.append(\"S\")\n        if (i == 0 or i == 2 or i == 4):\n            s.append(\"O\")\n        if (i == 0 or i == 1 or i == 3):\n            s.append(\"I\")\n        return s\n\n    wo = word_order(sdist, odist, iodist, defaultwo=(\n        1, 0, 2, 3))\n    probabs = probs((sfreq, ofreq, iofreq), variance)\n    clusterDict = {}\n    for i in range(len(probabs)):\n        nags = non_args(i)\n        wo_cat = wo\n        for ag in nags:\n            wo_cat = wo_cat.replace(ag, \"\")\n        clusterDict[wo_cat] = probabs[i]\n    return clusterDict\n\n# main function\ndef main_solution(sfreq, ofreq, iofreq, sdist, odist, iodist, variance):\n    # Convert input variables to JSON serializable\n    sfreq = float(sfreq)\n    ofreq = float(ofreq)\n    iofreq = float(iofreq)\n    sdist = float(sdist)\n    odist = float(odist)\n    iodist = float(iodist)\n    variance = float(variance)\n    \n    # Call the core function\n    result = clusterVerb(sfreq, ofreq, iofreq, sdist, odist, iodist, variance)\n    \n    # Convert output to JSON serializable\n    result_serializable = {k: float(v) for k, v in result.items()}\n    \n    return result_serializable", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random frequencies (non-negative, but not all zero)\n    sfreq = random.uniform(0.1, 10.0)\n    ofreq = random.uniform(0.1, 10.0)\n    iofreq = random.uniform(0.1, 10.0)\n    \n    # Generate random distances (positive)\n    sdist = random.uniform(0.1, 5.0)\n    odist = random.uniform(0.1, 5.0)\n    iodist = random.uniform(0.1, 5.0)\n    \n    # Generate random variance (positive)\n    variance = random.uniform(0.01, 2.0)\n    \n    return {\n        'sfreq': sfreq,\n        'ofreq': ofreq,\n        'iofreq': iofreq,\n        'sdist': sdist,\n        'odist': odist,\n        'iodist': iodist,\n        'variance': variance\n    }", "io_pairs": [{"input": {"sfreq": 4.457408034636534, "ofreq": 5.305488707380727, "iofreq": 0.24053967744760585, "sdist": 3.6740071545301576, "odist": 3.1110417501635523, "iodist": 4.393787927606115, "variance": 1.4836458715701022}, "output": {"SV": 0.15023735569674396, "OV": 0.1517619536456489, "IV": 0.1198718122689604, "SOV": 0.13408774277717056, "ISV": 0.1448580202389659, "IOV": 0.14807429204371078, "ISOV": 0.15110882332879946}}, {"input": {"sfreq": 8.933648098076887, "ofreq": 5.020483282193126, "iofreq": 1.18679905731538, "sdist": 2.702101683467018, "odist": 3.9178123765800237, "iodist": 3.0840613218805464, "variance": 1.7924130428774037}, "output": {"SV": 0.1521419625102418, "OV": 0.14030480928965997, "IV": 0.11941493540050868, "OSV": 0.149960784165755, "ISV": 0.14883878754973032, "OIV": 0.13725206483107155, "OISV": 0.15208665625303258}}, {"input": {"sfreq": 2.5152568238987105, "ofreq": 9.95210837377146, "iofreq": 7.666278688238179, "sdist": 3.201289010619527, "odist": 0.5359885351305154, "iodist": 1.7149602016503505, "variance": 0.7510992733895705}, "output": {"SV": 0.11261311381625579, "OV": 0.15488534760273145, "IV": 0.14866795659951765, "SOV": 0.15313421207458197, "SIV": 0.14629176267227267, "IOV": 0.13569949874709875, "SIOV": 0.14870810848754168}}, {"input": {"sfreq": 2.544179137395965, "ofreq": 1.2040005337895674, "iofreq": 8.024215817220222, "sdist": 2.5504417475082666, "odist": 2.5731330216805652, "iodist": 3.126736645407928, "variance": 1.129845923541812}, "output": {"SV": 0.11652750721118502, "OV": 0.10083050088806282, "IV": 0.17080797339944567, "OSV": 0.11778262040143131, "ISV": 0.1688819852198965, "IOV": 0.16135343959590892, "IOSV": 0.16381597328406966}}, {"input": {"sfreq": 5.751894592925781, "ofreq": 1.4623197156102603, "iofreq": 5.929868573401243, "sdist": 2.941033226545182, "odist": 1.9351677638222213, "iodist": 2.0658996625935186, "variance": 1.6236593300286215}, "output": {"SV": 0.1450009063989259, "OV": 0.10401422369462605, "IV": 0.14665932714994775, "SOV": 0.1388558530205368, "SIV": 0.1644633698784957, "IOV": 0.1400522706124627, "SIOV": 0.16095404924500512}}, {"input": {"sfreq": 7.627588912662124, "ofreq": 5.883220686174023, "iofreq": 1.705154414801704, "sdist": 0.6945242568659772, "odist": 4.509485207497784, "iodist": 3.0168489943231287, "variance": 1.7226480894273448}, "output": {"SV": 0.14849446582168765, "OV": 0.14584708314933623, "IV": 0.12780426659878444, "OSV": 0.13965711604368428, "ISV": 0.14747854723642076, "OIV": 0.14431496428224452, "OISV": 0.14640355686784212}}, {"input": {"sfreq": 0.676929986673249, "ofreq": 2.0024839551435187, "iofreq": 2.4213346525667823, "sdist": 2.6334258435949605, "odist": 0.7145920511848795, "iodist": 2.6228363392051914, "variance": 1.8378607551597064}, "output": {"SV": 0.11227947731044322, "OV": 0.14054893666611198, "IV": 0.14872964331230096, "SOV": 0.1383480704065462, "SIV": 0.14431126627466442, "IOV": 0.1585894109852921, "SIOV": 0.15719319504464113}}, {"input": {"sfreq": 3.490007901391724, "ofreq": 4.874486450829595, "iofreq": 6.534118030403091, "sdist": 0.6952840281803826, "odist": 3.6748602684084846, "iodist": 3.0472422331699245, "variance": 1.2977437874247326}, "output": {"SV": 0.13773821109527512, "OV": 0.14419861166539097, "IV": 0.14761142377725045, "OSV": 0.14706353908466158, "ISV": 0.14706876103766053, "OIV": 0.14210177026460247, "OISV": 0.13421768307515883}}, {"input": {"sfreq": 9.915349562223682, "ofreq": 3.5820875275899007, "iofreq": 0.9279068991988922, "sdist": 2.9292853944067705, "odist": 1.839464495492143, "iodist": 3.6557839380216923, "variance": 0.41818317115098247}, "output": {"SV": 0.21250425154069277, "OV": 0.08626754348044241, "IV": 0.04668876536804291, "SOV": 0.21047085113015054, "ISV": 0.17494108923721183, "IOV": 0.07937778105606068, "ISOV": 0.18974971818739877}}, {"input": {"sfreq": 2.4066033467358676, "ofreq": 2.180518377694323, "iofreq": 2.896072562255207, "sdist": 2.7751500342297635, "odist": 4.542473742845384, "iodist": 3.5967586520794868, "variance": 1.0121557700533126}, "output": {"SV": 0.13625594122695048, "OV": 0.1323352789507432, "IV": 0.14375778744012763, "OSV": 0.1478887337714645, "ISV": 0.15076468103234825, "OIV": 0.15041580478500172, "OISV": 0.13858177279336414}}], "error_log": []}
{"context": "In a series of coin flip experiments, you are tasked with determining the average fraction of heads and the variability of this fraction across multiple trials. Given the number of coin flips per trial and the total number of trials, what is the mean fraction of heads and the standard deviation of this fraction?\n\nThe input and output requirements are as follows:\n\nInput:\n  `flips_per_trial` (int): The number of coin flips in each trial.\n  `trial_count` (int): The number of trials to perform.\n\nOutput:\n  `return` (dict): A dictionary containing the mean fraction of heads (`mean`) and the standard deviation of the fraction of heads (`standard_deviation`).", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef std_dev(X):\n    \"\"\"Assumes that X is a list of numbers.\n    Returns the standard deviation of X\"\"\"\n    mean = float(sum(X)) / len(X)\n    tot = 0.0\n    for x in X:\n        tot += (x - mean) ** 2\n    return (tot / len(X)) ** 0.5  # Square root of mean difference\n\ndef flip(flip_count):\n    heads = 0.0\n    for _ in range(flip_count):\n        if random.random() < 0.5:\n            heads += 1\n    return heads / flip_count\n\ndef flip_sim(flips_per_trial, trial_count):\n    heads_frac = []\n    for _ in range(trial_count):\n        heads_frac.append(flip(flips_per_trial))\n    mean = sum(heads_frac) / len(heads_frac)\n    sd = std_dev(heads_frac)\n    return (heads_frac, mean, sd)\n\n# main function\ndef main_solution(flips_per_trial, trial_count):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    heads_frac, mean, sd = flip_sim(flips_per_trial, trial_count)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"mean\": mean, \"standard_deviation\": sd}", "input_generator": "import random\n\ndef input_generator():\n    flips_per_trial = random.randint(10, 1000)\n    trial_count = random.randint(5, 100)\n    return {\"flips_per_trial\": flips_per_trial, \"trial_count\": trial_count}", "io_pairs": [{"input": {"flips_per_trial": 988, "trial_count": 29}, "output": {"mean": 0.5015705709898087, "standard_deviation": 0.017898963632443796}}, {"input": {"flips_per_trial": 536, "trial_count": 59}, "output": {"mean": 0.49879838097647355, "standard_deviation": 0.02162336285866529}}, {"input": {"flips_per_trial": 712, "trial_count": 12}, "output": {"mean": 0.49812734082397, "standard_deviation": 0.021077816824888452}}, {"input": {"flips_per_trial": 908, "trial_count": 29}, "output": {"mean": 0.5018988303205225, "standard_deviation": 0.01434168829794238}}, {"input": {"flips_per_trial": 551, "trial_count": 75}, "output": {"mean": 0.5014640048396852, "standard_deviation": 0.016751989268906586}}, {"input": {"flips_per_trial": 304, "trial_count": 92}, "output": {"mean": 0.5044693935926773, "standard_deviation": 0.028461165775882428}}, {"input": {"flips_per_trial": 53, "trial_count": 18}, "output": {"mean": 0.5031446540880502, "standard_deviation": 0.06860825229330637}}, {"input": {"flips_per_trial": 10, "trial_count": 11}, "output": {"mean": 0.5181818181818182, "standard_deviation": 0.10285189544531598}}, {"input": {"flips_per_trial": 235, "trial_count": 91}, "output": {"mean": 0.49333645078325933, "standard_deviation": 0.03466121387672157}}, {"input": {"flips_per_trial": 659, "trial_count": 72}, "output": {"mean": 0.5017914348339235, "standard_deviation": 0.023841670578052195}}], "error_log": []}
{"context": "Given a number `k`, what is the approximated square root of `k` using the Newton-Raphson method with a specified tolerance level `diff`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `k` (float): The number for which the square root is to be calculated.\n  `diff` (float): The tolerance level for the approximation of the square root.\n\nOutput:\n  `return` (dict): A dictionary containing the key `\"square_root\"` with the value being the approximated square root of `k`.", "reference_code": "# import necessary packages\n\n# main function\ndef main_solution(k, diff):\n    # Convert JSON serializable inputs to original input variables\n    k = float(k)\n    diff = float(diff)\n    \n    # Initial guess for the square root\n    guess = k - 1\n    \n    # Newton-Raphson method iteration\n    while abs(guess**2 - k) >= diff:\n        guess = guess - (((guess**2) - k) / (2 * guess))\n    \n    # Convert the output to JSON serializable format\n    return {\"square_root\": guess}", "input_generator": "import random\n\ndef input_generator():\n    k = random.uniform(1, 1000)  # Random positive number between 1 and 1000\n    diff = 10 ** random.uniform(-10, -1)  # Random small difference between 1e-10 and 0.1\n    return {\"k\": k, \"diff\": diff}", "io_pairs": [{"input": {"k": 313.35275542575215, "diff": 1.395208715416034e-09}, "output": {"square_root": 17.70177266338194}}, {"input": {"k": 182.61663672335095, "diff": 2.059204317137171e-08}, "output": {"square_root": 13.513572315392809}}, {"input": {"k": 726.4057877094654, "diff": 2.527933869720115e-06}, "output": {"square_root": 26.95191621591061}}, {"input": {"k": 298.87455327896794, "diff": 0.06597370739817443}, "output": {"square_root": 17.288000692041788}}, {"input": {"k": 482.90167246823324, "diff": 9.456221553036612e-07}, "output": {"square_root": 21.97502383630132}}, {"input": {"k": 870.905898020039, "diff": 0.002166163255137396}, "output": {"square_root": 29.511116499397403}}, {"input": {"k": 66.6842349758618, "diff": 3.1277636394608857e-06}, "output": {"square_root": 8.166041573238848}}, {"input": {"k": 279.96650692550344, "diff": 0.013884136006769595}, "output": {"square_root": 16.732206752507512}}, {"input": {"k": 266.98872788377884, "diff": 8.502232489129957e-06}, "output": {"square_root": 16.339789713573467}}, {"input": {"k": 441.8253060680734, "diff": 0.006344089718896852}, "output": {"square_root": 21.01964096057279}}], "error_log": []}
{"context": "Given a graph represented by an adjacency matrix, where each element indicates the number of edges between two nodes, how can we determine the shift matrix that represents the coin states of the nodes in the graph? Specifically, what is the shift matrix for the given adjacency matrix?\n\nThe input and output requirements are as follows:\n\nInput:\n  `adj` (list of lists of integers): A 2D adjacency matrix representing the graph. Each element `adj[i][j]` represents the number of edges between node `i` and node `j`.\n\nOutput:\n  `return` (list of lists of integers): A 2D shift matrix representing the coin states of the nodes in the graph. Each element `shift_matrix[i][j]` is either `0` or `1`, indicating whether there is a shift from coin state `i` to coin state `j`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef finddegrees(adj):\n    degrees = [0 for i in range(len(adj))]\n    for i in range(len(adj)):\n        number = 0\n        for j in range(len(adj[i])):\n            number += adj[i][j]\n        list = [0 for k in range(int(number))]\n        number2 = 0\n        for j in range(len(adj[i])):\n            if adj[i][j] != 0:\n                for s in range(int(adj[i][j])):\n                    list[number2] = j\n                    number2 += 1\n        degrees[i] = list\n    return degrees\n\ndef firstnode(degree):\n    number = 0\n    array = [0 for i in range(len(degree))]\n    for i in range(len(degree)):\n        array[i] = number\n        number += len(degree[i]) \n    return array\n\ndef forcoinstate(degree, i, j):\n    number = 0\n    number2 = 0\n    for k in range(len(degree[i])):\n        if number2 == 0:\n            if degree[i][k] != j:\n                number += 1\n            else:\n                number2 = 1\n    if number == len(degree[i]):\n        return 'no link between nodes i and j'\n    else:\n        return number\n\ndef createshift(adj):\n    degree = finddegrees(adj)\n    nodeindex = firstnode(degree)\n    size = nodeindex[len(adj)-1] + len(degree[len(adj)-1])\n    degree2 = [[0] for i in range(len(degree))]\n    for i in range(len(degree)):\n        degree2[i] = list(set(degree[i]))\n    array = np.zeros((size, size), dtype=int)\n    for i in range(len(degree)):\n        index1 = nodeindex[i]\n        number = 0\n        for j in range(len(degree2[i])):\n            nolinks = adj[degree2[i][j]][i]\n            number = forcoinstate(degree, i, degree[i][j])\n            coinstate1 = index1 + number\n            node = degree[i][j]\n            for k in range(len(degree2[node])):\n                if degree2[node][k] == i:\n                    coinstate2 = nodeindex[node] + forcoinstate(degree, node, i)\n            for k in range(int(nolinks)):\n                array[coinstate1 + k][coinstate2 + k] = 1\n    for i in range(len(array)):\n        for j in range(len(array)):\n            if array[i][j] == 1:\n                array[j][i] = 1\n    return array\n\n# main function\ndef main_solution(adj):\n    # Convert input to numpy array if it's not already\n    adj = np.array(adj)\n    # Call the createshift function to get the shift matrix\n    shift_matrix = createshift(adj)\n    # Convert the numpy array to a list of lists for JSON serialization\n    shift_matrix = shift_matrix.tolist()\n    return shift_matrix", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    n = random.randint(2, 5)  # Small matrix size for reasonable input\n    adj = np.zeros((n, n), dtype=int)\n    \n    for i in range(n):\n        for j in range(i, n):\n            if i == j:\n                adj[i][j] = 0  # No self-loops\n            else:\n                val = random.choice([0, 1, 1])  # Higher chance for 1 to ensure some edges\n                adj[i][j] = val\n                adj[j][i] = val  # Symmetric matrix\n    \n    return {'adj': adj.tolist()}", "io_pairs": [{"input": {"adj": [[0, 1, 0], [1, 0, 1], [0, 1, 0]]}, "output": [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]}, {"input": {"adj": [[0, 1], [1, 0]]}, "output": [[0, 1], [1, 0]]}, {"input": {"adj": [[0, 1, 1], [1, 0, 0], [1, 0, 0]]}, "output": [[0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 1, 0, 0]]}, {"input": {"adj": [[0, 1, 1], [1, 0, 1], [1, 1, 0]]}, "output": [[0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0]]}, {"input": {"adj": [[0, 0], [0, 0]]}, "output": []}, {"input": {"adj": [[0, 0, 0], [0, 0, 1], [0, 1, 0]]}, "output": [[0, 1], [1, 0]]}, {"input": {"adj": [[0, 1, 0, 1], [1, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0]]}, "output": [[0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 1, 0, 0]]}, {"input": {"adj": [[0, 0, 1, 0], [0, 0, 1, 1], [1, 1, 0, 0], [0, 1, 0, 0]]}, "output": [[0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0]]}, {"input": {"adj": [[0, 0, 1], [0, 0, 1], [1, 1, 0]]}, "output": [[0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 1, 0, 0]]}, {"input": {"adj": [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]}, "output": [[0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0]]}], "error_log": []}
{"context": "Given a Hilbert curve defined by the number of iterations `p` and the number of dimensions `N`, what is the original Hilbert distance `h` after converting it to N-dimensional coordinates and then back to the Hilbert distance?\n\nThe input and output requirements are as follows:\n\nInput:\n  `h` (int): The integer distance along the Hilbert curve.\n  `p` (int): The number of iterations in the Hilbert curve.\n  `N` (int): The number of dimensions.\n\nOutput:\n  `return` (int): The original Hilbert distance after converting to coordinates and back.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef _binary_repr(num, width):\n    \"\"\"Return a binary string representation of `num` zero padded to `width`\n    bits.\"\"\"\n    return format(num, 'b').zfill(width)\n\ndef _hilbert_integer_to_transpose(h, p, N):\n    \"\"\"Store a hilbert integer (`h`) as its transpose (`x`).\n\n    :param h: integer distance along hilbert curve\n    :type h: ``int``\n    :param p: number of iterations in Hilbert curve\n    :type p: ``int``\n    :param N: number of dimensions\n    :type N: ``int``\n    \"\"\"\n    h_bit_str = _binary_repr(h, p*N)\n    x = [int(h_bit_str[i::N], 2) for i in range(N)]\n    return x\n\ndef _transpose_to_hilbert_integer(x, p, N):\n    \"\"\"Restore a hilbert integer (`h`) from its transpose (`x`).\n\n    :param x: the transpose of a hilbert integer (N components of length p)\n    :type x: ``list`` of ``int``\n    :param p: number of iterations in hilbert curve\n    :type p: ``int``\n    :param N: number of dimensions\n    :type N: ``int``\n    \"\"\"\n    x_bit_str = [_binary_repr(x[i], p) for i in range(N)]\n    h = int(''.join([y[i] for i in range(p) for y in x_bit_str]), 2)\n    return h\n\ndef coordinates_from_distance(h, p, N):\n    \"\"\"Return the coordinates for a given hilbert distance.\n\n    :param h: integer distance along the curve\n    :type h: ``int``\n    :param p: side length of hypercube is 2^p\n    :type p: ``int``\n    :param N: number of dimensions\n    :type N: ``int``\n    \"\"\"\n    x = _hilbert_integer_to_transpose(h, p, N)\n    Z = 2 << (p-1)\n\n    # Gray decode by H ^ (H/2)\n    t = x[N-1] >> 1\n    for i in range(N-1, 0, -1):\n        x[i] ^= x[i-1]\n    x[0] ^= t\n\n    # Undo excess work\n    Q = 2\n    while Q != Z:\n        P = Q - 1\n        for i in range(N-1, -1, -1):\n            if x[i] & Q:\n                # invert\n                x[0] ^= P\n            else:\n                # excchange\n                t = (x[0] ^ x[i]) & P\n                x[0] ^= t\n                x[i] ^= t\n        Q <<= 1\n\n    # done\n    return x\n\ndef distance_from_coordinates(x, p, N):\n    \"\"\"Return the hilbert distance for a given set of coordinates.\n\n    :param x: coordinates len(x) = N\n    :type x: ``list`` of ``int``\n    :param p: side length of hypercube is 2^p\n    :type p: ``int``\n    :param N: number of dimensions\n    :type N: ``int``\n    \"\"\"\n    M = 1 << (p - 1)\n\n    # Inverse undo excess work\n    Q = M\n    while Q > 1:\n        P = Q - 1\n        for i in range(N):\n            if x[i] & Q:\n                x[0] ^= P\n            else:\n                t = (x[0] ^ x[i]) & P\n                x[0] ^= t\n                x[i] ^= t\n        Q >>= 1\n\n    # Gray encode\n    for i in range(1, N):\n        x[i] ^= x[i-1]\n    t = 0\n    Q = M\n    while Q > 1:\n        if x[N-1] & Q:\n            t ^= Q - 1\n        Q >>= 1\n    for i in range(N):\n        x[i] ^= t\n\n    h = _transpose_to_hilbert_integer(x, p, N)\n    return h\n\n# main function\ndef main_solution(h, p, N):\n    \"\"\"\n    Convert a Hilbert distance to N-dimensional coordinates and then back to the Hilbert distance.\n\n    :param h: integer distance along the Hilbert curve\n    :type h: ``int``\n    :param p: number of iterations in Hilbert curve\n    :type p: ``int``\n    :param N: number of dimensions\n    :type N: ``int``\n    :return: the original Hilbert distance after conversion\n    :rtype: ``int``\n    \"\"\"\n    # Convert Hilbert distance to coordinates\n    coordinates = coordinates_from_distance(h, p, N)\n    \n    # Convert coordinates back to Hilbert distance\n    h_converted = distance_from_coordinates(coordinates, p, N)\n    \n    return h_converted", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    # Generate reasonable values for p (iterations) and N (dimensions)\n    p = random.randint(1, 5)  # Keeps the hypercube side length (2^p) manageable\n    N = random.randint(2, 5)   # 2 to 5 dimensions\n    \n    # Maximum possible h value is (2^(p*N)) - 1\n    max_h = (1 << (p * N)) - 1\n    # Generate h within a reasonable range, avoiding edge cases sometimes\n    if random.random() < 0.8:\n        h = random.randint(0, max_h)\n    else:\n        h = random.choice([0, max_h // 2, max_h])\n    \n    return {'h': h, 'p': p, 'N': N}", "io_pairs": [{"input": {"h": 29, "p": 3, "N": 2}, "output": 29}, {"input": {"h": 6666, "p": 3, "N": 5}, "output": 6666}, {"input": {"h": 941, "p": 2, "N": 5}, "output": 941}, {"input": {"h": 1521, "p": 4, "N": 3}, "output": 1521}, {"input": {"h": 43, "p": 3, "N": 2}, "output": 43}, {"input": {"h": 53, "p": 2, "N": 3}, "output": 53}, {"input": {"h": 3288, "p": 3, "N": 4}, "output": 3288}, {"input": {"h": 20, "p": 1, "N": 5}, "output": 20}, {"input": {"h": 13202008, "p": 5, "N": 5}, "output": 13202008}, {"input": {"h": 37, "p": 5, "N": 2}, "output": 37}], "error_log": []}
{"context": "Given a system's current state represented by a set of fluents, each describing a specific condition or relationship, how can we determine if a particular fluent holds true within this state? Specifically, what is the result of checking if a given fluent is present in the current state?\n\nThe input and output requirements are as follows:\n\nInput:\n  `state` (Set[Tuple]): A set of tuples representing the current state of the system. Each tuple represents a fluent and its arguments.\n  `fluent` (Tuple): A tuple representing the fluent to be checked in the state.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the given fluent holds in the current state.", "reference_code": "# import necessary packages\nfrom typing import Optional, Set, Tuple, Dict\nimport random\n\n# all class and function definitions in the code file, if any\ndef fluent_holds_at(state: Set[Tuple], fluent: Tuple) -> bool:\n    return fluent in state\n\ndef fluent_to_string(fluent: Tuple) -> str:\n    arguments_str = \"\"\n    if len(fluent) > 1:\n        arguments_str = \"(\" + \", \".join([str(x) for x in fluent[1:]]) + \")\"\n    return \"{}{}\".format(fluent[0], arguments_str)\n\ndef unify(expression1: Tuple, expression2: Tuple) -> Tuple[bool, Optional[dict], Optional[dict]]:\n    if expression1[0] != expression2[0]:\n        return False, None, None\n    binding1 = {}\n    binding2 = {}\n    for v1, v2 in zip(expression1[1:], expression2[1:]):\n        success, d1, d2 = unify_helper(v1, v2)\n        if not success:\n            return False, None, None\n        if d1:\n            d1 = merge_variable_bindings(binding1, d1)\n            if d1 is None:\n                return False, None, None\n            binding1 = d1\n        if d2:\n            d2 = merge_variable_bindings(binding2, d2)\n            if d2 is None:\n                return False, None, None\n            binding2 = d2\n    if not binding1:\n        binding1 = None\n    if not binding2:\n        binding2 = None\n    return True, binding1, binding2\n\ndef unify_helper(val1, val2) -> Tuple[bool, Optional[dict], Optional[dict]]:\n    is_val1_str = type(val1) == str\n    is_val2_str = type(val2) == str\n    is_val1_var = is_val1_str and val1.startswith('$')\n    is_val2_var = is_val2_str and val2.startswith('$')\n\n    if is_val1_var and is_val2_var:\n        return True, None, None\n    elif is_val1_var:\n        return True, {val1: val2}, None\n    elif is_val2_var:\n        return True, None, {val2: val1}\n    else:\n        return val1 == val2, None, None\n\ndef merge_variable_bindings(d1: Dict, d2: Dict) -> Optional[dict]:\n    return (None if any(d1[k] != d2[k] for k in d1.keys() & d2) else {\n        **d1,\n        **d2\n    })\n\ndef apply_binding(expression: Tuple, binding: dict) -> Tuple:\n    bind = list(expression)\n    binding_key = list(binding.keys())\n    binding_value = list(binding.values())\n    for i in bind:\n        if type(i) is tuple:\n            original = i\n            original = list(original)\n            for j in range(len(binding_key)):\n                if binding_key[j] in i:\n                    for a in range(len(original)):\n                        if original[a] == binding_key[j]:\n                            original[a] = binding_value[j]\n            for q in range(len(bind)):\n                if bind[q] == i:\n                    bind[q] = tuple(original)\n    for i in range(len(bind)):\n        if bind[i] in binding_key:\n            name = str(bind[i])\n            bind[i] = binding[name]\n\n    return tuple(bind)\n\ndef apply_binding_to_set_of_fluents(expressions: Optional[Set[Tuple]], binding: Dict) -> Optional[Set[Tuple]]:\n    if not expressions:\n        return None\n    else:\n        binded_expressions = set()\n        for expression in expressions:\n            binded_expressions.add(apply_binding(expression, binding))\n        return binded_expressions\n\n# main function\ndef main_solution(state: Set[Tuple], fluent: Tuple) -> bool:\n    # Convert JSON serializable inputs to original input variables\n    state = set(state)\n    fluent = tuple(fluent)\n    \n    # Core solution logic\n    result = fluent_holds_at(state, fluent)\n    \n    # Convert output to JSON serializable format\n    return result", "input_generator": "import random\nfrom typing import Set, Tuple\n\ndef input_generator():\n    # Define possible predicates and variables\n    predicates = ['on', 'at', 'color', 'size', 'has', 'near', 'inside']\n    objects = ['box', 'table', 'ball', 'cup', 'book', 'pen', 'chair', 'desk']\n    variables = ['$x', '$y', '$z']\n    \n    # Randomly decide the size of the state (between 1 and 10 fluents)\n    state_size = random.randint(1, 10)\n    state = set()\n    \n    for _ in range(state_size):\n        # Randomly choose a predicate\n        pred = random.choice(predicates)\n        # Randomly decide the number of arguments (1 or 2)\n        num_args = random.choice([1, 2])\n        args = []\n        for _ in range(num_args):\n            # Randomly choose between an object or a variable\n            if random.random() < 0.3:\n                args.append(random.choice(variables))\n            else:\n                args.append(random.choice(objects))\n        fluent = (pred,) + tuple(args)\n        state.add(fluent)\n    \n    # Generate the fluent to check (50% chance to be in state, 50% not)\n    if random.random() < 0.5 and len(state) > 0:\n        # Pick a fluent from the state\n        fluent = random.choice(list(state))\n    else:\n        # Create a new fluent not in state\n        pred = random.choice(predicates)\n        num_args = random.choice([1, 2])\n        args = []\n        for _ in range(num_args):\n            if random.random() < 0.3:\n                args.append(random.choice(variables))\n            else:\n                args.append(random.choice(objects))\n        fluent = (pred,) + tuple(args)\n    \n    return {\n        'state': state,\n        'fluent': fluent\n    }", "io_pairs": [], "error_log": ["STDERR: Traceback (most recent call last):\n  File \"<string>\", line 215, in <module>\n  File \"C:\\Users\\ovane\\miniconda3\\envs\\dl2-code-io\\Lib\\json\\__init__.py\", line 231, in dumps\n    return _default_encoder.encode(obj)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\ovane\\miniconda3\\envs\\dl2-code-io\\Lib\\json\\encoder.py\", line 200, in encode\n    chunks = self.iterencode(o, _one_shot=True)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\ovane\\miniconda3\\envs\\dl2-code-io\\Lib\\json\\encoder.py\", line 258, in iterencode\n    return _iterencode(o, 0)\n           ^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\ovane\\miniconda3\\envs\\dl2-code-io\\Lib\\json\\encoder.py\", line 180, in default\n    raise TypeError(f'Object of type {o.__class__.__name__} '\nTypeError: Object of type set is not JSON serializable\n"]}
{"context": "Given a positive number, how can we determine the difference between the square root calculated using a custom iterative method and the square root calculated using a standard mathematical function? Specifically, what is the difference between the square root of the number calculated using the custom method and the square root calculated using the `math.sqrt` function in Python?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a` (float): A positive number for which the square root is to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `mysqrt` (float): The square root of `a` calculated using the `mysqrt` function.\n    - `math_sqrt` (float): The square root of `a` calculated using `math.sqrt`.\n    - `difference` (float): The absolute difference between the two square root values.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef mysqrt(a, x):\n    while True:\n        y = (x + a / x) / 2\n        if y == x:\n            return y\n        x = y\n\ndef factorial(n):\n    \"\"\"Computes factorial of n recursively.\"\"\"\n    if n == 0:\n        return 1\n    else:\n        result = n * factorial(n - 1)\n    return result\n\ndef estimate_pi():\n    e = 1e-15\n    c = (2 * math.sqrt(2)) / 9801\n    k = 0\n    total = 0\n    while True:\n        num = factorial(4 * k) * (1103 + 26390 * k)\n        den = factorial(k) ** 4 * 396 ** (4 * k)\n        term = c * num / den\n        total += term\n        mpi = 1 / total\n        if abs(mpi - math.pi) < e:\n            break\n        k += 1\n    return mpi\n\n# main function\ndef main_solution(a):\n    # Convert input to JSON serializable format if necessary\n    a = float(a)\n    \n    # Calculate the square root using mysqrt function\n    sqrt_value = mysqrt(a, 5)\n    \n    # Calculate the difference between mysqrt and math.sqrt\n    diff = abs(sqrt_value - math.sqrt(a))\n    \n    # Return the result as a dictionary\n    return {\"mysqrt\": sqrt_value, \"math_sqrt\": math.sqrt(a), \"difference\": diff}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random positive float, sometimes an integer, sometimes a small number, sometimes larger\n    if random.random() < 0.5:\n        a = random.uniform(0.1, 100.0)\n    else:\n        a = random.randint(1, 1000)\n    return {\"a\": a}", "io_pairs": [{"input": {"a": 579}, "output": {"mysqrt": 24.062418831031927, "math_sqrt": 24.06241883103193, "difference": 3.552713678800501e-15}}, {"input": {"a": 739}, "output": {"mysqrt": 27.184554438136374, "math_sqrt": 27.184554438136374, "difference": 0.0}}, {"input": {"a": 42.48096425448912}, "output": {"mysqrt": 6.517742266651016, "math_sqrt": 6.517742266651016, "difference": 0.0}}, {"input": {"a": 518}, "output": {"mysqrt": 22.759613353482084, "math_sqrt": 22.759613353482084, "difference": 0.0}}, {"input": {"a": 459}, "output": {"mysqrt": 21.42428528562855, "math_sqrt": 21.42428528562855, "difference": 0.0}}, {"input": {"a": 340}, "output": {"mysqrt": 18.439088914585774, "math_sqrt": 18.439088914585774, "difference": 0.0}}, {"input": {"a": 456}, "output": {"mysqrt": 21.354156504062622, "math_sqrt": 21.354156504062622, "difference": 0.0}}, {"input": {"a": 553}, "output": {"mysqrt": 23.515952032609697, "math_sqrt": 23.515952032609693, "difference": 3.552713678800501e-15}}, {"input": {"a": 536}, "output": {"mysqrt": 23.15167380558045, "math_sqrt": 23.15167380558045, "difference": 0.0}}, {"input": {"a": 39.59111117415349}, "output": {"mysqrt": 6.292146785807963, "math_sqrt": 6.292146785807963, "difference": 0.0}}], "error_log": []}
{"context": "Given a list of integers, how can we identify and separate the prime numbers from those that have exactly `k` proper divisors, where `k` is a non-negative integer? Specifically, what are the prime numbers and the numbers with exactly `k` proper divisors in the given list?\n\nThe input and output requirements are as follows:\n\nInput:\n  `ls` (list of strings): A list of strings where each string represents an integer.\n  `k` (string): A string representing a non-negative integer.\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `primes` (list of int): A list of integers that are prime numbers from the input list `ls`.\n    - `filtered_ls` (list of int): A list of integers from the input list `ls` that have exactly `k` proper divisors.", "reference_code": "# import necessary packages\nfrom math import sqrt\n\n# main function\ndef main_solution(ls, k):\n    # Convert input list to a list of integers\n    ls = [int(x) for x in ls]\n    k = int(k)\n    \n    # Function to find proper divisors count\n    def proper_divisors_count(n):\n        count = 0\n        for x in range(2, int(sqrt(n)) + 1):\n            if n % x == 0:\n                if n // x != x:\n                    count += 1\n                count += 1\n        return count\n    \n    # Lists to store prime numbers and numbers with exactly k proper divisors\n    primes = []\n    filtered_ls = []\n    \n    for num in ls:\n        div_count = proper_divisors_count(num)\n        if div_count == 0:\n            primes.append(num)\n        if div_count == k:\n            filtered_ls.append(num)\n    \n    # Update the original list with numbers having exactly k proper divisors\n    ls.clear()\n    ls.extend(filtered_ls)\n    \n    # Return the list of prime numbers and the updated list\n    return {\"primes\": primes, \"filtered_ls\": filtered_ls}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random list length between 5 and 20\n    list_length = random.randint(5, 20)\n    \n    # Generate a list of random integers between 2 and 100\n    ls = [random.randint(2, 100) for _ in range(list_length)]\n    \n    # Generate a random k between 1 and 5\n    k = random.randint(1, 5)\n    \n    return {\"ls\": ls, \"k\": k}", "io_pairs": [{"input": {"ls": [75, 87, 85, 95, 31, 81, 32, 54, 52, 95, 52, 99, 58], "k": 2}, "output": {"primes": [31], "filtered_ls": [87, 85, 95, 95, 58]}}, {"input": {"ls": [47, 52, 96, 37, 19, 33, 2, 64, 44, 33, 17, 34, 75, 49, 57], "k": 3}, "output": {"primes": [47, 37, 19, 2, 17], "filtered_ls": []}}, {"input": {"ls": [14, 94, 13, 35, 89, 94, 52], "k": 5}, "output": {"primes": [13, 89], "filtered_ls": []}}, {"input": {"ls": [36, 93, 88, 40, 60, 56, 54, 80, 62, 78, 42, 79, 12], "k": 2}, "output": {"primes": [79], "filtered_ls": [93, 62]}}, {"input": {"ls": [29, 22, 58, 38, 20, 77, 18, 93, 95, 94, 34, 24], "k": 2}, "output": {"primes": [29], "filtered_ls": [22, 58, 38, 77, 93, 95, 94, 34]}}, {"input": {"ls": [5, 7, 91, 54, 87, 40, 47, 68, 48, 17, 53, 24, 92, 6, 10, 42], "k": 5}, "output": {"primes": [5, 7, 47, 17, 53], "filtered_ls": []}}, {"input": {"ls": [74, 40, 9, 89, 94, 49, 51, 9, 27, 43, 31, 50, 29], "k": 4}, "output": {"primes": [89, 43, 31, 29], "filtered_ls": [50]}}, {"input": {"ls": [78, 27, 73, 36, 31, 54, 80, 49, 8, 45, 48, 43, 56], "k": 1}, "output": {"primes": [73, 31, 43], "filtered_ls": [49]}}, {"input": {"ls": [6, 61, 22, 20, 32, 24, 79, 46, 38, 95], "k": 1}, "output": {"primes": [61, 79], "filtered_ls": []}}, {"input": {"ls": [47, 74, 26, 30, 62], "k": 2}, "output": {"primes": [47], "filtered_ls": [74, 26, 62]}}], "error_log": []}
{"context": "Given a mathematical function and an interval over which to integrate, what is the numerical approximation of the integral using Simpson's rule? The function is provided as a string, and the interval is defined by two endpoints `x1` and `x2`. The number of sub-intervals to use in the integration is also specified.\n\nThe input and output requirements are as follows:\n\nInput:\n  `function_str` (str): A string representation of a mathematical function with one variable 'x'. For example, \"x**2 + 3*x + 2\".\n  `x1` (float): The starting value of the interval for integration (left endpoint).\n  `x2` (float): The ending value of the interval for integration (right endpoint).\n  `intervals` (int): The number of sub-intervals to use with Simpson's rule. Default is 1 sub-interval.\n\nOutput:\n  `return` (float): The numerical approximation to the integral of the function from `x1` to `x2` using Simpson's rule.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef integrate(fun, x1, x2, intervals=1):\n    \"\"\"Compute the integral of fun from x1 to x2 using Simpson's rule.\n\n    Arguments:\n        fun - a function with one real argument that returns a real value.\n        x1  - starting value of interval for integration (left endpoint)\n        x2  - ending value for interval for integration (right endpoint)\n        intervals - number of sub-intervals to use with Simpson's rule.\n              Default is 1 sub-interval.\n    Returns:\n        (float) numerical approximation to the integral of fun from x1 to x2.\n    \"\"\"\n    # Placeholder implementation for Simpson's rule\n    h = (x2 - x1) / intervals\n    sum_val = fun(x1) + fun(x2)\n    for i in range(1, intervals, 2):\n        sum_val += 4 * fun(x1 + i * h)\n    for i in range(2, intervals-1, 2):\n        sum_val += 2 * fun(x1 + i * h)\n    return sum_val * h / 3\n\n# main function\ndef main_solution(function_str, x1, x2, intervals=1):\n    # Convert the function string to a callable function\n    fun = eval(f\"lambda x: {function_str}\")\n    \n    # Compute the integral using the integrate function\n    result = integrate(fun, x1, x2, intervals)\n    \n    # Return the result as a float\n    return result", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random function from a set of common mathematical expressions\n    functions = [\n        \"x**2\",\n        \"math.sin(x)\",\n        \"math.cos(x)\",\n        \"math.exp(x)\",\n        \"math.log(abs(x) + 1)\",\n        \"x**3 - 2*x + 1\",\n        \"1 / (1 + x**2)\"\n    ]\n    function_str = random.choice(functions)\n    \n    # Generate random x1 and x2, ensuring x1 < x2\n    x1 = random.uniform(-10, 10)\n    x2 = random.uniform(x1, x1 + random.uniform(1, 20))\n    \n    # Generate a reasonable number of intervals (1 to 100)\n    intervals = random.randint(1, 100)\n    \n    return {\n        \"function_str\": function_str,\n        \"x1\": x1,\n        \"x2\": x2,\n        \"intervals\": intervals\n    }", "io_pairs": [{"input": {"function_str": "x**2", "x1": -2.4291305832250387, "x2": 10.15051923721515, "intervals": 34}, "output": 353.39079120336004}, {"input": {"function_str": "math.exp(x)", "x1": -3.8440845688526304, "x2": -1.6690238068846295, "intervals": 17}, "output": 0.14536010631940138}, {"input": {"function_str": "math.cos(x)", "x1": 1.3681190418441638, "x2": 16.818422893388508, "intervals": 26}, "output": -1.8767900828024457}, {"input": {"function_str": "math.log(abs(x) + 1)", "x1": 7.607571875217701, "x2": 11.838992646521792, "intervals": 6}, "output": 10.010913002227634}, {"input": {"function_str": "x**2", "x1": -5.419014141677083, "x2": -4.1822410010702304, "intervals": 9}, "output": 26.12337445694874}, {"input": {"function_str": "x**3 - 2*x + 1", "x1": 0.9165695807365264, "x2": 7.183606004434718, "intervals": 17}, "output": 505.94002530422836}, {"input": {"function_str": "x**3 - 2*x + 1", "x1": -3.607438587208125, "x2": 11.696160763286137, "intervals": 71}, "output": 4203.277916081185}, {"input": {"function_str": "math.exp(x)", "x1": -3.2752063550019734, "x2": -1.101149077187257, "intervals": 67}, "output": 0.2841789262625961}, {"input": {"function_str": "math.exp(x)", "x1": 7.879411280253532, "x2": 10.540259312533385, "intervals": 8}, "output": 35167.41235073169}, {"input": {"function_str": "math.log(abs(x) + 1)", "x1": -3.478121105086154, "x2": 4.333157038023184, "intervals": 96}, "output": 7.829349743478396}], "error_log": []}
{"context": "In a biological ecosystem, each species has a maximum of one direct predator, and this predator relationship can be inherited. Given the predator relationships among a set of species, how many groups can be formed such that no species is grouped with its direct or indirect predator?\n\nThe input and output requirements are as follows:\n\nInput:\n  `predator_list` (list of integers): A list where each element at index `i` represents the index of the direct predator of species `i`. If a species has no predator, the value is `-1`.\n\nOutput:\n  `return` (integer): The minimum number of groups required such that no species is grouped with its direct or indirect predator.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    def __init__(self, value):\n        self.value = value\n        self.parent = None\n        self.children = []\n    \n    # assume node is root\n    def tree_height(self):\n        if len(self.children) == 0:\n            return 1\n        max_height = 0\n        for child in self.children:\n            if child.tree_height() > max_height:\n                max_height = child.tree_height()\n        return 1 + max_height\n\ndef minimum_groups(arr):\n    nodes_map = {}\n    for idx, ele in enumerate(arr):\n        if idx not in nodes_map:\n            node = Node(idx)\n            nodes_map[idx] = node\n        else:\n            node = nodes_map.get(idx)\n        if ele == -1:\n            continue\n        if ele not in nodes_map:\n            parent_node = Node(ele)\n            nodes_map[ele] = parent_node\n        else:\n            parent_node = nodes_map.get(ele)\n        node.parent = parent_node\n        parent_node.children.append(node)\n\n    root_list = []\n    for node in nodes_map.values():\n        if node.parent is None:\n            root_list.append(node)\n\n    max_height = 0\n    for root in root_list:\n        if root.tree_height() > max_height:\n            max_height = root.tree_height()\n    return max_height\n\n# main function\ndef main_solution(predator_list):\n    # Convert the input list to a JSON serializable format\n    predator_list = list(predator_list)\n    \n    # Call the minimum_groups function\n    result = minimum_groups(predator_list)\n    \n    # Return the result as a JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Randomly decide the size of the predator list (between 5 and 20)\n    size = random.randint(5, 20)\n    predator_list = []\n    \n    # Generate a valid predator list where each element is either -1 or points to a valid index\n    for i in range(size):\n        # The root nodes (no predator) should have -1\n        if i == 0:\n            predator_list.append(-1)\n        else:\n            # Randomly decide if this node is a root or has a predator\n            if random.random() < 0.3:  # 30% chance to be a root\n                predator_list.append(-1)\n            else:\n                # The predator must be an existing index (0 <= predator < i)\n                predator_list.append(random.randint(0, i - 1))\n    \n    return {'predator_list': predator_list}", "io_pairs": [{"input": {"predator_list": [-1, -1, 1, 2, -1, 1, -1, -1, 1]}, "output": 3}, {"input": {"predator_list": [-1, -1, 0, 2, 3, -1, 2, -1, -1]}, "output": 4}, {"input": {"predator_list": [-1, 0, -1, -1, -1, -1, 2, 0, -1, 8, -1, 3, 1, -1, 13, -1, 2, 9, 13]}, "output": 3}, {"input": {"predator_list": [-1, -1, -1, 2, 0, 4, 4, 0, 6, 7, 4, 5, 6, -1, -1, 8, 4, 9]}, "output": 5}, {"input": {"predator_list": [-1, 0, -1, 0, 0, -1, 4, 5, -1, -1, 2, 7, -1, -1, 10, 13, 15, -1]}, "output": 3}, {"input": {"predator_list": [-1, 0, 0, 0, -1, -1]}, "output": 2}, {"input": {"predator_list": [-1, 0, 1, 0, 2, 1, 2]}, "output": 4}, {"input": {"predator_list": [-1, 0, -1, 1, -1, -1, 2, 4]}, "output": 3}, {"input": {"predator_list": [-1, 0, 1, -1, 1, 2, 3, 0, 3, -1, 1, -1, 10, 5, 5, 6, 3, 13]}, "output": 6}, {"input": {"predator_list": [-1, 0, 1, 2, 1, 3, -1]}, "output": 5}], "error_log": []}
{"context": "Given a dataset generated from a sinusoidal function with added noise, how can we determine the error and the coefficients of a polynomial regression model fitted to this data for a specified degree of the polynomial?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number_of_data` (int): The number of data points to generate for training.\n  `degree` (int): The degree of the polynomial to fit.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `error` (float): The calculated error between the predicted values and the actual values.\n    - `coefficients` (list of float): The coefficients of the polynomial fit.", "reference_code": "# import necessary packages\nimport random\nimport numpy as np\nimport math\n\n# all class and function definitions in the code file, if any\ndef mle_matrix_calculation_moorse(degree, x, y):\n    \"\"\"\n    :param degree: degree of the fitting polynomial\n    :param x:\n    :param y:\n    :return: coefficients\n    \"\"\"\n    matrix = []\n    row = []\n    for a in x:\n        for n in range(degree+1):\n            row.append(pow(a,n))\n        matrix.append(row)\n        row = []\n    fmatrix = np.linalg.pinv(matrix)\n    coeficients = np.dot(fmatrix, y)\n    return coeficients\n\ndef generate_training_data(numberofdata):\n    \"\"\"\n    This function generates random data for the training data\n    :param numberofdata: Number of points\n    :return: The training data generated\n    \"\"\"\n    x = []\n    y = []\n    for i in range(0, numberofdata):\n        x.append(random.uniform(0, 6))\n    x.sort()\n    noise = np.random.normal(0, 0.1, numberofdata)\n    pure = np.sin(x)\n    y = pure + noise\n    return x,y\n\ndef make_predictions(x,coef):\n    \"\"\"\n    Makes predictions for new data points\n    :param x: new data point\n    :param coef: coefficients of the predicted function\n    :return: predicted value\n    \"\"\"\n    w = []\n    for ix in range(len(x)):\n        q = 0\n        count = 0\n        for a in coef:\n            q = q + a*x[ix]**count\n            count = count + 1\n        w.append(q)\n    return w\n\ndef calculate_error(y,w):\n    \"\"\"\n    Calculates the error\n    :param y: target value\n    :param w: predicted value\n    :return: error\n    \"\"\"\n    n = len(y)\n    error = 0\n    for i in range(len(y)):\n        a = (y[i]-w[i])\n        error = error + pow(a,2)\n    return error\n\n# main function\ndef main_solution(number_of_data, degree):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    x, y = generate_training_data(number_of_data)\n    coef = mle_matrix_calculation_moorse(degree, x, y)\n    w = make_predictions(x, coef)\n    error = calculate_error(y, w)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"error\": error, \"coefficients\": coef.tolist()}", "input_generator": "import random\n\ndef input_generator():\n    number_of_data = random.randint(10, 100)\n    degree = random.randint(1, 5)\n    return {\"number_of_data\": number_of_data, \"degree\": degree}", "io_pairs": [{"input": {"number_of_data": 97, "degree": 2}, "output": {"error": 14.975812727851531, "coefficients": [0.7047599405089352, -0.1106909931777418, -0.033613802334030204]}}, {"input": {"number_of_data": 13, "degree": 4}, "output": {"error": 0.05278900548345397, "coefficients": [-0.14746339603955833, 1.5366773272234004, -0.5602156313646975, 0.0031951901577950146, 0.008039854050562721]}}, {"input": {"number_of_data": 65, "degree": 4}, "output": {"error": 0.7860884941949494, "coefficients": [-0.15011729045864336, 1.8193549138325174, -0.8170309442431348, 0.07446009747675555, 0.001806160705446395]}}, {"input": {"number_of_data": 89, "degree": 2}, "output": {"error": 15.967344175939395, "coefficients": [0.8720686708587021, -0.20610366566572325, -0.027527868864426572]}}, {"input": {"number_of_data": 85, "degree": 1}, "output": {"error": 14.149611419603044, "coefficients": [1.029550899141836, -0.31551593960614]}}, {"input": {"number_of_data": 87, "degree": 2}, "output": {"error": 14.859139592215625, "coefficients": [0.8712629431403074, -0.16666433441205952, -0.026053832323672622]}}, {"input": {"number_of_data": 70, "degree": 5}, "output": {"error": 0.7885422451610856, "coefficients": [0.1031954372542742, 0.2888098515805771, 0.8301230471578387, -0.591618619776769, 0.1161171948766394, -0.007016451931355647]}}, {"input": {"number_of_data": 94, "degree": 1}, "output": {"error": 15.651062538398735, "coefficients": [1.1477164923714536, -0.38339137372900167]}}, {"input": {"number_of_data": 12, "degree": 5}, "output": {"error": 0.048379640955678066, "coefficients": [0.08596037367238718, 0.9562049402458475, -0.033549558371805066, -0.23145493698484976, 0.0554210597525141, -0.003412118832656212]}}, {"input": {"number_of_data": 97, "degree": 4}, "output": {"error": 1.1801807259730737, "coefficients": [-0.14184300815843265, 1.7005104372109903, -0.7168463198807505, 0.048184782571431724, 0.004067499782622189]}}], "error_log": []}
{"context": "In a game of Tic Tac Toe, given a partially filled board, what is the optimal move for the current player to either win or prevent the opponent from winning?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (list of lists of strings/None): A 3x3 grid representing the Tic Tac Toe board. Each cell can be `\"X\"`, `\"O\"`, or `None` (representing an empty cell).\n\nOutput:\n  `return` (int or tuple of ints): If the game is over, returns an integer representing the utility of the board (`1` if X has won, `-1` if O has won, `0` otherwise). If the game is still ongoing, returns a tuple of two integers representing the optimal move for the current player in the format `(row, column)`.", "reference_code": "# import necessary packages\nimport copy\nimport random\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    xCounter = sum(row.count(X) for row in board)\n    oCounter = sum(row.count(O) for row in board)\n    return O if xCounter > oCounter else X\n\n# Function to get all possible actions\ndef actions(board):\n    possibleActions = {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}\n    return possibleActions\n\n# Function to get the result of an action\ndef result(board, action):\n    result = copy.deepcopy(board)\n    result[action[0]][action[1]] = player(board)\n    return result\n\n# Function to determine the winner\ndef winner(board):\n    lines = [\n        [(0, 0), (0, 1), (0, 2)],\n        [(1, 0), (1, 1), (1, 2)],\n        [(2, 0), (2, 1), (2, 2)],\n        [(0, 0), (1, 0), (2, 0)],\n        [(0, 1), (1, 1), (2, 1)],\n        [(0, 2), (1, 2), (2, 2)],\n        [(0, 0), (1, 1), (2, 2)],\n        [(0, 2), (1, 1), (2, 0)],\n    ]\n    for line in lines:\n        if all(board[i][j] == X for i, j in line):\n            return X\n        if all(board[i][j] == O for i, j in line):\n            return O\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or all(all(cell is not EMPTY for cell in row) for row in board)\n\n# Function to get the utility of the board\ndef utility(board):\n    win = winner(board)\n    if win == X:\n        return 1\n    elif win == O:\n        return -1\n    else:\n        return 0\n\n# Main function to solve the problem\ndef main_solution(board):\n    if terminal(board):\n        return utility(board)\n    else:\n        return minimax(board)\n\n# Function to get the optimal action using minimax algorithm\ndef minimax(board):\n    if terminal(board):\n        return None\n    else:\n        if player(board) == X:\n            value, move = max_value(board)\n            return move\n        else:\n            value, move = min_value(board)\n            return move\n\n# Helper function for max_value\ndef max_value(board):\n    if terminal(board):\n        return utility(board), None\n    v = float('-inf')\n    move = None\n    for action in actions(board):\n        low, _ = min_value(result(board, action))\n        if low > v:\n            v = low\n            move = action\n            if v == 1:\n                return v, move\n    return v, move\n\n# Helper function for min_value\ndef min_value(board):\n    if terminal(board):\n        return utility(board), None\n    v = float('inf')\n    move = None\n    for action in actions(board):\n        high, _ = max_value(result(board, action))\n        if high < v:\n            v = high\n            move = action\n            if v == -1:\n                return v, move\n    return v, move", "input_generator": "import random\n\ndef input_generator():\n    board = [[None, None, None], [None, None, None], [None, None, None]]\n    moves = random.randint(0, 9)\n    current_player = 'X'\n    \n    for _ in range(moves):\n        empty_positions = [(i, j) for i in range(3) for j in range(3) if board[i][j] is None]\n        if not empty_positions:\n            break\n        i, j = random.choice(empty_positions)\n        board[i][j] = current_player\n        current_player = 'O' if current_player == 'X' else 'X'\n    \n    return {'board': board}", "io_pairs": [{"input": {"board": [[null, "X", null], [null, null, "X"], ["X", "O", "O"]]}, "output": [1, 0]}, {"input": {"board": [[null, "O", "X"], ["X", null, null], [null, null, null]]}, "output": [1, 1]}, {"input": {"board": [[null, null, null], [null, null, null], [null, "O", "X"]]}, "output": [1, 2]}, {"input": {"board": [["O", "X", "X"], ["X", "X", "O"], ["X", "O", "O"]]}, "output": 1}, {"input": {"board": [["X", null, "O"], ["O", null, "X"], ["X", null, null]]}, "output": [1, 1]}, {"input": {"board": [["X", "O", "O"], ["X", "X", "X"], ["O", "O", "X"]]}, "output": 1}, {"input": {"board": [[null, null, null], ["O", null, "X"], [null, "X", null]]}, "output": [0, 2]}, {"input": {"board": [["O", "X", "X"], ["X", "O", "X"], ["O", "X", "O"]]}, "output": -1}, {"input": {"board": [[null, null, null], [null, null, null], [null, null, "X"]]}, "output": [1, 1]}, {"input": {"board": [[null, null, null], [null, "X", null], ["O", null, null]]}, "output": [0, 1]}], "error_log": []}
{"context": "Given a positive integer, what are its prime factors?\n\nThe input and output requirements are as follows:\n\nInput:\n  `number` (int): The integer for which the prime factors are to be determined.\n\nOutput:\n  `return` (dict): A dictionary containing the key `prime_factors` which is a list of integers representing the prime factors of the input number.", "reference_code": "# import necessary packages\nfrom math import sqrt\nfrom re import sub\nfrom itertools import count\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    if n < 2:\n        return False\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    divisor = 5\n    while divisor <= max_divisor:\n        if n % divisor == 0 or n % (divisor + 2) == 0:\n            return False\n        divisor += 6\n    return True\n\ndef prime_factors(num):\n    factors = []\n    for prime in prime_generator():\n        while num % prime == 0:\n            factors.append(prime)\n            num //= prime\n        if num == 1:\n            return factors\n\ndef prime_generator(block=100000):\n    primes = []\n    for i in count(0):\n        n = 1\n        while len(primes) <= i:\n            primes.extend(prime_sieve(block * n, primes))\n            n += 1\n        yield primes[i]\n\ndef prime_sieve(block, primes=[]):\n    if not primes:\n        offset = 3\n        extend = (block - offset) // 2 + 1\n        nums = [True] * extend\n    else:\n        offset = primes[-1] + 2\n        nums = primes_extender(primes, block)\n        extend = len(nums)\n    for i in range(extend):\n        if nums[i]:\n            for j in range(3 * i + offset, extend, 2 * i + offset):\n                nums[j] = False\n    if primes:\n        return [2 * i + offset for i in range(len(nums)) if nums[i]]\n    else:\n        return [2] + [2 * i + offset for i in range(len(nums)) if nums[i]]\n\ndef primes_extender(primes, block):\n    start = primes[-1] + 2\n    length = block\n    num = [True] * length\n    if 2 == primes[0]:\n        first = 1\n    else:\n        first = 0\n    for p in primes[first:]:\n        i_start = ((2 * -((p - start) // (2 * p)) + 1) * p - start) // 2\n        for i in range(i_start, length, p):\n            num[i] = False\n    return num\n\n# main function\ndef main_solution(number):\n    # Convert JSON serializable input to original input variables\n    number = int(number)\n    \n    # Get prime factors of the number\n    factors = prime_factors(number)\n    \n    # Convert the output to JSON serializable format\n    return {\"prime_factors\": factors}", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate a random number with a reasonable size, possibly with some prime factors\n    choices = [\n        random.randint(2, 100),  # Small numbers\n        random.randint(100, 10000),  # Medium numbers\n        random.randint(10000, 100000),  # Larger numbers\n        random.choice([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]) * random.randint(1, 100),  # Multiples of small primes\n        random.choice([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]) ** random.randint(1, 3),  # Powers of small primes\n    ]\n    number = random.choice(choices)\n    return {\"number\": number}", "io_pairs": [{"input": {"number": 86}, "output": {"prime_factors": [2, 43]}}, {"input": {"number": 41}, "output": {"prime_factors": [41]}}, {"input": {"number": 9877}, "output": {"prime_factors": [7, 17, 83]}}, {"input": {"number": 3412}, "output": {"prime_factors": [2, 2, 853]}}, {"input": {"number": 669}, "output": {"prime_factors": [3, 223]}}, {"input": {"number": 19}, "output": {"prime_factors": [19]}}, {"input": {"number": 91}, "output": {"prime_factors": [7, 13]}}, {"input": {"number": 9264}, "output": {"prime_factors": [2, 2, 2, 2, 3, 193]}}, {"input": {"number": 1001}, "output": {"prime_factors": [7, 11, 13]}}, {"input": {"number": 928}, "output": {"prime_factors": [2, 2, 2, 2, 2, 29]}}], "error_log": []}
{"context": "Given a system that decays over time according to a first-order differential equation, what are the values of the dependent variable `y` at specified time points when the initial condition and decay constant are known?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_condition` (float): The initial value of the dependent variable `y` at time `t=0`.\n  `time_points` (list of floats): A list of time points at which the solution of the ODE is to be evaluated.\n  `decay_constant` (float): The decay constant `k` in the differential equation `dy/dt = -k * y`.\n\nOutput:\n  `return` (list of floats): A list of values representing the solution of the ODE at the specified time points.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom scipy.integrate import odeint\n\n# function that returns dy/dt\ndef model(y, t, k):\n    dydt = -k * y\n    return dydt\n\n# main function\ndef main_solution(initial_condition, time_points, decay_constant):\n    # Convert JSON serializable inputs to the required format\n    initial_condition = float(initial_condition)\n    time_points = np.array(time_points, dtype=float)\n    decay_constant = float(decay_constant)\n    \n    # solve ODE\n    y = odeint(model, initial_condition, time_points, args=(decay_constant,))\n    \n    # Convert the output to JSON serializable format\n    y_list = y.tolist()\n    \n    return y_list", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    initial_condition = random.uniform(0.1, 10.0)\n    time_points = np.linspace(0, random.uniform(1.0, 10.0), random.randint(5, 20)).tolist()\n    decay_constant = random.uniform(0.01, 1.0)\n    return {\n        'initial_condition': initial_condition,\n        'time_points': time_points,\n        'decay_constant': decay_constant\n    }", "io_pairs": [{"input": {"initial_condition": 3.3713617972769336, "time_points": [0.0, 0.6677186319763437, 1.3354372639526875, 2.003155895929031, 2.670874527905375, 3.338593159881719, 4.006311791858062, 4.674030423834406], "decay_constant": 0.747948126495386}, "output": [[3.3713617972769336], [2.046022937899216], [1.241696996804367], [0.753565074938027], [0.45732596699291894], [0.2775434360240506], [0.16843644058167215], [0.10222124200656517]]}, {"input": {"initial_condition": 9.733382607736194, "time_points": [0.0, 1.2483627958463739, 2.4967255916927478, 3.7450883875391217, 4.9934511833854955], "decay_constant": 0.06371258930579413}, "output": [[9.733382607736194], [8.989210920619762], [8.301935190685674], [7.667205465748328], [7.081004618266807]]}, {"input": {"initial_condition": 8.055942023219533, "time_points": [0.0, 0.25612431080923265, 0.5122486216184653, 0.768372932427698, 1.0244972432369306, 1.2806215540461632, 1.536745864855396, 1.7928701756646286, 2.048994486473861], "decay_constant": 0.5585178522477822}, "output": [[8.055942023219533], [6.98217149974927], [6.051522901397376], [5.244919914561242], [4.545828396618102], [3.939918269245515], [3.4147695637283544], [2.9596173861050055], [2.565132131947308]]}, {"input": {"initial_condition": 1.9407265176451731, "time_points": [0.0, 0.9287704045770353, 1.8575408091540706, 2.786311213731106, 3.715081618308141, 4.643852022885176, 5.572622427462212, 6.501392832039247, 7.430163236616282, 8.358933641193317], "decay_constant": 0.22679914823248717}, "output": [[1.9407265176451731], [1.5721090730987937], [1.2735060295218879], [1.0316189984085344], [0.8356754879889672], [0.6769490518384514], [0.5483707884905124], [0.44421440592933614], [0.3598412643023788], [0.29149377311879093]]}, {"input": {"initial_condition": 5.496000592201379, "time_points": [0.0, 0.3304176003335964, 0.6608352006671928, 0.9912528010007893, 1.3216704013343856, 1.652088001667982, 1.9825056020015785, 2.312923202335175, 2.6433408026687712, 2.9737584030023676], "decay_constant": 0.30937933026705067}, "output": [[5.496000592201379], [4.961937560461208], [4.479770965749778], [4.04445797338934], [3.6514457033418593], [3.2966236240539515], [2.9762806777386004], [2.687066431900992], [2.425956091774527], [2.190218507766139]]}, {"input": {"initial_condition": 2.11588778446945, "time_points": [0.0, 0.9765104620855998, 1.9530209241711995, 2.9295313862567993, 3.906041848342399, 4.882552310427998, 5.859062772513599, 6.835573234599199, 7.812083696684798], "decay_constant": 0.45659216667560937}, "output": [[2.11588778446945], [1.3547371784626778], [0.8673961264819132], [0.5553667479189789], [0.35558405614291233], [0.22766940243273992], [0.14576963164256443], [0.09333176646732345], [0.059757429863604744]]}, {"input": {"initial_condition": 2.434027407578588, "time_points": [0.0, 0.6130273118970054, 1.2260546237940109, 1.8390819356910164, 2.4521092475880217, 3.065136559485027, 3.678163871382033, 4.291191183279038], "decay_constant": 0.9948224474591132}, "output": [[2.434027407578588], [1.3227249310463445], [0.7188091607942849], [0.390622862911398], [0.21227639195316367], [0.11535748089723087], [0.06268878357052117], [0.034067003433746385]]}, {"input": {"initial_condition": 8.85283535230729, "time_points": [0.0, 0.6892082608350552, 1.3784165216701103, 2.0676247825051655, 2.7568330433402206], "decay_constant": 0.8047721925887396}, "output": [[8.85283535230729], [5.083917692911152], [2.919541354527734], [1.676604936893394], [0.9628238360969537]]}, {"input": {"initial_condition": 3.4678994238346674, "time_points": [0.0, 0.8776854632206724, 1.7553709264413448, 2.633056389662017, 3.5107418528826897, 4.388427316103362], "decay_constant": 0.4333229705128775}, "output": [[3.4678994238346674], [2.3708008373123843], [1.6207784216168057], [1.1080317896908183], [0.757496780830867], [0.5178563927455296]]}, {"input": {"initial_condition": 4.55423443019682, "time_points": [0.0, 0.5199246675188943, 1.0398493350377886, 1.5597740025566829, 2.0796986700755773, 2.5996233375944717, 3.1195480051133657, 3.63947267263226], "decay_constant": 0.7472558582389681}, "output": [[4.55423443019682], [3.088052727213654], [2.0938908204633746], [1.4197875109487197], [0.9627037631043376], [0.6527726717573805], [0.4426202333569939], [0.30012388518909455]]}], "error_log": []}
{"context": "Given a system of linear algebraic equations (SLAE) represented by a coefficient matrix and a right-hand-side vector, what is the solution vector that satisfies the system of equations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `coefficient_matrix` (list of lists of int or float): A square matrix representing the coefficients of the system of linear equations.\n  `rhs_vector` (list of int or float): A vector representing the right-hand-side values of the system of linear equations.\n\nOutput:\n  `return` (list of int or float): A vector representing the solution to the system of linear equations.", "reference_code": "# import necessary packages\nfrom copy import deepcopy\nfrom typing import Union\n\n# all class and function definitions in the code file, if any\ndef solve(arr_a, arr_b: Union[list, tuple]) -> tuple:\n    \"\"\"Find the solution of the SLAE.\n\n    :param arr_a: The coefficient matrix of equations\n    :param arr_b: The column vector of right-hand-sides of equations\n    :return: X, the solution vector\n    \"\"\"\n    det = get_det_if_valid(arr_a, arr_b)\n\n    arr_x = tuple(\n        get_det(arr_replace_column(arr_a, arr_b, i)) / det\n        for i in range(len(arr_a))\n    )\n\n    return arr_x\n\n\ndef get_det_if_valid(arr_a, arr_b: Union[list, tuple]) -> Union[int, float]:\n    \"\"\"Get the determinant of an array A, if arrays are correct.\n\n    :param arr_a: The coefficient matrix of equations\n    :param arr_b: The column vector of right-hand-sides of equations\n    :return: The determinant of an array A\n    \"\"\"\n    if not (arr_a and arr_b):\n        raise ValueError(\n            \"The matrix or the column vector of right-hand-sides of the \"\n            \"equations is empty!\"\n        )\n\n    size = len(arr_a)\n    if len(arr_b) != size:\n        raise ValueError(\n            \"The size of the column vector of right-hand-sides of the \"\n            \"equations must be equal to the size of the matrix!\"\n        )\n\n    if size != 1:\n        for arr in arr_a:\n            if not isinstance(arr, list) or len(arr) != size:\n                raise ValueError(\"The matrix must be quadratic!\")\n\n    det = get_det(arr_a)\n    if not det:\n        raise ValueError(\"The matrix determinant must not be 0!\")\n\n    return det\n\n\ndef get_det(arr) -> Union[int, float]:\n    \"\"\"Get the determinant of an array.\n\n    :param arr: An array\n    :return: The array determinant\n    \"\"\"\n    if len(arr) == 1:\n        return arr[0]\n\n    det = 0\n    for i, j in enumerate(arr[0]):\n        det += j * ((-1) ** i) * get_det(arr_remove(arr, i))\n\n    return det\n\n\ndef arr_remove(arr, index: int):\n    \"\"\"Remove the 1st row and the index-th column from an array.\n\n    :param arr: An array\n    :param index: An index\n    :return: A changed copy of the array\n    \"\"\"\n    res = deepcopy(arr[1:])\n\n    for i in res:\n        i.pop(index)\n\n    if len(res) == 1:\n        return res[0]\n    return res\n\n\ndef arr_replace_column(arr, col: Union[list, tuple], index: int):\n    \"\"\"Replace the index-th column from an array by a column vector.\n\n    :param arr: An array\n    :param col: A column vector\n    :param index: An index\n    :return: A changed copy of the array\n    \"\"\"\n    if len(arr) == 1:\n        return col\n\n    res = deepcopy(arr)\n\n    for i, j in enumerate(col):\n        res[i][index] = j\n\n    return res\n\n# main function\ndef main_solution(coefficient_matrix: list, rhs_vector: list) -> list:\n    \"\"\"Solve a system of linear algebraic equations (SLAE) using Cramer's rule.\n\n    :param coefficient_matrix: A list of lists representing the coefficient matrix of the SLAE.\n    :param rhs_vector: A list representing the right-hand-side vector of the SLAE.\n    :return: A list representing the solution vector X.\n    \"\"\"\n    # Convert input to JSON serializable format if necessary\n    coefficient_matrix = [list(row) for row in coefficient_matrix]\n    rhs_vector = list(rhs_vector)\n\n    # Solve the SLAE\n    solution_vector = solve(coefficient_matrix, rhs_vector)\n\n    # Convert output to JSON serializable format\n    return list(solution_vector)", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    size = random.randint(2, 5)  # Generate small matrices (2x2 to 5x5)\n    \n    # Generate a random matrix with non-zero determinant\n    while True:\n        matrix = np.random.randint(-10, 10, size=(size, size)).tolist()\n        det = np.linalg.det(matrix)\n        if not np.isclose(det, 0.0):\n            break\n    \n    # Generate a random right-hand side vector\n    rhs = np.random.randint(-10, 10, size=size).tolist()\n    \n    return {\n        'coefficient_matrix': matrix,\n        'rhs_vector': rhs\n    }", "io_pairs": [{"input": {"coefficient_matrix": [[-9, 6, 6], [1, 6, 1], [8, 9, 2]], "rhs_vector": [-9, 7, 8]}, "output": [-0.12, 1.76, -3.44]}, {"input": {"coefficient_matrix": [[-7, 4], [-1, 7]], "rhs_vector": [1, -5]}, "output": [-0.6, -0.8]}, {"input": {"coefficient_matrix": [[9, 8], [6, 7]], "rhs_vector": [2, -10]}, "output": [6.266666666666667, -6.8]}, {"input": {"coefficient_matrix": [[-7, -4], [6, 4]], "rhs_vector": [-9, 6]}, "output": [3.0, -3.0]}, {"input": {"coefficient_matrix": [[2, 7], [-3, -5]], "rhs_vector": [-7, 2]}, "output": [1.9090909090909092, -1.5454545454545454]}, {"input": {"coefficient_matrix": [[4, -6], [-3, -9]], "rhs_vector": [8, -1]}, "output": [1.4444444444444444, -0.37037037037037035]}, {"input": {"coefficient_matrix": [[3, 1, 1], [4, -6, 2], [-1, 4, 9]], "rhs_vector": [-6, -4, -1]}, "output": [-1.794392523364486, -0.5514018691588785, -0.06542056074766354]}, {"input": {"coefficient_matrix": [[-2, 1], [8, -7]], "rhs_vector": [6, -4]}, "output": [-6.333333333333333, -6.666666666666667]}, {"input": {"coefficient_matrix": [[8, 4], [4, 8]], "rhs_vector": [-6, -4]}, "output": [-0.6666666666666666, -0.16666666666666666]}, {"input": {"coefficient_matrix": [[7, 4], [-5, -10]], "rhs_vector": [3, 0]}, "output": [0.6, -0.3]}], "error_log": []}
{"context": "Given a logical formula involving bitwise operations, what is the smallest non-negative integer `a` such that the formula `x&25 \u2260 0 \u2192 (x&19 = 0 \u2192 x&a \u2260 0)` is true for all non-negative integers `x`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `a_max` (int): The maximum value of `a` to check for the smallest non-negative integer `a` that makes the formula true for all non-negative integers `x`.\n\nOutput:\n  `return` (int or None): The smallest non-negative integer `a` that satisfies the formula for all non-negative integers `x`. If no such `a` is found within the range, it returns `None`.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef task15(x, a):\n    return (x & 25 != 0) <= ((x & 19 == 0) <= (x & a != 0))\n\n# main function\ndef main_solution(a_max):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    for a in range(a_max + 1):\n        Flag = True\n        for x in range(100):\n            if task15(x, a) == False:\n                Flag = False\n                break\n        if Flag == True:\n            return a\n    return None", "input_generator": "import random\n\ndef input_generator():\n    return {'a_max': random.randint(1, 100)}", "io_pairs": [{"input": {"a_max": 19}, "output": 8}, {"input": {"a_max": 95}, "output": 8}, {"input": {"a_max": 48}, "output": 8}, {"input": {"a_max": 34}, "output": 8}, {"input": {"a_max": 25}, "output": 8}, {"input": {"a_max": 75}, "output": 8}, {"input": {"a_max": 40}, "output": 8}, {"input": {"a_max": 36}, "output": 8}, {"input": {"a_max": 57}, "output": 8}, {"input": {"a_max": 76}, "output": 8}], "error_log": []}
{"context": "In a hypothetical chess match, Kasparov needs to win a certain number of games to claim victory. Given the probability of Kasparov winning a single game and the number of wins and losses he can have before needing to win the required number of games, what are the chances of Kasparov winning the match starting from both a 5-3 score and a 0-0 score?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p_kas_win` (float): The probability of Kasparov winning a single game, between 0 and 1.\n  `k_wins` (int): The number of wins Kasparov needs to win the match, a positive integer.\n  `r_losses` (int): The number of losses Kasparov can have before needing to win `k_wins` games, a non-negative integer.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `\"prob_5_3\"` (float): The probability of Kasparov winning the match starting at a 5-3 score.\n    - `\"prob_0_0\"` (float): The probability of Kasparov winning the match starting at a 0-0 score.", "reference_code": "# import necessary packages\nfrom scipy.stats import nbinom\n\n# main function\ndef main_solution(p_kas_win, k_wins, r_losses):\n  # Calculate the probability of Kasparov winning starting at 5-3\n  prob_5_3 = nbinom.pmf(0, k_wins, p_kas_win)\n  \n  # Calculate the probability of Kasparov winning starting at 0-0\n  prob_0_0 = sum([nbinom.pmf(i, k_wins + r_losses, p_kas_win) for i in range(r_losses)])\n  \n  # Return the probabilities as a dictionary\n  return {\"prob_5_3\": prob_5_3, \"prob_0_0\": prob_0_0}", "input_generator": "import random\n\ndef input_generator():\n    p_kas_win = random.uniform(0.5, 0.9)  # Probability between 0.5 and 0.9\n    k_wins = random.randint(1, 10)         # Number of wins between 1 and 10\n    r_losses = random.randint(1, 10)       # Number of losses between 1 and 10\n    return {\"p_kas_win\": p_kas_win, \"k_wins\": k_wins, \"r_losses\": r_losses}", "io_pairs": [{"input": {"p_kas_win": 0.6937986619918907, "k_wins": 6, "r_losses": 5}, "output": {"prob_5_3": 0.11153232298860163, "prob_0_0": 0.49425787672300436}}, {"input": {"p_kas_win": 0.5416494956566078, "k_wins": 6, "r_losses": 10}, "output": {"prob_5_3": 0.025252830203094084, "prob_0_0": 0.2168523265604549}}, {"input": {"p_kas_win": 0.6491359809615578, "k_wins": 5, "r_losses": 6}, "output": {"prob_5_3": 0.11525994593920529, "prob_0_0": 0.48702955403853754}}, {"input": {"p_kas_win": 0.5775091830527012, "k_wins": 3, "r_losses": 8}, "output": {"prob_5_3": 0.1926090473375095, "prob_0_0": 0.4851771180316496}}, {"input": {"p_kas_win": 0.6534826331281419, "k_wins": 10, "r_losses": 4}, "output": {"prob_5_3": 0.014201705522295776, "prob_0_0": 0.10815116878665584}}, {"input": {"p_kas_win": 0.8844596409019958, "k_wins": 3, "r_losses": 9}, "output": {"prob_5_3": 0.6918852318066387, "prob_0_0": 0.9998143522763024}}, {"input": {"p_kas_win": 0.8126283538017836, "k_wins": 2, "r_losses": 8}, "output": {"prob_5_3": 0.6603648414025967, "prob_0_0": 0.9926936672736764}}, {"input": {"p_kas_win": 0.889182530011472, "k_wins": 10, "r_losses": 1}, "output": {"prob_5_3": 0.3089649498396211, "prob_0_0": 0.27472623578326183}}, {"input": {"p_kas_win": 0.6229102846684056, "k_wins": 6, "r_losses": 8}, "output": {"prob_5_3": 0.05841885068834848, "prob_0_0": 0.4326821376489285}}, {"input": {"p_kas_win": 0.6127899744549057, "k_wins": 4, "r_losses": 2}, "output": {"prob_5_3": 0.14100892628059236, "prob_0_0": 0.17596822315590283}}], "error_log": []}
{"context": "Given a grid of cells, a maze is generated using a depth-first search algorithm. The maze consists of cells that are initially surrounded by walls. As the algorithm progresses, walls between cells are knocked down to create pathways. How many cells and how many walls are knocked down in the generated maze?\n\nThe input and output requirements are as follows:\n\nInput:\n  `nx` (int): The number of cells in the x-direction of the maze.\n  `ny` (int): The number of cells in the y-direction of the maze.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `num_cells` (int): The total number of cells in the maze.\n    - `walls_down` (int): The total number of walls knocked down during maze generation.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Cell:\n    \"\"\"A cell in the maze.\"\"\"\n    w, h = 25, 25  # Assuming CELL_WIDTH and CELL_HIGH are 25\n    wl = 5  # Assuming WALL_THICKNESS is 5\n    wall_pairs = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n\n    def __init__(self, x, y):\n        \"\"\"Initialize the cell at (x,y). At first it is surrounded by walls.\"\"\"\n        self.x, self.y = x, y\n        self.walls = {'N': True, 'S': True, 'E': True, 'W': True}\n\n    def has_all_walls(self):\n        \"\"\"Does this cell still have all its walls?\"\"\"\n        return all(self.walls.values())\n\n    def knock_down_wall(self, other, wall):\n        \"\"\"Knock down the wall between cells self and other.\"\"\"\n        self.walls[wall] = False\n        other.walls[Cell.wall_pairs[wall]] = False\n\nclass Maze:\n    \"\"\"A Maze, represented as a grid of cells.\"\"\"\n\n    def __init__(self, nx, ny, ix=0, iy=0):\n        \"\"\"Initialize the maze grid.\"\"\"\n        self.nx, self.ny = nx, ny\n        self.ix, self.iy = ix, iy\n        self.grid = [[Cell(x, y) for y in range(ny)] for x in range(nx)]\n\n    def cell_at(self, x, y):\n        \"\"\"Return the Cell object at (x,y).\"\"\"\n        return self.grid[x][y]\n\n    def find_valid_neighbours(self, cell):\n        \"\"\"Return a list of unvisited neighbours to cell.\"\"\"\n        delta = [('W', (-1,0)), ('E', (1,0)), ('S', (0,1)), ('N', (0,-1))]\n        neighbours = []\n        for direction, (dx,dy) in delta:\n            x2, y2 = cell.x + dx, cell.y + dy\n            if (0 <= x2 < self.nx) and (0 <= y2 < self.ny):\n                neighbour = self.cell_at(x2, y2)\n                if neighbour.has_all_walls():\n                    neighbours.append((direction, neighbour))\n        return neighbours\n\n    def make_maze(self):\n        n = self.nx * self.ny\n        cell_stack = []\n        current_cell = self.cell_at(self.ix, self.iy)\n        nv = 1\n\n        while nv < n:\n            neighbours = self.find_valid_neighbours(current_cell)\n\n            if not neighbours:\n                current_cell = cell_stack.pop()\n                continue\n\n            direction, next_cell = random.choice(neighbours)\n            current_cell.knock_down_wall(next_cell, direction)\n            cell_stack.append(current_cell)\n            current_cell = next_cell\n            nv += 1\n\n# main function\ndef main_solution(nx, ny):\n    \"\"\"Generate a maze and return the number of cells and the number of walls knocked down.\"\"\"\n    maze = Maze(nx, ny)\n    maze.make_maze()\n    \n    # Count the number of walls knocked down\n    walls_down = 0\n    for row in maze.grid:\n        for cell in row:\n            walls_down += sum(1 for wall in cell.walls.values() if not wall)\n    \n    return {\"num_cells\": nx * ny, \"walls_down\": walls_down}", "input_generator": "import random\n\ndef input_generator():\n    nx = random.randint(5, 20)\n    ny = random.randint(5, 20)\n    return {\"nx\": nx, \"ny\": ny}", "io_pairs": [{"input": {"nx": 19, "ny": 13}, "output": {"num_cells": 247, "walls_down": 492}}, {"input": {"nx": 18, "ny": 6}, "output": {"num_cells": 108, "walls_down": 214}}, {"input": {"nx": 12, "ny": 14}, "output": {"num_cells": 168, "walls_down": 334}}, {"input": {"nx": 19, "ny": 16}, "output": {"num_cells": 304, "walls_down": 606}}, {"input": {"nx": 19, "ny": 5}, "output": {"num_cells": 95, "walls_down": 188}}, {"input": {"nx": 19, "ny": 20}, "output": {"num_cells": 380, "walls_down": 758}}, {"input": {"nx": 12, "ny": 15}, "output": {"num_cells": 180, "walls_down": 358}}, {"input": {"nx": 12, "ny": 7}, "output": {"num_cells": 84, "walls_down": 166}}, {"input": {"nx": 12, "ny": 5}, "output": {"num_cells": 60, "walls_down": 118}}, {"input": {"nx": 11, "ny": 15}, "output": {"num_cells": 165, "walls_down": 328}}], "error_log": []}
{"context": "In a tic-tac-toe game, a bot is trained using different reinforcement learning techniques (Value Iteration, Monte Carlo, or Q-Learning). After training, the bot competes against an optimal bot to evaluate its performance. What is the percentage of games that end in a tie, and what are the win percentages for both the trained bot and the optimal bot?\n\nThe input and output requirements are as follows:\n\nInput:\n  `mode` (int): The mode of the bot. It can be one of the following:\n    - `0`: Value Iteration\n    - `1`: Monte Carlo\n    - `2`: Q-Learning\n  `num_iterations` (int): The number of iterations to train the bot.\n  `epsilon` (float, optional): The exploration rate for the bot. Default is `0`.\n\nOutput:\n  `return` (dict): A dictionary containing the results of the evaluation. It has the following keys:\n    - `ties` (float): The percentage of games that ended in a tie.\n    - `bot1_wins` (float): The percentage of games won by the trained bot.\n    - `bot2_wins` (float): The percentage of games won by the optimal bot.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef evalBoard(board):\n    rows = [board[0] + board[1] + board[2],\n            board[3] + board[4] + board[5],\n            board[6] + board[7] + board[8]]\n    cols = [board[0] + board[3] + board[6],\n            board[1] + board[4] + board[7],\n            board[2] + board[5] + board[8]]\n    diag1 = board[0] + board[4] + board[8]\n    diag2 = board[2] + board[4] + board[6]\n\n    complete = cols + rows + [diag1, diag2]\n    Owin = any([elem==3 for elem in complete])\n    Xwin = any([elem==-3 for elem in complete])\n    if Owin and Xwin:\n        raise ValueError('Invalid board -- wins for both Os and Xs')\n    result = Owin*1 + Xwin*-1\n    return result\n\ndef updateBoard(board, move):\n    newBoard = list(board)\n    newBoard[move] = nextPlayer(board)\n    return tuple(newBoard)\n\ndef nextPlayer(board):\n    currentStatus = sum(board)\n    if currentStatus > 0:\n        return -1\n    else:\n        return 1\n    \ndef possibleMoves(board):\n    if evalBoard(board) == 0:\n        possible = [i for i,a in enumerate(board) if a==0]\n    else:\n        possible = []\n    return possible\n\nnewGame = (0,0,0,0,0,0,0,0,0)\nUSE_VALUE_ITERATION, USE_MONTE_CARLO, USE_Q_LEARNING, USER_INPUT = range(4)\n\nclass ticTacToeBot(object):\n    def __init__(self, initBoard = newGame):\n        self._mode = USE_MONTE_CARLO\n        self._stepSize = 0\n        self._epsilon = 0\n        self._boardHist = []\n        self._boardValues = {}\n        self._stateActionValues = {}\n        self._stateVisitCount = {}\n        self.discountRate = 1\n        self.currentBoard = initBoard\n\n    def setStepSize(self, stepSize):\n        self._stepSize = stepSize\n\n    def setEpsilon(self, epsilon):\n        self._epsilon = epsilon\n\n    def setMode(self, mode):\n        self._mode = mode\n        \n    def initValues(self):\n        self._boardValues[newGame] = evalBoard(newGame)\n        possible = self.possibleMoves(newGame)\n        moves = {newGame : possible}\n\n        while len(moves)>0:\n            nextMoves = {}\n            for board,posMoves in moves.items():\n                for move in posMoves:\n                    newBoard = updateBoard(board, move)\n                    reward = evalBoard(newBoard)\n                    self._boardValues[newBoard] = reward\n                    self._stateActionValues[(board,move)] = reward\n                    if reward == 0:\n                        nextMoves[newBoard] = self.possibleMoves(newBoard)\n                    else:\n                        self._stateActionValues[(newBoard)] = 0\n            moves = nextMoves\n\n    def possibleMoves(self, board):\n        if evalBoard(board) == 0:\n            possible = [i for i,a in enumerate(board) if a==0]\n        else:\n            possible = []\n        return possible\n\n    def getMove(self, board ):\n        player = nextPlayer(board)\n        possible = self.possibleMoves(board)\n        bestMove = -1\n        bestValue = 0\n        randVal = random.uniform(0,1)\n        if randVal > self._epsilon:\n          for move in possible:\n              if self._mode == USE_MONTE_CARLO or self._mode == USE_VALUE_ITERATION:\n                  value = player * self._boardValues[ updateBoard( board, move) ]\n              else:\n                  value = player * self._stateActionValues[(board,move)]\n              if bestMove == -1 or value > bestValue:\n                  bestValue = value\n                  bestMove = move\n        else:\n          bestMove = random.choice(possible)\n            \n        return updateBoard( board, bestMove), bestMove\n\n    def logBoard(self, board):\n        self._boardHist.append(board)\n\n    def monteCarloUpdate(self):\n        if self._mode != USE_MONTE_CARLO:\n            return\n\n        discountedReward = evalBoard(self._boardHist[-1])\n        for board in reversed(self._boardHist):\n            numStateVisits = self._stateVisitCount.get(board,0)\n            self._boardValues[board] = 1.0 * numStateVisits / (numStateVisits + 1) * self._boardValues[board] + 1.0 * discountedReward / (numStateVisits + 1)\n            self._stateVisitCount[board] = numStateVisits + 1\n            discountedReward = self.discountRate * discountedReward\n        self._boardHist = []\n\n    def QUpdate(self, board, move):\n        if self._mode != USE_Q_LEARNING:\n            return\n        newBoard = updateBoard(board, move)\n        reward = evalBoard(newBoard)\n        nextMoves = possibleMoves(newBoard)\n\n        if len(nextMoves) > 0:\n            player = nextPlayer(newBoard)\n            maxNextMoveQval = player * max([player * self._stateActionValues[(newBoard,nextMove)] for nextMove in nextMoves])\n        else:\n            maxNextMoveQval = 0\n        self._stateActionValues[(board,move)] = self._stateActionValues[(board,move)] + self._stepSize * (reward + self.discountRate * maxNextMoveQval - self._stateActionValues[(board,move)])\n        \n    def iterateValue(self):\n        anyUpdate = False\n        for board,value in self._boardValues.items():\n            possible = possibleMoves(board)\n            player = nextPlayer(board)\n            valuesInNextStates = []\n            if len(possible) > 0 :\n              for move in possible:\n                  valuesInNextStates.append(player * self._boardValues[updateBoard(board, move)])\n              valueOfBestMove = player * max(valuesInNextStates)\n                \n              newBoardValue = evalBoard(board) + self.discountRate * valueOfBestMove\n              if newBoardValue != self._boardValues[board]:\n                  anyUpdate = True\n                  self._boardValues[board] = newBoardValue\n                  \n        return anyUpdate\n\ndef valueIteration():\n    myBot = ticTacToeBot()\n    myBot.initValues()\n    update = True\n    while update:\n        update = myBot.iterateValue()\n\n    return myBot\n        \n\ndef runMCiterations(myBot, numIter, epsilon=0):\n    myBot._stateVisitCount = {}\n    myBot._boardHist = []\n    player = 1\n    for iter in range(numIter):\n        playGame(myBot, epsilon)\n        myBot.monteCarloUpdate()\n        myBot._boardHist = []\n        player = player * -1\n    return myBot\n\ndef runQiterations(myBot, numIter, epsilon=0):\n    player = 1\n    for iter in range(numIter):\n        playGame(myBot, epsilon)\n        myBot._boardHist = []\n        player = player * -1\n    return myBot\n\ndef playGame(myBot, epsilon=0):\n    board = newGame\n    myBot.logBoard(board)\n    while len(possibleMoves(board)) > 0 and evalBoard(board)==0:\n        randVal = random.uniform(0,1)\n        if randVal > epsilon:\n            newBoard, move = myBot.getMove(board)\n        else:\n            move = random.choice(possibleMoves(board))\n            newBoard = updateBoard(board, move)\n        myBot.QUpdate(board, move) \n            \n        board = newBoard\n        myBot.logBoard(board)\n\n    return evalBoard(board)\n\ndef getOptimalBot():\n    myBot = ticTacToeBot()\n    myBot.initValues()\n    myBot.setMode(USE_VALUE_ITERATION)\n    update = True\n    while update:\n        update = myBot.iterateValue()\n\n    return myBot\n\ndef getMonteCarloBot():\n    myBot = ticTacToeBot()\n    myBot.initValues()\n    myBot.setMode(USE_MONTE_CARLO)\n\n    return myBot\n\ndef getQlearningBot():\n    myBot = ticTacToeBot()\n    myBot.initValues()\n    myBot.setMode(USE_Q_LEARNING)\n\n    return myBot\n\ndef getUserBot():\n    myBot = ticTacToeBot()\n    myBot.setMode(USER_INPUT)\n\n    return myBot\n\ndef BotVsBot(myBot1, myBot2, player=1, verbose=False):\n    if player != 1 and player != -1:\n        raise ValueError(\"Invalid player values.  Should be 1 or -1\")\n    board = newGame\n    myBot1.logBoard(board)\n    myBot2.logBoard(board)\n    while len(possibleMoves(board)) > 0 and evalBoard(board)==0:\n        if player == 1:\n            newBoard, move = myBot1.getMove(board)\n        else:\n            newBoard, move = myBot2.getMove(board)\n        if verbose:\n            printBoard(newBoard)\n        myBot1.QUpdate(board, move)\n        myBot2.QUpdate(board, move)\n        board = newBoard\n        myBot1.logBoard(board)\n        myBot2.logBoard(board)\n        player = player * -1\n    myBot1.monteCarloUpdate()\n    myBot2.monteCarloUpdate()\n\n    return evalBoard(board)\n\ndef playGames(myBot1, myBot2, iterations = -1):\n    numGames = numTies = bot1Win = bot2Win = 0\n    donePlaying = False\n    while not donePlaying:\n        player = 1\n        result = player * BotVsBot(myBot1, myBot2, player)\n        numGames = numGames + 1\n        \n        if result == 0:\n            numTies = numTies + 1\n        if result == 1:\n            bot1Win = bot1Win + 1\n        if result == -1:\n            bot2Win = bot2Win + 1\n\n        if iterations == -1:\n            response = (raw_input(\"Play again? [n to stop] \")).lower()\n            if len(response) > 0 and response[0] == \"n\":\n                break\n            \n        if numGames == iterations:\n            donePlaying = True\n            \n    return [1.0 * val / numGames for val in [numTies, bot1Win, bot2Win]]\n\n# main function\ndef main_solution(mode, num_iterations, epsilon=0):\n    # Convert mode to integer\n    mode = int(mode)\n    \n    # Initialize bots based on the mode\n    if mode == USE_VALUE_ITERATION:\n        bot1 = getOptimalBot()\n    elif mode == USE_MONTE_CARLO:\n        bot1 = getMonteCarloBot()\n    elif mode == USE_Q_LEARNING:\n        bot1 = getQlearningBot()\n    else:\n        raise ValueError(\"Invalid mode\")\n    \n    bot2 = getOptimalBot()\n    \n    # Train the bot based on the mode\n    if mode == USE_MONTE_CARLO:\n        bot1 = runMCiterations(bot1, num_iterations, epsilon)\n    elif mode == USE_Q_LEARNING:\n        bot1 = runQiterations(bot1, num_iterations, epsilon)\n    \n    # Evaluate the bot against the optimal bot\n    results = playGames(bot1, bot2, iterations=1000)\n    \n    # Return the results as a dictionary\n    return {\"ties\": results[0], \"bot1_wins\": results[1], \"bot2_wins\": results[2]}", "input_generator": "import random\n\ndef input_generator():\n    modes = [0, 1, 2]  # USE_VALUE_ITERATION, USE_MONTE_CARLO, USE_Q_LEARNING\n    mode = random.choice(modes)\n    num_iterations = random.randint(100, 1000)\n    epsilon = random.uniform(0, 0.2)\n    return {\"mode\": mode, \"num_iterations\": num_iterations, \"epsilon\": epsilon}", "io_pairs": [{"input": {"mode": 1, "num_iterations": 521, "epsilon": 0.06640587129331495}, "output": {"ties": 0.999, "bot1_wins": 0.0, "bot2_wins": 0.001}}, {"input": {"mode": 1, "num_iterations": 797, "epsilon": 0.0974387582464891}, "output": {"ties": 0.997, "bot1_wins": 0.0, "bot2_wins": 0.003}}, {"input": {"mode": 1, "num_iterations": 682, "epsilon": 0.1713500819368}, "output": {"ties": 0.994, "bot1_wins": 0.0, "bot2_wins": 0.006}}, {"input": {"mode": 0, "num_iterations": 742, "epsilon": 0.0213229146517137}, "output": {"ties": 1.0, "bot1_wins": 0.0, "bot2_wins": 0.0}}, {"input": {"mode": 1, "num_iterations": 651, "epsilon": 0.18917412087171315}, "output": {"ties": 0.988, "bot1_wins": 0.0, "bot2_wins": 0.012}}, {"input": {"mode": 1, "num_iterations": 407, "epsilon": 0.04815981280655462}, "output": {"ties": 0.997, "bot1_wins": 0.0, "bot2_wins": 0.003}}, {"input": {"mode": 1, "num_iterations": 884, "epsilon": 0.0990035433471961}, "output": {"ties": 0.997, "bot1_wins": 0.0, "bot2_wins": 0.003}}, {"input": {"mode": 0, "num_iterations": 887, "epsilon": 0.175894716476075}, "output": {"ties": 1.0, "bot1_wins": 0.0, "bot2_wins": 0.0}}, {"input": {"mode": 0, "num_iterations": 550, "epsilon": 0.03515284133777221}, "output": {"ties": 1.0, "bot1_wins": 0.0, "bot2_wins": 0.0}}, {"input": {"mode": 2, "num_iterations": 315, "epsilon": 0.17399052891691838}, "output": {"ties": 0.0, "bot1_wins": 0.0, "bot2_wins": 1.0}}], "error_log": []}
{"context": "In a series of Bernoulli trials, where each trial has a certain probability of success, what is the likelihood of achieving 10 or more successes in a given number of trials? The number of trials, the probability of success, and the number of experiments are provided.\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): Number of trials in each Bernoulli experiment.\n  `p` (float): Probability of success in each trial.\n  `size` (int): Number of Bernoulli experiments to perform.\n\nOutput:\n  `probability` (float): Probability of getting 10 or more successes in the Bernoulli experiments.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# Function definitions from the code file\ndef ecdf(data):\n    \"\"\"Compute ECDF for a one-dimensional array of measurements.\"\"\"\n    n = len(data)\n    x = np.sort(data)\n    y = np.arange(1, n+1) / n\n    return x, y\n\ndef perform_bernoulli_trials(n, p):\n    \"\"\"Perform n Bernoulli trials with success probability p and return number of successes.\"\"\"\n    n_success = 0\n    for i in range(n):\n        random_number = np.random.random()\n        if random_number < p:\n            n_success += 1\n    return n_success\n\n# main function\ndef main_solution(n, p, size):\n    \"\"\"\n    Perform Bernoulli trials and compute the probability of getting a specific number of successes.\n\n    Parameters:\n    n (int): Number of trials in each Bernoulli experiment.\n    p (float): Probability of success in each trial.\n    size (int): Number of Bernoulli experiments to perform.\n\n    Returns:\n    float: Probability of getting a specific number of successes.\n    \"\"\"\n    # Perform Bernoulli trials\n    n_defaults = np.empty(size)\n    for i in range(size):\n        n_defaults[i] = perform_bernoulli_trials(n, p)\n    \n    # Compute the number of experiments with 10 or more successes\n    n_lose_money = np.sum(n_defaults >= 10)\n    \n    # Compute and return the probability\n    probability = n_lose_money / size\n    return probability", "input_generator": "import numpy as np\n\ndef input_generator():\n    n = np.random.randint(5, 20)\n    p = np.random.uniform(0.1, 0.9)\n    size = np.random.randint(100, 1000)\n    return {'n': n, 'p': p, 'size': size}", "io_pairs": [{"input": {"n": 15, "p": 0.323249749292778, "size": 545}, "output": 0.005504587155963303}, {"input": {"n": 17, "p": 0.4041231193184889, "size": 784}, "output": 0.09693877551020408}, {"input": {"n": 10, "p": 0.41052316255861077, "size": 344}, "output": 0.0}, {"input": {"n": 10, "p": 0.7974927218565694, "size": 132}, "output": 0.09848484848484848}, {"input": {"n": 14, "p": 0.3467950110513228, "size": 621}, "output": 0.004830917874396135}, {"input": {"n": 17, "p": 0.149837091638239, "size": 721}, "output": 0.0}, {"input": {"n": 8, "p": 0.36143879344461494, "size": 256}, "output": 0.0}, {"input": {"n": 7, "p": 0.3606200264127136, "size": 436}, "output": 0.0}, {"input": {"n": 13, "p": 0.1846595096782629, "size": 548}, "output": 0.0}, {"input": {"n": 8, "p": 0.874446524176005, "size": 915}, "output": 0.0}], "error_log": []}
{"context": "A child is running up a staircase with `n` steps and can hop either 1 step, 2 steps, or 3 steps at a time. How many possible ways can the child run up the stairs?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of steps in the staircase. It should be a positive integer.\n\nOutput:\n  `return` (int): The number of possible ways the child can run up the stairs. It is a non-negative integer.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef triple_step_helper(cur):\n    if cur == 0:\n        return 1\n    if cur < 0:\n        return 0\n    \n    return triple_step_helper(cur-1) + triple_step_helper(cur-2) + triple_step_helper(cur-3)\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = triple_step_helper(n)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(0, 20)\n    return {'n': n}", "io_pairs": [{"input": {"n": 9}, "output": 149}, {"input": {"n": 17}, "output": 19513}, {"input": {"n": 20}, "output": 121415}, {"input": {"n": 11}, "output": 504}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 7}, "output": 44}, {"input": {"n": 4}, "output": 7}, {"input": {"n": 3}, "output": 4}, {"input": {"n": 5}, "output": 13}, {"input": {"n": 8}, "output": 81}], "error_log": []}
{"context": "Given a base row of colored blocks and a list of allowed triangular patterns, can you construct a pyramid where each triangular pattern in the pyramid is one of the allowed patterns? The pyramid must be built such that each row contains one less block than the row beneath it and is centered on top.\n\nThe input and output requirements are as follows:\n\nInput:\n  `bottom` (str): The base row of the pyramid, represented as a string of single-letter colors.\n  `allowed` (List[str]): List of allowed triangular patterns, each pattern being a three-letter string where the first two characters represent the bottom blocks and the third character represents the top block.\n\nOutput:\n  `return` (bool): True if the pyramid can be built using the allowed patterns starting from the given bottom row, False otherwise.", "reference_code": "# import necessary packages\nimport collections\nimport itertools\n\n# main function\ndef main_solution(bottom, allowed):\n    \"\"\"\n    Determines if a pyramid can be built from the given bottom row using the allowed triangular patterns.\n\n    :param bottom: str - The base row of the pyramid.\n    :param allowed: List[str] - List of allowed triangular patterns.\n    :return: bool - True if the pyramid can be built, False otherwise.\n    \"\"\"\n    mapping = collections.defaultdict(set)\n    for brick in allowed:\n        mapping[brick[:2]].add(brick[2])\n    \n    def search(cur_level, cur_len):\n        if cur_len == 1:\n            return True\n        \n        next_cand = ' '        \n        for i in range(cur_len-1):\n            if cur_level[i:i+2] in mapping:\n                next_cand = map(''.join, itertools.product(next_cand, mapping[cur_level[i:i+2]]))\n            else:\n                return False\n        \n        if next_cand: \n            for cand in list(next_cand):\n                if search(cand[1:], cur_len-1):\n                    return True\n        return False\n    \n    return search(bottom, len(bottom))", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random bottom string of length between 2 and 5\n    bottom_len = random.randint(2, 5)\n    bottom = ''.join(random.choice(string.ascii_uppercase) for _ in range(bottom_len))\n    \n    # Generate allowed patterns based on the bottom string\n    allowed = []\n    for i in range(len(bottom) - 1):\n        base = bottom[i:i+2]\n        # Generate 1 to 3 allowed patterns for each base\n        for _ in range(random.randint(1, 3)):\n            allowed_char = random.choice(string.ascii_uppercase)\n            allowed.append(base + allowed_char)\n    \n    # Add some random allowed patterns not necessarily related to bottom\n    extra_allowed = random.randint(0, 3)\n    for _ in range(extra_allowed):\n        base = ''.join(random.choice(string.ascii_uppercase) for _ in range(2))\n        allowed_char = random.choice(string.ascii_uppercase)\n        allowed.append(base + allowed_char)\n    \n    # Ensure uniqueness in allowed patterns\n    allowed = list(set(allowed))\n    \n    return {'bottom': bottom, 'allowed': allowed}", "io_pairs": [{"input": {"bottom": "QFNJ", "allowed": ["NJF", "NJH", "QFT", "XLJ", "FNK"]}, "output": false}, {"input": {"bottom": "ZN", "allowed": ["ZNM", "CPK", "ZNP"]}, "output": true}, {"input": {"bottom": "YKMG", "allowed": ["KML", "MGG", "YKI", "MGR", "KMX", "MGN"]}, "output": false}, {"input": {"bottom": "IFF", "allowed": ["FFW", "IFT", "VQY", "IFG", "FFL", "AST", "VQJ", "FFS", "IFH"]}, "output": false}, {"input": {"bottom": "JQAY", "allowed": ["AYI", "QAO", "XPL", "JQF", "JQK", "JQB", "NBD"]}, "output": false}, {"input": {"bottom": "NKQ", "allowed": ["XKQ", "NKM", "KQX", "KQO"]}, "output": false}, {"input": {"bottom": "XRR", "allowed": ["XRN", "XRS", "RRZ"]}, "output": false}, {"input": {"bottom": "MTXWO", "allowed": ["WOL", "XWR", "XWD", "XWZ", "MTH", "TXU", "EGW"]}, "output": false}, {"input": {"bottom": "JFQTR", "allowed": ["QTW", "FQM", "TRB", "TRT", "JFQ", "TRI", "JFJ", "QTB"]}, "output": false}, {"input": {"bottom": "FYM", "allowed": ["YMG", "FYD", "LRJ", "YMR", "FYW", "BAV", "YMF"]}, "output": false}], "error_log": []}
{"context": "Given a function \\( f(x) = x + \\cos(x) \\) and its derivative \\( f'(x) = 1 - \\sin(x) \\), you are tasked with finding the root of the function using the Newton-Raphson method. What is the approximated root and the error when starting from a given initial guess `x0` and using a specified tolerance `tol`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x0` (float): The initial guess for the root of the function.\n  `tol` (float): The tolerance level for the root approximation.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `root` (float): The approximated root of the function.\n    - `error` (float): The error between the last two approximations.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom math import cos, sin\n\n# main function\ndef main_solution(x0, tol):\n    # Convert JSON serializable inputs to original input variables\n    fx = lambda x: x + cos(x)\n    dfx = lambda x: 1 - sin(x)\n    \n    xi = x0\n    tramo = abs(2 * tol)\n    \n    while not (tramo <= tol):\n        xn = xi - fx(xi) / dfx(xi)\n        tramo = abs(xn - xi)\n        xi = xn\n    \n    # Convert output to JSON serializable format\n    result = {\n        \"root\": xn,\n        \"error\": tramo\n    }\n    \n    return result", "input_generator": "import random\nimport numpy as np\n\ndef input_generator():\n    x0 = random.uniform(-10.0, 10.0)\n    tol = 10 ** random.uniform(-6, -2)\n    return {\n        \"x0\": x0,\n        \"tol\": tol\n    }", "io_pairs": [{"input": {"x0": -2.6930852821255513, "tol": 8.519224505729195e-06}, "output": {"root": -0.7390851332157878, "error": 1.685418018149143e-06}}, {"input": {"x0": -5.221967119258537, "tol": 3.389658268362217e-05}, "output": {"root": -0.7390851332151626, "error": 9.283415614014245e-08}}, {"input": {"x0": 1.9087712398382823, "tol": 0.0001762529827130261}, "output": {"root": -0.7390851333933468, "error": 2.8407690450760192e-05}}, {"input": {"x0": -7.399673312643427, "tol": 0.0002890117636757456}, "output": {"root": -0.7390851348159658, "error": 8.51482321082564e-05}}, {"input": {"x0": 4.910421464400212, "tol": 4.0902112791823335e-05}, "output": {"root": -0.7390851332151774, "error": 2.7590242634989437e-07}}, {"input": {"x0": 6.630430109186818, "tol": 9.108170477091738e-06}, "output": {"root": -0.7390851332151607, "error": 4.3964820672925953e-10}}, {"input": {"x0": -1.7757834017271286, "tol": 4.229340300745084e-06}, "output": {"root": -0.7390851332151608, "error": 1.780015279617686e-08}}, {"input": {"x0": -4.364480003852417, "tol": 0.00073695648300736}, "output": {"root": -0.7390851332157469, "error": 1.6293840473524668e-06}}, {"input": {"x0": -6.7742884968033685, "tol": 0.00023970595158259383}, "output": {"root": -0.7390851332547246, "error": 1.3385883259831033e-05}}, {"input": {"x0": -5.446701326927199, "tol": 8.526082683380787e-06}, "output": {"root": -0.7390851332151607, "error": 1.474775135346107e-08}}], "error_log": []}
{"context": "Given a plaintext message, how can we securely encrypt it using the RSA algorithm and then decrypt it back to the original message? Specifically, what are the encrypted and decrypted versions of the message?\n\nThe input and output requirements are as follows:\n\nInput:\n  `plaintext` (str): A string representing the plaintext message to be encrypted. The string should be in UTF-8 format.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `encrypted_text` (list of int): A list of integers representing the encrypted message.\n    - `decrypted_text` (str): A string representing the decrypted message, which should match the original plaintext.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef get_Eula(a, b):\n    lx = [1, 0, b]\n    ly = [0, 1, a]\n    while ly[2] != 1:\n        if ly[2] == 0:\n            return 0\n        q = lx[2] // ly[2]\n        lt = [lx[i] - ly[i] * q for i in range(3)]\n        lx = ly\n        ly = lt\n    return ly[1] % b\n\ndef coprime(a, b):\n    if a < b:\n        a, b = b, a\n    while b != 0:\n        t = a % b\n        a = b\n        b = t\n    return (a, b)\n\ndef get_e(e_n):\n    flag = 1\n    while flag:\n        e = random.randrange(e_n)\n        if coprime(e, e_n) == (1, 0):\n            flag = 0\n    return e\n\ndef encrypt(plaintext, n, e):\n    ciphertext = [pow(c, e, n) for c in plaintext]\n    return ciphertext\n\ndef decrypt(ciphertext, d, n):\n    plaintext = [pow(c, d, n) for c in ciphertext]\n    return plaintext\n\ndef AKS(a, n):\n    if pow(17 - a, n, n) == pow(17, n, n) - (a % n):\n        return 1\n    else:\n        return 0\n\ndef big_rand():\n    flag = 0\n    l, u = 2**16, 2**32\n    while not flag:\n        n = random.randrange(l, u)\n        if any([n % x == 0 for x in [2, 3, 5, 7, 13]]):\n            continue\n        flag = AKS(2, n)\n    return n\n\ndef get_key():\n    p = big_rand()\n    q = big_rand()\n    n = p * q\n    e_n = n - p - q + 1\n    e = get_e(e_n)\n    d = get_Eula(e, e_n)\n    return [e, n, e_n, d, p, q]\n\n# main function\ndef main_solution(plaintext):\n    # Convert plaintext to a list of integers representing UTF-8 characters\n    plaintext_int = [ord(char) for char in plaintext]\n    \n    # Generate RSA keys\n    k = get_key()\n    e, n, d = k[0], k[1], k[3]\n    \n    # Encrypt the plaintext\n    encrypted_text = encrypt(plaintext_int, n, e)\n    \n    # Decrypt the ciphertext\n    decrypted_text_int = decrypt(encrypted_text, d, n)\n    \n    # Convert decrypted integers back to characters\n    decrypted_text = ''.join(chr(char) for char in decrypted_text_int)\n    \n    # Return the encrypted and decrypted texts\n    return {\"encrypted_text\": encrypted_text, \"decrypted_text\": decrypted_text}", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random plaintext of reasonable length (e.g., 5 to 20 characters)\n    length = random.randint(5, 20)\n    plaintext = ''.join(random.choice(string.ascii_letters + string.digits + ' ') for _ in range(length))\n    \n    return {\"plaintext\": plaintext}", "io_pairs": [{"input": {"plaintext": "ApXe5T4"}, "output": {"encrypted_text": [7090087153008820302, 5370868597247957225, 5105519983987143784, 9024673950330660267, 6231612185170495754, 1510650589343527466, 7687053666140882087], "decrypted_text": "ApXe5T4"}}, {"input": {"plaintext": "rKS5em"}, "output": {"encrypted_text": [6971269044502002727, 5923363350539823238, 4759275214188230060, 6261040713810508684, 5994852015749315287, 4642309574173503469], "decrypted_text": "rKS5em"}}, {"input": {"plaintext": "EDQ1PJFm"}, "output": {"encrypted_text": [51199630967254274, 36083613234213526, 116163755268078919, 142756850070885226, 138711952743204554, 134636324131623101, 22330422012418193, 21012484705853491], "decrypted_text": "EDQ1PJFm"}}, {"input": {"plaintext": "0pIa1fTtXu"}, "output": {"encrypted_text": [1041739573308976755, 120744375106601912, 655923405336961131, 913216137406284930, 201641664648811282, 603064097235537722, 49100446674865719, 578235405684850188, 692361577306424343, 1110784824285125602], "decrypted_text": "0pIa1fTtXu"}}, {"input": {"plaintext": "HC32F1ErL"}, "output": {"encrypted_text": [1192458677460178766, 4343734493998581985, 457991361192960817, 296728975021104656, 1775581926761860657, 1702339202941299083, 947718596010165784, 2419317886533425405, 5111702774452410248], "decrypted_text": "HC32F1ErL"}}, {"input": {"plaintext": "VKNNJofTZH8cQ"}, "output": {"encrypted_text": [804926976577451317, 687327596009874845, 225924347642100119, 225924347642100119, 1015022340091605791, 84886408678879504, 43009249564959781, 563027289830540341, 405432566324756583, 195314762649534355, 899089464911541880, 542472606462952838, 185628997750909084], "decrypted_text": "VKNNJofTZH8cQ"}}, {"input": {"plaintext": "oIFYe60EOTq"}, "output": {"encrypted_text": [6468548229404607266, 2537353668222765638, 163900987429727284, 5224334239642952617, 131058778620276251, 825120969741239287, 6154158077555599110, 1935029607333755571, 1266046339242261980, 6257131651910731797, 1981488490758476011], "decrypted_text": "oIFYe60EOTq"}}, {"input": {"plaintext": "cVQvQ3AhZerv"}, "output": {"encrypted_text": [1215907236054837811, 1234835663082700466, 317793979710697566, 59827296561320360, 317793979710697566, 1052287160343549614, 1237034707612664490, 703073012421996123, 1331208972450463997, 977293902191274165, 44096828517052180, 59827296561320360], "decrypted_text": "cVQvQ3AhZerv"}}, {"input": {"plaintext": "R21xpuyUeoPs"}, "output": {"encrypted_text": [3770004592451811665, 8871681176012357378, 437455966268784542, 7425697282562090851, 4038486211775860071, 4563187272927142115, 867790295954927597, 7614980550147055535, 1006844482963894860, 53642246458177478, 2273796922679086671, 51460919257274114], "decrypted_text": "R21xpuyUeoPs"}}, {"input": {"plaintext": "WsX6MnCe6DvTu7"}, "output": {"encrypted_text": [117712609988732974, 82011731385433039, 26222873331784076, 22344786986422172, 167283317899001844, 101598900073483227, 113596460109445593, 109966231045693558, 22344786986422172, 145435014357850710, 150509456042869571, 159893248962872759, 151951975243713765, 119419821822529454], "decrypted_text": "WsX6MnCe6DvTu7"}}], "error_log": []}
{"context": "Given a specific location defined by its latitude and longitude coordinates, how can we determine the numerical grid references that cover a certain radius around this location, suitable for indexing in a relational database?\n\nThe input and output requirements are as follows:\n\nInput:\n  `latitude` (float): The latitude coordinate of the location.\n  `longitude` (float): The longitude coordinate of the location.\n  `grid_size` (int, optional): The size of the grid. Default is 1000.\n  `distance_units` (str, optional): The units for distance ('K' for kilometers, 'M' for miles, 'N' for nautical miles). Default is 'K'.\n  `radius` (int, optional): The radius around the location to consider for grid references. Default is 0.\n\nOutput:\n  `return` (list of int): A list of grid references corresponding to the given latitude and longitude coordinates within the specified radius.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass GridLatLong(object):\n\n    grid_size = 1000\n    distance_units = 'K'\n    earth_radius = 6378.1\n\n    def __init__(self, grid_size=1000, distance_units='K'):\n        self.grid_size = grid_size\n        self.distance_units = distance_units\n\n        if self.distance_units == 'N':\n            self.earth_radius = 3441.6147438\n        elif self.distance_units == 'M':\n            self.earth_radius = 3963.1676\n        else:\n            self.earth_radius = 6378.1\n\n    def get_grid_references(self, lat_long, radius=0):\n        bounding_north = self.get_internal_grid_reference(self.add_lat_long(lat_long, 0, radius))\n        bounding_east = self.get_internal_grid_reference(self.add_lat_long(lat_long, 90, radius))\n        bounding_south = self.get_internal_grid_reference(self.add_lat_long(lat_long, 180, radius))\n        bounding_west = self.get_internal_grid_reference(self.add_lat_long(lat_long, 270, radius))\n        references = []\n\n        for lat in range(bounding_south[0], bounding_north[0] + 1):\n            for lon in range(bounding_west[1], bounding_east[1] + 1):\n                references.append(((lat + lon) * (lat + lon + 1)) / 2 + lon)\n\n        return references\n\n    def add_lat_long(self, lat_long, bearing, distance):\n        lat1 = math.radians(float(lat_long[0]))\n        lon1 = math.radians(float(lat_long[1]))\n        brng = math.radians(float(bearing))\n        dst = float(distance)\n\n        lat2 = math.asin(math.sin(lat1) * math.cos(dst / self.earth_radius) + math.cos(lat1) * math.sin(dst / self.earth_radius) * math.cos(brng))\n        lon2 = lon1 + math.atan2(math.sin(brng)*math.sin(dst / self.earth_radius)*math.cos(lat1), math.cos(dst / self.earth_radius)-math.sin(lat1) * math.sin(lat2))\n\n        return (math.degrees(lat2), math.degrees(lon2))\n\n    def get_internal_grid_reference(self, lat_long):\n        grid_latitude = math.floor((float(self.grid_size) / 180.0) * (90.0 + float(lat_long[0])))\n        grid_longitude = math.floor((float(self.grid_size) / 360.0) * (180.0 + float(lat_long[1])))\n        return (int(grid_latitude), int(grid_longitude))\n\n# main function\ndef main_solution(latitude, longitude, grid_size=1000, distance_units='K', radius=0):\n    # Convert JSON serializable inputs to the original input variables\n    lat_long = (float(latitude), float(longitude))\n    \n    # Initialize the GridLatLong object\n    gll = GridLatLong(grid_size, distance_units)\n    \n    # Get the grid references\n    references = gll.get_grid_references(lat_long, radius)\n    \n    # Convert the output to JSON serializable format\n    return references", "input_generator": "import random\n\ndef input_generator():\n    # Generate random latitude and longitude within valid ranges\n    latitude = random.uniform(-90, 90)\n    longitude = random.uniform(-180, 180)\n    \n    # Randomly choose grid_size, distance_units, and radius\n    grid_size = random.choice([100, 500, 1000, 2000])\n    distance_units = random.choice(['K', 'M', 'N'])\n    radius = random.uniform(0, 100)  # Reasonable radius in kilometers\n    \n    return {\n        'latitude': latitude,\n        'longitude': longitude,\n        'grid_size': grid_size,\n        'distance_units': distance_units,\n        'radius': radius\n    }", "io_pairs": [{"input": {"latitude": -26.951968216482733, "longitude": -47.579596105817984, "grid_size": 100, "distance_units": "M", "radius": 36.40204127382618}, "output": [2521.0, 2592.0]}, {"input": {"latitude": 20.352132557212883, "longitude": 57.47019655695516, "grid_size": 500, "distance_units": "M", "radius": 11.426575445167764}, "output": [202259.0, 202896.0]}, {"input": {"latitude": -18.520900397128827, "longitude": 121.42863131664416, "grid_size": 500, "distance_units": "N", "radius": 53.111604344796525}, "output": [188608.0, 189223.0, 189839.0, 189222.0, 189838.0, 190455.0, 189837.0, 190454.0, 191072.0, 190453.0, 191071.0, 191690.0, 191070.0, 191689.0, 192309.0, 191688.0, 192308.0, 192929.0]}, {"input": {"latitude": -45.68299931103861, "longitude": -29.7910621250154, "grid_size": 1000, "distance_units": "M", "radius": 1.0568309992682656}, "output": [220533.0]}, {"input": {"latitude": -76.67071306486393, "longitude": -126.62082220444555, "grid_size": 100, "distance_units": "K", "radius": 32.096900006819084}, "output": [245.0, 268.0]}, {"input": {"latitude": -52.53645689504469, "longitude": 80.55619675122404, "grid_size": 2000, "distance_units": "M", "radius": 6.724632858445889}, "output": [1734037.0, 1735900.0, 1737764.0, 1735899.0, 1737763.0, 1739628.0, 1737762.0, 1739627.0, 1741493.0]}, {"input": {"latitude": -63.97724019186086, "longitude": -144.5450460671628, "grid_size": 100, "distance_units": "M", "radius": 2.827479087316598}, "output": [285.0]}, {"input": {"latitude": -26.30361567693025, "longitude": -154.3077580461127, "grid_size": 2000, "distance_units": "N", "radius": 1.0771010086294441}, "output": [360967.0]}, {"input": {"latitude": -7.773721545589467, "longitude": -145.8372805546894, "grid_size": 500, "distance_units": "K", "radius": 22.11031874549042}, "output": [37722.0, 37997.0]}, {"input": {"latitude": 77.81035885280298, "longitude": -179.62301334193572, "grid_size": 2000, "distance_units": "M", "radius": 7.526256421336608}, "output": [1734452.0, 1736316.0, 1738181.0, 1740047.0, 1741914.0, 1743782.0, 1736315.0, 1738180.0, 1740046.0, 1741913.0, 1743781.0, 1745650.0, 1738179.0, 1740045.0, 1741912.0, 1743780.0, 1745649.0, 1747519.0]}], "error_log": []}
{"context": "Given a range of integers, what are the prime numbers that can be found within that range?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start_range` (int): The starting integer of the range within which to check for prime numbers.\n  `end_range` (int): The ending integer of the range within which to check for prime numbers.\n\nOutput:\n  `return` (list of int): A list of prime numbers found within the specified range.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef isPrime(possibleDivisor, n):\n    \"\"\"Determine if input n is prime.\"\"\"\n    if n < 2:\n        return False\n    if possibleDivisor == n:\n        return True\n    if n % possibleDivisor == 0:\n        return False\n    if possibleDivisor >= math.sqrt(n):\n        return True\n    return isPrime(possibleDivisor + 1, n)\n\n# main function\ndef main_solution(start_range, end_range):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    results = []\n    for n in range(start_range, end_range + 1):\n        if isPrime(2, n):\n            results.append(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return results", "input_generator": "import random\n\ndef input_generator():\n    start = random.randint(0, 100)\n    end = start + random.randint(1, 100)\n    return {'start_range': start, 'end_range': end}", "io_pairs": [{"input": {"start_range": 48, "end_range": 125}, "output": [53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113]}, {"input": {"start_range": 51, "end_range": 123}, "output": [53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113]}, {"input": {"start_range": 11, "end_range": 67}, "output": [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]}, {"input": {"start_range": 63, "end_range": 129}, "output": [67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127]}, {"input": {"start_range": 87, "end_range": 136}, "output": [89, 97, 101, 103, 107, 109, 113, 127, 131]}, {"input": {"start_range": 50, "end_range": 115}, "output": [53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113]}, {"input": {"start_range": 6, "end_range": 22}, "output": [7, 11, 13, 17, 19]}, {"input": {"start_range": 27, "end_range": 51}, "output": [29, 31, 37, 41, 43, 47]}, {"input": {"start_range": 98, "end_range": 126}, "output": [101, 103, 107, 109, 113]}, {"input": {"start_range": 68, "end_range": 122}, "output": [71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113]}], "error_log": []}
{"context": "Given a real number `x` and an integer `y`, what is the rational approximation of `x` obtained by running the Farey algorithm for `y` iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (float): The number for which a rational approximation is to be found.\n  `y` (int): The number of iterations to run the Farey algorithm, which affects the accuracy of the approximation.\n\nOutput:\n  `return` (str): A string representation of the rational approximation of `x` in the form of a fraction.", "reference_code": "# import necessary packages\nimport math\nimport numpy as np\nfrom fractions import Fraction as frac\n\n# main function\ndef main_solution(x, y):\n    \"\"\"\n    Takes a number x as input then uses the Farey algorithm to find a rational approximation of x.\n    y is the number of times the loop runs and thus is directly related to the accuracy of the approximation.\n    \"\"\"\n    z = x - int(x)\n    a = [0, 1]\n    b = [1, 1]\n    for i in range(y):\n        c = [a[0] + b[0], a[1] + b[1]]\n        if z > c[0] / c[1]:\n            a = c\n        elif z < c[0] / c[1]:\n            b = c\n    rational_approximation = frac(int(x) * c[1] + c[0], c[1])\n    return str(rational_approximation)", "input_generator": "import random\nimport math\n\ndef input_generator():\n    x = random.uniform(0, 100)  # Random float between 0 and 100\n    y = random.randint(1, 20)   # Random integer between 1 and 20\n    return {'x': x, 'y': y}", "io_pairs": [{"input": {"x": 21.206911692341624, "y": 11}, "output": "1739/82"}, {"input": {"x": 56.037236283386285, "y": 12}, "output": "729/13"}, {"input": {"x": 87.457811828036, "y": 14}, "output": "26937/308"}, {"input": {"x": 25.325559351134697, "y": 19}, "output": "4280/169"}, {"input": {"x": 6.278344937761182, "y": 2}, "output": "19/3"}, {"input": {"x": 62.11910577771168, "y": 9}, "output": "1056/17"}, {"input": {"x": 25.738667945496264, "y": 20}, "output": "55647/2162"}, {"input": {"x": 69.99792056869431, "y": 2}, "output": "209/3"}, {"input": {"x": 76.9849509522203, "y": 17}, "output": "1385/18"}, {"input": {"x": 64.33970375843239, "y": 6}, "output": "901/14"}], "error_log": []}
{"context": "On an 8x8 chessboard, three pieces\u2014a queen, a rook, and a knight\u2014are placed at specific coordinates. Each piece can attack multiple fields on the board. Given the coordinates of these three pieces, how many unique fields on the chessboard are under attack by at least one of these pieces?\n\nThe input and output requirements are as follows:\n\nInput:\n  `queen_coords` (str): A string representing the coordinates of the queen on a chessboard. The format is a single letter (from 'a' to 'h') followed by a single digit (from '1' to '8').\n  `rook_coords` (str): A string representing the coordinates of the rook on a chessboard. The format is a single letter (from 'a' to 'h') followed by a single digit (from '1' to '8').\n  `knight_coords` (str): A string representing the coordinates of the knight on a chessboard. The format is a single letter (from 'a' to 'h') followed by a single digit (from '1' to '8').\n\nOutput:\n  `return` (int): An integer representing the total number of unique fields on the chessboard that are under attack by the queen, rook, and knight.", "reference_code": "# import necessary packages\nfrom typing import List, Union, Set\nimport random\n\n# all class and function definitions in the code file, if any\ndef get_rook_attack_fields(v: str, h: int) -> List[str]:\n    coords = []\n    for i in range(1, 9):\n        if i == h:\n            continue\n        coords.append(f\"{v}{i}\")\n\n    for i in range(97, 105):  # 'a' and 'h' in ascii respectively\n        if ord(v) == i:\n            continue\n        coords.append(f\"{chr(i)}{h}\")\n\n    return coords\n\n\ndef get_bishop_attack_fields(v: str, h: int) -> List[str]:\n    coords = []\n    cur_vertical = ord(v)\n    cur_horizontal = h\n    while cur_vertical < ord('h') and cur_horizontal < 9:\n        cur_vertical += 1\n        cur_horizontal += 1\n        field = f\"{chr(cur_vertical)}{cur_horizontal}\"\n        coords.append(field)\n\n    cur_vertical = ord(v)\n    cur_horizontal = h\n    while cur_vertical >= ord('a') and cur_horizontal > 1:\n        cur_vertical -= 1\n        cur_horizontal -= 1\n        field = f\"{chr(cur_vertical)}{cur_horizontal}\"\n        coords.append(field)\n\n    cur_vertical = ord(v)\n    cur_horizontal = h\n    while cur_vertical > ord('a') and cur_horizontal < 9:\n        cur_vertical -= 1\n        cur_horizontal += 1\n        field = f\"{chr(cur_vertical)}{cur_horizontal}\"\n        coords.append(field)\n\n    cur_vertical = ord(v)\n    cur_horizontal = h\n    while cur_vertical < ord('i') and cur_horizontal > 1:\n        cur_vertical += 1\n        cur_horizontal -= 1\n        field = f\"{chr(cur_vertical)}{cur_horizontal}\"\n        coords.append(field)\n\n    return coords\n\n\ndef get_knight_attack_fields(v: str, h: int) -> Set[str]:\n    fields = []\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    for move in moves:\n        new_v = ord(v) + move[0]\n        new_h = h + move[1]\n        if 97 <= new_v <= 104 and 1 <= new_h <= 8:\n            fields.append(f\"{chr(new_v)}{new_h}\")\n\n    return set(fields)\n\n\ndef get_queen_attack_fields(v: str, h: int) -> Set[str]:\n    queen_fields = []\n    queen_fields.extend(get_rook_attack_fields(v, h))\n    queen_fields.extend(get_bishop_attack_fields(v, h))\n\n    return set(queen_fields)\n\n\ndef get_pawn_attack_fields(v: str, h: int) -> Set[str]:\n    coords = []\n    if ord(v) > ord('a') and h > 1:\n        coords.append(f\"{chr(ord(v) - 1)}{h - 1}\")\n    if ord(v) < ord('h') and h > 1:\n        coords.append(f\"{chr(ord(v) + 1)}{h - 1}\")\n\n    return set(coords)\n\n\ndef get_fields_under_attack(piece: str, field: str) -> List[str]:\n    v, h = list(field)\n    h = int(h)\n    if piece == 'queen':\n        fields = get_queen_attack_fields(v, h)\n    elif piece == 'rook':\n        fields = get_rook_attack_fields(v, h)\n    elif piece == 'bishop':\n        fields = get_bishop_attack_fields(v, h)\n    elif piece == 'knight':\n        fields = get_knight_attack_fields(v, h)\n    elif piece == 'pawn':\n        fields = get_pawn_attack_fields(v, h)\n    else:\n        fields = []\n\n    return sorted(fields)\n\n# main function\ndef main_solution(queen_coords: str, rook_coords: str, knight_coords: str) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    queen_fields = get_fields_under_attack('queen', queen_coords)\n    rook_fields = get_fields_under_attack('rook', rook_coords)\n    knight_fields = get_fields_under_attack('knight', knight_coords)\n\n    all_fields = set(queen_fields + rook_fields + knight_fields)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return len(all_fields)", "input_generator": "import random\n\ndef input_generator():\n    verticals = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n    horizontals = [1, 2, 3, 4, 5, 6, 7, 8]\n    \n    queen_coords = f\"{random.choice(verticals)}{random.choice(horizontals)}\"\n    rook_coords = f\"{random.choice(verticals)}{random.choice(horizontals)}\"\n    knight_coords = f\"{random.choice(verticals)}{random.choice(horizontals)}\"\n    \n    return {\n        'queen_coords': queen_coords,\n        'rook_coords': rook_coords,\n        'knight_coords': knight_coords\n    }", "io_pairs": [{"input": {"queen_coords": "h5", "rook_coords": "h1", "knight_coords": "e4"}, "output": 36}, {"input": {"queen_coords": "d3", "rook_coords": "f3", "knight_coords": "d3"}, "output": 37}, {"input": {"queen_coords": "a5", "rook_coords": "g7", "knight_coords": "d2"}, "output": 40}, {"input": {"queen_coords": "d7", "rook_coords": "g2", "knight_coords": "h1"}, "output": 38}, {"input": {"queen_coords": "h3", "rook_coords": "b8", "knight_coords": "b1"}, "output": 35}, {"input": {"queen_coords": "h7", "rook_coords": "g5", "knight_coords": "h6"}, "output": 32}, {"input": {"queen_coords": "g4", "rook_coords": "d1", "knight_coords": "g6"}, "output": 40}, {"input": {"queen_coords": "a5", "rook_coords": "e2", "knight_coords": "e5"}, "output": 41}, {"input": {"queen_coords": "a3", "rook_coords": "c8", "knight_coords": "b3"}, "output": 34}, {"input": {"queen_coords": "g5", "rook_coords": "e1", "knight_coords": "c4"}, "output": 38}], "error_log": []}
{"context": "Given the sizes of packages available for buying McNuggets (6, 9, and 20), what is the combination of package quantities (a, b, c) that allows you to buy exactly `n` McNuggets, and can `n` McNuggets be bought in exact quantity?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of McNuggets to check if they can be bought in exact quantity using the given package sizes.\n  `packages` (list of int): A list containing the sizes of the packages available for buying McNuggets.\n\nOutput:\n  `return` (dict): A dictionary with the following keys:\n    - `can_be_bought` (bool): Indicates whether the number of McNuggets can be bought in exact quantity.\n    - `coefficients` (list of int or None): If `can_be_bought` is True, this contains the coefficients [a, b, c] such that `a*packages[0] + b*packages[1] + c*packages[2] = n`. If `can_be_bought` is False, this is None.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef find_consecutive(l):\n    # INPUTS: l, a list \n    # This function looks at list with 6 number\n    # and checks if those numbers are consecutive\n    if l[0:6] == list(range(l[0], l[0]+6)):\n        return True\n    return False\n\ndef finding_packages(n, l, non_solutions, packages):\n    for a in range(0, round(n/packages[0])+2):\n        for b in range(0, round(n/packages[1])+2):\n            for c in range(0, round(n/packages[2])+2):\n                coeff = [a, b, c]\n                products = sum([x * y for x, y in zip(list(packages), coeff)])\n                if products == n:\n                    l.append(products)\n                    return coeff\n    return non_solutions.append(n)\n\n# main function\ndef main_solution(n, packages):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    l = []\n    non_solutions = []\n    result = finding_packages(n, l, non_solutions, packages)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if result is None:\n        return {\"can_be_bought\": False, \"coefficients\": None}\n    else:\n        return {\"can_be_bought\": True, \"coefficients\": result}", "input_generator": "import random\n\ndef input_generator():\n    packages_options = [\n        [6, 9, 20],\n        [5, 10, 15],\n        [4, 7, 11],\n        [3, 5, 8],\n        [2, 3, 5]\n    ]\n    packages = random.choice(packages_options)\n    n = random.randint(1, 100)\n    return {\"n\": n, \"packages\": packages}", "io_pairs": [{"input": {"n": 59, "packages": [5, 10, 15]}, "output": {"can_be_bought": false, "coefficients": null}}, {"input": {"n": 24, "packages": [2, 3, 5]}, "output": {"can_be_bought": true, "coefficients": [0, 3, 3]}}, {"input": {"n": 53, "packages": [4, 7, 11]}, "output": {"can_be_bought": true, "coefficients": [0, 6, 1]}}, {"input": {"n": 8, "packages": [3, 5, 8]}, "output": {"can_be_bought": true, "coefficients": [0, 0, 1]}}, {"input": {"n": 31, "packages": [3, 5, 8]}, "output": {"can_be_bought": true, "coefficients": [0, 3, 2]}}, {"input": {"n": 43, "packages": [5, 10, 15]}, "output": {"can_be_bought": false, "coefficients": null}}, {"input": {"n": 71, "packages": [3, 5, 8]}, "output": {"can_be_bought": true, "coefficients": [0, 3, 7]}}, {"input": {"n": 11, "packages": [6, 9, 20]}, "output": {"can_be_bought": false, "coefficients": null}}, {"input": {"n": 41, "packages": [6, 9, 20]}, "output": {"can_be_bought": true, "coefficients": [2, 1, 1]}}, {"input": {"n": 20, "packages": [4, 7, 11]}, "output": {"can_be_bought": true, "coefficients": [5, 0, 0]}}], "error_log": []}
{"context": "In a game of poker, a player and an AI are each dealt 5 cards. The player has the option to swap up to 5 cards with new ones from the deck. After the swap, the hands are compared to determine the winner based on the ranking of the poker hands. Given the player's name and the positions of the cards they want to swap, what is the result of the round and does the AI win?\n\nThe input and output requirements are as follows:\n\nInput:\n  `player_name` (str): The name of the player.\n  `swap_positions` (list of int): A list of positions (1-5) of the cards the player wants to swap.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `AI_win` (bool): True if the AI wins, False otherwise.\n    - `result` (str): A string describing the result of the round.", "reference_code": "# import necessary packages\nfrom random import shuffle\nimport operator\nimport copy\n\n# all class and function definitions in the code file, if any\nclass Card:\n    suits = [\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"]\n    ranks = [\n        \"narf\",\n        \"Ace\",\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"10\",\n        \"Jack\",\n        \"Queen\",\n        \"King\"]\n\n    def __init__(self, suit=0, rank=0):\n        self.suit = suit\n        self.rank = rank\n\n    def __str__(self):\n        return f'{self.ranks[self.rank]} of {self.suits[self.suit]}'\n\n\nclass Deck:\n    def __init__(self):\n        self.cards = []\n        self.build_deck()\n        self.shuffle()\n\n    def build_deck(self):\n        for suit in range(0, 4):\n            for rank in range(1, 14):\n                self.cards.append(Card(suit, rank))\n\n    def shuffle(self):\n        shuffle(self.cards)\n\n    def deal(self):\n        return self.cards.pop()\n\n\nclass Hand(Deck):\n    def __init__(self, name=''):\n        self.cards = []\n        self.name = name\n\n    def deal(self, deck, cards):\n        while len(self.cards) < cards:\n            self.cards.append(deck.deal())\n        self.sort_hand()\n\n    def sort_hand(self):\n        self.cards.sort(key=operator.attrgetter('rank'))\n\n    def get_cards(self):\n        return self.cards\n\n    def swap_cards(self, deck, positions):\n        for pos in positions:\n            self.cards.pop(pos-1)\n            self.cards.insert(pos-1, deck.deal())\n        self.sort_hand()\n\n\nclass Ranking:\n    rankings = [\n        'High Card',\n        'Pair',\n        'Two Pair',\n        'Trips',\n        'Straight',\n        'Flush',\n        'Full House',\n        'Quads',\n        'narf',\n        'Straight Flush'\n    ]\n\n    def rank_hand(self, hand):\n        value = 0\n        value += self.flush(hand)\n        value += self.straight(hand)\n        if value == 0:\n            rank_value, _ = self.two_three_four(hand)\n            value += rank_value\n        return value, self.rankings[value]\n\n    def flush(self, hand):\n        value = 0\n        flush = True\n        for card in hand.get_cards():\n            if 'previous_suit' in locals():\n                if card.suit != previous_suit:\n                    flush = False\n            previous_suit = card.suit\n        if(flush):\n            value = 5\n        return value\n\n    def straight(self, hand):\n        value = 0\n        connected = 0\n        for card in hand.get_cards():\n            if 'previous_rank' in locals():\n                if card.rank == 1:\n                    if card.rank == previous_rank + 1 or card.rank == previous_rank + 9:\n                        connected += 1\n                else:\n                    if card.rank == previous_rank + 1:\n                        connected += 1\n            previous_rank = card.rank\n        if connected == 4:\n            value = 4\n        return value\n\n    def two_three_four(self, hand):\n        value = 0\n        first_card = self.determine_first_card_in_set(hand)\n        first_card_rank = 0\n        second_card = None\n        same = 0\n        first_same = 0\n        if first_card is not None:\n            first_card_rank = first_card.rank\n        for card in hand.get_cards():\n            if 'previous_rank' in locals():\n                if card.rank == previous_rank:\n                    same += 1\n                    if card.rank == first_card_rank:\n                        first_same += 1\n                    else:\n                        second_card = card\n            previous_rank = card.rank\n        if same == 3 and first_same == 3:\n            value = 7\n        if same == 3 and first_same != 3:\n            value = 6\n        if same == 2 and first_same == 2:\n            value = 3\n        if same == 2 and first_same != 2:\n            value = 2\n        if same == 1:\n            value = 1\n        return value, second_card\n\n    def determine_first_card_in_set(self, hand):\n        return_card = None\n        cards_to_copy = hand.get_cards()\n        cards = copy.deepcopy(cards_to_copy)\n        card_found = False\n        for i in range(4):\n            if not card_found:\n                card = cards.pop(0)\n                for c in cards:\n                    if card.rank == c.rank:\n                        return_card = card\n                        card_found = True\n                        break\n        return return_card\n\n    def get_highcard(self, hand):\n        cards = hand.get_cards()\n        if cards[0].rank == 1:\n            return cards[0]\n        else:\n            return cards[4]\n\n    def determine_winner(self, player_hand, AI_hand):\n        player_value, player_ranking = self.rank_hand(player_hand)\n        AI_value, AI_ranking = self.rank_hand(AI_hand)\n        result = ''\n        AI_win = False\n        if player_value > AI_value:\n            result = f'{player_hand.name} wins the round with a {player_ranking}.'\n        elif AI_value > player_value:\n            AI_win = True\n            result = f'{AI_hand.name} wins the round with a {AI_ranking}.'\n        else:\n            AI_win = self.tiebreak(player_hand, AI_hand, player_value)\n            if not AI_win:\n                result = f'{player_hand.name} wins the round with a better {player_ranking}.'\n            else:\n                result = f'{AI_hand.name} wins the round with a better {AI_ranking}.'\n        return AI_win, result\n\n    def tiebreak(self, player_hand, AI_hand, value):\n        AI_win = False\n        if value == 9 or value == 5:\n            if AI_hand.get_cards()[0].suit > player_hand.get_cards()[0].suit:\n                AI_win = True\n\n        if value == 7 or value == 3 or value == 1:\n            player_set = self.determine_first_card_in_set(player_hand)\n            AI_set = self.determine_first_card_in_set(AI_hand)\n            if AI_set.rank == 1 and player_set.rank != 1:\n                AI_win = True\n            if player_set.rank != 1:\n                if AI_set.rank > player_set.rank:\n                    AI_win = True\n\n        if value == 6 or value == 2:\n            player_rank, player_trips = self.two_three_four(player_hand)\n            AI_rank, AI_trips = self.two_three_four(AI_hand)\n            player_set = self.determine_first_card_in_set(player_hand)\n            AI_set = self.determine_first_card_in_set(AI_hand)\n            if AI_set.rank == 1 and player_set.rank != 1:\n                AI_win = True\n            if player_set.rank != 1:\n                if AI_trips.rank > player_trips.rank:\n                    AI_win = True\n                if AI_trips.rank == player_trips.rank:\n                    player_highcard = self.get_highcard(player_hand)\n                    AI_highcard = self.get_highcard(AI_hand)\n                    if AI_highcard.rank > player_highcard.rank:\n                        AI_win = True\n                    if AI_highcard.rank == player_highcard.rank:\n                        if AI_highcard.suit > player_highcard.suit:\n                            AI_win = True\n\n        if value == 4 or value == 0:\n            player_highcard = self.get_highcard(player_hand)\n            AI_highcard = self.get_highcard(AI_hand)\n            if AI_highcard.rank == 1 and player_highcard.rank != 1:\n                AI_win = True\n            if player_highcard.rank != 1:\n                if AI_highcard.rank > player_highcard.rank:\n                    AI_win = True\n            if AI_highcard.rank == player_highcard.rank:\n                if AI_highcard.suit > player_highcard.suit:\n                    AI_win = True\n        return AI_win\n\n# main function\ndef main_solution(player_name, swap_positions):\n    deck = Deck()\n    player_hand = Hand(player_name)\n    AI_hand = Hand('AI')\n    player_hand.deal(deck, 5)\n    AI_hand.deal(deck, 5)\n    player_hand.swap_cards(deck, swap_positions)\n    ranking = Ranking()\n    AI_win, result = ranking.determine_winner(player_hand, AI_hand)\n    return {\"AI_win\": AI_win, \"result\": result}", "input_generator": "import random\nfrom random import randint\n\ndef input_generator():\n    player_names = [\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\", \"Frank\", \"Grace\", \"Heidi\"]\n    player_name = random.choice(player_names)\n    \n    # Generate between 0 and 3 swap positions, each between 1 and 5\n    num_swaps = randint(0, 3)\n    swap_positions = random.sample(range(1, 6), num_swaps) if num_swaps > 0 else []\n    \n    return {\n        \"player_name\": player_name,\n        \"swap_positions\": swap_positions\n    }", "io_pairs": [{"input": {"player_name": "Charlie", "swap_positions": [5, 4]}, "output": {"AI_win": false, "result": "Charlie wins the round with a better Pair."}}, {"input": {"player_name": "Frank", "swap_positions": [5, 3, 4]}, "output": {"AI_win": false, "result": "Frank wins the round with a Pair."}}, {"input": {"player_name": "Grace", "swap_positions": [1]}, "output": {"AI_win": false, "result": "Grace wins the round with a Pair."}}, {"input": {"player_name": "Grace", "swap_positions": []}, "output": {"AI_win": true, "result": "AI wins the round with a better Pair."}}, {"input": {"player_name": "Charlie", "swap_positions": [1, 4, 3]}, "output": {"AI_win": false, "result": "Charlie wins the round with a better Pair."}}, {"input": {"player_name": "Grace", "swap_positions": [4, 2]}, "output": {"AI_win": false, "result": "Grace wins the round with a Pair."}}, {"input": {"player_name": "Heidi", "swap_positions": []}, "output": {"AI_win": true, "result": "AI wins the round with a Pair."}}, {"input": {"player_name": "Eve", "swap_positions": [3, 2, 1]}, "output": {"AI_win": true, "result": "AI wins the round with a better High Card."}}, {"input": {"player_name": "David", "swap_positions": [1]}, "output": {"AI_win": true, "result": "AI wins the round with a better Pair."}}, {"input": {"player_name": "Alice", "swap_positions": [1, 3, 5]}, "output": {"AI_win": true, "result": "AI wins the round with a better High Card."}}], "error_log": []}
{"context": "Given a text and parameters for an n-gram model, what is the perplexity of the text when evaluated using an n-gram model with add-k smoothing?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the n-grams.\n  `k` (float): The smoothing parameter for add-k smoothing.\n  `text` (str): The text to be used for updating the model and calculating perplexity.\n\nOutput:\n  `return` (float): The perplexity of the text based on the trained n-gram model.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\nclass NgramModel(object):\n    ''' A basic n-gram model using add-k smoothing '''\n\n    def __init__(self, n, k):\n        self.n = n\n        self.k = k\n        self.vocab = set()\n        self.ngram_probs = {}\n\n    def get_vocab(self):\n        ''' Returns the set of characters in the vocab '''\n        return self.vocab\n\n    def update(self, text):\n        ''' Updates the model n-grams based on text '''\n        probs = self.ngram_probs\n        grams = ngrams(self.n, text)\n        for context, char in grams:\n            self.vocab.add(char)\n            if context in probs:\n                if char in probs[context]:\n                    probs[context][char] += 1\n                else:\n                    probs[context][char] = 1\n            else:\n                probs[context] = {}\n                probs[context][char] = 1\n\n    def prob(self, context, char):\n        ''' Returns the probability of char appearing after context '''\n        probs = self.ngram_probs\n        if context not in probs:\n            return 1 / len(self.vocab)\n        else:\n            total = sum(probs[context].values()) + self.k * len(self.vocab)\n            return (probs[context].get(char, 0) + self.k) / total\n\n    def random_char(self, context):\n        ''' Returns a random character based on the given context and the\n            n-grams learned by this model '''\n        r = random.random()\n        vocab = sorted(self.vocab)\n        prob_sum = 0\n        for v in vocab:\n            prob_sum += self.prob(context, v)\n            if prob_sum > r:\n                return v\n\n    def random_text(self, length):\n        ''' Returns text of the specified character length based on the\n            n-grams learned by this model '''\n        context = '~' * self.n\n        text = ''\n        for _ in range(length):\n            char = self.random_char(context)\n            text += char\n            context = context[1:] + char if self.n > 0 else ''\n        return text\n\n    def perplexity(self, text):\n        ''' Returns the perplexity of text based on the n-grams learned by\n            this model '''\n        N = len(text)\n        log_sum = 0\n        context = '~' * self.n\n        for i in range(N):\n            prob = self.prob(context, text[i])\n            if (prob == 0):\n                return float('inf')\n            log_sum += math.log(prob)\n            context = context[1:] + text[i]\n        return math.exp((-1/N) * log_sum)\n\ndef start_pad(n):\n    ''' Returns a padding string of length n to append to the front of text\n        as a pre-processing step to building n-grams '''\n    return '~' * n\n\ndef ngrams(n, text):\n    ''' Returns the ngrams of the text as tuples where the first element is\n        the length-n context and the second is the character '''\n    padded = start_pad(n) + text\n    ngrams = [tuple((padded[i:n+i],c)) for i,c in enumerate(text)]\n    return ngrams\n\n# main function\ndef main_solution(n, k, text):\n    '''\n    This function creates an n-gram model with add-k smoothing, updates it with the given text,\n    and then calculates the perplexity of the text based on the trained model.\n\n    Parameters:\n    n (int): The size of the n-grams.\n    k (float): The smoothing parameter for add-k smoothing.\n    text (str): The text to be used for updating the model and calculating perplexity.\n\n    Returns:\n    float: The perplexity of the text based on the trained n-gram model.\n    '''\n    model = NgramModel(n, k)\n    model.update(text)\n    perplexity = model.perplexity(text)\n    return perplexity", "input_generator": "import random\nimport string\n\ndef input_generator():\n    n = random.choice([1, 2, 3])\n    k = random.uniform(0.1, 1.0)\n    text_length = random.randint(10, 100)\n    text = ''.join(random.choices(string.ascii_lowercase + ' ', k=text_length))\n    return {'n': n, 'k': k, 'text': text}", "io_pairs": [{"input": {"n": 2, "k": 0.11904150952419988, "text": "tmrqmrvqrbdken m if"}, "output": 2.357285893009053}, {"input": {"n": 2, "k": 0.6669522043874724, "text": "lpvtxlyamqulffwlijk"}, "output": 6.601438863602964}, {"input": {"n": 1, "k": 0.241228615838956, "text": "uwjxywwucemhh pkloycteb bbzxibwzeltwemkfgmfyoh"}, "output": 5.833694836382898}, {"input": {"n": 2, "k": 0.7023438989325752, "text": "xzmvrpurgtpeyxzakhaezumrruhnlepjvgjatnvtkojfgtcfpbzz"}, "output": 9.295406406717579}, {"input": {"n": 1, "k": 0.6837209457529168, "text": "jrzdaphgs epouliylwactgyjpwvxktlwhjgakoveqxzzo"}, "output": 10.458619655627865}, {"input": {"n": 3, "k": 0.8935100667066395, "text": "xyvhhftocwnipwbfdarbyjynnlccxszdlpyenciuhyu "}, "output": 11.381366232573392}, {"input": {"n": 3, "k": 0.9518988812322875, "text": "ldjwxocauiqxfoqsaolxit qekdnhitpvcpp dvktlnhobxfyz znqjcr"}, "output": 12.704281081995301}, {"input": {"n": 3, "k": 0.44442260308483605, "text": "yftktierijjdnvijmo mrzqljihyzutvhcjqwicvpx"}, "output": 7.769000462181315}, {"input": {"n": 2, "k": 0.21261174306719982, "text": "fzcvdzddwiurc gdrnd emk bu"}, "output": 3.63000598851306}, {"input": {"n": 3, "k": 0.49805754648956746, "text": "  wqrbkojrkvipwb gluc wdujmibigzxp msthfqy honiwxrmlgzrqsdcxwrojmqyc ehs"}, "output": 9.311722531231792}], "error_log": []}
{"context": "Given two matrices, what is the resulting matrix after performing matrix multiplication? The matrices are represented by `matrix1_data` and `matrix2_data`, where each matrix is a 2D list of integers.\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix1_data` (list of lists of integers): A 2D list representing the first matrix. Each sublist represents a row in the matrix.\n  `matrix2_data` (list of lists of integers): A 2D list representing the second matrix. Each sublist represents a row in the matrix.\n\nOutput:\n  `return` (list of lists of integers): A 2D list representing the result of the matrix multiplication of `matrix1_data` and `matrix2_data`. Each sublist represents a row in the resulting matrix.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass MatrixException(BaseException):\n    def __init__(self, type):\n        self.type = type\n\nclass Matrix:\n    def __init__(self, rows, columns):\n        self.ROWS = rows\n        self.COLUMNS = columns\n        self.list = []\n        for i in range(rows):\n            self.list.append([])\n\n    def getdata(self, data):\n        for i in range(self.ROWS):\n            for j in range(self.COLUMNS):\n                self.list[i].append(data[i][j])\n\n    def showdata(self):\n        for i in range(self.ROWS):\n            for j in range(self.COLUMNS):\n                print(\"%3s\" % (self.list[i][j]), end='')\n            print()\n\n    def __add__(self, other):\n        temp = Matrix(self.ROWS, self.COLUMNS)\n        if (self.ROWS == other.ROWS) and (self.COLUMNS == other.COLUMNS):\n            for i in range(self.ROWS):\n                for j in range(self.COLUMNS):\n                    temp.list[i].append(str(int(self.list[i][j]) + int(other.list[i][j])))\n        else:\n            pass\n        return temp\n\n    def __mul__(self, other):\n        temp = Matrix(self.ROWS, other.COLUMNS)\n        if (self.COLUMNS == other.ROWS):\n            for i in range(self.ROWS):\n                for j in range(other.COLUMNS):\n                    sum = 0\n                    for k in range(self.COLUMNS):\n                        sum += int(self.list[i][k]) * int(other.list[k][j])\n                    temp.list[i].append(str(sum))\n        else:\n            raise MatrixException(\"Row Column mismatch\")\n        return temp\n\n    def transpose(self):\n        temp = Matrix(self.COLUMNS, self.ROWS)\n        for i in range(self.COLUMNS):\n            for j in range(self.ROWS):\n                temp.list[i].append(str(self.list[j][i]))\n        return temp\n\n# main function\ndef main_solution(matrix1_data, matrix2_data):\n    # Convert JSON serializable inputs to Matrix objects\n    matrix1 = Matrix(len(matrix1_data), len(matrix1_data[0]))\n    matrix1.getdata(matrix1_data)\n    \n    matrix2 = Matrix(len(matrix2_data), len(matrix2_data[0]))\n    matrix2.getdata(matrix2_data)\n    \n    # Perform matrix multiplication\n    result_matrix = matrix1 * matrix2\n    \n    # Convert result matrix to JSON serializable output\n    result_data = []\n    for row in result_matrix.list:\n        result_data.append([int(val) for val in row])\n    \n    return result_data", "input_generator": "import random\n\ndef input_generator():\n    # Randomly decide the dimensions of the matrices\n    rows1 = random.randint(1, 5)\n    cols1 = random.randint(1, 5)\n    rows2 = cols1  # Ensure multiplication is possible\n    cols2 = random.randint(1, 5)\n    \n    # Generate random data for matrix1\n    matrix1_data = []\n    for _ in range(rows1):\n        row = [str(random.randint(-10, 10)) for _ in range(cols1)]\n        matrix1_data.append(row)\n    \n    # Generate random data for matrix2\n    matrix2_data = []\n    for _ in range(rows2):\n        row = [str(random.randint(-10, 10)) for _ in range(cols2)]\n        matrix2_data.append(row)\n    \n    return {\n        'matrix1_data': matrix1_data,\n        'matrix2_data': matrix2_data\n    }", "io_pairs": [{"input": {"matrix1_data": [["2"]], "matrix2_data": [["-9"]]}, "output": [[-18]]}, {"input": {"matrix1_data": [["8"]], "matrix2_data": [["-1", "7"]]}, "output": [[-8, 56]]}, {"input": {"matrix1_data": [["-1", "4"]], "matrix2_data": [["3"], ["4"]]}, "output": [[13]]}, {"input": {"matrix1_data": [["-3"]], "matrix2_data": [["3", "-8", "8"]]}, "output": [[-9, 24, -24]]}, {"input": {"matrix1_data": [["7"], ["8"]], "matrix2_data": [["-8"]]}, "output": [[-56], [-64]]}, {"input": {"matrix1_data": [["-2"]], "matrix2_data": [["-7", "-7", "-2", "-3"]]}, "output": [[14, 14, 4, 6]]}, {"input": {"matrix1_data": [["1"]], "matrix2_data": [["-2", "5", "-10"]]}, "output": [[-2, 5, -10]]}, {"input": {"matrix1_data": [["-4", "-4"]], "matrix2_data": [["8"], ["6"]]}, "output": [[-56]]}, {"input": {"matrix1_data": [["-9"]], "matrix2_data": [["-3", "4", "1"]]}, "output": [[27, -36, -9]]}, {"input": {"matrix1_data": [["8"], ["-8"]], "matrix2_data": [["7", "-4"]]}, "output": [[56, -32], [-56, 32]]}], "error_log": []}
{"context": "Given a matrix of size NxN, where N is a positive integer, how can we represent the determinant of the matrix in a string format that alternates between '+' and '-' signs followed by the elements of the matrix in a specific order?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The size of the NxN matrix. It should be a positive integer.\n\nOutput:\n  `return` (str): A string representing the determinant of the NxN matrix. The string consists of alternating '+' and '-' signs followed by the elements of the matrix in a specific order.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef getReverseFewNum(arr):\n    totals = 0  # \u9006\u5e8f\u6570\n\n    def merge(leftArr, rightArr):\n        nonlocal totals\n        temp = []\n        i = j = 0\n        while i < len(leftArr) and j < len(rightArr):\n            if leftArr[i] <= rightArr[j]:\n                temp.append(leftArr[i])\n                i += 1\n            else:\n                temp.append(rightArr[j])\n                totals += len(leftArr) - i  # \u8ba1\u7b97\u9006\u5e8f\u7684\u5173\u952e\u4e00\u6b65\n                j += 1\n\n        if i == len(leftArr):\n            temp += rightArr[j:]\n        else:\n            temp += leftArr[i:]\n\n        return temp\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n\n        middle = len(arr) // 2\n        left = merge_sort(arr[:middle])\n        right = merge_sort(arr[middle:])\n        return merge(left, right)\n\n    merge_sort(arr)\n    return totals\n\ndef get_all_fron(length):\n    all = list(range(length))\n    result = []\n\n    def _fron(arr, res_list):\n        if len(arr) == 1:\n            res_list.append(arr[0])\n            result.append(res_list)\n        else:\n            for i in range(len(arr)):\n                new_arr = arr[:]\n                new_arr.pop(i)\n                _fron(new_arr, res_list + [arr[i]])\n\n    _fron(all, [])\n    return result\n\ndef genDString(D):\n    string = ''\n\n    for fron in get_all_fron(len(D)):\n        if getReverseFewNum(list(map(lambda x: x + 1, fron))) % 2 == 0:\n            string += '+'\n        else:\n            string += '-'\n        for i in range(len(fron)):\n            string += D[i][fron[i]]\n\n    return string\n\n# main function\ndef main_solution(N):\n    # Generate the NxN matrix\n    D = []\n    for i in range(N):\n        row = []\n        for j in range(N):\n            row.append(f'a{i+1}{j+1}')\n        D.append(row)\n    \n    # Generate the determinant string\n    determinant_string = genDString(D)\n    \n    return determinant_string", "input_generator": "import random\n\ndef input_generator():\n    N = random.randint(2, 5)  # Reasonable size to avoid excessive computation\n    return {'N': N}", "io_pairs": [{"input": {"N": 3}, "output": "+a11a22a33-a11a23a32-a12a21a33+a12a23a31+a13a21a32-a13a22a31"}, {"input": {"N": 2}, "output": "+a11a22-a12a21"}], "error_log": []}
{"context": "Given a sequence of five numbers and a target result, can you find an equation using the numbers and the basic arithmetic operations (+, -, *, /) that equals the target result? The equation should not use any parentheses and should follow the standard order of operations. What is the equation that satisfies these conditions?\n\nThe input and output requirements are as follows:\n\nInput:\n  `nums` (list of strings): A list of 5 strings, each representing a number to be used in the equation.\n  `result` (string): A string representing the result that the equation should equal.\n\nOutput:\n  `return` (string or None): A string representing the valid equation that equals the result, or None if no valid equation is found.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(nums, result):\n    cos = [\"+\", \"-\", \"*\", \"/\"]\n    nums = list(map(int, nums))  # Convert input string to list of integers\n    result = int(result)  # Convert result to integer\n    times = 0\n    left = nums[0]\n    right = nums[1]\n    \n    for operators in itertools.product(cos, repeat=4):\n        expression = f\"{left}{operators[0]}{right}\"\n        for i in range(2, 5):\n            if operators[i-1] == \"/\":\n                if nums[i] == 0:\n                    break\n            expression += f\"{operators[i-1]}{nums[i]}\"\n        \n        try:\n            if eval(expression) == result:\n                return expression\n        except ZeroDivisionError:\n            continue\n    \n    return None", "input_generator": "import random\n\ndef input_generator():\n    nums = [random.randint(1, 10) for _ in range(5)]\n    result = random.randint(1, 100)\n    return {'nums': nums, 'result': result}", "io_pairs": [{"input": {"nums": [1, 6, 8, 2, 2], "result": 49}, "output": "1+6*8+2-2"}, {"input": {"nums": [10, 2, 7, 2, 4], "result": 70}, "output": "10*2*7*2/4"}, {"input": {"nums": [5, 9, 8, 5, 7], "result": 65}, "output": "5+9*8-5-7"}, {"input": {"nums": [9, 7, 10, 2, 4], "result": 64}, "output": "9*7+10/2-4"}, {"input": {"nums": [10, 3, 10, 2, 5], "result": 32}, "output": "10-3+10*2+5"}, {"input": {"nums": [6, 7, 2, 3, 8], "result": 29}, "output": "6*7-2-3-8"}, {"input": {"nums": [5, 10, 4, 2, 4], "result": 40}, "output": "5*10-4-2-4"}, {"input": {"nums": [4, 1, 10, 10, 9], "result": 14}, "output": "4+1+10-10+9"}, {"input": {"nums": [8, 4, 5, 7, 1], "result": 39}, "output": "8-4+5*7*1"}, {"input": {"nums": [10, 8, 10, 6, 5], "result": 100}, "output": "10*8-10+6*5"}], "error_log": []}
{"context": "In a game of chess, you are given a board of size N x N and a list of initial models placed on the board. Each model can be a rook (x), a bishop (+), or a queen (o). Your task is to determine the maximum possible score by adding new models to the board without causing any collisions. The score is calculated as the total number of rooks and bishops on the board. What is the final score and which models need to be added to achieve this score?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The size of the board (N x N).\n  `models` (list of str): A list of strings where each string represents a model on the board. Each string is formatted as \"type x y\", where `type` is one of \"o\", \"+\", or \"x\", and `x` and `y` are the coordinates of the model on the board.\n\nOutput:\n  `return` (str): A string containing the score and the list of added models. The first line contains the score and the number of added models, followed by each added model on a new line.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_bishop_collision(bishop_a, bishops):\n    for bishop in bishops:\n        if (bishop_a[0] + bishop_a[1]) == (bishop[0] + bishop[1]) or (bishop_a[0] - bishop_a[1]) == (bishop[0] - bishop[1]):\n            return True\n    return False\n\ndef rook_arrangement(N, rooks, start_i):\n    for i in range(start_i, N + 1):\n        for j in range(1, N + 1):\n            if not any(x == i or y == j for x, y in rooks):\n                new_rooks = rooks[:]\n                new_rooks.append((i, j))\n                future_arrangement = rook_arrangement(N, new_rooks, i)\n                if len(future_arrangement) == N:\n                    return future_arrangement\n    return rooks[:]\n\n# main function\ndef main_solution(N, models):\n    bishop_models = []\n    rook_models = []\n    for model in models:\n        model_type, x, y = model.split()\n        x = int(x)\n        y = int(y)\n\n        if model_type == \"+\" or model_type == \"o\":\n            bishop_models.append((x, y))\n        if model_type == \"x\" or model_type == \"o\":\n            rook_models.append((x, y))\n\n    final_bishop_models = [(1, c) for c in range(1, N + 1)]\n    final_bishop_models.extend([(N, c) for c in range(2, N)])\n\n    for bishop in final_bishop_models[:]:\n        if is_bishop_collision(bishop, bishop_models):\n            final_bishop_models.remove(bishop)\n\n    final_bishop_models.extend(bishop_models)\n\n    final_rook_models = rook_arrangement(N, rook_models, 1)\n\n    score = len(final_rook_models) + len(final_bishop_models)\n    queen_models = [model for model in final_bishop_models if model in final_rook_models]\n\n    for model in queen_models: final_rook_models.remove(model)\n    for model in queen_models: final_bishop_models.remove(model)\n\n    added_models = []\n    for model in queen_models:\n        if model not in rook_models or model not in bishop_models:\n            added_models.append(\"o {0} {1}\".format(model[0], model[1]))\n\n    for model in final_rook_models:\n        if model not in rook_models:\n            added_models.append(\"x {0} {1}\".format(model[0], model[1]))\n\n    for model in final_bishop_models:\n        if model not in bishop_models:\n            added_models.append(\"+ {0} {1}\".format(model[0], model[1]))\n\n    result_lines = []\n    result_lines.append(\"{0} {1}\".format(score, len(added_models)))\n    if len(added_models) > 0:\n        result_lines.append(\"\\n\".join(added_models))\n    \n    return \"\\n\".join(result_lines)", "input_generator": "import random\n\ndef input_generator():\n    N = random.randint(4, 8)\n    num_models = random.randint(1, N)\n    models = []\n    rook_positions = set()\n    bishop_positions = set()\n    \n    for _ in range(num_models):\n        model_type = random.choice(['+', 'x', 'o'])\n        x = random.randint(1, N)\n        y = random.randint(1, N)\n        \n        while (model_type == 'x' or model_type == 'o') and (x in [pos[0] for pos in rook_positions] or (y in [pos[1] for pos in rook_positions]):\n            x = random.randint(1, N)\n            y = random.randint(1, N)\n        \n        while (model_type == '+' or model_type == 'o') and ((x, y) in bishop_positions or any((x + y == bx + by) or (x - y == bx - by) for bx, by in bishop_positions)):\n            x = random.randint(1, N)\n            y = random.randint(1, N)\n        \n        models.append(f\"{model_type} {x} {y}\")\n        if model_type == 'x' or model_type == 'o':\n            rook_positions.add((x, y))\n        if model_type == '+' or model_type == 'o':\n            bishop_positions.add((x, y))\n    \n    return {'N': N, 'models': models}", "io_pairs": [], "error_log": ["STDERR:   File \"<string>\", line 56\n    while (model_type == 'x' or model_type == 'o') and (x in [pos[0] for pos in rook_positions] or (y in [pos[1] for pos in rook_positions]):\n                                                                                                                                            ^\nSyntaxError: invalid syntax\n"]}
{"context": "Given a set of distinct integers, you are tasked with determining the k-th permutation sequence. The set of integers is provided as a comma-separated string, and k is an integer indicating the position of the desired permutation. What is the k-th permutation sequence for the given set of integers?\n\nThe input and output requirements are as follows:\n\nInput:\n  `values` (str): A comma-separated string of integers representing the values to permute.\n  `k` (int): An integer representing the k-th permutation to find.\n\nOutput:\n  `return` (str): A comma-separated string of integers representing the k-th permutation of the input values.", "reference_code": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(values, k):\n    # Convert input values to a list of integers\n    values = list(map(int, values.split(',')))\n    k = int(k)\n    \n    # Function to get the permutation\n    def get_permutation(values, n, k):\n        digits = []\n        while values:\n            n1Fact = math.factorial(n - 1)\n            first_index = (k - 1) // n1Fact\n            first_dig = values.pop(first_index)\n            digits.append(first_dig)\n            k %= n1Fact\n            n -= 1\n        return digits\n    \n    # Get the permutation\n    result = get_permutation(values, len(values), k)\n    \n    # Convert the result to a JSON serializable format\n    return ','.join(map(str, result))", "input_generator": "import random\nimport math\n\ndef input_generator():\n    n = random.randint(1, 8)  # Reasonable size to avoid large factorials\n    values = list(range(1, n+1))\n    random.shuffle(values)\n    values_str = ','.join(map(str, values))\n    max_k = math.factorial(n)\n    k = random.randint(1, max_k)\n    return {'values': values_str, 'k': str(k)}", "io_pairs": [{"input": {"values": "3,1,4,2,5", "k": "47"}, "output": "1,5,2,3,4"}, {"input": {"values": "5,4,2,3,1", "k": "28"}, "output": "4,5,3,1,2"}, {"input": {"values": "2,1", "k": "2"}, "output": "1,2"}, {"input": {"values": "3,1,5,2,6,4", "k": "197"}, "output": "1,6,3,4,5,2"}, {"input": {"values": "4,6,2,5,3,1", "k": "601"}, "output": "1,4,6,2,5,3"}, {"input": {"values": "4,3,1,2,6,8,7,5", "k": "12370"}, "output": "1,6,3,4,8,7,5,2"}, {"input": {"values": "2,1", "k": "1"}, "output": "2,1"}, {"input": {"values": "5,7,8,6,2,3,1,4", "k": "1007"}, "output": "5,8,2,6,4,1,7,3"}, {"input": {"values": "1", "k": "1"}, "output": "1"}, {"input": {"values": "4,2,1,3,5,6,8,7", "k": "36242"}, "output": "7,2,3,4,1,5,8,6"}], "error_log": []}
{"context": "In a social networking platform, users form connections with each other, creating a social graph. Given the number of users and the average number of friendships each user should have, what are the metrics for a specific user's social network, including the number of direct friends, the size of their extended network, the percentage of total users in their extended network, and the average degree of separation in their extended network?\n\nThe input and output requirements are as follows:\n\nInput:\n  `num_users` (int): The number of users to be added to the social graph.\n  `avg_friendships` (int): The average number of friendships each user should have.\n  `user_id` (int): The ID of the user for whom the metrics are to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `direct_friends_count` (int): The number of direct friends the user has.\n    - `extended_network_count` (int): The number of users in the user's extended network.\n    - `percent_of_total_users_in_extended_network` (float): The percentage of total users in the user's extended network.\n    - `avg_degree_of_separation` (float): The average degree of separation in the user's extended network.", "reference_code": "# import necessary packages\nfrom collections import deque\nimport random\nimport math\n\n# all class and function definitions in the code file, if any\nclass User:\n    def __init__(self, name):\n        self.name = name\n\nclass SocialGraph:\n    def __init__(self):\n        self.last_id = 0\n        self.users = {}\n        self.friendships = {}\n\n    def add_friendship(self, user_id, friend_id):\n        \"\"\"\n        Creates a bi-directional friendship\n        \"\"\"\n        if user_id == friend_id:\n            return False\n        elif friend_id in self.friendships[user_id] or user_id in self.friendships[friend_id]:\n            return False\n        else:\n            self.friendships[user_id].add(friend_id)\n            self.friendships[friend_id].add(user_id)\n            return True\n\n    def add_user(self, name):\n        \"\"\"\n        Create a new user with a sequential integer ID\n        \"\"\"\n        self.last_id += 1  # automatically increment the ID to assign the new user\n        self.users[self.last_id] = User(name) # {1: User(\"mari\")}\n        self.friendships[self.last_id] = set() # {1: {}}\n\n    def populate_graph(self, num_users, avg_friendships):\n        \"\"\"\n        Takes a number of users and an average number of friendships\n        as arguments\n\n        Creates that number of users and a randomly distributed friendships\n        between those users.\n\n        The number of users must be greater than the average number of friendships.\n        \"\"\"\n        # Reset graph\n        self.last_id = 0\n        self.users = {} # {1: User(\"1\"), 2: User(\"2\"), ...}\n        self.friendships = {}  # {1: {2, 3, 4}, 2: {1}, 3: {1}, 4: {1}}\n\n        # Add users\n        for i in range(num_users):\n            self.add_user(f\"User {i}\")\n\n        # Create friendships\n        possible_friendships = []\n        for user_id in self.users:\n            for friend_id in range(user_id + 1, self.last_id + 1):\n                possible_friendships.append((user_id, friend_id))\n\n        random.shuffle(possible_friendships)\n\n        for i in range(math.floor(num_users * avg_friendships / 2)):\n            friendship = possible_friendships[i]\n            self.add_friendship(friendship[0], friendship[1])\n\n    def get_all_social_paths(self, user_id):\n        \"\"\"\n        Takes a user's user_id as an argument\n\n        Returns a dictionary containing every user in that user's\n        extended network with the shortest friendship path between them.\n\n        The key is the friend's ID and the value is the path.\n        \"\"\"\n        visited = {}  # Note that this is a dictionary, not a set\n        queue = deque()\n        queue.append([user_id])\n\n        while len(queue) > 0:\n            currPath = queue.popleft()\n            currNode = currPath[-1]\n            visited[currNode] = currPath\n            for friend in self.friendships[currNode]:\n                if friend not in visited:\n                    new_path = list(currPath)\n                    new_path.append(friend)\n                    queue.append(new_path)\n\n        return visited\n\n    def count_direct_friends(self, friend_id):\n        if friend_id not in self.friendships:\n            return -1\n        return len(self.friendships[friend_id])\n\n    def count_extended_network(self, friend_id):\n        if friend_id not in self.friendships:\n            return -1\n        return len(self.get_all_social_paths(friend_id))\n\n    def percent_of_total_users_in_extended_network(self, friend_id):\n        if friend_id not in self.friendships:\n            return -1\n        return (self.count_extended_network(friend_id) / len(self.users)) * 100\n\n    def avg_degree_of_separation_in_extended_network(self, friend_id):\n        if friend_id not in self.friendships:\n            return -1\n        degrees_of_separation = []\n        extended_network = self.get_all_social_paths(friend_id)\n        degrees_of_separation = [len(p) for p in extended_network.values()]\n        return sum(degrees_of_separation) / len(degrees_of_separation)\n\n# main function\ndef main_solution(num_users, avg_friendships, user_id):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    sg = SocialGraph()\n    sg.populate_graph(num_users, avg_friendships)\n    \n    # Calculate the required metrics\n    direct_friends_count = sg.count_direct_friends(user_id)\n    extended_network_count = sg.count_extended_network(user_id)\n    percent_of_total_users_in_extended_network = sg.percent_of_total_users_in_extended_network(user_id)\n    avg_degree_of_separation = sg.avg_degree_of_separation_in_extended_network(user_id)\n    \n    # Return the results as a dictionary\n    return {\n        \"direct_friends_count\": direct_friends_count,\n        \"extended_network_count\": extended_network_count,\n        \"percent_of_total_users_in_extended_network\": percent_of_total_users_in_extended_network,\n        \"avg_degree_of_separation\": avg_degree_of_separation\n    }", "input_generator": "import random\nimport math\n\ndef input_generator():\n    num_users = random.randint(10, 100)\n    avg_friendships = random.randint(1, min(10, num_users - 1))\n    user_id = random.randint(1, num_users)\n    return {\n        \"num_users\": num_users,\n        \"avg_friendships\": avg_friendships,\n        \"user_id\": user_id\n    }", "io_pairs": [{"input": {"num_users": 98, "avg_friendships": 8, "user_id": 26}, "output": {"direct_friends_count": 6, "extended_network_count": 98, "percent_of_total_users_in_extended_network": 100.0, "avg_degree_of_separation": 4.316326530612245}}, {"input": {"num_users": 55, "avg_friendships": 3, "user_id": 14}, "output": {"direct_friends_count": 5, "extended_network_count": 54, "percent_of_total_users_in_extended_network": 98.18181818181819, "avg_degree_of_separation": 4.166666666666667}}, {"input": {"num_users": 35, "avg_friendships": 2, "user_id": 33}, "output": {"direct_friends_count": 2, "extended_network_count": 28, "percent_of_total_users_in_extended_network": 80.0, "avg_degree_of_separation": 5.107142857142857}}, {"input": {"num_users": 95, "avg_friendships": 2, "user_id": 88}, "output": {"direct_friends_count": 1, "extended_network_count": 82, "percent_of_total_users_in_extended_network": 86.31578947368422, "avg_degree_of_separation": 8.182926829268293}}, {"input": {"num_users": 57, "avg_friendships": 8, "user_id": 20}, "output": {"direct_friends_count": 4, "extended_network_count": 57, "percent_of_total_users_in_extended_network": 100.0, "avg_degree_of_separation": 4.017543859649122}}, {"input": {"num_users": 61, "avg_friendships": 3, "user_id": 48}, "output": {"direct_friends_count": 3, "extended_network_count": 59, "percent_of_total_users_in_extended_network": 96.72131147540983, "avg_degree_of_separation": 4.508474576271187}}, {"input": {"num_users": 52, "avg_friendships": 6, "user_id": 8}, "output": {"direct_friends_count": 7, "extended_network_count": 52, "percent_of_total_users_in_extended_network": 100.0, "avg_degree_of_separation": 3.8653846153846154}}, {"input": {"num_users": 23, "avg_friendships": 6, "user_id": 14}, "output": {"direct_friends_count": 3, "extended_network_count": 23, "percent_of_total_users_in_extended_network": 100.0, "avg_degree_of_separation": 3.6956521739130435}}, {"input": {"num_users": 86, "avg_friendships": 4, "user_id": 52}, "output": {"direct_friends_count": 3, "extended_network_count": 85, "percent_of_total_users_in_extended_network": 98.83720930232558, "avg_degree_of_separation": 4.870588235294117}}, {"input": {"num_users": 42, "avg_friendships": 6, "user_id": 39}, "output": {"direct_friends_count": 6, "extended_network_count": 42, "percent_of_total_users_in_extended_network": 100.0, "avg_degree_of_separation": 3.8095238095238093}}], "error_log": []}
{"context": "Given a system of linear equations represented by a coefficient matrix \\( A \\) and a right-hand side vector \\( b \\), what is the solution vector \\( x \\) that satisfies the equation \\( Ax = b \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `A_list` (list of lists of floats): A list of lists representing the coefficient matrix \\( A \\) of the system of linear equations \\( Ax = b \\). Each inner list represents a row of the matrix.\n  `b_list` (list of floats): A list representing the right-hand side vector \\( b \\) of the system of linear equations \\( Ax = b \\).\n\nOutput:\n  `return` (list of floats): A list representing the solution vector \\( x \\) of the system of linear equations \\( Ax = b \\). Each element in the list corresponds to an element in the solution vector.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass ElemOp:\n    def __init__(self, A, b):\n        self.A = A\n        self.b = b\n        dims = A.shape\n        self.n_rows, self.n_cols = dims[0], dims[1]\n    \n    def swap_rows(self, row1, row2):\n        self.A[[row1,row2],:] = self.A[[row2, row1],:]\n        self.b[row1], self.b[row2] = self.b[row2], self.b[row1]\n    \n    def scalar_mult(self, row, scalar):\n        if scalar == 0:\n            return None\n        self.A[row] = scalar * self.A[row]\n        self.b[row] = scalar * self.b[row]\n\n    def add_to_row(self, row1, row2, scalar):\n        self.A[row2] = scalar * self.A[row1] + self.A[row2]\n        self.b[row2] = scalar * self.b[row1] + self.b[row2]    \n        \n    def is_row_zeros(self, row):\n        return np.all(self.A[row] == 0)\n    \n    def move_zero_rows(self):\n        n = self.n_rows - 1\n        i = 0\n        while i < n + 1:\n            if self.is_row_zeros(i):\n                self.swap_rows(i, n)\n                i += 1\n                n -= 1\n            else:\n                i += 1\n\n    def clear_pivot_column(self, pivot):\n        for k in range(pivot + 1, self.n_rows):\n            factor = -self.A[k, pivot] / self.A[pivot, pivot]\n            self.add_to_row(pivot, k, factor)\n    \n    def iter_pivots(self):\n        for k in range(self.n_cols - 2):\n            self.clear_pivot_column(k)\n\ndef back_sub(A, b, n_rows, n_cols):\n    x_vec = np.zeros((n_rows, 1))\n    n = n_rows - 1\n    x_vec[n] = b[n] / A[n, n]\n    for i in reversed(range(n)):\n        out = back_sub_sum(A[i], x_vec, i, n_cols)\n        x_vec[i] = (b[i] - out) / A[i, i]\n    return x_vec\n      \ndef back_sub_sum(A_vec, x_vec, row_num, n_cols):\n    out = 0\n    for j in range(row_num + 1, n_cols):\n        out += A_vec[j] * x_vec[j]\n    return out\n\n# main function\ndef main_solution(A_list, b_list):\n    # Convert JSON serializable inputs to numpy arrays\n    A = np.array(A_list, dtype=float)\n    b = np.array(b_list, dtype=float)\n    \n    # Initialize ElemOp class\n    x = ElemOp(A, b)\n    \n    # Perform Gaussian elimination\n    x.iter_pivots()\n    \n    # Solve the system of equations\n    solution = back_sub(x.A, x.b, x.n_rows, x.n_cols)\n    \n    # Convert the solution to a JSON serializable output\n    solution_list = solution.flatten().tolist()\n    \n    return solution_list", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose the size of the matrix (between 2x2 and 5x5)\n    n_rows = random.randint(2, 5)\n    n_cols = n_rows  # Square matrix for simplicity\n    \n    # Generate a random matrix A with some zero rows possible\n    A = np.random.rand(n_rows, n_cols) * 10 - 5  # Values between -5 and 5\n    # Randomly zero out some rows to test the move_zero_rows functionality\n    for i in range(n_rows):\n        if random.random() < 0.2:  # 20% chance to zero out a row\n            A[i] = 0\n    \n    # Generate a random vector b\n    b = np.random.rand(n_rows) * 10 - 5  # Values between -5 and 5\n    \n    # Convert to lists for JSON serialization\n    A_list = A.tolist()\n    b_list = b.tolist()\n    \n    return {'A_list': A_list, 'b_list': b_list}", "io_pairs": [{"input": {"A_list": [[-4.626777846355971, -4.711903360052968, 0.14038081626996846], [1.6514393544451833, 0.6935722999808389, 0.3748264124520446], [3.9248803593742156, 4.011167437807719, -2.0449229042499373]], "b_list": [-0.2763695403827331, -3.2455338490267627, -0.9235963852434717]}, "output": [-3.631532798604421, 3.642493729712306, 0.60131722385898]}, {"input": {"A_list": [[-0.3918579993302167, -1.5066141137743418], [1.9105078705553016, -1.902644645353476]], "b_list": [2.9659684156884767, 4.069797037512394]}, "output": [0.6551122088847415, -2.1390210975293824]}, {"input": {"A_list": [[-4.177050980609055, 3.103025333240531], [0.0, 0.0]], "b_list": [-2.6681177192403194, 1.36591722119719]}, "output": [Infinity, Infinity]}, {"input": {"A_list": [[4.041171826505863, 1.8320932890840016], [0.9319163111203483, -3.5521653578060564]], "b_list": [2.9849796937290405, -4.924732116893712]}, "output": [0.1101067674743146, 1.3864028334354912]}, {"input": {"A_list": [[-1.2656901787261363, -2.1939885623879594, 1.419171114587968], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]], "b_list": [3.699083469874541, -2.07521516324386, 0.8813717602141589]}, "output": [NaN, NaN, Infinity]}, {"input": {"A_list": [[0.6441881807807546, 2.241924164879191, -1.240237524774627], [-0.7845531634686642, -3.973661278242566, 4.329346676968676], [-4.1830828145191035, -4.421653010292412, 3.4014661718678916]], "b_list": [0.48424712643957957, -3.0760120018959123, -0.9155051200127327]}, "output": [-3.34976136504162, 0.9134484333822992, -0.4791353899508608]}, {"input": {"A_list": [[4.6342352952174455, -0.36237372414870705, -4.728387718696654], [0.0, 0.0, 0.0], [3.942838554754685, -0.5214760065213833, 3.4892069167130817]], "b_list": [-0.28023260864729505, 2.9597163645617695, 4.7111673260869384]}, "output": [Infinity, Infinity, 0.6588780128320235]}, {"input": {"A_list": [[0.0, 0.0], [0.0, 0.0]], "b_list": [0.9175958219969838, 0.5834194452807164]}, "output": [NaN, Infinity]}, {"input": {"A_list": [[-3.5444532194086067, 1.5404104467101352], [0.0, 0.0]], "b_list": [-0.015689634093444482, -2.460970078047613]}, "output": [-Infinity, -Infinity]}, {"input": {"A_list": [[-3.0074871773565715, -2.4364874309959808], [2.6324561488949874, -2.204337518438222]], "b_list": [2.593183962434365, -3.7542361092021945]}, "output": [-2.2420037831390185, 1.7031131021451194]}], "error_log": []}
{"context": "In a magical kingdom, there are unicorns of different colors: red (R), orange (O), yellow (Y), green (G), blue (B), and violet (V). The kingdom has a special rule: no two unicorns of the same color can be adjacent to each other. Given the total number of unicorns (N) and the count of each color, what is the arrangement of the unicorns in a circle that satisfies this rule? If no such arrangement is possible, what should be returned?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The total number of unicorns.\n  `R` (int): The number of unicorns of red color.\n  `O` (int): The number of unicorns of orange color.\n  `Y` (int): The number of unicorns of yellow color.\n  `G` (int): The number of unicorns of green color.\n  `B` (int): The number of unicorns of blue color.\n  `V` (int): The number of unicorns of violet color.\n\nOutput:\n  `return` (str): A string representing the arrangement of unicorns in a circle, or \"IMPOSSIBLE\" if no valid arrangement exists.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef yup(R, Y, B):\n    N = R + Y + B\n    result = \"\"\n    Y_ = 'Y'\n    R_ = 'R'\n    B_ = 'B'\n    if Y <= N/2 and R <= N/2 and B <= N/2:\n        if Y >= R and Y >= B:\n            pass\n        elif R >= Y and R >= B:\n            Y, R = R, Y\n            Y_, R_, = R_, Y_\n        else:\n            Y, B = B, Y\n            Y_, B_, = B_, Y_\n        fusions = R+B-Y\n        for _ in range(fusions):\n            result += Y_ + R_ + B_\n        for _ in range(R-fusions):\n            result += Y_ + R_\n        for _ in range(B-fusions):\n            result += Y_ + B_\n        return result\n    else:\n        return \"IMPOSSIBLE\"\n\ndef algo(N, R, O, Y, G, B, V):\n    result = \"\"\n\n    if Y <= N/2 and R <= N/2 and B <= N/2 and (O < B or B == 0) and (G < R or R == 0) and (V < Y or Y == 0):\n        r = yup(R-G, Y-V, B-O)\n\n        if r == \"IMPOSSIBLE\":\n            return \"IMPOSSIBLE\"\n\n        for i in range(len(r)):\n            if r[i] == 'B' and O != 0:\n                plo = \"BO\"*O\n                r = r[0:i] + plo + 'B' + r[i+1:]\n                break\n\n        for i in range(len(r)):\n            if r[i] == 'R' and G != 0:\n                plo = \"RG\"*G\n                r = r[0:i] + plo + 'R' + r[i+1:]\n                break\n\n        for i in range(len(r)):\n            if r[i] == 'Y' and V != 0:\n                plo = \"YV\"*V\n                r = r[0:i] + plo + 'Y' + r[i+1:]\n                break\n        return r\n    elif O == B and O + B == N:\n         return \"OB\"*(N//2)\n    elif G == R and G + R == N:\n         return \"GR\"*(N//2)\n    elif Y == V and Y + V == N:\n         return \"YV\"*(N//2)\n    else:\n        return \"IMPOSSIBLE\"\n\n# main function\ndef main_solution(N, R, O, Y, G, B, V):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = algo(N, R, O, Y, G, B, V)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\n\ndef input_generator():\n    N = random.randint(1, 100)\n    R = random.randint(0, N)\n    Y = random.randint(0, N - R)\n    B = N - R - Y\n    O = random.randint(0, min(B, N // 2))\n    G = random.randint(0, min(R, N // 2))\n    V = random.randint(0, min(Y, N // 2))\n    \n    # Ensure constraints are met\n    if R + Y + B != N:\n        B = N - R - Y\n    \n    # Adjust to meet the conditions in the algo function\n    if random.random() < 0.5:\n        # Make sure no color exceeds N/2\n        while R > N / 2 or Y > N / 2 or B > N / 2:\n            R = random.randint(0, N // 2)\n            Y = random.randint(0, N // 2)\n            B = N - R - Y\n            if B < 0:\n                B = 0\n                Y = N - R\n        O = random.randint(0, min(B, N // 2))\n        G = random.randint(0, min(R, N // 2))\n        V = random.randint(0, min(Y, N // 2))\n    else:\n        # Sometimes generate cases where one color pair dominates\n        choice = random.choice(['OB', 'GR', 'YV'])\n        if choice == 'OB':\n            O = B = N // 2\n            R = Y = G = V = 0\n        elif choice == 'GR':\n            G = R = N // 2\n            Y = B = O = V = 0\n        else:\n            Y = V = N // 2\n            R = O = G = B = 0\n    \n    return {\n        'N': N,\n        'R': R,\n        'O': O,\n        'Y': Y,\n        'G': G,\n        'B': B,\n        'V': V\n    }", "io_pairs": [{"input": {"N": 27, "R": 13, "O": 0, "Y": 0, "G": 13, "B": 0, "V": 0}, "output": "IMPOSSIBLE"}, {"input": {"N": 46, "R": 5, "O": 0, "Y": 19, "G": 3, "B": 22, "V": 14}, "output": "IMPOSSIBLE"}, {"input": {"N": 33, "R": 0, "O": 16, "Y": 0, "G": 0, "B": 16, "V": 0}, "output": "IMPOSSIBLE"}, {"input": {"N": 70, "R": 0, "O": 0, "Y": 35, "G": 0, "B": 0, "V": 35}, "output": "YVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYVYV"}, {"input": {"N": 49, "R": 0, "O": 0, "Y": 24, "G": 0, "B": 0, "V": 24}, "output": "IMPOSSIBLE"}, {"input": {"N": 8, "R": 0, "O": 4, "Y": 0, "G": 0, "B": 4, "V": 0}, "output": "OBOBOBOB"}, {"input": {"N": 81, "R": 0, "O": 40, "Y": 0, "G": 0, "B": 40, "V": 0}, "output": "IMPOSSIBLE"}, {"input": {"N": 7, "R": 0, "O": 0, "Y": 3, "G": 0, "B": 0, "V": 3}, "output": "IMPOSSIBLE"}, {"input": {"N": 32, "R": 11, "O": 4, "Y": 10, "G": 2, "B": 11, "V": 2}, "output": "RGRGRYVYVYBOBOBOBOBRYBRYBRYBRYBRYBRYRYRB"}, {"input": {"N": 42, "R": 0, "O": 21, "Y": 0, "G": 0, "B": 21, "V": 0}, "output": "OBOBOBOBOBOBOBOBOBOBOBOBOBOBOBOBOBOBOBOBOB"}], "error_log": []}
{"context": "Given a neural network with an affine transformation layer, how would the output and gradients of the input, weights, and bias be calculated for a specific set of input data, weight matrix, bias vector, and gradient of the output with respect to the layer's output?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x` (list of lists of floats): A 2D list representing the input matrix `x` with dimensions `(batch_size, n)`.\n  `W` (list of lists of floats): A 2D list representing the weight matrix `W` with dimensions `(n, m)`.\n  `b` (list of lists of floats): A 2D list representing the bias matrix `b` with dimensions `(1, m)`.\n  `doutdy` (list of lists of floats): A 2D list representing the gradient of the output with respect to `y` with dimensions `(batch_size, m)`.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `y` (list of lists of floats): A 2D list representing the output matrix `y` with dimensions `(batch_size, m)`.\n    - `doutdx` (list of lists of floats): A 2D list representing the gradient of the output with respect to `x` with dimensions `(batch_size, n)`.\n    - `doutdW` (list of lists of floats): A 2D list representing the gradient of the output with respect to `W` with dimensions `(n, m)`.\n    - `doutdb` (list of floats): A 1D list representing the gradient of the output with respect to `b` with dimensions `(m,)`.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass AffineLayer:\n    \"\"\"\n    forward/backward propagation for Affine transformation: Y = XW + B\n\n    In the textbook, `doutdW` and `doutdb` are fields.\n    \"\"\"\n\n    def __init__(self):\n        self.x = None\n        self.W = None\n        self.b = None\n\n    def forward(self, x, W, b):\n        \"\"\"\n        return y = xW + b\n\n        x: (batch_size, n) matrix\n        W: (n, m) matrix\n        b: (1, m) matrix. This is NOT (batch_size, m) matrix because bias is common for all data in `x`.\n        \"\"\"\n        self.x = x\n        self.W = W\n        self.b = b\n        return np.dot(self.x, self.W) + self.b\n\n    def backward(self, doutdy):\n        \"\"\"\n        return d(out)/dx, d(out)/dW\n\n        d(out)/dx = d(out)/dy * [W]T\n        d(out)/dW = [x]T * d(out)/dy\n        d(out)/db = d(out)/dy\n        ([A]T means the transpose matrix of A.)\n\n        doutdy: (batch_size, m) matrix (`batch_size` and `m` must be consistent with those of `forward`.)\n        \"\"\"\n        doutdx = np.dot(doutdy, self.W.T)\n        doutdW = np.dot(self.x.T, doutdy)\n        doutdb = np.sum(doutdy, axis=0)\n        return doutdx, doutdW, doutdb\n\n# main function\ndef main_solution(x, W, b, doutdy):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # convert JSON serializable inputs to numpy arrays\n    x = np.array(x)\n    W = np.array(W)\n    b = np.array(b)\n    doutdy = np.array(doutdy)\n\n    affine_layer = AffineLayer()\n    y = affine_layer.forward(x, W, b)\n    doutdx, doutdW, doutdb = affine_layer.backward(doutdy)\n\n    # convert numpy arrays to JSON serializable lists\n    y = y.tolist()\n    doutdx = doutdx.tolist()\n    doutdW = doutdW.tolist()\n    doutdb = doutdb.tolist()\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"y\": y, \"doutdx\": doutdx, \"doutdW\": doutdW, \"doutdb\": doutdb}", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    batch_size = random.randint(1, 10)\n    n = random.randint(1, 10)\n    m = random.randint(1, 10)\n    \n    x = np.random.rand(batch_size, n).tolist()\n    W = np.random.rand(n, m).tolist()\n    b = np.random.rand(1, m).tolist()\n    doutdy = np.random.rand(batch_size, m).tolist()\n    \n    return {\"x\": x, \"W\": W, \"b\": b, \"doutdy\": doutdy}", "io_pairs": [{"input": {"x": [[0.60821903168757]], "W": [[0.24430477565168673]], "b": [[0.9185292976804142]], "doutdy": [[0.7128158757428354]]}, "output": {"y": [[1.0671201117639322]], "doutdx": [[0.17414432260431403]], "doutdW": [[0.4335481817158346]], "doutdb": [0.7128158757428354]}}], "error_log": []}
{"context": "Given a positive integer, determine whether it is an Emirp number. An Emirp number is a prime number that remains prime when its digits are reversed. What is the result of checking if the given number is an Emirp number?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): A positive integer to be checked if it is an Emirp number.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"is_emirp\"` which is a boolean indicating whether the input number is an Emirp number.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef is_prime(t, i=2):\n    if t == 1:\n        return False\n    elif i < t:\n        if t % i != 0:\n            return is_prime(t, i + 1)\n        else:\n            return False\n    else:\n        return True\n\ndef reverse_number(n):\n    s = 0\n    while n > 0:\n        r = n % 10\n        s = s * 10 + r\n        n = n // 10\n    return s\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    # Check if the number is prime\n    if not is_prime(n):\n        return {\"is_emirp\": False}\n    \n    # Reverse the number\n    reversed_n = reverse_number(n)\n    \n    # Check if the reversed number is prime\n    if not is_prime(reversed_n):\n        return {\"is_emirp\": False}\n    \n    # If both the number and its reverse are prime, it is an Emirp number\n    return {\"is_emirp\": True}", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random positive integer between 2 and 1000\n    n = random.randint(2, 1000)\n    return {\"n\": n}", "io_pairs": [{"input": {"n": 323}, "output": {"is_emirp": false}}, {"input": {"n": 381}, "output": {"is_emirp": false}}, {"input": {"n": 68}, "output": {"is_emirp": false}}, {"input": {"n": 521}, "output": {"is_emirp": false}}, {"input": {"n": 13}, "output": {"is_emirp": true}}, {"input": {"n": 951}, "output": {"is_emirp": false}}, {"input": {"n": 9}, "output": {"is_emirp": false}}, {"input": {"n": 7}, "output": {"is_emirp": true}}, {"input": {"n": 895}, "output": {"is_emirp": false}}, {"input": {"n": 76}, "output": {"is_emirp": false}}], "error_log": []}
{"context": "Given a computational task to estimate the value of Pi using the Monte Carlo method, where random points are generated within a unit square and checked if they fall within the unit circle, how can we efficiently distribute the workload across multiple processors to achieve a more accurate and faster estimation of Pi? Specifically, what is the estimated value of Pi when using `n` random points and `np` worker processes?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The total number of random points to use for the Pi estimation.\n  `np` (int): The number of worker processes to use for parallel computation.\n\nOutput:\n  `return` (float): The estimated value of Pi based on the Monte Carlo method.", "reference_code": "# import necessary packages\nimport random\nimport multiprocessing\nfrom multiprocessing import Pool\n\n# main function\ndef main_solution(n, np):\n    # Convert JSON serializable inputs to original input variables\n    part_count = [n // np for _ in range(np)]\n    \n    # Create the worker pool\n    pool = Pool(processes=np)\n    \n    # Parallel map\n    count = pool.map(monte_carlo_pi_part, part_count)\n    \n    # Calculate the estimated value of Pi\n    pi_estimate = sum(count) / (n * 1.0) * 4\n    \n    # Return the estimated value of Pi as a JSON serializable output\n    return pi_estimate\n\n# Function to calculate the number of points in the unit circle out of n points\ndef monte_carlo_pi_part(n):\n    count = 0\n    for i in range(n):\n        x = random.random()\n        y = random.random()\n        if x * x + y * y <= 1:\n            count += 1\n    return count", "input_generator": "import random\n\ndef input_generator():\n    n = random.randint(1000, 100000)\n    np = random.randint(2, multiprocessing.cpu_count())\n    return {'n': n, 'np': np}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a target value, what is the first value in a spiral pattern that exceeds this target value? The spiral pattern starts at the origin (0,0) and expands outward, with each new value being the sum of all adjacent values (including diagonals) that have already been filled.\n\nThe input and output requirements are as follows:\n\nInput:\n  `target_value` (int): The target value to find the next value that exceeds it in a spiral pattern.\n\nOutput:\n  `return` (int): The first value in the spiral pattern that exceeds the `target_value`.", "reference_code": "# import necessary packages\nfrom typing import List\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        return (self.x == other.x) and (self.y == other.y)\n\nclass Node(object):\n    def __init__(self, value, loc: Point):\n        self.value = value\n        self.loc = loc\n\n\ndef right(loc: Point):\n    loc.x += 1\n    return loc\n\n\ndef down(loc: Point):\n    loc.y -= 1\n    return loc\n\n\ndef left(loc: Point):\n    loc.x -= 1\n    return loc\n\n\ndef up(loc: Point):\n    loc.y += 1\n    return loc\n\n\ndef find_next_value(spiral_list: List[Node], loc:Point):\n    walk = [up, left, down, down, right, right, up, up]\n    current_location = deepcopy(loc)\n    value = 0\n    for move in walk:\n        # Modify the location\n        move(current_location)\n\n        # Check the list to see if location exists\n        for node in spiral_list:\n            # If so, add the value to the current value\n            if node.loc == current_location:\n                value += node.value\n\n    return value\n\n# main function\ndef main_solution(target_value: int):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    movement = [right, up, left, down]\n    spiral_list: List[Node] = []\n\n    current_location = Point(0,0)\n    current_value = 1\n    current_step = 1\n    current_direction = 0\n    num_directions = len(movement)\n    value_which_exceeds_target = 0\n\n    # Generate Spiral\n    while current_value <= target_value:\n        for idx in range(2):\n            steps = 0\n            while steps < current_step:\n                # Place the value\n                spiral_list.append(Node(current_value, deepcopy(current_location)))\n\n                # Move to the next position\n                movement[current_direction](current_location)\n\n                # Find next value\n                current_value = find_next_value(spiral_list, current_location)\n\n                # Check to see if the just calculated value exceeds the target\n                if (value_which_exceeds_target == 0) and (current_value > target_value):\n                    # Store the value which exceeded the target\n                    value_which_exceeds_target = current_value\n\n                # Count the step\n                steps += 1\n\n            # Change direction\n            current_direction = (current_direction + 1) % num_directions\n\n        # Increase the number of steps taken per direction\n        current_step += 1\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return value_which_exceeds_target", "input_generator": "import random\n\ndef input_generator():\n    return {'target_value': random.randint(1, 1000)}", "io_pairs": [{"input": {"target_value": 633}, "output": 747}, {"input": {"target_value": 436}, "output": 747}, {"input": {"target_value": 202}, "output": 304}, {"input": {"target_value": 173}, "output": 304}, {"input": {"target_value": 680}, "output": 747}, {"input": {"target_value": 545}, "output": 747}, {"input": {"target_value": 55}, "output": 57}, {"input": {"target_value": 996}, "output": 1968}, {"input": {"target_value": 220}, "output": 304}, {"input": {"target_value": 755}, "output": 806}], "error_log": []}
{"context": "Given a list of words, which word can be reduced to an empty string by repeatedly removing one letter at a time, and each resulting word must also be in the list? What is the longest word that can be reduced in this manner?\n\nThe input and output requirements are as follows:\n\nInput:\n  `word_list` (list of strings): A list of words from which to find the largest reducible word. Each word is a string.\n\nOutput:\n  `return` (string): The largest reducible word from the input list. If no reducible word is found, it returns an empty string.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef find_children(words, word):\n    \"\"\"Find all children of a word, i.e. words that are revealed\n    by dropping a single letter.\n    words: dictionary of words\n    word: string\n    \"\"\"\n    children = []\n    for i in range(len(word)):\n        possible_child = word[:i] + word[i+1:]\n        if possible_child in words:\n            children.append(possible_child)\n    return children\n\ndef is_reducible(words, word, known):\n    \"\"\"True if a word is reducible, given a dictionary of words.\n    words: dictionary\n    word: string\n    known: dictionary to memoize results\n    \"\"\"\n    # Base case. Empty string is reducible.\n    if word == '':\n        return True\n\n    # Check memos\n    if word in known:\n        return known[word]\n    \n    # Cycle through children. If any is reducible, return True.\n    for child in find_children(words, word):\n        if is_reducible(words, child, known):\n            known[word] = True # Set memo\n            return True\n        \n    # No reducible children. Word isn't reducible.\n    known[word] = False # Set memo\n    return False\n\ndef add_single_letter_words(words):\n    \"\"\"Add single letter words to the dictionary.\n    \"\"\"\n    words[''] = None\n    words['i'] = None\n    words['a'] = None\n    return words\n\ndef get_words(word_list):\n    \"\"\"Convert a list of words into a dictionary.\n    \"\"\"\n    words = dict()\n    for word in word_list:\n        words[word] = None\n    return add_single_letter_words(words)\n\ndef find_reducible(words):\n    \"\"\"Find all reducible words in words. Return a new dictionary.\n    words: dictionary\n    \"\"\"\n    reducible = dict()\n    known = dict()\n    for word in words:\n        if is_reducible(words, word, known):\n            reducible[word] = None\n    return reducible\n\ndef key_lengths(words):\n    \"\"\"Return a dictionary whose keys are numbers indicating word length.\n    Their values will be a list of all words whose length is equal to that key.\n    words: dictionary of words\n    \"\"\"\n    word_length = dict()\n    for word in words:\n        word_length.setdefault(len(word), []).append(word)\n    return word_length\n\ndef max_key(words):\n    \"\"\"Return the item with the maximum key in words.\n    words: dictionary\n    \"\"\"\n    return words[max(words.keys())]\n\n# main function\ndef main_solution(word_list):\n    \"\"\"Find the largest reducible word from a list of words.\n    word_list: list of strings\n    \"\"\"\n    words = get_words(word_list)\n    reducible = find_reducible(words)\n    reducible_by_length = key_lengths(reducible)\n    longest_reducibles = max_key(reducible_by_length)\n    return longest_reducibles[0] if longest_reducibles else \"\"", "input_generator": "import random\n\ndef input_generator():\n    # Common single and double letter words that can form reducible chains\n    base_words = ['a', 'i', 'at', 'it', 'in', 'be', 'as', 'an', 'am', 'me', 'my', 'by', 'go', 'hi', 'up', 'we']\n    \n    # Generate some longer words that can be reduced\n    longer_words = [\n        'start', 'starts', 'starting', 'startling', 'star', 'staring', 'string', 'sting', 'sing', 'sin', 'in',\n        'bat', 'bats', 'bates', 'ate', 'at', 'a',\n        'bite', 'bit', 'it', 'i',\n        'hello', 'hell', 'hel', 'he', 'e',\n        'testing', 'test', 'est', 'es', 'e',\n        'printing', 'print', 'pint', 'pin', 'in', 'i'\n    ]\n    \n    # Combine base and longer words\n    word_pool = base_words + longer_words\n    \n    # Randomly select a subset of words\n    num_words = random.randint(5, 20)\n    word_list = random.sample(word_pool, num_words)\n    \n    return {'word_list': word_list}", "io_pairs": [{"input": {"word_list": ["hi", "i", "printing", "est", "bat", "i", "am", "me"]}, "output": "hi"}, {"input": {"word_list": ["as", "a", "startling", "staring", "print", "e", "a", "bates", "be", "it", "starting"]}, "output": "as"}, {"input": {"word_list": ["e", "e", "we", "go", "hi", "string", "sin", "in"]}, "output": "sin"}, {"input": {"word_list": ["i", "me", "in", "at", "starting", "sing", "bat", "up"]}, "output": "bat"}, {"input": {"word_list": ["sting", "i", "up", "string", "in", "sin", "at", "we", "starts", "i", "go", "bates"]}, "output": "sin"}, {"input": {"word_list": ["in", "string", "hell", "it", "we", "i", "pint", "e", "at"]}, "output": "in"}, {"input": {"word_list": ["go", "string", "hell", "sin", "it", "as", "hi", "e", "testing", "star", "at"]}, "output": "it"}, {"input": {"word_list": ["pint", "by", "go", "e", "in", "string", "start", "as", "bats", "testing"]}, "output": "in"}, {"input": {"word_list": ["up", "starts", "bat", "an", "est", "sting"]}, "output": "an"}, {"input": {"word_list": ["my", "we", "staring", "i", "sin", "bats", "pint"]}, "output": "i"}], "error_log": []}
{"context": "In a game where players form a circle and are sequentially removed based on a list of counts, which player number will be the last one standing and thus considered the winner?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The number of players in the game.\n  `counts` (list of int): A list of numbers representing the counts in each turn.\n\nOutput:\n  `return` (int): The number of the winning player.", "reference_code": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef count(n, m):\n    players = list(range(1, n + 1))\n    location = 0\n    for i in m:\n        location = (location + i - 1) % len(players)\n        players.pop(location)\n    return players[0]\n\n# main function\ndef main_solution(N, counts):\n    # Convert JSON serializable inputs to the original input variables\n    N = int(N)\n    counts = [int(i) for i in counts]\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    winner = count(N, counts)\n    \n    # Convert the output to JSON serializable\n    return winner", "input_generator": "import random\n\ndef input_generator():\n    N = random.randint(2, 100)\n    m_length = random.randint(1, N - 1)\n    counts = [random.randint(1, 100) for _ in range(m_length)]\n    return {'N': N, 'counts': counts}", "io_pairs": [{"input": {"N": 9, "counts": [80, 48, 28]}, "output": 1}, {"input": {"N": 29, "counts": [83, 66, 77, 89, 11, 4, 78, 62, 71, 37, 71, 79, 65, 40]}, "output": 3}, {"input": {"N": 4, "counts": [90]}, "output": 1}, {"input": {"N": 35, "counts": [12, 59, 55, 8, 67, 47, 41, 99]}, "output": 3}, {"input": {"N": 28, "counts": [93, 24, 50, 80, 92, 58, 71, 37, 85, 18, 53, 93, 88, 67, 60, 37]}, "output": 3}, {"input": {"N": 79, "counts": [24, 1]}, "output": 1}, {"input": {"N": 22, "counts": [19, 47, 19, 36, 59, 26, 13, 1, 66, 68, 64, 63]}, "output": 1}, {"input": {"N": 27, "counts": [71, 36, 70, 14, 56, 94, 95, 2, 95, 88, 52, 88, 16, 92, 19]}, "output": 2}, {"input": {"N": 53, "counts": [90, 30, 77, 72, 88]}, "output": 1}, {"input": {"N": 99, "counts": [97, 63, 9, 41, 86, 53, 51, 77, 48, 96, 60, 68, 65, 86]}, "output": 1}], "error_log": []}
{"context": "Given a function \\( f(x) = \\frac{2}{x - 4} \\), you are tasked with finding the integral of this function over a specified interval using Simpson's rule. What is the value of the integral when integrating from `x0` to `x2`?\n\nThe input and output requirements are as follows:\n\nInput:\n  `x0` (float): The starting point of the interval for integration.\n  `x2` (float): The ending point of the interval for integration.\n\nOutput:\n  `return` (float): The result of the integral calculated using Simpson's rule, rounded to 8 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(x0, x2):\n    # Convert JSON serializable inputs to the original input variables\n    x0 = float(x0)\n    x2 = float(x2)\n    \n    # Calculate intermediate values\n    h1 = (x0 + x2) / 2\n    x1 = x0 + h1\n    \n    # Define the function to be integrated\n    f1 = lambda x: 2 / (x - 4)\n    \n    # Calculate the integral using Simpson's rule\n    result = (h1 / 3) * (f1(x0) + 4 * f1(x1) + f1(x2))\n    \n    # Convert the result to a JSON serializable output\n    return round(result, 8)", "input_generator": "import random\n\ndef input_generator():\n    x0 = random.uniform(-10.0, 3.9)  # Avoid x0 being 4 to prevent division by zero\n    x2 = random.uniform(x0 + 0.1, 10.0)  # Ensure x2 > x0 and also avoid x2 being 4\n    return {'x0': x0, 'x2': x2}", "io_pairs": [{"input": {"x0": -4.370913622049925, "x2": 9.849930769803173}, "output": -1.20323123}, {"input": {"x0": 2.085783458272644, "x2": 7.830803588492701}, "output": 3.47960516}, {"input": {"x0": -5.113459309000458, "x2": -3.626364370752274}, "output": 1.56592473}, {"input": {"x0": -1.3743154092554093, "x2": 1.8292762631124555}, "output": -0.21594303}, {"input": {"x0": -9.28860888549762, "x2": -4.762813502677912}, "output": 1.80924454}, {"input": {"x0": 3.4091915563343242, "x2": 6.122200377819278}, "output": -0.83646639}, {"input": {"x0": -3.0707046701188974, "x2": 3.90836678090201}, "output": -3.25455069}, {"input": {"x0": -3.034603807745178, "x2": 0.04375418369451589}, "output": 0.86121605}, {"input": {"x0": -4.11625878392216, "x2": 6.4270162657849434}, "output": -0.22015427}, {"input": {"x0": -9.109667210261083, "x2": -3.8045491691412607}, "output": 1.75994145}], "error_log": []}
{"context": "Given the initial position and velocity of a celestial body orbiting a massive object, what will be the final position of the celestial body after a specified time interval, calculated using the Euler method with a given number of steps?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_position` (list of floats): Initial position [x, y] in meters.\n  `initial_velocity` (list of floats): Initial velocity [vx, vy] in meters per second.\n  `time_interval` (float): Total time interval in seconds.\n  `steps` (int): Number of steps for the Euler method.\n\nOutput:\n  `return` (list of floats): Final position [x, y] in meters.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# Constants\nM = 1.98e30\nG = 6.67e-11\n\ndef derivada(r, t):\n    '''Fun\u00e7\u00e3o que calcula a derivada do exerc\u00edcio\n    e retorna uma array com x, dx, y, dy'''\n    x = r[0]\n    y = r[2]\n    dx = -G * M * x/np.sqrt(x**2 + y**2)**3\n    dy = -G * M * y/np.sqrt(x**2 + y**2)**3\n    return np.array([r[1], dx, r[3], dy])\n\ndef Euler(f, ri, ti, tf, n):\n    '''Fun\u00e7\u00e3o que calcula EDO de primeiro ordem de maneira num\u00e9rica\n    atrav\u00e9s do m\u00e9todo de Euler.\n    '''\n    t = np.zeros(n)\n    if isinstance(ri,(float, int)):\n        r = np.zeros(n)\n    else:\n        r = np.zeros((n, len(ri)))\n\n    t[0] = ti\n    r[0] = ri\n    h = (tf-ti)/n\n    for k in range(n - 1):\n        t[k + 1] = t[k] + h\n        r[k + 1] = r[k]+h*f(r[k], t[k])\n    return t, r\n\n# main function\ndef main_solution(initial_position, initial_velocity, time_interval, steps):\n    '''\n    Solves the orbital motion problem using the Euler method.\n    \n    Parameters:\n    initial_position (list): Initial position [x, y] in meters.\n    initial_velocity (list): Initial velocity [vx, vy] in meters per second.\n    time_interval (float): Total time interval in seconds.\n    steps (int): Number of steps for the Euler method.\n    \n    Returns:\n    list: Final position [x, y] in meters.\n    '''\n    # Convert input to numpy array\n    ri = np.array([initial_position[0], initial_velocity[0], initial_position[1], initial_velocity[1]])\n    ti = 0\n    tf = time_interval\n    n = steps\n    \n    # Solve using Euler method\n    t, r = Euler(derivada, ri, ti, tf, n)\n    \n    # Extract final position\n    final_position = [r[-1, 0], r[-1, 2]]\n    \n    return final_position", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Generate random initial position within reasonable range (e.g., 1e10 to 1e12 meters)\n    x = random.uniform(1e10, 1e12)\n    y = random.uniform(1e10, 1e12)\n    initial_position = [x, y]\n    \n    # Generate random initial velocity (e.g., 1e3 to 1e5 m/s)\n    vx = random.uniform(-1e5, 1e5)\n    vy = random.uniform(-1e5, 1e5)\n    initial_velocity = [vx, vy]\n    \n    # Generate random time interval (e.g., 1e5 to 1e7 seconds)\n    time_interval = random.uniform(1e5, 1e7)\n    \n    # Generate random steps (e.g., 100 to 10000)\n    steps = random.randint(100, 10000)\n    \n    return {\n        'initial_position': initial_position,\n        'initial_velocity': initial_velocity,\n        'time_interval': time_interval,\n        'steps': steps\n    }", "io_pairs": [{"input": {"initial_position": [569507709860.9939, 466100998051.0412], "initial_velocity": [5801.783809256362, 85868.04120672599], "time_interval": 1745159.9258888632, "steps": 9026}, "output": [579379193213.2548, 615711870689.2062]}, {"input": {"initial_position": [340023661249.57605, 324912589200.47815], "initial_velocity": [-2726.547079131429, 88723.32348230053], "time_interval": 7742516.392551607, "steps": 4420}, "output": [312871863939.6252, 1003183349132.3824]}, {"input": {"initial_position": [279299786835.6378, 318160660737.6173], "initial_velocity": [4848.924623618877, 20016.428997515075], "time_interval": 3077415.607574612, "steps": 9486}, "output": [292152088259.1966, 377295139109.77966]}, {"input": {"initial_position": [315051818453.90857, 315821939943.2965], "initial_velocity": [77521.38764629091, 8307.003594467562], "time_interval": 2251272.4612138784, "steps": 3417}, "output": [488477204663.01556, 333598680859.3266]}, {"input": {"initial_position": [841481982688.2144, 905575322254.3912], "initial_velocity": [16897.398959419603, 47865.83831457779], "time_interval": 1738369.5715350285, "steps": 6510}, "output": [870767080021.9741, 988678671202.609]}, {"input": {"initial_position": [549762918836.1472, 815951612666.4331], "initial_velocity": [-52260.71623961623, -79938.43333543924], "time_interval": 5301408.061930093, "steps": 661}, "output": [271440373187.40262, 390326728014.1953]}, {"input": {"initial_position": [890807545990.3044, 906217163309.3119], "initial_velocity": [-40667.90705306422, -32000.8170046834], "time_interval": 8134357.465044354, "steps": 2856}, "output": [557714964531.5713, 643462492149.926]}, {"input": {"initial_position": [24382196341.961773, 202148958809.40707], "initial_velocity": [64162.46102756512, -71816.01928952168], "time_interval": 9674285.119315183, "steps": 9714}, "output": [539675898638.7305, -549527577764.8546]}, {"input": {"initial_position": [281248745455.84985, 421411853657.997], "initial_velocity": [72792.30537192622, 94488.95433195462], "time_interval": 1720412.03283039, "steps": 2727}, "output": [406097394649.14795, 583412930091.3763]}, {"input": {"initial_position": [775325826804.5303, 350383107255.767], "initial_velocity": [-6738.92311712043, -38548.83867243628], "time_interval": 6125729.185519858, "steps": 3830}, "output": [730483649123.8213, 113056466271.0884]}], "error_log": []}
{"context": "Given a fraction with a numerator of 1 and a denominator between 2 and 999, what is the decimal representation of the fraction, and does it repeat? If it repeats, how many digits repeat?\n\nThe input and output requirements are as follows:\n\nInput:\n  `denominator` (int): The denominator of the fraction for which the decimal representation is to be found. It should be an integer between 2 and 999.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `denominator` (int): The input denominator.\n    - `decimal_representation` (str): The decimal representation of the fraction 1/denominator.\n    - `repeating_info` (str): A string indicating whether the decimal representation is repeating and, if so, how many digits repeat.", "reference_code": "# import necessary packages\nimport random\n\n# main function\ndef main_solution(denominator):\n    digits = {1: 1}\n    decimal = []\n    last_numerator = 1\n    repeating = \"\"\n    done = False\n    digit = 0\n    while not done:\n        digit += 1\n        if digit >= 1000:  # safety net\n            done = True\n        numerator = 10 * last_numerator\n        if numerator < denominator:  # quotient will be 0\n            digits[last_numerator] = digit\n            decimal.append('0')\n            last_numerator = numerator\n            continue\n        else:\n            quotient = numerator // denominator\n            remainder = numerator % denominator\n            if remainder == 0:\n                decimal.append(str(quotient))\n                done = True\n            else:\n                if remainder in digits:\n                    # we have a repeating decimal\n                    decimal.append(str(quotient))\n                    digits_repeating = (digit - digits[remainder] + 1)\n                    repeating = \" last %d digits repeating\" % digits_repeating\n                    break\n                else:\n                    # remember remainder in digits as this digit\n                    digits[remainder] = digit + 1\n                    # append quotient to decimal\n                    decimal.append(str(quotient))\n        last_numerator = remainder\n    \n    return {\n        \"denominator\": denominator,\n        \"decimal_representation\": \"\".join(decimal),\n        \"repeating_info\": repeating\n    }", "input_generator": "import random\n\ndef input_generator():\n    # Generate a denominator between 2 and 999 to avoid division by 1 and keep size reasonable\n    denominator = random.randint(2, 999)\n    return {\"denominator\": denominator}", "io_pairs": [{"input": {"denominator": 634}, "output": {"denominator": 634, "decimal_representation": "00157728706624605678233438485804416403785488958990536277602523659305993690851735", "repeating_info": " last 79 digits repeating"}}, {"input": {"denominator": 366}, "output": {"denominator": 366, "decimal_representation": "0027322404371584699453551912568306010928961748633879781420765", "repeating_info": " last 60 digits repeating"}}, {"input": {"denominator": 651}, "output": {"denominator": 651, "decimal_representation": "001536098310291858678955453149", "repeating_info": " last 30 digits repeating"}}, {"input": {"denominator": 844}, "output": {"denominator": 844, "decimal_representation": "001184834123222748815165876777251", "repeating_info": " last 30 digits repeating"}}, {"input": {"denominator": 915}, "output": {"denominator": 915, "decimal_representation": "0010928961748633879781420765027322404371584699453551912568306", "repeating_info": " last 60 digits repeating"}}, {"input": {"denominator": 200}, "output": {"denominator": 200, "decimal_representation": "005", "repeating_info": ""}}, {"input": {"denominator": 110}, "output": {"denominator": 110, "decimal_representation": "009", "repeating_info": " last 2 digits repeating"}}, {"input": {"denominator": 620}, "output": {"denominator": 620, "decimal_representation": "001612903225806451", "repeating_info": " last 15 digits repeating"}}, {"input": {"denominator": 656}, "output": {"denominator": 656, "decimal_representation": "0015243902", "repeating_info": " last 5 digits repeating"}}, {"input": {"denominator": 169}, "output": {"denominator": 169, "decimal_representation": "005917159763313609467455621301775147928994082840236686390532544378698224852071", "repeating_info": " last 78 digits repeating"}}], "error_log": []}
{"context": "Given the classic 8-queen problem, where you need to place 8 queens on an 8x8 chessboard such that no two queens threaten each other, starting from a specific row, what is the arrangement of queens that satisfies the condition?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start_row` (int): The row index from which to start placing the queens. It should be an integer between 0 and 7 inclusive.\n\nOutput:\n  `return` (list or None): A list of integers representing the column indices where queens are placed in each row. If no solution is found starting from `start_row`, it returns `None`.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef is_ok(row, column, result):\n    \"\"\"\n    Check if placing a queen at (row, column) is valid given the current result.\n    \"\"\"\n    leftup, rightup = column - 1, column + 1\n    for i in range(row - 1, -1, -1):\n        if column == result[i] or leftup == result[i] or rightup == result[i]:\n            return False\n        leftup -= 1\n        rightup += 1\n    return True\n\ndef cal8queen(row, result):\n    \"\"\"\n    Recursively calculate the positions of queens for the 8-queen problem.\n    \"\"\"\n    if row == 8:\n        return True\n    for column in range(8):\n        if is_ok(row, column, result):\n            result[row] = column\n            if cal8queen(row + 1, result):\n                return True\n    return False\n\n# main function\ndef main_solution(start_row):\n    \"\"\"\n    Solve the 8-queen problem starting from a given row.\n    \"\"\"\n    result = [0] * 8  # Initialize the result list\n    if cal8queen(start_row, result):\n        return result\n    else:\n        return None", "input_generator": "import random\n\ndef input_generator():\n    return {'start_row': random.randint(0, 7)}", "io_pairs": [{"input": {"start_row": 1}, "output": [0, 4, 7, 5, 2, 6, 1, 3]}, {"input": {"start_row": 4}, "output": [0, 0, 0, 0, 5, 7, 1, 3]}, {"input": {"start_row": 0}, "output": [0, 4, 7, 5, 2, 6, 1, 3]}, {"input": {"start_row": 2}, "output": [0, 0, 3, 5, 7, 1, 4, 2]}, {"input": {"start_row": 6}, "output": [0, 0, 0, 0, 0, 0, 7, 1]}], "error_log": []}
{"context": "Given a number represented by a list of digits, where some digits can be replaced by any digit from 0 to 9, what is the smallest prime number that can be formed by replacing these digits, such that the resulting number is part of an eight prime value family?\n\nThe input and output requirements are as follows:\n\nInput:\n  `guess` (str): A JSON serialized list of integers representing the digits of the number to be tested. The list may contain placeholders (represented by 10) which will be replaced by digits from 0 to 9 to form candidate numbers.\n\nOutput:\n  `return` (str): A string representing the smallest prime number in the family of numbers generated by replacing the placeholders in the input list with digits from 0 to 9. If no such family exists, an empty string is returned.", "reference_code": "# import necessary packages\nimport itertools\nimport json\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef get_family(guess):\n    candidates = [int(''.join(str(d) if d < 10 else str(nd) for d in guess)) for nd in range(10)]\n    return [candidate for candidate in candidates if is_prime(candidate)]\n\n# main function\ndef main_solution(guess):\n    # Convert the input list to a JSON serializable list\n    guess = json.loads(guess)\n    \n    # Get the prime family\n    family = get_family(guess)\n    \n    # Return the first member of the family as a string\n    return str(family[0]) if family else \"\"", "input_generator": "import random\nimport json\n\ndef input_generator():\n    # Generate a random length for the guess list (between 1 and 5)\n    length = random.randint(1, 5)\n    \n    # Generate random digits for the guess list (digits between 0 and 9)\n    guess = [random.randint(0, 9) for _ in range(length)]\n    \n    # Convert the guess list to a JSON string\n    guess_json = json.dumps(guess)\n    \n    return {'guess': guess_json}", "io_pairs": [{"input": {"guess": "[3]"}, "output": "3"}, {"input": {"guess": "[1, 4, 3, 6]"}, "output": ""}, {"input": {"guess": "[8, 2, 6]"}, "output": ""}, {"input": {"guess": "[8]"}, "output": ""}, {"input": {"guess": "[8, 3, 7, 0, 8]"}, "output": ""}, {"input": {"guess": "[3, 0]"}, "output": ""}, {"input": {"guess": "[7, 8, 2, 0]"}, "output": ""}, {"input": {"guess": "[2, 8, 4, 8]"}, "output": ""}, {"input": {"guess": "[5, 8, 0]"}, "output": ""}, {"input": {"guess": "[5, 1, 7]"}, "output": ""}], "error_log": []}
{"context": "Given a range of numbers from 2 to n, where n is an integer between 2 and 9, what is the largest 9-digit pandigital number that can be formed by concatenating the results of multiplying a number by each of the numbers from 1 to n?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The upper limit for the range of numbers to be checked for generating the largest pandigital number. It should be an integer between 2 and 9.\n\nOutput:\n  `return` (str): The largest 9-digit pandigital number that can be formed by concatenating the results of multiplying a number by each of the numbers from 1 to n.", "reference_code": "# import necessary packages\nfrom itertools import permutations\nfrom math import ceil\n\n# all class and function definitions in the code file, if any\ndef concatenate(number, tuple):\n    return ''.join(map(lambda d: str(number * d), tuple))\n\ndef is_pandigital(n):\n    digits = str(n)\n    if '0' in digits:\n        return False\n    return len(set(digits)) == 9 and len(digits) == 9\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    digits = map(str, range(1, 10))\n    big = 0\n\n    for n in range(2, n + 1):\n        R = int(ceil(9.0 / n))\n        t = range(1, n + 1)\n        for r in range(1, R + 1):\n            for d in map(lambda p: int(''.join(p)), permutations(digits, r)):\n                c = concatenate(d, t)\n                if is_pandigital(c) and c > big:\n                    big = c\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return big", "input_generator": "import random\n\ndef input_generator():\n    return {'n': random.randint(2, 5)}", "io_pairs": [{"input": {"n": 5}, "output": 0}, {"input": {"n": 3}, "output": 0}, {"input": {"n": 2}, "output": 0}, {"input": {"n": 4}, "output": 0}], "error_log": []}
{"context": "In a 4x4 tic-tac-toe game, a player wins if they have four consecutive marks (horizontally, vertically, or diagonally). The character 'T' can be considered as either 'X' or 'O'. Given a 4x4 board configuration, what is the current status of the game? Is it a win for 'X', a win for 'O', a draw, or is the game still ongoing?\n\nThe input and output requirements are as follows:\n\nInput:\n  `board` (str): A string representing the 4x4 tic-tac-toe board. Each row is separated by a newline character (`\\n`). The board contains characters 'X', 'O', 'T', and '.' where 'T' represents a wildcard that can be either 'X' or 'O', and '.' represents an empty cell.\n\nOutput:\n  `return` (str): A string indicating the result of the game. Possible values are:\n    - `\"X\"`: Player 'X' has won.\n    - `\"O\"`: Player 'O' has won.\n    - `\"draw\"`: The game is a draw.\n    - `\"incomplete\"`: The game is still ongoing.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef check_diagonal(board, t_loc):\n    result = -1\n    t_on_diag_left = (t_loc[0] == t_loc[1])\n    t_on_diag_right = t_loc[0] + t_loc[1] == 3\n    if  (not t_on_diag_left) and (board[0][0] == board[1][1] and board[2][2] == board[3][3] and board[0][0] == board[2][2]) and board[0][0] != '.':\n        result = board[0][0]\n    \n    elif (not t_on_diag_left) and (board[0][3] == board[1][2] and board[2][1] == board[3][0] and board[1][2] == board[2][1]) and board[0][3] != '.':\n        result = board[0][3]\n    \n    elif t_on_diag_left and board[0][0] != '.' and board[1][1] != '.' and board[2][2] != '.' and board[3][3] != '.':\n        row = 0\n        count = 0\n        player = board[0][0]\n        if player == 'T':\n            player = board[1][1]\n        for i in board:\n            if row != t_loc[0] and i[row] == player:\n                count = count + 1\n            row = row + 1\n        if count == 3:\n            result = player\n    \n    elif t_on_diag_right and board[0][3] != '.' and board[1][2] != '.' and board[2][1] != '.' and board[3][0] != '.':\n        row = 0\n        count = 0\n        player = board[0][3]\n        if player == 'T':\n            player = board[2][1]\n        for i in board:\n            if row != t_loc[0] and i[3 - row] == player:\n                count = count + 1\n            row = row + 1\n        if count == 3:\n            result = player\n    return result\n\ndef check_horizontal(board):\n    result = -1\n    for i in board:\n        if i == \"XXXX\" or i == \"TXXX\" or i == \"XTXX\" or i == \"XXTX\" or i == \"XXXT\":\n            result = 'X'\n        elif i == \"OOOO\" or i == \"TOOO\" or i == \"OTOO\" or i == \"OOTO\" or i == \"OOOT\":\n            result = 'O'\n    return result\n\ndef check_vertical(board, t_loc):\n    result = -1\n    i = 0\n    while i < 4:\n        if board[0][i] == board[1][i] and board[2][i] == board[3][i] and board[0][i] == board[2][i] and board[0][i] != '.' and i != t_loc[1]:\n            result = board[0][i]\n        elif i == t_loc[1]:\n            j = 0\n            count = 0\n            player = board[0][i]\n            if t_loc[0] == 0:\n                player = board[1][i]\n            while j < 4:\n                if board[j][i] == player and player != '.':\n                    count = count + 1\n                j = j + 1\n            if count == 3:\n                result = player\n        i = i + 1\n    return result\n\ndef check_draw(board):\n    result = \"draw\"\n    for i in board:\n        if '.' in i:\n            result = -1\n    return result\n\ndef check_win(board, t_loc):\n    win = -1\n    win = check_horizontal(board)\n    if win == -1:\n        win = check_vertical(board, t_loc)\n        if win == -1:\n            win = check_diagonal(board, t_loc)\n    return win\n\ndef assess_board(board, t_loc):\n    result = -1\n    winner = check_win(board, t_loc)\n    if winner != -1:\n        result = winner\n    else:\n        result = check_draw(board)\n    return result\n\ndef find_t(board):\n    row = 0\n    column  = -1\n    result = [-1, -2]\n    for i in board:\n        if 'T' in i:\n            column = i.index('T')\n            result = [row, column]\n        row = row + 1\n    return result\n\n# main function\ndef main_solution(board):\n    # Convert the board to a list of strings\n    board = [row for row in board.split('\\n') if row]\n    \n    # Find the location of 'T'\n    t_loc = find_t(board)\n    \n    # Assess the board to determine the result\n    result = assess_board(board, t_loc)\n    \n    # Convert the result to a JSON serializable output\n    if result == -1:\n        result = \"incomplete\"\n    \n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Possible characters in the board\n    chars = ['X', 'O', '.', 'T']\n    \n    # Generate a 4x4 board\n    board = []\n    t_loc = None\n    for i in range(4):\n        row = []\n        for j in range(4):\n            # Randomly choose a character, but ensure 'T' appears at most once\n            if t_loc is None and random.random() < 0.1:\n                char = 'T'\n                t_loc = (i, j)\n            else:\n                char = random.choice(['X', 'O', '.'])\n            row.append(char)\n        board.append(''.join(row))\n    \n    # Ensure 'T' is present at least once (50% chance)\n    if t_loc is None and random.random() < 0.5:\n        i = random.randint(0, 3)\n        j = random.randint(0, 3)\n        row = list(board[i])\n        row[j] = 'T'\n        board[i] = ''.join(row)\n        t_loc = (i, j)\n    \n    # Join the board into a single string with newlines\n    board_str = '\\n'.join(board)\n    \n    return {'board': board_str}", "io_pairs": [{"input": {"board": "O...\nXO..\n..XT\nXXO."}, "output": "incomplete"}, {"input": {"board": "X.TX\nX...\nOXXO\nOOOO"}, "output": "O"}, {"input": {"board": "XX.X\nX..X\nOOXX\n..OO"}, "output": "incomplete"}, {"input": {"board": "XOOX\n....\n..T.\nXXO."}, "output": "incomplete"}, {"input": {"board": "TX.O\nX.OX\n.OOO\n.X.."}, "output": "incomplete"}, {"input": {"board": "XX.T\n.OXO\nXO..\n...."}, "output": "incomplete"}, {"input": {"board": "OO.T\nXOXO\nO.O.\n...."}, "output": "incomplete"}, {"input": {"board": "TO..\n.OXO\n.X.O\nO.OX"}, "output": "incomplete"}, {"input": {"board": "OXOX\nOT..\n.OXX\nOOO."}, "output": "incomplete"}, {"input": {"board": "OO.T\nOOO.\n.O.X\nXX.."}, "output": "incomplete"}], "error_log": []}
{"context": "Given the historical information that 1900 started on a Monday and considering the rules for leap years, how many times does the first day of a month fall on a Sunday between the years `start_year` and `end_year` (inclusive)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `start_year` (int): The starting year of the range (inclusive).\n  `end_year` (int): The ending year of the range (inclusive).\n\nOutput:\n  `return` (int): The number of times the first day of a month falls on a Sunday within the specified range of years.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef isUruu(year):\n    result = False\n    if year % 4 == 0:\n        result = True\n        if year % 400 != 0 and year % 100 == 0:\n            result = False\n    return result\n\ndef isSun(day):\n    if day % 7 == 6:\n        return True\n    else:\n        return False\n\ndef getdays(month, year):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month in [4, 6, 9, 11]:\n        return 30\n    elif year % 400 == 0:\n        return 29\n    elif year % 100 == 0:\n        return 28\n    elif year % 4 == 0:\n        return 29\n    else:\n        return 28\n\n# main function\ndef main_solution(start_year, end_year):\n    result = 0\n    sum_of_days = 0\n    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Calculate the number of days from 1900 to the start of start_year\n    for year in range(1900, start_year):\n        for month in range(12):\n            sum_of_days += getdays(month + 1, year)\n    \n    # Check each month in the given range\n    for year in range(start_year, end_year + 1):\n        for month in range(12):\n            sum_of_days += getdays(month + 1, year)\n            if isSun(sum_of_days):\n                result += 1\n    \n    return result", "input_generator": "import random\n\ndef input_generator():\n    start_year = random.randint(1900, 2100)\n    end_year = random.randint(start_year, start_year + random.randint(1, 50))\n    return {'start_year': start_year, 'end_year': end_year}", "io_pairs": [{"input": {"start_year": 2007, "end_year": 2034}, "output": 48}, {"input": {"start_year": 2015, "end_year": 2015}, "output": 3}, {"input": {"start_year": 2013, "end_year": 2030}, "output": 31}, {"input": {"start_year": 1952, "end_year": 1991}, "output": 70}, {"input": {"start_year": 1935, "end_year": 1967}, "output": 56}, {"input": {"start_year": 1933, "end_year": 1953}, "output": 35}, {"input": {"start_year": 1978, "end_year": 1981}, "output": 7}, {"input": {"start_year": 1935, "end_year": 1939}, "output": 8}, {"input": {"start_year": 2066, "end_year": 2091}, "output": 44}, {"input": {"start_year": 1990, "end_year": 2011}, "output": 37}], "error_log": []}
{"context": "In a game of Tic-Tac-Toe, a player chooses either 'X' or 'O' and makes a series of moves on a 3x3 grid. The computer also makes moves in response. Given the player's piece choice and a sequence of moves made by both the player and the computer, what is the current status of the game?\n\nThe input and output requirements are as follows:\n\nInput:\n  `player_piece` (str): The piece chosen by the player ('X' or 'O').\n  `moves` (list of str): A list of moves made by the player and the computer, represented as strings ('1' to '9').\n\nOutput:\n  `return` (str): The result of the game, which can be \"Player wins\", \"Computer wins\", \"Draw\", or \"Game ongoing\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef initialize_board():\n    return {str(i): str(i) for i in range(1, 10)}\n\ndef display_board(board):\n    return [board[str(i)] for i in range(1, 10)]\n\ndef check_winner(board, player):\n    winning_scenarios = [\n        ['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9'],  # rows\n        ['1', '4', '7'], ['2', '5', '8'], ['3', '6', '9'],  # columns\n        ['1', '5', '9'], ['3', '5', '7']                   # diagonals\n    ]\n    for scenario in winning_scenarios:\n        if all(board[pos] == player for pos in scenario):\n            return True\n    return False\n\ndef get_valid_moves(board):\n    return [pos for pos in board if board[pos].isdigit()]\n\ndef make_move(board, position, player):\n    if position in get_valid_moves(board):\n        board[position] = player\n        return True\n    return False\n\n# main function\ndef main_solution(player_piece, moves):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    board = initialize_board()\n    current_player = 'X'\n    \n    for move in moves:\n        if current_player == player_piece:\n            make_move(board, move, player_piece)\n        else:\n            make_move(board, move, 'O' if player_piece == 'X' else 'X')\n        \n        if check_winner(board, player_piece):\n            return \"Player wins\"\n        elif check_winner(board, 'O' if player_piece == 'X' else 'X'):\n            return \"Computer wins\"\n        \n        current_player = 'O' if current_player == 'X' else 'X'\n    \n    return \"Draw\" if not get_valid_moves(board) else \"Game ongoing\"", "input_generator": "import random\n\ndef input_generator():\n    player_piece = random.choice(['X', 'O'])\n    valid_moves = [str(i) for i in range(1, 10)]\n    num_moves = random.randint(1, 9)\n    moves = random.sample(valid_moves, num_moves)\n    return {'player_piece': player_piece, 'moves': moves}", "io_pairs": [{"input": {"player_piece": "X", "moves": ["7", "1", "2", "4"]}, "output": "Game ongoing"}, {"input": {"player_piece": "O", "moves": ["5", "1", "2", "8", "6"]}, "output": "Game ongoing"}, {"input": {"player_piece": "O", "moves": ["6", "8", "4", "1", "2", "3", "7", "9", "5"]}, "output": "Computer wins"}, {"input": {"player_piece": "X", "moves": ["8", "3"]}, "output": "Game ongoing"}, {"input": {"player_piece": "O", "moves": ["6", "7", "3", "4", "5", "1", "2"]}, "output": "Player wins"}, {"input": {"player_piece": "X", "moves": ["1", "2", "6", "7", "9"]}, "output": "Game ongoing"}, {"input": {"player_piece": "O", "moves": ["1", "6", "4", "3", "5", "7", "2"]}, "output": "Game ongoing"}, {"input": {"player_piece": "X", "moves": ["6", "1", "2", "5", "7", "9", "4", "8", "3"]}, "output": "Computer wins"}, {"input": {"player_piece": "O", "moves": ["6", "7", "1"]}, "output": "Game ongoing"}, {"input": {"player_piece": "O", "moves": ["4", "5", "6"]}, "output": "Game ongoing"}], "error_log": []}
{"context": "In a traditional chess game, queens are placed on an N x N chessboard such that no two queens can attack each other. However, a new rule has been introduced where no three queens should lie in any straight line on the board. Given the size of the chessboard `N`, what is the arrangement of queens on the board that satisfies these conditions?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The size of the chessboard (N x N). It represents the number of queens to be placed on the board.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents the column position of a queen on the board. The positions are 1-based (i.e., the first column is represented as \"1\"). If no solution is found, the list will be empty.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef cross_lines(r, N, drop, result):\n    for y, x in enumerate(result):\n        for z, x2 in enumerate(result[(y+1):]):\n            y2 = z + y + 1\n            dx = x2 - x\n            dy = y2 - y\n            n = (r - y) * dx / float(dy)\n            if n - int(n) == 0 and x + n >= 0 and x + n < N:\n                drop.add(x + int(n))\n\ndef insert(r, N, result, space):\n    \"\"\" insert a queen into row r of board b \"\"\" \n    drop = set(result)\n    #cross out diagonals intersection\n    for y, x in enumerate(result):\n        c = x + (y - r)\n        if c < N and c >= 0:\n            drop.add(c)\n        c = x - (y - r)\n        if c >= 0 and c < N: \n            drop.add(c)\n\n    #cross out lines intersections\n    cross_lines(r, N, drop, result)\n    #get possible columns\n    for c in (x for x in space if x not in drop):\n        result.append(c)\n        if r < (N-1):\n            if(insert(r + 1, N, result, space)):\n                return True\n            else:\n                result.pop()\n        else:\n            return True\n    return False\n\n# main function\ndef main_solution(N):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    result = []\n    space = range(N)\n    if insert(0, N, result, space):\n        # Convert result to a list of strings representing the column positions\n        return [str(n + 1) for n in result]\n    else:\n        return []", "input_generator": "import random\n\ndef input_generator():\n    N = random.randint(1, 20)  # Reasonable size for N-Queens problem\n    return {'N': N}", "io_pairs": [], "error_log": ["Timeout expired after {timeout} seconds"]}
{"context": "Given a parameterized curve in n-dimensional Euclidean space, defined by a list of functions and a parameter, what is the length of the curve at a specific value of the parameter?\n\nThe input and output requirements are as follows:\n\nInput:\n  `functions` (list of strings): A list of strings representing the parameterized functions of the curve.\n  `parameter` (string): A string representing the parameter of the curve.\n  `value` (float): A float representing the value at which to evaluate the length of the curve.\n\nOutput:\n  `return` (float): A float representing the length of the curve at the given value.", "reference_code": "# import necessary packages\nimport numpy as np\nfrom sympy import integrate, sqrt, diff, simplify\nfrom sympy.abc import x\n\n# all class and function definitions in the code file, if any\nclass Curve:\n    def __init__(self, functions, parameter):\n        self.functions = functions\n        self.parameter = parameter\n\n    @property\n    def dimension(self):\n        return len(self.functions)\n\n    def dot(self, other):\n        result = np.dot(self.functions, other.functions)\n        return simplify(result)\n\n    def length(self):\n        result = sqrt(self.dot(self))\n        return simplify(result)\n\n    def angle(self, other):\n        dots = self.dot(other)\n        simplifiedLengths = self.length() * other.length()\n        result = dots / simplifiedLengths\n        return simplify(result)\n\n    def isPerpendicular(self, other):\n        return self.dot(other) == 0\n\n    def cross(self, other):\n        product = list(np.cross(self.functions, other.functions))\n        result = [simplify(pr) for pr in product]\n        return Curve(result, self.parameter)\n\n    def isUnitLength(self):\n        d = self.diffV()\n        return d.length() == 1\n\n    def uTangent(self):\n        if self.dimension != 3:\n            raise ValueError(\"Finding the Tangent curve requires 3 dimensions but got %s dimensions\" % str(self.dimension))\n        if not self.isUnitLength():\n            raise ValueError(\"Using uTangent requires a unit speed curve but input curve is not\")\n        return self.diffV()\n\n    def uNormal(self):\n        if self.dimension != 3:\n            raise ValueError(\"Finding the Normal curve requires 3 dimensions but got %s dimensions\" % str(self.dimension))\n        if not self.isUnitLength():\n            raise ValueError(\"Using uNormal requires a unit speed curve but input curve is not\")\n        tangentPrime = self.uTangent().diffV()\n        tPrimeLength = tangentPrime.length()\n        if tPrimeLength != 0:\n            tangentPrimeFunctions = list((np.array(tangentPrime.functions)) / tPrimeLength)\n            return Curve(tangentPrimeFunctions, self.parameter)\n        else:\n            return \"undefined\"\n\n    def uCurvature(self):\n        if self.dimension != 3:\n            raise ValueError(\"Finding the curvature of the curve requires 3 dimensions but got %s dimensions\" % str(self.dimension))\n        if not self.isUnitLength():\n            raise ValueError(\"Using uCurvature requires a unit speed curve but input curve is not\")\n        tangentPrime = self.uTangent().diffV()\n        return tangentPrime.length()\n\n    def solveCurve(self, value):\n        results = [func.subs(self.parameter, value) for func in self.functions]\n        return results\n\n    def uBinormal(self):\n        if self.dimension != 3:\n            raise ValueError(\"Finding the Binormal curve requires 3 dimensions but got %s dimensions\" % str(self.dimension))\n        if not self.isUnitLength():\n            raise ValueError(\"Using uBinormal requires a unit speed curve but input curve is not\")\n        normal = self.uNormal()\n        tangent = self.uTangent()\n        if type(normal) is str:\n            return \"undefined\"\n        else:\n            return tangent.cross(normal)\n\n    def uTorsion(self):\n        if self.dimension != 3:\n            raise ValueError(\"Finding the curvature of the curve requires 3 dimensions but got %s dimensions\" % str(self.dimension))\n        if not self.isUnitLength():\n            raise ValueError(\"Using uTorsion requires a unit speed curve but input curve is not\")\n        binormalPrime = self.diffV()\n        normal = self.uNormal()\n        return binormalPrime.dot(normal)\n\n    def diffV(self):\n        result = [diff(func, self.parameter) for func in self.functions]\n        return Curve(result, self.parameter)\n\n# main function\ndef main_solution(functions, parameter, value):\n    # Convert JSON serializable inputs to original input variables\n    functions = [simplify(func) for func in functions]\n    parameter = simplify(parameter)\n    \n    # Create the Curve object\n    curve = Curve(functions, parameter)\n    \n    # Calculate the length of the curve at the given value\n    length_at_value = curve.length().subs(curve.parameter, value)\n    \n    # Return the length as a JSON serializable output\n    return float(length_at_value)", "input_generator": "import numpy as np\nfrom sympy import symbols, sin, cos, exp, ln, sqrt\nimport random\n\ndef input_generator():\n    x = symbols('x')\n    parameter = x\n    \n    # Randomly choose a type of curve\n    curve_type = random.choice(['trigonometric', 'polynomial', 'exponential', 'logarithmic'])\n    \n    if curve_type == 'trigonometric':\n        functions = [\n            sin(x),\n            cos(x),\n            sin(x) + cos(x)\n        ]\n    elif curve_type == 'polynomial':\n        a = random.randint(1, 3)\n        b = random.randint(1, 3)\n        c = random.randint(1, 3)\n        functions = [\n            a * x**2 + b * x + c,\n            b * x**3 - a * x,\n            c * x**2 - b * x + a\n        ]\n    elif curve_type == 'exponential':\n        functions = [\n            exp(x),\n            exp(-x),\n            exp(x) - exp(-x)\n        ]\n    else:  # logarithmic\n        functions = [\n            ln(x + 1),\n            ln(x + 2),\n            ln(x + 1) - ln(x + 2)\n        ]\n    \n    # Ensure the functions are in a list and simplified\n    functions = [func for func in functions]\n    \n    # Generate a random value within a reasonable range\n    value = random.uniform(0.1, 5.0)\n    \n    # Convert functions to strings for JSON serialization\n    functions_str = [str(func) for func in functions]\n    \n    return {\n        'functions': functions_str,\n        'parameter': str(parameter),\n        'value': value\n    }", "io_pairs": [{"input": {"functions": ["3*x**2 + x + 2", "x**3 - 3*x", "2*x**2 - x + 3"], "parameter": "x", "value": 2.0800481074215096}, "output": 19.75595903702465}, {"input": {"functions": ["exp(x)", "exp(-x)", "exp(x) - exp(-x)"], "parameter": "x", "value": 3.484283931638175}, "output": 46.0803791195863}, {"input": {"functions": ["3*x**2 + 3*x + 2", "3*x**3 - 3*x", "2*x**2 - 3*x + 3"], "parameter": "x", "value": 4.2079025444614375}, "output": 223.0064045060932}, {"input": {"functions": ["3*x**2 + x + 3", "x**3 - 3*x", "3*x**2 - x + 3"], "parameter": "x", "value": 4.656249301832881}, "output": 129.8792312791326}, {"input": {"functions": ["sin(x)", "cos(x)", "sin(x) + cos(x)"], "parameter": "x", "value": 4.324383013127983}, "output": 1.6433011483797118}, {"input": {"functions": ["x**2 + 3*x + 1", "3*x**3 - x", "x**2 - 3*x + 1"], "parameter": "x", "value": 1.8202754934263181}, "output": 19.01798058301115}, {"input": {"functions": ["exp(x)", "exp(-x)", "exp(x) - exp(-x)"], "parameter": "x", "value": 0.8316871374759377}, "output": 2.9888411331721922}, {"input": {"functions": ["exp(x)", "exp(-x)", "exp(x) - exp(-x)"], "parameter": "x", "value": 4.751407132009969}, "output": 163.6849269637655}, {"input": {"functions": ["exp(x)", "exp(-x)", "exp(x) - exp(-x)"], "parameter": "x", "value": 0.17788228868729622}, "output": 1.5019381102141942}, {"input": {"functions": ["sin(x)", "cos(x)", "sin(x) + cos(x)"], "parameter": "x", "value": 2.789334789644611}, "output": 1.1628994254324605}], "error_log": []}
{"context": "Given the specifications of a material (type, thickness, and dimensions), and the desired frequency band, what are the sound insulation values in decibels for the specified frequency range?\n\nThe input and output requirements are as follows:\n\nInput:\n  `material` (str): The type of material, e.g., 'Ladrillo', 'Concrete', 'Wood'.\n  `thickness` (float): The thickness of the material in meters.\n  `lx` (float): The length of the material in the x-direction in meters.\n  `ly` (float): The length of the material in the y-direction in meters.\n  `frequency_band` (str): The type of frequency band, either 'octave' or 'third'.\n\nOutput:\n  `return` (list of float): A list of sound insulation values in dB for the specified frequency band.", "reference_code": "# import necessary packages\nimport numpy as np\nimport pandas as pd\n\n# all class and function definitions in the code file, if any\ndef octave_thirdoctave(frequency_band):\n    '''\n    Returns a numpy array, with frequency values ranging 20 Hz to 20Khz.\n    If you type 'octave' it will return 10 values, from 31.5 Hz to 16KHz.\n    If you type 'third' it will return 31 values, from 31.5 Hz to 16KHz.\n\n    Parameters\n    ----------\n    frequency_band : str\n        Type 'octave' or 'third' to choose frequency band type.\n\n    Returns\n    -------\n    freqs : ndarray\n        The desired numpy array.\n\n    '''\n    band_type = {'octave' : [31.5,63,125,250,500,1000,2000,4000,8000,16000],\n              'third' : [20,25,31.5,40,50,63,80,100,125,160,\n                         200,250,315,400,500,630,800,1000,\n                         1250,1600,2000,2500,3150,4000,5000,\n                         6300,8000,10000,12500,16000,20000]}\n    \n    if(frequency_band=='octave'):\n        freqs = np.array(band_type['octave'])\n    elif(frequency_band=='third'):\n        freqs = np.array(band_type['third'])\n    else:\n        print('Error')\n    \n    return freqs\n\ndef parametro(tipo_de_material):\n    materiales = pd.DataFrame({\n        'Material': ['Ladrillo', 'Concrete', 'Wood'],\n        'Densidad': [1800, 2400, 600],\n        'M\u00f3dulo de Young': [2.5e10, 3e10, 1.2e10],\n        'Factor de p\u00e9rdidas': [0.01, 0.02, 0.05],\n        'M\u00f3dulo Poisson': [0.2, 0.2, 0.3]\n    })\n    \n    a = materiales['Material'] == tipo_de_material\n        \n    for i in range(len(a)):\n        if a[i]==True:\n            datos = materiales.iloc[i]\n            density  = datos.loc['Densidad']\n            E = datos.loc['M\u00f3dulo de Young']\n            ninterno = datos.loc['Factor de p\u00e9rdidas']\n            tau = datos.loc['M\u00f3dulo Poisson']\n            \n    return density, E, ninterno, tau\n\ndef cremer_model(freqs, lx, ly, thickness, young, poisson, density, ninterno, c0 = 343):\n    ms = density * thickness\n    B = (young*(thickness**3))/(12*(1-(poisson**2)))\n    fc = ((c0**2)/(2*np.pi))*(np.sqrt(ms/B))\n    fd = (young/(2*np.pi*density)) * (np.sqrt(ms/B))\n\n    R = np.zeros_like(freqs)\n    ntotal = np.array(np.zeros(len(freqs)))\n        \n    R[freqs<fc] = 20*np.log10(ms*freqs[freqs<fc])-47\n        \n    condition = (freqs>fc) & (fd>freqs)\n    ntotal[condition] = ninterno + (ms/(485*np.sqrt(freqs[condition])))\n    R[condition] = (20*np.log10(ms*freqs[condition]) \n                    - 10*np.log10(np.pi/(4*ntotal[condition])) \n                    - 10*np.log10(fc/(freqs[condition]-fc)) - 47)    \n    \n    R[freqs>fd] = 20*np.log10(ms*freqs[freqs>fd]) - 47\n            \n    return R\n\n# main function\ndef main_solution(material, thickness, lx, ly, frequency_band):\n    # Convert JSON serializable inputs to original input variables\n    freqs = octave_thirdoctave(frequency_band)\n    density, young, ninterno, poisson = parametro(material)\n    \n    # Calculate the result using the cremer_model\n    result = cremer_model(freqs, lx, ly, thickness, young, poisson, density, ninterno)\n    \n    # Convert the result to JSON serializable output\n    result = result.tolist()\n    \n    return result", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    materials = ['Ladrillo', 'Concrete', 'Wood']\n    frequency_bands = ['octave', 'third']\n    \n    material = random.choice(materials)\n    thickness = random.uniform(0.01, 0.1)  # in meters (1 cm to 10 cm)\n    lx = random.uniform(1.0, 10.0)  # in meters\n    ly = random.uniform(1.0, 10.0)  # in meters\n    frequency_band = random.choice(frequency_bands)\n    \n    return {\n        'material': material,\n        'thickness': thickness,\n        'lx': lx,\n        'ly': ly,\n        'frequency_band': frequency_band\n    }", "io_pairs": [{"input": {"material": "Ladrillo", "thickness": 0.032939172368322056, "lx": 8.384671368302165, "ly": 4.747293189122419, "frequency_band": "octave"}, "output": [18.425914835075446, 24.44651474835507, 30.397904019444553, 36.41850393272418, 42.4391038460038, 30.62044898837543, 41.147347260281066, 50.5952365507347, 59.72644151596229, 68.74933848317379]}, {"input": {"material": "Wood", "thickness": 0.07639381505967298, "lx": 6.854016323523533, "ly": 3.4740204633498664, "frequency_band": "octave"}, "output": [16.190400062783283, 22.210999976062894, 28.162389247152404, 18.514192046083494, 31.051728417876618, 41.06789632871565, 50.48196778054792, 59.671986186931576, 68.76759647578913, 77.82210103861594]}, {"input": {"material": "Concrete", "thickness": 0.045894691547020874, "lx": 6.457348792846481, "ly": 6.7411993071919305, "frequency_band": "octave"}, "output": [23.80568501721332, 29.826284930492946, 35.77767420158243, 41.79827411486205, 28.0802244145964, 41.143594878272296, 51.03674098105931, 60.30111242439081, 69.36347218126383, 78.35902575572331]}, {"input": {"material": "Wood", "thickness": 0.012556664477454129, "lx": 2.4873117975725614, "ly": 1.5881561067566077, "frequency_band": "octave"}, "output": [0.5067218787812493, 6.527321792060874, 12.47871106315037, 18.499310976429996, 24.51991088970962, 30.540510802989246, 23.742065627887015, 34.84166784930804, 44.62218054738419, 53.9823790346871]}, {"input": {"material": "Concrete", "thickness": 0.05781028764670738, "lx": 6.471851470184601, "ly": 3.1769084987401564, "frequency_band": "octave"}, "output": [25.81053851602391, 31.831138429303536, 37.78252770039303, 43.80312761367266, 33.86999407979465, 44.98018339086052, 54.47924368672375, 63.572811956146154, 72.54179297772004, 81.48061577239321]}, {"input": {"material": "Concrete", "thickness": 0.033673084949213485, "lx": 9.46851620268432, "ly": 3.0428953877037292, "frequency_band": "octave"}, "output": [21.116094029319555, 27.13669394259918, 33.08808321368866, 39.10868312696829, 45.12928304024791, 35.636463291023134, 46.35971992998729, 55.912462470533825, 65.11489303617468, 74.18857351219303]}, {"input": {"material": "Concrete", "thickness": 0.05212210603901151, "lx": 3.5681547936080182, "ly": 1.7022703649451265, "frequency_band": "octave"}, "output": [24.910875018848387, 30.931474932128012, 36.882864203217494, 42.90346411649712, 31.491384617518477, 43.276202577148595, 52.936802910888176, 62.10364285699198, 71.11377097766706, 80.07808660601881]}, {"input": {"material": "Ladrillo", "thickness": 0.06464036175351891, "lx": 5.566552839539479, "ly": 8.148816668254636, "frequency_band": "octave"}, "output": [24.281736743064172, 30.302336656343797, 36.253725927433294, 42.27432584071292, 32.029339397310764, 42.273298622152495, 51.43337004589793, 60.3137883448924, 69.1306676477072, 77.95727731768936]}, {"input": {"material": "Wood", "thickness": 0.07238754963615189, "lx": 7.069212323015411, "ly": 6.178214896321454, "frequency_band": "octave"}, "output": [15.722513598211151, 21.743113511490776, 27.69450278258026, 17.105071729983848, 30.193408129317632, 40.29971443222381, 49.74689315824517, 58.95212826146536, 68.05547970656286, 77.11416406793586]}, {"input": {"material": "Ladrillo", "thickness": 0.010360489133665881, "lx": 7.114448097328564, "ly": 8.410808014518414, "frequency_band": "octave"}, "output": [8.37926636912622, 14.399866282405846, 20.351255553495335, 26.37185546677496, 32.392455380054585, 38.41305529333421, 19.16722935431929, 33.313601623978144, 43.57304710046961, 53.08014198540971]}], "error_log": []}
{"context": "Given a binary tree represented by a list of integers and `None` values, where each integer represents a node value and `None` represents a missing node, determine whether the binary tree is balanced. A balanced binary tree is defined as a tree where the absolute difference in height between the left and right subtrees of every node is no more than 1, and both the left and right subtrees are also balanced. What is the result indicating whether the given binary tree is balanced?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_structure` (list of int or None): A list representing the structure of the binary tree. Each element in the list represents a node value, with `None` indicating a missing node. The list is constructed in a breadth-first manner, starting from the root.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is balanced. `True` if the tree is balanced, `False` otherwise.", "reference_code": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deep(self, root):\n        if root == None:\n            return 0\n        return max(self.deep(root.left), self.deep(root.right)) + 1\n\n    def IsBalanced_Solution(self, root):\n        if root == None:\n            return True\n        if (abs(self.deep(root.left) - self.deep(root.right)) < 2 and self.IsBalanced_Solution(\n                root.left) and self.IsBalanced_Solution(root.right)):\n            return True\n        else:\n            return False\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            node = queue.pop(0)\n            if nodes[i] is not None:\n                node.left = TreeNode(nodes[i])\n                queue.append(node.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                node.right = TreeNode(nodes[i])\n                queue.append(node.right)\n            i += 1\n        return root\n\n    root = build_tree(tree_structure)\n    solution = Solution()\n    is_balanced = solution.IsBalanced_Solution(root)\n    \n    # Convert the output to JSON serializable format\n    return is_balanced", "input_generator": "import random\nimport json\n\ndef input_generator():\n    def generate_tree(depth):\n        if depth == 0:\n            return None\n        val = random.randint(1, 100)\n        node = [val]\n        left = generate_tree(depth - 1) if random.random() < 0.7 else None\n        right = generate_tree(depth - 1) if random.random() < 0.7 else None\n        if left is not None:\n            node.append(left[0] if isinstance(left, list) else left)\n        else:\n            node.append(None)\n        if right is not None:\n            node.append(right[0] if isinstance(right, list) else right)\n        else:\n            node.append(None)\n        return node\n    \n    def flatten_tree(tree):\n        if not tree:\n            return []\n        flattened = []\n        queue = [tree]\n        while queue:\n            current = queue.pop(0)\n            if isinstance(current, list):\n                flattened.append(current[0])\n                children = current[1:]\n                queue.extend(children)\n            else:\n                flattened.append(current)\n        return flattened\n    \n    depth = random.randint(1, 5)\n    tree = generate_tree(depth)\n    tree_structure = flatten_tree(tree)\n    \n    return {'tree_structure': tree_structure}", "io_pairs": [{"input": {"tree_structure": [56, null, null]}, "output": true}, {"input": {"tree_structure": [15, null, 35]}, "output": true}, {"input": {"tree_structure": [30, null, 90]}, "output": true}, {"input": {"tree_structure": [92, null, 32]}, "output": true}, {"input": {"tree_structure": [37, 19, null]}, "output": true}, {"input": {"tree_structure": [42, 91, 48]}, "output": true}, {"input": {"tree_structure": [62, 5, 82]}, "output": true}, {"input": {"tree_structure": [56, 57, null]}, "output": true}, {"input": {"tree_structure": [40, null, null]}, "output": true}, {"input": {"tree_structure": [38, null, null]}, "output": true}], "error_log": []}
{"context": "Given a neural network with a linear layer followed by a ReLU activation and a softmax layer, and a cross-entropy loss function, what is the cross-entropy loss after one forward and backward pass, given the input data, labels, and learning rate?\n\nThe input and output requirements are as follows:\n\nInput:\n  `in_features` (int): The size of each input sample.\n  `out_features` (int): The size of each output sample.\n  `input_data` (list of lists): A 2D list representing the input data, where each sublist is a sample.\n  `labels` (list of lists): A 2D list representing the labels, where each sublist is a one-hot encoded label corresponding to the input data.\n  `learning_rate` (float): The learning rate used for updating the parameters.\n\nOutput:\n  `return` (float): The computed cross-entropy loss after one forward and backward pass.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass LinearModule(object):\n    def __init__(self, in_features, out_features):\n        self.params = {'weight': np.random.normal(0, 0.0001, (in_features, out_features)),\n                       'bias': np.zeros(out_features)}\n        self.grads = {'weight': np.zeros((in_features, out_features)), 'bias': np.zeros(out_features)}\n        self.x = None\n        self.out_features = out_features\n\n    def forward(self, x):\n        self.x = x\n        out = x @ self.params[\"weight\"] + self.params[\"bias\"]\n        return out\n\n    def backward(self, dout):\n        self.grads[\"weight\"] = self.x.T @ dout\n        self.grads[\"bias\"] = dout.mean(axis=0)\n        dx = dout @ self.params[\"weight\"].T\n        return dx\n\n    def update_parameters(self, learning_rate):\n        self.params[\"weight\"] -= learning_rate * self.grads[\"weight\"]\n        self.params[\"bias\"] -= learning_rate * self.grads[\"bias\"]\n\nclass ReLUModule(object):\n    def __init__(self):\n        self.x = None\n\n    def forward(self, x):\n        self.x = x\n        out = np.maximum(np.zeros(x.shape), x)\n        return out\n\n    def backward(self, dout):\n        dx = dout * (self.x > 0).astype(int)\n        return dx\n\nclass SoftMaxModule(object):\n    def __init__(self):\n        self.x = None\n\n    def forward(self, x):\n        self.x = x\n        out = self.softmax(x)\n        return out\n\n    @staticmethod\n    def softmax(x):\n        z = x.max(axis=1, keepdims=True)\n        z = np.repeat(z, x.shape[1], axis=1)\n        out = np.exp(x - z) / np.exp(x - z).sum(axis=1, keepdims=True)\n        return out\n\n    def backward(self, dout):\n        out = self.softmax(self.x)\n        gradient = - np.einsum(\"ij, ik -> ijk\", out, out)\n        diagonals = np.apply_along_axis(np.diag, axis=1, arr=out)\n        gradient += diagonals\n        dout = dout[..., np.newaxis]\n        dx = np.einsum(\"ijk, ikl -> ijl\", gradient, dout).squeeze(axis=2)\n        return dx\n\nclass CrossEntropyModule(object):\n    def forward(self, x, y):\n        epsilon = 1e-10\n        x[x == 0] = epsilon\n        out = - (np.log(x) * y).sum(axis=1)\n        out = out.mean()\n        return out\n\n    def backward(self, x, y):\n        dx = - y / x\n        dx = dx / x.shape[0]\n        return dx\n\n# main function\ndef main_solution(in_features, out_features, input_data, labels, learning_rate):\n    # Convert JSON serializable inputs to original input variables\n    input_data = np.array(input_data)\n    labels = np.array(labels)\n\n    # Initialize modules\n    linear_module = LinearModule(in_features, out_features)\n    relu_module = ReLUModule()\n    softmax_module = SoftMaxModule()\n    cross_entropy_module = CrossEntropyModule()\n\n    # Forward pass\n    linear_output = linear_module.forward(input_data)\n    relu_output = relu_module.forward(linear_output)\n    softmax_output = softmax_module.forward(relu_output)\n    loss = cross_entropy_module.forward(softmax_output, labels)\n\n    # Backward pass\n    dsoftmax = cross_entropy_module.backward(softmax_output, labels)\n    drelu = softmax_module.backward(dsoftmax)\n    dlinear = relu_module.backward(drelu)\n    linear_module.backward(dlinear)\n\n    # Update parameters\n    linear_module.update_parameters(learning_rate)\n\n    # Convert output to JSON serializable\n    return float(loss)", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    in_features = random.randint(1, 10)\n    out_features = random.randint(1, 10)\n    batch_size = random.randint(1, 10)\n    \n    input_data = np.random.randn(batch_size, in_features).tolist()\n    labels = np.zeros((batch_size, out_features))\n    for i in range(batch_size):\n        labels[i, random.randint(0, out_features-1)] = 1\n    labels = labels.tolist()\n    \n    learning_rate = random.uniform(0.001, 0.1)\n    \n    return {\n        'in_features': in_features,\n        'out_features': out_features,\n        'input_data': input_data,\n        'labels': labels,\n        'learning_rate': learning_rate\n    }", "io_pairs": [{"input": {"in_features": 5, "out_features": 1, "input_data": [[0.14335287064234292, -0.3153342458830066, 1.870672974159895, 1.3858661498834686, 1.586918763118123]], "labels": [[1.0]], "learning_rate": 0.06322725619621565}, "output": 0.0}, {"input": {"in_features": 4, "out_features": 1, "input_data": [[-0.38571971124156473, 0.8278036296730664, 1.3497170963513272, -0.4748717112826762]], "labels": [[1.0]], "learning_rate": 0.03620388052867513}, "output": 0.0}, {"input": {"in_features": 1, "out_features": 1, "input_data": [[-0.657679908076328]], "labels": [[1.0]], "learning_rate": 0.03784877713344583}, "output": 0.0}, {"input": {"in_features": 3, "out_features": 2, "input_data": [[0.6941440894195878, 2.3734380611823847, 0.3509249734994405]], "labels": [[0.0, 1.0]], "learning_rate": 0.09992001937608513}, "output": 0.6931471805599453}, {"input": {"in_features": 2, "out_features": 3, "input_data": [[1.9215936911509957, -0.38811969913401306]], "labels": [[0.0, 1.0, 0.0]], "learning_rate": 0.0035051539022531654}, "output": 1.0985061505412357}, {"input": {"in_features": 1, "out_features": 1, "input_data": [[0.708187465253001]], "labels": [[1.0]], "learning_rate": 0.08824189367450345}, "output": 0.0}, {"input": {"in_features": 3, "out_features": 2, "input_data": [[0.6703197626614336, 0.5214943798540879, 0.8327456196718386]], "labels": [[0.0, 1.0]], "learning_rate": 0.061917241584557636}, "output": 0.6930855060821163}, {"input": {"in_features": 3, "out_features": 1, "input_data": [[-2.242017507078936, -0.6176676717460208, 0.9405359230193502]], "labels": [[1.0]], "learning_rate": 0.08072194560774412}, "output": 0.0}, {"input": {"in_features": 1, "out_features": 3, "input_data": [[1.4134242650834512]], "labels": [[1.0, 0.0, 0.0]], "learning_rate": 0.038176154474007275}, "output": 1.0984506034515493}, {"input": {"in_features": 2, "out_features": 3, "input_data": [[0.6084813162672501, -0.3096253985363737]], "labels": [[0.0, 1.0, 0.0]], "learning_rate": 0.04954883650794157}, "output": 1.098634173161042}], "error_log": []}
{"context": "Given a message encoded by mapping each letter to its corresponding number (a=1, b=2, ..., z=26), how many different ways can the encoded message be decoded back into its original form?\n\nThe input and output requirements are as follows:\n\nInput:\n  `encoded_message` (str): A string representing the encoded message where each character is mapped to its corresponding number (a=1, b=2, ..., z=26).\n\nOutput:\n  `return` (int): The number of ways the encoded message can be decoded.", "reference_code": "# import necessary packages\nfrom collections import deque\nfrom random import randint\n\n# all class and function definitions in the code file, if any\ndef encode(string):\n    return ''.join([str(ord(c) - 96) for c in string])\n\ndef decode(string):\n    solutions = []\n    queue = deque([[[], string]])\n    while queue:\n        path, rem = queue.popleft()\n        if rem:\n            if 10 <= int(rem[:2]) <= 26:\n                if len(rem[:3]) == 3 and int(rem[:3]) % 10 == 0:\n                    queue.append([path + [int(rem[0])], rem[1:]])\n                    continue\n                queue.append([path + [int(rem[:2])], rem[2:]])\n                if int(rem[:2]) % 10 == 0:\n                    continue\n            queue.append([path + [int(rem[0])], rem[1:]])\n        else:\n            solutions.append(path)\n    return solutions\n\n# main function\ndef main_solution(encoded_message):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solutions = decode(encoded_message)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return len(solutions)", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random string of lowercase letters\n    length = random.randint(1, 10)\n    original_string = ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n    \n    # Encode the string to digits\n    encoded_message = ''.join([str(ord(c) - 96) for c in original_string])\n    \n    return {'encoded_message': encoded_message}", "io_pairs": [{"input": {"encoded_message": "1210"}, "output": 2}, {"input": {"encoded_message": "157232"}, "output": 4}, {"input": {"encoded_message": "201018410826"}, "output": 4}, {"input": {"encoded_message": "12"}, "output": 2}, {"input": {"encoded_message": "51982341511132421"}, "output": 160}, {"input": {"encoded_message": "14261213"}, "output": 20}, {"input": {"encoded_message": "22220"}, "output": 3}, {"input": {"encoded_message": "17131"}, "output": 4}, {"input": {"encoded_message": "21885"}, "output": 3}, {"input": {"encoded_message": "2561314"}, "output": 8}], "error_log": []}
{"context": "Given a one-dimensional cellular automaton that evolves according to specific rules, what will be the state of the automaton after a certain number of generations, starting from a given initial configuration? The automaton's rules are defined by a pattern number, which determines how each cell and its neighbors evolve over time. The initial configuration is a string of characters consisting of '.' and 'x', and the evolution is applied repeatedly for a specified number of generations.\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_string` (str): A non-empty string consisting of the characters '.' and 'x'.\n  `pattern_number` (int): An integer between 0 and 255 representing a set of rules for the cellular automaton.\n  `generations` (int): A positive integer representing the number of generations to apply the rules.\n\nOutput:\n  `return` (str): The resulting string after applying the rules for the specified number of generations.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef build_patterns(pattern_number):\n    default_patterns = {\n        1 : '...',\n        2 : '..x',\n        4 : '.x.',\n        8 : '.xx',\n        16 : 'x..',\n        32 : 'x.x',\n        64 : 'xx.',\n        128 : 'xxx'\n    }\n\n    patterns = {}\n    for k in reversed(sorted(default_patterns.keys())):\n        if pattern_number >= k:\n            patterns[default_patterns[k]] = 'x'\n            pattern_number -= k\n        else:\n            patterns[default_patterns[k]] = '.'\n    return patterns\n\ndef calculate_field(field, patterns, gen_number):\n    if gen_number == 0:\n        return field\n    else:\n        l = ['']*len(field)\n        length = len(field)\n        for i in range(0, length):\n            pattern_item = field[i-1] + field[i] + field[(i+1) % length]\n            l[i] = patterns[pattern_item]\n        field = ''.join(l)\n        return calculate_field(field, patterns, gen_number - 1)\n\n# main function\ndef main_solution(initial_string, pattern_number, generations):\n    # Convert JSON serializable inputs to original input variables\n    pattern_number = int(pattern_number)\n    generations = int(generations)\n    \n    # Invoke the original functions\n    pattern = build_patterns(pattern_number)\n    result = calculate_field(initial_string, pattern, generations)\n    \n    # Convert the result to JSON serializable output\n    return result", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random initial string with '.' and 'x' characters\n    length = random.randint(5, 20)\n    initial_string = ''.join(random.choice(['.', 'x']) for _ in range(length))\n    \n    # Generate a random pattern number between 0 and 255\n    pattern_number = random.randint(0, 255)\n    \n    # Generate a random number of generations between 1 and 10\n    generations = random.randint(1, 10)\n    \n    return {\n        'initial_string': initial_string,\n        'pattern_number': pattern_number,\n        'generations': generations\n    }", "io_pairs": [{"input": {"initial_string": ".xxxxxx...", "pattern_number": 43, "generations": 8}, "output": "xxxxx....x"}, {"input": {"initial_string": "...xx.x.x..", "pattern_number": 190, "generations": 6}, "output": "xxxxx.xxxx."}, {"input": {"initial_string": "....x...x...x", "pattern_number": 209, "generations": 1}, "output": "xxx..xx..xx.."}, {"input": {"initial_string": "...xx.x.....x", "pattern_number": 70, "generations": 4}, "output": ".xx.x.x.x.x.x"}, {"input": {"initial_string": ".xx.........x", "pattern_number": 174, "generations": 3}, "output": ".........xxxx"}, {"input": {"initial_string": "xx.xxx.x..", "pattern_number": 112, "generations": 10}, "output": "xx..xx.x.."}, {"input": {"initial_string": ".xx.x", "pattern_number": 66, "generations": 4}, "output": "....x"}, {"input": {"initial_string": "xxx...x.xxx.x", "pattern_number": 133, "generations": 8}, "output": ".x..x.x..x.x."}, {"input": {"initial_string": ".x..x....xxx", "pattern_number": 82, "generations": 7}, "output": "..x..x..xx.x"}, {"input": {"initial_string": "xxx..", "pattern_number": 231, "generations": 4}, "output": "xxx.x"}], "error_log": []}
{"context": "Given a string consisting of lowercase letters, what are all the unique permutations of the string in lexicographical order?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string for which permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of unique permutations of the input string, sorted in lexicographical order.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def my_Permutation(self, str):\n        if len(str) == 0:\n            return None\n        res = []\n        path = ''\n        self.helper(str, res, path)\n        return sorted(list(set(res)))\n    \n    def helper(self, str, res, path):\n        if len(str) == 0:\n            res.append(path)\n        for i in range(len(str)):\n            self.helper(str[:i] + str[i+1:], res, path + str[i])\n\n# main function\ndef main_solution(input_string):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    result = solution.my_Permutation(input_string)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 6)\n    chars = random.choices(string.ascii_letters, k=length)\n    input_string = ''.join(chars)\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "hsl"}, "output": ["hls", "hsl", "lhs", "lsh", "shl", "slh"]}, {"input": {"input_string": "axV"}, "output": ["Vax", "Vxa", "aVx", "axV", "xVa", "xaV"]}, {"input": {"input_string": "WuZ"}, "output": ["WZu", "WuZ", "ZWu", "ZuW", "uWZ", "uZW"]}, {"input": {"input_string": "hD"}, "output": ["Dh", "hD"]}, {"input": {"input_string": "k"}, "output": ["k"]}, {"input": {"input_string": "G"}, "output": ["G"]}, {"input": {"input_string": "y"}, "output": ["y"]}, {"input": {"input_string": "P"}, "output": ["P"]}, {"input": {"input_string": "UX"}, "output": ["UX", "XU"]}, {"input": {"input_string": "o"}, "output": ["o"]}], "error_log": []}
{"context": "Given a mathematical function that calculates the integral of \\( (x^n) \\cdot (e^x) \\) from 0 to 1, what are the results of this integral for values of \\( n \\) ranging from 0 to a given maximum \\( n \\)?\n\nThe input and output requirements are as follows:\n\nInput:\n  `max_n` (int): The maximum value of `n` for which the integral should be calculated. It should be a non-negative integer.\n\nOutput:\n  `return` (list of float): A list of results where each element corresponds to the result of the integral for `n` ranging from 0 to `max_n`. Each result is a float representing the value of the integral for the respective `n`.", "reference_code": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Ejercicio11:\n    def integral(self, n):\n        if n == 0:\n            return math.e - 1\n        return math.e - (n * self.integral(n - 1))\n\n# main function\ndef main_solution(max_n):\n    # max_n should be an integer\n    ejercicio = Ejercicio11()\n    results = []\n    for n in range(0, max_n + 1):\n        results.append(ejercicio.integral(n))\n    return results", "input_generator": "import random\n\ndef input_generator():\n    return {'max_n': random.randint(1, 10)}", "io_pairs": [{"input": {"max_n": 8}, "output": [1.718281828459045, 1.0, 0.7182818284590451, 0.5634363430819098, 0.4645364561314058, 0.395599547802016, 0.34468454164694906, 0.30549003693040166, 0.27436153301583177]}, {"input": {"max_n": 7}, "output": [1.718281828459045, 1.0, 0.7182818284590451, 0.5634363430819098, 0.4645364561314058, 0.395599547802016, 0.34468454164694906, 0.30549003693040166]}, {"input": {"max_n": 9}, "output": [1.718281828459045, 1.0, 0.7182818284590451, 0.5634363430819098, 0.4645364561314058, 0.395599547802016, 0.34468454164694906, 0.30549003693040166, 0.27436153301583177, 0.24902803131655915]}, {"input": {"max_n": 4}, "output": [1.718281828459045, 1.0, 0.7182818284590451, 0.5634363430819098, 0.4645364561314058]}, {"input": {"max_n": 3}, "output": [1.718281828459045, 1.0, 0.7182818284590451, 0.5634363430819098]}, {"input": {"max_n": 6}, "output": [1.718281828459045, 1.0, 0.7182818284590451, 0.5634363430819098, 0.4645364561314058, 0.395599547802016, 0.34468454164694906]}, {"input": {"max_n": 10}, "output": [1.718281828459045, 1.0, 0.7182818284590451, 0.5634363430819098, 0.4645364561314058, 0.395599547802016, 0.34468454164694906, 0.30549003693040166, 0.27436153301583177, 0.24902803131655915, 0.22800151529345358]}, {"input": {"max_n": 2}, "output": [1.718281828459045, 1.0, 0.7182818284590451]}, {"input": {"max_n": 1}, "output": [1.718281828459045, 1.0]}, {"input": {"max_n": 5}, "output": [1.718281828459045, 1.0, 0.7182818284590451, 0.5634363430819098, 0.4645364561314058, 0.395599547802016]}], "error_log": []}
{"context": "Given a string consisting of uppercase letters, what are all the possible unique arrangements of the characters in the string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `input_string` (str): A string for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string.", "reference_code": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all permutations of the list of characters\n    permutations = list(itertools.permutations(char_list))\n    \n    # Convert each permutation tuple back to a string\n    result = [''.join(perm) for perm in permutations]\n    \n    # Return the list of permutations\n    return result", "input_generator": "import random\nimport string\n\ndef input_generator():\n    length = random.randint(1, 5)\n    input_string = ''.join(random.choice(string.ascii_letters) for _ in range(length))\n    return {'input_string': input_string}", "io_pairs": [{"input": {"input_string": "nza"}, "output": ["nza", "naz", "zna", "zan", "anz", "azn"]}, {"input": {"input_string": "oqR"}, "output": ["oqR", "oRq", "qoR", "qRo", "Roq", "Rqo"]}, {"input": {"input_string": "dEs"}, "output": ["dEs", "dsE", "Eds", "Esd", "sdE", "sEd"]}, {"input": {"input_string": "n"}, "output": ["n"]}, {"input": {"input_string": "CaM"}, "output": ["CaM", "CMa", "aCM", "aMC", "MCa", "MaC"]}, {"input": {"input_string": "U"}, "output": ["U"]}, {"input": {"input_string": "q"}, "output": ["q"]}, {"input": {"input_string": "u"}, "output": ["u"]}, {"input": {"input_string": "th"}, "output": ["th", "ht"]}, {"input": {"input_string": "P"}, "output": ["P"]}], "error_log": []}
{"context": "Given the coordinates of two locations on Earth, what is the distance between them in miles?\n\nThe input and output requirements are as follows:\n\nInput:\n  `p1` (list of float): A list containing the latitude and longitude of the first point in degrees.\n  `p2` (list of float): A list containing the latitude and longitude of the second point in degrees.\n\nOutput:\n  `return` (float): The distance between the two points in miles.", "reference_code": "# import necessary packages\nfrom math import sin, cos, sqrt, atan2, radians\n\n# main function\ndef main_solution(p1, p2):\n    # Convert input coordinates to radians\n    lat1 = radians(p1[0])\n    lon1 = radians(p1[1])\n    lat2 = radians(p2[0])\n    lon2 = radians(p2[1])\n    \n    # Calculate the distance using the Haversine formula\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    \n    # Convert distance from km to miles\n    R = 6373.0  # approximate radius of earth in km\n    toMiles = 0.621371\n    distance_miles = R * c * toMiles\n    \n    # Return the distance in miles\n    return distance_miles", "input_generator": "import random\nimport math\n\ndef input_generator():\n    # Generate random latitude and longitude within valid ranges\n    lat1 = random.uniform(-90, 90)\n    lon1 = random.uniform(-180, 180)\n    lat2 = random.uniform(-90, 90)\n    lon2 = random.uniform(-180, 180)\n    \n    return {\n        'p1': (lat1, lon1),\n        'p2': (lat2, lon2)\n    }", "io_pairs": [{"input": {"p1": [-21.823505553474746, 29.764099006772312], "p2": [-58.21013432645671, -97.862082367858]}, "output": 6151.394493296428}, {"input": {"p1": [-23.59315670754576, 144.7374700584179], "p2": [52.16172762562047, -33.321622108147636]}, "output": 10463.513052799151}, {"input": {"p1": [54.92501791376037, -142.1838416597662], "p2": [-10.195222765709161, 155.29041059166303]}, "output": 5759.679491477678}, {"input": {"p1": [-64.00263574401976, 6.407935436554396], "p2": [-47.73364371615406, 83.89675339464742]}, "output": 2985.522670506173}, {"input": {"p1": [78.36647933928259, -41.276781051565166], "p2": [-52.29934777283658, -0.11618883078608633]}, "output": 9192.961815297404}, {"input": {"p1": [-74.754883024252, 129.03402062294253], "p2": [62.62497490287106, 40.295421725678295]}, "output": 10274.702008321849}, {"input": {"p1": [-11.452255363848693, -121.22767960067827], "p2": [-63.34413548272719, -61.20300636575399]}, "output": 4603.118221722251}, {"input": {"p1": [-45.54475736479129, -170.78207221768662], "p2": [73.01572475146295, -52.78278252891437]}, "output": 9755.054064980848}, {"input": {"p1": [25.32224274080174, -150.79067488884897], "p2": [32.09750756763103, 116.17262057148002]}, "output": 5476.645660528388}, {"input": {"p1": [84.71672306066051, 3.1421414622191435], "p2": [44.67796153081616, 92.8171720466828]}, "output": 3146.9733888377536}], "error_log": []}
{"context": "In a busy public transportation area, people are trying to find seats based on certain rules. Initially, some seats are occupied ('#'), some are empty ('L'), and some are floor ('.') where no one can sit. People follow specific rules to occupy or vacate seats based on the number of occupied seats visible from their current position. After several rounds of people moving, the seating arrangement stabilizes. How many seats end up being occupied when the arrangement no longer changes?\n\nThe input and output requirements are as follows:\n\nInput:\n  `initial_layout` (list of strings): A list where each string represents a row of seats in a seating arrangement. Each character in the string can be either 'L' (empty seat), '#' (occupied seat), or '.' (floor).\n\nOutput:\n  `return` (int): The total number of occupied seats ('#') after the seating arrangement has stabilized.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef count_occupied_adjacent_seats(row, col, data):\n    occupied_seats = 0\n    max_col = len(data[0])-1\n    max_row = len(data) - 1\n    min_row = 0\n    min_col = 0\n    adjacent_coords = [(row-1, col-1), \n                       (row-1, col),\n                       (row, col-1),\n                       (row+1, col+1),\n                       (row+1, col),\n                       (row, col+1),\n                       (row-1, col+1),\n                       (row+1, col-1)]\n    valid_coords = []\n    for coord_row, coord_col in adjacent_coords:\n        if coord_row < min_row or coord_col < min_col or coord_col > max_col or coord_row > max_row:\n            continue\n        valid_coords.append((coord_row, coord_col))\n    for coord_row, coord_col in valid_coords:\n        if '#' == data[coord_row][coord_col]:\n            occupied_seats += 1\n    return occupied_seats\n\ndef count_seats_in_sight(row, col, data):\n    occupied_seats = 0\n    max_col = len(data[0])\n    max_row = len(data)\n    line_of_sight = {}\n    try:\n        line_of_sight['right'] = data[row][col+1:]\n    except IndexError:\n        line_of_sight['right'] = ''\n    line_of_sight['left'] = data[row][:col][::-1]\n    try:\n        line_of_sight['down'] = ''.join([tmp[col] for tmp in data])[row+1:]\n    except IndexError:\n        line_of_sight['down'] = ''\n    line_of_sight['up'] = ''.join([tmp[col] for tmp in data])[:row][::-1]\n    line_of_sight['up-right'] = ''\n    line_of_sight['up-left'] = ''\n    line_of_sight['down-right'] = ''\n    line_of_sight['down-left'] = ''\n    for index in range(1, max(max_row, max_col)):\n        if (row - index >= 0) and (col - index >= 0):\n            line_of_sight['up-left'] += data[row - index][col - index]\n        if (row + index < max_row) and (col + index < max_col):\n            line_of_sight['down-right'] += data[row + index][col + index]\n        if (row - index >= 0) and (col + index < max_col):\n            line_of_sight['up-right'] += data[row - index][col + index]\n        if (row + index < max_row) and (col - index >= 0):\n            line_of_sight['down-left'] += data[row + index][col - index]\n    for _, val in line_of_sight.items():\n        val = val.replace('.', '')\n        if val and val[0] == '#':\n            occupied_seats += 1\n    return occupied_seats\n\ndef file_people_in(data):\n    people_moved = False\n    shuffle_move = []\n    max_col = len(data[0])\n    max_row = len(data)\n    for cur_row in range(0, max_row):\n        cur_row_lst = []\n        for cur_col in range(0, max_col):\n            if 'L' == data[cur_row][cur_col]:\n                if 0 == count_seats_in_sight(cur_row, cur_col, data):\n                    people_moved = True\n                    cur_row_lst.append('#')\n                else:\n                    cur_row_lst.append('L')\n            elif '#' == data[cur_row][cur_col]:\n                if 5 <= count_seats_in_sight(cur_row, cur_col, data):\n                    people_moved = True\n                    cur_row_lst.append('L')\n                else:\n                    cur_row_lst.append('#')\n            else:\n                cur_row_lst.append(data[cur_row][cur_col])\n        shuffle_move.append(''.join(cur_row_lst))\n        cur_row = []\n    return people_moved, shuffle_move\n\n# main function\ndef main_solution(initial_layout):\n    data = initial_layout\n    people_still_moving = True\n    while people_still_moving:\n        people_still_moving, data = file_people_in(data)\n    occupied_seats = sum([row.count('#') for row in data])\n    return occupied_seats", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(5, 15)\n    cols = random.randint(5, 15)\n    initial_layout = []\n    for _ in range(rows):\n        row = []\n        for _ in range(cols):\n            choice = random.choices(['L', '.', '#'], weights=[0.4, 0.4, 0.2], k=1)[0]\n            row.append(choice)\n        initial_layout.append(''.join(row))\n    return {'initial_layout': initial_layout}", "io_pairs": [{"input": {"initial_layout": [".##.L.LL..#L", ".#L#LLL.#L.#", ".#L.#LL#L#.L", ".#..L..L.#LL", "L.LLL.L.LLL#"]}, "output": 16}, {"input": {"initial_layout": ["L....LLL..#", "...L.#..#.L", "L#..##L.L.L", "LL...L#.###", "#.#LLLL.L.L", ".LLLL.L#.##"]}, "output": 17}, {"input": {"initial_layout": ["LLLL.L#", ".LLLL..", ".LL.#L.", ".L#....", ".LLL.#.", "..#.#.L", "L.#..LL", ".#L#L#.", ".LLL.#.", ".L.L..L"]}, "output": 17}, {"input": {"initial_layout": ["LLL#L.", "#..L..", "..LLLL", "L...#L", "L#..LL"]}, "output": 5}, {"input": {"initial_layout": ["L.###.....LL.", "L...#..LLLL.#", "LL#LL#LLLLLL.", "...####LLL...", "....L.LL#..LL"]}, "output": 17}, {"input": {"initial_layout": [".L##L#.L#", "#L#.L.LLL", "#LL#.LL..", "#L#.L.L.#", "#.L.L#.LL", ".##L.....", "L.###.LLL", "#L..##L.#"]}, "output": 21}, {"input": {"initial_layout": ["LLL.#....#...L", "#L.LL.LL....#.", "LLLL.##..L.#L.", "LL##..LL.LLLLL", "#.LLLL#L.LL#.L", "..L.#L#..LLL.L", "..LL..L...#L.L", ".#.##...L...LL"]}, "output": 24}, {"input": {"initial_layout": ["LL#LL.L", ".L.L#..", "LLL..LL", "..L..LL", "L.L#LL.", "LL.L.L#", ".LLLL#L", "#.LLL..", "L.#L..L"]}, "output": 18}, {"input": {"initial_layout": ["..#LL", "LL.LL", ".L.##", "..#L#", "..LLL", "L...L", "L#L#.", "LL#L#"]}, "output": 11}, {"input": {"initial_layout": ["L.L.#", "L.LL#", "#LLLL", "L.L..", "..LLL", "L.#LL", "..L#.", "LL#.."]}, "output": 11}], "error_log": []}
{"context": "Given a sequence of integers, determine if it represents the post-order traversal of a Binary Search Tree (BST). What is the result of the verification?\n\nThe input and output requirements are as follows:\n\nInput:\n  `sequence` (list of integers): A list of integers representing the sequence to be verified as the post-order traversal of a Binary Search Tree (BST).\n\nOutput:\n  `return` (string): A string indicating whether the input sequence is a valid post-order traversal of a BST. The possible values are \"Yes\" or \"No\".", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, sequence):\n        if not sequence:\n            return False\n        if len(sequence) == 1:\n            return True\n        root_val = sequence[-1]\n        i = 0\n        while (sequence[i] < root_val):\n            i += 1\n        j = i\n        while (j < len(sequence) - 1):\n            if sequence[j] < root_val:\n                return False\n            j += 1\n        left = True\n        right = True\n        if (len(sequence[0:i]) > 0):\n            left = self.VerifySquenceOfBST(sequence[0:i])\n        if (len(sequence[i:j]) > 0):\n            right = self.VerifySquenceOfBST(sequence[i:j])\n        return left and right\n\n# main function\ndef main_solution(sequence):\n    # Convert input to the required format\n    sequence = list(sequence)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the VerifySquenceOfBST method\n    result = solution.VerifySquenceOfBST(sequence)\n    \n    # Convert the result to a JSON serializable output\n    return \"Yes\" if result else \"No\"", "input_generator": "import random\n\ndef input_generator():\n    def generate_sequence(length):\n        if length == 0:\n            return []\n        root = random.randint(1, 100)\n        left_length = random.randint(0, length - 1)\n        right_length = length - 1 - left_length\n        left = []\n        if left_length > 0:\n            left = [random.randint(1, root - 1) for _ in range(left_length)]\n            left = generate_sequence(left_length)\n        right = []\n        if right_length > 0:\n            right = [random.randint(root + 1, 200) for _ in range(right_length)]\n            right = generate_sequence(right_length)\n        return left + right + [root]\n    \n    def generate_invalid_sequence(length):\n        sequence = [random.randint(1, 100) for _ in range(length)]\n        if random.random() < 0.5:\n            sequence[-1] = random.randint(1, 100)  # Ensure it's not necessarily a valid BST\n        return sequence\n    \n    if random.random() < 0.5:\n        sequence = generate_sequence(random.randint(0, 10))\n    else:\n        sequence = generate_invalid_sequence(random.randint(0, 10))\n    \n    return {'sequence': sequence}", "io_pairs": [{"input": {"sequence": [65, 71, 62]}, "output": "Yes"}, {"input": {"sequence": [33]}, "output": "Yes"}, {"input": {"sequence": [88, 60, 25]}, "output": "Yes"}, {"input": {"sequence": [45, 34, 61, 13, 65, 1]}, "output": "Yes"}, {"input": {"sequence": [52, 87, 47, 82, 40, 19, 87, 14, 42, 61]}, "output": "No"}, {"input": {"sequence": [56, 87, 74, 54, 69, 76, 12, 68, 69]}, "output": "No"}, {"input": {"sequence": [75, 71, 66, 89, 5]}, "output": "Yes"}, {"input": {"sequence": [97, 12, 2, 73, 16]}, "output": "No"}, {"input": {"sequence": [84, 47, 76, 15]}, "output": "No"}, {"input": {"sequence": [19, 11]}, "output": "Yes"}], "error_log": []}
{"context": "Given a harmonic series, we want to compare the sum of the series when calculated from the smallest to the largest term (ascending order) and from the largest to the smallest term (descending order). How does the relative error between these two sums change as we increase the number of terms in the series?\n\nThe input and output requirements are as follows:\n\nInput:\n  `N` (int): The number of terms in the harmonic series to be summed.\n\nOutput:\n  `return` (list of float): A list of relative errors calculated for each term from 1 to N-1. Each element in the list represents the relative error between the two sums at that term.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(N):\n    # Convert input to integer if it's not already\n    N = int(N)\n    \n    # Initialize variables\n    sum1 = 0.0\n    sum2 = 0.0\n    array1 = np.zeros(N + 1)\n    array2 = np.zeros(N + 1)\n    \n    # Calculate the first sum (1/1 + 1/2 + ... + 1/N)\n    for i in range(1, N + 1):\n        sum1 += 1 / i\n        array1[i] = sum1\n    \n    # Calculate the second sum (1/N + 1/(N-1) + ... + 1/1)\n    for w in range(N, 0, -1):\n        sum2 += 1 / w\n        array2[N - w] = sum2\n    \n    # Calculate the difference and relative error\n    arraysum = np.zeros(N + 1)\n    for q in range(1, N):\n        arraysum[q] = ((array1[q]) - (array2[q])) / abs((array1[q]) + abs(array2[q]))\n    \n    # Return the relative error array as a list\n    return arraysum[1:N].tolist()", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    N = random.randint(1, 1000)\n    return {'N': N}", "io_pairs": [{"input": {"N": 3}, "output": [0.09090909090909095, -0.09999999999999999]}, {"input": {"N": 1}, "output": []}, {"input": {"N": 18}, "output": [0.7947214076246334, 0.7890377588306943, 0.7654694937256599, 0.73733618185092, 0.7070178694460226, 0.6750815394450806, 0.6415698842848618, 0.6062999874365506, 0.5689386060371766, 0.5290006179457083, 0.4857998396431761, 0.4383412104322677, 0.3851032768340293, 0.323565747390941, 0.24901881759926667, 0.1507225105576071, -0.008011286889635138]}, {"input": {"N": 10}, "output": [0.6513761467889908, 0.6338880484114976, 0.5857216406384074, 0.5268285589646649, 0.4594800253646163, 0.3819809736989367, 0.2893931919092254, 0.1697694278394534, -0.0173673328738801]}, {"input": {"N": 4}, "output": [0.26315789473684215, 0.1612903225806452, -0.0638297872340425]}, {"input": {"N": 7}, "output": [0.5272727272727272, 0.49289099526066354, 0.4141414141414142, 0.3118440779610195, 0.17813267813267816, -0.028328611898016984]}, {"input": {"N": 14}, "output": [0.7416267942583732, 0.7324167107350608, 0.7007375371664673, 0.6627244096580867, 0.6210877625725509, 0.5762189433993928, 0.5277175765790587, 0.4746574238999998, 0.41547593426962787, 0.3475202929228192, 0.2658139064204774, 0.15904471597381076, -0.011105713099822804]}, {"input": {"N": 2}, "output": [-0.2]}, {"input": {"N": 16}, "output": [0.7712177121771218, 0.7640882044102205, 0.7370555953233119, 0.7047264007793035, 0.669656160065989, 0.6323752709240748, 0.5927966659691647, 0.5505232424448351, 0.5048915207612387, 0.45489494572658223, 0.3989744644541538, 0.33454025243265906, 0.25675558230168083, 0.15461439827753778, -0.009329809222022815]}, {"input": {"N": 15}, "output": [0.7573221757322176, 0.7492524562152925, 0.7200790445914597, 0.6851397942142973, 0.6470736599368252, 0.6063615324153591, 0.5627957854313209, 0.5157790637028141, 0.46432085447815324, 0.4068510953088658, 0.3407456232212599, 0.2610987375175502, 0.15675662035237897, -0.010147455744269144]}], "error_log": []}
{"context": "Given a Lights Out puzzle with a certain number of rows and columns, and a sequence of moves performed on the puzzle, determine if the puzzle is solved after all the moves are applied. The puzzle is considered solved if all the lights are turned off. What is the status of the puzzle after the moves are performed?\n\nThe input and output requirements are as follows:\n\nInput:\n  `rows` (int): The number of rows in the Lights Out puzzle.\n  `cols` (int): The number of columns in the Lights Out puzzle.\n  `moves` (list of lists): A list of moves, where each move is a list containing two integers representing the row and column of the move.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"is_solved\"` whose value is a boolean indicating whether the puzzle is solved after performing the moves.", "reference_code": "# import necessary packages\nimport math\nimport random\n\n# all class and function definitions in the code file, if any\nclass LightsOutPuzzle(object):\n    def __init__(self, board):\n        self.__board = board\n        self.__row = len(board)\n        self.__col = len(board[0])\n\n    def get_board(self):\n        return self.__board\n\n    def perform_move(self, row, col):\n        self.__board[row][col] = not self.__board[row][col]\n        if row:\n            self.__board[row - 1][col] = not self.__board[row - 1][col]\n        if self.__row - 1 - row:\n            self.__board[row + 1][col] = not self.__board[row + 1][col]\n        if col:\n            self.__board[row][col - 1] = not self.__board[row][col - 1]\n        if self.__col - 1 - col:\n            self.__board[row][col + 1] = not self.__board[row][col + 1]\n\n    def scramble(self):\n        for i in range(self.__row):\n            for j in range(self.__col):\n                if random.random() < 0.5:\n                    self.perform_move(i, j)\n\n    def is_solved(self):\n        return not any([any(i) for i in self.__board])\n\n    def copy(self):\n        return LightsOutPuzzle([i[:] for i in self.__board])\n\n    def successors(self):\n        for i in range(self.__row):\n            for j in range(self.__col):\n                temp = self.copy()\n                temp.perform_move(i, j)\n                yield (i, j), temp\n\n    def find_solution(self):\n        if self.is_solved():\n            return\n        temp = self.copy()\n        queue = [temp]\n        visited = []\n        path = {temp: tuple()}\n        while queue:\n            node = queue.pop(0)\n            if node.is_solved():\n                return list(path[node])\n            if node.get_board() in visited:\n                continue\n            visited.append(node.get_board())\n            for move, new_n in node.successors():\n                queue.append(new_n)\n                path[new_n] = tuple([move]) if not path[node] else tuple([*path[node], move])\n        return None\n\ndef create_puzzle(rows, cols):\n    puzzle = [[False] * cols] * rows\n    return LightsOutPuzzle(puzzle)\n\n# main function\ndef main_solution(rows, cols, moves):\n    # Convert moves from list of tuples to list of lists\n    moves = [list(move) for move in moves]\n    \n    # Create the puzzle\n    puzzle = create_puzzle(rows, cols)\n    \n    # Perform the moves\n    for move in moves:\n        puzzle.perform_move(move[0], move[1])\n    \n    # Check if the puzzle is solved\n    is_solved = puzzle.is_solved()\n    \n    # Return the result\n    return {\"is_solved\": is_solved}", "input_generator": "import random\n\ndef input_generator():\n    rows = random.randint(1, 5)\n    cols = random.randint(1, 5)\n    num_moves = random.randint(0, 10)\n    moves = [(random.randint(0, rows-1), random.randint(0, cols-1)) for _ in range(num_moves)]\n    return {\"rows\": rows, \"cols\": cols, \"moves\": moves}", "io_pairs": [{"input": {"rows": 4, "cols": 1, "moves": [[3, 0], [0, 0], [2, 0], [2, 0], [0, 0]]}, "output": {"is_solved": true}}, {"input": {"rows": 4, "cols": 4, "moves": [[1, 0], [0, 1], [3, 0], [0, 0]]}, "output": {"is_solved": false}}, {"input": {"rows": 3, "cols": 4, "moves": [[2, 1], [2, 2], [0, 2], [1, 2]]}, "output": {"is_solved": false}}, {"input": {"rows": 5, "cols": 2, "moves": [[0, 1], [4, 1]]}, "output": {"is_solved": true}}, {"input": {"rows": 4, "cols": 3, "moves": [[1, 0], [0, 2], [0, 1]]}, "output": {"is_solved": false}}, {"input": {"rows": 4, "cols": 4, "moves": []}, "output": {"is_solved": true}}, {"input": {"rows": 4, "cols": 1, "moves": [[2, 0], [0, 0], [2, 0]]}, "output": {"is_solved": true}}, {"input": {"rows": 3, "cols": 1, "moves": []}, "output": {"is_solved": true}}, {"input": {"rows": 2, "cols": 5, "moves": [[1, 0], [1, 1], [0, 1], [0, 4], [0, 4]]}, "output": {"is_solved": false}}, {"input": {"rows": 4, "cols": 2, "moves": [[0, 0], [0, 0], [0, 1], [2, 1], [3, 1], [0, 0]]}, "output": {"is_solved": false}}], "error_log": []}
{"context": "In a population consisting of three types of individuals (K, M, and N), we are interested in the probability of a successful combination event. Given the counts of each type of individual (K, M, and N), what is the probability of a successful combination event, considering specific combination rules?\n\nThe input and output requirements are as follows:\n\nInput:\n  `k` (int): The number of individuals of type K.\n  `m` (int): The number of individuals of type M.\n  `n` (int): The number of individuals of type N.\n\nOutput:\n  `return` (float): The probability of a successful combination, rounded to 5 decimal places.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef factorial(start, stop):\n    res = 1\n    while start >= stop:\n        res *= start\n        start -= 1\n    return res\n\ndef combine(m, n):\n    return (factorial(n, n - m + 1) + 0.0) / factorial(m, 1)\n\n# main function\ndef main_solution(k, m, n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = (combine(2, k) / combine(2, k + m + n) +\n              combine(1, k) * combine(1, m) / combine(2, k + n + m) +\n              combine(1, k) * combine(1, n) / combine(2, k + m + n) +\n              combine(1, m) * combine(1, n) / combine(2, k + m + n) * 0.5 +\n              combine(2, m) / combine(2, k + m + n) * 3 / 4)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return round(result, 5)", "input_generator": "import random\n\ndef input_generator():\n    k = random.randint(1, 20)\n    m = random.randint(1, 20)\n    n = random.randint(1, 20)\n    return {'k': k, 'm': m, 'n': n}", "io_pairs": [{"input": {"k": 7, "m": 15, "n": 9}, "output": 0.72097}, {"input": {"k": 9, "m": 4, "n": 12}, "output": 0.695}, {"input": {"k": 5, "m": 13, "n": 4}, "output": 0.77706}, {"input": {"k": 11, "m": 4, "n": 1}, "output": 0.97083}, {"input": {"k": 19, "m": 5, "n": 5}, "output": 0.93842}, {"input": {"k": 7, "m": 4, "n": 18}, "output": 0.53079}, {"input": {"k": 19, "m": 10, "n": 8}, "output": 0.88101}, {"input": {"k": 19, "m": 2, "n": 17}, "output": 0.78201}, {"input": {"k": 3, "m": 6, "n": 6}, "output": 0.65}, {"input": {"k": 1, "m": 7, "n": 13}, "output": 0.3869}], "error_log": []}
{"context": "Given a scenario where you need to estimate the value of Pi using a MonteCarlo integration technique, how would you approximate Pi based on a specified number of random iterations?\n\nThe input and output requirements are as follows:\n\nInput:\n  `attempts` (int): The number of iterations for the MonteCarlo method. Must be a positive integer.\n\nOutput:\n  `return` (float): The approximated value of Pi calculated using the MonteCarlo method.", "reference_code": "# import necessary packages\nimport random\nimport math\n\n# main function\ndef main_solution(attempts):\n    \"\"\"\n    This function calculates an approximation of Pi using a raw MonteCarlo\n    integration technique.\n    \n    :param attempts: the number of iterations for the MonteCarlo method\n    :type attempts: int\n    :return: the approximated value of Pi\n    :rtype: float\n    \"\"\"\n    assert isinstance(attempts, int), 'you must provide an integer'\n    assert attempts > 0, 'you must provide a positive integer'\n    falling_inside = 0\n    for _ in range(attempts):\n        x = random.uniform(0.0, 1.0)\n        y = random.uniform(0.0, 1.0)\n        if math.sqrt(x**2 + y**2) <= 1:\n            falling_inside += 1\n    pi = 4 * falling_inside / attempts\n    return pi", "input_generator": "import random\n\ndef input_generator():\n    return {\n        'attempts': random.randint(100, 100000)\n    }", "io_pairs": [{"input": {"attempts": 75886}, "output": 3.1407637772448145}, {"input": {"attempts": 93112}, "output": 3.1372970186442135}, {"input": {"attempts": 70076}, "output": 3.145727495861636}, {"input": {"attempts": 78862}, "output": 3.1491973320483884}, {"input": {"attempts": 67817}, "output": 3.1434006222628543}, {"input": {"attempts": 82395}, "output": 3.137035014260574}, {"input": {"attempts": 1545}, "output": 3.1067961165048543}, {"input": {"attempts": 56836}, "output": 3.134210711520867}, {"input": {"attempts": 50421}, "output": 3.134249618214633}, {"input": {"attempts": 52129}, "output": 3.1469623434172918}], "error_log": []}
{"context": "Given a tree structure represented by a string, where each node is enclosed in brackets and contains a category label followed by terminal or other nodes, how can the tree be formatted to clearly display its hierarchical structure? Specifically, what is the prettified version of the given tree string?\n\nThe input and output requirements are as follows:\n\nInput:\n  `tree_string` (str): A string representing a tree structure in the format `[CAT TERMINAL]` or `[CAT [CAT TERMINAL] [CAT TERMINAL]]`. The string should be properly formatted with brackets and spaces.\n\nOutput:\n  `return` (str): A prettified string representation of the input tree structure, with indentation to show the hierarchy of the tree.", "reference_code": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\nclass Subtree:\n\n    left_bracket = r\"[\"\n    right_bracket = r\"]\"\n    \n    def __init__(self, s):\n        self.s = self.__basic_cleanup(s)\n        self.cat = \"\"\n        self.daughters = []\n        self.__parse()\n\n    def __parse(self):\n        if self.is_atomic():\n            cat, terminal = self.__remove_outer_brackets(self.s).split(\" \")\n            self.cat = cat\n            self.daughters = [terminal]\n        else:\n            bracket_count = 0\n            start = 1\n            for i in range(len(self.s)):\n                char = self.s[i]\n                if char == Subtree.left_bracket:\n                    bracket_count += 1\n                elif char == Subtree.right_bracket:\n                    bracket_count -= 1\n                if bracket_count == 1 and char == Subtree.right_bracket:\n                    self.daughters.append(Subtree(self.s[start:i+1]))\n                    start = i+1\n\n    def is_atomic(self):\n        atomic_re = re.compile(r\"^\\%s[^\\%s]+\\%s$\" % (Subtree.left_bracket, Subtree.right_bracket, Subtree.right_bracket))\n        return bool(atomic_re.search(self.s))\n\n    def __basic_cleanup(self, s):\n        newline_re = re.compile(r\"\\s*\\n+\", re.M)\n        s = newline_re.sub(\" \", s)\n        s = re.sub(r\"\\s{2,}\", \" \", s)\n        s = re.sub(r\"\\s*([\\%s\\%s])\\s*\" % (Subtree.left_bracket, Subtree.right_bracket), r\"\\1\", s)\n        nonterminal_re = re.compile(r\"\\%s\\s*[\\(A-Z/\\)]+\\s*\\%s\" % (Subtree.left_bracket, Subtree.left_bracket))\n        s = nonterminal_re.sub(\"%s%s\" % (Subtree.left_bracket, Subtree.left_bracket), s)\n        return s\n            \n    def __remove_outer_brackets(self, s):\n        outer_bracket_re = re.compile(r\"(^\\%s|\\%s$)\" % (Subtree.left_bracket, Subtree.right_bracket))\n        return outer_bracket_re.sub(r\"\", s)\n \n    def prettify(self, depth=0):\n        tab = \"  \" * depth\n        s = \"\"\n        if self.is_atomic():\n            s += tab + Subtree.left_bracket + self.cat + \" \" + self.daughters[0] + Subtree.right_bracket\n        else:\n            s += tab + Subtree.left_bracket\n            for d in self.daughters:\n                s += \"\\n\" + d.prettify(depth+1)\n            s += Subtree.right_bracket\n        return s\n\n# main function\ndef main_solution(tree_string):\n    # Convert the input string to a Subtree object\n    tree = Subtree(tree_string)\n    \n    # Return the prettified version of the tree\n    return tree.prettify()", "input_generator": "import random\nimport string\n\ndef generate_atomic_subtree():\n    categories = ['NP', 'VP', 'PP', 'ADJP', 'ADVP']\n    terminals = ['the', 'dog', 'cat', 'runs', 'jumps', 'quickly', 'slowly', 'big', 'small']\n    category = random.choice(categories)\n    terminal = random.choice(terminals)\n    return f\"[{category} {terminal}]\"\n\ndef generate_complex_subtree(depth=0):\n    if depth >= 2 or random.random() < 0.3:\n        return generate_atomic_subtree()\n    else:\n        subtrees = []\n        num_subtrees = random.randint(2, 4)\n        for _ in range(num_subtrees):\n            subtrees.append(generate_complex_subtree(depth + 1))\n        return \"[\" + \"\".join(subtrees) + \"]\"\n\ndef input_generator():\n    tree_string = generate_complex_subtree()\n    return {'tree_string': tree_string}", "io_pairs": [{"input": {"tree_string": "[[PP runs][VP dog][[NP jumps][VP the][NP runs]]]"}, "output": "[\n  [PP runs]\n  [VP dog]\n  [\n    [NP jumps]\n    [VP the]\n    [NP runs]]]"}, {"input": {"tree_string": "[ADVP cat]"}, "output": "[ADVP cat]"}, {"input": {"tree_string": "[VP jumps]"}, "output": "[VP jumps]"}, {"input": {"tree_string": "[ADJP the]"}, "output": "[ADJP the]"}, {"input": {"tree_string": "[NP small]"}, "output": "[NP small]"}, {"input": {"tree_string": "[ADJP small]"}, "output": "[ADJP small]"}, {"input": {"tree_string": "[[[VP jumps][ADVP dog][PP dog]][VP runs]]"}, "output": "[\n  [\n    [VP jumps]\n    [ADVP dog]\n    [PP dog]]\n  [VP runs]]"}, {"input": {"tree_string": "[VP dog]"}, "output": "[VP dog]"}, {"input": {"tree_string": "[[NP jumps][[VP cat][PP the]][ADVP jumps]]"}, "output": "[\n  [NP jumps]\n  [\n    [VP cat]\n    [PP the]]\n  [ADVP jumps]]"}, {"input": {"tree_string": "[[NP slowly][[VP dog][VP the]]]"}, "output": "[\n  [NP slowly]\n  [\n    [VP dog]\n    [VP the]]]"}], "error_log": []}
{"context": "Given the infinite continued fraction representation of the square root of two, we can generate successive approximations by expanding the fraction. For a given number of expansions, how many of these approximations have a numerator with more digits than the denominator?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of expansions to consider.\n\nOutput:\n  `return` (int): The count of fractions where the numerator has more digits than the denominator.", "reference_code": "# import necessary packages\nfrom fractions import Fraction\n\n# all class and function definitions in the code file, if any\ndef nth_term_of_sqrt_2(n):\n    f = Fraction(1/2)\n    two = Fraction(2)\n    for i in range(1, n):\n        f = Fraction(1, two + f)\n    return Fraction(1) + f\n\ndef gen_sqrt_2_terms(n):\n    f = Fraction(1/2)\n    one = Fraction(1)\n    two = Fraction(2)\n    yield one + f\n    for i in range(n):\n        f = Fraction(1, two + f)\n        yield one + f\n\ndef _digit_count(n):\n    return len(str(n))\n\ndef _dcn_gt_dcd(f):\n    return _digit_count(f.numerator) > _digit_count(f.denominator)\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    terms = list(gen_sqrt_2_terms(n))\n    count = len(list(filter(_dcn_gt_dcd, terms)))\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count", "input_generator": "import random\nfrom fractions import Fraction\n\ndef input_generator():\n    n = random.randint(1, 100)\n    return {'n': n}", "io_pairs": [{"input": {"n": 27}, "output": 4}, {"input": {"n": 25}, "output": 4}, {"input": {"n": 66}, "output": 9}, {"input": {"n": 22}, "output": 3}, {"input": {"n": 20}, "output": 3}, {"input": {"n": 67}, "output": 10}, {"input": {"n": 8}, "output": 1}, {"input": {"n": 95}, "output": 15}, {"input": {"n": 78}, "output": 11}, {"input": {"n": 60}, "output": 9}], "error_log": []}
{"context": "Sofia and her friends found a treasure chest filled with slips of paper, each containing a six-digit number. They believe these numbers could be lucky tickets, which could potentially win them a reward. A ticket is considered mathematically lucky if no combination of its digits, using basic arithmetic operations (addition, subtraction, multiplication, and division), can evaluate to exactly 100. Given a six-digit number from one of these slips, can you determine if it is mathematically lucky or not?\n\nThe input and output requirements are as follows:\n\nInput:\n  `ticket_number` (str): A string representing a 6-digit number.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the ticket number is mathematically lucky (True) or not (False).", "reference_code": "# import necessary packages\nfrom operator import add, mul, sub, truediv as div\nfrom typing import Generator\n\n# all class and function definitions in the code file, if any\nOPERATIONS = (add, mul, sub, div)\n\ndef num_generator(data: str) -> Generator[int, None, None]:\n    yield int(data)\n    for pos in range(1, len(data)):\n        for head, tail in (\n            (h, t) for h in num_generator(data[:pos])\n            for t in num_generator(data[pos:])\n        ):\n            for op in (op for op in OPERATIONS if tail):\n                yield op(head, tail)\n\n# main function\ndef main_solution(ticket_number: str) -> bool:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    return 100 not in num_generator(ticket_number)", "input_generator": "import random\n\ndef input_generator():\n    # Generate a random 6-digit ticket number as a string\n    ticket_number = ''.join([str(random.randint(0, 9)) for _ in range(6)])\n    return {'ticket_number': ticket_number}", "io_pairs": [{"input": {"ticket_number": "653477"}, "output": false}, {"input": {"ticket_number": "641912"}, "output": false}, {"input": {"ticket_number": "242703"}, "output": false}, {"input": {"ticket_number": "843703"}, "output": false}, {"input": {"ticket_number": "190451"}, "output": false}, {"input": {"ticket_number": "704235"}, "output": false}, {"input": {"ticket_number": "645211"}, "output": false}, {"input": {"ticket_number": "722526"}, "output": false}, {"input": {"ticket_number": "774759"}, "output": false}, {"input": {"ticket_number": "061743"}, "output": true}], "error_log": []}
{"context": "Given a certain number of nodes, how many unique binary search trees can be constructed using these nodes?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The number of nodes in the binary search tree.\n\nOutput:\n  `return` (int): The total number of binary search trees possible with `n` nodes.", "reference_code": "# import necessary packages\nfrom math import factorial\n\n# main function\ndef main_solution(n):\n    # Calculate the number of binary search trees possible with n nodes\n    ans = factorial(2 * n) / (factorial(n) * (n + 1) * factorial(n))\n    return int(ans)", "input_generator": "import random\nfrom math import factorial\n\ndef input_generator():\n    n = random.randint(1, 10)\n    return {'n': n}", "io_pairs": [{"input": {"n": 6}, "output": 132}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 9}, "output": 4862}, {"input": {"n": 5}, "output": 42}, {"input": {"n": 4}, "output": 14}, {"input": {"n": 7}, "output": 429}, {"input": {"n": 3}, "output": 5}, {"input": {"n": 8}, "output": 1430}, {"input": {"n": 2}, "output": 2}, {"input": {"n": 10}, "output": 16796}], "error_log": []}
{"context": "Given a neural network with a specific architecture, activation function, and cost function, how does the network respond to a particular input pattern? Specifically, what is the output of the neural network when it processes the given input layer?\n\nThe input and output requirements are as follows:\n\nInput:\n  `layers_sizes` (list of integers): A list representing the number of nodes in each layer of the neural network. The first element is the input layer size, and the last element is the output layer size.\n  `activation` (string): The activation function to be used in the neural network. Possible values are 'sigmoid', 'tanh', or 'relu'.\n  `cost_function` (string): The cost function to be used in the neural network. Possible values are 'quadratic' or 'cross_entropy'.\n  `input_layer` (list of floats): A list representing the input values for the neural network.\n\nOutput:\n  `return` (list of floats): A list representing the output values from the neural network after forward propagation.", "reference_code": "# import necessary packages\nimport numpy as np\nimport random\nimport json\n\n# all class and function definitions in the code file, if any\nclass NN: \n    def __init__(self, layers_sizes, activation = 'sigmoid', cost_function = 'quadratic'):\n        self.layers_sizes = layers_sizes\n        self.initialize_weights()\n        self.function_activation = activation\n        self.cost_function = cost_function\n\n    def initialize_weights(self):\n        self.weights = [np.random.randn(self.layers_sizes[i], self.layers_sizes[i-1])/np.sqrt(self.layers_sizes[i-1]) for i in range(1, len(self.layers_sizes))]\n        self.biases = [np.random.randn(i, 1) for i in self.layers_sizes[1:]]\n\n    def forward_prop(self, input_layer):\n        output_layer = input_layer\n        for i, j in zip(self.weights, self.biases):\n            output_layer = self.activation_function(np.dot(i, output_layer)+j)\n        return output_layer\n\n    def activation_function(self, z):\n        if(self.function_activation == 'sigmoid'):\n            return 1.0 / (1.0+np.exp(-z))\n        elif(self.function_activation == 'tanh'):\n            return np.tanh(z)\n        elif(self.function_activation == 'relu'):\n            return np.maximum(0, z)\n\n    def activation_function_derivative(self, z):\n        if(self.function_activation == 'sigmoid'):\n            return self.activation_function(z)*(1-self.activation_function(z))\n        elif(self.function_activation == 'tanh'):\n            return 1-self.activation_function(z) ** 2\n        elif(self.function_activation == 'relu'):\n            return self.activation_function(z) / z\n\n    def train(self, training_data, epochs, batch_size, learning_rate, test_data = None, lambda_term = 0):\n        for i in range(epochs):\n            random.shuffle(training_data)\n            batches = [training_data[j:j+batch_size] for  j in range(0, len(training_data), batch_size)]\n            for k in batches:\n                self.update_batch(k, learning_rate, lambda_term, len(training_data))\n            if test_data:\n                print(\"Epoch {} : {} / {}\".format(i, self.evaluate(test_data), len(test_data)))\n            else:\n                print(\"Epoch \"+str(i))\n\n    def update_batch(self, batch, learning_rate, lambda_term, n):\n        gradient_weights = [np.zeros(weight.shape) for weight in self.weights]\n        gradient_biases = [np.zeros(bias.shape) for bias in self.biases]\n\n        for x, y in batch:\n            delta_gradient_weights, delta_gradient_biases = self.backprop(x, y)\n            gradient_weights = [i+j for i, j in zip(gradient_weights, delta_gradient_weights)]\n            gradient_biases = [i+j for i, j in zip(gradient_biases, delta_gradient_biases)]\n\n        self.weights = [(1-learning_rate*lambda_term/n)*w-(learning_rate/len(batch))*nw for w, nw in zip(self.weights, gradient_weights)]\n        self.biases = [b-(learning_rate/len(batch))*nb for b, nb in zip(self.biases, gradient_biases)]\n\n    def backprop(self, x, y):\n        gradient_weights = [np.zeros(weight.shape) for weight in self.weights]\n        gradient_biases = [np.zeros(bias.shape) for bias in self.biases]\n        \n        activation = x\n        activations = [x]\n        z_vectors = []\n        for i, j in zip(self.weights, self.biases):\n            z = np.dot(i, activation) + j\n            z_vectors.append(z)\n            activation = self.activation_function(z)\n            activations.append(activation)\n        \n        delta = self.error_delta_output(activations[-1], y, z_vectors[-1])\n        gradient_weights[-1] = np.dot(delta, activations[-2].transpose())\n        gradient_biases[-1] = delta\n\n        for i in range(2, len(self.layers_sizes)):\n            z = z_vectors[-i]\n            derivative = self.activation_function_derivative(z)\n            delta = np.dot(self.weights[-i+1].transpose(), delta) * derivative\n            gradient_weights[-i] = np.dot(delta, activations[-i-1].transpose())\n            gradient_biases[-i] = delta\n        \n        return (gradient_weights, gradient_biases)\n\n    def error_delta_output(self, output_layer, y, z_vector):\n        if(self.cost_function == 'quadratic'):\n            return self.delta_output(output_layer, y) * self.activation_function_derivative(z_vector)\n        elif(self.cost_function == 'cross_entropy'):\n            return self.delta_output(output_layer, y)\n\n    def delta_output(self, output_layer, y):\n        return (output_layer-y)\n    \n    def evaluate(self, test_data):\n        test_result = [(np.argmax(self.forward_prop(x)), y) for (x, y) in test_data]\n        return sum((x == y) for (x, y) in test_result)\n\n    def save(self, file_name):\n        data = {'layers_sizes': self.layers_sizes, 'weights': [i.tolist() for i in self.weights], 'biases': [i.tolist() for i in self.biases], 'cost_function': self.cost_function}\n        with open(file_name, 'w') as outfile:\n            json.dump(data, outfile) \n\n    def load(self, file_name):\n        with open(file_name, 'r') as json_file:\n            data = json.load(json_file)\n            self.cost_function = data['cost_function']\n            self.layers_sizes = data['layers_sizes']\n            self.weights = [np.array(i) for i in data['weights']]\n            self.biases = [np.array(i) for i in data['biases']]\n\n# main function\ndef main_solution(layers_sizes, activation, cost_function, input_layer):\n    # Convert JSON serializable inputs to original input variables\n    layers_sizes = [int(x) for x in layers_sizes]\n    input_layer = np.array(input_layer).reshape(-1, 1)\n\n    # Initialize the neural network\n    nn = NN(layers_sizes, activation, cost_function)\n\n    # Perform forward propagation\n    output_layer = nn.forward_prop(input_layer)\n\n    # Convert output to JSON serializable\n    output_layer = output_layer.tolist()\n\n    return output_layer", "input_generator": "import numpy as np\nimport random\n\ndef input_generator():\n    # Randomly choose layer sizes (between 2 and 4 layers)\n    num_layers = random.randint(2, 4)\n    layers_sizes = [random.randint(2, 10) for _ in range(num_layers)]\n    \n    # Randomly choose activation function\n    activation = random.choice(['sigmoid', 'tanh', 'relu'])\n    \n    # Randomly choose cost function\n    cost_function = random.choice(['quadratic', 'cross_entropy'])\n    \n    # Generate random input layer matching the first layer size\n    input_layer = np.random.rand(layers_sizes[0]).tolist()\n    \n    return {\n        'layers_sizes': layers_sizes,\n        'activation': activation,\n        'cost_function': cost_function,\n        'input_layer': input_layer\n    }", "io_pairs": [{"input": {"layers_sizes": [6, 10], "activation": "sigmoid", "cost_function": "cross_entropy", "input_layer": [0.7552497039975968, 0.9340683932641126, 0.9429162472852313, 0.7745645641862279, 0.05185771046749499, 0.8903338078919266]}, "output": [[0.7484558961307604], [0.4458112733845645], [0.2542279802779185], [0.08502492612852587], [0.19049799504200554], [0.7082728866827581], [0.11828767412767248], [0.32082735394346346], [0.8583264074085633], [0.4558552426910606]]}, {"input": {"layers_sizes": [3, 10, 6], "activation": "sigmoid", "cost_function": "quadratic", "input_layer": [0.06650107429148289, 0.013495546897155375, 0.2402565608106415]}, "output": [[0.43697649723866655], [0.42881827356509994], [0.6645930351834394], [0.3189044478105244], [0.16160796130560565], [0.5216146641453586]]}, {"input": {"layers_sizes": [5, 10, 5], "activation": "tanh", "cost_function": "cross_entropy", "input_layer": [0.23910494153517015, 0.8050080467283246, 0.644742585486638, 0.7863644278568055, 0.12263707487627562]}, "output": [[0.9824680494449646], [-0.16439952326798105], [0.897698482690773], [-0.6270667753525879], [-0.7064851846966687]]}, {"input": {"layers_sizes": [4, 10, 2], "activation": "tanh", "cost_function": "quadratic", "input_layer": [0.26564733299689447, 0.9010117847863334, 0.978678897868152, 0.5257820546808336]}, "output": [[0.924234986808849], [0.5288951083402904]]}, {"input": {"layers_sizes": [3, 3], "activation": "tanh", "cost_function": "quadratic", "input_layer": [0.4514642730743692, 0.2098264507519636, 0.3984506046511398]}, "output": [[0.4068081788401566], [-0.5466854110105982], [0.8774014453530371]]}, {"input": {"layers_sizes": [3, 2, 10, 2], "activation": "tanh", "cost_function": "quadratic", "input_layer": [0.2120580736500176, 0.07651981386233009, 0.23585042951610813]}, "output": [[0.6321463247700224], [-0.23862807185950602]]}, {"input": {"layers_sizes": [4, 8, 2, 2], "activation": "relu", "cost_function": "quadratic", "input_layer": [0.3767278536704698, 0.24448650050755516, 0.8554692585982907, 0.03153242601340123]}, "output": [[0.9882915467868447], [0.0]]}, {"input": {"layers_sizes": [3, 7, 6, 7], "activation": "sigmoid", "cost_function": "quadratic", "input_layer": [0.7908773158419837, 0.6654526364032659, 0.18403562221116265]}, "output": [[0.2148502669901632], [0.4692871250077604], [0.6878799328947939], [0.09322463704776128], [0.17012386076584687], [0.35378196984214444], [0.6158608977702911]]}, {"input": {"layers_sizes": [3, 7], "activation": "tanh", "cost_function": "cross_entropy", "input_layer": [0.2539968357259941, 0.7742348389492755, 0.13525447347051]}, "output": [[0.05978970315075553], [0.6393285937200643], [-0.5759691747028701], [0.6627955338371726], [0.9232485225544387], [-0.3756150113945202], [0.09163470417950485]]}, {"input": {"layers_sizes": [2, 7, 5, 2], "activation": "tanh", "cost_function": "cross_entropy", "input_layer": [0.07402614991911671, 0.7158795105658637]}, "output": [[0.8123788384375995], [-0.8017901209271089]]}], "error_log": []}
{"context": "Given an encrypted text that has been encoded using a Vigen\u00e8re cipher, what are the average Index of Coincidence (IC) values for different period lengths of the key, ranging from 1 to a specified maximum period length? The encrypted text contains only uppercase letters (A-Z) and no spaces or punctuation.\n\nThe input and output requirements are as follows:\n\nInput:\n  `encrypted_text` (str): A string representing the encrypted text. The string should contain only uppercase letters (A-Z) and no spaces or punctuation.\n  `max_period` (int): An integer representing the maximum period length for the key to be considered. The value should be between 1 and 30.\n\nOutput:\n  `return` (list of float): A list of floats representing the average Index of Coincidence (IC) for period lengths from 1 to `max_period`. Each float in the list corresponds to the IC for a specific period length.", "reference_code": "# import necessary packages\nimport random\nimport string\n\n# all class and function definitions in the code file, if any\ndef update_freq(freq, char):\n    # to update the frequency according to char\n    i = ord(char) - ord('A')\n    if i >= 0 and i <= 25:\n        freq[i] += 1\n\ndef compute_IC(freq, N):\n    # computes the Index of Coincidence for the given frequency\n    # and total number of elements N\n    return sum([freq[i]*(freq[i]-1) for i in range(0,26)])/(N*(N-1))\n\n# main function\ndef main_solution(encrypted_text, max_period):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # encrypted_text: string, max_period: integer\n    \n    # Remove any newline characters from the encrypted text\n    encrypted_text = encrypted_text.replace('\\n', '')\n    N = len(encrypted_text)\n    \n    IC = [0]*(max_period+1)\n    \n    for period in range(1, max_period+1):\n        IC_for_this_period = [0]*period\n        for i in range(0, period):\n            freq = [0]*26\n            n = 0\n            for j in range(i, N, period):\n                update_freq(freq, encrypted_text[j])\n                n += 1\n            IC_for_this_period[i] = compute_IC(freq, n)\n        IC[period] = sum(IC_for_this_period)/period\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return IC[1:]", "input_generator": "import random\nimport string\n\ndef input_generator():\n    # Generate a random encrypted text (uppercase letters only)\n    length = random.randint(50, 200)\n    encrypted_text = ''.join(random.choices(string.ascii_uppercase, k=length))\n    \n    # Generate a random max_period between 1 and 10\n    max_period = random.randint(1, 10)\n    \n    return {\n        'encrypted_text': encrypted_text,\n        'max_period': max_period\n    }", "io_pairs": [{"input": {"encrypted_text": "PMIVTZGEDIFNYNUYCJBIICDSWGQFBSJRHSZJCDOMHBZGXYJCUEIKTBDUTXDIRJNIAMVHRCPUPMYUJOJKHA", "max_period": 2}, "output": [0.03733815115928937, 0.036585365853658534]}, {"input": {"encrypted_text": "KLDZRTFGSVPPIHQAFHCXKAVXUKAZDZTBYRXSIFYJSJFNIOXRJXWHYQOPBCQMEJCJOMFCWCYQOSEDSHRXMI", "max_period": 3}, "output": [0.03432700993676603, 0.03597560975609756, 0.04056437389770723]}, {"input": {"encrypted_text": "EPZOAKUMQXGBXOYBMNUJRNAOXPFXMANVJENUBSAYRSLJCQMAFTEGDOZDXGAUZDBWJXMIGDRVLCQHUQHWWCXMVEQMSOSMOKUHEO", "max_period": 8}, "output": [0.03766042499474016, 0.036139455782312924, 0.037980612577386774, 0.03916666666666667, 0.03941520467836257, 0.03725490196078431, 0.02511773940345369, 0.03394522144522145]}, {"input": {"encrypted_text": "XUWFQVCETVLVCRAWKHWAZVEJTLDYYCRYAVFBLEMKPKQLLJPTZNGQZRUWUQPQENUPBRDCLVRWFDHGZWTNUTJI", "max_period": 6}, "output": [0.03815261044176707, 0.04006968641114983, 0.037037037037037035, 0.041666666666666664, 0.03607843137254902, 0.047619047619047616]}, {"input": {"encrypted_text": "OYIGAFNAIEEMOTSJZOOBCBPJFAQQXLGZDIINUQCWOPLYGCRZHVESXR", "max_period": 8}, "output": [0.030747728860936407, 0.027065527065527065, 0.026143790849673203, 0.023809523809523808, 0.025454545454545452, 0.037037037037037035, 0.03231292517006802, 0.04047619047619047]}, {"input": {"encrypted_text": "MLFUMCWOICHWWXFBMQTORPBKOOMFRQBEAMGGKOOPZXGBDUSLTJQBN", "max_period": 5}, "output": [0.03991291727140784, 0.041595441595441596, 0.04466230936819172, 0.04624542124542125, 0.02707070707070707]}, {"input": {"encrypted_text": "PLKGRGWUOHGUNIHKMCCIJGGVETAFWJETNWXOVBLJCEGQBPDRGIWUJLEVXJXBUIPEHINHFTJHNFGAQRUZQJSX", "max_period": 8}, "output": [0.03930005737234653, 0.038908246225319396, 0.03791887125220458, 0.0369047619047619, 0.033725490196078435, 0.042124542124542134, 0.02164502164502164, 0.03207070707070707]}, {"input": {"encrypted_text": "HYQHIALANIKGKUMYBPJICRPOGQRIBUNLOOOABICUTUGJBWYKLHEKMAPRUJXWTLEZXUSCVQZHDAMPEQE", "max_period": 4}, "output": [0.0344044141512496, 0.04237516869095817, 0.029211775878442547, 0.03874269005847953]}, {"input": {"encrypted_text": "DOVYDVZOTWBWSEILDXKUQJICFFHUJVAJEBKVWBOVYYXDKRNABAFEHZRBKZZVAU", "max_period": 7}, "output": [0.03913273400317292, 0.04086021505376344, 0.04152046783625731, 0.03125, 0.0365967365967366, 0.041750841750841754, 0.013038548752834467]}, {"input": {"encrypted_text": "PVXVDAYQHOQQJJJKIPIPNRDTFHESIMDHCDLSXOGNKVSWDOTUWIMBDNIDCVXWECLJABMEELGUFQP", "max_period": 4}, "output": [0.03423423423423423, 0.03639165481270744, 0.02888888888888889, 0.034313725490196074]}], "error_log": []}
{"context": "Given a sparse matrix represented by a 2D list of floats, where non-zero values are explicitly listed and zero values are omitted, how would the matrix look after scaling it by a given scalar value?\n\nThe input and output requirements are as follows:\n\nInput:\n  `matrix_data` (list of lists of floats): A 2D list representing the sparse matrix. Each sublist represents a row, and each element in the sublist represents the value at the corresponding column. Non-zero values are explicitly listed, and zero values are omitted.\n  `scalar` (float): A scalar value by which the matrix is to be scaled.\n\nOutput:\n  `return` (list of lists of floats): A 2D list representing the scaled sparse matrix. Each sublist represents a row, and each element in the sublist represents the scaled value at the corresponding column.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\nclass SparseMatrix:\n    # Creates a sparse matrix of size numRows x numCols initialized to 0\n    def __init__(self, numRows, numCols):\n        self._numCols = numCols\n        self._listOfRows = [None] * numRows\n\n    # Returns the number of rows in the matrix\n    def numRows(self):\n        return len(self._listOfRows)\n\n    # Returns the number of columns in the matrix\n    def numCols(self):\n        return self._numCols\n\n    # Returns the value of element (i, j): x[i, j]\n    def __getitem__(self, ndxTuple):\n        row, col = ndxTuple\n        curNode = self._listOfRows[row]\n        while curNode is not None and curNode.col != col:\n            curNode = curNode.next\n        if curNode is not None:\n            return curNode.value\n        else:\n            return 0.0\n\n    # Set the value of element (i, j) to value s: x[i, j] = s\n    def __setitem__(self, ndxTuple, value):\n        row, col = ndxTuple\n        predNode = None\n        curNode = self._listOfRows[row]\n        while curNode is not None and curNode.col != col:\n            predNode = curNode\n            curNode = curNode.next\n\n        # See if the element is in the list\n        if curNode is not None and curNode.col == col:\n            if value == 0.0:  # remove the node\n                if curNode == self._listOfRows[row]:\n                    self._listOfRows[row] = curNode.next\n                else:\n                    predNode.next = curNode.next\n            else:\n                curNode.value = value\n        # Otherwise the element is not in the list\n        elif value != 0.0:\n            newNode = _MatrixElementNode(col, value)\n            newNode.next = curNode\n            if curNode == self._listOfRows[row]:\n                self._listOfRows[row] = newNode\n            else:\n                predNode.next = newNode\n\n    # Scales the matrix by the given scalar\n    def scaleBy(self, scalar):\n        for row in range(self.numRows()):\n            curNode = self._listOfRows[row]\n            while curNode is not None:\n                curNode.value *= scalar\n                curNode = curNode.next\n\n    # Creates and returns a new matrix that is the transpose of this matrix\n    def transpose(self):\n        newMatrix = SparseMatrix(self.numCols(), self.numRows())\n        for row in range(self.numRows()):\n            curNode = self._listOfRows[row]\n            while curNode is not None:\n                newMatrix[curNode.col, row] = curNode.value\n                curNode = curNode.next\n        return newMatrix\n\n    # Matrix addition: newMatrix = self + rhsMatrix\n    def __add__(self, rhsMatrix):\n        assert rhsMatrix.numRows() == self.numRows() and \\\n               rhsMatrix.numCols() == self.numCols(), \\\n            \"Matrix sizes not compatible for adding\"\n\n        newMatrix = SparseMatrix(self.numRows(), self.numCols())\n\n        for row in range(self.numRows()):\n            curNode = self._listOfRows[row]\n            while curNode is not None:\n                newMatrix[row, curNode.col] = curNode.value\n                curNode = curNode.next\n\n        for row in range(rhsMatrix.numRows()):\n            curNode = rhsMatrix._listOfRows[row]\n            while curNode is not None:\n                value = newMatrix[row, curNode.col]\n                value += curNode.value\n                newMatrix[row, curNode.col] = value\n                curNode = curNode.next\n\n        return newMatrix\n\n# Storage class for creating matrix element nodes\nclass _MatrixElementNode:\n    def __init__(self, col, value):\n        self.col = col\n        self.value = value\n        self.next = None\n\n# main function\ndef main_solution(matrix_data, scalar):\n    # Convert JSON serializable input to original input variables\n    numRows = len(matrix_data)\n    numCols = len(matrix_data[0])\n    matrix = SparseMatrix(numRows, numCols)\n\n    for row in range(numRows):\n        for col in range(numCols):\n            if matrix_data[row][col] != 0:\n                matrix[row, col] = matrix_data[row][col]\n\n    # Perform the scaling operation\n    matrix.scaleBy(scalar)\n\n    # Convert the result to JSON serializable output\n    result = []\n    for row in range(numRows):\n        result_row = []\n        for col in range(numCols):\n            result_row.append(matrix[row, col])\n        result.append(result_row)\n\n    return result", "input_generator": "import random\n\ndef input_generator():\n    numRows = random.randint(1, 10)\n    numCols = random.randint(1, 10)\n    matrix_data = []\n    for _ in range(numRows):\n        row = []\n        for _ in range(numCols):\n            # Generate sparse matrix with mostly zeros\n            if random.random() < 0.2:  # 20% chance of non-zero\n                row.append(round(random.uniform(-10, 10), 2))\n            else:\n                row.append(0)\n        matrix_data.append(row)\n    scalar = round(random.uniform(-5, 5), 2)\n    return {'matrix_data': matrix_data, 'scalar': scalar}", "io_pairs": [{"input": {"matrix_data": [[6.38, 0, 2.34, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, -7.53], [-7.74, 0, 0, 0, 0, -4.88, 0.76, 0]], "scalar": 3.86}, "output": [[24.6268, 0.0, 9.032399999999999, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -29.0658], [-29.8764, 0.0, 0.0, 0.0, 0.0, -18.8368, 2.9335999999999998, 0.0]]}, {"input": {"matrix_data": [[-9.48, 0, 0, 0, 0, 0, 0, 0]], "scalar": 3.35}, "output": [[-31.758000000000003, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]}, {"input": {"matrix_data": [[0, 0, 0, 0], [-6.7, 0, 0, 0], [0, 0, 0, 0], [-0.13, 0, 0, 0], [0, 5.73, 0, 0]], "scalar": 1.87}, "output": [[0.0, 0.0, 0.0, 0.0], [-12.529000000000002, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [-0.2431, 0.0, 0.0, 0.0], [0.0, 10.715100000000001, 0.0, 0.0]]}, {"input": {"matrix_data": [[0, 0, 0], [0, 0, -9.7]], "scalar": -4.97}, "output": [[0.0, 0.0, 0.0], [0.0, 0.0, 48.208999999999996]]}, {"input": {"matrix_data": [[-2.36, 0, 0, 0, 0, 0], [1.48, 0, 0, 0, 0, 0], [0, -8.85, 0, 0, 0, 0]], "scalar": 4.75}, "output": [[-11.209999999999999, 0.0, 0.0, 0.0, 0.0, 0.0], [7.03, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, -42.0375, 0.0, 0.0, 0.0, 0.0]]}, {"input": {"matrix_data": [[0, 0, 0], [0, 0, 0], [0, 5.8, 0], [0, -8.03, 0]], "scalar": -3.98}, "output": [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, -23.084, 0.0], [0.0, 31.9594, 0.0]]}, {"input": {"matrix_data": [[0, 0], [0, 0], [-9.35, 0]], "scalar": 1.75}, "output": [[0.0, 0.0], [0.0, 0.0], [-16.3625, 0.0]]}, {"input": {"matrix_data": [[0.19, 8.47, 0, 6.54, 0, 0], [0, 0, 4.48, 0, -7.18, 0], [0, 0, 9.58, 0, 0, 0]], "scalar": 1.51}, "output": [[0.2869, 12.789700000000002, 0.0, 9.8754, 0.0, 0.0], [0.0, 0.0, 6.764800000000001, 0.0, -10.8418, 0.0], [0.0, 0.0, 14.4658, 0.0, 0.0, 0.0]]}, {"input": {"matrix_data": [[0, 0, 3.68, 0, 0, -9.42, 0]], "scalar": 2.86}, "output": [[0.0, 0.0, 10.5248, 0.0, 0.0, -26.9412, 0.0]]}, {"input": {"matrix_data": [[0, 0, 0, 0, 0, 0]], "scalar": 2.93}, "output": [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]}], "error_log": []}
