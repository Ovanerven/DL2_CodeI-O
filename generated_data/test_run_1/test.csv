context,reference_code,input_generator
"In a classic N-Queens puzzle, the goal is to place N queens on an NÃ—N chessboard such that no two queens threaten each other. Given a board size `n`, a limit for side moves `limit`, and a number of iterations `iterations`, what is the success rate of finding a solution and the average number of steps taken to find a solution across all successful runs?

The input and output requirements are as follows:

Input:
  `n` (int): The size of the board, representing the number of queens.
  `limit` (int): The limit for the number of side moves allowed when the heuristic value does not decrease.
  `iterations` (int): The number of times the algorithm is run to calculate the success rate and average steps.

Output:
  `return` (dict): A dictionary containing the following keys:
    - `success_rate` (float): The success rate of finding a solution in the given number of iterations.
    - `average_steps` (float): The average number of steps taken to find a solution across all successful runs.","# import necessary packages
import random

# all class and function definitions in the code file, if any
def checkBoard(board):
    for x in range(0, len(board)):
        for y in range(x+1, len(board)):
            if (board[y] == board[x] + (y-x)) or (board[y] == board[x] - (y-x)):
                return False
    return True

def swap(board, first, second):
    temp = board[first]
    board[first] = board[second]
    board[second] = temp

def findH(board):
    h = 0
    for x in range(0, len(board)):
        for y in range(x+1, len(board)):
            if (board[y] == board[x] + (y-x)) or (board[y] == board[x] - (y-x)):
                h += 1
    return h

# main function
def main_solution(n, limit, iterations):
    step = []

    for _ in range(iterations):
        board = list(range(n))
        random.shuffle(board)

        h = findH(board)
        
        sides = 0

        minh = 100000
        tup = None
        steps = 0
        while not checkBoard(board):
            for x in range(0, len(board)):
                for y in range(x+1, len(board)):
                    temp = list(board)
                    swap(temp, x, y)
                    calc = findH(temp)
                    if calc < minh:
                        minh = calc
                        tup = (x, y)  
            if minh < h:
                swap(board, tup[0], tup[1])
                steps += 1
                h = minh
            elif h == minh and sides < limit:
                sides += 1
                swap(board, tup[0], tup[1])
                steps += 1
            else:
                break
        if checkBoard(board):
            step.append(steps)
    
    success_rate = len(step) / iterations
    avg_steps = sum(step) / len(step) if step else 0
    
    return {""success_rate"": success_rate, ""average_steps"": avg_steps}","import random

def input_generator():
    n = random.choice([4, 5, 6, 7, 8])
    limit = random.randint(1, 5)
    iterations = random.randint(100, 1000)
    return {""n"": n, ""limit"": limit, ""iterations"": iterations}"
