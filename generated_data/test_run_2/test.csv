"context","input_generator","reference_code"
"In a classic N-Queens puzzle, the goal is to place N queens on an NÃ—N chessboard such that no two queens threaten each other. Given a board size `n`, a limit for side moves `limit`, and a number of iterations `iterations`, what is the success rate of finding a solution and the average number of steps taken to find a solution across all successful runs?  The input and output requirements are as follows:  Input:   `n` (int): The size of the board, representing the number of queens.   `limit` (int): The limit for the number of side moves allowed when the heuristic value does not decrease.   `iterations` (int): The number of times the algorithm is run to calculate the success rate and average steps.  Output:   `return` (dict): A dictionary containing the following keys:     - `success_rate` (float): The success rate of finding a solution in the given number of iterations.     - `average_steps` (float): The average number of steps taken to find a solution across all successful runs.","import random  def input_generator():     n = random.choice([4, 5, 6, 7, 8])     limit = random.randint(1, 5)     iterations = random.randint(10, 100)     return {""n"": n, ""limit"": limit, ""iterations"": iterations}","# import necessary packages import random  # all class and function definitions in the code file, if any def checkBoard(board):     for x in range(0, len(board)):         for y in range(x+1, len(board)):             if (board[y] == board[x] + (y-x)) or (board[y] == board[x] - (y-x)):                 return False     return True  def swap(board, first, second):     temp = board[first]     board[first] = board[second]     board[second] = temp  def findH(board):     h = 0     for x in range(0, len(board)):         for y in range(x+1, len(board)):             if (board[y] == board[x] + (y-x)) or (board[y] == board[x] - (y-x)):                 h += 1     return h  # main function def main_solution(n, limit, iterations):     step = []      for _ in range(iterations):         board = list(range(n))         random.shuffle(board)          h = findH(board)                  sides = 0          minh = 100000         tup = None         steps = 0         while not checkBoard(board):             for x in range(0, len(board)):                 for y in range(x+1, len(board)):                     temp = list(board)                     swap(temp, x, y)                     calc = findH(temp)                     if calc < minh:                         minh = calc                         tup = (x, y)               if minh < h:                 swap(board, tup[0], tup[1])                 steps += 1                 h = minh             elif h == minh and sides < limit:                 sides += 1                 swap(board, tup[0], tup[1])                 steps += 1             else:                 break         if checkBoard(board):             step.append(steps)          success_rate = len(step) / iterations     avg_steps = sum(step) / len(step) if step else 0          return {""success_rate"": success_rate, ""average_steps"": avg_steps}"
"In a forest fire simulation, a fire starts at a specific tree and spreads based on a given probability. Given the size of the forest, the probability of fire spreading, and the coordinates of the initial tree that catches fire, what percentage of the forest will be burned?  The input and output requirements are as follows:  Input:   `size` (int): The number of trees in each row and column of the forest.   `prob_spread` (float): The probability threshold for fire spreading, between 0 and 1.   `x` (int): The x-coordinate of the initial tree to set smoldering.   `y` (int): The y-coordinate of the initial tree to set smoldering.  Output:   `return` (float): The percentage of trees that were burned, as a float between 0 and 1.","import numpy as np  def input_generator():     size = np.random.randint(5, 20)     prob_spread = np.random.uniform(0.1, 0.9)     x = np.random.randint(0, size)     y = np.random.randint(0, size)     return {'size': size, 'prob_spread': prob_spread, 'x': x, 'y': y}","# import necessary packages import numpy as np  # Constants UNBURNT = 1 BURNT = 0 SMOLDERING = 2 BURNING = 3  # Function definitions from the code file def initialize_forest(size):     """""" Create the forest of unburnt trees as a 2D array      Parameters:         size (int): number of trees in each row and column     Returns:         size x size numpy array     """"""     forest = np.empty((size, size), dtype='u4')     forest.fill(UNBURNT)     return forest  def light_tree(row_size, forest, x, y):     """""" Tree at position x, y in forest set to smoldering      Parameters:         row_size (int): number of trees in each row and column         forest (array): array representing the 2D forest         x (int), y (int): x,y location of tree to set smoldering      post[forest]:         If x, y is properly within the array, the tree at x, y is set.         Otherwise, one tree in the center of the forest is set.     """"""     if x >= row_size or y >= row_size:         i = int(row_size / 2)         j = int(row_size / 2)     else:         i = int(x)         j = int(y)     forest[i, j] = SMOLDERING  def fire_spreads(prob_spread):     """""" Generates a random number between 0 an 1 and checks if < prob_spread      Parameters:         prob_spread (float):             probability threshold for determining whether burning tree will             spread to neighboring tree      Returns:         True if new random value is < prob_spread, False otherwise     """"""     prob = np.random.random_sample()     return prob < prob_spread  def forest_burns(forest, row_size, prob_spread):     """"""One round of burning the forest      Sets every burning tree to burnt, and every smoldering tree to burning.     Then sets fire to unburnt trees next to burning trees randomly, based on     the probability of spreading.      Parameters:         forest (array): array representing the 2D forest         row_size (int): number of trees in each row and column         prob_spread (float):             probability threshold for determining whether burning tree will             spread to neighboring tree     """"""     for index, value in np.ndenumerate(forest):         if forest[index] == BURNING:             forest[index] = BURNT         if forest[index] == SMOLDERING:             forest[index] = BURNING      for index, value in np.ndenumerate(forest):         i, j = index[0], index[1]         if forest[index] == BURNING:             if i != 0 and forest[(i - 1, j)] == UNBURNT and fire_spreads(prob_spread):                 forest[(i - 1, j)] = SMOLDERING             if i != row_size - 1 and forest[(i + 1, j)] == UNBURNT and fire_spreads(prob_spread):                 forest[(i + 1, j)] = SMOLDERING             if j != 0 and forest[(i, j - 1)] == UNBURNT and fire_spreads(prob_spread):                 forest[(i, j - 1)] = SMOLDERING             if j != row_size - 1 and forest[(i, j + 1)] == UNBURNT and fire_spreads(prob_spread):                 forest[(i, j + 1)] = SMOLDERING  def forest_is_burning(forest):     """""" Checks for any remaining smoldering or burning trees      Parameters:         forest (array): array representing the 2D forest      Returns:         True if at least one tree is still in burning or smoldering state.         False if all trees are burnt.     """"""     for row in forest:         for tree in row:             if tree == SMOLDERING or tree == BURNING:                 return True     return False  def get_percent_burned(forest, row_size):     """""" Determine how many trees burned during fire      Parameters:         forest (array): array representing the 2D forest         row_size (int): number of trees in each row and column      Returns:         percent : float             Percentage of total number of trees that were burned,             as a float between 0 and 1.     """"""     sum = 0     for row in forest:         for tree in row:             if tree == BURNT:                 sum += 1     return float(sum) / float(row_size * row_size)  # main function def main_solution(size, prob_spread, x, y):     """""" Simulate the forest fire and return the percentage of burned trees      Parameters:         size (int): number of trees in each row and column         prob_spread (float): probability threshold for fire spreading         x (int): x-coordinate of the initial tree to set smoldering         y (int): y-coordinate of the initial tree to set smoldering      Returns:         float: Percentage of trees that were burned     """"""     forest = initialize_forest(size)     light_tree(size, forest, x, y)     while forest_is_burning(forest):         forest_burns(forest, size, prob_spread)     return get_percent_burned(forest, size)"
