{"context": "In a classic N-Queens puzzle, the goal is to place N queens on an N\u00d7N chessboard such that no two queens threaten each other. Given a board size `n`, a limit for side moves `limit`, and a number of iterations `iterations`, what is the success rate of finding a solution and the average number of steps taken to find a solution across all successful runs?\n\nThe input and output requirements are as follows:\n\nInput:\n  `n` (int): The size of the board, representing the number of queens.\n  `limit` (int): The limit for the number of side moves allowed when the heuristic value does not decrease.\n  `iterations` (int): The number of times the algorithm is run to calculate the success rate and average steps.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `success_rate` (float): The success rate of finding a solution in the given number of iterations.\n    - `average_steps` (float): The average number of steps taken to find a solution across all successful runs.", "reference_code": "# import necessary packages\nimport random\n\n# all class and function definitions in the code file, if any\ndef checkBoard(board):\n    for x in range(0, len(board)):\n        for y in range(x+1, len(board)):\n            if (board[y] == board[x] + (y-x)) or (board[y] == board[x] - (y-x)):\n                return False\n    return True\n\ndef swap(board, first, second):\n    temp = board[first]\n    board[first] = board[second]\n    board[second] = temp\n\ndef findH(board):\n    h = 0\n    for x in range(0, len(board)):\n        for y in range(x+1, len(board)):\n            if (board[y] == board[x] + (y-x)) or (board[y] == board[x] - (y-x)):\n                h += 1\n    return h\n\n# main function\ndef main_solution(n, limit, iterations):\n    step = []\n\n    for _ in range(iterations):\n        board = list(range(n))\n        random.shuffle(board)\n\n        h = findH(board)\n        \n        sides = 0\n\n        minh = 100000\n        tup = None\n        steps = 0\n        while not checkBoard(board):\n            for x in range(0, len(board)):\n                for y in range(x+1, len(board)):\n                    temp = list(board)\n                    swap(temp, x, y)\n                    calc = findH(temp)\n                    if calc < minh:\n                        minh = calc\n                        tup = (x, y)  \n            if minh < h:\n                swap(board, tup[0], tup[1])\n                steps += 1\n                h = minh\n            elif h == minh and sides < limit:\n                sides += 1\n                swap(board, tup[0], tup[1])\n                steps += 1\n            else:\n                break\n        if checkBoard(board):\n            step.append(steps)\n    \n    success_rate = len(step) / iterations\n    avg_steps = sum(step) / len(step) if step else 0\n    \n    return {\"success_rate\": success_rate, \"average_steps\": avg_steps}", "input_generator": "import random\n\ndef input_generator():\n    n = random.choice([4, 5, 6, 7, 8])\n    limit = random.randint(1, 5)\n    iterations = random.randint(10, 100)\n    return {\"n\": n, \"limit\": limit, \"iterations\": iterations}"}
{"context": "In a forest fire simulation, a fire starts at a specific tree and spreads based on a given probability. Given the size of the forest, the probability of fire spreading, and the coordinates of the initial tree that catches fire, what percentage of the forest will be burned?\n\nThe input and output requirements are as follows:\n\nInput:\n  `size` (int): The number of trees in each row and column of the forest.\n  `prob_spread` (float): The probability threshold for fire spreading, between 0 and 1.\n  `x` (int): The x-coordinate of the initial tree to set smoldering.\n  `y` (int): The y-coordinate of the initial tree to set smoldering.\n\nOutput:\n  `return` (float): The percentage of trees that were burned, as a float between 0 and 1.", "reference_code": "# import necessary packages\nimport numpy as np\n\n# Constants\nUNBURNT = 1\nBURNT = 0\nSMOLDERING = 2\nBURNING = 3\n\n# Function definitions from the code file\ndef initialize_forest(size):\n    \"\"\" Create the forest of unburnt trees as a 2D array\n\n    Parameters:\n        size (int): number of trees in each row and column\n    Returns:\n        size x size numpy array\n    \"\"\"\n    forest = np.empty((size, size), dtype='u4')\n    forest.fill(UNBURNT)\n    return forest\n\ndef light_tree(row_size, forest, x, y):\n    \"\"\" Tree at position x, y in forest set to smoldering\n\n    Parameters:\n        row_size (int): number of trees in each row and column\n        forest (array): array representing the 2D forest\n        x (int), y (int): x,y location of tree to set smoldering\n\n    post[forest]:\n        If x, y is properly within the array, the tree at x, y is set.\n        Otherwise, one tree in the center of the forest is set.\n    \"\"\"\n    if x >= row_size or y >= row_size:\n        i = int(row_size / 2)\n        j = int(row_size / 2)\n    else:\n        i = int(x)\n        j = int(y)\n    forest[i, j] = SMOLDERING\n\ndef fire_spreads(prob_spread):\n    \"\"\" Generates a random number between 0 an 1 and checks if < prob_spread\n\n    Parameters:\n        prob_spread (float):\n            probability threshold for determining whether burning tree will\n            spread to neighboring tree\n\n    Returns:\n        True if new random value is < prob_spread, False otherwise\n    \"\"\"\n    prob = np.random.random_sample()\n    return prob < prob_spread\n\ndef forest_burns(forest, row_size, prob_spread):\n    \"\"\"One round of burning the forest\n\n    Sets every burning tree to burnt, and every smoldering tree to burning.\n    Then sets fire to unburnt trees next to burning trees randomly, based on\n    the probability of spreading.\n\n    Parameters:\n        forest (array): array representing the 2D forest\n        row_size (int): number of trees in each row and column\n        prob_spread (float):\n            probability threshold for determining whether burning tree will\n            spread to neighboring tree\n    \"\"\"\n    for index, value in np.ndenumerate(forest):\n        if forest[index] == BURNING:\n            forest[index] = BURNT\n        if forest[index] == SMOLDERING:\n            forest[index] = BURNING\n\n    for index, value in np.ndenumerate(forest):\n        i, j = index[0], index[1]\n        if forest[index] == BURNING:\n            if i != 0 and forest[(i - 1, j)] == UNBURNT and fire_spreads(prob_spread):\n                forest[(i - 1, j)] = SMOLDERING\n            if i != row_size - 1 and forest[(i + 1, j)] == UNBURNT and fire_spreads(prob_spread):\n                forest[(i + 1, j)] = SMOLDERING\n            if j != 0 and forest[(i, j - 1)] == UNBURNT and fire_spreads(prob_spread):\n                forest[(i, j - 1)] = SMOLDERING\n            if j != row_size - 1 and forest[(i, j + 1)] == UNBURNT and fire_spreads(prob_spread):\n                forest[(i, j + 1)] = SMOLDERING\n\ndef forest_is_burning(forest):\n    \"\"\" Checks for any remaining smoldering or burning trees\n\n    Parameters:\n        forest (array): array representing the 2D forest\n\n    Returns:\n        True if at least one tree is still in burning or smoldering state.\n        False if all trees are burnt.\n    \"\"\"\n    for row in forest:\n        for tree in row:\n            if tree == SMOLDERING or tree == BURNING:\n                return True\n    return False\n\ndef get_percent_burned(forest, row_size):\n    \"\"\" Determine how many trees burned during fire\n\n    Parameters:\n        forest (array): array representing the 2D forest\n        row_size (int): number of trees in each row and column\n\n    Returns:\n        percent : float\n            Percentage of total number of trees that were burned,\n            as a float between 0 and 1.\n    \"\"\"\n    sum = 0\n    for row in forest:\n        for tree in row:\n            if tree == BURNT:\n                sum += 1\n    return float(sum) / float(row_size * row_size)\n\n# main function\ndef main_solution(size, prob_spread, x, y):\n    \"\"\" Simulate the forest fire and return the percentage of burned trees\n\n    Parameters:\n        size (int): number of trees in each row and column\n        prob_spread (float): probability threshold for fire spreading\n        x (int): x-coordinate of the initial tree to set smoldering\n        y (int): y-coordinate of the initial tree to set smoldering\n\n    Returns:\n        float: Percentage of trees that were burned\n    \"\"\"\n    forest = initialize_forest(size)\n    light_tree(size, forest, x, y)\n    while forest_is_burning(forest):\n        forest_burns(forest, size, prob_spread)\n    return get_percent_burned(forest, size)", "input_generator": "import numpy as np\n\ndef input_generator():\n    size = np.random.randint(5, 20)\n    prob_spread = np.random.uniform(0.1, 0.9)\n    x = np.random.randint(0, size)\n    y = np.random.randint(0, size)\n    return {'size': size, 'prob_spread': prob_spread, 'x': x, 'y': y}"}
