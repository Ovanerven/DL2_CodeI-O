"context","input_generator","reference_code"
"In a game of Tic Tac Toe, given the current state of the board and the markers assigned to two players, what would be the resulting board state after one move, and which player, if any, would be declared the winner?  The input and output requirements are as follows:  Input: - `board_state` (list of lists of strings): A 3x3 grid representing the current state of the Tic Tac Toe board. Each cell can be either an empty string `''`, `'X'`, or `'O'`. - `player1_marker` (string): The marker for player 1, either `'X'` or `'O'`. - `player2_marker` (string): The marker for player 2, either `'X'` or `'O'`.  Output: - `return` (tuple): A tuple containing:   - `new_board_state` (list of lists of strings): The updated 3x3 grid after the move.   - `winner` (string or None): The marker of the winner (`'X'` or `'O'`), or `None` if there is no winner yet.","import random  def input_generator():     markers = ['X', 'O']     player1_marker = random.choice(markers)     player2_marker = 'O' if player1_marker == 'X' else 'X'          board_state = []     for _ in range(3):         row = []         for _ in range(3):             cell = random.choice(['', 'X', 'O'])             row.append(cell)         board_state.append(row)          return {         'board_state': board_state,         'player1_marker': player1_marker,         'player2_marker': player2_marker     }","# import necessary packages import random import copy import ast  # Constants MARKERS = ['X', 'O']  # Board class definition class Board(object):     def __init__(self):         self.state = []         self.newBoard()      def newBoard(self):         self.state = [['', '', ''] for _ in range(3)]      def getState(self):         return self.state      def place(self, marker, x, y):         if marker in MARKERS and self.state[y][x] not in MARKERS:             self.state[y][x] = marker      def checkForWin(self):         nn = {             ""topLeft"": self.state[0][0],             ""topMid"": self.state[0][1],             ""topRight"": self.state[0][2],             ""midLeft"": self.state[1][0],             ""midMid"": self.state[1][1],             ""midRight"": self.state[1][2],             ""botLeft"": self.state[2][0],             ""botMid"": self.state[2][1],             ""botRight"": self.state[2][2],         }          if nn['topLeft'] in MARKERS:             if (nn['topLeft'] == nn['topMid'] == nn['topRight'] or                 nn['topLeft'] == nn['midMid'] == nn['botRight'] or                 nn['topLeft'] == nn['midLeft'] == nn['botLeft']):                 return nn['topLeft']         if nn['topMid'] in MARKERS:             if nn['topMid'] == nn['midMid'] == nn['botMid']:                 return nn['topMid']         if nn['topRight'] in MARKERS:             if nn['topRight'] == nn['midRight'] == nn['botRight']:                 return nn['topRight']         if nn['midLeft'] in MARKERS:             if nn['midLeft'] == nn['midMid'] == nn['midRight']:                 return nn['midLeft']         if nn['midMid'] in MARKERS:             if nn['midMid'] == nn['topRight'] == nn['botLeft']:                 return nn['midMid']         if nn['botLeft'] in MARKERS:             if nn['botLeft'] == nn['botMid'] == nn['botRight']:                 return nn['botLeft']         for value in nn.values():             if value not in MARKERS:                 return None         return 'Draw'  # Agent class definition class Agent(object):     def __init__(self, marker, random=False):         self.stateValues = {}         self.epsilon = 0.1         self.alpha = 0.99         self.marker = marker         self.lastState = []         self.random = random      def updateVars(self):         self.epsilon *= 0.9999         self.alpha *= 0.9999      def greedyMove(self, currentState):         possibilities = {}         for i in range(3):             for j in range(3):                 if currentState[i][j] not in MARKERS:                     possibleState = copy.deepcopy(currentState)                     possibleState[i][j] = self.marker                     if str(possibleState) in self.stateValues:                         possibilities[str(possibleState)] = self.stateValues[str(possibleState)]                     else:                         self.stateValues[str(possibleState)] = 0.5                         possibilities[str(possibleState)] = 0.5          maxState = None         maxValue = -10         for key, value in possibilities.items():             if value > maxValue:                 maxState = key                 maxValue = value             elif value == maxValue:                 if random.randint(0, 1) == 0:                     maxState = key                     maxValue = value          x = y = 0         maxState = ast.literal_eval(maxState)         for i in range(3):             for j in range(3):                 if currentState[i][j] != maxState[i][j]:                     x = j                     y = i          if str(currentState) in self.stateValues:             self.stateValues[str(currentState)] += self.alpha * (self.stateValues[str(maxState)] - self.stateValues[str(currentState)])         else:             self.stateValues[str(currentState)] = 0.5          self.lastState = maxState         return x, y      def exploratoryMove(self, currentState):         possibilities = []         for i in range(3):             for j in range(3):                 if currentState[i][j] not in MARKERS:                     possibilities.append((j, i))          choice = random.randint(0, len(possibilities) - 1)         move = possibilities[choice]         x, y = move          temp = copy.deepcopy(currentState)         temp[y][x] = self.marker         self.lastState = temp          return x, y      def chooseMove(self, currentState):         rVal = random.randint(1, 100)         decrVal = float(rVal) / 100          if self.random or decrVal <= self.epsilon:             x, y = self.exploratoryMove(currentState)         else:             x, y = self.greedyMove(currentState)          self.updateVars()         return x, y  # main function def main_solution(board_state, player1_marker, player2_marker):     board = Board()     board.state = board_state     p1 = Agent(player1_marker)     p2 = Agent(player2_marker)      game = Game(p1, p2)     game.board = board     game.makeMove(game.nextMove)      return game.board.getState(), game.winner.marker if game.winner else None  class Game(object):     def __init__(self, p1, p2):         self.board = Board()         self.p1 = p1         self.p2 = p2         self.lastMove, self.nextMove = self.chooseFirst(self.p1, self.p2)         self.winner = None      def chooseFirst(self, p1, p2):         return (p1, p2) if random.randint(0, 1) == 0 else (p2, p1)      def makeMove(self, player):         x, y = player.chooseMove(self.board.getState())         self.board.place(player.marker, x, y)         self.nextMove = self.lastMove         self.lastMove = player         result = self.board.checkForWin()         if result == player.marker:             self.gameOver(player.marker)         elif result == 'Draw':             self.gameOver('Draw')         else:             self.makeMove(self.nextMove)      def gameOver(self, status):         if status in MARKERS:             self.winner = self.lastMove         else:             self.winner = None"
"Given a dataset with features and target values, how can we determine the optimal parameters (theta) for a linear regression model using gradient descent, given a specific learning rate and number of iterations?  The input and output requirements are as follows:  Input:   `X_data` (list of lists): A list of lists representing the feature matrix. Each sublist represents a row in the matrix.   `y_data` (list): A list representing the target vector.   `alpha` (float): The learning rate for the gradient descent algorithm.   `iterations` (int): The number of iterations for the gradient descent algorithm.  Output:   `return` (list of lists): A list of lists representing the final theta values after running the gradient descent algorithm. Each sublist contains one theta value.","import numpy as np import random  def input_generator():     # Generate a random number of data points between 10 and 100     n = random.randint(10, 100)          # Generate random X_data (features) between -10 and 10     X_data = [random.uniform(-10, 10) for _ in range(n)]          # Generate random y_data (target) with some linear relationship plus noise     slope = random.uniform(-5, 5)     intercept = random.uniform(-5, 5)     noise = [random.uniform(-1, 1) for _ in range(n)]     y_data = [slope * x + intercept + n for x, n in zip(X_data, noise)]          # Generate random alpha (learning rate) between 0.001 and 0.1     alpha = random.uniform(0.001, 0.1)          # Generate random iterations between 100 and 1000     iterations = random.randint(100, 1000)          return {         'X_data': X_data,         'y_data': y_data,         'alpha': alpha,         'iterations': iterations     }","# import necessary packages import numpy as np  # main function def main_solution(X_data, y_data, alpha, iterations):     # Convert JSON serializable inputs to numpy matrices     X = np.matrix(X_data).T     y = np.matrix(y_data).T     theta = np.matrix([0, 1]).T      for i in range(iterations):         h = X.dot(theta)         derivative = np.matrix([0, 0]).T         for j in range(X.shape[1]):             derivative[j] = sum(np.multiply(h - y, X[:, j]))         theta = theta - alpha * derivative      # Convert numpy matrix to JSON serializable list     theta_list = theta.tolist()     return theta_list"
"Given a time series represented by a 2D array, where each row is a separate time series, and a specific segment of each row is set to a constant value (referred to as a ""top hat"" function), what is the autocorrelation function for each time series after normalization? The autocorrelation function should be calculated for each row and normalized by the variance of the row.  The input and output requirements are as follows:  Input:   `m` (int): Number of rows in the array.   `n` (int): Number of columns in the array.   `top_hat_indices` (list of int): A list containing two integers representing the start and end indices of the top hat function.  Output:   `return` (list of list of float): A list of autocorrelation functions, where each autocorrelation function is represented as a list of floats.","import numpy as np import random  def input_generator():     m = random.randint(1, 10)     n = random.randint(5, 20)     start = random.randint(0, n - 2)     end = random.randint(start + 1, n)     top_hat_indices = [start, end]     return {'m': m, 'n': n, 'top_hat_indices': top_hat_indices}","# import necessary packages import numpy as np  # main function def main_solution(m, n, top_hat_indices):     # Initialize the array     x = np.zeros(shape=(m, n))          # Apply the top hat function to each row     for row in x:         row[top_hat_indices[0]:top_hat_indices[1]] = 1          # Calculate the autocorrelation for each row     acorrs = []     for row in x:         y = row - row.mean()         acorr = np.correlate(y, y, mode=""full"")         acorr = acorr[acorr.size // 2:]         acorr /= (row.var() * np.arange(row.size, 0, -1))         acorrs.append(acorr.tolist())  # Convert to list for JSON serializability          return acorrs"
"Given a square matrix, what are the eigenvalues and corresponding eigenvectors of the matrix?  The input and output requirements are as follows:  Input:   `matrix` (list of lists of floats): A 2D list representing a square matrix. Each sublist represents a row in the matrix.  Output:   `return` (dict): A dictionary containing two keys:     - `eigenvalues` (list of floats): A list of eigenvalues of the input matrix.     - `eigenvectors` (list of lists of floats): A list of eigenvectors corresponding to the eigenvalues. Each eigenvector is represented as a list of floats.","import numpy as np import random  def input_generator():     # Generate a random size for the matrix (2x2 or 3x3)     size = random.choice([2, 3])          # Generate random integers for the matrix elements     matrix = np.random.randint(-10, 10, size=(size, size)).tolist()          return {""matrix"": matrix}","# import necessary packages import numpy as np from numpy.linalg import eig  # main function def main_solution(matrix):     # Convert the input matrix to a numpy array     A = np.array(matrix)          # Calculate the eigenvalues and eigenvectors     eigenvalues, eigenvectors = eig(A)          # Convert the eigenvalues and eigenvectors to JSON serializable format     eigenvalues = eigenvalues.tolist()     eigenvectors = eigenvectors.tolist()          # Return the eigenvalues and eigenvectors     return {""eigenvalues"": eigenvalues, ""eigenvectors"": eigenvectors}"
"Given two numbers represented in base -2, what is the sum of these two numbers when they are converted back to base -2?  The input and output requirements are as follows:  Input:   `arr1` (list of int): A list of integers representing a number in base -2.   `arr2` (list of int): A list of integers representing another number in base -2. Output:   `return` (list of int): A list of integers representing the sum of the two input numbers in base -2.","import random  def input_generator():     # Generate two random integers between -100 and 100     int1 = random.randint(-100, 100)     int2 = random.randint(-100, 100)          # Convert integers to base -2 lists     arr1 = [int(c) for c in int2neg2(int1)] if int1 != 0 else [0]     arr2 = [int(c) for c in int2neg2(int2)] if int2 != 0 else [0]          return {'arr1': arr1, 'arr2': arr2}","# import necessary packages  # all class and function definitions in the code file, if any def int2neg2(x):     ans = """"     while x != 0:         tmp = abs(x % (-2))         ans += str(tmp)         x = (x - tmp) // (-2)     return """".join(reversed(ans))  def neg22int(arr):     answer = 0     base = 1     for i in range(len(arr) - 1, -1, -1):         if arr[i] == 1:             answer += base         base *= (-2)     return answer  # main function def main_solution(arr1, arr2):     # Convert the input lists to integers in base -2     int1 = neg22int(arr1)     int2 = neg22int(arr2)          # Sum the integers     sum_int = int1 + int2          # Convert the sum back to base -2     sum_neg2 = int2neg2(sum_int)          # Convert the result to a list of integers     result = [int(char) for char in sum_neg2]          # Return the result as a list of integers     return result"
"Given a Rubik's Cube that is initially solved, if we apply a series of random scramble moves to it, will the cube remain solved? Specifically, what is the result of applying the given scramble moves to the cube?  The input and output requirements are as follows:  Input:   `scramble_moves` (list of strings): A list of strings representing the moves to scramble the Rubik's Cube. Each string should be a valid move in the format ""F"", ""B"", ""L"", ""R"", ""U"", ""D"", ""F'"", ""B'"", ""L'"", ""R'"", ""U'"", ""D'"", ""F2"", ""B2"", ""L2"", ""R2"", ""U2"", ""D2"".  Output:   `return` (dictionary): A dictionary with a single key ""is_solved"" (boolean) indicating whether the Rubik's Cube is solved after applying the scramble moves.","import random  def input_generator():     move_options = ['F', 'B', 'L', 'R', 'U', 'D']     modifiers = ["""", ""'"", ""2""]     num_moves = random.randint(5, 15)     scramble_moves = []     for _ in range(num_moves):         move = random.choice(move_options)         modifier = random.choice(modifiers)         scramble_moves.append(move + modifier)     return {""scramble_moves"": scramble_moves}","# import necessary packages import random  # all class and function definitions in the code file, if any class Cubie(object):     def __init__(self, cx, cy, cz):         self.colors = [cx, cy, cz]      def rotate(self, axis):         if axis == 0:  # X             self.colors = [self.colors[0], self.colors[2], self.colors[1]]         elif axis == 1:  # Y             self.colors = [self.colors[2], self.colors[1], self.colors[0]]         elif axis == 2:  # Z             self.colors = [self.colors[1], self.colors[0], self.colors[2]]      def update_colors(self, new_color):         self.colors = new_color  class Cube(object):     def __init__(self, state=None):         self._orientation = [0, 1, 2]         self._state = []          if not state:             for i in range(27):                 cx = cy = cz = None                  if i % 3 == 0:  # left                     cx = 'b'                 elif i % 3 == 2:  # right                     cx = 'g'                 if i < 9:  # front                     cz = 'r'                 elif i > 17:  # back                     cz = 'o'                 if i % 9 < 3:  # up                     cy = 'y'                 elif i % 9 > 5:  # down                     cy = 'w'                  self._state.append(Cubie(cx, cy, cz))          self._front = [self._state[i] for i in (0, 1, 2, 5, 8, 7, 6, 3, 4)]         self._back = [self._state[i] for i in (20, 19, 18, 21, 24, 25, 26, 23, 22)]         self._left = [self._state[i] for i in (18, 9, 0, 3, 6, 15, 24, 21, 12)]         self._right = [self._state[i] for i in (2, 11, 20, 23, 26, 17, 8, 5, 14)]         self._up = [self._state[i] for i in (18, 19, 20, 11, 2, 1, 0, 9, 10)]         self._down = [self._state[i] for i in (6, 7, 8, 17, 26, 25, 24, 15, 16)]         self._equator = [self._state[i] for i in (3, 4, 5, 14, 23, 22, 21, 12, 13)]          self._face_dict = {             'F': (self._front, 2), 'B': (self._back, 2),             'L': (self._left, 0), 'R': (self._right, 0),             'U': (self._up, 1), 'D': (self._down, 1)         }          self._face_order = ('U', 'L', 'F', 'R', 'B', 'D')      def get_face(self, face, side=False):         face_s = self._face_dict[face][0]         if not side:             axis = self._face_dict[face][1]             return ''.join(face_s[i].colors[axis] for i in (0, 1, 2, 7, 8, 3, 6, 5, 4))         else:             re = ''             for i in range(0, 8, 2):                 axis = 0 if i % 4 == 2 else 2                 for j in range(3):                     re += face_s[i+j if i+j < 8 else 0].colors[axis]             return re      def set_face(self, face, s):         face_s = self._face_dict[face][0]         axis = self._face_dict[face][1]         for i, j in zip((0, 1, 2, 7, 8, 3, 6, 5, 4), range(9)):             face_s[i].colors[axis] = s[j]      def is_solved(self):         for face in self._face_dict.keys():             face_s = self.get_face(face)             c = face_s[0]             for i in face_s[1:]:                 if i != c:                     return False         return True      def turn(self, face):         if 'Y' in face:             self.rotate_y(False if ""'"" in face else True)             if '2' in face:                 self.rotate_y(False if ""'"" in face else True)             return          shift = 2 if ""'"" in face else -2         face_s = self._face_dict[face[0]][0]         axis = self._face_dict[face[0]][1]         face_ref = [face_s[(i + shift) % 8].colors for i in range(8)]         for color, color_new in zip(face_s[:-1], face_ref):             color.update_colors(color_new)             color.rotate(axis)          if '2' in face:             self.turn(face[:-1])      def rotate_y(self, cw=True):         shift = 0         if cw:             self.turn('U')             self.turn(""D'"")             shift = 2         else:             self.turn(""U'"")             self.turn('D')             shift = -2         cubies = self._equator         cubies_ref = [cubies[(i + shift) % 8].colors for i in range(8)]         for color, color_new in zip(cubies[:-1], cubies_ref):             color.update_colors(color_new)             color.rotate(1)      def scramble(self, turns=10, by_hand=False):         p = []         for i in range(turns):             move_pool = ['F', 'B', 'L', 'R', 'U']             if by_hand:                 move_pool.append('D')             move = random.choice(move_pool)             move += random.choice([""'"", ''])             self.turn(move)             p.append(move)         return p  # main function def main_solution(scramble_moves):     # Initialize a solved cube     cube = Cube()          # Apply the scramble moves to the cube     for move in scramble_moves:         cube.turn(move)          # Check if the cube is solved after applying the scramble moves     is_solved = cube.is_solved()          # Return the result as a dictionary     return {""is_solved"": is_solved}"
"Given a set of dominoes, each with two numbers on its sides, can you determine if they can be arranged in a chain such that the second number of each domino matches the first number of the next domino? If a valid chain exists, what is the arrangement of the dominoes in that chain?  The input and output requirements are as follows:  Input:   `dominoes` (list of lists): A list of dominoes, where each domino is represented as a list of two integers. Each integer represents the number on one side of the domino.  Output:   `return` (list of lists): A valid chain of dominoes if one exists, otherwise an empty list. Each domino in the chain is represented as a list of two integers.","import random  def input_generator():     # Randomly decide the number of dominoes (between 1 and 6 for reasonable size)     n = random.randint(1, 6)          # Generate dominoes ensuring some can form a chain     if random.random() < 0.5:         # Generate a valid chain         first = random.randint(0, 6)         dominoes = []         prev = first         for _ in range(n):             next_num = random.randint(0, 6)             dominoes.append([prev, next_num])             prev = next_num         # Close the loop if more than one domino         if n > 1:             dominoes[-1][1] = first     else:         # Generate random dominoes (may or may not form a chain)         dominoes = []         for _ in range(n):             a = random.randint(0, 6)             b = random.randint(0, 6)             dominoes.append([a, b])          # Shuffle the dominoes to add randomness     random.shuffle(dominoes)          return {'dominoes': dominoes}","# import necessary packages import itertools  # main function def main_solution(dominoes):     """"""     Determines if a set of dominoes can form a valid chain.      Args:         dominoes (list of lists): A list of dominoes, where each domino is represented as a list of two integers.      Returns:         list of lists: A valid chain of dominoes if one exists, otherwise an empty list.     """"""     if not dominoes:         return []      for permutation in itertools.permutations(dominoes):         solution = check(permutation)         if solution is not None:             return solution     return []  def check(permutation):     """"""     Checks if a given permutation of dominoes forms a valid chain.      Args:         permutation (tuple of lists): A permutation of dominoes.      Returns:         list of lists: A valid chain of dominoes if one exists, otherwise None.     """"""     last_prev, prev = permutation[0]     solution = [list(permutation[0])]     for i in range(1, len(permutation)):         if permutation[i][0] == prev:             prev = permutation[i][1]             solution.append(list(permutation[i]))         elif permutation[i][1] == prev:             prev = permutation[i][0]             solution.append(list(permutation[i][::-1]))         else:             return None     return solution if prev == last_prev else None"
"Alice and Bob are playing a game with a pile of stones. Alice always goes first. On each player's turn, they can remove either 2, 3, or 5 stones from the pile. The player who cannot make a move loses the game. Given the number of stones `n` in the pile, who will win the game if both players play optimally?  The input and output requirements are as follows:  Input:   `n` (int): The number of stones in the pile.  Output:   `return` (str): A string indicating the winner of the game. It can be either ""First"" or ""Second"".","import random  def input_generator():     n = random.randint(0, 100)     return {'n': n}","# import necessary packages import sys  # all class and function definitions in the code file, if any win = {0: False, 1: False}  def progdyn(n):     if n not in win:         win[n] = not progdyn(n - 2) or (n > 2 and not progdyn(n - 3)) or (n > 4 and not progdyn(n - 5))     return win[n]  # main function def main_solution(n):     # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)     # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)     result = progdyn(n)     # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)     return ""First"" if result else ""Second"""
"Given a polynomial function defined by its coefficients, how can we find an approximate root of this polynomial using the Newton-Raphson method starting from a given initial guess?  The input and output requirements are as follows:  Input:   `coefficients` (list of float): The coefficients of the polynomial function in descending order of degree. For example, for the polynomial \(3x^3 - 2x^2 + 5x - 1\), the coefficients would be `[3, -2, 5, -1]`.   `initial_guess` (float): The initial guess for the root of the polynomial function.  Output:   `return` (dict): A dictionary containing the following keys:     - `root` (float): The approximate root of the polynomial function.     - `error` (float): The error (distance from the root to zero) of the approximation.     - `iterations` (int): The number of iterations taken to find the root.","import random  def input_generator():     # Generate random coefficients for a cubic polynomial (a, b, c, d)     coefficients = [random.uniform(-10, 10) for _ in range(4)]          # Generate a reasonable initial guess, possibly near a root     # To make it reasonable, we can pick a value between -5 and 5     initial_guess = random.uniform(-5, 5)          return {         ""coefficients"": coefficients,         ""initial_guess"": initial_guess     }","# import necessary packages import random  # all class and function definitions in the code file, if any def cubic_function(a=0, b=0, c=0, d=0):     return lambda x : (a * pow(x, 3)) + (b * pow(x, 2)) + (c * x) + d  def derivative(function, x, h=0.00001):     return (function(x + h) - function(x)) / h  def evaluate_guess(function, guess_x):     return abs( 0 - function(guess_x) )  def newthon_raphson_step(function, guess_x=0):     return guess_x - (function(guess_x) / derivative(function, guess_x) )  def newthon_raphson(function, x_0=0, precision=0.000001, max_iterations=1000):     best_guess_x = x_0     Δ = evaluate_guess(function, x_0)     iteration = 0      while best_guess_x is not None and Δ > precision and iteration < max_iterations:         iteration += 1         best_guess_x = newthon_raphson_step(function, best_guess_x)         Δ = evaluate_guess(function, best_guess_x)      return best_guess_x, Δ, iteration  # main function def main_solution(coefficients, initial_guess):   """"""   Find the root of a polynomial function using the Newton-Raphson method.    Parameters:   coefficients (list of float): The coefficients of the polynomial function in descending order of degree.   initial_guess (float): The initial guess for the root.    Returns:   dict: A dictionary containing the root, the error, and the number of iterations.   """"""   # Convert coefficients to a polynomial function   function = cubic_function(*coefficients)      # Find the root using Newton-Raphson method   root, error, iterations = newthon_raphson(function, initial_guess)      # Return the result as a dictionary   return {       ""root"": root,       ""error"": error,       ""iterations"": iterations   }"
"Given a string and a pattern, how can we determine all possible ways to map each character in the pattern to a non-empty substring of the string such that the concatenation of the substrings matches the pattern?  The input and output requirements are as follows:  Input:   `input_string` (str): A string that needs to be matched against the pattern.   `pattern` (str): A pattern string that defines the structure of the mapping.  Output:   `return` (list of dict): A list of dictionaries where each dictionary represents a possible mapping of the pattern characters to substrings of the input string. Each key in the dictionary is a character from the pattern, and the corresponding value is the substring from the input string that matches the pattern character.","import random import string  def input_generator():     # Generate a random pattern with 1-3 unique lowercase letters     pattern_length = random.randint(1, 3)     pattern = ''.join(random.sample(string.ascii_lowercase, pattern_length))          # Generate a random input string with length between pattern_length and 10     input_length = random.randint(pattern_length, 10)     input_string = ''.join(random.choices(string.ascii_lowercase, k=input_length))          return {         'input_string': input_string,         'pattern': pattern     }","# import necessary packages import copy  # main function def main_solution(input_string, pattern):     # Convert the input variables to the required format for the recursion function     def recursion(str, ptn, map={}, res=[]):         if len(ptn) == 0:             if len(str) == 0:                 res.append(copy.deepcopy(map))                 return             else:                 return                  ch = ptn[0]         rop = ptn[1:]                  if ch in map:             if map[ch] == str[0:len(map[ch])]:                 recursion(str[len(map[ch]):], rop, map, res)         else:             for i in range(len(str)):                 prefix = str[0:i+1]                 rest = str[i+1:]                 map[ch] = prefix                 recursion(rest, rop, map, res)                 del map[ch]                  return res          # Call the recursion function with the provided input and pattern     result = recursion(input_string, pattern)          # Convert the result to a JSON serializable format     json_result = [dict(item) for item in result]          return json_result"
"Given a binary string, determine if the number it represents is divisible by 3. What is the result of checking the divisibility of the given binary string?  The input and output requirements are as follows:  Input:   `binary_string` (str): A string representing a binary number. The string should only contain characters '0' and '1'.  Output:   `return` (bool): A boolean value indicating whether the input binary string represents a number divisible by 3. `True` if divisible, `False` otherwise.","import random  def input_generator():     # Generate a random binary string that may or may not be divisible by 3     length = random.randint(1, 20)     binary_string = ''.join(random.choice('01') for _ in range(length))          # Occasionally ensure the string is divisible by 3     if random.random() < 0.5:         num = random.randint(0, 100) * 3         binary_string = bin(num)[2:]          return {'binary_string': binary_string}","# import necessary packages import re  # main function def main_solution(binary_string):     # Convert the input binary string to a format suitable for the regex     binary_string = str(binary_string)          # Define the regex pattern for numbers divisible by 3     DIV_3 = re.compile(r'^(0|11|10(00)*(1+(00)+)*1*01)+$')          # Check if the binary string matches the regex pattern     match = bool(DIV_3.match(binary_string))          # Return the result     return match"
"Given a range of digits from 1 to a specified highest digit, what is the largest prime number that can be formed by permuting these digits?  The input and output requirements are as follows:  Input:   `highest_digit` (int): The highest digit to consider for generating pandigital numbers. Must be between 1 and 9.  Output:   `return` (int): The largest prime pandigital number found for the given `highest_digit`. If no such number is found, returns 0.","import random  def input_generator():     highest_digit = random.randint(2, 8)     return {'highest_digit': highest_digit}","# import necessary packages import math from itertools import permutations  # all class and function definitions in the code file, if any def IsPrime(num):     if num <= 1:         return False      sqRt = round(math.sqrt(num))     for i in range(2, sqRt + 1):         if num % i == 0:             return False     return True  # main function def main_solution(highest_digit):     largest = 0      while largest == 0 and highest_digit >= 1:         l = list(permutations(range(1, highest_digit + 1)))          for permutation in l:             num = 0             for i in permutation:                 num *= 10                 num += i             if num < largest or not IsPrime(num):                 continue             else:                 largest = num          highest_digit -= 1      return largest"
"Given a positive integer, determine the value of the Mobius function for that integer. The Mobius function is defined as follows: - It returns `1` if the integer is square-free and has an even number of prime factors. - It returns `-2` if the integer is square-free and has an odd number of prime factors. - It returns `0` if the integer is not square-free.  What is the value of the Mobius function for the given integer?  The input and output requirements are as follows:  Input:   `number` (int): A positive integer for which the Mobius function is to be calculated.  Output:   `return` (int): The result of the Mobius function applied to the input number. The possible values are:     - `1` if the number is square-free and has an even number of prime factors.     - `-2` if the number is square-free and has an odd number of prime factors.     - `0` if the number is not square-free.","import random  def input_generator():     # Generate a random number between 1 and 1000, with higher probability for smaller numbers     # to ensure a mix of square-free and non-square-free numbers     number = random.choices(         range(1, 1001),         weights=[1/(i+1) for i in range(1000)],         k=1     )[0]     return {'number': number}","# import necessary packages import random  # all class and function definitions in the code file, if any def isSquareFree(factors):     for i in factors:         if factors.count(i) > 1:             return False     return True  def primeFactor(number):     i = 2     factors = []     while i * i <= number:         if number % i:             i += 1         else:             number //= i             factors.append(i)     if number > 1:         factors.append(number)     return factors  def mobiusFunction(number):     factors = primeFactor(number)     if isSquareFree(factors):         if len(factors) % 2 == 0:             return 1         elif len(factors) % 2 != 0:             return -2     else:         return 0  # main function def main_solution(number):     # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)     # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)     result = mobiusFunction(number)     # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)     return result"
"In a secure communication system, two parties wish to establish a shared secret key using the Diffie-Hellman key exchange protocol. Given a prime number `p` and a generator `g`, what is the shared secret key that both parties will derive?  The input and output requirements are as follows:  Input:   `p` (int): A prime number used as the modulus in the Diffie-Hellman key exchange.   `g` (int): A generator number used in the Diffie-Hellman key exchange.  Output:   `return` (int): The shared secret key generated by the Diffie-Hellman key exchange process.","import random import sympy  def input_generator():     # Generate a large prime p     p = sympy.randprime(2**10, 2**16)     # Generate a generator g (primitive root modulo p)     def is_primitive_root(g, p):         if g == 0:             return False         order = p - 1         factors = sympy.primefactors(order)         for factor in factors:             if pow(g, order // factor, p) == 1:                 return False         return True     g = random.randint(2, p - 1)     while not is_primitive_root(g, p):         g = random.randint(2, p - 1)     return {'p': p, 'g': g}","# import necessary packages from random import randint  # all class and function definitions in the code file, if any class CryptoMath:     @staticmethod     def mod_mul(a, b, n):         """""" returns (a * b) % n without overflowing """"""         x = 0         y = a         while b > 0:             if (b & 1) != 0:                 # odd number                 x = (x + y) % n             y = (y + y) % n             b = b // 2         return x % n      @staticmethod     def mod_exp(a, b, n):         """"""returns (a ** b) % n without overflowing """"""         x = 1         y = a         while b > 0:             if (b & 1) != 0:                 # odd number                 x = CryptoMath.mod_mul(x, y, n)             y = CryptoMath.mod_mul(y, y, n)             b = b // 2         return x % n   class DiffieHellman:     def __init__(self, p, g):         """"""Initialize the modulus and generator""""""         self.p = p         self.g = g              def get_dh_key(self):         # the random numbers a,b must be in the group modulo p         self.a = randint(0, self.p)         self.A = CryptoMath.mod_exp(self.g, self.a, self.p)              self.b = randint(0, self.p)         self.B = CryptoMath.mod_exp(self.g, self.b, self.p)                  # simulate the shared key generation         self.key_A = CryptoMath.mod_exp(self.B, self.a, self.p)         self.key_B = CryptoMath.mod_exp(self.A, self.b, self.p)         assert(self.key_A == self.key_B)         return self.key_A  # main function def main_solution(p, g):     # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)     dh = DiffieHellman(p, g)     shared_key = dh.get_dh_key()     # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)     return shared_key"
"Given a chessboard of size `n x n`, how can we place `n` queens on the board such that no two queens threaten each other? Each queen must be placed in a unique row and column, and no two queens can be on the same diagonal. What are the possible configurations of the queens on the board?  The input and output requirements are as follows:  Input:   `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.  Output:   `return` (list of strings): A list of strings where each string represents a solution to the N-Queens problem. Each solution is formatted as `""[1 3 5 2 4 ]""`, where the numbers represent the row positions of the queens in each column. If no solution exists, the function returns `-1`.","import random  def input_generator():     n = random.choice([4, 5, 6, 7, 8])     return {'n': n}","# import necessary packages import random  # all class and function definitions in the code file, if any def is_safe(board, row, col):     # Check the row     for i in range(col):         if board[row][i] == 1:             return False     # Check the main diagonal     i = row - 1; j = col - 1     while i >= 0 and j >= 0:         if board[i][j] == 1:             return False         i -= 1         j -= 1     # Check the secondary diagonal     i = row; j = col     while i < len(board) and j >= 0:         if board[i][j] == 1:             return False         i += 1         j -= 1     return True  def solve(board, n, solutions, col, solution):     if col >= n:         solutions.append(solution)         return True     for i in range(n):         if is_safe(board, i, col):             board[i][col] = 1             solve(board, n, solutions, col + 1, solution + [i + 1])             board[i][col] = 0     return False  # main function def main_solution(n):     board = [[0 for _ in range(n)] for _ in range(n)]     solutions = []     solve(board, n, solutions, 0, [])     if len(solutions) == 0:         return -1     formatted_solutions = [""["" + "" "".join([str(val) for val in sol]) + "" ]"" for sol in solutions]     return formatted_solutions"
"Given an initial state of a Sudoku board represented as a string, where each character represents a cell in the board (with '0' for empty cells and '1'-'9' for filled cells), what is the solved state of the Sudoku board?  The input and output requirements are as follows:  Input:   `board_string` (str): A string representing the initial state of the Sudoku board. Each character in the string represents a cell in the board, where '0' represents an empty cell and '1'-'9' represent the filled cells. The length of the string should be a perfect square (e.g., 81 for a 9x9 board).  Output:   `return` (str): A string representing the solved Sudoku board. Each character in the string represents a cell in the board, where '1'-'9' represent the filled cells. If no solution is found, the string ""No solution found"" is returned.","import random import math  def input_generator():     # Generate a random Sudoku board size (4 or 9 for simplicity)     size = random.choice([4, 9])     subsquare = int(math.sqrt(size))          # Create a solved Sudoku board     def create_solved_board(size):         base = subsquare         side = base * base         nums = random.sample(range(1, side + 1), side)         board = [[nums[(base * (r % base) + r // base + c) % side] for c in range(side)] for r in range(side)]         return board          solved_board = create_solved_board(size)          # Randomly remove some numbers to create a puzzle     board_string = []     for row in solved_board:         for num in row:             if random.random() < 0.5:  # 50% chance to keep the number                 board_string.append(str(num))             else:                 board_string.append('0')          board_string = ''.join(board_string)          return {'board_string': board_string}","# import necessary packages import struct import string import math import random  # all class and function definitions in the code file, if any class SudokuBoard:     def __init__(self, size, board):         self.BoardSize = size          self.CurrentGameBoard = board       def set_value(self, row, col, value):         self.CurrentGameBoard[row][col] = value          return SudokuBoard(self.BoardSize, self.CurrentGameBoard)   def parse_file(board_string):     BoardSize = int(math.sqrt(len(board_string)))     board = [ [ 0 for i in range(BoardSize) ] for j in range(BoardSize) ]     index = 0     for i in range(BoardSize):         for j in range(BoardSize):             board[i][j] = int(board_string[index])             index += 1     return board  def iscomplete(BoardArray):     size = len(BoardArray)     for row in range(size):         for col in range(size):             if BoardArray[row][col] == 0:                 return False     return True  def checkValid(sb):     BoardArray = sb.CurrentGameBoard     size = len(BoardArray)     subsquare = int(math.sqrt(size))     for row in range(size):         for col in range(size):             if BoardArray[row][col] != 0:                 for i in range(size):                     if ((BoardArray[row][i] == BoardArray[row][col]) and i != col):                         return False                     if ((BoardArray[i][col] == BoardArray[row][col]) and i != row):                         return False                 SquareRow = row // subsquare                 SquareCol = col // subsquare                 for i in range(subsquare):                     for j in range(subsquare):                         si = SquareRow * subsquare + i                          sj = SquareCol * subsquare + j                         if((BoardArray[si][sj] == BoardArray[row][col]) and (si != row) and (sj != col)):                             return False     return True  def solveBoard_recursiveBT(sb):     if iscomplete(sb.CurrentGameBoard):         return sb     else:         BoardArray = sb.CurrentGameBoard         size = len(BoardArray)         for row in range(size):             for col in range(size):                 if BoardArray[row][col] == 0:                     for val in range(1, size + 1):                         if checkValid(sb.set_value(row, col, val)):                             sb = sb.set_value(row, col, val)                             child = solveBoard_recursiveBT(sb)                             if child is not False:                                 return child                     sb = sb.set_value(row, col, 0)                     return False  # main function def main_solution(board_string):     board = parse_file(board_string)     sb = SudokuBoard(len(board), board)     solved_board = solveBoard_recursiveBT(sb)     if solved_board:         return ''.join(map(str, [item for sublist in solved_board.CurrentGameBoard for item in sublist]))     else:         return ""No solution found"""
"Given a binary tree, where each node can have up to two children, what are the values of the nodes that have both a left and a right child? (The input variables are `tree_structure`.)  The input and output requirements are as follows:  Input:   `tree_structure` (dict): A dictionary representing the binary tree structure. Each node is represented as a dictionary with keys 'data' (int), 'left' (dict or None), and 'right' (dict or None).  Output:   `return` (list of int): A list of integers representing the data of the full nodes in the binary tree. A full node is defined as a node that has both left and right children.","import json import random  def input_generator():     def generate_random_tree(depth):         if depth == 0 or random.random() < 0.3:             return None         node = {             'data': random.randint(1, 100),             'left': generate_random_tree(depth - 1),             'right': generate_random_tree(depth - 1)         }         return node          tree_structure = generate_random_tree(random.randint(2, 5))     return {'tree_structure': tree_structure}","# import necessary packages import json  # all class and function definitions in the code file, if any class Node:     def __init__(self, key):         self.data = key          self.left = None         self.right = None  def fullnodes(root, res):     if not root:         return res     if root.left and root.right:         res.append(root.data)     if root.left: fullnodes(root.left, res)     if root.right: fullnodes(root.right, res)     return res  # main function def main_solution(tree_structure):     # Convert the JSON serializable input to the original input variables     root = json_to_tree(tree_structure)          # Call the function that requires non-JSON serializable inputs     res = fullnodes(root, [])          # Convert the result to JSON serializable output     return res  def json_to_tree(tree_structure):     if not tree_structure:         return None     root = Node(tree_structure['data'])     root.left = json_to_tree(tree_structure['left'])     root.right = json_to_tree(tree_structure['right'])     return root"
"Given a prime number `p`, determine if the Mersenne number with exponent `p` is a prime number. What is the result of this determination?  The input and output requirements are as follows:  Input:   `p` (int): The exponent for the Mersenne number, which should be a prime number.  Output:   `return` (dict): A dictionary with a single key `""is_prime""` whose value is a boolean indicating whether the Mersenne number with exponent `p` is prime.","import random  def input_generator():     known_mersenne_exponents = [2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127]     if random.random() < 0.7:         p = random.choice(known_mersenne_exponents)     else:         p = random.randint(2, 128)     return {""p"": p}","# import necessary packages import random  # all class and function definitions in the code file, if any def mersenne_number(p: int):     return 2**p - 1  def lucas_lehmer(p: int):     M = 2**p - 1     ll = []     i = p - 2     n = 4     for number in range(i + 1):         if number > 0:             n = (n**2 - 2) % M         ll.append(n)     return ll  def is_mersenne_prime(p: int):     """"""The Mersenne number is prime if the Lucas-Lehmer series is 0 at position p-2""""""     M = 2**p - 1     ll = []     i = p - 2     n = 4     for number in range(i + 1):         if number > 0:             n = (n**2 - 2) % M         ll.append(n)     return ll[-1] == 0  # main function def main_solution(p: int):     # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)     # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)     result = is_mersenne_prime(p)     # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)     return {""is_prime"": result}"
"Given a neural network with an affine transformation layer, how would the output and gradients of the input, weights, and bias be calculated for a specific set of input data, weight matrix, bias vector, and gradient of the output with respect to the layer's output?  The input and output requirements are as follows:  Input:   `x` (list of lists of floats): A 2D list representing the input matrix `x` with dimensions `(batch_size, n)`.   `W` (list of lists of floats): A 2D list representing the weight matrix `W` with dimensions `(n, m)`.   `b` (list of lists of floats): A 2D list representing the bias matrix `b` with dimensions `(1, m)`.   `doutdy` (list of lists of floats): A 2D list representing the gradient of the output with respect to `y` with dimensions `(batch_size, m)`.  Output:   `return` (dictionary): A dictionary containing the following keys:     - `y` (list of lists of floats): A 2D list representing the output matrix `y` with dimensions `(batch_size, m)`.     - `doutdx` (list of lists of floats): A 2D list representing the gradient of the output with respect to `x` with dimensions `(batch_size, n)`.     - `doutdW` (list of lists of floats): A 2D list representing the gradient of the output with respect to `W` with dimensions `(n, m)`.     - `doutdb` (list of floats): A 1D list representing the gradient of the output with respect to `b` with dimensions `(m,)`.","import numpy as np import random  def input_generator():     batch_size = random.randint(1, 10)     n = random.randint(1, 10)     m = random.randint(1, 10)          x = np.random.rand(batch_size, n).tolist()     W = np.random.rand(n, m).tolist()     b = np.random.rand(1, m).tolist()     doutdy = np.random.rand(batch_size, m).tolist()          return {""x"": x, ""W"": W, ""b"": b, ""doutdy"": doutdy}","# import necessary packages import numpy as np  # all class and function definitions in the code file, if any class AffineLayer:     """"""     forward/backward propagation for Affine transformation: Y = XW + B      In the textbook, `doutdW` and `doutdb` are fields.     """"""      def __init__(self):         self.x = None         self.W = None         self.b = None      def forward(self, x, W, b):         """"""         return y = xW + b          x: (batch_size, n) matrix         W: (n, m) matrix         b: (1, m) matrix. This is NOT (batch_size, m) matrix because bias is common for all data in `x`.         """"""         self.x = x         self.W = W         self.b = b         return np.dot(self.x, self.W) + self.b      def backward(self, doutdy):         """"""         return d(out)/dx, d(out)/dW          d(out)/dx = d(out)/dy * [W]T         d(out)/dW = [x]T * d(out)/dy         d(out)/db = d(out)/dy         ([A]T means the transpose matrix of A.)          doutdy: (batch_size, m) matrix (`batch_size` and `m` must be consistent with those of `forward`.)         """"""         doutdx = np.dot(doutdy, self.W.T)         doutdW = np.dot(self.x.T, doutdy)         doutdb = np.sum(doutdy, axis=0)         return doutdx, doutdW, doutdb  # main function def main_solution(x, W, b, doutdy):     # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)     # convert JSON serializable inputs to numpy arrays     x = np.array(x)     W = np.array(W)     b = np.array(b)     doutdy = np.array(doutdy)      affine_layer = AffineLayer()     y = affine_layer.forward(x, W, b)     doutdx, doutdW, doutdb = affine_layer.backward(doutdy)      # convert numpy arrays to JSON serializable lists     y = y.tolist()     doutdx = doutdx.tolist()     doutdW = doutdW.tolist()     doutdb = doutdb.tolist()      # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)     return {""y"": y, ""doutdx"": doutdx, ""doutdW"": doutdW, ""doutdb"": doutdb}"
"In a nuclear reactor, the heat generated by the fuel needs to be managed to ensure safe operation. Given the parameters of the reactor and the heat pipes, what is the maximum temperature that the fuel can reach at a specified fuel radius?  The input and output requirements are as follows:  Input:   `fuel_radius` (float): The radius of the fuel in centimeters (cm).  Output:   `return` (dict): A dictionary containing the key `max_temperature` with the value being the maximum temperature in Kelvin (K).","import random import math  def input_generator():     # Generate a random fuel radius between 1.1 cm and 5.0 cm     fuel_radius = random.uniform(1.1, 5.0)          return {""fuel_radius"": fuel_radius}","# import necessary packages import math  # Constants pi = math.pi Qdot = 500e3  # 500 KW T_h = 1200  # K APPF = 1.25 RPPF = 1.35 N = 91  # Number of heat pipes L = 42  # cm wallthick = 0.2  # cm kHP = 0.523  # W/cmK rHPo = 1  # cm, wall thickness is 0.2 cm rHPi = rHPo - wallthick kF = 0.3  # W/cmK  # Function definitions def Rf(rF):     return (1 / (2 * pi * kF)) * math.log(rF / rHPo)  def Tfmax(rF):     qprimemax = APPF * RPPF * (Qdot / (N * L))     RHP = (1 / (2 * pi * kHP)) * math.log(rHPo / rHPi)     return T_h + qprimemax * (Rf(rF) + RHP)  # main function def main_solution(fuel_radius):     # Convert input to float     fuel_radius = float(fuel_radius)          # Calculate the maximum temperature     max_temp = Tfmax(fuel_radius)          # Return the result as a dictionary     return {""max_temperature"": max_temp}"
